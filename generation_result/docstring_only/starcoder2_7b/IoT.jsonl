{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t desc_len;\n\tuint8_t desc_type;\n\n\twhile (1) {\n\t\tdesc_len = desc_ptr[0];\n\t\tdesc_type = desc_ptr[1];\n\n\t\tif (desc_type == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\n\t\tif (desc_len == 0) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdesc_ptr += desc_len;\n\t}\n}\n", "CodeBleu_score": 30.584699136568428}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\n\tnext_desc = desc;\n\tdo {\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + next_desc->bLength);\n\t} while ((next_desc->bDescriptorType!= desc_id) && (next_desc->bLength!= 0));\n\n\tif (next_desc->bLength == 0) {\n\t\tnext_desc = NULL;\n\t}\n\n\treturn next_desc;\n}\n", "CodeBleu_score": 30.140041069439526}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t desc_len;\n\n\twhile (desc_ptr < (uint8_t *) desc + desc->bLength) {\n\t\tdesc_len = desc_ptr[0];\n\t\tif (desc_ptr[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\t\tdesc_ptr += desc_len;\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 33.08191513039998}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (udc_config_desc_size == 0) {\n\t\treturn false;\n\t}\n\tif (iface_num >= udc_config_desc_size) {\n\t\treturn false;\n\t}\n\tuint8_t *desc = udc_config_desc;\n\twhile (desc[0]!= USB_DT_INTERFACE) {\n\t\tif (desc[0] == USB_DT_ENDPOINT) {\n\t\t\tdesc += desc[0];\n\t\t} else {\n\t\t\tdesc += desc[1];\n\t\t}\n\t}\n\tdesc += USB_DT_INTERFACE_SIZE;\n\twhile (desc[0]!= USB_DT_INTERFACE) {\n\t\tif (desc[0] == USB_DT_ENDPOINT) {\n\t\t\tdesc += desc[0];\n\t\t} else {\n\t\t\tdesc += desc[1];\n\t\t}\n\t}\n\tif (desc[2] == iface_num && desc[3] == setting_num) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 30.262609718925248}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tuint8_t i;\n\tuint8_t *p;\n\tuint8_t *end;\n\tuint8_t *desc;\n\tuint8_t desc_size;\n\tuint8_t desc_type;\n\tuint8_t desc_index;\n\tuint8_t desc_length;\n\tuint8_t desc_num_endpoints;\n\tuint8_t desc_interface_number;\n\tuint8_t desc_interface_class;\n\tuint8_t desc_interface_subclass;\n\tuint8_t desc_interface_protocol;\n\tuint8_t desc_interface_setting;\n\tuint8_t desc_interface_string_index;\n\tuint8_t desc_interface_string_length;\n\tuint8_t desc_interface_string[USB_STRING_DESCRIPTOR_LENGTH];\n\tuint8_t desc_endpoint_address;\n\tuint8_t desc_endpoint_attributes;\n\tuint8_t desc_endpoint_size;\n\tuint8_t desc_endpoint_interval;\n\tuint8_t desc_endpoint_string_index;\n\tuint8_t desc_endpoint_string_length;\n\tuint8_t desc_endpoint_string[USB_STRING_DESCRIPTOR_LENGTH];\n\n\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_config_desc[0]) {\n\t\treturn false;\n\t}\n\n\tp = (uint8_t *) udc_config_desc;\n\tend = (uint8_t *) udc_config_desc + udc_config_desc[0];\n\n\twhile (p < end) {\n\t\tdesc = p;\n\t\tdesc_size = desc[0];\n\t\tdesc_type = desc[1];\n\t\tdesc_index = desc[2];\n\t\tdesc_length = desc[3];\n\n\t\tswitch (desc_type) {\n\t\tcase USB_DESCRIPTOR_TYPE_INTERFACE:\n\t\t\tif (desc_index == iface_num) {\n\t\t\t\tdesc_interface_number = desc[2];\n\t\t\t\tdesc_interface_class = desc[4];\n\t\t\t\tdesc_interface_subclass = desc[5];\n\t\t\t\tdesc_interface_protocol =", "CodeBleu_score": 26.66083617614159}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tuint8_t i;\n\tuint8_t desc_len;\n\tuint8_t desc_type;\n\tuint8_t desc_subtype;\n\tuint8_t desc_setting_num;\n\tuint8_t desc_iface_num;\n\n\t// Check if there is a valid configuration descriptor\n\tif (!udc_config_desc) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is within bounds\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tfor (i = 0; i < udc_config_desc->wTotalLength; i++) {\n\t\t// Get the descriptor length and type\n\t\tdesc_len = udc_config_desc->data[i];\n\t\tdesc_type = udc_config_desc->data[i + 1];\n\n\t\t// Check if the descriptor is an interface descriptor\n\t\tif (desc_type == USB_DT_INTERFACE) {\n\t\t\t// Get the descriptor subtype and interface number\n\t\t\tdesc_subtype = udc_config_desc->data[i + 2];\n\t\t\tdesc_iface_num = udc_config_desc->data[i + 4];\n\n\t\t\t// Check if the descriptor subtype is an endpoint descriptor\n\t\t\tif (desc_subtype == USB_DT_ENDPOINT) {\n\t\t\t\t// Get the descriptor setting number\n\t\t\t\tdesc_setting_num = udc_config_desc->data[i + 5];\n\n\t\t\t\t// Check if the interface number and setting number match\n\t\t\t\tif (desc_iface_num == iface_num && desc_setting_num == setting_num) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return false if no matching interface descriptor is found\n\treturn false;\n}\n", "CodeBleu_score": 38.2029820244856}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void)\tuint8_t ep_addr = (uint8_t) (g_req_buf[0] & 0x0F);\n\tuint8_t ep_dir = (uint8_t) ((g_req_buf[0] & 0x80) >> 7);\n\tuint8_t ep_type = (uint8_t) ((g_req_buf[0] & 0x60) >> 5);\n\tuint8_t ep_num = (uint8_t) (ep_addr & 0x0F);\n\tuint8_t ep_dir_mask = (uint8_t) (ep_dir << 7);\n\tuint8_t ep_type_mask = (uint8_t) (ep_type << 5);\n\tuint8_t ep_addr_mask = (uint8_t) (ep_num | ep_dir_mask | ep_type_mask);\n\tuint8_t ep_status = 0;\n\tif (g_req_buf[0]!= ep_addr_mask) {\n\t\treturn false;\n\t}\n\tif (ep_dir == 0) {\n\t\tif (ep_num == 0) {\n\t\t\tep_status = (uint8_t) ((g_ep0_status & 0x03) | (g_ep0_stall << 2));\n\t\t} else {\n\t\t\tep_status = (uint8_t) ((g_ep_status[ep_num - 1] & 0x03) | (g_ep_stall[ep_num - 1] << 2));\n\t\t}\n\t} else {\n\t\tif (ep_num == 0) {\n\t\t\tep_status = (uint8_t) ((g_ep0_status & 0x03) | (g_ep0_stall << 2));\n\t\t} else {\n\t\t\tep_status = (uint8_t) ((g_ep_status[ep_num - 1] & 0x03) | (g_ep_stall[ep_num - 1] << 2));\n\t\t}\n\t}\n\tg_resp_buf[0] = ep_status", "CodeBleu_score": 28.38254637097335}, {"code": "static bool udc_req_std_ep_get_status(void)\tuint8_t ep_addr = usb_setup_packet.wIndex & 0x0F;\n\tuint8_t ep_dir = (usb_setup_packet.wIndex & 0x80) >> 7;\n\tuint8_t ep_num = ep_addr & 0x0F;\n\tuint8_t ep_type = (ep_addr & 0x70) >> 4;\n\tuint8_t ep_status = 0;\n\tif (ep_num == 0) {\n\t\tep_status = 0;\n\t} else {\n\t\tif (ep_dir == 0) {\n\t\t\tif (ep_type == 0) {\n\t\t\t\tep_status = usb_ep0_in_halted;\n\t\t\t} else {\n\t\t\t\tep_status = usb_ep0_out_halted;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ep_type == 0) {\n\t\t\t\tep_status = usb_ep0_out_halted;\n\t\t\t} else {\n\t\t\t\tep_status = usb_ep0_in_halted;\n\t\t\t}\n\t\t}\n\t}\n\tif (usb_setup_packet.wLength == sizeof(ep_status)) {\n\t\tusb_ep0_data_buffer[0] = ep_status;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 36.65607101274677}, {"code": "static bool udc_req_std_ep_get_status(void)\tif (req_length!= sizeof(udc_ep_status)) {\n\t\treturn false;\n\t}\n\tudc_ep_status status = 0;\n\tif (req_index & 0x80) {\n\t\tstatus = udc_ep_get_status(req_index & 0x7F);\n\t} else {\n\t\tstatus = udc_ep_get_status(0x80 | req_index);\n\t}\n\tif (status == UDC_EP_HALTED) {\n\t\tstatus = 1;\n\t}\n\tudc_ep_status *p = (udc_ep_status *) req_payload;\n\t*p = status;\n\treturn true;\n}\n", "CodeBleu_score": 50.304798792129056}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void)\tif (usb_dev_state!= USB_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\tif (setup.wIndex!= 0) {\n\t\treturn false;\n\t}\n\t/* Update interface descriptor */\n\tusb_iface_desc.bAlternateSetting = setup.wValue;\n\tusb_iface_desc.bNumEndpoints = 0;\n\tusb_iface_desc.bInterfaceClass = 0;\n\tusb_iface_desc.bInterfaceSubClass = 0;\n\tusb_iface_desc.bInterfaceProtocol = 0;\n\tusb_iface_desc.iInterface = 0;\n\t/* Update alternate setting */\n\tif (!udi_setup_alt_setting()) {\n\t\treturn false;\n\t}\n\t/* Call the UDI setup function */\n\treturn udi_setup();\n}\n", "CodeBleu_score": 32.82776401483881}, {"code": "static bool udc_req_iface(void)\tif (udc_state!= UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\tif (usb_setup.wIndex > 0) {\n\t\treturn false;\n\t}\n\tif (usb_setup.wValue > 1) {\n\t\treturn false;\n\t}\n\tif (usb_setup.wIndex == 0) {\n\t\t/*\n\t\t * The device is in a configured state.\n\t\t * The requested interface number is valid.\n\t\t * Update the interface descriptor to the default setting.\n\t\t */\n\t\tusb_iface_desc.bAlternateSetting = 0;\n\t\tif (usb_iface_desc.bAlternateSetting!= 0) {\n\t\t\treturn false;\n\t\t}\n\t\t/*\n\t\t * Update the interface descriptor to the current alternate setting.\n\t\t */\n\t\tusb_iface_desc.bAlternateSetting = usb_setup.wValue;\n\t\tif (usb_iface_desc.bAlternateSetting!= usb_setup.wValue) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t/*\n\t * Forward the SETUP request to the corresponding USB Device Interface (UDI) handler and return the result of the handler's setup function.\n\t */\n\treturn udc_udi_setup(usb_setup.bmRequestType, usb_setup.bRequest, usb_setup.wValue, usb_setup.wIndex, usb_setup.wLength);\n}\n", "CodeBleu_score": 47.31088924911156}, {"code": "static bool udc_req_iface(void)\tif (usb_dev_state!= CONFIGURED) {\n\t\treturn false;\n\t}\n\tif (usb_setup.wIndex > usb_dev_desc.bNumConfigurations) {\n\t\treturn false;\n\t}\n\tusb_dev_iface = usb_setup.wIndex;\n\tif (usb_dev_iface > usb_dev_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\tif (usb_dev_iface_desc.bAlternateSetting!= usb_setup.wValue) {\n\t\tusb_dev_iface_desc.bAlternateSetting = usb_setup.wValue;\n\t\tif (!udi_set_iface_desc(usb_dev_iface, usb_dev_iface_desc.bAlternateSetting)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (usb_dev_iface_desc.bAlternateSetting > usb_dev_iface_desc.bNumAlternateSettings) {\n\t\treturn false;\n\t}\n\treturn udi_req_iface_setup();\n}\n", "CodeBleu_score": 49.60958408949153}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void)\tudi_msc_cbw_t *cbw;\n\tuint8_t lun;\n\n\t/*\n\t * Retrieve the number of LUNs\n\t */\n\tudi_msc_lun_nb = udi_msc_get_lun();\n\n\tif (udi_msc_lun_nb == 0) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check if the external enable function is implemented\n\t */\n\tif (udi_msc_enable_ext == NULL) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Initialize the MSC interface\n\t */\n\tudi_msc_state = UDI_MSC_STATE_READY;\n\tudi_msc_cbw_state = UDI_MSC_CBW_STATE_IDLE;\n\tudi_msc_data_state = UDI_MSC_DATA_STATE_IDLE;\n\tudi_msc_data_dir = UDI_MSC_DATA_DIR_NONE;\n\tudi_msc_data_len = 0;\n\tudi_msc_data_ptr = NULL;\n\tudi_msc_data_cb = NULL;\n\tudi_msc_cbw_ptr = NULL;\n\tudi_msc_cbw_len = 0;\n\tudi_msc_cbw_cb = NULL;\n\tudi_msc_cbw_tag = 0;\n\tudi_msc_cbw_tag_next = 0;\n\tudi_msc_cbw_tag_last = 0;\n\tudi_msc_cbw_tag_last_lun = 0;\n\tudi_msc_cbw_tag_last_lun_nb = 0;\n\tudi_msc_cbw_tag_last_lun_nb_max = 0;\n\tudi_msc_cbw_tag_last_lun_nb_max_max = 0;\n\tudi_msc_cbw_tag_last_lun_nb_max_max_max = 0;\n\tudi_msc_cbw_tag_last_lun_nb_max_max_max_max = 0;\n\tudi_msc_cbw_tag_last_lun_nb_max_max_max_max_max = 0;\n\tudi_msc_cbw_tag", "CodeBleu_score": 32.91274046464684}, {"code": "bool udi_msc_enable(void)\tudi_msc_lun_t lun;\n\tudi_msc_cbw_t cbw;\n\tudi_msc_cbw_t *cbw_ptr = &cbw;\n\tudi_msc_csw_t csw;\n\tudi_msc_csw_t *csw_ptr = &csw;\n\tudi_msc_cbw_cb_t cbw_cb;\n\tudi_msc_cbw_cb_t *cbw_cb_ptr = &cbw_cb;\n\tudi_msc_scsi_cmd_t scsi_cmd;\n\tudi_msc_scsi_cmd_t *scsi_cmd_ptr = &scsi_cmd;\n\tudi_msc_scsi_cmd_t *scsi_cmd_ptr_tmp;\n\tudi_msc_scsi_cmd_t scsi_cmd_tmp;\n\tudi_msc_scsi_cmd_t *scsi_cmd_ptr_tmp_tmp;\n\tudi_msc_scsi_cmd_t scsi_cmd_tmp_tmp;\n\tudi_msc_scsi_cmd_t scsi_cmd_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t *scsi_cmd_ptr_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t scsi_cmd_tmp_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t *scsi_cmd_ptr_tmp_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t scsi_cmd_tmp_tmp_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t *scsi_cmd_ptr_tmp_tmp_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t scsi_cmd_tmp_tmp_tmp_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t *scsi_cmd_ptr_tmp_tmp_tmp_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t scsi_cmd_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tudi_msc_scsi_cmd_t *scsi_cmd_ptr_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tudi", "CodeBleu_score": 10.264273200359744}, {"code": "bool udi_msc_enable(void)\tudi_msc_cbw_state = UDI_MSC_CBW_STATE_IDLE;\n\tudi_msc_cbw_lun = 0;\n\tudi_msc_cbw_length = 0;\n\tudi_msc_cbw_cb[0] = 0;\n\tudi_msc_cbw_cb[1] = 0;\n\tudi_msc_cbw_cb[2] = 0;\n\tudi_msc_cbw_cb[3] = 0;\n\tudi_msc_cbw_cb[4] = 0;\n\tudi_msc_cbw_cb[5] = 0;\n\tudi_msc_cbw_cb[6] = 0;\n\tudi_msc_cbw_cb[7] = 0;\n\tudi_msc_cbw_cb[8] = 0;\n\tudi_msc_cbw_cb[9] = 0;\n\tudi_msc_cbw_cb[10] = 0;\n\tudi_msc_cbw_cb[11] = 0;\n\tudi_msc_cbw_cb[12] = 0;\n\tudi_msc_cbw_cb[13] = 0;\n\tudi_msc_cbw_cb[14] = 0;\n\tudi_msc_cbw_cb[15] = 0;\n\tudi_msc_cbw_cb[16] = 0;\n\tudi_msc_cbw_cb[17] = 0;\n\tudi_msc_cbw_cb[18] = 0;\n\tudi_msc_cbw_cb[19] = 0;\n\tudi_msc_cbw_cb[20] = 0;\n\tudi_msc_cbw_cb[21] = 0;\n\tudi_msc_cbw_cb[22] = 0;\n\tudi_msc_cbw_cb[23] = 0;\n\tudi_msc_cbw_cb[24] = 0;\n\tudi_msc_cbw_cb[25] = 0;\n\tudi_", "CodeBleu_score": 15.137586639401352}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\t/* Check if transfer is successful */\n\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t/* Wait for MSC setup reset to restart CBW reception */\n\t\tudi_msc_cbw_received();\n\t\treturn;\n\t}\n\n\t/* Update the sense data */\n\tudi_msc_sense_data.sense_data[0] = 0x00;\n\tudi_msc_sense_data.sense_data[1] = 0x00;\n\tudi_msc_sense_data.sense_data[2] = 0x00;\n\tudi_msc_sense_data.sense_data[3] = 0x00;\n\n\t/* Decrease the data residue in the CSW */\n\tudi_msc_cbw.data_residue -= nb_sent;\n\n\t/* Process the updated CSW */\n\tudi_msc_process_csw();\n}\n", "CodeBleu_score": 49.1344572206548}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tudi_msc_status_t *msc_status = udi_msc_get_status();\n\tuint8_t *buf = msc_status->cbw.data;\n\tuint8_t *csw = msc_status->csw.data;\n\tuint32_t residue = msc_status->csw.residue;\n\tuint32_t residue_sent = (uint32_t)nb_sent;\n\n\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t/*\n\t\t * If the transfer is not successful, it waits for a MSC setup reset to restart CBW reception.\n\t\t */\n\t\tudi_msc_set_status(MSC_STATUS_CBW_RECEIVED);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the transfer is successful, it updates the sense data, decreases the data residue in the CSW by the amount of data sent, and processes the updated CSW.\n\t */\n\tif (msc_status->cbw.data_transfer_length!= 0) {\n\t\tif (residue_sent > msc_status->cbw.data_transfer_length) {\n\t\t\tresidue_sent = msc_status->cbw.data_transfer_length;\n\t\t}\n\t\tresidue -= residue_sent;\n\t\tif (residue_sent < msc_status->cbw.data_transfer_length) {\n\t\t\t/*\n\t\t\t * If the amount of data sent is less than the amount of data requested, the transfer is not complete.\n\t\t\t */\n\t\t\tudi_msc_set_status(MSC_STATUS_DATA_RECEIVED);\n\t\t\treturn;\n\t\t}\n\t\tmsc_status->cbw.data_transfer_length = 0;\n\t}\n\tcsw[MSC_CSW_RESIDUE_OFFSET] = (uint8_t)(residue & 0xFF);\n\tcsw[MSC_CSW_RESIDUE_OFFSET + 1] = (uint8_t)((residue >> 8) & 0xFF);\n\tcsw[MSC_CSW_RESIDUE_OFFSET + 2] = (uint8_t)((residue >> 16) & 0xFF);\n\tcsw[MSC_CSW", "CodeBleu_score": 44.09288388222129}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_cbw_reset();\n\t\treturn;\n\t}\n\n\tudi_msc_cbw.dCSWDataResidue -= nb_sent;\n\tudi_msc_cbw.bCSWStatus = UDI_MSC_CSW_CMD_PASSED;\n\tudi_msc_cbw_process();\n}\n", "CodeBleu_score": 55.412865985167294}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void)\tif (udi_msc_csw.residue) {\n\t\tif (udi_msc_csw.dir) {\n\t\t\tudi_msc_stall_ep(udi_msc_csw.dir);\n\t\t} else {\n\t\t\tudi_msc_stall_ep(udi_msc_csw.dir);\n\t\t}\n\t}\n\tudi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_csw.tag = udi_msc_cbw.tag;\n\tudi_msc_csw.residue = udi_msc_cbw.data_length;\n\tudi_msc_csw.status = UDI_MSC_CSW_STATUS_OK;\n\tudi_msc_csw_send();\n}\n", "CodeBleu_score": 48.918333613312626}, {"code": "static void udi_msc_csw_process(void)\t/*\n\t * If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\t */\n\tif (udi_msc_csw.residue) {\n\t\tif (udi_msc_csw.dir == USB_EP_DIR_OUT) {\n\t\t\tudi_msc_csw.dir = USB_EP_DIR_IN;\n\t\t} else {\n\t\t\tudi_msc_csw.dir = USB_EP_DIR_OUT;\n\t\t}\n\t\tudi_msc_csw.residue = 0;\n\t\tudi_msc_csw.status = UDI_MSC_CSW_STATUS_FAILED;\n\t\tudi_msc_csw.tag = udi_msc_cbw.tag;\n\t\tudi_msc_csw.residue = udi_msc_cbw.data_len;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue - udi_msc_cbw.data_len;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue & 0x000000FF;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue << 24;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue | (udi_msc_csw.residue >> 8);\n\t\tudi_msc_csw.residue = udi_msc_csw.residue << 8;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue | (udi_msc_csw.residue >> 24);\n\t\tudi_msc_csw.residue = udi_msc_csw.residue & 0x0000FFFF;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue << 16;\n\t\tudi_msc_csw.residue = udi_msc_csw.residue | (udi_msc_csw.residue >> 16);\n\t\tudi_msc_csw", "CodeBleu_score": 39.067388065523076}, {"code": "static void udi_msc_csw_process(void)\tuint8_t *p_csw;\n\tuint32_t residue;\n\tuint32_t csw_tag;\n\tuint8_t  csw_status;\n\tuint8_t  csw_data_residue[4];\n\tuint8_t  csw_data_residue_le[4];\n\n\tif (udi_msc_cbw.data_transfer_length == 0) {\n\t\t/*\n\t\t * If the data transfer length is zero, the CSW is sent immediately.\n\t\t */\n\t\tudi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n\t\tudi_msc_csw.tag = udi_msc_cbw.tag;\n\t\tudi_msc_csw.data_residue = 0;\n\t\tudi_msc_csw.status = UDI_MSC_CSW_STATUS_OK;\n\n\t\t/*\n\t\t * Send the CSW.\n\t\t */\n\t\tudi_msc_csw_send();\n\t} else {\n\t\t/*\n\t\t * If the data transfer length is non-zero, the CSW is sent after the data transfer.\n\t\t */\n\t\tudi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n\t\tudi_msc_csw.tag = udi_msc_cbw.tag;\n\t\tudi_msc_csw.data_residue = 0;\n\t\tudi_msc_csw.status = UDI_MSC_CSW_STATUS_OK;\n\n\t\t/*\n\t\t * Send the CSW.\n\t\t */\n\t\tudi_msc_csw_send();\n\n\t\t/*\n\t\t * If there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\t\t */\n\t\tif (udi_msc_cbw.data_transfer_length!= 0) {\n\t\t\tif (udi_msc_cbw.data_transfer_direction == UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\t\t/*\n\t\t\t\t * If the direction of the data transfer is IN, stall the next request from the USB host on the IN endpoint.\n\t\t\t\t */\n\t\t\t\tudi_msc_in_ep.status = UDI_MSC_EP_STATUS", "CodeBleu_score": 43.606809583779075}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (b_enable) {\n\t\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.02423100721555}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (b_enable) {\n\t\tif (usb_cdc_dtr_rate_1200[port] == 0) {\n\t\t\tusb_cdc_dtr_rate_1200[port] = 1;\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tif (usb_cdc_dtr_rate_1200[port] == 1) {\n\t\t\tusb_cdc_dtr_rate_1200[port] = 0;\n\t\t\tif (usb_cdc_dtr_rate_1200[0] == 0 && usb_cdc_dtr_rate_1200[1] == 0) {\n\t\t\t\tinitiateReset();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.83103888488092}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (b_enable) {\n\t\t// enable DTR\n\t\tif (port == 0) {\n\t\t\t// port 0\n\t\t\tif (usb_cdc_dtr_status[port] == 0) {\n\t\t\t\tusb_cdc_dtr_status[port] = 1;\n\t\t\t\t// check if DTR rate is 1200\n\t\t\t\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t\t\t\t// schedule delayed reset\n\t\t\t\t\tusb_cdc_reset_scheduled[port] = 1;\n\t\t\t\t\t// initiate reset\n\t\t\t\t\tinitiateReset();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// port 1\n\t\t\tif (usb_cdc_dtr_status[port] == 0) {\n\t\t\t\tusb_cdc_dtr_status[port] = 1;\n\t\t\t\t// check if DTR rate is 1200\n\t\t\t\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t\t\t\t// schedule delayed reset\n\t\t\t\t\tusb_cdc_reset_scheduled[port] = 1;\n\t\t\t\t\t// initiate reset\n\t\t\t\t\tinitiateReset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// disable DTR\n\t\tif (port == 0) {\n\t\t\t// port 0\n\t\t\tif (usb_cdc_dtr_status[port] == 1) {\n\t\t\t\tusb_cdc_dtr_status[port] = 0;\n\t\t\t\t// cancel reset\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t} else {\n\t\t\t// port 1\n\t\t\tif (usb_cdc_dtr_status[port] == 1) {\n\t\t\t\tusb_cdc_dtr_status[port] = 0;\n\t\t\t\t// cancel reset\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.79026886589582}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)\tif (usb_setup.bmRequestType == 0x21) {\n\t\tif (usb_setup.bRequest == 0x04) {\n\t\t\tif (usb_setup.wValue == 0x0100) {\n\t\t\t\tusb_setup.wLength = 12;\n\t\t\t\tusb_setup.wIndex = 0x0409;\n\t\t\t\tusb_setup.wValue = 0x0100;\n\t\t\t\tusb_setup.bRequest = 0x01;\n\t\t\t\tusb_setup.bmRequestType = 0xA1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (usb_setup.bRequest == 0x05) {\n\t\t\tif (usb_setup.wValue == 0x0100) {\n\t\t\t\tusb_setup.wLength = 0x0008;\n\t\t\t\tusb_setup.wIndex = 0x0509;\n\t\t\t\tusb_setup.wValue = 0x0100;\n\t\t\t\tusb_setup.bRequest = 0x01;\n\t\t\t\tusb_setup.bmRequestType = 0xA1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 20.0074650838085}, {"code": "bool usb_task_other_requests(void)\tif (usb_request_type == USB_REQUEST_TYPE_VENDOR) {\n\t\tif (usb_request_index == 0x04) {\n\t\t\t// Vendor-specific request index 0x04\n\t\t\t// This request is used to set up pointers and sizes for Microsoft-compatible ID and extended properties descriptors.\n\t\t\t// The request payload is a pointer to a \"usb_vendor_request_id_t\" structure.\n\t\t\tusb_vendor_request_id_t *request = (usb_vendor_request_id_t *)usb_request_payload;\n\t\t\tif (request->id_type == 0x00) {\n\t\t\t\t// Request ID type 0x00\n\t\t\t\t// This request is used to set up pointers and sizes for Microsoft-compatible ID descriptors.\n\t\t\t\t// The request payload is a pointer to a \"usb_vendor_request_id_microsoft_t\" structure.\n\t\t\t\tusb_vendor_request_id_microsoft_t *microsoft = (usb_vendor_request_id_microsoft_t *)request;\n\t\t\t\tif (microsoft->id_type == 0x00) {\n\t\t\t\t\t// Microsoft-compatible ID descriptor type 0x00\n\t\t\t\t\t// This descriptor is used to identify the device as a Microsoft-compatible device.\n\t\t\t\t\t// The request payload is a pointer to a \"usb_vendor_request_id_microsoft_00_t\" structure.\n\t\t\t\t\tusb_vendor_request_id_microsoft_00_t *microsoft_00 = (usb_vendor_request_id_microsoft_00_t *)microsoft;\n\t\t\t\t\t// Update the control request payload and size accordingly\n\t\t\t\t\tusb_request_payload = (uint8_t *)microsoft_00;\n\t\t\t\t\tusb_request_size = sizeof(usb_vendor_request_id_microsoft_00_t);\n\t\t\t\t\t// Return true to indicate that the request is processed\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (microsoft->id_type == 0x01) {\n\t\t\t\t\t// Microsoft-compatible ID descriptor type 0x01\n\t\t\t\t\t// This descriptor is used to identify the device as a Microsoft-compatible device.\n\t\t\t\t\t// The request payload is a pointer to a \"usb_vendor_request_id_microsoft_01_t\" structure.\n\t\t\t\t\tusb_vendor_request_id_microsoft", "CodeBleu_score": 17.690863365599792}, {"code": "bool usb_task_other_requests(void)\tuint8_t request_index = usb_control_request.wIndex;\n\tuint16_t request_value = usb_control_request.wValue;\n\tuint16_t request_length = usb_control_request.wLength;\n\tuint8_t request_type = usb_control_request.bmRequestType;\n\tuint8_t request_direction = request_type & USB_REQUEST_DIRECTION_MASK;\n\tuint8_t request_type_type = request_type & USB_REQUEST_TYPE_MASK;\n\n\tif (request_index == 0x04) {\n\t\t// Check if the request is a GET_DESCRIPTOR\n\t\tif (request_type_type == USB_REQUEST_TYPE_STANDARD && request_direction == USB_REQUEST_DIRECTION_DEVICE_TO_HOST) {\n\t\t\t// Check if the descriptor type is a string\n\t\t\tif (request_value == USB_DESCRIPTOR_TYPE_STRING) {\n\t\t\t\t// Check if the string index is the Microsoft OS string descriptor index\n\t\t\t\tif (request_value == USB_STRING_ID_MS_OS) {\n\t\t\t\t\t// Set the descriptor pointer to the Microsoft OS string descriptor\n\t\t\t\t\tusb_control_request_payload = (uint8_t *) &usb_string_descriptor_ms_os;\n\t\t\t\t\t// Set the descriptor size to the Microsoft OS string descriptor size\n\t\t\t\t\tusb_control_request_payload_size = sizeof(usb_string_descriptor_ms_os);\n\t\t\t\t}\n\t\t\t\t// Check if the string index is the Microsoft OS Compatible ID string descriptor index\n\t\t\t\telse if (request_value == USB_STRING_ID_MS_OS_COMPATIBLE_ID) {\n\t\t\t\t\t// Set the descriptor pointer to the Microsoft OS Compatible ID string descriptor\n\t\t\t\t\tusb_control_request_payload = (uint8_t *) &usb_string_descriptor_ms_os_compatible_id;\n\t\t\t\t\t// Set the descriptor size to the Microsoft OS Compatible ID string descriptor size\n\t\t\t\t\tusb_control_request_payload_size = sizeof(usb_string_descriptor_ms_os_compatible_id);\n\t\t\t\t}\n\t\t\t\t// Check if the string index is the Microsoft OS Extended Properties string descriptor index\n\t\t\t\telse if (request_value == USB_STRING_ID_MS_OS_EXTENDED_PROPERTIES) {\n\t\t\t\t\t// Set", "CodeBleu_score": 32.46540948231137}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint16_t i;\n\tfor (i = 0; i < nbyte; i++) {\n\t\tSPI0_PUSHR = 0x00;\n\t\twhile (!(SPI0_SR & SPI_SR_RFDF_MASK))\n\t\t\t;\n\t\tbuf[i] = SPI0_POPR;\n\t}\n\tSPI0_PUSHR = 0x00;\n\twhile (!(SPI0_SR & SPI_SR_RFDF_MASK))\n\t\t;\n\tbuf[nbyte] = SPI0_POPR;\n}\n", "CodeBleu_score": 47.94086615862526}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0) return;\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(0x00);\n\t\tbuf[i] = spiRec();\n\t}\n\tspiSend(0x00);\n\tbuf[i] = spiRec();\n}\n", "CodeBleu_score": 46.88847733291014}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif(nbyte == 0) {\n\t\treturn;\n\t}\n\tuint16_t i;\n\tfor(i = 0; i < nbyte; i++) {\n\t\tspiSend(0);\n\t\twhile(!(SPI0_S & SPI_S_SPRF_MASK));\n\t\tbuf[i] = spiRec();\n\t}\n\tspiSend(0);\n\twhile(!(SPI0_S & SPI_S_SPRF_MASK));\n\tbuf[nbyte-1] = spiRec();\n}\n", "CodeBleu_score": 52.50003614633765}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler = NULL;\n\n\t/*\n\t * Disable global interrupts to ensure atomic operation.\n\t */\n\t__disable_irq();\n\n\t/*\n\t * Retrieve the current handler for the specified IRQ.\n\t */\n\toldHandler = (pfnISR_Handler) vtor_relocate_vector_table[irq];\n\n\t/*\n\t * Replace the current handler with the new handler.\n\t */\n\tvtor_relocate_vector_table[irq] = (uint32_t) newHandler;\n\n\t/*\n\t * Enable global interrupts.\n\t */\n\t__enable_irq();\n\n\t/*\n\t * Return the original ISR handler.\n\t */\n\treturn oldHandler;\n}\n", "CodeBleu_score": 50.770617288285045}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler;\n\tuint32_t *pVectorTable;\n\tuint32_t *pVectorTableAddr;\n\tuint32_t *pVectorTableOffset;\n\tuint32_t *pVectorTableOffsetAddr;\n\tuint32_t *pVectorTableOffsetAddr_2;\n\tuint32_t *pVectorTableOffsetAddr_3;\n\tuint32_t *pVectorTableOffsetAddr_4;\n\tuint32_t *pVectorTableOffsetAddr_5;\n\tuint32_t *pVectorTableOffsetAddr_6;\n\tuint32_t *pVectorTableOffsetAddr_7;\n\tuint32_t *pVectorTableOffsetAddr_8;\n\tuint32_t *pVectorTableOffsetAddr_9;\n\tuint32_t *pVectorTableOffsetAddr_10;\n\tuint32_t *pVectorTableOffsetAddr_11;\n\tuint32_t *pVectorTableOffsetAddr_12;\n\tuint32_t *pVectorTableOffsetAddr_13;\n\tuint32_t *pVectorTableOffsetAddr_14;\n\tuint32_t *pVectorTableOffsetAddr_15;\n\tuint32_t *pVectorTableOffsetAddr_16;\n\tuint32_t *pVectorTableOffsetAddr_17;\n\tuint32_t *pVectorTableOffsetAddr_18;\n\tuint32_t *pVectorTableOffsetAddr_19;\n\tuint32_t *pVectorTableOffsetAddr_20;\n\tuint32_t *pVectorTableOffsetAddr_21;\n\tuint32_t *pVectorTableOffsetAddr_22;\n\tuint32_t *pVectorTableOffsetAddr_23;\n\tuint32_t *pVectorTableOffsetAddr_24;\n\tuint32_t *pVectorTableOffsetAddr_25;\n\tuint32_t *pVectorTableOffsetAddr_26;\n\tuint32_t *pVectorTableOffsetAddr_27;\n\tuint32_t *pVectorTableOffsetAddr_28;\n", "CodeBleu_score": 5.615712141628712}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tuint32_t *pVectorTable = (uint32_t *)0x0;\n\tuint32_t *pOriginalHandler;\n\tuint32_t *pNewHandler;\n\n\t__disable_irq();\n\tpVectorTable = (uint32_t *)*(uint32_t *)(0x0);\n\tpOriginalHandler = (uint32_t *)*(uint32_t *)((uint32_t)pVectorTable + (uint32_t)irq * 4);\n\tpNewHandler = (uint32_t *)newHandler;\n\t*(uint32_t *)pOriginalHandler = *(uint32_t *)pNewHandler;\n\t__enable_irq();\n\n\treturn (pfnISR_Handler)pOriginalHandler;\n}\n", "CodeBleu_score": 39.1119017014521}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek()\tif (cdc_enabled) {\n\t\tif (cdc_rx_buffer_in_use) {\n\t\t\tif (cdc_rx_buffer_in == cdc_rx_buffer_out) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn cdc_rx_buffer[cdc_rx_buffer_out];\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n}\n", "CodeBleu_score": 19.467148420581637}, {"code": "int MarlinSerialUSB::peek()\tif (CDC_IsConnected()) {\n\t\tif (CDC_IsRxReady()) {\n\t\t\treturn CDC_ReadChar();\n\t\t}\n\t}\n\treturn -1;\n}\n", "CodeBleu_score": 8.219161437879578}, {"code": "int MarlinSerialUSB::peek()\treturn peek(0);\n}\n", "CodeBleu_score": 12.636155226965101}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read()\tif (pendingChar) {\n\t\tchar c = pendingChar;\n\t\tpendingChar = 0;\n\t\treturn c;\n\t}\n\tif (!enabled ||!configured) return -1;\n\tif (usb_cdc_available()) {\n\t\treturn usb_cdc_read();\n\t}\n\treturn -1;\n}\n", "CodeBleu_score": 30.236639129645315}, {"code": "int MarlinSerialUSB::read()\t// check if there is a pending character\n\tif (pending_char) {\n\t\t// return the pending character\n\t\tint c = pending_char;\n\t\t// reset the pending character\n\t\tpending_char = 0;\n\t\t// return the character\n\t\treturn c;\n\t}\n\n\t// check if the USB CDC is enabled and configured\n\tif (!cdc_enabled ||!cdc_configured) {\n\t\t// return -1\n\t\treturn -1;\n\t}\n\n\t// check if there are any bytes available to read from the PC\n\tif (cdc_available() > 0) {\n\t\t// read the byte\n\t\tint c = cdc_read();\n\t\t// update the emergency parser if enabled\n\t\tif (emergency_parser_enabled) {\n\t\t\temergency_parser.update(c);\n\t\t}\n\t\t// return the read character\n\t\treturn c;\n\t}\n\n\t// return -1\n\treturn -1;\n}\n", "CodeBleu_score": 44.78922762791599}, {"code": "int MarlinSerialUSB::read()#ifdef USB_CDC_ENABLED\n  if (pending_char) {\n    char c = pending_char;\n    pending_char = 0;\n    return c;\n  }\n  if (usb_cdc_enabled) {\n    if (usb_cdc_available()) {\n      char c = usb_cdc_read();\n      if (emergency_parser_enabled) {\n        emergency_parser.parse(c);\n      }\n      return c;\n    }\n  }", "CodeBleu_score": 41.676141283201915}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available()#if USB_CDC_ENABLED == true\n  return (CDC_IsConnected() && CDC_IsReady())? 1 : 0;", "CodeBleu_score": 14.036901018264746}, {"code": "int MarlinSerialUSB::available()\treturn (CDC_IsConnected() && CDC_GetRxBufferSize() > 0)? 1 : 0;\n}\n", "CodeBleu_score": 9.816513495988797}, {"code": "int MarlinSerialUSB::available()\treturn 0;\n}\n", "CodeBleu_score": 4.3663662126463745}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tuint8_t data;\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (!read_data(pos, data, crc)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (writing) {\n\t\t\tvalue[i] = data;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 40.03416754075127}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tuint8_t b;\n\tbool ret = true;\n\twhile (size > 0) {\n\t\tif (!read_data(pos, b)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (writing) {\n\t\t\tif (value!= NULL) {\n\t\t\t\t*value = b;\n\t\t\t\tvalue++;\n\t\t\t}\n\t\t}\n\t\tif (crc!= NULL) {\n\t\t\t*crc = crc16_ccitt_update(*crc, b);\n\t\t}\n\t\tsize--;\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 41.85644669528767}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t byte;\n\t\tif (!read_byte(pos, byte)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (writing) {\n\t\t\t*value++ = byte;\n\t\t}\n\t\tif (crc!= nullptr) {\n\t\t\t*crc = crc16_update(*crc, byte);\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 42.99606332460495}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\tif (pin == 0 || pin > MAX_PIN_NUMBER) {\n\t\treturn;\n\t}\n\tif (freq == 0) {\n\t\treturn;\n\t}\n\tif (res == 0) {\n\t\treturn;\n\t}\n\tif (value > (1 << res) - 1) {\n\t\treturn;\n\t}\n\tif (res > 16) {\n\t\treturn;\n\t}\n\tif (freq > PWM_FREQUENCY) {\n\t\treturn;\n\t}\n\tif (freq < 1000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (res > 16) {\n\t\treturn;\n\t}\n\tif (res < 1) {\n\t\treturn;\n\t}\n\tuint8_t channel = 0;\n\tif (pin < 32) {\n\t\tif (pin < 16) {\n\t\t\tchannel = 0;\n\t\t} else {\n\t\t\tchannel = 1;\n\t\t\tpin -= 16;\n\t\t}\n\t\tif (ledcWrite(channel, pin, value)) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pin < 32) {\n\t\treturn;\n\t}\n\tif (pin < 48) {\n\t\tchannel = 2;\n\t\tpin -= 32;\n\t} else {\n\t\tchannel = 3;\n\t\tpin -= 48;\n\t}\n\tif (ledcWrite(channel, pin, value)) {\n\t\treturn;\n\t}\n\tif (pin < 32) {\n\t\treturn;\n\t}\n\tif (pin < 48) {\n\t\tchannel = 4;\n\t\tpin -= 32;\n\t} else {\n\t\tchannel = 5;\n\t\tpin -= 48;\n\t}\n\tif (ledcWrite(channel, pin, value)) {\n\t\treturn;\n\t}\n\tif (pin < 32) {\n\t\treturn;\n\t}\n\tif (pin < 48) {\n\t\tchannel = 6;\n\t\tpin -= 32;\n\t} else {\n\t", "CodeBleu_score": 28.65492442994908}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\tif (pin >= PIN_COUNT) {\n\t\treturn;\n\t}\n\tif (value > (1 << res) - 1) {\n\t\treturn;\n\t}\n\tif (res > 16) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq == 0) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}\n\tif (freq > 1000000) {\n\t\treturn;\n\t}", "CodeBleu_score": 16.27467733883189}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\tif (pin < 0 || pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\tif (value > (1 << res) - 1) {\n\t\treturn;\n\t}\n\tif (freq > 0) {\n\t\tledcWrite(pin, value);\n\t}\n\telse {\n\t\tif (pin == PWM_PIN_DEFAULT) {\n\t\t\tpwmWrite(value);\n\t\t}\n\t\telse {\n\t\t\tpwmWrite(pin, value);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 25.15264798100563}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value)#if defined(ARDUINO) && (ARDUINO >= 100)\n  if (servo_delay_array_length!= 0) {\n    static_assert(servo_delay_array_length == SERVO_DELAY_ARRAY_LENGTH, \"The servo delay array length must be equal to the number of servos attached.\");\n  }\n  if (servo_attached) {\n    servo.write(value);\n    delay(servo_delay_array[servo_channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      detach();\n    }\n  }", "CodeBleu_score": 44.1478383720867}, {"code": "void Servo::move(const int value)\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH > 0, \"SERVO_DELAY_ARRAY_LENGTH must be greater than 0\");\n\tif (servo.attach(pin)) {\n\t\tservo.write(value);\n\t\tdelay(SERVO_DELAY_ARRAY[channel]);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tservo.detach();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 48.386477015525244}, {"code": "void Servo::move(const int value)\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH does not match SERVO_CHANNEL_COUNT\");\n\n\tif (servo.attach(servoPin, MIN_SERVO_PULSE_WIDTH, MAX_SERVO_PULSE_WIDTH)) {\n\t\tservo.write(value);\n\t\tdelay(SERVO_DELAY_ARRAY[servoPin]);\n\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tservo.detach();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.85098925540578}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample()\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tif (i2s_pins[i].active) {\n\t\t\tif (i2s_pins[i].tick_count == 0) {\n\t\t\t\ti2s_pins[i].tick_count = i2s_pins[i].tick_count_max;\n\t\t\t\tif (i2s_pins[i].state) {\n\t\t\t\t\ti2s_pins[i].state = 0;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pins[i].state = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti2s_pins[i].tick_count--;\n\t\t}\n\t}\n\n\tuint8_t data = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tdata |= i2s_pins[i].state << i;\n\t}\n\ti2s_buffer[i2s_buffer_pos++] = data;\n\n\tif (i2s_buffer_pos == I2S_BUFFER_SIZE) {\n\t\ti2s_buffer_pos = 0;\n\t\ti2s_dma_buffer_full = 1;\n\t}\n}\n", "CodeBleu_score": 35.71410845470906}, {"code": "void i2s_push_sample()\tuint32_t i;\n\tuint32_t sample;\n\n\tfor (i = 0; i < I2S_PIN_COUNT; i++) {\n\t\tif (i2s_pins[i].pwm_active) {\n\t\t\ti2s_pins[i].pwm_tick_count--;\n\t\t\tif (i2s_pins[i].pwm_tick_count == 0) {\n\t\t\t\ti2s_pins[i].pwm_tick_count = i2s_pins[i].pwm_period;\n\t\t\t\ti2s_pins[i].pwm_state =!i2s_pins[i].pwm_state;\n\t\t\t}\n\t\t}\n\t}\n\n\tsample = 0;\n\tfor (i = 0; i < I2S_PIN_COUNT; i++) {\n\t\tif (i2s_pins[i].pwm_active) {\n\t\t\tsample |= (i2s_pins[i].pwm_state << i);\n\t\t}\n\t}\n\n\ti2s_buffer[i2s_buffer_pos++] = sample;\n}\n", "CodeBleu_score": 30.34489859759684}, {"code": "void i2s_push_sample()\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tif (i2s_pins[i].pwm_active) {\n\t\t\tif (i2s_pins[i].pwm_tick_count == 0) {\n\t\t\t\ti2s_pins[i].pwm_tick_count = i2s_pins[i].pwm_tick_count_max;\n\t\t\t\tif (i2s_pins[i].pwm_state) {\n\t\t\t\t\ti2s_pins[i].pwm_state = 0;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pins[i].pwm_state = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ti2s_pins[i].pwm_tick_count--;\n\t\t\t}\n\t\t}\n\t}\n\ti2s_buffer[i2s_buffer_pos] = i2s_port;\n\ti2s_buffer_pos++;\n\tif (i2s_buffer_pos == I2S_BUFFER_SIZE) {\n\t\ti2s_buffer_pos = 0;\n\t}\n}\n", "CodeBleu_score": 33.14395185201971}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\treturn hal_timer_get_count(timer_num);\n}\n", "CodeBleu_score": 13.73194225950237}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\thal_timer_t timer_count;\n\tuint32_t timer_config = TIMER_CONFIG_REG(timer_num);\n\tuint32_t timer_count_reg = TIMER_COUNT_REG(timer_num);\n\ttimer_count.timer_num = timer_num;\n\ttimer_count.timer_count_reg = timer_count_reg;\n\ttimer_count.timer_config_reg = timer_config;\n\ttimer_count.timer_config = timer_config;\n\treturn timer_count;\n}\n", "CodeBleu_score": 42.03131239655198}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\thal_timer_t count;\n\tuint32_t timer_base;\n\tuint32_t timer_cfg;\n\tuint32_t timer_count;\n\n\ttimer_base = (uint32_t) timer_num * 0x1000;\n\ttimer_cfg = timer_base + 0x00;\n\ttimer_count = timer_base + 0x04;\n\n\t// check if timer is enabled\n\tif ((*(volatile uint32_t *) timer_cfg) & 0x00000001) {\n\t\tcount = *(volatile uint32_t *) timer_count;\n\t} else {\n\t\tcount = 0;\n\t}\n\n\treturn count;\n}\n", "CodeBleu_score": 40.47619858779742}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos + i);\n\t\tif (crc!= NULL) {\n\t\t\t*crc = crc16_update(*crc, value[i]);\n\t\t}\n\t\tif (writing) {\n\t\t\tEEPROM.write(pos + i, value[i]);\n\t\t}\n\t}\n\tpos += size;\n\treturn true;\n}\n", "CodeBleu_score": 61.26535440005307}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t v = EEPROM.read(pos);\n\t\tif (writing) {\n\t\t\tvalue[i] = v;\n\t\t}\n\t\t*crc = crc16_update(*crc, v);\n\t\tpos++;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 61.2057871065389}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tuint8_t *buf = nullptr;\n\tif (writing) {\n\t\tbuf = value;\n\t}\n\n\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t b = EEPROM.read(pos);\n\t\tif (writing) {\n\t\t\t*buf++ = b;\n\t\t}\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, b);\n\t\t}\n\t\tpos++;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 53.22908410540887}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tuint32_t retries = 0;\n\tuint32_t status;\n\tbool result = false;\n\tdo {\n\t\tstatus = SDIO_WriteBlock(block, src);\n\t\tif (status == SD_OK) {\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\tretries++;\n\t} while (retries < SD_MAX_RETRIES);\n\tif (retries == SD_MAX_RETRIES) {\n\t\tprintf(\"Failed to write block %d\\n\", block);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 35.692313795584504}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (SDIOHandle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tbool success = false;\n\n\tfor (int i = 0; i < SDIO_MAX_RETRIES; i++) {\n\t\tif (HAL_SDIO_WriteBlocks(SDIOHandle, (uint8_t *)src, block, 1, 1000) == HAL_OK) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!success) {\n\t\tprintf(\"Error: SDIO write failed\\n\");\n\t}\n\n\treturn success;\n}\n", "CodeBleu_score": 36.35663043792531}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tuint32_t retry = 0;\n\tuint32_t status = 0;\n\tuint32_t error = 0;\n\tbool success = false;\n\tif (block == 0) {\n\t\treturn false;\n\t}\n\tif (src == NULL) {\n\t\treturn false;\n\t}\n\twhile (retry < SDIO_MAX_RETRIES) {\n\t\tstatus = HAL_SDIO_WriteBlock(hsd, src, block, SDIO_TIMEOUT);\n\t\tif (status!= HAL_OK) {\n\t\t\terror = HAL_SDIO_GetError(hsd);\n\t\t\tif (error == HAL_SDIO_ERROR_CMD) {\n\t\t\t\tSDIO_Reset();\n\t\t\t\tretry++;\n\t\t\t} else {\n\t\t\t\tprintf(\"SDIO_WriteBlock: HAL_SDIO_WriteBlock failed with error %u\\n\", error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retry == SDIO_MAX_RETRIES) {\n\t\tprintf(\"SDIO_WriteBlock: HAL_SDIO_WriteBlock failed after %u retries\\n\", retry);\n\t}\n\treturn success;\n}\n", "CodeBleu_score": 40.1217724235065}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\tif (timer_num == TEMPERATURE_TIMER) {\n\t\t// Set the timer frequency\n\t\tTIMER_SetPrescale(TEMPERATURE_TIMER_BASE, TEMPERATURE_TIMER_PRESCALE);\n\t\tTIMER_SetPrescale(STEPPER_TIMER_BASE, STEPPER_TIMER_PRESCALE);\n\t\tTIMER_SetLoad(TEMPERATURE_TIMER_BASE, TIMER_FREQ_TO_COUNT(frequency, TEMPERATURE_TIMER_PRESCALE));\n\t\tTIMER_SetLoad(STEPPER_TIMER_BASE, TIMER_FREQ_TO_COUNT(frequency, STEPPER_TIMER_PRESCALE));\n\t\t// Start the timer\n\t\tTIMER_Start(TEMPERATURE_TIMER_BASE);\n\t\tTIMER_Start(STEPPER_TIMER_BASE);\n\t\t// Set the callback priority\n\t\tNVIC_SetPriority(TEMPERATURE_TIMER_IRQ, TEMPERATURE_TIMER_IRQ_PRIORITY);\n\t\tNVIC_SetPriority(STEPPER_TIMER_IRQ, STEPPER_TIMER_IRQ_PRIORITY);\n\t\t// Enable the timer interrupt\n\t\tNVIC_EnableIRQ(TEMPERATURE_TIMER_IRQ);\n\t\tNVIC_EnableIRQ(STEPPER_TIMER_IRQ);\n\t} else if (timer_num == STEPPER_TIMER) {\n\t\t// Set the timer frequency\n\t\tTIMER_SetPrescale(TEMPERATURE_TIMER_BASE, TEMPERATURE_TIMER_PRESCALE);\n\t\tTIMER_SetPrescale(STEPPER_TIMER_BASE, STEPPER_TIMER_PRESCALE);\n\t\tTIMER_SetLoad(TEMPERATURE_TIMER_BASE, TIMER_FREQ_TO_COUNT(frequency, TEMPERATURE_TIMER_PRESCALE));\n\t\tTIMER_SetLoad(STEPPER_TIMER_BASE, TIMER_FREQ_TO_COUNT(frequency, STEPPER_TIMER_PRESCALE));\n\t\t// Start the timer\n\t\tTIMER_Start(TEMPERATURE_TIMER_BASE);\n\t\tTIMER_Start(STEPPER_TIMER_BASE);\n\t\t// Set the callback priority\n\t\tNVIC_SetPriority(TEMPERATURE_TIMER_IRQ, TEMPERATURE_TIMER_IRQ_PRIORITY);\n\t\tNVIC_SetPriority(STEPPER_TIMER_IRQ, STEPPER_TIMER_IRQ_PRIORITY);\n\t\t// Enable the timer interrupt\n\t\tNVIC_EnableIRQ(TEMPERATURE_TIMER_IRQ", "CodeBleu_score": 36.10818013750078}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\t// Check if timer_num is valid\n\tassert(timer_num < TIMER_CHANNEL_COUNT);\n\n\t// Check if the timer is already started\n\tif (HAL_timer_is_started(timer_num)) {\n\t\t// Timer is already started\n\t\treturn;\n\t}\n\n\t// Start timer\n\tif (timer_num == TEMPERATURE_TIMER_CHANNEL) {\n\t\t// Start temperature timer\n\t\tHAL_timer_start_temperature(frequency);\n\t} else if (timer_num == STEPPER_TIMER_CHANNEL) {\n\t\t// Start stepper timer\n\t\tHAL_timer_start_stepper(frequency);\n\t} else {\n\t\t// Timer is invalid\n\t\tassert(0);\n\t}\n}\n", "CodeBleu_score": 35.90438959768114}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\tswitch (timer_num) {\n\tcase TIMER_TEMPERATURE:\n\t\tTIMER_SetPrescale(TIMER_TEMPERATURE, (uint32_t) (TIMER_FREQUENCY / frequency));\n\t\tTIMER_Start(TIMER_TEMPERATURE);\n\t\tNVIC_SetPriority(TIMER_TEMPERATURE_IRQn, TIMER_TEMPERATURE_PRIORITY);\n\t\tNVIC_EnableIRQ(TIMER_TEMPERATURE_IRQn);\n\t\tbreak;\n\tcase TIMER_STEPPER:\n\t\tTIMER_SetPrescale(TIMER_STEPPER, (uint32_t) (TIMER_FREQUENCY / frequency));\n\t\tTIMER_Start(TIMER_STEPPER);\n\t\tNVIC_SetPriority(TIMER_STEPPER_IRQn, TIMER_STEPPER_PRIORITY);\n\t\tNVIC_EnableIRQ(TIMER_STEPPER_IRQn);\n\t\tbreak;\n\tdefault:\n\t\tassert_param(false);\n\t\tbreak;\n\t}\n}\n", "CodeBleu_score": 31.047063311606205}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start()\tif (file.open(filename, O_RDWR | O_CREAT)) {\n\t\tif (file.size() < EEPROM_SIZE) {\n\t\t\tfor (int i = file.size(); i < EEPROM_SIZE; i++) {\n\t\t\t\tbuffer[i] = EEPROM_ERASE_VALUE;\n\t\t\t}\n\t\t}\n\t\tfile.read(buffer, EEPROM_SIZE);\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 20.143823643022575}, {"code": "bool PersistentStore::access_start()\t// Open the EEPROM file in read-only mode.\n\tif (!eeprom_file.open(EEPROM_FILENAME, O_RDONLY)) {\n\t\treturn false;\n\t}\n\n\t// Get the file size.\n\tif (!eeprom_file.getSize(eeprom_file_size)) {\n\t\treturn false;\n\t}\n\n\t// If the file is smaller than the expected EEPROM size, fill the remainder of the buffer with a default erase value.\n\tif (eeprom_file_size < EEPROM_SIZE) {\n\t\tmemset(eeprom_buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t}\n\n\t// Read the file's contents into the buffer.\n\tif (!eeprom_file.read(eeprom_buffer, eeprom_file_size)) {\n\t\treturn false;\n\t}\n\n\t// Close the file.\n\tif (!eeprom_file.close()) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 28.098093506690986}, {"code": "bool PersistentStore::access_start()\t// Open the EEPROM file\n\tif (!eeprom_file.open(eeprom_filename, O_RDWR | O_CREAT)) {\n\t\treturn false;\n\t}\n\n\t// Initialize the buffer\n\tbuffer.clear();\n\tbuffer.resize(eeprom_size);\n\n\t// Check the file size\n\tif (eeprom_file.size() < eeprom_size) {\n\t\t// Fill the remainder of the buffer with the default erase value\n\t\tfor (uint32_t i = eeprom_file.size(); i < eeprom_size; i++) {\n\t\t\tbuffer[i] = erase_value;\n\t\t}\n\t}\n\n\t// Read the file's contents into the buffer\n\tif (eeprom_file.size() == eeprom_size) {\n\t\teeprom_file.read(buffer.data(), eeprom_size);\n\t}\n\n\t// Close the EEPROM file\n\teeprom_file.close();\n\n\treturn true;\n}\n", "CodeBleu_score": 31.472237537948832}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t rx = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_STM32_MOSI_GPIO_Port, SPI_STM32_MOSI_Pin, (b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_STM32_CLK_GPIO_Port, SPI_STM32_CLK_Pin, GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(SPI_STM32_CLK_GPIO_Port, SPI_STM32_CLK_Pin, GPIO_PIN_RESET);\n\t\trx = rx << 1;\n\t\trx = rx | HAL_GPIO_ReadPin(SPI_STM32_MISO_GPIO_Port, SPI_STM32_MISO_Pin);\n\t\tb = b << 1;\n\t}\n\treturn rx;\n}\n", "CodeBleu_score": 35.71514505412413}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i, d = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, b & 0x80);\n\t\tHAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);\n\t\td = (d << 1) | (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) & 0x01);\n\t\tHAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);\n\t\tb = b << 1;\n\t}\n\tHAL_Delay(1);\n\treturn d;\n}\n", "CodeBleu_score": 38.368470307605804}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i, d = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_STM32_PORT_CLK, SPI_STM32_PIN_CLK, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_STM32_PORT_MOSI, SPI_STM32_PIN_MOSI, (b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tb <<= 1;\n\t\tHAL_GPIO_WritePin(SPI_STM32_PORT_CLK, SPI_STM32_PIN_CLK, GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(SPI_STM32_PORT_CLK, SPI_STM32_PIN_CLK, GPIO_PIN_RESET);\n\t\td <<= 1;\n\t\td |= HAL_GPIO_ReadPin(SPI_STM32_PORT_MISO, SPI_STM32_PIN_MISO)? 1 : 0;\n\t}\n\tHAL_Delay(SPI_STM32_DELAY);\n\treturn d;\n}\n", "CodeBleu_score": 36.3288651495148}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 73.71358658894387}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 75.26335500508152}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\tRCC_ClocksTypeDef RCC_ClocksStatus;\n\tuint32_t tmp = 0;\n\tuint32_t tmpreg = 0;\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\t/* Get the AHB peripheral clocks enable bit status */\n\ttmp = RCC->AHBENR;\n\n\t/* Get the current clock configuration */\n\tRCC_GetClocksFreq(&RCC_ClocksStatus);\n\n\t/* Set the bit field of the corresponding AHB peripheral clock enable bit in the RCC_AHBENR register */\n\tif (NewState!= DISABLE) {\n\t\ttmp |= RCC_AHBPeriph;\n\t} else {\n\t\ttmp &= ~RCC_AHBPeriph;\n\t}\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmpreg));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(tmp));\n\n\t/* Check the parameters */\n\tassert_param(IS", "CodeBleu_score": 49.94954417008719}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)\tuint8_t c = obj->s_rbr;\n\tif (c & _PARITY_ERROR) {\n\t\t// Parity error, ignore byte\n\t\treturn;\n\t}\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\t// There is space in the receive buffer, store the byte\n\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_BUFFER_SIZE;\n\t}\n\tif (obj->rx_emergency_parser!= NULL) {\n\t\t// Update the emergency parser with the received byte\n\t\tobj->rx_emergency_parser->update(c);\n\t}\n}\n", "CodeBleu_score": 40.49605774749301}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)\tuint8_t c = obj->rx_buffer[obj->rx_buffer_head];\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head >= SERIAL_RX_BUFFER_SIZE) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t} else {\n\t\t\tobj->rx_buffer_head++;\n\t\t}\n\t}\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head >= SERIAL_RX_BUFFER_SIZE) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t}\n\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\t\tif (obj->rx_buffer_head == obj->rx_buffer_tail) {\n\t\t\tobj->rx_buffer_tail++;\n\t\t\tif (obj->rx_buffer_tail >= SERIAL_RX_BUFFER_SIZE) {\n\t\t\t\tobj->rx_buffer_tail = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head >= SERIAL_RX_BUFFER_SIZE) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t} else {\n\t\t\tobj->rx_buffer_head++;\n\t\t}\n\t}\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head >= SERIAL_RX_BUFFER_SIZE) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t} else {\n\t\t\tobj->rx_buffer_head++;\n\t\t}\n\t}\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head >= SERIAL_RX_BUFFER_SIZE) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t} else {\n\t\t\tobj->rx_buffer_head++;\n\t\t}\n\t}\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head >= SERIAL_RX", "CodeBleu_score": 32.08399781619179}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)\tuint8_t c = obj->rbr;\n\tif (obj->lcr & SERIAL_LCR_PARITY_MASK) {\n\t\tif (c & SERIAL_LCR_PARITY_MASK) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (obj->rbr == '\\r') {\n\t\tc = '\\n';\n\t}\n\tif (obj->rbr == '\\n') {\n\t\tc = '\\r';\n\t}\n\tif (obj->rbr == '\\r' || obj->rbr == '\\n') {\n\t\tobj->rx_complete_flag = true;\n\t\treturn;\n\t}\n\tif (obj->rx_buffer_head < obj->rx_buffer_tail) {\n\t\tobj->rx_buffer[obj->rx_buffer_head++] = c;\n\t\tif (obj->rx_buffer_head == RX_BUFFER_SIZE) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.50245465372831}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tif (timer_num == MF_TIMER_STEP) {\n\t\tHAL_NVIC_EnableIRQ(TIMER0_IRQn);\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tHAL_NVIC_EnableIRQ(TIMER1_IRQn);\n\t}\n}\n", "CodeBleu_score": 22.84892127962134}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\t// Check if the timer is initialized\n\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (step_timer_initialized == 1) {\n\t\t\t// Check if the timer does not already have an interrupt attached\n\t\t\tif (step_timer_interrupt_attached == 0) {\n\t\t\t\t// Attach the interrupt handler\n\t\t\t\tHAL_interrupt_attach_handler(HAL_INTERRUPT_TIMER_STEP, Step_Handler);\n\t\t\t\t// Set the interrupt flag\n\t\t\t\tstep_timer_interrupt_attached = 1;\n\t\t\t}\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (temp_timer_initialized == 1) {\n\t\t\t// Check if the timer does not already have an interrupt attached\n\t\t\tif (temp_timer_interrupt_attached == 0) {\n\t\t\t\t// Attach the interrupt handler\n\t\t\t\tHAL_interrupt_attach_handler(HAL_INTERRUPT_TIMER_TEMP, Temp_Handler);\n\t\t\t\t// Set the interrupt flag\n\t\t\t\ttemp_timer_interrupt_attached = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 28.055580220480902}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tif (timer_num == MF_TIMER_STEP) {\n\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t}\n}\n", "CodeBleu_score": 30.89209065540144}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\treturn LastIndexRabinKarpHash[T](s, sep)\n}\n", "CodeBleu_score": 9.665178476397063}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\treturn rabinKarpLastIndex(s, sep, 0, len(s)-1, 0, len(sep)-1, rabinKarpHash(sep))\n}\n", "CodeBleu_score": 7.675056106567533}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\t// If the separator is empty, return the length of the string\n\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\n\t// Calculate the hash of the separator\n\tsepHash := hash(sep)\n\n\t// Calculate the hash of the last n characters of the string, where n is the length of the separator\n\tlastNHash := hash(s[len(s)-len(sep):])\n\n\t// Iterate through the string from the end towards the beginning\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\t// Calculate the hash of the next n characters of the string, where n is the length of the separator\n\t\tnextNHash := hash(s[i:i+len(sep)])\n\n\t\t// Check if the hash of the next n characters matches the hash of the separator\n\t\tif nextNHash == sepHash {\n\t\t\t// Check if the actual substring matches\n\t\t\tif string(s[i:i+len(sep)]) == string(sep) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\t// Check if the hash of the next n characters matches the hash of the last n characters of the string\n\t\tif nextNHash == lastNHash {\n\t\t\t// Check if the actual substring matches\n\t\t\tif string(s[i:i+len(sep)]) == string(sep) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no match is found, return -1\n\treturn -1\n}\n", "CodeBleu_score": 40.36768654941858}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush()\t// Disable interrupts\n\tinterrupts := DisableInterrupts()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.waitTxc {\n\t\t// If there is, send it to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t\t// Set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore interrupt mask\n\tRestoreInterrupts(interrupts)\n}\n", "CodeBleu_score": 35.1248580042901}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.waitTxc = false\n\tif usbcdc.txc!= nil {\n\t\tusbcdc.txc.Lock()\n\t\tif usbcdc.txc.len() > 0 {\n\t\t\tusbcdc.SendUSBInPacket(usbcdc.txc.data)\n\t\t}\n\t\tusbcdc.txc.Unlock()\n\t}\n}\n", "CodeBleu_score": 24.506230894525842}, {"code": "func (usbcdc *USBCDC) Flush()\t// Disable interrupts\n\tusbcdc.DisableIRQ()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txc!= 0 {\n\t\t// Send it to the USB endpoint\n\t\tusbcdc.SendUSBInPacket(usbcdc.txc)\n\t\t// Set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t} else {\n\t\t// Set \"waitTxc\" to true\n\t\tusbcdc.waitTxc = true\n\t}\n\t// Restore interrupt mask\n\tusbcdc.EnableIRQ()\n}\n", "CodeBleu_score": 35.8041633042963}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.clearInterruptFlag()\n\ti2c.setStartCondition()\n\ti2c.enable()\n\ti2c.waitForStartCondition()\n\ti2c.writeAddress(address, write)\n}\n", "CodeBleu_score": 23.394146165592616}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.I2C.CR1.SetBits(i2c.CR1.Bits() & ^(1 << 15)) // clear interrupt flag\n\ti2c.I2C.CR1.SetBits(i2c.CR1.Bits() | (1 << 8))   // send start condition\n\ti2c.I2C.CR1.SetBits(i2c.CR1.Bits() | (1 << 0))   // enable I2C module\n\n\tfor!i2c.I2C.SR1.Bits().Get(9) { // wait for start condition to be transmitted\n\t}\n\n\ti2c.I2C.DR.Set(uint16(address << 1) | uint16(write))\n}\n", "CodeBleu_score": 28.445572109988763}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.control = 0\n\ti2c.control |= I2C_CR_START\n\ti2c.control |= I2C_CR_ENABLE\n\ti2c.data = address << 1\n\tif!write {\n\t\ti2c.data |= 1\n\t}\n}\n", "CodeBleu_score": 28.145760706599166}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"start or len is negative\")\n\t}\n\t// Calculate the start address based on the block number and block size\n\tstartAddr := start * f.blockSize\n\t// Wait for any ongoing flash operations to complete\n\tf.flash.WaitForBusy()\n\t// Configure the flash for erasing\n\tf.flash.Erase(startAddr, len)\n\t// Wait until the flash is no longer busy\n\tfor f.flash.IsBusy() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\t// Set the flash back to read mode\n\tf.flash.Read()\n\treturn nil\n}\n", "CodeBleu_score": 26.007265244976637}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tf.flash.ConfigureForErase()\n\tfor i := start; i < start+len; i++ {\n\t\tf.flash.EraseBlock(i)\n\t\tfor f.flash.IsBusy() {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t}\n\t}\n\tf.flash.ConfigureForRead()\n\treturn nil\n}\n", "CodeBleu_score": 34.854760157429915}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tf.flash.Unlock()\n\tf.flash.Lock()\n\tdefer f.flash.Unlock()\n\n\tif start+len > f.flash.Size() {\n\t\treturn errors.New(\"EraseBlocks: invalid range\")\n\t}\n\n\tstartAddr := start * int64(f.blockSize)\n\tendAddr := startAddr + (len * int64(f.blockSize)) - 1\n\n\tfor addr := startAddr; addr <= endAddr; addr += int64(f.blockSize) {\n\t\tf.flash.EraseBlock(addr)\n\t\tfor f.flash.Busy() {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}\n\n\tf.flash.Unlock()\n\tf.flash.Lock()\n\tf.flash.SetReadMode()\n\treturn nil\n}\n", "CodeBleu_score": 35.93627784574306}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"WriteAt: offset exceeds flash memory bounds\")\n\t}\n\tif f.writeBlockSize > 0 {\n\t\tif len(p)%f.writeBlockSize!= 0 {\n\t\t\tp = append(p, make([]byte, f.writeBlockSize-len(p)%f.writeBlockSize)...)\n\t\t}\n\t}\n\tstartAddress := f.startAddress + uint32(off)\n\tf.flashMemoryController.WriteEnable()\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\tif err := f.flashMemoryController.Write(startAddress+uint32(i), p[i:i+f.writeBlockSize]); err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 34.27192333671586}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\t// Check if the write operation exceeds the flash memory bounds\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"write operation exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddress := off + f.BaseAddress\n\t// Pad the byte slice to fit the write block size\n\tpaddedBytes := make([]byte, len(p))\n\tcopy(paddedBytes, p)\n\n\t// Enable write mode on the flash memory controller\n\tf.controller.EnableWrite()\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(paddedBytes); i += f.BlockSize {\n\t\t// Calculate the block offset\n\t\tblockOffset := i / f.BlockSize\n\n\t\t// Calculate the block start address\n\t\tblockStartAddress := startAddress + int64(blockOffset*f.BlockSize)\n\n\t\t// Calculate the block size\n\t\tblockSize := f.BlockSize\n\t\tif blockSize > len(paddedBytes)-i {\n\t\t\tblockSize = len(paddedBytes) - i\n\t\t}\n\n\t\t// Write the block\n\t\terr := f.controller.WriteBlock(blockStartAddress, paddedBytes[i:i+blockSize])\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Wait for the flash memory to be ready\n\t\terr = f.controller.WaitUntilReady()\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}\n", "CodeBleu_score": 30.779749701589136}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off > f.Size() {\n\t\treturn 0, fmt.Errorf(\"offset %d exceeds flash memory size %d\", off, f.Size())\n\t}\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, fmt.Errorf(\"offset %d and length %d exceed flash memory size %d\", off, len(p), f.Size())\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddr := off\n\tif startAddr%f.BlockSize!= 0 {\n\t\tstartAddr = (startAddr/f.BlockSize + 1) * f.BlockSize\n\t}\n\n\t// Pad the byte slice to fit the write block size\n\tif startAddr+int64(len(p)) > f.Size() {\n\t\tp = append(p, make([]byte, startAddr+int64(len(p))-f.Size())...)\n\t}\n\n\t// Enable write mode on the flash memory controller\n\tf.WriteEnable()\n\n\t// Write the data in blocks\n\tfor i := startAddr; i < startAddr+int64(len(p)); i += int64(f.BlockSize) {\n\t\t// Calculate the block offset and size\n\t\tblockOffset := i - startAddr\n\t\tblockSize := f.BlockSize\n\t\tif i+int64(f.BlockSize) > startAddr+int64(len(p)) {\n\t\t\tblockSize = startAddr + int64(len(p)) - i\n\t\t}\n\n\t\t// Write the block\n\t\terr = f.WriteBlock(p[blockOffset:blockOffset+blockSize], i)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Wait for the flash memory to be ready after each write operation\n\tfor i := startAddr; i < startAddr+int64(len(p)); i += int64(f.BlockSize) {\n\t\terr = f.WaitReady()\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\treturn len(p), nil\n}\n", "CodeBleu_score": 31.32995159327443}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor.\n\tfdCopy, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, err.Error(), err\n\t}\n\t// Close the original file descriptor.\n\terr = syscall.Close(int(fd))\n\tif err!= nil {\n\t\treturn 0, err.Error(), err\n\t}\n\t// Attempt to open the directory.\n\tdirPtr, err := syscall.Fdopendir(fdCopy)\n\tif err!= nil {\n\t\t// Close the duplicated file descriptor.\n\t\terr = syscall.Close(fdCopy)\n\t\tif err!= nil {\n\t\t\treturn 0, err.Error(), err\n\t\t}\n\t\treturn 0, err.Error(), err\n\t}\n\t// Return the directory pointer.\n\treturn dirPtr, \"\", nil\n}\n", "CodeBleu_score": 43.566411562957974}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tvar dirp uintptr\n\tvar err error\n\tfor {\n\t\tdirp, err = syscall.Fdopendir(fd)\n\t\tif err!= nil {\n\t\t\tif err!= syscall.EINTR {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err!= nil {\n\t\tsyscall.Close(fd)\n\t}\n\treturn dirp, \"\", err\n}\n", "CodeBleu_score": 42.143743630793644}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tfor {\n\t\tdir, err := syscall.Fdopendir(fd)\n\t\tif err!= nil {\n\t\t\tif err!= syscall.EINTR {\n\t\t\t\t_ = syscall.Close(fd)\n\t\t\t\treturn 0, err.Error(), err\n\t\t\t}\n\t\t} else {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.45979586269243}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response)\tuint32_t size = 0;\n\tif (response) {\n\t\tESP_IMAGE_HEADER_P header = esp_image_get_header();\n\t\tsize = header->partition_info.maximum_size - header->partition_info.minimum_free_size;\n\t} else {\n\t\tESP_IMAGE_HEADER_P header = esp_image_get_header();\n\t\tsize = header->partition_info.maximum_size;\n\t}\n\treturn size;\n}\n", "CodeBleu_score": 35.020673927649796}, {"code": "static uint32_t sketchSize(sketchSize_t response)\tuint32_t size = 0;\n\tif (response) {\n\t\tsize = ESP.getFreeSketchSpace();\n\t} else {\n\t\tsize = ESP.getSketchSize();\n\t}\n\treturn size;\n}\n", "CodeBleu_score": 21.961551748044254}, {"code": "static uint32_t sketchSize(sketchSize_t response)\tuint32_t size = 0;\n\tuint8_t *sketchData = (uint8_t *) get_running_sketch();\n\tif (sketchData) {\n\t\tif (sketchData[0] == 0xE9 && sketchData[1] == 0x00 && sketchData[2] == 0x00 && sketchData[3] == 0x00) {\n\t\t\tsize = sketchData[5] << 24 | sketchData[6] << 16 | sketchData[7] << 8 | sketchData[8];\n\t\t\tif (response) {\n\t\t\t\tsize = get_partition_info(sketchData[4], size);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n", "CodeBleu_score": 28.768978206997588}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\t// Calculate the number of sectors required for the RAM disk\n\tuint32_t sector_count = 0;\n\tif (msc_partition_running) {\n\t\tsector_count += 1; // 1 sector for the boot sector\n\t\tsector_count += 1; // 1 sector for the file allocation table\n\t\tsector_count += 1; // 1 sector for the root directory entry\n\t}\n\tsector_count += 1; // 1 sector for the firmware file\n\tsector_count += 1; // 1 sector for the MSC device descriptor\n\n\t// Allocate memory for the RAM disk\n\tmsc_disk_sectors = malloc(sector_count * sizeof(uint8_t));\n\tif (msc_disk_sectors == NULL) {\n\t\t// Log an error if allocation failed\n\t\tprintf(\"Error: Failed to allocate memory for the RAM disk\\n\");\n\t\treturn false;\n\t}\n\n\t// Set up the boot sector and file allocation table (FAT)\n\tif (msc_partition_running) {\n\t\t// Set up the boot sector\n\t\tmsc_disk_sectors[0] = 0xEB; // Jump instruction\n\t\tmsc_disk_sectors[1] = 0x3C; // Jump offset\n\t\tmsc_disk_sectors[2] = 0x90; // Jump instruction\n\t\tmsc_disk_sectors[3] = 0x80; // Operating system identifier\n\t\tmsc_disk_sectors[4] = 0x02; // Bytes per sector (512 bytes)\n\t\tmsc_disk_sectors[5] = 0x08; // Sectors per cluster\n\t\tmsc_disk_sectors[6] = 0x00; // Reserved sectors\n\t\tmsc_disk_sectors[7] = 0x02; // Number of FATs\n\t\tmsc_disk_sectors[8] = 0x00; // Root directory entries (16 entries)\n\t\tmsc_disk_sectors[9] = 0x02; // Total sectors (1 sector for the boot sector, 1 sector for the file allocation table, and 1 sector for the root directory entry)\n\t\tmsc_disk_sectors[10]", "CodeBleu_score": 14.633849242877883}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\t// Calculate the required disk sectors\n\tuint32_t required_sectors = 0;\n\tif (msc_partition_running) {\n\t\trequired_sectors = 1 + (msc_partition_size_sectors / msc_sector_size);\n\t} else {\n\t\trequired_sectors = 1 + (msc_disk_size_sectors / msc_sector_size);\n\t}\n\n\t// Allocate memory for the RAM disk\n\tmsc_disk_buffer = malloc(msc_sector_size * required_sectors);\n\tif (msc_disk_buffer == NULL) {\n\t\tlog_error(\"Could not allocate memory for RAM disk\");\n\t\treturn false;\n\t}\n\n\t// Log the required disk size\n\tlog_info(\"Required RAM disk size: %d KB\", required_sectors * msc_sector_size / 1024);\n\n\t// Set up the boot sector\n\tmemset(msc_disk_buffer, 0, msc_sector_size);\n\tmsc_disk_buffer[0x00] = 0xEB;\n\tmsc_disk_buffer[0x01] = 0x3C;\n\tmsc_disk_buffer[0x02] = 0x90;\n\tstrcpy((char *) &msc_disk_buffer[0x03], \"MSWIN4.1\");\n\tmsc_disk_buffer[0x0B] = 0x02;\n\tmsc_disk_buffer[0x0C] = 0x00;\n\tmsc_disk_buffer[0x0D] = 0x02;\n\tmsc_disk_buffer[0x0E] = 0x00;\n\tmsc_disk_buffer[0x0F] = 0x01;\n\tmsc_disk_buffer[0x10] = 0x00;\n\tmsc_disk_buffer[0x11] = 0x00;\n\tmsc_disk_buffer[0x12] = 0x01;\n\tmsc_disk_buffer[0x13] = 0x00;\n\tmsc_disk_buffer[0x14] = 0x0", "CodeBleu_score": 19.255870546999155}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\tuint32_t disk_sectors;\n\tuint32_t fat_sectors;\n\tuint32_t root_dir_sectors;\n\tuint32_t root_dir_entries;\n\tuint32_t boot_sector_sectors;\n\tuint32_t fat_table_sectors;\n\tuint32_t root_dir_sectors_per_cluster;\n\tuint32_t root_dir_clusters;\n\tuint32_t root_dir_entries_per_cluster;\n\tuint32_t root_dir_sectors_per_cluster_rounded;\n\tuint32_t root_dir_clusters_rounded;\n\tuint32_t root_dir_entries_per_cluster_rounded;\n\tuint32_t root_dir_sectors_rounded;\n\tuint32_t root_dir_clusters_rounded_rounded;\n\tuint32_t root_dir_entries_per_cluster_rounded_rounded;\n\tuint32_t root_dir_sectors_rounded_rounded;\n\tuint32_t root_dir_clusters_rounded_rounded_rounded;\n\tuint32_t root_dir_entries_per_cluster_rounded_rounded_rounded;\n\tuint32_t root_dir_sectors_rounded_rounded_rounded;\n\tuint32_t root_dir_clusters_rounded_rounded_rounded_rounded;\n\tuint32_t root_dir_entries_per_cluster_rounded_rounded_rounded_rounded;\n\tuint32_t root_dir_sectors_rounded_rounded_rounded_rounded;\n\tuint32_t root_dir_clusters_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t root_dir_entries_per_cluster_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t root_dir_sectors_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t root_dir_clusters_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t root_dir_entries_per_cluster_rounded_rounded_rounded_rounded_rounded_rounded;\n\t", "CodeBleu_score": 6.302865141185354}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tesp_err_t ret;\n\tif (offset % partition->erase_size) {\n\t\tESP_LOGW(TAG, \"Offset 0x%08x is not aligned with sector size 0x%08x\", offset, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (partition->size < offset + size) {\n\t\tESP_LOGW(TAG, \"Offset 0x%08x + size 0x%08x exceeds partition size 0x%08x\", offset, size, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size > partition->erase_size) {\n\t\tESP_LOGW(TAG, \"Size 0x%08x exceeds sector size 0x%08x\", size, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size == 0) {\n\t\treturn ESP_OK;\n\t}\n\tif (partition->erase_size!= 0) {\n\t\tret = esp_partition_erase_range(partition, offset, size);\n\t\tif (ret!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase sector at offset 0x%08x\", offset);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = esp_partition_write(partition, offset, data, size);\n\tif (ret!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write data at offset 0x%08x\", offset);\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 48.444106563501464}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"offset %d is not aligned with the partition sector size %d\", offset, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tesp_err_t ret = ESP_OK;\n\tif (size > partition->size - offset) {\n\t\tESP_LOGE(TAG, \"data size %d is greater than the partition size %d\", size, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (offset + size > partition->size) {\n\t\tESP_LOGE(TAG, \"data size %d is greater than the partition size %d\", size, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (partition->size - offset > partition->erase_size) {\n\t\tret = esp_partition_erase_range(partition, offset, partition->erase_size);\n\t\tif (ret!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"failed to erase partition sector at offset %d\", offset);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = esp_partition_write(partition, offset, data, size);\n\tif (ret!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"failed to write data to partition at offset %d\", offset);\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 45.878945983365725}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tesp_err_t err = ESP_OK;\n\tuint32_t sector = offset / partition->erase_size;\n\tuint32_t sector_offset = offset % partition->erase_size;\n\tuint32_t sector_size = partition->erase_size;\n\tif (sector_offset + size > sector_size) {\n\t\tsector++;\n\t\tsector_size = sector_size - sector_offset;\n\t}\n\tif (sector_size == 0) {\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (sector_size!= size) {\n\t\terr = esp_partition_erase_range(partition, sector, sector_size);\n\t\tif (err!= ESP_OK) {\n\t\t\tESP_LOGW(TAG, \"Failed to erase sector %d in partition %s: %s\", sector, partition->label, esp_err_to_name(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGW(TAG, \"Failed to write to partition %s: %s\", partition->label, esp_err_to_name(err));\n\t}\n\treturn err;\n}\n", "CodeBleu_score": 53.24105813782373}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t len = 0;\n\tunsigned char b;\n\tfor (size_t i = 0; i < maxlen; i++) {\n\t\tif (in[2 * i] == '\\0') {\n\t\t\tbreak;\n\t\t}\n\t\tif (in[2 * i + 1] == '\\0') {\n\t\t\tbreak;\n\t\t}\n\t\tif (in[2 * i] >= '0' && in[2 * i] <= '9') {\n\t\t\tb = (in[2 * i] - '0') << 4;\n\t\t} else if (in[2 * i] >= 'A' && in[2 * i] <= 'F') {\n\t\t\tb = (in[2 * i] - 'A' + 10) << 4;\n\t\t} else if (in[2 * i] >= 'a' && in[2 * i] <= 'f') {\n\t\t\tb = (in[2 * i] - 'a' + 10) << 4;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[2 * i + 1] >= '0' && in[2 * i + 1] <= '9') {\n\t\t\tb += in[2 * i + 1] - '0';\n\t\t} else if (in[2 * i + 1] >= 'A' && in[2 * i + 1] <= 'F') {\n\t\t\tb += in[2 * i + 1] - 'A' + 10;\n\t\t} else if (in[2 * i + 1] >= 'a' && in[2 * i + 1] <= 'f') {\n\t\t\tb += in[2 * i + 1] - 'a' + 10;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tout[i] = b;\n\t\tlen++;\n\t}\n\treturn len;\n}\n", "CodeBleu_score": 31.678064592790218}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (in[i] && j < maxlen) {\n\t\tif (isxdigit(in[i])) {\n\t\t\tif (isxdigit(in[i + 1])) {\n\t\t\t\tout[j] = (hex2byte(in[i]) << 4) | hex2byte(in[i + 1]);\n\t\t\t\ti += 2;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tout[j] = hex2byte(in[i]);\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn j;\n}\n", "CodeBleu_score": 43.342678819952326}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i, j;\n\tunsigned char a, b;\n\tfor (i = j = 0; i < strlen(in) && j < maxlen; i++, j++) {\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\ta = in[i] - '0';\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\ta = in[i] - 'a' + 10;\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\ta = in[i] - 'A' + 10;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tb = in[i] - '0';\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tb = in[i] - 'a' + 10;\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tb = in[i] - 'A' + 10;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tout[j] = a * 16 + b;\n\t}\n\treturn j;\n}\n", "CodeBleu_score": 38.67102480954679}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void)\tif (m_pRingBuffer == NULL)\n\t\treturn 0;\n\tif (m_pSemaphoreLock == NULL)\n\t\treturn 0;\n\tif (m_pSemaphoreLock->take(m_iLockTimeout)) {\n\t\tint iFreeSize = m_pRingBuffer->getFreeSize();\n\t\tm_pSemaphoreLock->give();\n\t\treturn iFreeSize;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 46.41217602058772}, {"code": "int HWCDC::availableForWrite(void)\tif(txRingBuffer && txLock) {\n\t\tif(xSemaphoreTake(txLock, 1000) == pdTRUE) {\n\t\t\tint freeSpace = txRingBuffer->availableForWrite();\n\t\t\txSemaphoreGive(txLock);\n\t\t\treturn freeSpace;\n\t\t}\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 41.117019354029566}, {"code": "int HWCDC::availableForWrite(void)\tif (tx_ring_buffer == NULL) {\n\t\treturn 0;\n\t}\n\tif (tx_ring_buffer->initialized == false) {\n\t\treturn 0;\n\t}\n\tif (tx_ring_buffer->lock_sem == NULL) {\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\tif (sem_wait_timeout(tx_ring_buffer->lock_sem, 1000) == 0) {\n\t\tret = tx_ring_buffer->free_size;\n\t\tsem_post(tx_ring_buffer->lock_sem);\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 44.63296720315798}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\t_onReceiveCB = function;\n\tif (_onReceiveCB!= NULL) {\n\t\t_rxTimeout = onlyOnTimeout;\n\t\t_rxTimeoutTime = millis();\n\t\tif (_rxTimeout) {\n\t\t\t_rxTimeoutTime += _rxTimeout;\n\t\t}\n\t\tif (_rxTimeout) {\n\t\t\tif (_rxTimeout > 0) {\n\t\t\t\t_rxTimeoutTime += _rxTimeout;\n\t\t\t}\n\t\t\t_rxTimeoutTime -= millis();\n\t\t}\n\t\tif (_rxTimeout) {\n\t\t\t_rxTimeoutTime += millis();\n\t\t}\n\t\t_rxTimeoutTime = _rxTimeoutTime / 1000;\n\t\tif (_rxTimeoutTime == 0) {\n\t\t\t_rxTimeoutTime = 1;\n\t\t}\n\t\tif (_rxTimeoutTime > 1000) {\n\t\t\t_rxTimeoutTime = 1000;\n\t\t}\n\t\t_rxTimeoutTime = _rxTimeoutTime * 1000;\n\t\tif (_rxTimeoutTime > 1000) {\n\t\t\t_rxTimeoutTime = 1000;\n\t\t}\n\t\t_rxTimeoutTime = _rxTimeoutTime / 1000;\n\t\tif (_rxTimeoutTime == 0) {\n\t\t\t_rxTimeoutTime = 1;\n\t\t}\n\t\tif (_rxTimeoutTime > 1000) {\n\t\t\t_rxTimeoutTime = 1000;\n\t\t}\n\t\t_rxTimeoutTime = _rxTimeoutTime * 1000;\n\t\tif (_rxTimeoutTime > 1000) {\n\t\t\t_rxTimeoutTime = 1000;\n\t\t}\n\t\t_rxTimeoutTime = _rxTimeoutTime / 1000;\n\t\tif (_rxTimeoutTime == 0) {\n\t\t\t_rxTimeoutTime = 1;\n\t\t}\n\t\tif (_rxTimeoutTime > 1000) {\n\t\t\t_rxTimeoutTime = 1000;\n\t\t}\n\t\t_rxTimeoutTime = _rxTimeoutTime * 1000;\n\t\tif (_rxTimeoutTime > 1000) {\n\t\t\t_rxTimeoutTime = 1000;\n\t\t}\n\t\t_rxTimeoutTime = _rxTimeoutTime / 1000;", "CodeBleu_score": 41.049796675555726}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\t_mutex.lock();\n\t_onReceiveCB = function;\n\tif (_onReceiveCB) {\n\t\tif (onlyOnTimeout) {\n\t\t\t_rxTimeout = 0;\n\t\t}\n\t\tif (_rxTimeout > 0) {\n\t\t\tif (!_rxTimeoutEvent.isCreated()) {\n\t\t\t\t_rxTimeoutEvent.create(NULL, onReceiveTimeout, this, _rxTimeout);\n\t\t\t}\n\t\t\t_rxTimeoutEvent.start();\n\t\t}\n\t}\n\t_mutex.unlock();\n}\n", "CodeBleu_score": 42.49157198588711}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\t// Lock the serial mutex\n\t_serialMutex.lock();\n\n\t// Assign the callback function to the \"_onReceiveCB\" variable\n\t_onReceiveCB = function;\n\n\t// Configure the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n\tif (onlyOnTimeout) {\n\t\t// Set the FIFO full threshold to the maximum value\n\t\t_uart->setFifoFullThreshold(UART_FIFO_FULL_THRESHOLD_MAX);\n\n\t\t// If the receive timeout is enabled, create an event task\n\t\tif (_rxTimeout) {\n\t\t\t// Create an event task\n\t\t\t_eventTask = new EventTask(this, EventTask::EVENT_RX_TIMEOUT);\n\n\t\t\t// Set the event task priority\n\t\t\t_eventTask->setPriority(EventTask::PRIORITY_HIGH);\n\t\t}\n\t} else {\n\t\t// Set the FIFO full threshold to the minimum value\n\t\t_uart->setFifoFullThreshold(UART_FIFO_FULL_THRESHOLD_MIN);\n\n\t\t// If the receive timeout is disabled, delete the event task\n\t\tif (!_rxTimeout) {\n\t\t\t// Delete the event task\n\t\t\tdelete _eventTask;\n\t\t\t_eventTask = NULL;\n\t\t}\n\t}\n\n\t// Unlock the serial mutex\n\t_serialMutex.unlock();\n}\n", "CodeBleu_score": 43.4104321331703}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tif (length < 1) return 0;\n\tsize_t n = 0;\n\twhile (n < (length - 1)) {\n\t\tint c = timedRead();\n\t\tif (c < 0) return n;\n\t\t*buffer++ = c;\n\t\tif (c == terminator) break;\n\t\tn++;\n\t}\n\t*buffer = 0;\n\treturn n;\n}\n", "CodeBleu_score": 58.687642596171486}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t i = 0;\n\tchar c;\n\twhile (i < length - 1) {\n\t\tif (timedRead(&c, 1)!= 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\ti++;\n\t}\n\t*buffer = '\\0';\n\treturn i;\n}\n", "CodeBleu_score": 60.21480343438385}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\tsize_t i = 0;\n\tchar c;\n\twhile (i < length - 1) {\n\t\tif (timedRead(&c, 1)!= 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\ti++;\n\t}\n\t*buffer = 0;\n\n\treturn i;\n}\n", "CodeBleu_score": 60.19289798533924}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\tif (pinAvailable(pin)) {\n\t\ttoneInit(pin, frequency, duration);\n\t} else {\n\t\tSerial.print(\"Error: Pin \");\n\t\tSerial.print(pin);\n\t\tSerial.println(\" is already in use.\");\n\t}\n}\n", "CodeBleu_score": 21.565690555397946}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\tif (pinAvailable(pin)) {\n\t\tinitTone(pin, frequency, duration);\n\t\tqueueTone(pin, frequency, duration);\n\t} else {\n\t\tSerial.println(\"Pin is in use\");\n\t}\n}\n", "CodeBleu_score": 20.26650825510073}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\tif (pinAvailable(pin)) {\n\t\tif (isToneActive(pin)) {\n\t\t\tlogError(\"Tone on pin %d is already active. Stop the current tone first.\", pin);\n\t\t} else {\n\t\t\tinitTone(pin, frequency, duration);\n\t\t\tsendToneStart(pin, frequency, duration);\n\t\t}\n\t} else {\n\t\tlogError(\"Pin %d is not available.\", pin);\n\t}\n}\n", "CodeBleu_score": 30.039135505653945}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled)\tif (enabled) {\n\t\tif (started) {\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tstarted = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tstarted = true;\n\t\t}\n\t} else {\n\t\tstarted = false;\n\t}\n\treturn!started;\n}\n", "CodeBleu_score": 34.30861102326577}, {"code": "bool ESPUSB::webUSB(bool enabled)\tif (!started) {\n\t\twebUSBEnabled = enabled;\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (usbVersion < 0x0210) {\n\t\t\treturn false;\n\t\t}\n\t\t// Enable WebUSB\n\t\tusb_webusb_enable();\n\t} else {\n\t\t// Disable WebUSB\n\t\tusb_webusb_disable();\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 34.34965810032263}, {"code": "bool ESPUSB::webUSB(bool enabled)\tif (enabled) {\n\t\tif (!started) {\n\t\t\tstarted = true;\n\t\t\twebUSBEnabled = true;\n\t\t\treturn true;\n\t\t}\n\t\tif (version < 0x0210) {\n\t\t\twebUSBEnabled = true;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\twebUSBEnabled = false;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 41.217560516123555}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX()\t// Read data into buffer\n\tuint8_t bytesRead = _serial->read(_rxBuffer, USBCDC_RX_BUFFER_SIZE);\n\t// Send each byte to the receive queue\n\tfor (uint8_t i = 0; i < bytesRead; i++) {\n\t\tif (_rxQueue.isFull()) {\n\t\t\t// Overflow event\n\t\t\t_onOverflow(bytesRead - i);\n\t\t\treturn;\n\t\t}\n\t\t_rxQueue.put(_rxBuffer[i]);\n\t}\n\t// Receive event\n\t_onReceive(bytesRead);\n}\n", "CodeBleu_score": 15.95116313691567}, {"code": "void USBCDC::_onRX()\t// Read data from the USB CDC device\n\tuint8_t data[CDC_RX_BUFFER_SIZE];\n\tuint16_t length = CDC_RX_BUFFER_SIZE;\n\tif (CDC_Read(&data[0], &length)!= USBD_OK) {\n\t\t// An error occurred\n\t\tCDC_HandleTypeDef *cdc = (CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;\n\t\tcdc->RxState = 0;\n\t\treturn;\n\t}\n\n\t// If the read was successful, post a receive event\n\tif (length > 0) {\n\t\t// Post a receive event\n\t\tUSBEvent event;\n\t\tevent.type = USBEvent::USB_EVENT_RX;\n\t\tevent.data = data;\n\t\tevent.length = length;\n\t\t_eventQueue.postEvent(event);\n\t}\n}\n", "CodeBleu_score": 19.858414782417}, {"code": "void USBCDC::_onRX()\tuint8_t data[CDC_DATA_SIZE];\n\tuint16_t len;\n\tuint16_t dropped;\n\tuint16_t i;\n\tuint16_t j;\n\n\t// Read data from the USB CDC device\n\tlen = _device->read(data, CDC_DATA_SIZE);\n\n\t// If there is no data, return\n\tif (len == 0) {\n\t\treturn;\n\t}\n\n\t// Attempt to send each byte to the receive queue\n\tdropped = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (!_rxQueue.push(data[i])) {\n\t\t\tdropped++;\n\t\t}\n\t}\n\n\t// If there are any bytes dropped, log an error\n\tif (dropped > 0) {\n\t\tlog.error(\"Dropped %d bytes from USB CDC receive queue\", dropped);\n\t}\n\n\t// Post a receive event with the length of the received data\n\t_event.post(USB_CDC_EVENT_RX, len);\n}\n", "CodeBleu_score": 23.392882004173966}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tres.Header().Set(\"Content-Type\", \"application/json\")\n\n\t// Get the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Check if a robot with the given name exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot does not exist, return an error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the given name\"})\n\t\treturn\n\t}\n\n\t// If the robot exists, get its devices\n\tdevices, err := a.db.GetDevices(robot.ID)\n\tif err!= nil {\n\t\t// If there was an error retrieving the devices, return an error message\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"Failed to retrieve devices for the given robot\"})\n\t\treturn\n\t}\n\n\t// Write the JSON response to the HTTP response writer\n\tjson.NewEncoder(res).Encode(devices)\n}\n", "CodeBleu_score": 36.645769644386846}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the URL path\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\t// Get the robot with the given name\n\trobot, err := a.robotRepository.Get(robotName)\n\n\t// Check if an error occurred while getting the robot\n\tif err!= nil {\n\t\t// If the robot does not exist, return a JSON response indicating that no robot was found\n\t\tif err == robots.ErrRobotNotFound {\n\t\t\ta.respondWithError(res, http.StatusNotFound, \"No robot found with the given name\")\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise, return a JSON response indicating an internal server error\n\t\ta.respondWithError(res, http.StatusInternalServerError, \"Internal server error\")\n\t\treturn\n\t}\n\n\t// Get the devices associated with the robot\n\tdevices, err := a.deviceRepository.GetByRobot(robot.ID)\n\n\t// Check if an error occurred while getting the devices\n\tif err!= nil {\n\t\t// If the devices could not be retrieved, return a JSON response indicating an internal server error\n\t\ta.respondWithError(res, http.StatusInternalServerError, \"Internal server error\")\n\t\treturn\n\t}\n\n\t// Create a JSON response with the devices\n\tjsonResponse, err := json.Marshal(devices)\n\n\t// Check if an error occurred while creating the JSON response\n\tif err!= nil {\n\t\t// If the JSON response could not be created, return a JSON response indicating an internal server error\n\t\ta.respondWithError(res, http.StatusInternalServerError, \"Internal server error\")\n\t\treturn\n\t}\n\n\t// Write the JSON response to the HTTP response writer\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(jsonResponse)\n}\n", "CodeBleu_score": 33.941772598125816}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the URL path\n\trobotName := mux.Vars(req)[\"name\"]\n\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot does not exist, return a JSON response with an error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the given name\"})\n\t\treturn\n\t}\n\n\t// If the robot exists, gather its devices into a JSON format and write this JSON response to the HTTP response writer\n\tdevices := robot.GetDevices()\n\tjson.NewEncoder(res).Encode(devices)\n}\n", "CodeBleu_score": 30.243041000014248}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\t// Check if the robot exists\n\trobot, err := a.robotStore.Get(robotName)\n\tif err!= nil {\n\t\t// If the robot does not exist, write an error message to the HTTP response\n\t\thttp.Error(res, fmt.Sprintf(\"No robot with name %s found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format\n\tconnectionsJSON, err := json.Marshal(robot.Connections)\n\tif err!= nil {\n\t\t// If there is an error converting the connections to JSON, write an error message to the HTTP response\n\t\thttp.Error(res, \"Error converting connections to JSON\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the connections in JSON format to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}\n", "CodeBleu_score": 33.35383150706669}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Check if the robot exists\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\t// If the robot does not exist, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with the specified name was found\"))\n\t\treturn\n\t}\n\n\t// Convert the connections of the robot to JSON format\n\tconnectionsJSON, err := json.Marshal(robot.Connections)\n\tif err!= nil {\n\t\t// If there is an error converting the connections to JSON format, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"An error occurred while converting the connections to JSON format\"))\n\t\treturn\n\t}\n\n\t// Write the connections of the robot to the HTTP response\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}\n", "CodeBleu_score": 27.638627437841297}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\trobotName := path.Base(req.URL.Path)\n\n\t// Check if the robot exists\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\t// Write an error message to the HTTP response if the robot is not found\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %s found\", robotName)\n\t\treturn\n\t}\n\n\t// Convert the connections of the robot to JSON format\n\tconnectionsJSON, err := json.Marshal(robot.Connections)\n\tif err!= nil {\n\t\t// Write an error message to the HTTP response if an error occurs while converting the connections to JSON\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error converting connections to JSON: %v\", err)\n\t\treturn\n\t}\n\n\t// Write the connections in JSON format to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, \"%s\", connectionsJSON)\n}\n", "CodeBleu_score": 32.21024557800526}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Get the robot from the database\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\t// Write the error message as a JSON response\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Get the device from the robot\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err!= nil {\n\t\t// Write the error message as a JSON response\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\terr = device.ExecuteCommand(req.URL.Query().Get(\"command\"))\n\tif err!= nil {\n\t\t// Write the error message as a JSON response\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Write the success message as a JSON response\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(map[string]string{\"message\": \"Command executed successfully\"})\n}\n", "CodeBleu_score": 47.481821764006696}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tjson.NewEncoder(res).Encode(err.Error())\n\t\treturn\n\t}\n\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tjson.NewEncoder(res).Encode(err.Error())\n\t\treturn\n\t}\n\n\terr = device.ExecuteCommand(command)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tjson.NewEncoder(res).Encode(err.Error())\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(\"Command executed successfully\")\n}\n", "CodeBleu_score": 44.896640333690634}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\t// Get the device name from the URL query parameters\n\tdeviceName := req.URL.Query().Get(\"device\")\n\t// Get the command from the URL query parameters\n\tcommand := req.URL.Query().Get(\"command\")\n\n\t// Get the robot with the specified name\n\trobot, err := a.getRobot(robotName)\n\tif err!= nil {\n\t\t// If an error occurs while retrieving the robot, write the error message as a JSON response\n\t\twriteJSONResponse(res, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Get the device with the specified name from the robot\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err!= nil {\n\t\t// If an error occurs while retrieving the device, write the error message as a JSON response\n\t\twriteJSONResponse(res, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device\n\terr = device.Execute(command)\n\tif err!= nil {\n\t\t// If an error occurs while executing the command, write the error message as a JSON response\n\t\twriteJSONResponse(res, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Write a JSON response indicating that the command was executed successfully\n\twriteJSONResponse(res, \"Command executed successfully\", http.StatusOK)\n}\n", "CodeBleu_score": 47.30304593849964}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\")!= \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 61.574068731224905}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || username!= user || password!= pass {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 49.34884212102425}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// Check if the \"Authorization\" header is present\n\t\tif authHeader == \"\" {\n\t\t\t// If the \"Authorization\" header is not present, respond with a \"401 Unauthorized\" status and an error message\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the \"Authorization\" header into username and password\n\t\tauthHeaderParts := strings.Split(authHeader, \" \")\n\t\tif len(authHeaderParts)!= 2 || strings.ToLower(authHeaderParts[0])!= \"basic\" {\n\t\t\t// If the \"Authorization\" header is not in the correct format, respond with a \"401 Unauthorized\" status and an error message\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the username and password from base64\n\t\tdecodedAuthHeader, err := base64.StdEncoding.DecodeString(authHeaderParts[1])\n\t\tif err!= nil {\n\t\t\t// If the base64 decoding fails, respond with a \"401 Unauthorized\" status and an error message\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the username and password into separate strings\n\t\tdecodedAuthHeaderParts := strings.Split(string(decodedAuthHeader), \":\")\n\t\tif len(decodedAuthHeaderParts)!= 2 {\n\t\t\t// If the username and password are not separated by a colon, respond with a \"401 Unauthorized\" status and an error message\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password with the provided credentials\n\t\tif decodedAuthHeaderParts[0]!= username || decodedAuthHeaderParts[1]!=", "CodeBleu_score": 45.78510526451864}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the sensor for reading\n\ta.Lock()\n\tdefer a.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.connection.AnalogReadSupported() {\n\t\treturn -1, -1, errors.New(\"connection does not support analog reading\")\n\t}\n\n\t// Read the raw sensor value\n\trawValue, err := a.connection.AnalogRead(a.channel)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaledValue := a.scale(rawValue)\n\n\t// Update the last read values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\t// Return the raw and scaled values\n\treturn rawValue, scaledValue, nil\n}\n", "CodeBleu_score": 42.590851298858844}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the sensor for reading\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"Analog sensor does not support analog reading\")\n\t}\n\n\t// Read the raw sensor value\n\trawValue, err := a.connection.AnalogRead(a.address)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaledValue := a.scaleValue(rawValue)\n\n\t// Update the last read values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}\n", "CodeBleu_score": 49.53284003353266}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\tif a.isLocked {\n\t\treturn 0, 0, errors.New(\"AnalogSensorDriver: Analog sensor is locked for reading\")\n\t}\n\tif!a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"AnalogSensorDriver: Connection does not support analog reading\")\n\t}\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := a.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 43.51160731692521}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDrivervar (\n\t\tname string\n\t\terr  error\n\t)\n\tif len(opts) > 0 {\n\t\tname, err = opts[0].(string)\n\t\tif err!= nil {\n\t\t\tname = \"GroveSoundSensorDriver\"\n\t\t}\n\t} else {\n\t\tname = \"GroveSoundSensorDriver\"\n\t}\n\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, name, opts...),\n\t}\n}\n", "CodeBleu_score": 33.22299358097847}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDrivervar (\n\t\tname string\n\t)\n\n\t// Parse the optional parameters.\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase string:\n\t\t\tname = opt.(string)\n\t\t}\n\t}\n\n\t// Create the driver.\n\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\t// Set the default name if necessary.\n\tif name == \"\" {\n\t\td.Name = \"Grove Sound Sensor\"\n\t} else {\n\t\td.Name = name\n\t}\n\n\treturn d\n}\n", "CodeBleu_score": 47.91735513054925}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriverreturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}\n", "CodeBleu_score": 35.37524968042367}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(time.Millisecond * 100)\n\tstatus, err := d.readRegister(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status&SoftReset == SoftReset {\n\t\treturn errors.New(\"softReset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 48.501356105992286}, {"code": "func (d *MFRC522Common) softReset() error\terr := d.writeRegister(CommandReg, SoftReset)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Millisecond * 10)\n\tstatus, err := d.readRegister(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status&SoftReset!= 0 {\n\t\treturn errors.New(\"softReset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 59.11682216622452}, {"code": "func (d *MFRC522Common) softReset() error\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(time.Millisecond * 10)\n\tstatus, err := d.readRegister(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status&SoftReset!= 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 49.0280923668496}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Check if FIFO buffer is empty\n\tfifoLevel, err := d.readRegister(MFRC522_RegFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif fifoLevel == 0 {\n\t\treturn 0, errors.New(\"FIFO buffer empty\")\n\t}\n\t// Check if FIFO buffer is not full\n\tfifoLevel, err = d.readRegister(MFRC522_RegFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif fifoLevel == 0 {\n\t\treturn 0, errors.New(\"FIFO buffer empty\")\n\t}\n\t// Read FIFO buffer\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(MFRC522_RegFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Get last bits\n\tlastBits, err := d.readRegister(MFRC522_RegControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits, nil\n}\n", "CodeBleu_score": 49.90260595973892}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Check if FIFO buffer is empty\n\tif err := d.isFifoEmpty(); err!= nil {\n\t\treturn 0, err\n\t}\n\t// Check if FIFO buffer is full\n\tif err := d.isFifoFull(); err!= nil {\n\t\treturn 0, err\n\t}\n\t// Read FIFO buffer\n\tif err := d.writeRegister(MFRC522_FIFODATA, backData); err!= nil {\n\t\treturn 0, err\n\t}\n\t// Read control register\n\treturn d.readRegister(MFRC522_CONTROL)\n}\n", "CodeBleu_score": 28.67873705292794}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// First get the number of bytes available in the FIFO.\n\tvar fifoSize uint8\n\tfifoSize, err := d.getRegister(mfrc522.RegisterFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if there are enough bytes in the FIFO.\n\tif fifoSize < uint8(len(backData)) {\n\t\treturn 0, errors.New(\"not enough bytes in FIFO\")\n\t}\n\n\t// Read the FIFO.\n\terr = d.readRegister(mfrc522.RegisterFIFOData, backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Read the control register.\n\tvar control uint8\n\tcontrol, err = d.getRegister(mfrc522.RegisterControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn control, nil\n}\n", "CodeBleu_score": 41.436686353066236}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error\tif d.debug {\n\t\td.debugLog(\"piccHalt\")\n\t}\n\tcmd := []byte{PICC_HALT}\n\tcrc, err := d.calculateCRC(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tcmd = append(cmd, crc...)\n\tstatus, err := d.toCard(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status!= STATUS_OK {\n\t\treturn fmt.Errorf(\"piccHalt: error 0x%x\", status)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 40.342932797308606}, {"code": "func (d *MFRC522Common) piccHalt() error\tif d.Debug {\n\t\td.debugPrint(\"piccHalt\")\n\t}\n\n\t// Build command buffer\n\tcmd := make([]byte, 4)\n\tcmd[0] = PiccHalt\n\tcmd[1] = 0x00\n\tcmd[2] = 0x00\n\tcmd[3] = 0x00\n\n\t// Calculate CRC\n\tcrc := d.calculateCRC(cmd)\n\n\t// Copy data to command buffer\n\tcmd[1] = crc[0]\n\tcmd[2] = crc[1]\n\n\t// Transmit command\n\terr := d.writeCommand(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Receive response\n\tresp, err := d.readResponse()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check response\n\tif resp[0]!= 0x00 {\n\t\treturn errors.New(\"piccHalt: Command error\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 29.235485453738146}, {"code": "func (d *MFRC522Common) piccHalt() error\tif d.Debug {\n\t\td.debugPrint(\"piccHalt\")\n\t}\n\n\t// Build command buffer\n\tcmd := make([]byte, 2)\n\tcmd[0] = MFRC522_HALT\n\tcmd[1] = 0\n\n\t// Calculate CRC\n\tcrc, err := d.calculateCRC(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Append CRC to command buffer\n\tcmd = append(cmd, crc...)\n\n\t// Transmit command\n\terr = d.writeCommand(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check for error\n\terr = d.checkError()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 30.301497297199166}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tvar data []byte\n\tvar status byte\n\n\t// Prepare the read command.\n\tcmd := make([]byte, 0)\n\tcmd = append(cmd, piccReadCmd)\n\tcmd = append(cmd, block)\n\n\t// Calculate the CRC.\n\tcrc, err := d.calculateCRC(cmd)\n\tif err!= nil {\n\t\treturn data, err\n\t}\n\n\t// Append the CRC to the command.\n\tcmd = append(cmd, crc...)\n\n\t// Transmit the command.\n\tstatus, err = d.communicate(cmd)\n\tif err!= nil {\n\t\treturn data, err\n\t}\n\n\t// Check for errors.\n\tif (status & 0x0F)!= 0x00 {\n\t\treturn data, errors.New(\"piccRead: Error\")\n\t}\n\n\t// Retrieve the data.\n\tdata = make([]byte, 0)\n\tdata = append(data, status)\n\tdata = append(data, d.rxBuf...)\n\n\treturn data, nil\n}\n", "CodeBleu_score": 38.396376606699334}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tvar (\n\t\terr error\n\t)\n\n\t// Prepare the read command.\n\tvar command []byte\n\tcommand = append(command, PiccRead)\n\tcommand = append(command, block)\n\n\t// Calculate the CRC.\n\tvar crc []byte\n\tcrc, err = d.calculateCRC(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Append the CRC to the command.\n\tcommand = append(command, crc...)\n\n\t// Transmit the command and receive the data.\n\tvar response []byte\n\tresponse, err = d.transceive(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check for errors.\n\tif response[0]!= 0x0A {\n\t\treturn nil, fmt.Errorf(\"piccRead: error %v\", response[0])\n\t}\n\n\t// Return the data.\n\treturn response[1:], nil\n}\n", "CodeBleu_score": 41.0750795635827}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tvar err error\n\tvar data []byte\n\tvar response []byte\n\n\t// Prepare the command\n\tcommand := []byte{\n\t\tpiccReadCommand,\n\t\tblock,\n\t\tbyte(0xff),\n\t\tbyte(0xff),\n\t}\n\n\t// Calculate the CRC\n\tcrc, err := d.calculateCRC(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Append the CRC to the command\n\tcommand = append(command, crc...)\n\n\t// Send the command to the RFID card\n\tresponse, err = d.sendCommand(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the response\n\tif response[0]!= 0x0a {\n\t\treturn nil, errors.New(\"invalid response\")\n\t}\n\n\t// Read the data\n\tdata = response[1:17]\n\n\treturn data, nil\n}\n", "CodeBleu_score": 45.473750233523766}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn errors.New(\"not enough space in the answer buffer\")\n\t}\n\n\t// Clear all bits in the collision register\n\td.writeRegister(MFRC522_REG_COLL, 0x80)\n\n\t// Tell the MFRC522 which request we want\n\tswitch reqMode {\n\tcase PICC_CMD_REQA:\n\t\td.writeRegister(MFRC522_REG_COMMAND, PICC_CMD_REQA)\n\t\td.writeRegister(MFRC522_REG_BITFRAMING, 0x07)\n\tcase PICC_CMD_WUPA:\n\t\td.writeRegister(MFRC522_REG_COMMAND, PICC_CMD_WUPA)\n\t\td.writeRegister(MFRC522_REG_BITFRAMING, 0x07)\n\tdefault:\n\t\treturn errors.New(\"invalid request mode\")\n\t}\n\n\t// Start the transmission\n\tif err := d.transceive(nil); err!= nil {\n\t\treturn err\n\t}\n\n\t// Read the response from the PICC\n\tif err := d.readRegister(MFRC522_REG_STATUS2, answer); err!= nil {\n\t\treturn err\n\t}\n\n\t// Check for collision\n\tif d.readRegister(MFRC522_REG_COLL, answer) == nil {\n\t\treturn errors.New(\"collision detected\")\n\t}\n\n\t// Tell the MFRC522 which request we want\n\tswitch reqMode {\n\tcase PICC_CMD_REQA:\n\t\td.writeRegister(MFRC522_REG_BITFRAMING, 0x00)\n\tcase PICC_CMD_WUPA:\n\t\td.writeRegister(MFRC522_REG_BITFRAMING, 0x00)\n\tdefault:\n\t\treturn errors.New(\"invalid request mode\")\n\t}\n\n\t// Read the response from the PICC\n\treturn d.readRegister(MFRC522_REG_STATUS2, answer)\n}\n", "CodeBleu_score": 51.34413965536343}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// The PICC must be in state ACTIVE after this call.\n\n\t// Store the current state of the PCD to detect changes after this call.\n\t//state := d.PCD_GetCurrentState()\n\n\t// Reset the buffer.\n\td.PCD_ClearRegisterBitMask(CollReg, 0x80)\n\n\t// Clear all bits set in CommandReg.\n\td.PCD_WriteRegister(CommandReg, PCD_IDLE)\n\n\t// Tell it we want to communicate with the PICC.\n\td.PCD_SetRegisterBitMask(BitFramingReg, 0x80)\n\n\t// Tell it to use the default number of bits per command.\n\td.PCD_WriteRegister(BitFramingReg, 0x00)\n\n\t// Set the number of bits that will be transmitted.\n\tswitch reqMode {\n\tcase PICC_CMD_REQA:\n\t\td.PCD_WriteRegister(BitFramingReg, (d.PCD_ReadRegister(BitFramingReg)&0xF0) | 0x07)\n\tcase PICC_CMD_WUPA:\n\t\td.PCD_WriteRegister(BitFramingReg, (d.PCD_ReadRegister(BitFramingReg)&0xF0) | 0x07)\n\tcase PICC_CMD_CT:\n\t\td.PCD_WriteRegister(BitFramingReg, (d.PCD_ReadRegister(BitFramingReg)&0xF0) | 0x09)\n\tcase PICC_CMD_HLTA:\n\t\td.PCD_WriteRegister(BitFramingReg, (d.PCD_ReadRegister(BitFramingReg)&0xF0) | 0x08)\n\tdefault:\n\t\treturn fmt.Errorf(\"Unknown command\")\n\t}\n\n\t// Start the transmission.\n\td.PCD_WriteRegister(CommandReg, PCD_TRANSCEIVE)\n\n\t// Wait for the transmission to finish.\n\t// Wait for the PCD to receive a acknowledge from the PICC.\n\tif!d.PCD_WaitUntilClear(CollReg, 0x80) {\n\t\t", "CodeBleu_score": 36.34269518379119}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// The PICC must be in state ACTIVE after this function.\n\t// We start by checking for basic errors.\n\n\t// In state ACTIVE the PCD has communication problems if bits 7-4 of Status2 register are set.\n\tif d.readRegister(Status2) & (1 << 7 | 1 << 4)!= 0 {\n\t\treturn fmt.Errorf(\"status2: %02x\", d.readRegister(Status2))\n\t}\n\n\t// In state ACTIVE the PCD has communication problems if bit 3 of Status2 register is set.\n\tif d.readRegister(Status2)&(1<<3)!= 0 {\n\t\treturn fmt.Errorf(\"status2: %02x\", d.readRegister(Status2))\n\t}\n\n\t// In state ACTIVE the PCD has communication problems if bit 2 of Status2 register is set.\n\tif d.readRegister(Status2)&(1<<2)!= 0 {\n\t\treturn fmt.Errorf(\"status2: %02x\", d.readRegister(Status2))\n\t}\n\n\t// In state ACTIVE the PCD has communication problems if bit 1 of Status2 register is set.\n\tif d.readRegister(Status2)&(1<<1)!= 0 {\n\t\treturn fmt.Errorf(\"status2: %02x\", d.readRegister(Status2))\n\t}\n\n\t// In state ACTIVE the PCD has communication problems if bit 0 of Status2 register is set.\n\tif d.readRegister(Status2)&1!= 0 {\n\t\treturn fmt.Errorf(\"status2: %02x\", d.readRegister(Status2))\n\t}\n\n\t// Clear internal buffer by setting the number of bytes to 0.\n\td.writeRegister(FIFOLevel, 0)\n\n\t// The bits in the collision position register indicate the number of bit collisions.\n\t// If there are three or more collisions, then we have a communication problem.\n\tif d.readRegister(Coll)&0x1F > 3 {\n\t\treturn fmt.Errorf(\"coll: %02x\", d.readRegister(Coll))\n\t}\n\n\t// Reset collision bit in collision register.\n\td.writeRegister(Coll, 0)\n\n", "CodeBleu_score": 31.348275374257046}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.Write(0)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.delay)\n\n\terr = d.stepPin.Write(1)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 58.316974412734744}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == -1 {\n\t\treturn errors.New(\"stepPin not set\")\n\t}\n\n\tif d.dirPin == -1 {\n\t\treturn errors.New(\"dirPin not set\")\n\t}\n\n\tif d.enablePin == -1 {\n\t\treturn errors.New(\"enablePin not set\")\n\t}\n\n\tif d.stepPin!= -1 {\n\t\tif d.direction == CW {\n\t\t\td.stepNumber++\n\t\t} else {\n\t\t\td.stepNumber--\n\t\t}\n\n\t\tif err := d.digitalWrite(d.stepPin, LOW); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(time.Duration(d.stepDelay) * time.Millisecond)\n\n\t\tif err := d.digitalWrite(d.stepPin, HIGH); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 50.53611869241418}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\terr := d.stepPin.Write(gpio.Low)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\terr = d.stepPin.Write(gpio.High)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 48.18396254407238}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorRunning = true\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitorWg.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdist, err := d.measureDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\tlog.Printf(\"distance monitor error: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distanceMonitorChannel <- dist\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n", "CodeBleu_score": 41.89548196956922}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitor!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\tstop := make(chan struct{})\n\twg := new(sync.WaitGroup)\n\twg.Add(1)\n\n\td.distanceMonitor = &distanceMonitor{\n\t\tstop: stop,\n\t\twg:   wg,\n\t}\n\n\tgo d.measureDistance(stop, wg)\n\n\treturn nil\n}\n", "CodeBleu_score": 28.45497775301236}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.monitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stop = make(chan struct{})\n\td.wg.Add(1)\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\terr := d.measureDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\tlog.Println(err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.interval)\n\t\t\t}\n\t\t}\n\t}()\n\n\td.monitorRunning = true\n\treturn nil\n}\n", "CodeBleu_score": 36.87474697148977}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar start time.Time\n\treturn func(pin int, duration time.Duration, event string, value uint32, timestamp uint32) {\n\t\tswitch event {\n\t\tcase \"rising\":\n\t\t\tstart = time.Now()\n\t\tcase \"falling\":\n\t\t\td.durationChannel <- time.Since(start)\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.15001097324632}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\treturn func(eventID int, duration time.Duration, pinName string, pinNumber uint32, pinValue uint32) {\n\t\tif eventID == 1 {\n\t\t\td.startTimestamp = time.Now()\n\t\t} else if eventID == 2 {\n\t\t\td.duration = time.Since(d.startTimestamp)\n\t\t\td.channel <- d.duration\n\t\t}\n\t}\n}\n", "CodeBleu_score": 31.712637647840637}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar start time.Time\n\treturn func(pin int, duration time.Duration, name string, value uint32, timestamp uint32) {\n\t\tif name == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if name == \"falling\" {\n\t\t\td.DurationChannel <- time.Since(start)\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.86565334413272}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error\t// Lock the measurement mutex to ensure exclusive access.\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor.\n\td.trigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur.\n\tselect {\n\tcase <-d.measurementComplete:\n\t\t// The measurement is complete.\n\t\td.measurementMutex.Unlock()\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// The timeout has occurred.\n\t\td.measurementMutex.Unlock()\n\t\treturn errors.New(\"timeout\")\n\t}\n}\n", "CodeBleu_score": 31.892868700385968}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.trigger()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete\n\tselect {\n\tcase <-d.done:\n\t\treturn errors.New(\"timeout\")\n\tcase <-d.done:\n\t\treturn nil\n\t}\n}\n", "CodeBleu_score": 42.28920785091732}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.trigger()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\terr = d.waitMeasurement()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Store the measured time in microseconds\n\td.distance = d.pulseDuration / 1000000.0\n\n\treturn nil\n}\n", "CodeBleu_score": 45.37597890564125}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n    # Check if the token is available in the environment variables.\n    token = os.getenv(self.token_env_var)\n    if token is not None:\n        return token\n    # Check the local state for a valid access token and its expiration time.\n    state = self.get_state()\n    if state is None:\n        raise AccountNotAuthorized()\n    if state[\"access_token\"] is None:\n        raise AccountNotAuthorized()\n    if state[\"access_token_expiration\"] is None:\n        raise AccountNotAuthorized()\n    if state[\"access_token_expiration\"] < datetime.now():\n        raise AccountNotAuthorized()\n    # If the access token is not expired, return it.\n    return state[\"access_token\"]\n    # If the access token is expired but a refresh token is available, try to fetch a new access token using the refresh token.\n    refresh_token = state[\"refresh_token\"]\n    if refresh_token is None:\n        raise AccountNotAuthorized()\n    # Fetch a new access token using the refresh token.\n    new_access_token = self.fetch_access_token(refresh_token)\n    # Update the local state with the new access token and its expiration time.\n    state = self.get_state()\n    state[\"access_token\"] = new_access_token\n    state[\"access_token_expiration\"] = datetime.now() + timedelta(seconds=state[\"expires_in\"])\n    self.set_state(state)\n    # Return the new access token.\n    return new_access_token\n\n  def fetch_access_token(self, refresh_token):\n    \"\"\"The function \"fetch_access_token\" fetches a new access token using the refresh token.\\nIt first constructs the request URL and headers for the refresh token request.\\nIt then sends the request using the requests library.\\nIf the request is successful, it returns the access token and its expiration time.\\nIf the request is not successful, it raises an \"AccountNotAuthorized\" exception.\"\"\"\n    # Construct the request URL and headers for the refresh token request.\n    request_url = self.token_url + \"?grant_type=refresh_token&client_id=\" + self.client_id + \"&client_secret=\" + self.client_secret + \"&refresh_token=\" + refresh_token\n    request_headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    # Send the request", "CodeBleu_score": 31.659776970955676}, {"code": "def fetch_authentication_token(self)\n    try:\n        if \"AUTH_TOKEN\" in os.environ:\n            return os.environ[\"AUTH_TOKEN\"]\n        else:\n            if \"ACCESS_TOKEN\" in self.local_state and \"ACCESS_TOKEN_EXPIRATION\" in self.local_state:\n                access_token = self.local_state[\"ACCESS_TOKEN\"]\n                access_token_expiration = self.local_state[\"ACCESS_TOKEN_EXPIRATION\"]\n                if access_token_expiration < datetime.datetime.now():\n                    if \"REFRESH_TOKEN\" in self.local_state:\n                        refresh_token = self.local_state[\"REFRESH_TOKEN\"]\n                        new_access_token = self.fetch_access_token(refresh_token)\n                        self.local_state[\"ACCESS_TOKEN\"] = new_access_token\n                        self.local_state[\"ACCESS_TOKEN_EXPIRATION\"] = datetime.datetime.now() + datetime.timedelta(seconds=self.local_state[\"ACCESS_TOKEN_EXPIRATION_SECONDS\"])\n                        return new_access_token\n                    else:\n                        raise AccountNotAuthorized()\n                else:\n                    return access_token\n            else:\n                raise AccountNotAuthorized()\n    except KeyError:\n        raise AccountNotAuthorized()\n\n", "CodeBleu_score": 37.53841858035465}, {"code": "def fetch_authentication_token(self)\n    # Check environment variables for authentication token\n    token = os.getenv(\"API_TOKEN\")\n    if token:\n        return token\n    # Check local state for authentication token\n    state = self.get_local_state()\n    if state:\n        token = state[\"authentication_token\"]\n        expiration = state[\"authentication_token_expiration\"]\n        if token and expiration and expiration > datetime.datetime.now():\n            return token\n    # Fetch new authentication token using refresh token\n    refresh_token = os.getenv(\"API_REFRESH_TOKEN\")\n    if refresh_token:\n        return self.fetch_authentication_token_with_refresh_token(refresh_token)\n    # Raise exception if authentication token is not available\n    raise AccountNotAuthorized(\"No authentication token is available.\")\n\n  def fetch_authentication_token_with_refresh_token(self, refresh_token):\n    \"\"\"The function \"fetch_authentication_token_with_refresh_token\" retrieves a new authentication token using a refresh token.\\nIt first creates a request to the authentication endpoint with the refresh token.\\nIt then parses the response and extracts the access token and its expiration time.\\nIf the access token is valid, it updates the local state with the new authentication data and returns the access token.\\nIf the access token is expired, it raises an \"AccountNotAuthorized\" exception.\"\"\"\n    # Create request to authentication endpoint\n    url = f\"{self.api_url}/authentication/token\"\n    data = {\"refresh_token\": refresh_token}\n    response = requests.post(url, json=data)\n    # Parse response and extract access token and expiration time\n    if response.status_code == 200:\n        data = response.json()\n        token = data[\"access_token\"]\n        expiration = datetime.datetime.fromtimestamp(data[\"expiration\"])\n        # Update local state with new authentication data\n        self.update_local_state({\"authentication_token\": token, \"authentication_token_expiration\": expiration})\n        return token\n    # Raise exception if access token is expired\n    raise AccountNotAuthorized(\"Access token is expired.\")\n\n  def update_local_state(self, state):\n    \"\"\"The function \"update_local_state\" updates the local state with the provided state data.\\nIt first checks if the local state file exists.\\nIf not, it creates a new state file with the provided state data.\\nIf the state file exists, it loads the existing state data.\\nIt", "CodeBleu_score": 37.28589291201776}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n    refresh_token = self.get_refresh_token()\n    self.delete_session()\n    try:\n      self.post(\"/v1/logout\", refresh_token)\n    except AccountError:\n      pass\n    return True\n\n  def get_refresh_token(self):\n    \"\"\"The function \"get_refresh_token\" retrieves the refresh token from the local session. If the token is not found, an AccountError is raised. The function returns the refresh token.\"\"\"\n    if self.session is None:\n      raise AccountError(\"No session found\")\n    if \"refresh_token\" not in self.session:\n      raise AccountError(\"No refresh token found\")\n    return self.session[\"refresh_token\"]\n\n  def get_access_token(self):\n    \"\"\"The function \"get_access_token\" retrieves the access token from the local session. If the token is not found, an AccountError is raised. The function returns the access token.\"\"\"\n    if self.session is None:\n      raise AccountError(\"No session found\")\n    if \"access_token\" not in self.session:\n      raise AccountError(\"No access token found\")\n    return self.session[\"access_token\"]\n\n  def get_account_id(self):\n    \"\"\"The function \"get_account_id\" retrieves the account ID from the local session. If the ID is not found, an AccountError is raised. The function returns the account ID.\"\"\"\n    if self.session is None:\n      raise AccountError(\"No session found\")\n    if \"account_id\" not in self.session:\n      raise AccountError(\"No account ID found\")\n    return self.session[\"account_id\"]\n\n  def get_user_id(self):\n    \"\"\"The function \"get_user_id\" retrieves the user ID from the local session. If the ID is not found, an AccountError is raised. The function returns the user ID.\"\"\"\n    if self.session is None:\n      raise AccountError(\"No session found\")\n    if \"user_id\" not in self.session:\n      raise AccountError(\"No user ID found\")\n    return self.session[\"user_id\"]\n\n  def get_username(self):\n    \"\"\"The function \"get_username\" retrieves the username from the local session. If the username is not found, an AccountError is raised. The function returns the username.\"\"\"\n    if self.session is None:\n      raise AccountError(\"No session found\")\n    if \"username", "CodeBleu_score": 42.309211198986524}, {"code": "def logout(self)\n    try:\n      refresh_token = self.get_refresh_token()\n      self.delete_session()\n      response = self.post(\"/v1/logout\", refresh_token)\n      if response.status_code == 400 and response.json()[\"error\"] == \"AccountError\":\n        return True\n      else:\n        return False\n    except Exception as e:\n      print(e)\n      return False\n\n  def get_refresh_token(self):\n    \"\"\"The function \"get_refresh_token\" retrieves the refresh token from the local session.\\nThe function returns the refresh token.\"\"\"\n    return self.session[\"refresh_token\"]\n\n  def get_access_token(self):\n    \"\"\"The function \"get_access_token\" retrieves the access token from the local session.\\nThe function returns the access token.\"\"\"\n    return self.session[\"access_token\"]\n\n  def get_user_id(self):\n    \"\"\"The function \"get_user_id\" retrieves the user ID from the local session.\\nThe function returns the user ID.\"\"\"\n    return self.session[\"user_id\"]\n\n  def get_user_email(self):\n    \"\"\"The function \"get_user_email\" retrieves the user email from the local session.\\nThe function returns the user email.\"\"\"\n    return self.session[\"user_email\"]\n\n  def get_user_name(self):\n    \"\"\"The function \"get_user_name\" retrieves the user name from the local session.\\nThe function returns the user name.\"\"\"\n    return self.session[\"user_name\"]\n\n  def get_user_picture(self):\n    \"\"\"The function \"get_user_picture\" retrieves the user picture from the local session.\\nThe function returns the user picture.\"\"\"\n    return self.session[\"user_picture\"]\n\n  def get_user_permissions(self):\n    \"\"\"The function \"get_user_permissions\" retrieves the user permissions from the local session.\\nThe function returns the user permissions.\"\"\"\n    return self.session[\"user_permissions\"]\n\n  def get_user_attributes(self):\n    \"\"\"The function \"get_user_attributes\" retrieves the user attributes from the local session.\\nThe function returns the user attributes.\"\"\"\n    return self.session[\"user_attributes\"]\n\n  def get_user_groups(self):\n    \"\"\"The function \"get_user_groups\" retrieves the user groups from the local session.\\nThe function returns the user groups.\"\"\"\n    return self.", "CodeBleu_score": 41.15731503144846}, {"code": "def logout(self)\n    try:\n      refresh_token = self.session.get(\"refresh_token\")\n      self.session.delete()\n      self.session.save()\n      self.session.post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n      return True\n    except AccountError:\n      return False\n\n  def get_user_id(self):\n    \"\"\"The function \"get_user_id\" retrieves the user ID of the current user. If the user is not logged in, an AccountError is raised.\"\"\"\n    if not self.is_logged_in():\n      raise AccountError(\"User is not logged in\")\n    return self.session.get(\"user_id\")\n\n  def get_user_name(self):\n    \"\"\"The function \"get_user_name\" retrieves the user name of the current user. If the user is not logged in, an AccountError is raised.\"\"\"\n    if not self.is_logged_in():\n      raise AccountError(\"User is not logged in\")\n    return self.session.get(\"user_name\")\n\n  def get_user_email(self):\n    \"\"\"The function \"get_user_email\" retrieves the user email of the current user. If the user is not logged in, an AccountError is raised.\"\"\"\n    if not self.is_logged_in():\n      raise AccountError(\"User is not logged in\")\n    return self.session.get(\"user_email\")\n\n  def get_user_picture(self):\n    \"\"\"The function \"get_user_picture\" retrieves the user picture of the current user. If the user is not logged in, an AccountError is raised.\"\"\"\n    if not self.is_logged_in():\n      raise AccountError(\"User is not logged in\")\n    return self.session.get(\"user_picture\")\n\n  def get_user_permissions(self):\n    \"\"\"The function \"get_user_permissions\" retrieves the user permissions of the current user. If the user is not logged in, an AccountError is raised.\"\"\"\n    if not self.is_logged_in():\n      raise AccountError(\"User is not logged in\")\n    return self.session.get(\"user_permissions\")\n\n  def get_user_role(self):\n    \"\"\"The function \"get_user_role\" retrieves the user role of the current user. If the user is not logged in, an AccountError is raised.\"\"\"\n    if not self.is_logged_in():\n      raise", "CodeBleu_score": 41.97129758224361}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n    result = []\n    for package in self.packages:\n      if package.is_optional:\n        continue\n      if package.is_external:\n        result.append((package.name, package.version, package.source_url))\n      else:\n        result.append((package.name, package.version))\n    return result\n\n  def dump_packages(self):\n    \"\"\"The function \"dump_packages\" returns a list of all packages with their names and versions.\\nIt iterates through the packages and collects metadata for them.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.\"\"\"\n    result = []\n    for package in self.packages:\n      if package.is_external:\n        result.append((package.name, package.version, package.source_url))\n      else:\n        result.append((package.name, package.version))\n    return result\n\n  def dump_packages_with_versions(self):\n    \"\"\"The function \"dump_packages_with_versions\" returns a list of all packages with their names and versions.\\nIt iterates through the packages and collects metadata for them.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.\"\"\"\n    result = []\n    for package in self.packages:\n      if package.is_external:\n        result.append((package.name, package.version, package.source_url))\n      else:\n        result.append((package.name, package.version))\n    return result\n\n  def dump_packages_with_versions_and_optional_packages(self):\n    \"\"\"The function \"dump_packages_with_versions_and_optional_packages\" returns a list of all packages with their names and versions.\\nIt iterates through the packages and collects metadata for them.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.\"\"\"\n    result = []\n    for package in self.packages:\n      if package.is_external:\n        result.append((package.name, package.version, package.source_url))\n      else:\n        result.append((package.name, package.version))\n    return result\n\n  def dump_packages_with_versions_and", "CodeBleu_score": 18.40574583144718}, {"code": "def dump_used_packages(self)\n    result = []\n    for package in self.packages:\n        if package.is_optional:\n            continue\n        result.append({\n            'name': package.name,\n           'version': package.version,\n           'source': package.source_url if package.is_external else None\n        })\n    return result\n", "CodeBleu_score": 24.443441540151667}, {"code": "def dump_used_packages(self)\n    result = []\n    for package in self.packages:\n      if not package.is_optional:\n        if package.is_external:\n          result.append({'name': package.name,'version': package.version,'source': package.source})\n        else:\n          result.append({'name': package.name,'version': package.version})\n    return result\n\n  def dump_used_packages_json(self):\n    \"\"\"The function \"dump_used_packages_json\" returns a string containing the list of non-optional packages with their names and versions.\\nIt iterates through the packages, skips optional ones, and collects metadata for the others.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.\"\"\"\n    return json.dumps(self.dump_used_packages())\n\n  def dump_used_packages_csv(self):\n    \"\"\"The function \"dump_used_packages_csv\" returns a string containing the list of non-optional packages with their names and versions.\\nIt iterates through the packages, skips optional ones, and collects metadata for the others.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.\"\"\"\n    result = ''\n    for package in self.packages:\n      if not package.is_optional:\n        if package.is_external:\n          result += package.name + ',' + package.version + ',' + package.source + '\\n'\n        else:\n          result += package.name + ',' + package.version + '\\n'\n    return result\n\n  def dump_used_packages_md(self):\n    \"\"\"The function \"dump_used_packages_md\" returns a string containing the list of non-optional packages with their names and versions.\\nIt iterates through the packages, skips optional ones, and collects metadata for the others.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.\"\"\"\n    result = ''\n    for package in self.packages:\n      if not package.is_optional:\n        if package.is_external:\n          result += package.name +'' + package.version +'(' + package.source + ')\\n'\n        else", "CodeBleu_score": 22.2941814879813}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    platform = env.platform\n    if platform is None:\n      raise UndefinedEnvPlatformError(env.name)\n    else:\n      return cls(platform, autoinstall, targets)\n  def __init__(self, platform, autoinstall=False, targets=None):\n    \"\"\"The class \"__init__\" creates a new instance of the class \"ProjectEnvironment\".\\nIt initializes the instance variables \"platform\", \"autoinstall\", and \"targets\".\\nIt also initializes the instance variable \"packages\" to an empty dictionary.\\nThe instance variable \"platform\" is set to the specified platform.\\nThe instance variable \"autoinstall\" is set to the specified autoinstall option.\\nThe instance variable \"targets\" is set to the specified targets.\\nThe instance variable \"packages\" is set to an empty dictionary.\"\"\"\n    self.platform = platform\n    self.autoinstall = autoinstall\n    self.targets = targets\n    self.packages = {}\n  def add_package(self, package):\n    \"\"\"The function \"add_package\" adds a package to the project environment.\\nIt retrieves the package name from the specified package.\\nIt then adds the package to the project environment's packages dictionary with the package name as the key and the package as the value.\\nFinally, it returns the package name.\"\"\"\n    name = package.name\n    self.packages[name] = package\n    return name\n  def remove_package(self, name):\n    \"\"\"The function \"remove_package\" removes a package from the project environment.\\nIt retrieves the package with the specified name from the project environment's packages dictionary.\\nIt then removes the package from the project environment's packages dictionary.\\nFinally, it returns the removed package.\"\"\"\n    package = self.packages.pop(name)\n    return package\n  def get_package(self, name):\n    \"\"\"The function \"get_package\" retrieves a package from the project environment.\\nIt retrieves the package with the specified name from the project environment's packages dictionary.\\nIt then returns the package with the specified name.\"\"\"\n    return self.packages[name]\n  def get_packages(self):\n    \"\"\"The function \"get_packages\" retrieves all packages from the project environment.\\nIt returns the project environment's packages dictionary.\"\"\"\n    return self.packages\n  def get_platform(self):\n    \"\"\"The function \"get_platform\" retrieves the platform of the project environment.\\nIt returns the project environment's platform.\"\"\"\n    return self.platform\n  def get_", "CodeBleu_score": 26.456702917489768}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if env not in envs:\n      raise UndefinedEnvError(env)\n    platform = envs[env]\n    return cls(platform, targets, autoinstall)\n\n  def __init__(self, platform, targets=None, autoinstall=False):\n    \"\"\"The constructor of the class \"ProjectEnvironment\" initializes the project environment with a specified platform specification and autoinstall option.\\nIt sets the project environment to the platform specification, and configures the project packages for the given environment and targets.\\nFinally, it returns the configured instance.\"\"\"\n    self.platform = platform\n    self.targets = targets\n    self.autoinstall = autoinstall\n    self.set_env()\n    self.configure_packages()\n\n  def set_env(self):\n    \"\"\"The function \"set_env\" sets the project environment to the platform specification.\"\"\"\n    os.environ[\"PLATFORM\"] = self.platform\n\n  def configure_packages(self):\n    \"\"\"The function \"configure_packages\" configures the project packages for the given environment and targets.\\nIt sets the target and platform environment variables, and then runs the \"configure\" script for each project package.\\nFinally, it returns the configured instance.\"\"\"\n    if self.targets:\n      os.environ[\"TARGETS\"] = \",\".join(self.targets)\n    os.environ[\"PLATFORM\"] = self.platform\n    for package in packages:\n      if self.autoinstall:\n        if not os.path.isdir(package):\n          os.mkdir(package)\n      if not os.path.isdir(os.path.join(package, \"build\")):\n        os.mkdir(os.path.join(package, \"build\"))\n      os.chdir(package)\n      os.system(\"bash configure\")\n      os.chdir(\"..\")", "CodeBleu_score": 28.529889628175976}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if env not in envs:\n      raise UndefinedEnvError(env)\n    spec = envs[env]\n    if not targets:\n      targets = spec.targets\n    return cls(spec, autoinstall=autoinstall, targets=targets)\n\n  def __init__(self, spec, autoinstall=False, targets=None):\n    \"\"\"The constructor of the class \"ProjectEnv\" takes the following arguments:\\nspec: the platform specification for the environment.\\nautoinstall: a boolean value that specifies whether the project packages should be automatically installed.\\ntargets: a list of target names that specifies the list of targets for which the project packages should be configured.\"\"\"\n    self.spec = spec\n    self.autoinstall = autoinstall\n    self.targets = targets\n    self.pkgs = {}\n    self.pkgs_config = {}\n    self.pkg_config = {}\n    self.pkg_config_targets = {}\n    self.pkg_config_targets_config = {}\n    self.pkg_config_targets_config_pkg = {}\n    self.pkg_config_targets_config_pkg_config = {}\n    self.pkg_config_targets_config_pkg_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config_config_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config_config_config_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config_config_config_config_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config_config_config_config_config_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config_config_config_config_config_config_config_config = {}\n    self.pkg_config_targets_config_pkg_config_config_config_config_config_config_config_config_config_config_config = {}\n    self.pkg_config_targets_config_", "CodeBleu_score": 25.752643439900837}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tuint8_t AddrH = Addr >> 8;\n\tuint8_t AddrL = Addr;\n\tuint8_t SizeH = Size >> 8;\n\tuint8_t SizeL = Size;\n\tuint8_t Data[3] = {AddrH, AddrL, SizeL};\n\tI2C_Write(0x34, 3, Data);\n\tI2C_Read(0x34, Size, Buff);\n}\n", "CodeBleu_score": 26.38231188852258}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tuint8_t i = 0;\n\tWire.beginTransmission(AXP192_SLAVE_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_SLAVE_ADDRESS, Size);\n\twhile (Wire.available()) {\n\t\tBuff[i] = Wire.read();\n\t\ti++;\n\t}\n}\n", "CodeBleu_score": 47.88271760531841}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}\n", "CodeBleu_score": 66.24655420137682}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us)\tSetSleep();\n\tif (time_in_us) {\n\t\tSetTimer(time_in_us);\n\t}\n\tInitiateDeepSleep();\n}\n", "CodeBleu_score": 33.32681153259804}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)\tif (time_in_us > 0) {\n\t\tSetSleep(true, true);\n\t\tSetSleepTimer(time_in_us);\n\t\tSetSleep(true, false);\n\t} else {\n\t\tSetSleep(true, true);\n\t\tSetSleep(true, false);\n\t}\n}\n", "CodeBleu_score": 40.299212372704986}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)\tSetSleep(time_in_us);\n\tif (time_in_us > 0) {\n\t\tEnableTimerWakeup(time_in_us);\n\t} else {\n\t\tDisableTimerWakeup();\n\t}\n\tInitiateDeepSleep();\n}\n", "CodeBleu_score": 52.01626233623351}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)\tint y = get_y();\n\tint height = get_height();\n\tint width = get_width();\n\tint top = get_top();\n\tint bottom = get_bottom();\n\tint left = get_left();\n\tint right = get_right();\n\tint x = get_x();\n\tint scroll_address = get_scroll_address();\n\n\tif (y + height > bottom) {\n\t\tif (tteBar) {\n\t\t\ty = top;\n\t\t} else {\n\t\t\ty = bottom - height;\n\t\t}\n\t} else {\n\t\ty += height;\n\t}\n\n\tif (y + height > bottom) {\n\t\tif (tteBar) {\n\t\t\ty = top;\n\t\t} else {\n\t\t\ty = bottom - height;\n\t\t}\n\t} else {\n\t\ty += height;\n\t}\n\n\tif (y + height > bottom) {\n\t\tif (tteBar) {\n\t\t\ty = top;\n\t\t} else {\n\t\t\ty = bottom - height;\n\t\t}\n\t} else {\n\t\ty += height;\n\t}\n\n\tif (y + height > bottom) {\n\t\tif (tteBar) {\n\t\t\ty = top;\n\t\t} else {\n\t\t\ty = bottom - height;\n\t\t}\n\t} else {\n\t\ty += height;\n\t}\n\n\tif (y + height > bottom) {\n\t\tif (tteBar) {\n\t\t\ty = top;\n\t\t} else {\n\t\t\ty = bottom - height;\n\t\t}\n\t} else {\n\t\ty += height;\n\t}\n\n\tif (y + height > bottom) {\n\t\tif (tteBar) {\n\t\t\ty = top;\n\t\t} else {\n\t\t\ty = bottom - height;\n\t\t}\n\t} else {\n\t\ty += height;\n\t}\n\n\tif (y + height > bottom) {\n\t\tif (tteBar) {\n\t\t\ty = top;\n\t\t} else {\n\t\t\ty = bottom - height;\n\t\t}\n\t} else {\n\t\ty += height;\n\t}\n\n\tif (y + height > bottom) {\n\t\tif (tteBar) {\n\t\t\ty = top;\n\t\t} else {\n\t\t\ty = bottom - height;\n\t\t}\n\t", "CodeBleu_score": 20.155087370301516}, {"code": "int Display::scroll_line(uint32_t color)\tint y;\n\tif (tteBar) {\n\t\ty = (scrollAddr + 1) % (DISPLAY_HEIGHT - 1);\n\t} else {\n\t\ty = (scrollAddr + 1) % DISPLAY_HEIGHT;\n\t}\n\tif (y == 0) {\n\t\ty = DISPLAY_HEIGHT - 1;\n\t}\n\tdisplay.fillRect(0, y, DISPLAY_WIDTH, 1, color);\n\tscrollAddr = y;\n\treturn y;\n}\n", "CodeBleu_score": 13.178696947574775}, {"code": "int Display::scroll_line(uint32_t color)\tint y = start_y;\n\tint x = start_x;\n\tint w = width;\n\tint h = height;\n\n\tif (tteBar) {\n\t\ty = 0;\n\t\th = 16;\n\t}\n\n\tint y_old = y;\n\ty += h;\n\tif (y > h - 1) {\n\t\ty -= h;\n\t}\n\n\tif (tteBar) {\n\t\ty += 16;\n\t}\n\n\tif (color == 0) {\n\t\tcolor = 0x000000;\n\t}\n\n\tint i;\n\tfor (i = 0; i < w; i++) {\n\t\tdraw_pixel(x + i, y, color);\n\t}\n\n\tstart_y = y;\n\treturn y_old;\n}\n", "CodeBleu_score": 22.447644395038992}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\tif (!setup_access_points(access_points)) {\n\t\treturn false;\n\t}\n\tif (!setup_html()) {\n\t\treturn false;\n\t}\n\tif (!setup_ssids(ssids)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 53.431147594138615}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\t// create access point list\n\taccess_point_list = new LinkedList<AccessPoint>();\n\t// create ssid list\n\tssid_list = new LinkedList<ssid>();\n\n\t// iterate through all access points\n\tfor (int i = 0; i < access_points->size(); i++) {\n\t\t// add access point to list\n\t\taccess_point_list->add(access_points->get(i));\n\t}\n\n\t// iterate through all ssids\n\tfor (int i = 0; i < ssids->size(); i++) {\n\t\t// add ssid to list\n\t\tssid_list->add(ssids->get(i));\n\t}\n\n\t// setup access points\n\tif (!setupAccessPoints()) {\n\t\t// if setting access points fails, return false\n\t\treturn false;\n\t}\n\n\t// setup html content\n\tif (!setupHTML()) {\n\t\t// if setting html content fails, return false\n\t\treturn false;\n\t}\n\n\t// start portal\n\tportal.begin();\n\n\t// return true\n\treturn true;\n}\n", "CodeBleu_score": 47.566511501665154}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\t// set up access points\n\tif (!setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\t// set up HTML content\n\tif (!setupHTMLContent(ssids)) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\treturn start();\n}\n", "CodeBleu_score": 52.95852040889919}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue()\tif (!queue_enabled_flag) {\n\t\t// flush the queue\n\t\twhile (gps_queue.pop_front())\n\t\t\t;\n\n\t\t// initialize the queue\n\t\ttext = \"\";\n\t\ttext_in = \"\";\n\t\tqueue_enabled_flag = true;\n\t}\n}\n", "CodeBleu_score": 5.62400470499387}, {"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\tqueue.clear();\n\t\ttext.clear();\n\t\ttext_in.clear();\n\t} else {\n\t\tqueue.clear();\n\t\tqueue_enabled_flag = true;\n\t}\n}\n", "CodeBleu_score": 7.95337596124766}, {"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\tqueue.flush();\n\t\ttext.clear();\n\t\ttext_in.clear();\n\t} else {\n\t\tqueue_enabled_flag = true;\n\t}\n}\n", "CodeBleu_score": 7.258096975158964}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea()\tif (queue_nmea) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\n\tqueue_nmea = new Queue<NmeaSentence>();\n}\n", "CodeBleu_score": 37.73357136582445}, {"code": "void GpsInterface::flush_queue_nmea()\tif (gps_nmea_queue!= NULL) {\n\t\tdelete gps_nmea_queue;\n\t\tgps_nmea_queue = NULL;\n\t}\n\tgps_nmea_queue = new Queue<char*>();\n}\n", "CodeBleu_score": 34.574110621332984}, {"code": "void GpsInterface::flush_queue_nmea()\tif (this->queue_nmea!= nullptr) {\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = nullptr;\n\t}\n\tthis->queue_nmea = new Queue<NmeaSentence>();\n}\n", "CodeBleu_score": 17.58382501002222}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)\tuint32_t start_x = area->x1;\n\tuint32_t start_y = area->y1;\n\tuint32_t end_x = area->x2;\n\tuint32_t end_y = area->y2;\n\n\tuint32_t x, y;\n\tuint32_t x_end = end_x - start_x;\n\tuint32_t y_end = end_y - start_y;\n\n\tuint32_t x_offset = start_x % 8;\n\tuint32_t y_offset = start_y % 8;\n\n\tuint32_t x_bytes = x_end / 8;\n\tuint32_t y_bytes = y_end / 8;\n\n\tuint32_t x_start = start_x / 8;\n\tuint32_t y_start = start_y / 8;\n\n\tuint32_t x_end_byte = x_start + x_bytes;\n\tuint32_t y_end_byte = y_start + y_bytes;\n\n\tuint32_t x_end_bit = x_end % 8;\n\tuint32_t y_end_bit = y_end % 8;\n\n\tuint32_t x_end_bit_mask = 0xFF >> x_end_bit;\n\tuint32_t y_end_bit_mask = 0xFF >> y_end_bit;\n\n\tuint32_t x_start_byte = x_start;\n\tuint32_t y_start_byte = y_start;\n\n\tuint32_t x_end_byte_mask = 0xFF;\n\tuint32_t y_end_byte_mask = 0xFF;\n\n\tif (x_end_bit!= 0) {\n\t\tx_end_byte_mask = x_end_bit_mask;\n\t}\n\tif (y_end_bit!= 0) {\n\t\ty_end_byte_mask = y_end_bit_mask;\n\t}\n\n\tuint32_t x_start_bit = 0;\n\t", "CodeBleu_score": 28.78693238548123}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)\tuint32_t x, y;\n\tuint32_t w = (area->x2 - area->x1 + 1);\n\tuint32_t h = (area->y2 - area->y1 + 1);\n\tuint32_t index = 0;\n\n\tmy_disp_start_write_transaction();\n\n\tmy_disp_set_address_window(area->x1, area->y1, w, h);\n\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tmy_disp_write_pixel(x, y, color_p[index++]);\n\t\t}\n\t}\n\n\tmy_disp_end_write_transaction();\n\n\tlv_disp_flush_ready(disp);\n}\n", "CodeBleu_score": 49.56078377106643}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)\tuint32_t i;\n\tuint32_t x_length = area->x2 - area->x1 + 1;\n\tuint32_t y_length = area->y2 - area->y1 + 1;\n\tuint32_t x_offset = area->x1;\n\tuint32_t y_offset = area->y1;\n\tuint32_t x_index = 0;\n\tuint32_t y_index = 0;\n\tuint32_t index = 0;\n\tuint32_t x_end = x_length - 1;\n\tuint32_t y_end = y_length - 1;\n\tuint32_t x_start = 0;\n\tuint32_t y_start = 0;\n\tuint32_t x_pos = 0;\n\tuint32_t y_pos = 0;\n\tuint32_t x_end_pos = 0;\n\tuint32_t y_end_pos = 0;\n\tuint32_t x_start_pos = 0;\n\tuint32_t y_start_pos = 0;\n\tuint32_t x_index_pos = 0;\n\tuint32_t y_index_pos = 0;\n\tuint32_t index_pos = 0;\n\tuint32_t x_end_index = 0;\n\tuint32_t y_end_index = 0;\n\tuint32_t x_start_index = 0;\n\tuint32_t y_start_index = 0;\n\tuint32_t x_index_index = 0;\n\tuint32_t y_index_index = 0;\n\tuint32_t index_index = 0;\n\tuint32_t x_end_index_index = 0;\n\tuint32_t y_end_index_index = 0;\n\tuint32_t x_start_index_index = 0;\n\tuint32_t y_start_index_index = 0;", "CodeBleu_score": 20.946251272247935}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tif (menu!= NULL) {\n\t\tfor (int i = 0; i < menu->getMenuSize(); i++) {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tcout << \"\\t\";\n\t\t\t}\n\t\t\tcout << menu->getMenuNode(i)->getName() << endl;\n\t\t\tif (menu->getMenuNode(i)->getSubMenu()!= NULL) {\n\t\t\t\tshowMenuList(menu->getMenuNode(i)->getSubMenu(), layer + 1);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n", "CodeBleu_score": 43.62756550783518}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tif (menu == NULL) {\n\t\treturn;\n\t}\n\tMenu * temp = menu->next;\n\twhile (temp!= NULL) {\n\t\tfor (int i = 0; i < layer; i++) {\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << temp->name << endl;\n\t\ttemp = temp->next;\n\t}\n\tcout << endl;\n}\n", "CodeBleu_score": 44.22520319165779}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tif (menu == NULL) {\n\t\tcout << \"Menu is empty.\" << endl;\n\t}\n\telse {\n\t\tfor (int i = 0; i < menu->getSize(); i++) {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tcout << \"\\t\";\n\t\t\t}\n\t\t\tcout << menu->getMenuNode(i)->getName() << endl;\n\t\t\tif (menu->getMenuNode(i)->getChild()!= NULL) {\n\t\t\t\tshowMenuList(menu->getMenuNode(i)->getChild(), layer + 1);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n", "CodeBleu_score": 44.18212534930975}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count)\tint ssidCount = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char) random(32, 126);\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tmac += (char) random(32, 126);\n\t\t}\n\t\tmac += \":\";\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tmac += (char) random(32, 126);\n\t\t}\n\t\tmac += \":\";\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tmac += (char) random(32, 126);\n\t\t}\n\t\tSerial.printf(\"SSID: %s, channel: %d, MAC: %s\\n\", ssid.c_str(), channel, mac.c_str());\n\t\tWiFi.softAP(ssid.c_str(), \"\", channel, false, 1, mac.c_str());\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}\n", "CodeBleu_score": 42.48878650900554}, {"code": "int WiFiScan::generateSSIDs(int count)\tint ssids = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char) random(97, 123);\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 17; j++) {\n\t\t\tmac += (char) random(48, 58);\n\t\t\tif (j == 2 || j == 5 || j == 8 || j == 11 || j == 14) {\n\t\t\t\tmac += \":\";\n\t\t\t}\n\t\t}\n\t\tWiFi.softAP(ssid.c_str(), \"\", channel, false, 4);\n\t\tWiFi.softAPmacAddress(mac.c_str());\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.println(ssid);\n\t\tSerial.print(\"Channel: \");\n\t\tSerial.println(channel);\n\t\tSerial.print(\"MAC: \");\n\t\tSerial.println(mac);\n\t\tssids++;\n\t}\n\treturn ssids;\n}\n", "CodeBleu_score": 41.823087102617485}, {"code": "int WiFiScan::generateSSIDs(int count)\t// Generate a list of SSIDs\n\tstd::vector<std::string> ssids;\n\tfor (int i = 0; i < count; i++) {\n\t\t// Create a random SSID\n\t\tchar ssid[7];\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid[j] = (char) random(33, 126);\n\t\t}\n\t\tssid[6] = '\\0';\n\t\t// Add the SSID to the list\n\t\tssids.push_back(ssid);\n\t}\n\t// Print the list of SSIDs\n\tfor (int i = 0; i < ssids.size(); i++) {\n\t\tSerial.print(ssids[i]);\n\t\tSerial.print(\" \");\n\t}\n\tSerial.println();\n\t// Return the number of SSIDs\n\treturn ssids.size();\n}\n", "CodeBleu_score": 37.69731423046748}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\n    # Initialize a PublisherClient\n    publisher_client = pubsub_v1.PublisherClient()\n\n    # Construct the topic path using the provided project ID and topic name\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n\n    # Create the topic\n    topic = publisher_client.create_topic(name=topic_path)\n\n    # Print confirmation message with the topic details\n    print(f\"Topic {topic.name} created successfully.\")\n\n", "CodeBleu_score": 34.22879043268211}, {"code": "def create_topic(project_id, topic_name)\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = pubsub_v1.Topic(name=topic_path)\n    topic = publisher.create_topic(request={\"name\": topic_path, \"topic\": topic})\n    print(f\"Topic {topic.name} created.\")\n\n", "CodeBleu_score": 47.85826721189811}, {"code": "def create_topic(project_id, topic_name)\n\n    # Initialize a PublisherClient\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the topic path using the provided project ID and topic name\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    # Print the topic details\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 53.46263551943253}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n    token = {\n        'iat': datetime.utcnow(),\n        'exp': datetime.utcnow() + timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 47.027021235383295}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n    # Create a JWT using the given project ID and private key\n    token = {\n        'iat': datetime.utcnow(),\n        'exp': datetime.utcnow() + timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 47.027021235383295}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n    now = datetime.datetime.utcnow()\n    m = math.floor(now.timestamp())\n    exp = math.ceil(m + 3600)\n    iat = math.floor(m)\n    jwt = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": project_id\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    encoded_jwt = jwt.encode(jwt, private_key, algorithm=algorithm)\n    return encoded_jwt\n\n", "CodeBleu_score": 45.87653658563451}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n    # If the message's payload is \"on\", capture a preview image and upload it to a specified bucket.\n    if message.payload == b\"on\":\n        # Capture a preview image.\n        preview = camera.capture_preview()\n        # Upload the preview image to a specified bucket.\n        preview_url = upload_file_to_bucket(preview)\n        # Publish the preview image's URL to an MQTT event topic.\n        client.publish(preview_event_topic, preview_url)\n    # If the message's payload is not \"on\", print \"off\".\n    elif message.payload!= b\"on\":\n        print(\"off\")\n\n", "CodeBleu_score": 19.630905380376284}, {"code": "def on_message(unused_client, unused_userdata, message)\n    # Print the received message's payload, topic, and QoS.\n    print(\"Received message on topic '{}': {}\".format(message.topic, message.payload))\n    # If the payload is \"on\", capture a preview image, upload the file to a specified bucket, and publish the file's URL to an MQTT event topic.\n    if message.payload == b'on':\n        # Capture a preview image.\n        preview_image = camera.capture()\n        # Upload the file to a specified bucket.\n        bucket_name = 'iot-camera-bucket'\n        file_name = 'preview.jpg'\n        upload_file(bucket_name, file_name, preview_image)\n        # Publish the file's URL to an MQTT event topic.\n        event_topic = 'events/camera'\n        event_message = 'Preview image uploaded to'+ bucket_name + '/' + file_name\n        publish_event(event_topic, event_message)\n    # If the payload is not \"on\", simply print \"off\".\n    else:\n        print(\"off\")\n", "CodeBleu_score": 30.075031870546344}, {"code": "def on_message(unused_client, unused_userdata, message)\n    if message.topic == \"devices/myDevice/events/myEvent\":\n        print(\"Message received: \" + str(message.payload.decode(\"utf-8\")))\n        print(\"From topic: \" + message.topic)\n        print(\"QoS: \" + str(message.qos))\n        if str(message.payload.decode(\"utf-8\")) == \"on\":\n            # Capture a preview image\n            preview = camera.capture_preview()\n            # Upload the preview image to a specified bucket\n            upload_to_cloud(preview, \"myBucket\")\n            # Publish the URL of the uploaded file to an MQTT event topic\n            publish_event(\"https://storage.googleapis.com/myBucket/myImage.jpg\")\n        else:\n            print(\"off\")\n    else:\n        print(\"Message received: \" + str(message.payload.decode(\"utf-8\")))\n        print(\"From topic: \" + message.topic)\n        print(\"QoS: \" + str(message.qos))\n\n", "CodeBleu_score": 34.28280100917471}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection.')\n    parser.add_argument('--project_id', help='Google Cloud project ID.')\n    parser.add_argument('--subscription_name', help='Google Cloud Pub/Sub subscription name.')\n    args = parser.parse_args()\n    if not args.project_id:\n        args.project_id = os.getenv('GOOGLE_CLOUD_PROJECT')\n    return args\n\n", "CodeBleu_score": 43.60141027193966}, {"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"Google Cloud project ID\",\n    )\n    parser.add_argument(\n        \"--subscription_name\",\n        default=os.environ.get(\"SUBSCRIPTION_NAME\"),\n        help=\"Google Cloud Pub/Sub subscription name\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        default=os.environ.get(\"REGISTRY_ID\"),\n        help=\"Google Cloud IoT Core registry ID\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        default=os.environ.get(\"DEVICE_ID\"),\n        help=\"Google Cloud IoT Core device ID\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=os.environ.get(\"PRIVATE_KEY_FILE\"),\n        help=\"Path to private key file\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        default=os.environ.get(\"ALGORITHM\"),\n        help=\"Algorithm used to generate the authentication JWT\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=os.environ.get(\"CA_CERTS\"),\n        help=\"Path to CA certificate(s) for verifying the MQTT server\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=os.environ.get(\"MQTT_BRIDGE_HOSTNAME\"),\n        help=\"MQTT bridge hostname\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        default=os.environ.get(\"MQTT_BRIDGE_PORT\"),\n        help=\"MQTT bridge port\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_topic\",\n        default=os.environ.get(\"MQTT_BRIDGE_TOPIC\"),\n        help=\"MQTT bridge topic\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_username\",\n        default=os.environ.get(\"MQTT_BRIDGE_USERNAME\"),\n        help=\"MQTT bridge username\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_password\",\n        default=os.environ.get(\"MQTT_BRIDGE_PASSWORD\"),\n        help=\"MQTT bridge password\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_client_", "CodeBleu_score": 39.045569496784914}, {"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection')\n    parser.add_argument('--project_id', help='Google Cloud project ID')\n    parser.add_argument('--subscription_name', help='Google Cloud Pub/Sub subscription name')\n    parser.add_argument('--device_id', help='Google Cloud IoT device ID')\n    parser.add_argument('--registry_id', help='Google Cloud IoT registry ID')\n    parser.add_argument('--private_key_file', help='Path to private key file')\n    parser.add_argument('--algorithm', help='Algorithm used for signing')\n    parser.add_argument('--ca_certs', help='Path to CA root certificates')\n    parser.add_argument('--cloud_region', help='Google Cloud region')\n    parser.add_argument('--mqtt_bridge_hostname', help='MQTT bridge hostname')\n    parser.add_argument('--mqtt_bridge_port', help='MQTT bridge port')\n    parser.add_argument('--mqtt_bridge_topic', help='MQTT bridge topic')\n    parser.add_argument('--mqtt_bridge_username', help='MQTT bridge username')\n    parser.add_argument('--mqtt_bridge_password', help='MQTT bridge password')\n    parser.add_argument('--mqtt_bridge_use_tls', help='Use TLS for MQTT bridge connection')\n    parser.add_argument('--mqtt_bridge_ca_certs', help='Path to CA root certificates for MQTT bridge')\n    parser.add_argument('--mqtt_bridge_tls_version', help='TLS version for MQTT bridge connection')\n    parser.add_argument('--mqtt_bridge_tls_ciphers', help='TLS ciphers for MQTT bridge connection')\n    parser.add_argument('--mqtt_bridge_tls_insecure', help='Disable host name verification for MQTT bridge connection')\n    parser.add_argument('--mqtt_bridge_client_id', help='MQTT bridge client ID')\n    parser.add_argument('--mqtt_bridge_bridge_hostname', help='MQTT bridge bridge hostname')\n    parser.add_argument('--mqtt_bridge_bridge_port', help='MQTT bridge bridge port')\n    parser.add_argument('--mqtt_bridge_bridge_topic', help='MQTT bridge bridge topic')\n    parser.add_argument('--mqtt_bridge_bridge_username', help='MQTT bridge bridge username')\n    parser.add_argument('--mqtt_bridge_bridge_password", "CodeBleu_score": 23.32171476760775}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n    # Create the client for the Google Cloud IoT Core service\n    client = discovery.build('cloudiot', 'v1', credentials=service_account.Credentials.from_service_account_file(service_account_json), discoveryServiceUrl='https://cloudiot.googleapis.com/$discovery/rest')\n    return client\n\n", "CodeBleu_score": 9.57967730850062}, {"code": "def get_client(service_account_json)\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(SCOPES)\n    client = discovery.build(API_SERVICE_NAME, API_VERSION, credentials=scoped_credentials, discoveryServiceUrl=DISCOVERY_URL)\n    return client\n", "CodeBleu_score": 10.11374394494221}, {"code": "def get_client(service_account_json)\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(\n        ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/cloudiot'])\n    client = discovery.build('cloudiot', 'v1', credentials=scoped_credentials, cache_discovery=False)\n    return client\n", "CodeBleu_score": 18.5421724374606}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n    if hash_method == \"sha1\":\n        hash_method_asn1 = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\"\n    elif hash_method == \"sha256\":\n        hash_method_asn1 = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    else:\n        raise ValueError(\"Invalid hash method\")\n    hash_method_asn1 += hash_value\n    hash_method_asn1 = pkcs1_padding(hash_method_asn1)\n    signature = rsa.encrypt(hash_method_asn1, priv_key)\n    return signature\n\n", "CodeBleu_score": 26.01429459938698}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    if hash_method == 'SHA-1':\n        hash_asn1 = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'SHA-256':\n        hash_asn1 = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    else:\n        raise ValueError('Invalid hash method')\n    hash_value_asn1 = hash_asn1 + hash_value\n    padded_hash = pkcs1_pad(hash_value_asn1, 256)\n    signature = rsa_encrypt(padded_hash, priv_key)\n    return signature\n", "CodeBleu_score": 23.500771883323402}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    try:\n        hash_method_asn1 = get_hash_method_asn1(hash_method)\n    except ValueError:\n        raise ValueError(\"Invalid hash method\")\n    hash_value = hash_method_asn1 + hash_value\n    hash_value = pad_hash(hash_value)\n    signature = priv_key.sign(hash_value, ec.ECDSA(hash_method))\n    return signature\n", "CodeBleu_score": 29.534826427355725}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n    # Convert the signature to an integer\n    sig = int.from_bytes(signature, byteorder='big')\n    # Decrypt the signature to obtain the clear signature\n    clear_sig = pow(sig, pub_key.d, pub_key.n)\n    # Determine the hash method used\n    if pub_key.hash_method == \"SHA-256\":\n        # Compute the hash of the message\n        hash_method = hashlib.sha256()\n        hash_method.update(message)\n        # Reconstruct the expected padded hash\n        padded_hash = (pub_key.n - 1 - hash_method.digest()) % pub_key.n\n        # Verify the signature\n        if clear_sig == padded_hash:\n            return pub_key.hash_method\n        else:\n            raise ValueError(\"Signature verification failed\")\n    elif pub_key.hash_method == \"SHA-384\":\n        # Compute the hash of the message\n        hash_method = hashlib.sha384()\n        hash_method.update(message)\n        # Reconstruct the expected padded hash\n        padded_hash = (pub_key.n - 1 - hash_method.digest()) % pub_key.n\n        # Verify the signature\n        if clear_sig == padded_hash:\n            return pub_key.hash_method\n        else:\n            raise ValueError(\"Signature verification failed\")\n    elif pub_key.hash_method == \"SHA-512\":\n        # Compute the hash of the message\n        hash_method = hashlib.sha512()\n        hash_method.update(message)\n        # Reconstruct the expected padded hash\n        padded_hash = (pub_key.n - 1 - hash_method.digest()) % pub_key.n\n        # Verify the signature\n        if clear_sig == padded_hash:\n            return pub_key.hash_method\n        else:\n            raise ValueError(\"Signature verification failed\")\n\n", "CodeBleu_score": 25.886272765941815}, {"code": "def verify(message, signature, pub_key)\n    try:\n        # Convert the signature to an integer\n        sig = int.from_bytes(signature, 'big')\n        # Decrypt the signature\n        clear_sig = pow(sig, pub_key.e, pub_key.n)\n        # Determine the hash method used\n        if pub_key.hash_method == 'SHA-1':\n            # Compute the hash of the message\n            hash_method = hashlib.sha1()\n            hash_method.update(message)\n            # Reconstruct the padded hash\n            padded_hash = int.from_bytes(hash_method.digest(), 'big')\n        elif pub_key.hash_method == 'SHA-256':\n            # Compute the hash of the message\n            hash_method = hashlib.sha256()\n            hash_method.update(message)\n            # Reconstruct the padded hash\n            padded_hash = int.from_bytes(hash_method.digest(), 'big')\n        elif pub_key.hash_method == 'SHA-512':\n            # Compute the hash of the message\n            hash_method = hashlib.sha512()\n            hash_method.update(message)\n            # Reconstruct the padded hash\n            padded_hash = int.from_bytes(hash_method.digest(), 'big')\n        else:\n            raise ValueError('Invalid hash method')\n        # Check if the expected padded hash matches the clear signature\n        if clear_sig == padded_hash:\n            return pub_key.hash_method\n        else:\n            raise ValueError('Invalid signature')\n    except ValueError as err:\n        raise err\n\n", "CodeBleu_score": 31.355201616781525}, {"code": "def verify(message, signature, pub_key)\n    try:\n        # Convert the signature to an integer\n        signature = int(signature)\n        # Decrypt the signature\n        clear_signature = pub_key.decrypt(signature)\n        # Determine the hash method used\n        hash_method = pub_key.hash_method\n        # Compute the hash of the message\n        hash_value = hash_method(message)\n        # Reconstruct the expected padded hash\n        expected_padded_hash = hash_method.new(hash_value).digest()\n        # Check the validity of the signature\n        if expected_padded_hash!= clear_signature:\n            raise Exception(\"Signature verification failed.\")\n        else:\n            return hash_method.name\n    except Exception as e:\n        print(e)\n", "CodeBleu_score": 33.1541288977826}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT()\t// Get the current time\n\ttime_t now = time(NULL);\n\t// Check if the time is valid\n\tif (now!= -1) {\n\t\t// Update the JWT using the current UNIX time format\n\t\tupdateJWT(now);\n\t\t// Call the function to connect to the MQTT client\n\t\tconnectMQTTClient();\n\t\t// Set a flag to send an MQTT SUBSCRIBE packet after the connection is established\n\t\tsubscribeMQTT = true;\n\t\t// Print a debug message indicating the MQTT connection attempt\n\t\tprintf(\"MQTT connection attempt\\n\");\n\t}\n}\n", "CodeBleu_score": 22.48757124550792}, {"code": "static void connectMQTT()\tuint32_t current_time = get_current_time();\n\tif (current_time > 0) {\n\t\tupdate_jwt(current_time);\n\t}\n\n\tif (connect_mqtt_client() == 0) {\n\t\tmqtt_subscribe_flag = 1;\n\t\tDEBUG_PRINT(\"MQTT connection established.\\n\");\n\t} else {\n\t\tDEBUG_PRINT(\"MQTT connection failed.\\n\");\n\t}\n}\n", "CodeBleu_score": 14.648496183069456}, {"code": "static void connectMQTT()\tif (isValidTime()) {\n\t\tupdateJWT();\n\t}\n\tconnectMQTTClient();\n\tmqtt_subscribe_flag = 1;\n\tprintf(\"MQTT connection attempt...\\n\");\n}\n", "CodeBleu_score": 10.136676845210266}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (str[i] - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}\n", "CodeBleu_score": 21.106283063498804}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t result = 0;\n\twhile (width-- > 0) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + (*str - '0');\n\t\tstr++;\n\t}\n\t*num = result;\n\treturn str;\n}\n", "CodeBleu_score": 21.425142874473252}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t result = 0;\n\tuint32_t digit;\n\twhile (width > 0) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tdigit = *str - '0';\n\t\tif (result > (UINT32_MAX - digit) / 10) {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + digit;\n\t\tstr++;\n\t\twidth--;\n\t}\n\t*num = result;\n\treturn str;\n}\n", "CodeBleu_score": 27.386257661527214}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = 0;\n\tuint8_t* cert_data = NULL;\n\tuint16_t cert_data_size = 0;\n\tuint8_t* cert_data_ptr = NULL;\n\tuint16_t cert_data_remaining = 0;\n\tuint8_t* cert_data_end = NULL;\n\tuint8_t* cert_data_start = NULL;\n\tuint16_t cert_data_length = 0;\n\tuint8_t* cert_data_length_ptr = NULL;\n\tuint8_t* cert_data_length_end = NULL;\n\tuint8_t* cert_data_length_start = NULL;\n\tuint8_t* cert_data_type = NULL;\n\tuint8_t* cert_data_type_end = NULL;\n\tuint8_t* cert_data_type_start = NULL;\n\tuint8_t* cert_data_value = NULL;\n\tuint8_t* cert_data_value_end = NULL;\n\tuint8_t* cert_data_value_start = NULL;\n\tuint8_t* cert_data_value_length = NULL;\n\tuint8_t* cert_data_value_length_end = NULL;\n\tuint8_t* cert_data_value_length_start = NULL;\n\tuint8_t* cert_data_value_length_ptr = NULL;\n\tuint8_t* cert_data_value_length_end_ptr = NULL;\n\tuint8_t* cert_data_value_ptr = NULL;\n\tuint8_t* cert_data_value_end_ptr = NULL;\n\tuint8_t* cert_data_value_start_ptr = NULL;\n\tuint8_t* cert_data_value_length_start_ptr = NULL;\n\tuint8_t* cert_data_value_length_end_ptr = NULL;\n\tuint8_t* cert_data_value_length_ptr_ptr = NULL;\n\tuint8_t* cert_data_value_length_end_ptr_ptr = NULL;\n\tuint8_t* cert_data_value_ptr", "CodeBleu_score": 9.446500217208776}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = 0;\n\tuint8_t* cert_data = build_state->cert_data;\n\tuint8_t* cert_data_end = cert_data + build_state->cert_data_size;\n\tuint8_t* cert_data_end_orig = cert_data_end;\n\tuint8_t* cert_data_end_orig_orig = cert_data_end_orig;\n\tuint8_t* cert_data_orig = cert_data;\n\tuint8_t* cert_data_orig_orig = cert_data_orig;\n\tuint8_t* cert_data_orig_orig_orig = cert_data_orig_orig;\n\tuint8_t* cert_data_orig_orig_orig_orig = cert_data_orig_orig_orig;\n\tuint8_t* cert_data_orig_orig_orig_orig_orig = cert_data_orig_orig_orig_orig;\n\tuint8_t* cert_data_orig_orig_orig_orig_orig_orig = cert_data_orig_orig_orig_orig_orig;\n\tuint8_t* cert_data_orig_orig_orig_orig_orig_orig_orig = cert_data_orig_orig_orig_orig_orig_orig;\n\tuint8_t* cert_data_orig_orig_orig_orig_orig_orig_orig_orig = cert_data_orig_orig_orig_orig_orig_orig_orig;\n\tuint8_t* cert_data_orig_orig_orig_orig_orig_orig_orig_orig_orig = cert_data_orig_orig_orig_orig_orig_orig_orig_orig;\n\tuint8_t* cert_data_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig = cert_data_orig_orig_orig_orig_orig_orig_orig_orig_orig;\n\tuint8_t* cert_data_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig = cert_data_orig_orig_orig_orig_orig_orig_orig_orig_orig_orig;\n\tuint8_t", "CodeBleu_score": 9.219068948625484}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint result = ATCACERT_E_SUCCESS;\n\tint ret_val = 0;\n\tuint8_t* der_data = NULL;\n\tuint8_t der_data_buf[ATCACERT_DER_MAX_SIZE];\n\tuint16_t der_data_size = 0;\n\tuint16_t der_data_size_max = ATCACERT_DER_MAX_SIZE;\n\tuint8_t* der_data_ptr = NULL;\n\tuint8_t* der_data_end = NULL;\n\tuint8_t* der_data_start = NULL;\n\tuint8_t* der_data_end_ptr = NULL;\n\tuint8_t* der_data_start_ptr = NULL;\n\tuint8_t* der_data_start_ptr_tmp = NULL;\n\tuint8_t* der_data_start_ptr_tmp2 = NULL;\n\tuint8_t* der_data_start_ptr_tmp3 = NULL;\n\tuint8_t* der_data_start_ptr_tmp4 = NULL;\n\tuint8_t* der_data_start_ptr_tmp5 = NULL;\n\tuint8_t* der_data_start_ptr_tmp6 = NULL;\n\tuint8_t* der_data_start_ptr_tmp7 = NULL;\n\tuint8_t* der_data_start_ptr_tmp8 = NULL;\n\tuint8_t* der_data_start_ptr_tmp9 = NULL;\n\tuint8_t* der_data_start_ptr_tmp10 = NULL;\n\tuint8_t* der_data_start_ptr_tmp11 = NULL;\n\tuint8_t* der_data_start_ptr_tmp12 = NULL;\n\tuint8_t* der_data_start_ptr_tmp13 = NULL;\n\tuint8_t* der_data_start_ptr_tmp14 = NULL;\n\tuint8_t* der_data_start_ptr_tmp15 = NULL;\n\tuint8_t* der_data_start_ptr_tmp16 = NULL;\n\tuint8_t*", "CodeBleu_score": 8.805141479471187}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])#if defined(ATCA_SW_CRYPTO)\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    if (cert_size < cert_def->cert_template[ATCACERT_CERT_DATA_OFFSET] + sizeof(atcacert_cert_element_t)) {\n        return ATCA_BAD_PARAM;\n    }\n\n    // Get the TBS digest\n    uint8_t tbs_digest[ATCA_SHA2_256_DIGEST_SIZE];\n    int ret = atcacert_get_tbs_digest(cert_def, cert, tbs_digest);\n    if (ret!= ATCA_SUCCESS) {\n        return ret;\n    }\n\n    // Get the signature\n    uint8_t signature[ATCA_SHA2_256_DIGEST_SIZE];\n    ret = atcacert_get_signature(cert_def, cert, signature);\n    if (ret!= ATCA_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the signature\n    ret = atcacert_verify_signature(cert_def, tbs_digest, signature, ca_public_key);\n    if (ret!= ATCA_SUCCESS) {\n        return ret;\n    }", "CodeBleu_score": 60.5807799314594}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])\tint result = ATCACERT_E_SUCCESS;\n\tuint8_t tbs_digest[ATCA_SHA2_256_DIGEST_SIZE];\n\tuint8_t signature[ATCA_SHA2_256_DIGEST_SIZE];\n\tuint8_t temp_buf[ATCA_SHA2_256_DIGEST_SIZE];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tif (cert_size < cert_def->cert_template.cert_sn_size + cert_def->cert_template.cert_sig_size) {\n\t\treturn ATCACERT_E_BAD_CERT;\n\t}\n\n\t// Get the TBS digest\n\tresult = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (result!= ATCACERT_E_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t// Get the signature\n\tmemcpy(temp_buf, cert + cert_def->cert_template.cert_sn_size, cert_def->cert_template.cert_sig_size);\n\n\t// Verify the signature\n\tresult = atcacert_verify_sig(cert_def, tbs_digest, temp_buf, ca_public_key, signature);\n\tif (result!= ATCACERT_E_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t// Compare the signature to the expected signature\n\tresult = memcmp(temp_buf, signature, cert_def->cert_template.cert_sig_size);\n\tif (result!= 0) {\n\t\treturn ATCACERT_E_VERIFY_FAILED;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 55.80955853850096}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])#ifdef ATCACERT_VERIFY_CERT_HW_DEBUG\n    printf(\"atcacert_verify_cert_hw()\\n\");", "CodeBleu_score": 5.388765641603375}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\tif(list == NULL || timer == NULL) {\n\t\treturn false;\n\t}\n\tif(timer->next == NULL) {\n\t\treturn false;\n\t}\n\ttimerStruct_t *next = timer->next;\n\ttimer->next = next->next;\n\tnext->next = NULL;\n\treturn true;\n}\n}\n", "CodeBleu_score": 11.44039524104464}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\ttimerStruct_t * volatile *head = list;\n\ttimerStruct_t * volatile *prev = head;\n\ttimerStruct_t * volatile *curr = head;\n\n\twhile(curr!= NULL)\n\t{\n\t\tif(*curr == timer)\n\t\t{\n\t\t\t*prev = *curr;\n\t\t\treturn true;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = curr->next;\n\t}\n\treturn false;\n} }\n", "CodeBleu_score": 24.48873549770311}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\ttimerStruct_t * volatile *list_head = list;\n\ttimerStruct_t * volatile *list_next = &timer->next;\n\ttimerStruct_t * volatile *list_prev = &timer->prev;\n\ttimerStruct_t * volatile *list_prev_next = &timer->prev->next;\n\ttimerStruct_t * volatile *list_next_prev = &timer->next->prev;\n\n\tif (timer->next == timer) {\n\t\t*list_head = NULL;\n\t} else {\n\t\t*list_next_prev = timer->next;\n\t\t*list_prev_next = timer->prev;\n\t}\n\t*list_next = timer->next;\n\t*list_prev = timer->prev;\n\ttimer->next = NULL;\n\ttimer->prev = NULL;\n\treturn true;\n} }\n", "CodeBleu_score": 21.824047075762056}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket)\tBSD_socket_t *bsd_socket = BSD_get_socket(socket);\n\tif (bsd_socket == NULL) {\n\t\tBSD_errno = BSD_EBADF;\n\t\treturn BSD_ERROR;\n\t}\n\tbsd_socket->state = BSD_NOT_A_SOCKET;\n\tint result = close(socket);\n\tif (result == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tBSD_errno = BSD_EBADF;\n\t\t\t\tbreak;\n\t\t\tcase EINTR:\n\t\t\t\tBSD_errno = BSD_EINTR;\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\tBSD_errno = BSD_EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBSD_errno = BSD_EIO;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 46.70768025784315}, {"code": "int BSD_close(int socket)\tint status;\n\tstruct BSD_socket_info *socket_info = get_socket_info(socket);\n\n\tif (socket_info == NULL) {\n\t\terrno = EBADF;\n\t\treturn BSD_ERROR;\n\t}\n\n\tsocket_info->state = NOT_A_SOCKET;\n\n\tstatus = close(socket);\n\n\tif (status == -1) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = EBADF;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EINTR) {\n\t\t\terrno = EINTR;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EIO) {\n\t\t\terrno = EIO;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == ENOTSOCK) {\n\t\t\terrno = ENOTSOCK;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EPROTO) {\n\t\t\terrno = EPROTO;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EPERM) {\n\t\t\terrno = EPERM;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EFAULT) {\n\t\t\terrno = EFAULT;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EINVAL) {\n\t\t\terrno = EINVAL;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EISDIR) {\n\t\t\terrno = EISDIR;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == ELOOP) {\n\t\t\terrno = ELOOP;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == ENAMETOOLONG) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == ENOENT) {\n\t\t\terrno = ENOENT;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == ENOSYS) {\n\t\t\terrno = ENOSYS;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == ENOTDIR) {\n\t\t\terrno = ENOTDIR;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EROFS) {\n\t\t\terrno = EROFS;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == E", "CodeBleu_score": 39.547901516908965}, {"code": "int BSD_close(int socket)\tstruct sockaddr_in addr;\n\tint ret = 0;\n\n\t//Check if the socket is valid\n\tif (BSD_is_valid_socket(socket) == 0) {\n\t\treturn BSD_ERROR;\n\t}\n\n\t//Retrieve the socket information\n\tBSD_get_socket_info(socket, &addr);\n\n\t//Set the socket state to \"NOT_A_SOCKET\"\n\tBSD_set_socket_state(socket, NOT_A_SOCKET);\n\n\t//Call the close function\n\tret = close(socket);\n\n\t//Check if an error occurred\n\tif (ret == -1) {\n\t\t//Set the appropriate error number based on the error type\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tBSD_set_error(BSD_INVALID_SOCKET);\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\tBSD_set_error(BSD_INVALID_OPERATION);\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\tBSD_set_error(BSD_NOT_A_SOCKET);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBSD_set_error(BSD_UNKNOWN_ERROR);\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 47.180980038261765}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog)\tint response = listen(socket, backlog);\n\tif (response < 0) {\n\t\tif (errno == EBADF) {\n\t\t\tBSD_errno = BSD_EBADF;\n\t\t} else if (errno == EINVAL) {\n\t\t\tBSD_errno = BSD_EINVAL;\n\t\t} else if (errno == ENOTSOCK) {\n\t\t\tBSD_errno = BSD_ENOTSOCK;\n\t\t} else if (errno == EOPNOTSUPP) {\n\t\t\tBSD_errno = BSD_EOPNOTSUPP;\n\t\t} else if (errno == EACCES) {\n\t\t\tBSD_errno = BSD_EACCES;\n\t\t} else if (errno == EMFILE) {\n\t\t\tBSD_errno = BSD_EMFILE;\n\t\t} else if (errno == ENFILE) {\n\t\t\tBSD_errno = BSD_ENFILE;\n\t\t} else if (errno == ENOBUFS) {\n\t\t\tBSD_errno = BSD_ENOBUFS;\n\t\t} else if (errno == ENOMEM) {\n\t\t\tBSD_errno = BSD_ENOMEM;\n\t\t} else if (errno == EAFNOSUPPORT) {\n\t\t\tBSD_errno = BSD_EAFNOSUPPORT;\n\t\t} else if (errno == EPROTONOSUPPORT) {\n\t\t\tBSD_errno = BSD_EPROTONOSUPPORT;\n\t\t} else if (errno == EADDRINUSE) {\n\t\t\tBSD_errno = BSD_EADDRINUSE;\n\t\t} else if (errno == EADDRNOTAVAIL) {\n\t\t\tBSD_errno = BSD_EADDRNOTAVAIL;\n\t\t} else if (errno == ENETDOWN) {\n\t\t\tBSD_errno = BSD_ENETDOWN;\n\t\t} else if (errno == ENETUNREACH) {\n\t\t\tBSD_errno = BSD_ENETUNREACH;\n\t\t} else if (errno == ENETRESET) {\n\t\t\tBSD_errno = BSD_ENETRESET;\n\t\t} else if (errno == ECONNABORTED) {\n\t\t\tBSD_errno = BSD_ECONNABORTED;\n\t\t} else if (errno == EISCONN) {\n\t\t\tBSD_errno = BSD_EISCONN;\n\t\t} else if (errno == ENOTCONN) {\n\t\t\tBSD_errno = BSD_ENOTCONN;\n\t\t} else if (errno", "CodeBleu_score": 30.837208037950216}, {"code": "int BSD_listen(int socket, int backlog)\tint response;\n\tresponse = listen(socket, backlog);\n\tif (response == -1) {\n\t\tBSD_ERROR = errno;\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 14.54538226231431}, {"code": "int BSD_listen(int socket, int backlog)\tint result = listen(socket, backlog);\n\tif (result == -1) {\n\t\tBSD_set_errno(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 15.920949959070693}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret;\n\tint addr_family;\n\n\tif (socket < 0) {\n\t\tBSD_set_errno(EBADF);\n\t\treturn -1;\n\t}\n\n\tret = BSD_get_sockaddr_family(addr, &addr_family);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (addr_family!= AF_INET && addr_family!= AF_INET6) {\n\t\tBSD_set_errno(EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\tret = BSD_accept(socket, addr, addrlen);\n\tif (ret < 0) {\n\t\tif (ret == -1) {\n\t\t\tBSD_set_errno(EBADF);\n\t\t} else if (ret == -2) {\n\t\t\tBSD_set_errno(ENOTSOCK);\n\t\t} else if (ret == -3) {\n\t\t\tBSD_set_errno(EOPNOTSUPP);\n\t\t} else if (ret == -4) {\n\t\t\tBSD_set_errno(ECONNABORTED);\n\t\t} else if (ret == -5) {\n\t\t\tBSD_set_errno(ECONNRESET);\n\t\t} else if (ret == -6) {\n\t\t\tBSD_set_errno(EADDRINUSE);\n\t\t} else if (ret == -7) {\n\t\t\tBSD_set_errno(EADDRNOTAVAIL);\n\t\t} else if (ret == -8) {\n\t\t\tBSD_set_errno(ENETDOWN);\n\t\t} else if (ret == -9) {\n\t\t\tBSD_set_errno(ENETUNREACH);\n\t\t} else if (ret == -10) {\n\t\t\tBSD_set_errno(ENETRESET);\n\t\t} else if (ret == -11) {\n\t\t\tBSD_set_errno(ECONNREFUSED);\n\t\t} else if (ret == -12) {\n\t\t\tBSD_set_errno(EHOSTDOWN);\n\t\t} else if (ret == -13) {\n\t\t\tBSD_set_errno(EHOSTUNREACH);\n\t\t} else if (ret == -14) {\n\t\t\tBSD_set_errno(EINPROGRESS);\n\t\t} else if (ret == -15) {\n\t\t\t", "CodeBleu_score": 38.46041751810972}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret = 0;\n\tstruct sockaddr_storage ss;\n\tsocklen_t sslen;\n\n\tif (socket < 0 || socket >= MAX_FDS) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tif (sockets[socket].type == SOCK_STREAM) {\n\t\tif (sockets[socket].state!= LISTEN) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\terrno = EOPNOTSUPP;\n\t\treturn -1;\n\t}\n\n\tsslen = sizeof(ss);\n\tret = accept(sockets[socket].fd, (struct sockaddr *) &ss, &sslen);\n\n\tif (ret < 0) {\n\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n\t\t\terrno = EWOULDBLOCK;\n\t\t\treturn -1;\n\t\t} else if (errno == EBADF) {\n\t\t\terrno = EBADF;\n\t\t\treturn -1;\n\t\t} else if (errno == ECONNABORTED) {\n\t\t\terrno = ECONNABORTED;\n\t\t\treturn -1;\n\t\t} else if (errno == EFAULT) {\n\t\t\terrno = EFAULT;\n\t\t\treturn -1;\n\t\t} else if (errno == EINTR) {\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t} else if (errno == EINVAL) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t} else if (errno == EMFILE) {\n\t\t\terrno = EMFILE;\n\t\t\treturn -1;\n\t\t} else if (errno == ENFILE) {\n\t\t\terrno = ENFILE;\n\t\t\treturn -1;\n\t\t} else if (errno == ENOBUFS) {\n\t\t\terrno = ENOBUFS;\n\t\t\treturn -1;\n\t\t} else if (errno == ENOMEM) {\n\t\t\terrno = ENOMEM;\n\t\t\treturn -1;\n\t\t} else if (errno == ENOTSOCK) {\n\t\t\terrno = ENOTSOCK;\n\t\t\treturn -1;\n\t\t} else if (errno == EOPNOTSUPP) {\n\t\t\terrno = EOPNOTSUPP;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\terrno = EIO;\n\t\t\treturn -1", "CodeBleu_score": 36.376124199904126}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret;\n\tstruct sockaddr * addr_temp;\n\tsocklen_t addrlen_temp;\n\tif(socket < 0) {\n\t\tBSD_errno = EBADF;\n\t\treturn -1;\n\t}\n\tif(socket >= BSD_MAX_SOCKETS) {\n\t\tBSD_errno = EBADF;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 0) {\n\t\tBSD_errno = ENOTSOCK;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 1) {\n\t\tBSD_errno = EOPNOTSUPP;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 2) {\n\t\tBSD_errno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 3) {\n\t\tBSD_errno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 4) {\n\t\tBSD_errno = EISCONN;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 5) {\n\t\tBSD_errno = EINPROGRESS;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 6) {\n\t\tBSD_errno = EISCONN;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 7) {\n\t\tBSD_errno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 8) {\n\t\tBSD_errno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 9) {\n\t\tBSD_errno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 10) {\n\t\tBSD_errno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets[socket].type == 11) {\n\t\tBSD_errno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(BSD_sockets", "CodeBleu_score": 32.57435607303657}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT()\tif (getTime()) {\n\t\tupdateJWT();\n\t\tMQTT_connect();\n\t\tmqtt_subscribe_flag = 1;\n\t}\n}\n", "CodeBleu_score": 7.207331306443961}, {"code": "static void connectMQTT()\tint32_t currentTime = time(NULL);\n\tif (currentTime > 0) {\n\t\tjwt.iat = currentTime;\n\t\tif (MQTT_connect(&mqttClient) == 0) {\n\t\t\tmqttConnected = true;\n\t\t\tmqttSubscribe = true;\n\t\t\tdebug_print(\"MQTT connected\\n\");\n\t\t} else {\n\t\t\tmqttConnected = false;\n\t\t\tdebug_print(\"MQTT connection failed\\n\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 53.68529140631209}, {"code": "static void connectMQTT()\tint32_t currentTime = getUnixTime();\n\tif (currentTime > 0) {\n\t\t// Update the JWT with the current time offset\n\t\tupdateJWT(currentTime);\n\t\t// Connect to the MQTT broker\n\t\tmqttConnect();\n\t\t// Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n\t\tsubscribeMQTT = true;\n\t} else {\n\t\t// Print debug message\n\t\tDEBUG_PRINTLN(\"MQTT: Current time invalid!\");\n\t}\n}\n", "CodeBleu_score": 54.27594956899631}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void)\tif (CLOUD_mqtt_connected()) {\n\t\tCLOUD_mqtt_disconnect();\n\t}\n\tCLOUD_log_debug(\"Disconnected from cloud service\");\n}\n", "CodeBleu_score": 21.23537366930949}, {"code": "void CLOUD_disconnect(void)\tif (cloud_state == CLOUD_CONNECTED) {\n\t\tMQTT_disconnect(&cloud_client);\n\t\tcloud_state = CLOUD_DISCONNECTED;\n\t\tDEBUG_print(\"Cloud disconnected\");\n\t}\n}\n", "CodeBleu_score": 42.552374271487245}, {"code": "void CLOUD_disconnect(void)\tif (CLOUD_mqtt_connection_state == CLOUD_MQTT_CONNECTION_STATE_CONNECTED) {\n\t\tCLOUD_mqtt_disconnect();\n\t}\n\tCLOUD_mqtt_connection_state = CLOUD_MQTT_CONNECTION_STATE_DISCONNECTED;\n\tDEBUG_log(DEBUG_LOG_LEVEL_INFO, \"Cloud: Disconnected\");\n}\n", "CodeBleu_score": 41.71225055379566}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\t// If new credentials are provided, attempt to connect using the specified SSID, authentication type, and password\n\tif (passed_wifi_creds) {\n\t\tif (WiFi.begin(ssid, password)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tSerial.println(\"Failed to connect to the specified Wi-Fi access point.\");\n\t\t\tupdate_networking_error_status(1);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Otherwise, attempt to connect using the default Wi-Fi settings\n\tif (WiFi.begin()) {\n\t\treturn true;\n\t} else {\n\t\tSerial.println(\"Failed to connect to the default Wi-Fi access point.\");\n\t\tupdate_networking_error_status(1);\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 36.63098137819483}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\t//If new credentials are passed, attempt to connect using the specified SSID, authentication type, and password\n\tif (passed_wifi_creds) {\n\t\t//Attempt to connect to the specified SSID using the specified authentication type and password\n\t\tif (WiFi.begin(ssid, password)) {\n\t\t\t//If the connection succeeds, return true\n\t\t\treturn true;\n\t\t}\n\t\t//If the connection fails, log an error message and return false\n\t\telse {\n\t\t\tSerial.println(\"Connection to specified SSID failed\");\n\t\t\treturn false;\n\t\t}\n\t}\n\t//If new credentials are not passed, attempt to connect using the default Wi-Fi settings\n\telse {\n\t\t//Attempt to connect to the specified SSID using the specified authentication type and password\n\t\tif (WiFi.begin()) {\n\t\t\t//If the connection succeeds, return true\n\t\t\treturn true;\n\t\t}\n\t\t//If the connection fails, log an error message and return false\n\t\telse {\n\t\t\tSerial.println(\"Connection to default SSID failed\");\n\t\t\treturn false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.814700061691454}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\t// If passed_wifi_creds is 1, use the new credentials.\n\tif (passed_wifi_creds == 1) {\n\t\t// Set the new credentials.\n\t\twifi_config_t wifi_config = {\n\t\t\t.sta = {\n\t\t\t\t.ssid = new_wifi_ssid,\n\t\t\t\t.password =,\n\t\t\t\t.threshold.authmode = new_wifi_auth_mode,\n\t\t\t\t.threshold.authmode = new_wifi_auth_mode,\n\t\t\t\t.threshold.authmode = new_wifi_auth_mode,\n\t\t\t}\n\t\t};\n\t\t// Attempt to connect to the new credentials.\n\t\tESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config));\n\t\tESP_ERROR_CHECK(esp_wifi_connect());\n\t}\n\t// If passed_wifi_creds is 0, use the default credentials.\n\telse {\n\t\t// Attempt to connect to the default credentials.\n\t\tESP_ERROR_CHECK(esp_wifi_connect());\n\t}\n\t// Check if the connection was successful.\n\tif (wifi_status!= WIFI_STATUS_CONNECTED) {\n\t\t// Log an error message.\n\t\tESP_LOGE(TAG, \"Connection failed.\");\n\t\t// Update the networking error status.\n\t\tnetworking_error_status = 1;\n\t\t// Return false.\n\t\treturn false;\n\t}\n\t// If the connection was successful, return true.\n\treturn true;\n}\n", "CodeBleu_score": 43.43575562195661}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map)\tconst client = new ApolloClient({\n\t\turi: 'https://api.spacex.land/graphql/',\n\t});\n\n\tconst { data } = await client.query({\n\t\tquery: gql`\n\t\t\tquery {\n\t\t\t\tsensors {\n\t\t\t\t\tid\n\t\t\t\t\tname\n\t\t\t\t\tlatitude\n\t\t\t\t\tlongitude\n\t\t\t\t}\n\t\t\t}\n\t\t`,\n\t});\n\n\tconsole.log('Retrieved sensors:');\n\tconsole.log(data.sensors);\n\n\tdata.sensors.forEach((sensor) => {\n\t\tconst marker = new google.maps.Marker({\n\t\t\tposition: {\n\t\t\t\tlat: sensor.latitude,\n\t\t\t\tlng: sensor.longitude,\n\t\t\t},\n\t\t\tmap,\n\t\t\ttitle: sensor.name,\n\t\t});\n\t});\n}", "CodeBleu_score": 31.850105018581655}, {"code": "async function DisplaySensors(map)\t// Create a client\n\tconst client = new ApolloClient({\n\t\turi: \"https://api.spacenews.com/graphql\",\n\t});\n\n\t// Send a GraphQL query to fetch sensor data\n\tconst response = await client.query({\n\t\tquery: gql`\n\t\t\tquery {\n\t\t\t\tsensors {\n\t\t\t\t\tid\n\t\t\t\t\tname\n\t\t\t\t\tlatitude\n\t\t\t\t\tlongitude\n\t\t\t\t}\n\t\t\t}\n\t\t`,\n\t});\n\n\t// Log the API response\n\tconsole.log(response);\n\n\t// If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\n\tif (response.data) {\n\t\tconsole.log(\"Retrieved sensors\");\n\t\tresponse.data.sensors.forEach((sensor) => {\n\t\t\t// Create a marker\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: {\n\t\t\t\t\tlat: sensor.latitude,\n\t\t\t\t\tlng: sensor.longitude,\n\t\t\t\t},\n\t\t\t\tmap,\n\t\t\t\ttitle: sensor.name,\n\t\t\t});\n\n\t\t\t// Add a click event listener to the marker\n\t\t\tmarker.addListener(\"click\", () => {\n\t\t\t\t// Open an info window when the marker is clicked\n\t\t\t\tconst infoWindow = new google.maps.InfoWindow({\n\t\t\t\t\tcontent: `<p>Sensor: ${sensor.name}</p>`,\n\t\t\t\t});\n\t\t\t\tinfoWindow.open(map, marker);\n\t\t\t});\n\t\t});\n\t}\n}\n", "CodeBleu_score": 37.87450859306354}, {"code": "async function DisplaySensors(map)\tconst client = new ApolloClient({\n\t\turi: 'https://api.spacex.land/graphql/',\n\t});\n\n\tconst query = gql`\n\t\tquery {\n\t\t\tlaunches(limit: 1000) {\n\t\t\t\tid\n\t\t\t\trocket {\n\t\t\t\t\tid\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t\tlocation {\n\t\t\t\t\tlatitude\n\t\t\t\t\tlongitude\n\t\t\t\t}\n\t\t\t\ttelemetry {\n\t\t\t\t\tflight_club\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`;\n\n\tconst result = await client.query({ query });\n\n\tconsole.log(result.data);\n\n\tconst sensors = result.data.launches;\n\n\tif (sensors.length > 0) {\n\t\tconsole.log('Retrieved sensors');\n\n\t\tsensors.forEach((sensor) => {\n\t\t\tconst { latitude, longitude } = sensor.location;\n\t\t\tconst { flight_club } = sensor.telemetry;\n\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: { lat: latitude, lng: longitude },\n\t\t\t\tmap,\n\t\t\t\ttitle: flight_club,\n\t\t\t});\n\t\t});\n\t}\n}\n", "CodeBleu_score": 32.342565972222694}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>\tlet sensorMarker = document.createElement(\"div\");\n\tsensorMarker.id = sensor.id;\n\tsensorMarker.className = \"sensorMarker\";\n\tsensorMarker.style.borderColor = sensor.color;\n\treturn sensorMarker;\n}\n", "CodeBleu_score": 30.699844163135424}, {"code": "const CreateSensorMarker = (sensor) =>\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\tmarker.style.borderStyle ='solid';\n\tmarker.style.borderWidth = '1px';\n\tmarker.style.borderRadius = '50%';\n\tmarker.style.width = '10px';\n\tmarker.style.height = '10px';\n\tmarker.style.position = 'absolute';\n\treturn marker;\n};\n", "CodeBleu_score": 31.373406476939657}, {"code": "const CreateSensorMarker = (sensor) =>\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n};\n", "CodeBleu_score": 33.31814467563249}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n    # Attempt to import the module\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        # Log and raise an error if the import fails\n        _LOGGER.error(\n            \"Failed to import module '%s' for multi-factor authentication (MFA): %s\",\n            module_name,\n            err,\n        )\n        raise\n    # Check if the module has requirements\n    if hasattr(module, \"REQUIREMENTS\"):\n        # Process the module's requirements\n        await _process_requirements(hass, module.REQUIREMENTS, module_name)\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 31.64040406580968}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    if module_name in _mfa_modules:\n        return _mfa_modules[module_name]\n\n    try:\n        module_path = f\"homeassistant.components.{module_name}\"\n        _mfa_modules[module_name] = importlib.import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Failed to load MFA module %s: %s\", module_name, err)\n        raise err\n\n    if module_name in _mfa_modules_requirements:\n        return _mfa_modules[module_name]\n\n    try:\n        requirements = _mfa_modules[module_name].REQUIREMENTS\n        if requirements:\n            _LOGGER.info(\"Installing requirements for MFA module %s\", module_name)\n            if not _skip_pip_install:\n                await hass.async_add_executor_job(pip_install, requirements)\n            else:\n                _LOGGER.warning(\"Skipping pip install for MFA module %s\", module_name)\n    except AttributeError:\n        pass\n\n    _mfa_modules_requirements[module_name] = True\n    return _mfa_modules[module_name]\n\n", "CodeBleu_score": 38.55681261438089}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n    # Attempt to import the module\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as error:\n        _LOGGER.error(\"Failed to load %s module: %s\", module_name, error)\n        raise\n    # Check if the module has requirements\n    if hasattr(module, \"REQUIREMENTS\"):\n        # Check if the requirements have already been processed\n        if module.REQUIREMENTS in _MFA_REQUIREMENTS_PROCESSED:\n            return module\n        # Process the requirements\n        if not skip_pip_install:\n            for requirement in module.REQUIREMENTS:\n                await hass.async_add_executor_job(pip_install, requirement)\n        # Mark the requirements as processed\n        _MFA_REQUIREMENTS_PROCESSED.add(module.REQUIREMENTS)\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 38.54111943922152}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    if self.data.get(user_id) is None:\n      self.data[user_id] = setup_data\n    else:\n      self.data[user_id] = setup_data\n    return True\n\n  async def async_verify_user(self, user_id: str, verify_data: Any) -> Any:\n    \"\"\"The function \"async_verify_user\" verifies a user's PIN.\\nIt extracts the PIN from the provided verification data and checks if the user has an entry in the internal data list.\\nIf an entry exists and the PIN matches, the function returns True; otherwise, it returns False.\"\"\"\n    if self.data.get(user_id) is None:\n      return False\n    return self.data[user_id] == verify_data\n\n  async def async_delete_user(self, user_id: str) -> Any:\n    \"\"\"The function \"async_delete_user\" deletes a user's entry from the internal data list.\\nIt checks if the user has an entry in the internal data list and deletes it if it exists.\"\"\"\n    if self.data.get(user_id) is None:\n      return False\n    del self.data[user_id]\n    return True\n\n  async def async_get_users(self) -> Any:\n    \"\"\"The function \"async_get_users\" returns a list of all users with their corresponding PINs.\\nThe function iterates through the internal data list and returns a list of tuples, where each tuple contains the user ID and the PIN.\"\"\"\n    return [(user_id, self.data[user_id]) for user_id in self.data]\n\n  async def async_get_user(self, user_id: str) -> Any:\n    \"\"\"The function \"async_get_user\" returns a user's entry from the internal data list.\\nIt checks if the user has an entry in the internal data list and returns it if it exists.\"\"\"\n    return self.data[user_id] if self.data.get(user_id) is not None else None", "CodeBleu_score": 30.18779901499762}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    if not self.data:\n        self.data = []\n    if not self.pin_length:\n        self.pin_length = 4\n    if not self.pin_digits:\n        self.pin_digits = \"0123456789\"\n    if not self.pin_case:\n        self.pin_case = \"lower\"\n    if not self.pin_delimiter:\n        self.pin_delimiter = \"-\"\n    if not self.pin_length_min:\n        self.pin_length_min = 4\n    if not self.pin_length_max:\n        self.pin_length_max = 4\n    if not self.pin_digits_min:\n        self.pin_digits_min = 4\n    if not self.pin_digits_max:\n        self.pin_digits_max = 4\n    if not self.pin_case_min:\n        self.pin_case_min = 1\n    if not self.pin_case_max:\n        self.pin_case_max = 1\n    if not self.pin_delimiter_min:\n        self.pin_delimiter_min = 0\n    if not self.pin_delimiter_max:\n        self.pin_delimiter_max = 0\n    if not self.pin_length_min_msg:\n        self.pin_length_min_msg = \"The PIN must be at least {pin_length_min} characters long.\"\n    if not self.pin_length_max_msg:\n        self.pin_length_max_msg = \"The PIN must be at most {pin_length_max} characters long.\"\n    if not self.pin_digits_min_msg:\n        self.pin_digits_min_msg = \"The PIN must contain at least {pin_digits_min} digit.\"\n    if not self.pin_digits_max_msg:\n        self.pin_digits_max_msg = \"The PIN must contain at most {pin_digits_max} digits.\"\n    if not self.pin_case_min_msg:\n        self.pin_case_min_msg = \"The PIN must contain at least {pin_case_min} character in lower case.\"\n    if not self.pin_case_max_msg:\n        self.pin_case_max_msg = \"The PIN must contain at most {pin_case_", "CodeBleu_score": 20.421238489558156}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    # Check if the user already has an entry in the internal data list.\n    if user_id in self.data:\n        # If an entry exists, update the PIN.\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        # If no entry exists, add a new entry with the user ID and PIN to the data list.\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n    # Return the user ID and PIN.\n    return {\"user_id\": user_id, \"pin\": setup_data[\"pin\"]}\n", "CodeBleu_score": 40.11601292830249}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n    if self.initialized:\n      return\n    await self.lock.acquire()\n    if self.initialized:\n      self.lock.release()\n      return\n    try:\n      data = await self.store.get(self.key)\n      if data is None:\n        data = {}\n      else:\n        data = json.loads(data)\n    except Exception:\n      data = {}\n    self.settings = {user.id: NotifySetting(user, data.get(str(user.id), {})) for user in self.bot.get_all_members()}\n    self.initialized = True\n    self.lock.release()", "CodeBleu_score": 41.126990768998404}, {"code": "async def _async_load(self) -> None\n    if self._async_load_lock.locked():\n        return\n    async with self._async_load_lock:\n        if self._async_loaded:\n            return\n        if self._async_data is None:\n            self._async_data = await self._async_load_data()\n        if self._async_data is None:\n            self._async_data = {}\n        for user_id in self._async_data:\n            self._async_data[user_id] = NotifySetting(user_id, self._async_data[user_id])\n        self._async_loaded = True\n\n", "CodeBleu_score": 28.736614249861848}, {"code": "async def _async_load(self) -> None\n    if self.initialized:\n        return\n    self.initialized = True\n    self.lock.acquire()\n    try:\n        if self.settings is None:\n            self.settings = {}\n            self.settings_loaded = False\n        if not self.settings_loaded:\n            self.settings_loaded = True\n            self.settings = await self.load_settings()\n        if self.settings is None:\n            self.settings = {}\n    finally:\n        self.lock.release()\n", "CodeBleu_score": 24.40918625594299}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    try:\n        # Load user settings\n        settings = await self.load_user_settings(user_id)\n        if settings is None:\n            return False\n\n        # Retrieve the notification settings for the user\n        notification_settings = settings.get(\"notification\", {})\n\n        # Validate the user input\n        otp = user_input.get(\"otp\")\n        if otp is None:\n            return False\n\n        # Validate the OTP using an executor job\n        job = self.executor.submit(self.validate_otp, otp, notification_settings.get(\"otp_secret\"))\n        if not job.result():\n            return False\n\n        # Return True if the validation passes\n        return True\n    except Exception as e:\n        logger.error(f\"Error validating user input for user ID {user_id}: {e}\")\n        return False\n\n", "CodeBleu_score": 44.625674448402684}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    # Load user settings\n    await self.load_user_settings(user_id)\n    # Retrieve notification settings for the user\n    notification_settings = self.notification_settings.get(user_id)\n    if notification_settings is None:\n        return False\n    # Validate the user input by verifying the OTP\n    otp_code = user_input.get(\"otp_code\")\n    if otp_code is None:\n        return False\n    executor_job = self.executor.submit(self.otp_validator.validate_otp, otp_code)\n    return await executor_job.result()\n", "CodeBleu_score": 51.12812501136099}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    # Load user settings\n    user_settings = await self.load_user_settings(user_id)\n    if user_settings is None:\n        return False\n\n    # Get notification settings for the user\n    notification_settings = user_settings.get(\"notifications\", {})\n    # Check if notification settings exist for the user\n    if notification_settings is None:\n        return False\n\n    # Get the OTP from the user input\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n\n    # Validate the OTP using an executor job\n    result = await self.executor.submit(self._validate_otp, otp, notification_settings)\n    return result\n\n", "CodeBleu_score": 49.239082918821175}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None or not device.area_id:\n        return None\n    area = area_dict.get(device.area_id)\n    if area is None:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 58.17302224102991}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.entity_dict.get(entity_id)\n    if not entity:\n        return None\n    device_id = entity.get(\"device_id\")\n    device = perm_lookup.device_dict.get(device_id)\n    if not device:\n        return None\n    area_id = device.get(\"area_id\")\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 51.75515989023096}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.device(entity.device_id)\n    if device is None:\n        return None\n    if device.area_id is None:\n        return None\n    area = area_dict.get(device.area_id)\n    if area is None:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 58.86581620094318}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                if category in merged_policy:\n                    merged_policy[category] = merge_categories(merged_policy[category], value)\n                else:\n                    merged_policy[category] = value\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 50.67430278438101}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, values in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                if category in merged_policy:\n                    merged_policy[category] = merge_categories(merged_policy[category], values)\n                else:\n                    merged_policy[category] = values\n    if isinstance(policies[0], dict):\n        return dict(merged_policy)\n    elif isinstance(policies[0], list):\n        return list(merged_policy)\n    elif isinstance(policies[0], set):\n        return set(merged_policy)\n    else:\n        raise TypeError(f\"Unsupported policy type: {type(policies[0])}\")\n\n", "CodeBleu_score": 35.06680247772197}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, values in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                if category in merged_policy:\n                    merged_policy[category].update(values)\n                else:\n                    merged_policy[category] = values\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 51.52819485105985}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    module_name = f\"homeassistant.components.{provider}\"\n    try:\n        module = importlib.import_module(module_name)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load authentication provider module %s\", module_name)\n        raise HomeAssistantError(err) from err\n\n    if not hasattr(module, \"AUTH_PROVIDER_REQUIREMENTS\"):\n        return module\n\n    requirements = set(module.AUTH_PROVIDER_REQUIREMENTS)\n    if not requirements:\n        return module\n\n    try:\n        hass.data[DOMAIN][AUTH_PROVIDERS_REQUIREMENTS].update(requirements)\n    except KeyError:\n        hass.data[DOMAIN][AUTH_PROVIDERS_REQUIREMENTS] = set(requirements)\n\n    return module\n\n", "CodeBleu_score": 40.048455486590804}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(f\"homeassistant.components.{provider}\")\n    except ImportError as ex:\n        _LOGGER.error(\n            \"Unable to import authentication provider module '%s': %s\",\n            provider,\n            ex,\n        )\n        raise HomeAssistantError(\n            \"Unable to import authentication provider module '%s': %s\", provider, ex\n        ) from ex\n\n    if not hasattr(module, \"AUTH_PROVIDERS\"):\n        return module\n\n    requirements = module.AUTH_PROVIDERS\n    if not requirements:\n        return module\n\n    if requirements is True:\n        return module\n\n    hass.data[DATA_AUTH_PROVIDERS].update(requirements)\n    return module\n\n", "CodeBleu_score": 39.12956199632791}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(f\"homeassistant.auth_providers.{provider}\")\n    except Exception:\n        _LOGGER.error(\n            \"Failed to load authentication provider module: %s\", provider, exc_info=True\n        )\n        raise HomeAssistantError(f\"Failed to load authentication provider module: {provider}\") from None\n\n    if not hasattr(module, \"AUTH_PROVIDERS\"):\n        return module\n\n    # If the module has additional requirements, process them and update the processed requirements set.\n    for req in module.AUTH_PROVIDERS:\n        if req not in AUTH_PROVIDERS_PROCESSED:\n            try:\n                importlib.import_module(req)\n            except Exception:\n                _LOGGER.error(\n                    \"Failed to load authentication provider module: %s\", provider, exc_info=True\n                )\n                raise HomeAssistantError(f\"Failed to load authentication provider module: {provider}\") from None\n            AUTH_PROVIDERS_PROCESSED.add(req)\n\n    return module\n\n", "CodeBleu_score": 36.32552756628152}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\n    try:\n      data = await self.store.get(self.name)\n      self.users = data.get(\"users\", [])\n      self.normalize_users()\n    except:\n      self.users = []\n\n  @staticmethod\n  def normalize_users() -> None:\n    \"\"\"The function \"normalize_users\" normalizes the usernames of the users list by removing leading and trailing whitespace and converting to lowercase.\"\"\"\n\n    for i, user in enumerate(self.users):\n      self.users[i] = user.strip().lower()\n\n  async def async_save(self) -> None:\n    \"\"\"The function \"async_save\" asynchronously saves the current user data to the store.\"\"\"\n\n    await self.store.set(self.name, {\"users\": self.users})\n\n  async def async_add_user(self, user: str) -> None:\n    \"\"\"The function \"async_add_user\" asynchronously adds a user to the users list.\\nIt first checks if the user is already in the list, and if not, it appends the user to the list and saves the data.\"\"\"\n\n    if user.strip().lower() not in self.users:\n      self.users.append(user.strip().lower())\n      await self.async_save()\n\n  async def async_remove_user(self, user: str) -> None:\n    \"\"\"The function \"async_remove_user\" asynchronously removes a user from the users list.\\nIt first checks if the user is in the list, and if so, it removes the user from the list and saves the data.\"\"\"\n\n    if user.strip().lower() in self.users:\n      self.users.remove(user.strip().lower())\n      await self.async_save()\n\n  async def async_check_user(self, user: str) -> bool:\n    \"\"\"The function \"async_check_user\" asynchronously checks if a user is in the users list.\\nIt first normalizes the user and then checks if the user is in the list.\"\"\"\n\n    return user.strip().lower() in self.users\n\n  async def async_get_users(self) -> list[str]:\n    \"\"\"The function \"async_get_users\" asynchronously returns the users list.\"\"\"\n\n    return self.users", "CodeBleu_score": 30.00097419815423}, {"code": "async def async_load(self) -> None\n    try:\n        await self.bot.wait_until_ready()\n        self.users = await self.bot.db.get_all_users()\n        for user in self.users:\n            if not user.get(\"username\"):\n                await self.bot.db.set_user(user.get(\"id\"), {\"username\": user.get(\"username\")})\n\n    except Exception as e:\n        await self.bot.log(e, \"error\")\n\n", "CodeBleu_score": 23.891866139823744}, {"code": "async def async_load(self) -> None\n    try:\n        data = await self.store.load()\n        if data is None:\n            self.users = []\n            return\n        if not isinstance(data, list):\n            raise TypeError(\"Invalid data type\")\n        for user in data:\n            if not isinstance(user, dict):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"username\"], str):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"password\"], str):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"role\"], str):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"active\"], bool):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"email\"], str):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"created\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_login\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_change\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_logout\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset_token\"], str):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset_token_expiration\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset_token_uses\"], int):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset_token_uses_expiration\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset_token_uses_expiration_warning\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset_token_uses_expiration_warning_sent\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset_token_uses_expiration_warning_sent\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(user[\"last_password_reset_token_uses_expiration_warning_sent\"], datetime):\n                raise TypeError(\"Invalid data type\")\n            if not isinstance(", "CodeBleu_score": 21.00758938672886}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b'a', bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), user.password_hash):\n                return\n            else:\n                if bcrypt.checkpw(password.encode(), dummy_hash):\n                    raise InvalidAuth()\n                else:\n                    raise InvalidAuth()\n    raise InvalidAuth()\n", "CodeBleu_score": 35.204271799004744}, {"code": "def validate_login(self, username: str, password: str) -> None\n    # Normalize username\n    username = username.strip()\n    # Initialize dummy hash\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt(10))\n    # Iterate through all users\n    for user in self.users:\n      # If a matching username is found\n      if user.username == username:\n        # Decode password hash\n        password_hash = user.password_hash.encode()\n        # If the provided password does not match the stored hash\n        if not bcrypt.checkpw(password.encode(), password_hash):\n          # Raise an \"InvalidAuth\" exception\n          raise InvalidAuth()\n        # If the provided password matches the stored hash\n        else:\n          # Set the user\n          self.user = user\n          # Break out of the loop\n          break\n    # If no matching user is found\n    else:\n      # If the dummy hash does not match the provided password\n      if not bcrypt.checkpw(password.encode(), dummy_hash):\n        # Raise an \"InvalidAuth\" exception\n        raise InvalidAuth()\n      # If the dummy hash matches the provided password\n      else:\n        # Raise an \"InvalidAuth\" exception\n        raise InvalidAuth()\n\n  def validate_password(self, password: str) -> None:\n    \"\"\"The function \"validate_password\" verifies a user's password.\\nIt normalizes the provided password and initializes a dummy hash to prevent timing attacks.\\nIt iterates through all users to find a matching username.\\nIf no matching user is found, it performs a dummy hash check and raises an \"InvalidAuth\" exception.\\nIf a user is found, it decodes the stored password hash and uses bcrypt's timing-safe check to compare the provided password with the stored hash.\\nIf the passwords do not match, it raises an \"InvalidAuth\" exception.\"\"\"\n    # Normalize password\n    password = password.strip()\n    # Initialize dummy hash\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt(10))\n    # Iterate through all users\n    for user in self.users:\n      # If a matching username is found\n      if user.username == self.user.username:\n        # Decode password hash\n        password_hash = user.password_hash.encode()\n        # If the provided password does not match the stored hash\n        if not bcrypt.checkpw(password.encode(), password_hash):\n          # Raise an \"InvalidAuth\" exception\n          raise InvalidAuth()\n        # If the provided password matches the stored hash\n       ", "CodeBleu_score": 38.40931557779259}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b'', bcrypt.gensalt())\n    for user in self.users:\n      if user['username'] == username:\n        stored_hash = user['password'].encode('utf-8')\n        if bcrypt.checkpw(password.encode('utf-8'), stored_hash) and bcrypt.checkpw(dummy_hash, stored_hash):\n          return\n        else:\n          raise InvalidAuth('Invalid username or password')\n    raise InvalidAuth('Invalid username or password')\n", "CodeBleu_score": 40.96035635425268}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n    try:\n        username = self.normalize_username(username)\n        user = self.users.pop(username)\n        self.users[username] = user\n    except KeyError:\n        raise InvalidUser(f\"user_not_found {username}\")\n\n", "CodeBleu_score": 32.06998237429104}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = username.lower()\n    if username in self.users:\n      self.users.remove(username)\n    else:\n      raise InvalidUser(f\"user_not_found: {username}\")", "CodeBleu_score": 20.72795663994551}, {"code": "def async_remove_auth(self, username: str) -> None\n    self.users.remove(self.normalize_username(username))\n\n  def async_get_auth(self, username: str) -> bool:\n    \"\"\"The function \"async_get_auth\" checks if a user is authenticated.\\nIt normalizes the provided username and searches for the user in the users list.\\nIf the user is found, it returns True.\\nIf the user is not found, it returns False.\"\"\"\n    return self.normalize_username(username) in self.users\n\n  def async_get_auth_info(self, username: str) -> str:\n    \"\"\"The function \"async_get_auth_info\" returns the authentication information of a user.\\nIt normalizes the provided username and searches for the user in the users list.\\nIf the user is found, it returns the authentication information of the user.\\nIf the user is not found, it raises an \"InvalidUser\" exception with the message \"user_not_found\".\"\"\"\n    return self.users[self.normalize_username(username)]\n\n  def async_get_auth_info_by_id(self, id: int) -> str:\n    \"\"\"The function \"async_get_auth_info_by_id\" returns the authentication information of a user by ID.\\nIt searches for the user in the users list by the provided ID.\\nIf the user is found, it returns the authentication information of the user.\\nIf the user is not found, it raises an \"InvalidUser\" exception with the message \"user_not_found\".\"\"\"\n    return self.users[id]\n\n  def async_get_auth_info_by_token(self, token: str) -> str:\n    \"\"\"The function \"async_get_auth_info_by_token\" returns the authentication information of a user by token.\\nIt searches for the user in the users list by the provided token.\\nIf the user is found, it returns the authentication information of the user.\\nIf the user is not found, it raises an \"InvalidUser\" exception with the message \"user_not_found\".\"\"\"\n    return self.users[token]\n\n  def async_get_auth_info_by_token_id(self, token_id: int) -> str:\n    \"\"\"The function \"async_get_auth_info_by_token_id\" returns the authentication information of a user by token ID.\\nIt searches for the", "CodeBleu_score": 29.444729148156867}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    try:\n        if not self.credentials:\n            await self.async_init()\n        if self.credentials.username == credentials.username:\n            self.credentials = None\n            await self.async_save()\n        else:\n            self.credentials = None\n            await self.async_save()\n    except InvalidUser:\n        pass", "CodeBleu_score": 42.516375334023195}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.data:\n        await self.async_initialize()\n    try:\n        await self.hass.async_add_executor_job(self.data.remove_credentials, credentials.username)\n        self.data.save()\n    except ValueError:\n        _LOGGER.debug(\"Credentials not found in data\")\n\n", "CodeBleu_score": 49.92033968708967}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    try:\n      await self.async_will_initialize_credentials()\n      await self.async_will_remove_credentials_from_user(credentials.username)\n    except InvalidUserException:\n      pass\n\n  @abstractmethod\n  async def async_will_remove_credentials_from_user(self, username: str) -> None:\n    \"\"\"The function \"async_will_remove_credentials_from_user\" handles the removal of authentication data for a given user.\\nIt removes the authentication data associated with the given username from the user's authentication data.\\nIt then saves the changes to the database.\"\"\"\n    pass\n\n  @abstractmethod\n  async def async_will_initialize_credentials(self) -> None:\n    \"\"\"The function \"async_will_initialize_credentials\" handles the initialization of authentication data.\\nIt initializes the authentication data for the user by creating a new authentication data object if it does not exist.\\nIt then saves the changes to the database.\"\"\"\n    pass\n\n  @abstractmethod\n  async def async_will_add_credentials(self, credentials: Credentials) -> None:\n    \"\"\"The function \"async_will_add_credentials\" handles the addition of authentication data when credentials are added.\\nIf the data is not initialized, it initializes it first.\\nIt then attempts to add the authentication associated with the given username and save the changes.\\nIf the user is invalid, it catches and ignores the exception.\"\"\"\n    try:\n      await self.async_will_initialize_credentials()\n      await self.async_will_add_credentials_to_user(credentials.username)\n    except InvalidUserException:\n      pass\n\n  @abstractmethod\n  async def async_will_add_credentials_to_user(self, username: str) -> None:\n    \"\"\"The function \"async_will_add_credentials_to_user\" handles the addition of authentication data for a given user.\\nIt adds the authentication data associated with the given username to the user's authentication data.\\nIt then saves the changes to the database.\"\"\"\n    pass\n\n  @abstractmethod\n  async def async_will_get_credentials(self, username: str) -> Credentials:\n    \"\"\"The function \"async_will_get_credentials\" handles the retrieval of authentication data for a given user.\\nIt retrieves the authentication data associated with the given username from the user's authentication data.\\nIf the user is invalid, it catches and ignores the exception.\"\"\"\n    try:\n      return await self.async_", "CodeBleu_score": 40.91588557432896}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    # Calculate the timeout for each thread\n    timeouts = {thread: timeout - (time.time() - thread.start_time) for thread in threads}\n\n    # Join threads within the specified timeout\n    for thread, timeout in timeouts.items():\n        if timeout > 0:\n            try:\n                thread.join(timeout)\n            except TimeoutError:\n                # If the thread is still alive, interrupt it\n                if thread.is_alive():\n                    thread.interrupt_main_loop()\n\n    # Add threads that are no longer alive or have no identifier to the joined set\n    joined = {thread for thread in threads if not thread.is_alive() or thread.identifier is None}\n\n    # Log threads that are still running\n    if log:\n        for thread in threads - joined:\n            logger.info(\"Thread %s is still running\", thread.name)\n\n    # Raise a SystemExit exception in any remaining threads\n    for thread in threads - joined:\n        try:\n            raise SystemExit\n        except SystemExit:\n            pass\n\n    return joined\n\n", "CodeBleu_score": 43.85966139032597}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread.join(timeout)\n            if thread.is_alive():\n                thread.interrupt()\n                if log:\n                    logging.warning(\n                        \"Thread %s with identifier %s is still running\",\n                        thread.name,\n                        thread.ident,\n                    )\n            if thread.is_alive():\n                raise SystemExit(\n                    \"Thread %s with identifier %s is still running\"\n                    % (thread.name, thread.ident)\n                )\n        joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 39.207431770418374}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined = set()\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                thread.join(timeout)\n            except TimeoutError:\n                if log:\n                    logger.warning(\n                        \"Timeout while waiting for thread %s\", thread.name\n                    )\n                thread.interrupt()\n                thread.join()\n            if thread.is_alive():\n                if log:\n                    logger.warning(\n                        \"Thread %s did not finish in time, interrupting\",\n                        thread.name,\n                    )\n                thread.interrupt()\n                thread.join()\n            else:\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    if log:\n        for thread in threads:\n            if thread not in joined:\n                logger.warning(\"Thread %s did not finish\", thread.name)\n    return joined\n\n", "CodeBleu_score": 36.188228704108106}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if not thread.is_alive() and not thread.is_daemon() and not thread.name == \"MainThread\"]\n    # Calculate the timeout for each thread\n    total_timeout = 10000\n    for thread in threads:\n        total_timeout -= thread.timeout\n    timeout = total_timeout / len(threads)\n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        if not thread.join(timeout=timeout):\n            logging.warning(\"Failed to join thread %s\", thread.name)\n\n", "CodeBleu_score": 28.837261474436243}, {"code": "def deadlock_safe_shutdown() -> None\n    global shutdown_timeout, shutdown_timeout_start, shutdown_timeout_end, shutdown_timeout_total, shutdown_timeout_remaining, shutdown_timeout_total_start, shutdown_timeout_total_end, shutdown_timeout_total_total, shutdown_timeout_total_remaining\n    shutdown_timeout_end = time.time()\n    shutdown_timeout_total_end = time.time()\n    shutdown_timeout_total_total = shutdown_timeout_total_end - shutdown_timeout_total_start\n    shutdown_timeout_total_remaining = shutdown_timeout_total_total / shutdown_timeout_total\n    shutdown_timeout_remaining = shutdown_timeout_total_remaining / shutdown_timeout_total\n    for thread in threading.enumerate():\n        if not thread.is_alive() or thread.daemon:\n            continue\n        if thread.name == \"MainThread\":\n            continue\n        thread_name = thread.name\n        thread_timeout = shutdown_timeout_remaining\n        thread_timeout_start = time.time()\n        thread_timeout_end = thread_timeout_start + thread_timeout\n        try:\n            thread.join(thread_timeout)\n        except Exception as exception:\n            logger.warning(f\"Thread '{thread_name}' failed to join within {thread_timeout} seconds.\")\n            logger.warning(f\"Thread '{thread_name}' failed to join within {thread_timeout} seconds. Exception: {exception}\")\n        thread_timeout_end = time.time()\n        thread_timeout_total = thread_timeout_end - thread_timeout_start\n        logger.warning(f\"Thread '{thread_name}' took {thread_timeout_total} seconds to join.\")\n\n", "CodeBleu_score": 29.705677551765554}, {"code": "def deadlock_safe_shutdown() -> None\n    # get a list of all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if not t.is_main_thread() and not t.is_daemon()]\n    # calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT / len(threads)\n    # attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout=timeout)\n        except Exception as e:\n            logger.warning(f\"Failed to join thread {thread.name}: {e}\")\n\n", "CodeBleu_score": 24.11741142058531}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n      self._signal_dispatcher.send_signal(\n        signal_name=\"remaining_setups\",\n        signal_value=remaining_with_setup_started\n      )\n    self._remaining_setups = remaining_with_setup_started\n\n  def _async_dispatch_setup_started(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_started\" dispatches a signal based on the state of remaining setups.\\nIf there are setups remaining, it sends an internal dispatcher signal with the remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    if self._remaining_setups:\n      self._signal_dispatcher.send_signal(\n        signal_name=\"remaining_setups\",\n        signal_value=self._remaining_setups\n      )\n    self._remaining_setups[setup_name] = time.time()\n\n  def _async_dispatch_setup_finished(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_finished\" dispatches a signal based on the state of remaining setups.\\nIf there are setups remaining, it sends an internal dispatcher signal with the remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    if self._remaining_setups:\n      self._signal_dispatcher.send_signal(\n        signal_name=\"remaining_setups\",\n        signal_value=self._remaining_setups\n      )\n    del self._remaining_setups[setup_name]\n\n  def _async_dispatch_setup_failed(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_failed\" dispatches a signal based on the state of remaining setups.\\nIf there are setups remaining, it sends an internal dispatcher signal with the remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    if self._remaining_setups:\n      self._signal_dispatcher.send_signal(\n        signal_name=\"remaining_setups\",\n        signal_value=self._remaining_setups\n      )\n    del self._remaining_setups[setup_name]\n\n  def _async_dispatch_setup_error(self, setup_name: str) -> None:\n    \"\"\"The function \"_async", "CodeBleu_score": 43.84083679281593}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n      self._signal_dispatcher.dispatch(\n        signal=self._signal_dispatcher.internal_signals.setup_remaining,\n        data=remaining_with_setup_started,\n      )\n    self._setup_remaining = bool(remaining_with_setup_started)\n\n  def _async_setup_started(self, setup_id: str) -> None:\n    \"\"\"The function \"_async_setup_started\" is called when a setup is started.\\nIt updates the internal dictionary of setups that are currently running and dispatches a signal to the internal dispatcher.\\nIt also updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._setup_started_with_id[setup_id] = time.time()\n    self._async_dispatch(self._setup_started_with_id)\n\n  def _async_setup_finished(self, setup_id: str) -> None:\n    \"\"\"The function \"_async_setup_finished\" is called when a setup is finished.\\nIt removes the setup from the internal dictionary of setups that are currently running and dispatches a signal to the internal dispatcher.\\nIt also updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    if setup_id in self._setup_started_with_id:\n      del self._setup_started_with_id[setup_id]\n    self._async_dispatch(self._setup_started_with_id)\n\n  def _async_setup_failed(self, setup_id: str) -> None:\n    \"\"\"The function \"_async_setup_failed\" is called when a setup fails.\\nIt removes the setup from the internal dictionary of setups that are currently running and dispatches a signal to the internal dispatcher.\\nIt also updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    if setup_id in self._setup_started_with_id:\n      del self._setup_started_with_id[setup_id]\n    self._async_dispatch(self._setup_started_with_id)\n\n  def _async_setup_cancelled(self, setup_id: str) -> None:\n    \"\"\"The function \"_async_setup_cancelled\" is called when a setup is cancelled.\\nIt removes the setup from the internal dictionary of setups that are currently running and dispatches a signal to the internal dispatcher.\\nIt also updates the internal flag", "CodeBleu_score": 38.87277361885039}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n      self.signal_dispatcher.emit(\n        \"signal_async_dispatch\",\n        remaining_with_setup_started,\n      )\n      self._remaining_setups_flag = True\n    else:\n      self._remaining_setups_flag = False\n\n  def _async_dispatch_from_setup_finished(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_from_setup_finished\" dispatches a signal based on the state of remaining setups.\\nIf there are setups remaining or the previous state was not empty, it sends an internal dispatcher signal with the remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    remaining_with_setup_started = self._get_remaining_with_setup_started()\n    if remaining_with_setup_started:\n      self.signal_dispatcher.emit(\n        \"signal_async_dispatch\",\n        remaining_with_setup_started,\n      )\n      self._remaining_setups_flag = True\n    else:\n      self._remaining_setups_flag = False\n\n  def _get_remaining_with_setup_started(self) -> dict[str, float]:\n    \"\"\"The function \"_get_remaining_with_setup_started\" returns a dictionary of the remaining setups with their start times.\\nThe dictionary contains the remaining setups and their start times, which are the values of the setups in the internal dictionary \"_setups\".\"\"\"\n    remaining_with_setup_started = {}\n    for setup_name, setup_start_time in self._setups.items():\n      if setup_start_time is None:\n        remaining_with_setup_started[setup_name] = setup_start_time\n    return remaining_with_setup_started\n\n  def _get_remaining_with_setup_finished(self) -> dict[str, float]:\n    \"\"\"The function \"_get_remaining_with_setup_finished\" returns a dictionary of the remaining setups with their finish times.\\nThe dictionary contains the remaining setups and their finish times, which are the values of the setups in the internal dictionary \"_setups\".\"\"\"\n    remaining_with_setup_finished = {}\n    for setup_name, setup_finish_time in self._setups.items():\n      if setup_finish_time is None:\n        remaining_with", "CodeBleu_score": 43.80776484207968}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # Create the Bluetooth content\n    bluetooth_content = create_bluetooth_content(integrations, config)\n\n    # Get the current Bluetooth content\n    current_bluetooth_content = get_current_bluetooth_content(config)\n\n    # Compare the Bluetooth content with the current Bluetooth content\n    if bluetooth_content!= current_bluetooth_content:\n        # Add an error to the configuration\n        config.errors.append(\n            {\n                \"domain\": DOMAIN,\n                \"message\": \"bluetooth.py is not up to date\",\n                \"suggested_fix\": \"Run `ha bluetooth validate` to generate a new bluetooth.py file\",\n            }\n        )\n\n", "CodeBleu_score": 36.2768504669868}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # Check if bluetooth.py is in the configuration cache\n    if \"bluetooth\" not in config.cache:\n        # If bluetooth.py is not in the configuration cache, create an empty dictionary\n        config.cache[\"bluetooth\"] = {}\n\n    # Create a list of integrations that are not being validated\n    integrations_to_validate = [\n        \"adguard\",\n        \"airthings\",\n        \"alexa_media\",\n        \"android_wifi_hotspot\",\n        \"apple_tv\",\n        \"appdaemon\",\n        \"appdaemon4\",\n        \"asuswrt\",\n        \"athom\",\n        \"avanza\",\n        \"axwell\",\n        \"baby_monitor\",\n        \"balboa\",\n        \"belkin_wemo\",\n        \"better_time\",\n        \"beward\",\n        \"binary_sensor\",\n        \"bluetooth_tracker\",\n        \"bluetooth_tracker_ble\",\n        \"bluetooth_tracker_hci\",\n        \"bluetooth_tracker_hci_raw\",\n        \"bluetooth_tracker_net\",\n        \"bluetooth_tracker_net_linux\",\n        \"bluetooth_tracker_net_mac\",\n        \"bluetooth_tracker_net_windows\",\n        \"bluetooth_tracker_nrfconnect\",\n        \"bluetooth_tracker_nrfconnect_ble\",\n        \"bluetooth_tracker_nrfconnect_hci\",\n        \"bluetooth_tracker_nrfconnect_hci_raw\",\n        \"bluetooth_tracker_nrfconnect_net\",\n        \"bluetooth_tracker_nrfconnect_net_linux\",\n        \"bluetooth_tracker_nrfconnect_net_mac\",\n        \"bluetooth_tracker_nrfconnect_net_windows\",\n        \"bluetooth_tracker_nrfconnect_net_windows_ble\",\n        \"bluetooth_tracker_nrfconnect_net_windows_ble_raw\",\n        \"bluetooth_tracker_nrfconnect_net_windows_hci\",\n        \"bluetooth_tracker_nrfconnect_net_windows_hci_raw\",\n        \"bluetooth_tracker_nrfconnect_net_windows_hci_raw_ble\",\n        \"bluetooth_tracker_nrfconnect_net_windows_hci_raw_ble_raw\",\n        \"bluetooth_tracker_nrfconnect_net_windows_hci_raw_ble_raw_ble\",\n        \"bluetooth_tracker_nrfconnect_net_windows_hci_raw_ble_raw", "CodeBleu_score": 17.403385090592256}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # If the bluetooth.py file is not found, it will be created and the content will be validated\n    if not os.path.exists(config.path_bluetooth):\n        if not os.path.exists(config.path_bluetooth_dir):\n            os.mkdir(config.path_bluetooth_dir)\n        with open(config.path_bluetooth, \"w\") as file:\n            file.write(\n                \"\"\"\\", "CodeBleu_score": 22.837105415984542}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error\t// Create the request body\n\tbody := url.Values{}\n\tbody.Add(\"grant_type\", \"refresh_token\")\n\tbody.Add(\"refresh_token\", d.refreshToken)\n\tbody.Add(\"client_id\", d.appKey)\n\tbody.Add(\"client_secret\", d.appSecret)\n\n\t// Create the request\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(body.Encode()))\n\tif err!= nil {\n\t\treturn err\n\t}\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request\n\tresp, err := d.client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the response status code\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\t// Read the response body\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Unmarshal the response body\n\tvar response struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\terr = json.Unmarshal(data, &response)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.accessToken = response.AccessToken\n\n\treturn nil\n}\n", "CodeBleu_score": 46.93744909842504}, {"code": "func (d *Dropbox) refreshToken() error\t// Create the request body\n\tdata := url.Values{}\n\tdata.Add(\"grant_type\", \"refresh_token\")\n\tdata.Add(\"refresh_token\", d.RefreshToken)\n\tdata.Add(\"client_id\", d.AppKey)\n\tdata.Add(\"client_secret\", d.AppSecret)\n\n\t// Create the request\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(data.Encode()))\n\tif err!= nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request\n\tres, err := d.Client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\t// Check the response\n\tif res.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", res.StatusCode)\n\t}\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Unmarshal the response body\n\tvar response map[string]interface{}\n\terr = json.Unmarshal(body, &response)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check the response\n\tif _, ok := response[\"access_token\"];!ok {\n\t\treturn fmt.Errorf(\"missing access_token in response: %s\", string(body))\n\t}\n\n\t// Update the access token\n\td.AccessToken = response[\"access_token\"].(string)\n\n\treturn nil\n}\n", "CodeBleu_score": 46.98189673008275}, {"code": "func (d *Dropbox) refreshToken() error\t// Send a POST request to the Dropbox OAuth2 token endpoint with the refresh token, app key, and app secret.\n\tresp, err := http.PostForm(\n\t\t\"https://api.dropboxapi.com/oauth2/token\",\n\t\turl.Values{\n\t\t\t\"grant_type\":    {\"refresh_token\"},\n\t\t\t\"refresh_token\": {d.refreshToken},\n\t\t\t\"client_id\":     {d.appKey},\n\t\t\t\"client_secret\": {d.appSecret},\n\t\t},\n\t)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Parse the JSON response.\n\tvar tokenResp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tif err := json.NewDecoder(resp.Body).Decode(&tokenResp); err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token.\n\td.accessToken = tokenResp.AccessToken\n\treturn nil\n}\n", "CodeBleu_score": 48.36444538658773}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\t// Set the authorization header with the access token.\n\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token)\n\n\t// Include parameters for supporting all drives.\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\n\t// Customize the request.\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\t// Send the request.\n\tclient := &http.Client{}\n\tresp, err = client.Do(req)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Handle errors.\n\tif resp.StatusCode == http.StatusUnauthorized {\n\t\t// Refresh the token and retry the request.\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t} else if resp.StatusCode!= http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status %d\", resp.StatusCode)\n\t}\n\n\t// Set the request result.\n\tif resp!= nil {\n\t\tif err := json.NewDecoder(resp.Body).Decode(resp); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Return the response body.\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}\n", "CodeBleu_score": 51.720073198911095}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\t// Create a new request.\n\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the authorization header with the access token.\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\t// Set the request parameters for supporting all drives.\n\treq.URL.RawQuery = \"supportsAllDrives=true\"\n\n\t// If a callback is provided, customize the request.\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\t// Send the request.\n\trespBody, err := d.sendRequest(req)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// If a response structure is provided, set the request result.\n\tif resp!= nil {\n\t\terr = json.Unmarshal(respBody, resp)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn respBody, nil\n}\n", "CodeBleu_score": 42.314766641470925}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\tvar err error\n\tvar respBody []byte\n\tvar req *http.Request\n\tvar respHeaders http.Header\n\tvar respStatus int\n\tvar respStatusText string\n\tvar respStatusCode int\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar respStatusText string\n\tvar resp", "CodeBleu_score": 6.152098096071555}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Get the chunk size\n\tchunkSize := d.chunkSize(stream.Size())\n\n\t// Upload the file in chunks\n\tfor i := 0; i < stream.Size(); i += chunkSize {\n\t\t// Get the next chunk\n\t\tchunk := stream.NextChunk(chunkSize)\n\n\t\t// Create the request\n\t\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, chunk)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the headers\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", i, i+chunkSize-1, stream.Size()))\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\n\t\t// Send the request\n\t\tresp, err := d.client.Do(req)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check for cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Check for errors\n\t\tif resp.StatusCode!= 200 && resp.StatusCode!= 201 {\n\t\t\treturn fmt.Errorf(\"failed to upload file: %s\", resp.Status)\n\t\t}\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 42.37936027460679}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Create a new HTTP request to upload the file.\n\treq, err := http.NewRequest(\"PUT\", url, stream)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Set the request headers.\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", stream.Size()-1, stream.Size()))\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"X-Upload-Content-Length\", strconv.FormatInt(stream.Size(), 10))\n\t// Create a new client to make the HTTP request.\n\tclient := &http.Client{}\n\t// Send the request.\n\tresp, err := client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Check the response status code.\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\t// Check the response headers.\n\tcontentRange := resp.Header.Get(\"Content-Range\")\n\tif contentRange == \"\" {\n\t\treturn fmt.Errorf(\"missing Content-Range header\")\n\t}\n\t// Parse the Content-Range header.\n\t_, err = fmt.Sscanf(contentRange, \"bytes %d-%d/%d\", &d.chunkStart, &d.chunkEnd, &d.chunkSize)\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"invalid Content-Range header: %s\", contentRange)\n\t}\n\t// Check if the context is cancelled.\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tdefault:\n\t}\n\t// Read the chunk from the file streamer.\n\tchunk := make([]byte, d.chunkSize)\n\tn, err := stream.Read(chunk)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Check if the number of bytes read is equal to the chunk size.\n\tif n!= d.chunkSize {\n\t\treturn fmt.Errorf(\"unexpected number of bytes read: %d\", n)\n\t}", "CodeBleu_score": 37.93859246308075}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Get the file size\n\tsize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the chunk size to 10 MB\n\tchunkSize := 10 * 1024 * 1024\n\n\t// Calculate the number of chunks\n\tnumChunks := int(math.Ceil(float64(size) / float64(chunkSize)))\n\n\t// Create a channel to receive the chunk upload results\n\tresultChan := make(chan error, numChunks)\n\n\t// Upload each chunk sequentially\n\tfor i := 0; i < numChunks; i++ {\n\t\t// Calculate the start and end offsets of the current chunk\n\t\tstartOffset := i * chunkSize\n\t\tendOffset := int(math.Min(float64(startOffset+chunkSize), float64(size)))\n\n\t\t// Create a new context with the cancellation token\n\t\tctx, cancel := context.WithCancel(ctx)\n\n\t\t// Create a goroutine to upload the current chunk\n\t\tgo func(startOffset int, endOffset int) {\n\t\t\t// Create a new context with the cancellation token\n\t\t\tctx, cancel := context.WithCancel(ctx)\n\n\t\t\t// Upload the current chunk\n\t\t\terr := d.uploadChunk(ctx, stream, url, startOffset, endOffset)\n\n\t\t\t// Send the result to the result channel\n\t\t\tresultChan <- err\n\n\t\t\t// Cancel the context\n\t\t\tcancel()\n\t\t}(startOffset, endOffset)\n\t}\n\n\t// Wait for all chunk upload goroutines to finish\n\tfor i := 0; i < numChunks; i++ {\n\t\t// Wait for a result from the result channel\n\t\terr := <-resultChan\n\n\t\t// Check for cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Cancelled\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\t// Continue\n\t\t}\n\n\t\t// Check for errors\n\t\tif err!= nil {\n\t\t\t// Error\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// No errors\n\treturn nil\n}\n", "CodeBleu_score": 40.61224230834123}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error\t// Bind JSON data from the request context\n\tvar req UmountStorageRequest\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Get mount point\n\tmountPoint := req.MountPoint\n\n\t// Return client error if mount point is empty\n\tif mountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"mount point cannot be empty\")\n\t}\n\n\t// Attempt to unmount storage\n\tif err := unmountStorage(mountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete configuration\n\tif err := deleteStorageConfig(mountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return success response\n\treturn ctx.NoContent(http.StatusNoContent)\n}", "CodeBleu_score": 39.1773322793812}, {"code": "func UmountStorage(ctx echo.Context) error\t// Get the mount point from the request context\n\tmountPoint := ctx.QueryParam(\"mount_point\")\n\t// If the mount point is empty, return a client error response\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point is empty\")\n\t}\n\t// Attempt to unmount the storage at the specified mount point\n\terr := unmountStorage(mountPoint)\n\t// If unmounting fails, return a service error response\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\t// Delete the corresponding configuration\n\terr = deleteStorageConfig(mountPoint)\n\t// If deleting the configuration fails, return a service error response\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, \"Storage successfully unmounted\")\n}\n", "CodeBleu_score": 31.348786749998002}, {"code": "func UmountStorage(ctx echo.Context) error\tvar storage Storage\n\tif err := ctx.Bind(&storage); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tif storage.MountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"mount_point is empty\")\n\t}\n\tif err := os.Unmount(storage.MountPoint, 0); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\tif err := DeleteStorage(storage.MountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"storage unmounted successfully\"})\n}\n", "CodeBleu_score": 36.57718932487337}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"file\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"File path is not provided\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"File does not exist\",\n\t\t})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}\n", "CodeBleu_score": 36.078449961686665}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is missing.\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": \"Missing file path.\",\n\t\t})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); err!= nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]interface{}{\n\t\t\t\"error\": \"File not found.\",\n\t\t})\n\t}\n\n\t// Read the file contents.\n\tfileContents, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"Failed to read file.\",\n\t\t})\n\t}\n\n\t// Return the file contents to the client.\n\treturn ctx.Blob(http.StatusOK, \"application/octet-stream\", fileContents)\n}\n", "CodeBleu_score": 36.16343873272833}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\t// If the file path is missing, return an error\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing file path\"})\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); err!= nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\t// Open the file\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Could not open file\"})\n\t}\n\t// Close the file when the function returns\n\tdefer file.Close()\n\t// Set the file name in the response header\n\tctx.Response().Header().Set(\"Content-Disposition\", \"attachment; filename=\"+filepath.Base(filePath))\n\t// Set the content type of the response\n\tctx.Response().Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t// Return the file to the client\n\treturn ctx.Stream(http.StatusOK, file.Name(), file)\n}\n", "CodeBleu_score": 34.5343940880802}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error\t// Get the \"name\" parameter from the request context\n\tname := ctx.Param(\"name\")\n\t// Bind the request body to a message map\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\t// If binding fails, return a bad request error with the binding error message\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := notifications.Send(name, message); err!= nil {\n\t\t// If sending fails, return an internal server error with the error message\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\t// If successful, return a success response\n\treturn ctx.JSON(http.StatusOK, \"Notification sent successfully\")\n}", "CodeBleu_score": 49.70543705711784}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.String(http.StatusBadRequest, \"name is required\")\n\t}\n\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\n\tif err := notify.Send(name, message); err!= nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.String(http.StatusOK, \"ok\")\n}", "CodeBleu_score": 49.09951160028544}, {"code": "func PostNotifyMessage(ctx echo.Context) error\t// Retrieve the name from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Create a new message map\n\tvar message map[string]interface{}\n\n\t// Bind the request body to the message map\n\tif err := ctx.Bind(&message); err!= nil {\n\t\t// If binding fails, return a bad request error with the binding error message\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := notifier.Send(name, message); err!= nil {\n\t\t// If sending fails, return an internal server error\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.NoContent(http.StatusOK)\n}\n", "CodeBleu_score": 49.198457111073004}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error\t// Get the WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\t// Add the connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Start the message sending service if it is not already running\n\tif!sendRunning {\n\t\tgo send()\n\t\tsendRunning = true\n\t}\n\t// Enter the loop to continuously read messages from the connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read the message\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tlog.Println(err)\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type\n\t\tlog.Println(\"Message type: \", ws.BinaryMessage)\n\t\t// Print the message\n\t\tlog.Println(\"Message: \", string(message))\n\t}\n}\n", "CodeBleu_score": 46.14733951917861}, {"code": "func NotifyWS(ctx echo.Context) error\t// Create a new WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it is not already running\n\tif!messageSendingServiceRunning {\n\t\tgo startMessageSendingService()\n\t\tmessageSendingServiceRunning = true\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Printf(\"Message type: %s\\n\", messageType(message))\n\t\tfmt.Printf(\"Message: %s\\n\", string(message))\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n", "CodeBleu_score": 42.67335520707023}, {"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP GET request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to a list of connections.\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running.\n\tif!sending {\n\t\tsending = true\n\t\tgo sendMessages()\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\t// If an error occurs, remove the WebSocket connection from the list of connections and close the connection.\n\t\t\tfor i, connection := range connections {\n\t\t\t\tif connection == ws {\n\t\t\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tws.Close()\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Printf(\"Message type: %d\\nMessage: %s\\nError: %v\\n\\n\", ws.Message, string(message), err)\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 44.050018265750765}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get the system information\n\tsystemInfo, err := GetSystemInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\t// Get the CPU information\n\tcpuInfo, err := GetCPUInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\t// Get the drive information\n\tdriveInfo, err := GetDriveInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\t// Return the system information\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"system_info\": systemInfo,\n\t\t\"cpu_info\":    cpuInfo,\n\t\t\"drive_info\":  driveInfo,\n\t})\n}", "CodeBleu_score": 20.102988087255653}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tvar (\n\t\terr error\n\t\tout []byte\n\t\tres = make(map[string]interface{})\n\t)\n\tif out, err = system.GetSystemHardwareInfo(); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\tif err = json.Unmarshal(out, &res); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, res)\n}\n", "CodeBleu_score": 27.280953488008862}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get the current system hardware information.\n\thardwareInfo, err := hardware.GetHardwareInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return the system hardware information.\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}\n", "CodeBleu_score": 12.887756069114614}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos*\") {\n\t\t\tif s.systemctl.ServiceStatus(service) == \"running\" {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}\n", "CodeBleu_score": 60.47527712197272}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\t// Get the list of services\n\tservices, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a map with the running and not running lists\n\tservicesMap := make(map[bool]*[]string)\n\tservicesMap[true] = new([]string)\n\tservicesMap[false] = new([]string)\n\n\t// Loop through the services and categorize them\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos*\") {\n\t\t\tif serviceStatus, err := s.systemctl.GetServiceStatus(service); err == nil {\n\t\t\t\tif serviceStatus == \"running\" {\n\t\t\t\t\t*servicesMap[true] = append(*servicesMap[true], service)\n\t\t\t\t} else {\n\t\t\t\t\t*servicesMap[false] = append(*servicesMap[false], service)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn servicesMap, nil\n}\n", "CodeBleu_score": 46.02235416499242}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\t// Get the list of services\n\tservices, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Separate the services into running and not running lists\n\tvar runningServices []string\n\tvar notRunningServices []string\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\t// Return the running and not running services in a map\n\tservicesMap := make(map[bool]*[]string)\n\tservicesMap[true] = &runningServices\n\tservicesMap[false] = &notRunningServices\n\treturn servicesMap, nil\n}\n", "CodeBleu_score": 60.2705058828686}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tmessageBytes, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message: %v\", err)\n\t\treturn\n\t}\n\tmessageString := string(messageBytes)\n\tlog.Printf(\"Sending notification %s with message %s\", name, messageString)\n\treq, err := http.NewRequest(\"POST\", i.notifyURL, bytes.NewBuffer(messageBytes))\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to create request: %v\", err)\n\t\treturn\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to send notification: %v\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode!= http.StatusOK {\n\t\tlog.Printf(\"Failed to send notification: %s\", resp.Status)\n\t\treturn\n\t}\n\tlog.Printf(\"Successfully sent notification %s\", name)\n}\n", "CodeBleu_score": 31.164032453350092}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\t// Serialize the message to JSON\n\tjsonBytes, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Error serializing message: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Create a new message\n\tmsg := &nats.Msg{\n\t\tSubject: name,\n\t\tData:    jsonBytes,\n\t}\n\n\t// Publish the message to the message bus\n\terr = i.bus.PublishMsg(msg)\n\tif err!= nil {\n\t\tlog.Printf(\"Error publishing message: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Wait for the response from the message bus\n\tresponse, err := i.bus.RequestMsg(msg)\n\tif err!= nil {\n\t\tlog.Printf(\"Error waiting for response: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Deserialize the response to a map\n\tvar responseMap map[string]interface{}\n\terr = json.Unmarshal(response.Data, &responseMap)\n\tif err!= nil {\n\t\tlog.Printf(\"Error deserializing response: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Check the response status code\n\tstatus, ok := responseMap[\"status\"]\n\tif!ok {\n\t\tlog.Printf(\"Response does not contain a status field\\n\")\n\t\treturn\n\t}\n\tstatusCode, ok := status.(float64)\n\tif!ok {\n\t\tlog.Printf(\"Status field is not a number\\n\")\n\t\treturn\n\t}\n\tif statusCode!= 200 {\n\t\tlog.Printf(\"Response status code is not OK: %v\\n\", statusCode)\n\t\treturn\n\t}\n\n\t// Log the success\n\tlog.Printf(\"Notification sent successfully\\n\")\n}\n\n\t}\n\n\t// Check if the response status code is OK\n\tstatus, ok := responseMap[\"status\"]\n\tif!ok {\n\t\tlog.Printf(\"Response does not contain a status field\\n\")\n\t\treturn\n\t}\n\tstatusCode, ok := status.(float64)\n\tif!ok {\n\t\tlog.Printf(\"Status field is not a number\\n\")\n\t\treturn\n\t}\n\tif statusCode!= 200 {\n\t\tlog", "CodeBleu_score": 35.681403159505834}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\t// serialize message to JSON string\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Println(\"Failed to serialize message to JSON:\", err)\n\t\treturn\n\t}\n\n\t// publish event to message bus\n\t_, err = i.client.Publish(i.topic, messageJSON)\n\tif err!= nil {\n\t\tlog.Println(\"Failed to publish event:\", err)\n\t\treturn\n\t}\n\n\t// log success\n\tlog.Println(\"Successfully published event:\", name)\n}", "CodeBleu_score": 31.98682715996523}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(c.runtimePath)\n\tif client.Server() == \"\" {\n\t\tclient.SetServer(message_bus.DefaultErrorServer)\n\t}\n\treturn client\n}\n", "CodeBleu_score": 18.93586612246371}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses()\n\tif err := client.Init(c.RuntimePath()); err!= nil {\n\t\tclient.SetServer(message_bus.NewError(err))\n\t\treturn client\n\t}\n\tif err := client.SetServer(c.MessageBusAddress()); err!= nil {\n\t\tclient.SetServer(message_bus.NewError(err))\n\t\treturn client\n\t}\n\treturn client\n}\n", "CodeBleu_score": 36.00524011880578}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tif c.messageBus == nil {\n\t\tc.messageBus = message_bus.NewClientWithResponses(c.runtimePath)\n\t}\n\treturn c.messageBus\n}\n", "CodeBleu_score": 20.343353892748787}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string\t// Get the IP address from the \"x-forwarded-for\" header\n\tforwardedFor := request.Header.Get(\"x-forwarded-for\")\n\tif forwardedFor!= \"\" {\n\t\t// Extract the first IP address from the \"x-forwarded-for\" header\n\t\tips := strings.Split(forwardedFor, \",\")\n\t\tif len(ips) > 0 {\n\t\t\treturn strings.TrimSpace(ips[0])\n\t\t}\n\t}\n\n\t// If the \"x-forwarded-for\" header is not available, use the remote address\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\n\t// Convert loopback addresses \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\"\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}\n", "CodeBleu_score": 48.33765909748266}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \":\")[0]\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 63.009250336138045}, {"code": "func GetIP(request *http.Request) string\tvar ip string\n\n\t// Check if the \"x-forwarded-for\" header is present.\n\tif forwarded := request.Header.Get(\"x-forwarded-for\"); forwarded!= \"\" {\n\t\t// Extract the first IP from the header.\n\t\tip = strings.Split(forwarded, \",\")[0]\n\t} else {\n\t\t// Use the remote address if the \"x-forwarded-for\" header is not present.\n\t\tip = request.RemoteAddr\n\t}\n\n\t// Convert \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\" for compatibility with older versions of Go.\n\tip = strings.Replace(ip, \"::ffff:\", \"\", 1)\n\tip = strings.Replace(ip, \"::1\", \"127.0.0.1\", 1)\n\n\treturn ip\n}", "CodeBleu_score": 56.56911249694573}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\t// Check if the entry file already exists\n\tif _, err := os.Stat(c.entryFile); err == nil {\n\t\t// The entry file already exists, so no need to generate it\n\t\treturn\n\t}\n\n\t// Check if the modules directory exists\n\tif _, err := os.Stat(c.modulesDir); err!= nil {\n\t\t// The modules directory does not exist, so no need to generate the entry file\n\t\treturn\n\t}\n\n\t// Create the entry file directory if it does not exist\n\tif err := os.MkdirAll(filepath.Dir(c.entryFile), 0755); err!= nil {\n\t\t// Failed to create the directory for the entry file\n\t\tc.logger.Errorf(\"Failed to create the directory for the entry file: %s\", err)\n\t\treturn\n\t}\n\n\t// Open the entry file for writing\n\tfile, err := os.Create(c.entryFile)\n\tif err!= nil {\n\t\t// Failed to open the entry file for writing\n\t\tc.logger.Errorf(\"Failed to open the entry file for writing: %s\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Read each module directory for entry.json files\n\tentries := []string{}\n\terr = filepath.Walk(c.modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\t// Check if the path is a directory and the file name is \"entry.json\"\n\t\tif info.IsDir() || info.Name()!= \"entry.json\" {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Open the entry.json file for reading\n\t\tentryFile, err := os.Open(path)\n\t\tif err!= nil {\n\t\t\t// Failed to open the entry.json file for reading\n\t\t\tc.logger.Errorf(\"Failed to open the entry.json file for reading: %s\", err)\n\t\t\treturn nil\n\t\t}\n\t\tdefer entryFile.Close()\n\n\t\t// Read the entry.json file contents\n\t\tentryBytes, err := ioutil.ReadAll(entryFile)\n\t\tif err!= nil {\n\t\t\t// Failed to read the entry.json file contents\n\t\t\tc.logger.Errorf(\"Failed to read the entry.json file contents: %s\", err)\n\t\t\treturn nil\n\t\t}", "CodeBleu_score": 35.65526432404289}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Set the path for the entry file\n\tentryFile := path.Join(c.modulesDirectory, \"entry.json\")\n\n\t// Create the entry file if it doesn't exist\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\t_, err := os.Create(entryFile)\n\t\tif err!= nil {\n\t\t\tlog.Println(\"Failed to create entry file:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Open the entry file for writing\n\tfile, err := os.OpenFile(entryFile, os.O_WRONLY|os.O_TRUNC, 0644)\n\tif err!= nil {\n\t\tlog.Println(\"Failed to open entry file for writing:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Create a new JSON encoder\n\tencoder := json.NewEncoder(file)\n\n\t// Set the indentation to 2 spaces\n\tencoder.SetIndent(\"\", \"  \")\n\n\t// Create an empty JSON array to hold the module entries\n\tmoduleEntries := []interface{}{}\n\n\t// Read the module directories\n\tmodulesDirectories, err := ioutil.ReadDir(c.modulesDirectory)\n\tif err!= nil {\n\t\tlog.Println(\"Failed to read module directories:\", err)\n\t\treturn\n\t}\n\n\t// Iterate over the module directories\n\tfor _, moduleDirectory := range modulesDirectories {\n\t\t// Skip directories that don't start with \"mod\"\n\t\tif!strings.HasPrefix(moduleDirectory.Name(), \"mod\") {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the path for the module entry file\n\t\tmoduleEntryFile := path.Join(c.modulesDirectory, moduleDirectory.Name(), \"entry.json\")\n\n\t\t// Open the module entry file for reading\n\t\tfile, err := os.Open(moduleEntryFile)\n\t\tif err!= nil {\n\t\t\tlog.Println(\"Failed to open module entry file for reading:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tdefer file.Close()\n\n\t\t// Create a new JSON decoder\n\t\tdecoder := json.NewDecoder(file)\n\n\t\t// Decode the module entry file into a JSON object\n\t\tmoduleEntry := map[string]interface{}{}\n\t\terr = decoder.Decode(&moduleEntry)\n\t\tif err!= nil {\n\t\t\tlog.Println(\"Failed to decode", "CodeBleu_score": 36.538726533458814}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Get the absolute path of the modules directory\n\tmodulesDir, err := filepath.Abs(c.config.ModulesDir)\n\tif err!= nil {\n\t\tlog.Printf(\"Error: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Get the absolute path of the entry file\n\tentryFile, err := filepath.Abs(c.config.EntryFile)\n\tif err!= nil {\n\t\tlog.Printf(\"Error: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Create an array to store the entry file contents\n\tvar entryFileContents []byte\n\n\t// Read each module directory for entry.json files\n\terr = filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the file is an entry.json file\n\t\tif info.Name() == \"entry.json\" {\n\t\t\t// Read the file contents\n\t\t\tfileContents, err := ioutil.ReadFile(path)\n\t\t\tif err!= nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Append the file contents to the entry file contents array\n\t\t\tentryFileContents = append(entryFileContents, fileContents...)\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tif err!= nil {\n\t\tlog.Printf(\"Error: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Write the entry file contents to the entry file path\n\terr = ioutil.WriteFile(entryFile, entryFileContents, 0644)\n\tif err!= nil {\n\t\tlog.Printf(\"Error: %v\\n\", err)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 42.51463428199451}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"Unable to find any MAC address\")\n}\n", "CodeBleu_score": 57.14321283420657}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := c.GetInterfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tif len(interfaces) == 0 {\n\t\treturn \"\", errors.New(\"No network interfaces found\")\n\t}\n\n\tnetworks, err := c.GetNetworks()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tif len(networks) == 0 {\n\t\treturn \"\", errors.New(\"No network names found\")\n\t}\n\n\tfor _, interfaceName := range interfaces {\n\t\tfor _, networkName := range networks {\n\t\t\tif strings.Contains(interfaceName, networkName) {\n\t\t\t\tmacAddress, err := c.GetMacAddressByName(interfaceName)\n\t\t\t\tif err!= nil {\n\t\t\t\t\treturn \"\", err\n\t\t\t\t}\n\t\t\t\treturn macAddress, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching interface found\")\n}\n", "CodeBleu_score": 55.57815628567524}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tvar macAddress string\n\tvar err error\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn macAddress, err\n\t}\n\tfor _, i := range interfaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err!= nil {\n\t\t\treturn macAddress, err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmacAddress = i.HardwareAddr.String()\n\t\t\treturn macAddress, nil\n\t\t}\n\t}\n\treturn macAddress, nil\n}\n", "CodeBleu_score": 51.36795833773748}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t ret = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (pTscObj->pAppObj!= NULL) {\n\t\t// Increment the request count for the application\n\t\tpTscObj->pAppObj->requestCount++;\n\t\t// Update the application's request summary\n\t\tpTscObj->pAppObj->requestSummary.totalRequestCount++;\n\t\tpTscObj->pAppObj->requestSummary.currentRequestCount++;\n\t}\n\n\t// Increment the request count for the TSC object\n\tpTscObj->requestCount++;\n\t// Update the TSC object's request summary\n\tpTscObj->requestSummary.totalRequestCount++;\n\tpTscObj->requestSummary.currentRequestCount++;\n\n\t// Add a reference to the request object\n\tpRequest->pRef = pTscObj;\n\n\t// Log debug information about the new request\n\tif (pRequest->pRef->pAppObj!= NULL) {\n\t\tLOG_DEBUG(\"New request (id=%d, type=%d, app=%s) registered for TSC object (id=%d, app=%s)\", pRequest->id, pRequest->type, pRequest->pRef->pAppObj->name, pRequest->pRef->id, pRequest->pRef->pAppObj->name);\n\t} else {\n\t\tLOG_DEBUG(\"New request (id=%d, type=%d) registered for TSC object (id=%d)\", pRequest->id, pRequest->type, pRequest->pRef->id);\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 33.05749159982868}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t status = 0;\n\n\t// Check if the request object is valid\n\tif (pRequest == NULL) {\n\t\tstatus = -1;\n\t\tgoto exit;\n\t}\n\n\t// Check if the TSC object is valid\n\tif (pTscObj == NULL) {\n\t\tstatus = -2;\n\t\tgoto exit;\n\t}\n\n\t// Check if the request is already registered\n\tif (pRequest->pTscObj!= NULL) {\n\t\tstatus = -3;\n\t\tgoto exit;\n\t}\n\n\t// Add a reference to the request object\n\tpRequest->pTscObj = pTscObj;\n\n\t// Increment the request count for the TSC object\n\tpTscObj->requestCount++;\n\n\t// Update the application's request summary, if applicable\n\tif (pTscObj->pAppObj!= NULL) {\n\t\tpTscObj->pAppObj->requestCount++;\n\t\tpTscObj->pAppObj->totalRequestCount++;\n\t}\n\n\t// Log debug information about the new request\n\tif (debug) {\n\t\tprintf(\"Request %p registered for TSC %p.\\n\", pRequest, pTscObj);\n\t}\n", "CodeBleu_score": 32.28333126450384}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t retCode = SUCCESS;\n\tuint32_t i;\n\n\t/* Check if the request is already registered */\n\tfor (i = 0; i < pTscObj->requestCount; i++) {\n\t\tif (pTscObj->pRequests[i] == pRequest) {\n\t\t\t/* Request is already registered */\n\t\t\tretCode = FAILURE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retCode == SUCCESS) {\n\t\t/* Add reference to the request object */\n\t\tpRequest->refCount++;\n\n\t\t/* Add reference to the TSC object */\n\t\tpTscObj->refCount++;\n\n\t\t/* Add request object to the TSC object */\n\t\tpTscObj->pRequests[pTscObj->requestCount++] = pRequest;\n\n\t\t/* Increment request count for the TSC object */\n\t\tpTscObj->requestCount++;\n\n\t\t/* Update application's request summary */\n\t\tif (pTscObj->pApp!= NULL) {\n\t\t\tpTscObj->pApp->requestCount++;\n\t\t\tpTscObj->pApp->currentRequestCount++;\n\t\t}\n\n\t\t/* Log debug information about the new request */\n\t\tif (g_debugLevel >= DEBUG_LEVEL_INFO) {\n\t\t\tif (pTscObj->pApp!= NULL) {\n\t\t\t\tprintf(\"TSC %d: Registered request %p (id=%d) for application %s (id=%d)\\n\",\n\t\t\t\t\t\tpTscObj->tscId, pRequest, pRequest->requestId, pTscObj->pApp->name, pTscObj->pApp->appId);\n\t\t\t} else {\n\t\t\t\tprintf(\"TSC %d: Registered request %p (id=%d) for application %s\\n\",\n\t\t\t\t\t\tpTscObj->tscId, pRequest, pRequest->requestId, pTscObj->pApp->name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn retCode;\n}\n", "CodeBleu_score": 26.066021282793177}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tchar *db;\n\tint i;\n\n\tif (pRequest->db_name == NULL) {\n\t\treturn false;\n\t}\n\n\tif (strcmp(pRequest->db_name, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < pRequest->db_name_count; i++) {\n\t\tdb = pRequest->db_names[i];\n\t\tif (db!= NULL && strncmp(db, \"schema\", 6)!= 0 && strcmp(db, exceptDb)!= 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 49.802647225982355}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tif (pRequest->db == NULL) {\n\t\treturn true;\n\t}\n\tif (strcmp(pRequest->db, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\tchar* db = pRequest->db;\n\tchar* p = strchr(db, '.');\n\tif (p!= NULL) {\n\t\tdb = p + 1;\n\t}\n\tbool isExceptDb = false;\n\twhile (db!= NULL) {\n\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\tisExceptDb = true;\n\t\t\tbreak;\n\t\t}\n\t\tdb = strchr(db, '.');\n\t\tif (db!= NULL) {\n\t\t\tdb++;\n\t\t}\n\t}\n\treturn!isExceptDb;\n}\n", "CodeBleu_score": 57.205353786442274}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tchar *db = pRequest->db;\n\tif (db!= NULL) {\n\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\tchar *db_ptr = db;\n\t\t\twhile (db_ptr!= NULL) {\n\t\t\t\tdb_ptr = strchr(db_ptr, '.');\n\t\t\t\tif (db_ptr!= NULL) {\n\t\t\t\t\tdb_ptr++;\n\t\t\t\t}\n\t\t\t\tif (db_ptr!= NULL && strcmp(db_ptr, exceptDb) == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 40.779632271114004}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tif (code == EACCES || code == EPERM || code == ESRCH) {\n\t\tif (msgType!= TMSG_FUSE_READDIR && msgType!= TMSG_FUSE_READDIRPLUS && msgType!= TMSG_FUSE_READLINK && msgType!= TMSG_FUSE_GETATTR && msgType!= TMSG_FUSE_GETXATTR && msgType!= TMSG_FUSE_LISTXATTR && msgType!= TMSG_FUSE_REMOVEXATTR && msgType!= TMSG_FUSE_SETXATTR && msgType!= TMSG_FUSE_UTIMES) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 41.03080077195641}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tif (code == RPC_REDIRECT) {\n\t\tif (msgType == MSG_RSP_RPC) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 31.023866631999276}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tbool ret = false;\n\tif (code == RFP_ERROR_CODE && msgType!= TMSG_RFP_ACK && msgType!= TMSG_RFP_NACK) {\n\t\tret = true;\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 24.366171218115053}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests)\tint i;\n\tfor (i = 0; i < pRequests->size; i++) {\n\t\tif (pRequests->table[i]!= NULL) {\n\t\t\tif (pRequests->table[i]->requestID!= -1) {\n\t\t\t\tif (pRequests->table[i]->query!= NULL) {\n\t\t\t\t\tif (pRequests->table[i]->query->query!= NULL) {\n\t\t\t\t\t\tif (pRequests->table[i]->query->query->query!= NULL) {\n\t\t\t\t\t\t\tstopQuery(pRequests->table[i]->query->query);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 30.717443844219233}, {"code": "void stopAllRequests(SHashObj *pRequests)\tint i;\n\tfor (i = 0; i < pRequests->size; i++) {\n\t\tif (pRequests->table[i]!= NULL) {\n\t\t\tif (pRequests->table[i]->requestID > 0) {\n\t\t\t\tstopQuery(pRequests->table[i]->requestID);\n\t\t\t}\n\t\t\treleaseRequest(pRequests->table[i]);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.170637919970936}, {"code": "void stopAllRequests(SHashObj *pRequests)\tint i;\n\tint requestID;\n\tint requestIDLen;\n\tchar *requestIDStr;\n\tint requestIDStrLen;\n\tSRequestObj *pRequest;\n\n\tfor (i = 0; i < pRequests->iSize; i++) {\n\t\trequestIDStr = pRequests->ppvValues[i];\n\t\trequestIDStrLen = strlen(requestIDStr);\n\t\trequestID = atoi(requestIDStr);\n\t\tif (requestIDStrLen > 0) {\n\t\t\tpRequest = getRequest(pRequests, requestID);\n\t\t\tif (pRequest!= NULL) {\n\t\t\t\tif (pRequest->pQuery!= NULL) {\n\t\t\t\t\tstopQuery(pRequest->pQuery);\n\t\t\t\t}\n\t\t\t\treleaseRequest(pRequests, pRequest);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.1264813639052}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport()\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_compare_exchange_strong(&tscCrashReportClientStop, &tscCrashReportClientStop, 1)) {\n\t\ttscLog(LOG_DEBUG, \"Stopping crash report thread\");\n\t\twhile (tscCrashReportClientStop) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\ttscLog(LOG_DEBUG, \"Crash report thread already stopped\");\n\t}\n}\n", "CodeBleu_score": 52.36272715441801}, {"code": "void tscStopCrashReport()\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\n\tint oldVal = 1;\n\tint newVal = 0;\n\twhile (atomic_compare_exchange_weak(&tscCrashReportClientStop, &oldVal, &newVal)) {\n\t\ttscLog(LOG_INFO, \"Crash report thread already stopped.\");\n\t\treturn;\n\t}\n\n\twhile (tscCrashReportClientStop) {\n\t\tusleep(100000);\n\t}\n}\n", "CodeBleu_score": 49.45072549797863}, {"code": "void tscStopCrashReport()\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\n\tint expected = 0;\n\tint desired = 1;\n\n\twhile (tscCrashReportClientStop.compare_exchange_strong(expected, desired)) {\n\t\t//log message indicating crash report thread is already stopped\n\t\tprintf(\"Crash report thread is already stopped\\n\");\n\t\treturn;\n\t}\n\n\t//wait for crash report thread to stop\n\twhile (tscCrashReportClientStop.load()!= 0) {\n\t\t//do nothing\n\t}\n}\n", "CodeBleu_score": 42.762289835456365}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t numViews = 0;\n\tint32_t numColumns = 0;\n\tint32_t numRows = 0;\n\tint32_t numRowsInView = 0;\n\tint32_t numRowsInViewTmp = 0;\n\tint32_t numRowsInViewTmp2 = 0;\n\tint32_t numRowsInViewTmp3 = 0;\n\tint32_t numRowsInViewTmp4 = 0;\n\tint32_t numRowsInViewTmp5 = 0;\n\tint32_t numRowsInViewTmp6 = 0;\n\tint32_t numRowsInViewTmp7 = 0;\n\tint32_t numRowsInViewTmp8 = 0;\n\tint32_t numRowsInViewTmp9 = 0;\n\tint32_t numRowsInViewTmp10 = 0;\n\tint32_t numRowsInViewTmp11 = 0;\n\tint32_t numRowsInViewTmp12 = 0;\n\tint32_t numRowsInViewTmp13 = 0;\n\tint32_t numRowsInViewTmp14 = 0;\n\tint32_t numRowsInViewTmp15 = 0;\n\tint32_t numRowsInViewTmp16 = 0;\n\tint32_t numRowsInViewTmp17 = 0;\n\tint32_t numRowsInViewTmp18 = 0;\n\tint32_t numRowsInViewTmp19 = 0;\n\tint32_t numRowsInViewTmp20 = 0;\n\tint32_t numRowsInViewTmp21 = 0;\n\tint32_t numRowsInViewTmp22 = 0;\n\tint32_t numRowsInViewTmp23 = 0;\n\tint32_t", "CodeBleu_score": 6.984040332291817}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t i;\n\tint32_t rc = 0;\n\tint32_t numViews = 0;\n\tint32_t numColumns = 0;\n\tint32_t numColumnsInView = 0;\n\tint32_t numColumnsInTable = 0;\n\tint32_t numColumnsInTableInView = 0;\n\tint32_t numColumnsInTableNotInView = 0;\n\tint32_t numColumnsInTableNotInViewInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewNotInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewNotInViewInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewNotInViewNotInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewNotInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewNotInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewNotInViewInView = 0;\n\tint32_t numColumnsInTableNotInViewNotInViewNotInViewNotInView", "CodeBleu_score": 5.733007610029478}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t errCode = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t numViews = 0;\n\tint32_t numColumns = 0;\n\tint32_t numColumnsInView = 0;\n\tint32_t numColumnsInViewInCatalog = 0;\n\tint32_t numColumnsInViewInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponse = 0;\n\tint32_t numColumnsInViewInCatalogInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponseInResponse = ", "CodeBleu_score": 6.373584676653371}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tS3Status status = S3StatusOK;\n\tS3CallbackData *data = (S3CallbackData *)callbackData;\n\n\tif (properties->content_length > 0) {\n\t\tdata->content_length = properties->content_length;\n\t} else {\n\t\tdata->content_length = 0;\n\t}\n\n\treturn status;\n}\n", "CodeBleu_score": 65.16223233083205}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tS3Status status = S3StatusOK;\n\tS3ResponsePropertiesCallbackData *cbData = (S3ResponsePropertiesCallbackData *)callbackData;\n\tif (properties->content_length > 0) {\n\t\tcbData->contentLength = properties->content_length;\n\t} else {\n\t\tcbData->contentLength = 0;\n\t}\n\treturn status;\n}\n", "CodeBleu_score": 63.67069310676779}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tif (properties->content_length > 0) {\n\t\t*(S3Uint64 *)callbackData = properties->content_length;\n\t} else {\n\t\t*(S3Uint64 *)callbackData = 0;\n\t}\n\treturn S3StatusOK;\n}\n", "CodeBleu_score": 58.82250193847798}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync()\t// create the directory for checkpoint backups\n\tif (mkdir(CHECKPOINT_BACKUP_DIR, 0777) == -1) {\n\t\t// log error if directory creation failed\n\t\tlogError(\"Failed to create directory for checkpoint backups.\");\n\t}\n\n\t// remove empty directories\n\tremoveEmptyDirectories(CHECKPOINT_BACKUP_DIR);\n\n\t// generate the Rsync configuration file\n\tif (!generateRsyncConfig()) {\n\t\t// log error if configuration file generation failed\n\t\tlogError(\"Failed to generate Rsync configuration file.\");\n\t}\n\n\t// construct and execute the command to start the Rsync daemon\n\tchar command[256];\n\tsprintf(command, \"rsync --daemon --config=%s --port=%d\", RSYNC_CONFIG_FILE, RSYNC_PORT);\n\tif (system(command) == -1) {\n\t\t// log error if Rsync server failed to start\n\t\tlogError(\"Failed to start Rsync server.\");\n\t} else {\n\t\t// log if Rsync server started successfully\n\t\tlogInfo(\"Rsync server started successfully.\");\n\t}\n}\n", "CodeBleu_score": 21.946193677808505}, {"code": "void startRsync()\t// Create the checkpoint backup directory if it doesn't exist\n\tif (mkdir(backupDir, 0777) == -1 && errno!= EEXIST) {\n\t\tlogError(\"Could not create backup directory\");\n\t\treturn;\n\t}\n\n\t// Remove empty directories\n\tchar *emptyDir = (char *) malloc(strlen(backupDir) + 2);\n\tstrcpy(emptyDir, backupDir);\n\tstrcat(emptyDir, \"/\");\n\tremoveEmptyDirs(emptyDir);\n\tfree(emptyDir);\n\n\t// Generate the Rsync configuration file\n\tif (!generateRsyncConfig()) {\n\t\tlogError(\"Could not generate Rsync configuration file\");\n\t\treturn;\n\t}\n\n\t// Construct and execute the command to start the Rsync daemon\n\tchar *command = (char *) malloc(strlen(backupDir) + strlen(rsyncConfig) + 100);\n\tstrcpy(command, \"rsync --daemon --port \");\n\tstrcat(command, port);\n\tstrcat(command, \" --config=\");\n\tstrcat(command, rsyncConfig);\n\tsystem(command);\n\tfree(command);\n\n\t// Log whether the Rsync server started successfully or if it encountered an error\n\tif (errno == 0) {\n\t\tlogInfo(\"Rsync server started\");\n\t} else {\n\t\tlogError(\"Could not start Rsync server\");\n\t}\n}\n", "CodeBleu_score": 42.496390266444806}, {"code": "void startRsync()\t// Create the checkpoint backup directory if it doesn't already exist\n\tif (!createDir(CHECKPOINT_BACKUP_DIR)) {\n\t\tlogError(\"Failed to create checkpoint backup directory\");\n\t\treturn;\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDirs(CHECKPOINT_BACKUP_DIR);\n\n\t// Generate the Rsync configuration file\n\tif (!generateConfigFile()) {\n\t\tlogError(\"Failed to generate Rsync configuration file\");\n\t\treturn;\n\t}\n\n\t// Construct and execute the command to start the Rsync daemon with the specified port and configuration file\n\tchar command[100];\n\tsprintf(command, \"rsync --daemon --no-detach --port=%d --config=%s\", RSYNC_PORT, CONFIG_FILE);\n\tif (system(command) == -1) {\n\t\tlogError(\"Failed to start Rsync server\");\n\t\treturn;\n\t}\n\n\t// Log whether the Rsync server started successfully or if it encountered an error\n\tif (WIFEXITED(status)) {\n\t\tif (WEXITSTATUS(status) == 0) {\n\t\t\tlogInfo(\"Rsync server started successfully\");\n\t\t} else {\n\t\t\tlogError(\"Rsync server encountered an error\");\n\t\t}\n\t} else {\n\t\tlogError(\"Rsync server encountered an error\");\n\t}\n}\n", "CodeBleu_score": 30.998865926175412}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId)\tif (dispatcherId == null) {\n\t\tthrow new RuntimeException(\"Dispatcher ID is null\");\n\t}\n\tif (dispatcherId.isEmpty()) {\n\t\tthrow new RuntimeException(\"Dispatcher ID is empty\");\n\t}\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n}\n", "CodeBleu_score": 47.54810908146379}, {"code": "public void destroyDispatcher(String dispatcherId)\tif (dispatcherId == null) {\n\t\tthrow new RuntimeException(\"The parameter 'dispatcherId' cannot be null.\");\n\t}\n\tif (this.dispatchers.containsKey(dispatcherId)) {\n\t\tthis.dispatchers.get(dispatcherId).shutdown();\n\t\tthis.dispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"The dispatcher with the specified ID is not registered.\");\n\t}\n}\n", "CodeBleu_score": 35.27353235604018}, {"code": "public void destroyDispatcher(String dispatcherId)\tif (dispatcherId == null) {\n\t\tthrow new NullPointerException(\"dispatcherId is null\");\n\t}\n\tif (dispatcherId.length() == 0) {\n\t\tthrow new IllegalArgumentException(\"dispatcherId is empty\");\n\t}\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\ttry {\n\t\t\tdispatchers.get(dispatcherId).shutdown();\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Exception while shutting down the dispatcher with ID \" + dispatcherId, e);\n\t\t}\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"The dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n}\n", "CodeBleu_score": 47.680290055967426}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)-  Map<TbActorId, TbActorRef> children = getChildren(parent);", "CodeBleu_score": 19.89184099607762}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)-  TbActorId[] children = getChildren(parent);", "CodeBleu_score": 19.76903588966534}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)-    List<TbActorId> children = actorMap.get(parent);", "CodeBleu_score": 22.894465318671664}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (msg.getType() == TbActorMsg.RULE_NODE_UPDATED_MSG) {\n\t\tif (isDestroyed()) {\n\t\t\tif (msg.getRuleNode().getRuleNode().getRuleNode().getType() == TbRuleNode.RULE_NODE_TYPE_INIT) {\n\t\t\t\tif (isInitFailed()) {\n\t\t\t\t\tif (isInitFailed()) {\n\t\t\t\t\t\tinitActor();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmsg.setActor(null);\n\t\t\t\tmsg.notifyActorStopped();\n\t\t\t}\n\t\t}\n\t}\n\tif (highPriority) {\n\t\thighPriorityMsgs.add(msg);\n\t} else {\n\t\tnormalPriorityMsgs.add(msg);\n\t}\n\tif (isDestroyed()) {\n\t\treturn;\n\t}\n\tif (isProcessing()) {\n\t\treturn;\n\t}\n\tprocessQueue();\n}\n", "CodeBleu_score": 48.75615897104056}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (msg.getMsgID() == RULE_NODE_UPDATED_MSG) {\n\t\tif (this.destroying) {\n\t\t\tif (msg.getMsgData() == RULE_NODE_UPDATED_MSG_REINITIALIZE) {\n\t\t\t\tthis.reinitialize();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.notifyMsg(msg, STOPPED_MSG);\n\t\t}\n\t\treturn;\n\t}\n\tif (highPriority) {\n\t\tthis.highPriorityMsgs.add(msg);\n\t} else {\n\t\tthis.normalPriorityMsgs.add(msg);\n\t}\n\tthis.processQueue();\n}\n", "CodeBleu_score": 33.14559126989184}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (destroying) {\n\t\tif (highPriority && msg.getType() == RULE_NODE_UPDATED_MSG) {\n\t\t\tif (!initialized) {\n\t\t\t\tif (logger.isLoggable(Level.FINER))\n\t\t\t\t\tlogger.finer(\"Reinitializing actor \" + this + \" after failed initialization\");\n\t\t\t\tinitialize();\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.notifyStopped();\n\t\t}\n\t} else {\n\t\tif (highPriority)\n\t\t\thighPriorityMsgs.add(msg);\n\t\telse\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\ttry {\n\t\t\tprocessQueue();\n\t\t} catch (Throwable t) {\n\t\t\tlogger.log(Level.SEVERE, \"Exception while processing actor message queue\", t);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.170296786720684}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox()\t// Set the actor's status to busy\n\tstatus = ActorStatus.BUSY;\n\n\t// Process messages from the high priority queue\n\twhile (highPriorityQueue.size() > 0) {\n\t\t// Get the next message from the high priority queue\n\t\tMessage message = highPriorityQueue.poll();\n\n\t\t// Process the message\n\t\ttry {\n\t\t\t// Process the message\n\t\t\tprocess(message);\n\t\t} catch (ActorInitializationException e) {\n\t\t\t// Set the stop reason\n\t\t\tstopReason = e.getStopReason();\n\n\t\t\t// Destroy the actor\n\t\t\tdestroy();\n\t\t} catch (ActorProcessException e) {\n\t\t\t// Log the failure\n\t\t\tlog.error(\"Error processing message: \" + message, e);\n\n\t\t\t// Apply the process failure strategy\n\t\t\tapplyProcessFailureStrategy(message, e);\n\t\t}\n\t}\n\n\t// Process messages from the normal priority queue\n\twhile (normalPriorityQueue.size() > 0) {\n\t\t// Get the next message from the normal priority queue\n\t\tMessage message = normalPriorityQueue.poll();\n\n\t\t// Process the message\n\t\ttry {\n\t\t\t// Process the message\n\t\t\tprocess(message);\n\t\t} catch (ActorInitializationException e) {\n\t\t\t// Set the stop reason\n\t\t\tstopReason = e.getStopReason();\n\n\t\t\t// Destroy the actor\n\t\t\tdestroy();\n\t\t} catch (ActorProcessException e) {\n\t\t\t// Log the failure\n\t\t\tlog.error(\"Error processing message: \" + message, e);\n\n\t\t\t// Apply the process failure strategy\n\t\t\tapplyProcessFailureStrategy(message, e);\n\t\t}\n\t}\n\n\t// Set the actor's status to free\n\tstatus = ActorStatus.FREE;\n\n\t// Schedule a queue processing attempt\n\tscheduleQueueProcessingAttempt();\n}\n", "CodeBleu_score": 24.389375422279493}, {"code": "private void processMailbox()\ttry {\n\t\tif (highPriorityQueue.isEmpty()) {\n\t\t\tif (normalPriorityQueue.isEmpty()) {\n\t\t\t\tstatus = ActorStatus.FREE;\n\t\t\t\tif (processFailureStrategy == ActorProcessFailureStrategy.STOP) {\n\t\t\t\t\tstopReason = ActorStopReason.NO_MESSAGES;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tstatus = ActorStatus.PROCESSING_NORMAL_PRIORITY_QUEUE;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = ActorStatus.PROCESSING_HIGH_PRIORITY_QUEUE;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tMessage message;\n\t\t\tif (status == ActorStatus.PROCESSING_HIGH_PRIORITY_QUEUE) {\n\t\t\t\tmessage = highPriorityQueue.poll();\n\t\t\t} else {\n\t\t\t\tmessage = normalPriorityQueue.poll();\n\t\t\t}\n\t\t\tif (message == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tprocess(message);\n\t\t\t} catch (ActorInitializationException e) {\n\t\t\t\tstopReason = ActorStopReason.INITIALIZATION_FAILURE;\n\t\t\t\tdestroy();\n\t\t\t\treturn;\n\t\t\t} catch (ActorProcessException e) {\n\t\t\t\tif (processFailureStrategy == ActorProcessFailureStrategy.LOG) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t} else {\n\t\t\t\t\tdestroy();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tif (status == ActorStatus.PROCESSING_HIGH_PRIORITY_QUEUE) {\n\t\t\tstatus = ActorStatus.PROCESSING_NORMAL_PRIORITY_QUEUE;\n\t\t} else if (status == ActorStatus.PROCESSING_NORMAL_PRIORITY_QUEUE) {\n\t\t\tstatus = ActorStatus.FREE;\n\t\t}\n\t\tif (status == ActorStatus.FREE) {\n\t\t\tscheduleQueueProcessingAttempt();\n\t\t}\n\t}\n}", "CodeBleu_score": 27.58275011193231}, {"code": "private void processMailbox()\tif (status!= ActorStatus.FREE) {\n\t\treturn;\n\t}\n\tstatus = ActorStatus.BUSY;\n\ttry {\n\t\tif (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n\t\t\tstatus = ActorStatus.FREE;\n\t\t\treturn;\n\t\t}\n\t\tif (highPriorityQueue.isEmpty()) {\n\t\t\tprocessQueue(normalPriorityQueue);\n\t\t} else {\n\t\t\tprocessQueue(highPriorityQueue);\n\t\t}\n\t} catch (ActorInitializationException e) {\n\t\tstatus = ActorStatus.STOPPED;\n\t\tstopReason = e.getMessage();\n\t\tdestroy();\n\t} catch (ActorException e) {\n\t\tlogger.error(\"Actor \" + name + \" threw an exception while processing a message\", e);\n\t\tprocessFailureStrategy.apply(e);\n\t}\n\tstatus = ActorStatus.FREE;\n}\n", "CodeBleu_score": 17.44520670908156}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause)\tif (this.stopReason == null) {\n\t\tthis.stopReason = cause;\n\t}\n\tif (this.destroyed) {\n\t\treturn;\n\t}\n\tthis.destroyed = true;\n\tthis.dispatcher.executor().execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tif (destroyed) {\n\t\t\t\t\tActor.this.destroy();\n\t\t\t\t}\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlogger.warn(\"Exception during actor destruction\", t);\n\t\t\t}\n\t\t}\n\t});\n}\n", "CodeBleu_score": 20.27975320062038}, {"code": "public void destroy(Throwable cause)\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tif (destroyInProgress) {\n\t\treturn;\n\t}\n\tdestroyInProgress = true;\n\tdispatcher.execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tdestroy();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlogger.warn(\"Error in destroy method of actor {}.\", actorId, t);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tnotifyAll();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlogger.warn(\"Error in notifyAll method of actor {}.\", actorId, t);\n\t\t\t}\n\t\t}\n\t});\n}\n", "CodeBleu_score": 36.18748083060701}, {"code": "public void destroy(Throwable cause)\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tif (destroyInProgress) {\n\t\treturn;\n\t}\n\tdestroyInProgress = true;\n\tdispatcher.executor().execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tdestroy();\n\t\t\t} catch (Throwable e) {\n\t\t\t\tlog.warn(\"Exception during actor destruction\", e);\n\t\t\t}\n\t\t\tsynchronized (queue) {\n\t\t\t\tqueue.notifyAll();\n\t\t\t}\n\t\t}\n\t});\n}\n", "CodeBleu_score": 25.27875305331875}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\t// TODO: check if the tenant ID is the system tenant ID\n\t// TODO: retrieve the tenant profile\n\t// TODO: check if the tenant profile is found\n\t// TODO: check if the tenant profile is found and the ignoreTenantNotFound flag is set\n\t// TODO: retrieve the rate limit configuration from the tenant profile\n\t// TODO: check the rate limit\n\t// TODO: process the rate limit notification\n\t// TODO: return the rate limit check result\n\treturn true;\n}", "CodeBleu_score": 6.386942465385546}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\tif (tenantId.equals(TenantId.SYSTEM_TENANT)) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileDao.getTenantProfile(tenantId);\n\tif (tenantProfile == null && ignoreTenantNotFound) {\n\t\treturn true;\n\t}\n\tif (tenantProfile == null) {\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tRateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n\tif (rateLimitConfiguration == null) {\n\t\treturn true;\n\t}\n\tif (rateLimitConfiguration.isRateLimitExceeded(api, level)) {\n\t\tprocessRateLimitNotification(tenantId, api, level);\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 41.64383768524117}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\tTenantProfile tenantProfile = null;\n\ttry {\n\t\ttenantProfile = tenantProfileService.getTenantProfile(tenantId);\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tRateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n\tif (rateLimitConfiguration!= null) {\n\t\tRateLimitConfiguration.RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n\t\tif (rateLimit!= null) {\n\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\tlong lastRequestTime = rateLimit.getLastRequestTime(level);\n\t\t\tlong timeSinceLastRequest = currentTime - lastRequestTime;\n\t\t\tif (timeSinceLastRequest < rateLimit.getTimeWindow()) {\n\t\t\t\tlong requestsSinceLastRequest = rateLimit.getRequestsSinceLastRequest(level);\n\t\t\t\tif (requestsSinceLastRequest >= rateLimit.getMaxRequests()) {\n\t\t\t\t\trateLimit.setLastRequestTime(level, currentTime);\n\t\t\t\t\trateLimit.setRequestsSinceLastRequest(level, 0);\n\t\t\t\t\trateLimitNotificationService.processRateLimitNotification(tenantId, api, level, timeSinceLastRequest, requestsSinceLastRequest);\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\trateLimit.setRequestsSinceLastRequest(level, requestsSinceLastRequest + 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trateLimit.setLastRequestTime(level, currentTime);\n\t\t\t\trateLimit.setRequestsSinceLastRequest(level, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 40.84889400310043}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions()\t// TODO Auto-generated method stub\n\t\n}\n", "CodeBleu_score": 1.4758131806204684}, {"code": "public void evictTimeoutSessions()\t// TODO Auto-generated method stub\n\n}\n", "CodeBleu_score": 1.4758131806204684}, {"code": "public void evictTimeoutSessions()\tlong currentTimeMillis = System.currentTimeMillis();\n\tlong expirationTime = currentTimeMillis - inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tdtlsSessions.remove(entry.getKey());\n\t\t\tlogger.info(\"Removed DTLS session with ID \" + entry.getKey() + \" because it has been inactive for more than \" + inactivityTimeout + \" milliseconds\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.2176246405208}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tif (timeseries.isEmpty()) {\n\t\treturn new ArrayList<TsKvEntry>();\n\t}\n\tList<TsKvEntry> entries = new ArrayList<TsKvEntry>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tList<TsKvEntry.Value> tsValues = new ArrayList<TsKvEntry.Value>();\n\t\tfor (JsonNode value : values) {\n\t\t\ttsValues.add(TsKvEntry.Value.of(value.asDouble()));\n\t\t}\n\t\tentries.add(TsKvEntry.of(key, tsValues));\n\t}\n\treturn entries;\n}", "CodeBleu_score": 30.431185920845138}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tif (timeseries.isEmpty()) {\n\t\treturn new ArrayList<>();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tList<TsKvEntry.TsKvValue> tsKvValues = new ArrayList<>();\n\t\tfor (JsonNode value : values) {\n\t\t\tif (value.isDouble()) {\n\t\t\t\ttsKvValues.add(new TsKvEntry.TsKvValue(value.asDouble()));\n\t\t\t} else if (value.isLong()) {\n\t\t\t\ttsKvValues.add(new TsKvEntry.TsKvValue(value.asLong()));\n\t\t\t} else if (value.isTextual()) {\n\t\t\t\ttsKvValues.add(new TsKvEntry.TsKvValue(value.asText()));\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported value type: \" + value.getNodeType());\n\t\t\t}\n\t\t}\n\t\tresult.add(new TsKvEntry(key, tsKvValues));\n\t}\n\treturn result;\n}", "CodeBleu_score": 34.33860093752384}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tList<TsKvEntry> entries = new ArrayList<TsKvEntry>();\n\tif (!timeseries.isEmpty()) {\n\t\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\t\tentries.add(new TsKvEntry(entry.getKey(), toTimeseries(entry.getValue())));\n\t\t}\n\t}\n\treturn entries;\n}\n", "CodeBleu_score": 24.440100498140954}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken()\t// Create a request map containing the current refresh token\n\tMap<String, String> requestMap = new HashMap<String, String>();\n\trequestMap.put(\"refresh_token\", this.refreshToken);\n\t// Send a POST request to the authentication endpoint\n\tMap<String, String> responseMap = this.sendPostRequest(this.refreshEndpoint, requestMap);\n\t// Update the token information with the current timestamp and the response body\n\tthis.accessToken = responseMap.get(\"access_token\");\n\tthis.refreshToken = responseMap.get(\"refresh_token\");\n\tthis.tokenType = responseMap.get(\"token_type\");\n\tthis.expiresIn = responseMap.get(\"expires_in\");\n\tthis.expiresAt = System.currentTimeMillis() + Long.parseLong(this.expiresIn) * 1000;\n}\n", "CodeBleu_score": 34.63466910253491}, {"code": "public void refreshToken()\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\ttry {\n\t\tString response = HttpRequest.sendPost(this.refreshTokenEndpoint, requestMap);\n\t\tJSONObject responseObject = new JSONObject(response);\n\t\tthis.accessToken = responseObject.getString(\"accessToken\");\n\t\tthis.refreshToken = responseObject.getString(\"refreshToken\");\n\t\tthis.tokenExpiration = responseObject.getLong(\"tokenExpiration\");\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n}", "CodeBleu_score": 41.05594596040652}, {"code": "public void refreshToken()\tMap<String, String> requestMap = new HashMap<String, String>();\n\trequestMap.put(\"refresh_token\", this.refreshToken);\n\n\tMap<String, String> responseMap = new HashMap<String, String>();\n\tresponseMap = this.sendRequest(this.refreshTokenEndpoint, requestMap, \"POST\");\n\n\tthis.token = responseMap.get(\"access_token\");\n\tthis.refreshToken = responseMap.get(\"refresh_token\");\n\tthis.tokenExpirationTime = responseMap.get(\"expires_in\");\n}\n", "CodeBleu_score": 35.17634516040299}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin()\t// Create a login request map with the credentials\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\n\t// Send the login request to the authentication endpoint\n\ttry {\n\t\tResponse response = Unirest.post(authEndpoint + \"/login\")\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.body(loginRequest)\n\t\t\t\t.asJson();\n\n\t\t// Update the token information with the response data and the timestamp\n\t\ttoken = response.getBody().getObject().getString(\"token\");\n\t\ttokenTimestamp = System.currentTimeMillis();\n\n\t\t// Log the login information\n\t\tLog.i(\"Login\", \"Login successful\");\n\t\tLog.i(\"Login\", \"Token: \" + token);\n\t\tLog.i(\"Login\", \"Timestamp: \" + tokenTimestamp);\n\t} catch (UnirestException e) {\n\t\t// Handle the exception\n\t\tLog.e(\"Login\", \"Error: \" + e.getMessage());\n\t}\n}", "CodeBleu_score": 51.82092642550226}, {"code": " private void doLogin()\t//Create a login request map\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\t//Send the login request\n\tRestTemplate restTemplate = new RestTemplate();\n\tResponseEntity<Map> response = restTemplate.postForEntity(authEndpoint + \"/login\", loginRequest, Map.class);\n\t//Update the token information\n\ttoken = (String) response.getBody().get(\"token\");\n\ttokenTimestamp = System.currentTimeMillis();\n\t//Update the token information in the application context\n\tappContext.setToken(token);\n\tappContext.setTokenTimestamp(tokenTimestamp);\n\t//Update the login status\n\tappContext.setLoginStatus(true);\n\t//Update the username\n\tappContext.setUsername(username);\n\t//Update the password\n\tappContext.setPassword();\n\t//Update the authentication endpoint\n\tappContext.setAuthEndpoint(authEndpoint);\n\t//Update the user endpoint\n\tappContext.setUserEndpoint(userEndpoint);\n\t//Update the user ID\n\tappContext.setUserId(userId);\n\t//Update the user name\n\tappContext.setUserName(userName);\n\t//Update the user email\n\tappContext.setUserEmail(userEmail);\n\t//Update the user phone number\n\tappContext.setUserPhoneNumber(userPhoneNumber);\n\t//Update the user image\n\tappContext.setUserImage(userImage);\n\t//Update the user role\n\tappContext.setUserRole(userRole);\n\t//Update the user status\n\tappContext.setUserStatus(userStatus);\n\t//Update the user registration date\n\tappContext.setUserRegistrationDate(userRegistrationDate);\n\t//Update the user last login date\n\tappContext.setUserLastLoginDate(userLastLoginDate);\n\t//Update the user last login IP\n\tappContext.setUserLastLoginIP(userLastLoginIP);\n\t//Update the user last login device\n\tappContext.setUserLastLoginDevice(userLastLoginDevice);\n\t//Update the user last login browser\n\tappContext.setUserLastLoginBrowser(userLastLoginBrowser);\n\t//Update the user last login OS\n\tappContext.setUserLastLoginOS(userLastLoginOS);\n\t//Update", "CodeBleu_score": 51.18277921662511}, {"code": " private void doLogin() String username = mUsernameEditText.getText().toString();\n String password = mPasswordEditText.getText().toString();\n if (username.isEmpty() || password.isEmpty()) {\n Toast.makeText(this, \"Please enter your username and password to login.\", Toast.LENGTH_LONG).show();\n return;\n }\n Map loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", );\n long timestamp = System.currentTimeMillis();\n mLoginRequest = loginRequest;\n mLoginRequestTimestamp = timestamp;\n mLoginRequestTimestampMap.put(timestamp, mLoginRequest);\n mLoginRequestTimestampMap.remove(timestamp);\n }\n", "CodeBleu_score": 47.46310201548161}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\ttry {\n\t\treturn Optional.of(get(deviceId, Device.class));\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 30.755525193575416}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\treturn getDeviceById(deviceId, null);\n}\n", "CodeBleu_score": 6.280489801367669}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\treturn getDeviceById(deviceId, null);\n}\n", "CodeBleu_score": 6.280489801367669}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\ttry {\n\t\treturn Optional.of(post(Device.class, \"/api/device-with-credentials\", device, credentials));\n\t} catch (HttpStatusCodeException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 30.413186264407603}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\t// create the request object\n\tRequest request = new Request.Builder()\n\t\t.url(baseUrl + \"/api/device-with-credentials\")\n\t\t.post(RequestBody.create(MediaType.parse(\"application/json\"), gson.toJson(new DeviceWithCredentials(device, credentials))))\n\t\t.build();\n\n\t// attempt to send the request\n\ttry (Response response = client.newCall(request).execute()) {\n\t\t// if the response is successful, parse the response body as a Device object\n\t\tif (response.isSuccessful()) {\n\t\t\treturn Optional.of(gson.fromJson(response.body().string(), Device.class));\n\t\t}\n\t\t// if the response is a 404 error, return an empty Optional\n\t\telse if (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\t// otherwise, rethrow any other exceptions encountered\n\t\telse {\n\t\t\tthrow new RuntimeException(\"Error: \" + response.code() + \" \" + response.message());\n\t\t}\n\t}\n\tcatch (IOException e) {\n\t\tthrow new RuntimeException(\"Error: \" + e.getMessage());\n\t}\n}", "CodeBleu_score": 49.132248112493876}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\tif (device == null) {\n\t\tthrow new IllegalArgumentException(\"device cannot be null\");\n\t}\n\tif (credentials == null) {\n\t\tthrow new IllegalArgumentException(\"credentials cannot be null\");\n\t}\n\tRequest request = new Request.Builder()\n\t\t.url(baseUrl + \"/api/device-with-credentials\")\n\t\t.post(RequestBody.create(MediaType.parse(\"application/json\"), gson.toJson(new DeviceWithCredentials(device, credentials))))\n\t\t.build();\n\ttry {\n\t\tResponse response = client.newCall(request).execute();\n\t\tif (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else if (response.code()!= 201) {\n\t\t\tthrow new RuntimeException(\"unexpected response code: \" + response.code());\n\t\t}\n\t\treturn Optional.of(gson.fromJson(response.body().string(), Device.class));\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n", "CodeBleu_score": 45.66104775228531}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val)\tthis.send(addr, 0x10, val);\n\treturn this;\n}\n", "CodeBleu_score": 20.389423303539967}, {"code": "brightness(addr, val)\tthis.send(addr, [0x02, val]);\n\treturn this;\n}\n", "CodeBleu_score": 20.38176949664155}, {"code": "brightness(addr, val)\treturn this.send(this.cmd(0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00", "CodeBleu_score": 7.063892474513899}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr)\tvar self = this;\n\tvar proto = LedControl.prototype;\n\tvar keys = Object.keys(proto);\n\tvar obj = {};\n\tkeys.forEach(function(key) {\n\t\tif (proto[key] instanceof Function) {\n\t\t\tobj[key] = proto[key].bind(self, addr);\n\t\t}\n\t});\n\treturn obj;\n}\n", "CodeBleu_score": 25.227530609121356}, {"code": "device(addr)\tconst self = this;\n\tconst methods = {};\n\tfor (const key in LedControl.prototype) {\n\t\tif (LedControl.prototype.hasOwnProperty(key)) {\n\t\t\tmethods[key] = LedControl.prototype[key].bind(self, addr);\n\t\t}\n\t}\n\treturn methods;\n}\n", "CodeBleu_score": 24.979639135868066}, {"code": "device(addr)\tconst dev = Object.create(LedControl.prototype);\n\tfor (const key in LedControl.prototype) {\n\t\tdev[key] = LedControl.prototype[key].bind(dev, addr);\n\t}\n\treturn dev;\n}\n", "CodeBleu_score": 20.2871092223274}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => \tmethods.forEach(method => {\n\t\ttarget[method + 'CallbackReconciliation'] = (duration = 1000) => {\n\t\t\tif (!isFunction(target[method])) {\n\t\t\t\tthrow new Error(`The method ${method} does not exist on the target object.`);\n\t\t\t}\n\t\t\tif (!isFunction(target.callback)) {\n\t\t\t\tthrow new Error(`The callback function does not exist on the target object.`);\n\t\t\t}\n\t\t\tif (!isNumber(duration)) {\n\t\t\t\tthrow new Error(`The duration must be a number.`);\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\ttarget.forEach(element => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\ttarget[method](element);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\ttarget.callback();\n\t\t\t});\n\t\t};\n\t});\n};\n", "CodeBleu_score": 24.019610883443406}, {"code": "Collection.installCallbackReconciliation = (target, methods) => \tmethods.forEach(method => {\n\t\ttarget[method + \"Callback\"] = (duration = 1000, callback = () => {}) => {\n\t\t\tif (typeof callback!== \"function\") {\n\t\t\t\tthrow new TypeError(\"The callback must be a function.\");\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tthis.forEach(element => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\telement[method]();\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n};\n", "CodeBleu_score": 27.471728360131344}, {"code": "Collection.installCallbackReconciliation = (target, methods) => \tmethods.forEach(method => {\n\t\ttarget[method + 'Reconciliation'] = (duration = 1000) => {\n\t\t\tif (!target.hasOwnProperty(method)) {\n\t\t\t\tthrow new Error(`The method \"${method}\" does not exist on the target object.`);\n\t\t\t}\n\t\t\tif (typeof target[method]!== 'function') {\n\t\t\t\tthrow new Error(`The method \"${method}\" is not a function.`);\n\t\t\t}\n\t\t\tif (typeof duration!== 'number') {\n\t\t\t\tthrow new Error(`The duration \"${duration}\" is not a number.`);\n\t\t\t}\n\t\t\tif (typeof duration!== 'number') {\n\t\t\t\tthrow new Error(`The duration \"${duration}\" is not a number.`);\n\t\t\t}\n\t\t\tif (typeof target.callback!== 'function') {\n\t\t\t\tthrow new Error('The callback is not a function.');\n\t\t\t}\n\t\t\tlet promises = [];\n\t\t\ttarget.forEach(element => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\ttarget[method](element);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\ttarget.callback();\n\t\t\t});\n\t\t};\n\t});\n};\n", "CodeBleu_score": 26.177398150533648}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen()\tlet input = \"\";\n\tlet incompleteSentence = \"\";\n\n\t// Create a read stream for the specified serial port\n\tconst serialPort = new SerialPort(this.serialPortName, { baudRate: this.baudRate });\n\n\t// Start a read loop\n\tserialPort.on(\"data\", data => {\n\t\t// Append the data to the input string\n\t\tinput += data.toString();\n\n\t\t// Split the input string into sentences based on the \"\\r\\n\" delimiter\n\t\tconst sentences = input.split(\"\\r\\n\");\n\n\t\t// Process each complete sentence\n\t\tfor (let i = 0; i < sentences.length - 1; i++) {\n\t\t\t// Parse the sentence and store the result\n\t\t\tconst result = this.parseNmeaSentence(sentences[i]);\n\n\t\t\t// If the result is not null, emit the \"data\" event with the result\n\t\t\tif (result!== null) {\n\t\t\t\tthis.emit(\"data\", result);\n\t\t\t}\n\t\t}\n\n\t\t// Save the last sentence for the next read\n\t\tincompleteSentence = sentences[sentences.length - 1];\n\t});\n\n\t// Return the serial port\n\treturn serialPort;\n}\n", "CodeBleu_score": 54.471867681984044}, {"code": "listen()\tlet input = \"\";\n\tlet incompleteSentence = \"\";\n\tlet port = this.serialPort;\n\tlet serialPort = this.serialPort;\n\tlet serialPortName = this.serialPortName;\n\tlet serialPortBaudRate = this.serialPortBaudRate;\n\tlet serialPortReadInterval = this.serialPortReadInterval;\n\tlet serialPortReadIntervalTimeout;\n\tlet serialPortReadIntervalTimeoutValue = this.serialPortReadIntervalTimeoutValue;\n\tlet serialPortReadIntervalTimeoutFunction = this.serialPortReadIntervalTimeoutFunction;\n\tlet serialPortReadIntervalTimeoutFunctionArguments = this.serialPortReadIntervalTimeoutFunctionArguments;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsLength = this.serialPortReadIntervalTimeoutFunctionArgumentsLength;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsIndex = this.serialPortReadIntervalTimeoutFunctionArgumentsIndex;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValue = this.serialPortReadIntervalTimeoutFunctionArgumentsValue;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndex = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndex;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueLength = this.serialPortReadIntervalTimeoutFunctionArgumentsValueLength;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValue = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValue;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueLength = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueLength;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndex = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndex;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValue = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValue;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValueLength = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValueLength;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValueIndex = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValueIndex;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValueIndexValue = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValueIndexValue;\n\tlet serialPortReadIntervalTimeoutFunctionArgumentsValueIndexValueIndexValueIndexValueLength = this.serialPortReadIntervalTimeoutFunctionArgumentsValueIndex", "CodeBleu_score": 16.95706671595481}, {"code": "listen()\tlet input = \"\";\n\tlet incompleteSentence = \"\";\n\tlet port = this.serialPort;\n\tlet parser = this;\n\n\tport.on(\"data\", function(data) {\n\t\tinput += data.toString();\n\t\tlet sentences = input.split(\"\\r\\n\");\n\t\tinput = sentences.pop();\n\t\tsentences.forEach(function(sentence) {\n\t\t\tparser.parseNmeaSentence(sentence);\n\t\t});\n\t});\n}\n", "CodeBleu_score": 37.336566607327946}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tconst struct adc_ad559x_data *data = dev->data;\n\tsize_t num_channels = sequence->channels? sequence->channels->size : 0;\n\tsize_t buffer_size = sequence->buffer_size;\n\tsize_t sample_size = sizeof(uint16_t);\n\tsize_t active_channels;\n\tint ret;\n\n\tif (num_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_channels > 1) {\n\t\tactive_channels = num_channels;\n\t} else {\n\t\tactive_channels = 1;\n\t}\n\n\tif (buffer_size < active_channels * sample_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The buffer size must be a multiple of the number of active channels.\n\t * If the buffer size is not a multiple of the number of active channels,\n\t * the remaining data is discarded.\n\t */\n\tif (buffer_size % active_channels!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If the buffer size is not a multiple of the sample size, the remaining\n\t * data is discarded.\n\t */\n\tif (buffer_size % sample_size!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * The buffer size must be a multiple of the number of active channels\n\t * and the sample size.\n\t */\n\tif (buffer_size % (active_channels * sample_size)!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The buffer size must be a multiple of the number of active channels\n\t * and the sample size.\n\t */\n\tif (buffer_size % (active_channels * sample_size)!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 49.60300720781342}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t active_channels = 0;\n\tuint32_t buffer_size = 0;\n\tuint8_t i;\n\n\t/* Calculate the number of active channels and the buffer size based on the number of channels and the size of each data sample */\n\tfor (i = 0; i < sequence->channels_num; i++) {\n\t\tif (sequence->channels[i] < data->num_channels) {\n\t\t\tactive_channels++;\n\t\t\tbuffer_size += sequence->buffer_size;\n\t\t}\n\t}\n\n\t/* Check if the buffer size is sufficient */\n\tif (buffer_size < active_channels * sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 41.58082239045}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t buffer_size;\n\tuint32_t sample_size;\n\tuint32_t num_channels;\n\n\t/* Validate the buffer size */\n\tbuffer_size = sequence->options & ADC_SCAN_FLAGS_BUFFER_VALID;\n\tif (buffer_size < sequence->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Calculate the number of active channels */\n\tnum_channels = 0;\n\tfor (uint32_t i = 0; i < sequence->buffer_size; i++) {\n\t\tif (sequence->buffer[i]!= ADC_VALUE_INVALID) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\t/* Calculate the needed buffer size */\n\tsample_size = sizeof(uint16_t);\n\tbuffer_size = num_channels * sample_size;\n\tif (buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Check the buffer alignment */\n\tif (IS_ENABLED(CONFIG_ADC_AD559X_ALIGN_BUFFER) &&\n\t   !IS_ALIGNED(sequence->buffer, sample_size)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 51.391631139970485}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution %d, expected %d\", sequence->resolution, config->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < sequence->channels_count; i++) {\n\t\tif (sequence->channels[i] >= config->channels_count) {\n\t\t\tLOG_ERR(\"Invalid channel %d\", sequence->channels[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < sequence->channels_count) {\n\t\tLOG_ERR(\"Insufficient buffer size %d, expected at least %d\", sequence->buffer_size, sequence->channels_count);\n\t\treturn -EINVAL;\n\t}\n\n\tk_mutex_lock(&data->mutex, K_FOREVER);\n\n\tif (data->read_context) {\n\t\tLOG_ERR(\"ADC read already in progress\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tdata->read_context = sequence;\n\tdata->read_buffer = sequence->buffer;\n\tdata->read_buffer_size = sequence->buffer_size;\n\tdata->read_buffer_index = 0;\n\n\tret = adc_ad559x_start_read_context(dev);\n\tif (ret < 0) {\n\t\tdata->read_context = NULL;\n\t\tgoto out;\n\t}\n\n\tk_sem_take(&data->read_sem, K_FOREVER);\n\tret = data->read_result;\n", "CodeBleu_score": 52.73206476052127}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= data->resolution) {\n\t\tLOG_ERR(\"ADC resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels[0] >= data->channels_count) {\n\t\tLOG_ERR(\"Invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < data->channels_count) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = ad559x_adc_read_context_start(data->ad559x, sequence->channels[0]);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to start ADC read context\");\n\t\treturn ret;\n\t}\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn 0;\n}\n", "CodeBleu_score": 57.64450076563654}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Resolution mismatch: %u vs %u\", sequence->resolution, config->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels[0] > config->channels) {\n\t\tLOG_ERR(\"Invalid channel: %u\", sequence->channels[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels[1] > config->channels) {\n\t\tLOG_ERR(\"Invalid channel: %u\", sequence->channels[1]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels[2] > config->channels) {\n\t\tLOG_ERR(\"Invalid channel: %u\", sequence->channels[2]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels[3] > config->channels) {\n\t\tLOG_ERR(\"Invalid channel: %u\", sequence->channels[3]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < (sequence->channels_used * sizeof(uint16_t))) {\n\t\tLOG_ERR(\"Buffer too small: %u vs %u\", sequence->buffer_size, (sequence->channels_used * sizeof(uint16_t)));\n\t\treturn -EINVAL;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_init(&data->ctx, dev);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = adc_context_wait_for_completion(&data->ctx, K_FOREVER);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 56.99236563105978}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = ctx->data;\n\tstruct adc_data_buffer *buffer = data->buffer;\n\tstruct adc_data_buffer *repeat_buffer = data->repeat_buffer;\n\tstruct adc_channel_config *channel_config = data->channel_config;\n\tstruct adc_channel_config *channel_config_repeat = data->repeat_channel_config;\n\tuint8_t i;\n\tuint8_t channel_count = data->channel_count;\n\tuint8_t channel_count_repeat = data->repeat_channel_count;\n\tuint8_t channel_count_max = data->channel_count_max;\n\tuint8_t channel_count_repeat_max = data->repeat_channel_count_max;\n\tuint8_t channel_count_max_repeat = data->channel_count_max_repeat;\n\tuint8_t channel_count_max_repeat_repeat = data->channel_count_max_repeat_repeat;\n\tuint8_t channel_count_max_repeat_repeat_repeat = data->channel_count_max_repeat_repeat_repeat;\n\tuint8_t channel_count_max_repeat_repeat_repeat_repeat = data->channel_count_max_repeat_repeat_repeat_repeat;\n\tuint8_t channel_count_max_repeat_repeat_repeat_repeat_repeat = data->channel_count_max_repeat_repeat_repeat_repeat_repeat;\n\tuint8_t channel_count_max_repeat_repeat_repeat_repeat_repeat_repeat = data->channel_count_max_repeat_repeat_repeat_repeat_repeat_repeat;\n\tuint8_t channel_count_max_repeat_repeat_repeat_repeat_repeat_repeat_repeat = data->channel_count_max_repeat_repeat_repeat_repeat_repeat_repeat_repeat;\n\tuint8_t channel_count_max_repeat_repeat_repeat_repeat_repeat_repeat_repeat_repeat = data->channel_count_max_repeat_repeat_repeat_repeat_repeat_repeat_repeat_repeat;\n\tuint8_t channel_count_max_repeat_repeat_repeat_repeat_repeat_repeat_repeat_repeat_repeat = data->", "CodeBleu_score": 29.511213229458335}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\t// retrieve the ADC data structure from the context\n\tstruct adc_data *data = (struct adc_data *)ctx->data;\n\n\t// set the channels to be sampled\n\tdata->channels = ctx->channels;\n\n\t// initialize the repeat buffer with the data buffer\n\tdata->repeat_buffer = data->data_buffer;\n\n\t// release the semaphore to signal the start of sampling\n\txSemaphoreGive(data->semaphore);\n}\n", "CodeBleu_score": 51.15001126859614}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = ctx->data;\n\tint i;\n\n\t// Set channels to be sampled\n\tfor (i = 0; i < ADC_NUM_CHANNELS; i++) {\n\t\tif (ctx->channels & (1 << i)) {\n\t\t\tADC->CHER |= ADC_CHER_CH0EN;\n\t\t} else {\n\t\t\tADC->CHER &= ~(ADC_CHER_CH0EN);\n\t\t}\n\t}\n\n\t// Initialize repeat buffer\n\tfor (i = 0; i < ADC_REPEAT_BUFFER_SIZE; i++) {\n\t\tdata->repeat_buffer[i] = data->data_buffer[i];\n\t}\n\n\t// Release semaphore\n\txSemaphoreGive(data->start_sampling_sem);\n}\n", "CodeBleu_score": 34.839329999093515}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->buffer;\n\t}\n}\n", "CodeBleu_score": 49.88243588448712}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->data_container = ctx->repeat_data_container;\n\t} else {\n\t\tctx->data_container = ctx->data_container_1;\n\t}\n\tctx->data_container->buffer_pointer = ctx->data_container->buffer;\n}\n", "CodeBleu_score": 48.79310923046178}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->buffer;\n\t}\n}\n", "CodeBleu_score": 49.88243588448712}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tint ret;\n\tint i;\n\tint j;\n\tint channel_count;\n\tint channel_index;\n\tint channel_id;\n\tint channel_value;\n\tint channel_value_scaled;\n\tint channel_value_scaled_offset;\n\tint channel_value_scaled_offset_min;\n\tint channel_value_scaled_offset_max;\n\tint channel_value_scaled_offset_range;\n\tint channel_value_scaled_offset_range_min;\n\tint channel_value_scaled_offset_range_max;\n\tint channel_value_scaled_offset_range_mid;\n\tint channel_value_scaled_offset_range_mid_min;\n\tint channel_value_scaled_offset_range_mid_max;\n\tint channel_value_scaled_offset_range_mid_diff;\n\tint channel_value_scaled_offset_range_mid_diff_min;\n\tint channel_value_scaled_offset_range_mid_diff_max;\n\tint channel_value_scaled_offset_range_mid_diff_mid;\n\tint channel_value_scaled_offset_range_mid_diff_mid_min;\n\tint channel_value_scaled_offset_range_mid_diff_mid_max;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff_min;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff_max;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff_mid;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff_mid_min;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff_mid_max;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff_mid_diff;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff_mid_diff_min;\n\tint channel_value_scaled_offset_range_mid_diff_mid_diff_mid_diff", "CodeBleu_score": 5.314365687469003}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tint err;\n\tint i;\n\tint channel;\n\tint channel_count;\n\tint channel_buffer_size;\n\tint channel_buffer_index;\n\tint channel_buffer_count;\n\tint channel_buffer_read_count;\n\tint channel_buffer_read_size;\n\tint channel_buffer_read_offset;\n\tint channel_buffer_read_size_max;\n\tint channel_buffer_read_offset_max;\n\tint channel_buffer_read_size_total;\n\tint channel_buffer_read_offset_total;\n\tint channel_buffer_read_size_max_total;\n\tint channel_buffer_read_offset_max_total;\n\tint channel_buffer_read_size_total_max;\n\tint channel_buffer_read_offset_total_max;\n\tint channel_buffer_read_size_total_max_total;\n\tint channel_buffer_read_offset_total_max_total;\n\tint channel_buffer_read_size_total_max_total_max;\n\tint channel_buffer_read_offset_total_max_total_max;\n\tint channel_buffer_read_size_total_max_total_max_max;\n\tint channel_buffer_read_offset_total_max_total_max_max;\n\tint channel_buffer_read_size_total_max_total_max_max_max;\n\tint channel_buffer_read_offset_total_max_total_max_max_max;\n\tint channel_buffer_read_size_total_max_total_max_max_max_max;\n\tint channel_buffer_read_offset_total_max_total_max_max_max_max;\n\tint channel_buffer_read_size_total_max_total_max_max_max_max_max;\n\tint channel_buffer_read_offset_total_max_total_max_max_max_max_max;\n\tint channel_buffer_read_size_total_max_total_max_max_max_max_max_max;\n\tint channel_buffer_read_offset_total_max_total_max_max_max_max_max", "CodeBleu_score": 5.633681661669525}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\twhile (1) {\n\t\tk_sem_take(&data->acquisition_sem, K_FOREVER);\n\t\tfor (int i = 0; i < data->active_channels_count; i++) {\n\t\t\tint channel = data->active_channels[i];\n\t\t\tint value = adc_read_channel(data->adc_dev, channel);\n\t\t\tif (value < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel);\n\t\t\t\tdata->status = ADC_STATUS_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->buffer[i] = value;\n\t\t}\n\t\tif (data->status!= ADC_STATUS_ERROR) {\n\t\t\tdata->status = ADC_STATUS_DONE;\n\t\t}\n\t\tk_sem_give(&data->sampling_sem);\n\t}\n}\n", "CodeBleu_score": 32.45589730519736}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev)\tconst struct ads1112_config *config = dev->config;\n\tuint8_t status;\n\tint ret;\n\n\tk_sleep(K_MSEC(config->ready_time_ms));\n\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &status);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\twhile ((status & ADS1112_STATUS_RDY) == 0) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &status);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 72.03472085186266}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)\tint err;\n\tint i;\n\tuint16_t config_reg;\n\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_config *config = &data->config;\n\n\tfor (i = 0; i < config->ready_time; i++) {\n\t\tk_sleep(K_MSEC(100));\n\t\terr = ads1112_read_register(dev, ADS1112_CONFIG_REG, &config_reg);\n\t\tif (err!= 0) {\n\t\t\treturn err;\n\t\t}\n\t\tif (config_reg & ADS1112_CONFIG_RDY) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EIO;\n}\n", "CodeBleu_score": 48.445683112415196}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)\tint err;\n\tuint8_t config;\n\tint sleep_time = 100;\n\tint max_retries = 5;\n\tint retries = 0;\n\n\twhile (retries < max_retries) {\n\t\tk_sleep(K_MSEC(sleep_time));\n\t\terr = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t\tif ((config & ADS1112_CONFIG_DRDY) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tretries++;\n\t}\n\n\treturn -EIO;\n}\n", "CodeBleu_score": 36.798856758638884}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\t// Check if the buffer size is sufficient for the number of samplings in the sequence\n\tif (sequence->options & ADC_SEQ_BUF_VALID) {\n\t\t// Calculate the required buffer size based on the number of samplings\n\t\tint required_buffer_size = sequence->length + (sequence->options & ADC_SEQ_EXTRA_SAMPLINGS);\n\t\t// Check if the buffer size is sufficient\n\t\tif (required_buffer_size > sequence->buffer_length) {\n\t\t\t// Log an error message\n\t\t\tprintf(\"Error: Buffer size is not sufficient for the number of samplings in the sequence.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t// Return 0 if the buffer size is sufficient\n\treturn 0;\n}\n", "CodeBleu_score": 27.788373237050944}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tif (sequence->options.extra_samplings > sequence->length) {\n\t\treturn -EINVAL;\n\t}\n\n\tuint32_t buffer_size = sequence->length + sequence->options.extra_samplings;\n\tif (buffer_size > ADS1112_BUFFER_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 38.41976410025733}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tint buffer_size = sequence->options & ADC_SEQUENCE_OPTIONS_BUFFER_SIZE_MASK;\n\tint required_buffer_size = sequence->length + sequence->extra_samplings;\n\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"The buffer size is less than the required size for the ADC sequence. Required size: %d, Buffer size: %d\", required_buffer_size, buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 36.972205984198894}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_config *config = dev->config;\n\tint ret;\n\n\tif (sequence->channels == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_ASYNC) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < sequence->num_channels) {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_SCAN_BURST) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_NO_DMA) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_SINGLE_SHOT) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_CALC_OFFSET) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_CALC_GAIN) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_USE_DIFF) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_FIXED_RANGE) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_USE_LATEST_RANGE) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_CONTINUOUS) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_LOW_POWER) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INPUT_OFFSET) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INPUT_GAIN) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INPUT_CALIB) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_", "CodeBleu_score": 41.5111988311988}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->channels == NULL || sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_SINGLE_SHOT) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_CONTINUOUS) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_LOW_POWER) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_CALIBRATE) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_DIFF) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_SCAN) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_ASYNC) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_CHANNEL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_END) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_START) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_TRIGGER) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_CONTINUOUS) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_EDGE) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_SINGLE) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_SYNC) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_FLAGS_INJECT_TRIGGER_EDGE) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options &", "CodeBleu_score": 36.26357190261067}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tint ret = 0;\n\n\tif (sequence == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_ASYNC) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size!= sizeof(uint16_t)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels_used > 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_SCAN_MODE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_UPDATE_COMPARE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_Differential) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution!= 12) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling!= 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels[0] > 3) {\n\t\treturn -EINVAL;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = ads1112_adc_read(data);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = k_sem_take(&data->sem, K_FOREVER);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 46.91038883937564}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint32_t ret = 0;\n\tconst struct device *dev = NULL;\n\tstruct device_audio_codec_cfg *cfg = NULL;\n\tstruct device_audio_codec_prop *prop = NULL;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tcfg = dev->config->config_info;\n\tif (!cfg) {\n\t\tshell_error(sh, \"Device does not support audio codec\");\n\t\treturn -EINVAL;\n\t}\n\n\tprop = &cfg->prop;\n\tif (!prop) {\n\t\tshell_error(sh, \"Device does not support audio codec\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Missing audio codec property\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (strcmp(argv[2], \"format\") == 0) {\n\t\tif (argc < 4) {\n\t\t\tshell_error(sh, \"Missing audio codec format\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (strcmp(argv[3], \"pcm\") == 0) {\n\t\t\tprop->format = DEVICE_AUDIO_CODEC_FORMAT_PCM;\n\t\t} else if (strcmp(argv[3], \"alaw\") == 0) {\n\t\t\tprop->format = DEVICE_AUDIO_CODEC_FORMAT_ALAW;\n\t\t} else if (strcmp(argv[3], \"ulaw\") == 0) {\n\t\t\tprop->format = DEVICE_AUDIO_CODEC_FORMAT_ULAW;\n\t\t} else {\n\t\t\tshell_error(sh, \"Invalid audio codec format\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (strcmp(argv[2], \"sample_rate\") == 0) {\n\t\tif (argc < 4) {\n\t\t\tshell_error(sh, \"Missing audio codec sample rate\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (strcmp(argv[3], \"8000\") == 0) {\n\t\t\t", "CodeBleu_score": 50.06725467699358}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tif (argc < 2) {\n\t\treturn -EINVAL;\n\t}\n\tint err = 0;\n\tconst struct device *dev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\tstruct audio_codec_dev *adev = dev->driver_data;\n\tif (!adev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\tstruct audio_codec_prop prop;\n\tif (argc == 2) {\n\t\terr = audio_codec_get_prop(adev, &prop);\n\t} else {\n\t\terr = parse_prop(sh, argc, argv, &prop);\n\t}\n\tif (err) {\n\t\tshell_error(sh, \"Failed to parse property\");\n\t\treturn err;\n\t}\n\terr = audio_codec_set_prop(adev, &prop);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to set property\");\n\t\treturn err;\n\t}\n\tshell_print(sh, \"Property applied\");\n\treturn 0;\n}\n", "CodeBleu_score": 55.72027317028587}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tstruct device *dev = NULL;\n\tstruct device_binding *binding = NULL;\n\tstruct audio_codec_dev *codec_dev = NULL;\n\tstruct audio_codec_dev_cfg *cfg = NULL;\n\tint ret = 0;\n\n\tif (argc!= 2) {\n\t\tshell_error(sh, \"Wrong number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tbinding = device_get_binding(AUDIO_CODEC_DEV_NAME);\n\tif (binding == NULL) {\n\t\tshell_error(sh, \"Device binding failed\");\n\t\treturn -EINVAL;\n\t}\n\n\tcodec_dev = (struct audio_codec_dev *)dev;\n\tcfg = &codec_dev->cfg;\n\n\tif (strcmp(argv[0], \"apply_prop\") == 0) {\n\t\tret = binding->apply_prop(dev, cfg);\n\t\tif (ret == 0) {\n\t\t\tshell_print(sh, \"Successfully applied properties\");\n\t\t} else {\n\t\t\tshell_error(sh, \"Failed to apply properties\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 48.126287372365454}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUP;\n\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2S trigger failed (ret = %d)\", ret);\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 38.268071929138124}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\t\tcase DMIC_TRIGGER_START:\n\t\t\tif (data->state == DMIC_STATE_INACTIVE) {\n\t\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t\t\tif (ret) {\n\t\t\t\t\tLOG_ERR(\"Failed to start I2S\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMIC_TRIGGER_STOP:\n\t\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t\t\tif (ret) {\n\t\t\t\t\tLOG_ERR(\"Failed to stop I2S\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"Invalid trigger command\");\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 44.83847394892759}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret = 0;\n\n\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret == 0) {\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 30.230538513126383}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tuint8_t command = 0;\n\tuint8_t flags = 0;\n\tuint8_t blink_flags = 0;\n\tuint8_t display_mode_flags = 0;\n\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\n\tcommand = AUXDISPLAY_HD44780_DISPLAY_MODE_SET;\n\n\tif (data->cursor_blink_enabled) {\n\t\tblink_flags |= AUXDISPLAY_HD44780_CURSOR_BLINK_ENABLED;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tblink_flags |= AUXDISPLAY_HD44780_CURSOR_ENABLED;\n\t}\n\n\tif (data->cursor_position_blink_enabled) {\n\t\tblink_flags |= AUXDISPLAY_HD44780_CURSOR_POSITION_BLINK_ENABLED;\n\t}\n\n\tif (data->display_blink_enabled) {\n\t\tdisplay_mode_flags |= AUXDISPLAY_HD44780_DISPLAY_BLINK_ENABLED;\n\t}\n\n\tif (data->display_cursor_shift_enabled) {\n\t\tdisplay_mode_flags |= AUXDISPLAY_HD44780_DISPLAY_CURSOR_SHIFT_ENABLED;\n\t}\n\n\tif (data->display_cursor_shift_direction_right) {\n\t\tdisplay_mode_flags |= AUXDISPLAY_HD44780_DISPLAY_CURSOR_SHIFT_DIRECTION_RIGHT;\n\t}\n\n\tif (data->display_cursor_shift_direction_left) {\n\t\tdisplay_mode_flags |= AUXDISPLAY_HD44780_DISPLAY_CURSOR_SHIFT_DIRECTION_LEFT;\n\t}\n\n\tif (data->display_enabled) {\n\t\tflags |= AUXDISPLAY_HD44780_DISPLAY_ENABLED;\n\t}\n\n\tif (data->display_shift_enabled) {\n\t\tflags |= AUXDISPLAY_HD44780_DISPLAY_SHIFT_ENABLED;\n\t}\n\n\tif (data->display_shift_direction_right) {\n\t\tflags |= AUXDISPLAY_HD44780_DISPLAY_SHIFT_DIRECTION_RIGHT;\n\t}\n\n\tif (data->", "CodeBleu_score": 53.72536573406275}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tuint8_t command = 0;\n\n\tif (enabled) {\n\t\tcommand |= HD44780_DISPLAY_ON;\n\t}\n\n\tif (auxdisplay_hd44780_config->cursor_blink_enabled) {\n\t\tcommand |= HD44780_CURSOR_BLINK;\n\t}\n\n\tif (auxdisplay_hd44780_config->cursor_visible) {\n\t\tcommand |= HD44780_CURSOR_ON;\n\t}\n\n\tauxdisplay_hd44780_send_command(dev, HD44780_DISPLAY_MODE_SET | command);\n}\n", "CodeBleu_score": 46.32928895045198}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct auxdisplay_hd44780_data *data = dev->data;\n\n\tuint8_t command = AUXDISPLAY_HD44780_DISPLAY_MODE;\n\n\tif (data->cursor_blink) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t}\n\n\tif (data->cursor_visible) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_VISIBLE;\n\t}\n\n\tif (enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ENABLED;\n\t}\n\n\tauxdisplay_hd44780_send_command(dev, command);\n}\n", "CodeBleu_score": 54.267252113791876}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (config->busy_port == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_port, config->busy_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 64.15033240154952}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\n\tif (!config->busy_gpio.port) {\n\t\tLOG_ERR(\"busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (gpio_pin_get_raw(config->busy_gpio.port, config->busy_gpio.pin) == 0) {\n\t\tret = -EBUSY;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 59.9483449208305}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tconst struct gpio_dt_spec *gpio_busy = &config->gpio_busy;\n\tint ret;\n\n\tif (gpio_busy->port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(gpio_busy->port, gpio_busy->pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 63.79967610796765}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[AUXDISPLAY_SERLCD_BUFFER_SIZE];\n\tint ret;\n\n\t/* Construct the buffer */\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\t/* Send the buffer to the device */\n\tret = i2c_write(config->i2c_dev, config->i2c_addr, buffer, 2);\n\n\t/* Wait for the device to process the command */\n\tk_sleep(K_MSEC(config->delay_after_command));\n\n\treturn ret;\n}\n", "CodeBleu_score": 60.68665529746914}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tint ret = i2c_write(config->i2c, config->i2c_address, buffer, 2);\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn ret;\n}\n", "CodeBleu_score": 61.12663004198593}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\t/* Construct the buffer containing the special command prefix and the command itself */\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\t/* Write the buffer to the device using the I2C bus */\n\tret = i2c_write(config->i2c, config->i2c_addr, buffer, 2);\n\n\t/* Introduce a delay specified in the device configuration before returning the result of the I2C write operation */\n\tk_busy_wait(config->special_command_delay);\n\n\treturn ret;\n}\n", "CodeBleu_score": 59.52821047320832}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_data *bbram = dev->data;\n\n\tif (offset >= bbram->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram->size) {\n\t\tsize = bbram->size - offset;\n\t}\n\n\tmemcpy(data, bbram->data + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 56.57306825702618}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_emul = dev->data;\n\tint ret = 0;\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_emul->data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data_emul->data + offset, size);\n\n\treturn ret;\n}\n", "CodeBleu_score": 62.02408044725687}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tstruct bbram_emul_data *data_emul = dev->data;\n\n\tif (offset + size > data_emul->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data_emul->data + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 49.51559578611304}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_emul = dev->data;\n\tsize_t i;\n\n\tif (size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif ((offset + size) > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_emul->state!= BBRAM_EMUL_STATE_READY) {\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tdata_emul->data[offset + i] = data[i];\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 54.47111982627055}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tconst struct bbram_emul_data *bbram_emul_data = dev->data;\n\tuint8_t *mem = bbram_emul_data->mem;\n\n\tif (size > bbram_emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_data->state == BBRAM_EMUL_STATE_INVALID) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(mem + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 53.41501334958401}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tconst struct bbram_emul_data *bbram = dev->data;\n\n\tif (size > BBRAM_EMUL_MAX_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram->state == BBRAM_EMUL_STATE_INVALID) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(bbram->data + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 55.6380794770305}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tif (argc!= 2) {\n\t\tshell_error(sh, \"Invalid number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 73.92556009786897}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tint err;\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (IS_ENABLED(CONFIG_BBRAM_LOG_LEVEL)) {\n\t\tshell_print(sh, \"Using BBRAM device: %s\", argv[1]);\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}\n", "CodeBleu_score": 69.59698675861176}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tint rc = 0;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing BBRAM device name\");\n\t\trc = -EINVAL;\n\t} else {\n\t\t*bbram_dev = device_get_binding(argv[1]);\n\t\tif (!*bbram_dev) {\n\t\t\tshell_error(sh, \"BBRAM device not found\");\n\t\t\trc = -ENODEV;\n\t\t}\n\t}\n\n\treturn rc;\n}\n", "CodeBleu_score": 55.487015617178805}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev)\tstruct h4_uart_data *data = dev->data;\n\tuint16_t num_bytes_read;\n\n\tnum_bytes_read = data->rx_bytes_read;\n\tnum_bytes_read += uart_fifo_read(data->uart_dev, data->rx_buf + num_bytes_read, data->rx_buf_size - num_bytes_read);\n\tif (num_bytes_read < data->rx_buf_size) {\n\t\tLOG_ERR(\"Failed to read header from UART device\");\n\t} else {\n\t\tdata->rx_bytes_read = data->rx_buf_size;\n\t}\n}\n", "CodeBleu_score": 41.7428280369705}, {"code": "static void h4_read_hdr(const struct device *dev)\tstruct h4_data *data = dev->data;\n\tsize_t bytes_read = 0;\n\n\tif (data->hdr_bytes_read == 0) {\n\t\t/* read header */\n\t\tbytes_read = uart_fifo_read(data->uart_dev, data->hdr_buf, H4_HDR_LEN);\n\t\tif (bytes_read < H4_HDR_LEN) {\n\t\t\tLOG_ERR(\"Unable to read header\");\n\t\t\treturn;\n\t\t}\n\n\t\tdata->hdr_bytes_read = H4_HDR_LEN;\n\t}\n\n\t/* read remaining bytes */\n\tbytes_read = uart_fifo_read(data->uart_dev, data->hdr_buf + data->hdr_bytes_read, H4_HDR_LEN - data->hdr_bytes_read);\n\tif (bytes_read < H4_HDR_LEN - data->hdr_bytes_read) {\n\t\tLOG_ERR(\"Unable to read header\");\n\t\treturn;\n\t}\n\n\tdata->hdr_bytes_read = H4_HDR_LEN;\n}\n", "CodeBleu_score": 42.74684253147695}, {"code": "static void h4_read_hdr(const struct device *dev)\tstruct h4_uart_data *uart_data = dev->data;\n\tint ret;\n\tuint8_t *buf = uart_data->rx_buf;\n\tsize_t rx_len = uart_data->rx_len;\n\tsize_t rx_bytes_read = uart_data->rx_bytes_read;\n\tsize_t rx_bytes_remaining = uart_data->rx_bytes_remaining;\n\n\tif (rx_bytes_remaining == 0) {\n\t\treturn;\n\t}\n\n\tret = uart_fifo_read(uart_data->uart_dev, buf + rx_len, rx_bytes_remaining, &rx_bytes_read);\n\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"Failed to read UART FIFO: %d\", ret);\n\t\treturn;\n\t}\n\n\trx_len += rx_bytes_read;\n\trx_bytes_remaining -= rx_bytes_read;\n\tuart_data->rx_len = rx_len;\n\tuart_data->rx_bytes_remaining = rx_bytes_remaining;\n}\n", "CodeBleu_score": 42.52796813466426}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t num_read = 0;\n\tsize_t num_bytes_to_read = MIN(len, 33);\n\n\twhile (num_bytes_to_read > 0) {\n\t\tsize_t num_bytes_read = uart_fifo_read(uart, buf, num_bytes_to_read);\n\n\t\tif (num_bytes_read == 0) {\n\t\t\tLOG_ERR(\"UART read failed\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tnum_read += num_bytes_read;\n\t\tnum_bytes_to_read -= num_bytes_read;\n\t}\n\n\treturn num_read;\n}\n", "CodeBleu_score": 30.089146976763832}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tsize_t bytes_read = 0;\n\tuint8_t temp_buffer[33];\n\n\twhile (bytes_read < len) {\n\t\tsize_t bytes_remaining = len - bytes_read;\n\t\tsize_t bytes_to_read = MIN(bytes_remaining, 32);\n\t\tint err = uart_fifo_read(uart, temp_buffer, bytes_to_read);\n\t\tif (err < 0) {\n\t\t\tLOG_ERR(\"Failed to read %d bytes from UART FIFO\", bytes_to_read);\n\t\t\treturn 0;\n\t\t}\n\t\tbytes_read += err;\n\t}\n\n\treturn bytes_read;\n}\n", "CodeBleu_score": 35.24724571452309}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buffer[33];\n\tsize_t bytes_read = 0;\n\tsize_t bytes_to_read = MIN(len, sizeof(buffer));\n\n\twhile (bytes_to_read > 0) {\n\t\tbytes_read = uart_read(uart, buffer, bytes_to_read);\n\t\tif (bytes_read < 0) {\n\t\t\tLOG_ERR(\"Error reading from UART: %d\", bytes_read);\n\t\t\treturn 0;\n\t\t}\n\t\tbytes_to_read -= bytes_read;\n\t}\n\treturn len;\n}\n", "CodeBleu_score": 36.86133708306724}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tuint8_t i;\n\tuint8_t new_hop = chan->hop;\n\tstruct zbus_observer *obs;\n\tfor (i = 0; i < chan->observers_count; i++) {\n\t\tobs = chan->observers[i];\n\t\tif (obs->priority < new_hop && obs->enabled) {\n\t\t\tnew_hop = obs->priority;\n\t\t}\n\t}\n\tchan->hop = new_hop;\n}\n", "CodeBleu_score": 20.135988119184116}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tstruct zbus_channel_data *data = chan->data;\n\tuint8_t highest_priority = 0;\n\n\tzbus_channel_lock(chan);\n\tfor (uint8_t i = 0; i < ZBUS_MAX_OBSERVERS; i++) {\n\t\tif (data->observers[i].enabled && data->observers[i].priority < highest_priority) {\n\t\t\thighest_priority = data->observers[i].priority;\n\t\t}\n\t}\n\tzbus_channel_unlock(chan);\n\n\tzbus_channel_lock(chan);\n\tchan->highest_observer_priority = highest_priority;\n\tzbus_channel_unlock(chan);\n}\n", "CodeBleu_score": 26.74928013796432}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tuint8_t i;\n\tuint8_t highest_priority = 0;\n\tstruct zbus_observer *obs;\n\n\tzbus_chan_lock(chan);\n\n\tfor (i = 0; i < ZBUS_MAX_OBSERVERS; i++) {\n\t\tobs = &chan->observers[i];\n\t\tif (obs->enabled && obs->priority < highest_priority) {\n\t\t\thighest_priority = obs->priority;\n\t\t}\n\t}\n\n\tchan->highest_priority = highest_priority;\n\n\tzbus_chan_unlock(chan);\n}\n", "CodeBleu_score": 25.864461302200993}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tfor (uint32_t i = 0; i < zbus_channels_count; i++) {\n\t\tif (zbus_channels[i].observer == obs) {\n\t\t\tupdate_channel_hop(i);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 16.22222043568959}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tfor (uint8_t i = 0; i < ZBUS_CHANNEL_MAX; i++) {\n\t\tif (zbus_channels[i].obs == obs) {\n\t\t\tupdate_channel_hop(i);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 15.270411178001309}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tstruct zbus_channel_observer *ch_obs;\n\tstruct zbus_channel *ch;\n\tstruct zbus_observer *tmp_obs;\n\tstruct zbus_channel_observer *tmp_ch_obs;\n\tint i;\n\tint j;\n\n\tfor (i = 0; i < zbus_channels_count; i++) {\n\t\tch = &zbus_channels[i];\n\t\tfor (j = 0; j < ch->observers_count; j++) {\n\t\t\tch_obs = &ch->observers[j];\n\t\t\ttmp_obs = zbus_observer_get(ch_obs->observer_id);\n\t\t\tif (tmp_obs == obs) {\n\t\t\t\tupdate_channel_hop(ch, ch_obs);\n\t\t\t}\n\t\t\tzbus_observer_unref(tmp_obs);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 19.096810910028747}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tassert(obs!= NULL);\n\tassert(!zbus_is_in_isr());\n\tassert(!zbus_is_in_thread());\n\tif (zbus_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\tif (zbus_is_in_thread()) {\n\t\treturn -EPERM;\n\t}\n\tspin_lock(&zbus_observer_lock);\n\tobs->priority = zbus_thread_min_priority;\n\tzbus_obs_update_channels(obs);\n\tspin_unlock(&zbus_observer_lock);\n\treturn 0;\n}\n", "CodeBleu_score": 44.33661704119923}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\tif (in_interrupt()) {\n\t\treturn -1;\n\t}\n\tspin_lock(&zbus_lock);\n\tif (obs->priority > zbus_min_priority) {\n\t\tobs->priority = zbus_min_priority;\n\t}\n\tfor (int i = 0; i < zbus_channels_len; i++) {\n\t\tif (zbus_channels[i].obs == obs) {\n\t\t\tzbus_channels[i].obs = NULL;\n\t\t}\n\t}\n\tspin_unlock(&zbus_lock);\n\treturn 0;\n}\n", "CodeBleu_score": 41.17487247109984}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tif (in_isr()) {\n\t\treturn -1;\n\t}\n\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\n\tspinlock_acquire(&obs->lock);\n\tif (obs->priority!= ZBUS_OBS_PRIORITY_NONE) {\n\t\treturn -1;\n\t}\n\tobs->priority = zbus_get_thread_priority();\n\tfor (int i = 0; i < ZBUS_MAX_CHANNELS; i++) {\n\t\tif (obs->channels[i]!= NULL) {\n\t\t\tzbus_channel_update_priority(obs->channels[i]);\n\t\t}\n\t}\n\tspinlock_release(&obs->lock);\n\treturn 0;\n}\n", "CodeBleu_score": 41.004191634319284}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint err;\n\tstruct zbus_chan_context *context;\n\tk_timeout_t timeout_adj;\n\tk_timeout_t end_time;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Adjust the timeout if in an ISR */\n\tif (k_is_in_isr()) {\n\t\ttimeout_adj = k_uptime_get() + timeout;\n\t} else {\n\t\ttimeout_adj = timeout;\n\t}\n\n\t/* Initialize the context priority */\n\tcontext = (struct zbus_chan_context *)chan->context;\n\tcontext->priority = 0;\n\n\t/* Calculate the end time */\n\tend_time = k_uptime_get() + timeout_adj;\n\n\t/* Lock the channel */\n\terr = zbus_chan_lock(chan, end_time);\n\tif (err!= 0) {\n\t\treturn err;\n\t}\n\n\t/* Execute the notification logic */\n\terr = zbus_chan_notify_exec(chan, end_time);\n\n\t/* Unlock the channel */\n\tzbus_chan_unlock(chan);\n\n\treturn err;\n}\n", "CodeBleu_score": 51.04926503793876}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint err;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = k_timeout_adjust(timeout, k_cycle_get_32());\n\t}\n\n\tk_mutex_lock(&chan->lock, timeout);\n\terr = zbus_chan_notify_locked(chan);\n\tk_mutex_unlock(&chan->lock);\n\n\treturn err;\n}\n", "CodeBleu_score": 29.518698534206134}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tk_timeout_t end_time = timeout;\n\tif (k_is_in_isr()) {\n\t\tend_time = k_timeout_adjust(timeout, k_cycle_get_32());\n\t}\n\tint result = 0;\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\tif (chan->priority > ZBUS_PRIORITY_LOW) {\n\t\tchan->priority = ZBUS_PRIORITY_LOW;\n\t}\n\tif (chan->priority == ZBUS_PRIORITY_LOW) {\n\t\tresult = zbus_chan_notify_low(chan, end_time);\n\t} else {\n\t\tresult = zbus_chan_notify_high(chan, end_time);\n\t}\n\tk_spin_unlock(&chan->lock, key);\n\treturn result;\n}\n", "CodeBleu_score": 40.99537430292214}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tif (enable) {\n\t\tETH->ETH_IER |= Int;\n\t} else {\n\t\tETH->ETH_IDR &= ~Int;\n\t}\n}\n", "CodeBleu_score": 28.477241121711582}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\t/* Check the parameters */\n\tassert_param(IS_FUNCTIONAL_STATE(enable));\n\tassert_param(IS_ETH_IT(Int));\n\tif (enable) {\n\t\t/* Enable the interrupt */\n\t\tETH->ETH_IER |= Int;\n\t\tif (Int == ETH_IT_R) {\n\t\t\tETH->ETH_IER |= ETH_IER_RIE;\n\t\t} else if (Int == ETH_IT_T) {\n\t\t\tETH->ETH_IER |= ETH_IER_TIE;\n\t\t} else if (Int == ETH_IT_A) {\n\t\t\tETH->ETH_IER |= ETH_IER_AIE;\n\t\t} else if (Int == ETH_IT_E) {\n\t\t\tETH->ETH_IER |= ETH_IER_EIE;\n\t\t} else if (Int == ETH_IT_W) {\n\t\t\tETH->ETH_IER |= ETH_IER_WIE;\n\t\t}\n\t} else {\n\t\t/* Disable the interrupt */\n\t\tETH->ETH_IDR &= ~Int;\n\t\tif (Int == ETH_IT_R) {\n\t\t\tETH->ETH_IDR |= ETH_IDR_RIE;\n\t\t} else if (Int == ETH_IT_T) {\n\t\t\tETH->ETH_IDR |= ETH_IDR_TIE;\n\t\t} else if (Int == ETH_IT_A) {\n\t\t\tETH->ETH_IDR |= ETH_IDR_AIE;\n\t\t} else if (Int == ETH_IT_E) {\n\t\t\tETH->ETH_IDR |= ETH_IDR_EIE;\n\t\t} else if (Int == ETH_IT_W) {\n\t\t\tETH->ETH_IDR |= ETH_IDR_WIE;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.12825891419398}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tif (enable) {\n\t\tETH->MAC_ITR = Int;\n\t} else {\n\t\tETH->MAC_ITR = Int;\n\t}\n}\n", "CodeBleu_score": 27.7859848170987}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\t// Get the current transmit descriptor address\n\tETH_TX_DESC *txDesc = (ETH_TX_DESC *)ETH_DMA_TXDESC_BASE;\n\n\t// Check if the descriptor is owned by the device\n\tif ((txDesc->Status & ETH_TX_DESC_OWN) == 0) {\n\t\t// Return the descriptor\n\t\treturn txDesc;\n\t}\n\n\t// Loop through the list of descriptors\n\twhile (txDesc < (ETH_TX_DESC *)ETH_DMA_TXDESC_BASE + ETH_DMA_TX_DESC_NUM) {\n\t\t// Check if the descriptor is owned by the device\n\t\tif ((txDesc->Status & ETH_TX_DESC_OWN) == 0) {\n\t\t\t// Return the descriptor\n\t\t\treturn txDesc;\n\t\t}\n\n\t\t// Go to the next descriptor\n\t\ttxDesc++;\n\t}\n\n\t// Return 0 if no free descriptor is found\n\treturn 0;\n}\n", "CodeBleu_score": 47.306026049250185}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *desc;\n\tuint32_t reg;\n\n\t/* Get the current descriptor address */\n\treg = ETH->DMATPDR;\n\n\t/* Check if the descriptor is owned by the device */\n\tif ((reg & ETH_DMATPDR_OWN) == ETH_DMATPDR_OWN) {\n\t\t/* No free descriptor found */\n\t\treturn 0;\n\t}\n\n\t/* Get the descriptor */\n\tdesc = (ETH_TX_DESC *) (ETH_BASE + (reg & ETH_DMATPDR_TPSR));\n\n\t/* Return the descriptor */\n\treturn desc;\n}\n", "CodeBleu_score": 41.24045933003378}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *tx_desc;\n\tuint32_t reg_val;\n\tuint32_t reg_val_2;\n\tuint32_t reg_val_3;\n\n\ttx_desc = &ETH->TxDesc[0];\n\n\t// Check if the current descriptor is owned by the device\n\treg_val = ETH->DMATxDesc[0].Status;\n\tif (reg_val & ETH_DMATXDESC_OWN) {\n\t\t// If the current descriptor is owned by the device, start at the beginning of the list\n\t\ttx_desc = &ETH->TxDesc[0];\n\t}\n\n\t// Loop through the list of descriptors until a free descriptor is found\n\twhile (tx_desc->Status & ETH_DMATXDESC_OWN) {\n\t\ttx_desc++;\n\t\tif (tx_desc == &ETH->TxDesc[ETH_TX_DESC_CNT]) {\n\t\t\ttx_desc = &ETH->TxDesc[0];\n\t\t}\n\t}\n\n\t// Check if the current descriptor is owned by the device\n\treg_val_2 = ETH->DMATxDesc[0].Status;\n\tif (reg_val_2 & ETH_DMATXDESC_OWN) {\n\t\t// If the current descriptor is owned by the device, start at the beginning of the list\n\t\ttx_desc = &ETH->TxDesc[0];\n\t}\n\n\t// Loop through the list of descriptors until a free descriptor is found\n\twhile (tx_desc->Status & ETH_DMATXDESC_OWN) {\n\t\ttx_desc++;\n\t\tif (tx_desc == &ETH->TxDesc[ETH_TX_DESC_CNT]) {\n\t\t\ttx_desc = &ETH->TxDesc[0];\n\t\t}\n\t}\n\n\t// Check if the current descriptor is owned by the device\n\treg_val_3 = ETH->DMATxDesc[0].Status;\n\tif (reg_val_3 & ETH_DMATXDESC_OWN) {\n\t\t// If the current descriptor is owned by the device, start at the beginning of the list\n\t\ttx_desc = &ETH->TxDesc[0];\n\t}\n\n\t// Loop through the list of descriptors until a free descriptor is found\n\twhile (", "CodeBleu_score": 33.26003199930142}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\trt_err_t result = RT_EOK;\n\tstruct cyp_adc_device *cyp_adc = (struct cyp_adc_device *)device;\n\tstruct cyp_adc_config *config = &cyp_adc->config;\n\tstruct cyp_adc_channel *channel_config = &config->channels[channel];\n\tstruct cyp_adc_instance *instance = &cyp_adc->instance;\n\tstruct cyp_adc_channel_instance *channel_instance = &instance->channels[channel];\n\n\tif (device == RT_NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: device is null\\n\");\n\t\tresult = -RT_ERROR;\n\t} else {\n\t\tif (channel >= config->channels_count) {\n\t\t\trt_kprintf(\"cyp_adc_convert: channel %d is out of range\\n\", channel);\n\t\t\tresult = -RT_ERROR;\n\t\t} else {\n\t\t\tif (channel_config->enabled == false) {\n\t\t\t\trt_kprintf(\"cyp_adc_convert: channel %d is not enabled\\n\", channel);\n\t\t\t\tresult = -RT_ERROR;\n\t\t\t} else {\n\t\t\t\tif (channel_instance->enabled == false) {\n\t\t\t\t\tresult = cy_csd_init(channel_config->csd_base, &channel_config->csd_config);\n\t\t\t\t\tif (result == RT_EOK) {\n\t\t\t\t\t\tresult = cy_csd_channel_init(channel_config->csd_base, channel_config->csd_channel, &channel_config->csd_channel_config);\n\t\t\t\t\t\tif (result == RT_EOK) {\n\t\t\t\t\t\t\tresult = cy_csd_channel_enable(channel_config->csd_base, channel_config->csd_channel);\n\t\t\t\t\t\t\tif (result == RT_EOK) {\n\t\t\t\t\t\t\t\tchannel_instance->enabled = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (result == RT_EOK) {\n\t\t\t\t\tresult = cy_csd_channel_convert(channel_config->csd_base, channel_config->csd_channel, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 40.0041361540471}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\trt_err_t result = RT_EOK;\n\tstruct cyp_adc_device *cyp_adc = (struct cyp_adc_device *) device;\n\tstruct cyp_adc_channel *cyp_adc_channel = (struct cyp_adc_channel *) cyp_adc->channels[channel];\n\tstruct cyp_adc_config *cyp_adc_config = (struct cyp_adc_config *) cyp_adc->config;\n\tstruct cyp_adc_instance *cyp_adc_instance = (struct cyp_adc_instance *) cyp_adc->config->instance;\n\tstruct cyp_adc_channel_config *cyp_adc_channel_config = (struct cyp_adc_channel_config *) cyp_adc_channel->config;\n\tstruct cyp_adc_channel_instance *cyp_adc_channel_instance = (struct cyp_adc_channel_instance *) cyp_adc_channel->config->instance;\n\n\tif (device == RT_NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: device is null\\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\tif (cyp_adc_instance == RT_NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: cyp_adc_instance is null\\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\tif (cyp_adc_channel_instance == RT_NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: cyp_adc_channel_instance is null\\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\tif (cyp_adc_channel_config == RT_NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: cyp_adc_channel_config is null\\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\tif (cyp_adc_config == RT_NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: cyp_adc_config is null\\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\tif (cyp_adc_config->state!= CYP_ADC_STATE_READY) {\n\t\trt_kprintf(\"cyp_", "CodeBleu_score": 36.91611700911981}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\tstruct cyp_adc_device *adc = (struct cyp_adc_device *)device->parent.user_data;\n\trt_err_t result = RT_EOK;\n\tif (adc == RT_NULL) {\n\t\tresult = -RT_ERROR;\n\t\trt_kprintf(\"adc is null\\n\");\n\t\treturn result;\n\t}\n\tif (channel >= adc->csd_channels) {\n\t\tresult = -RT_ERROR;\n\t\trt_kprintf(\"channel is invalid\\n\");\n\t\treturn result;\n\t}\n\tresult = Cy_CSD_InitChannel(&adc->csd, channel);\n\tif (result!= CY_CSD_SUCCESS) {\n\t\trt_kprintf(\"Cy_CSD_InitChannel failed\\n\");\n\t\treturn result;\n\t}\n\tresult = Cy_CSD_EnableChannel(&adc->csd, channel);\n\tif (result!= CY_CSD_SUCCESS) {\n\t\trt_kprintf(\"Cy_CSD_EnableChannel failed\\n\");\n\t\treturn result;\n\t}\n\tresult = Cy_CSD_SetScanResolution(&adc->csd, CY_CSD_RESOLUTION_12);\n\tif (result!= CY_CSD_SUCCESS) {\n\t\trt_kprintf(\"Cy_CSD_SetScanResolution failed\\n\");\n\t\treturn result;\n\t}\n\tresult = Cy_CSD_SetScanResolution(&adc->csd, CY_CSD_RESOLUTION_12);\n\tif (result!= CY_CSD_SUCCESS) {\n\t\trt_kprintf(\"Cy_CSD_SetScanResolution failed\\n\");\n\t\treturn result;\n\t}\n\tresult = Cy_CSD_SetScanResolution(&adc->csd, CY_CSD_RESOLUTION_12);\n\tif (result!= CY_CSD_SUCCESS) {\n\t\trt_kprintf(\"Cy_CSD_SetScanResolution failed\\n\");\n\t\treturn result;\n\t}\n\tresult = Cy_CSD_SetScanResolution(&adc->csd, CY_CSD_RESOLUTION_12);\n\tif (result!= CY_CSD_SUCCESS) {\n\t\trt_kprintf(\"Cy_CSD_SetScanResolution failed\\n\");\n\t\t", "CodeBleu_score": 38.197161705447165}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\tif (addr + size > 0x200000) {\n\t\trt_kprintf(\"ERROR: ifx_flash_read_32k: invalid argument\\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\trt_uint32_t i;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *((volatile rt_uint8_t *) (addr + i));\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 42.11760734343679}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\tint ret = 0;\n\tif (addr + size > FLASH_SIZE_32K) {\n\t\trt_kprintf(\"Error: read address exceeds flash memory size\\n\");\n\t\tret = -RT_EINVAL;\n\t} else {\n\t\trt_uint32_t i = 0;\n\t\trt_uint32_t *p = (rt_uint32_t *) buf;\n\t\tfor (i = 0; i < size; i += 4) {\n\t\t\t*p = *(rt_uint32_t *) (FLASH_BASE_ADDR_32K + addr + i);\n\t\t\tp++;\n\t\t}\n\t\tret = size;\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 38.13172873609528}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\tif (addr + size > 0x200000) {\n\t\trt_kprintf(\"Read operation would exceed flash memory's end address\\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (int i = 0; i < size; i++) {\n\t\tbuf[i] = *((volatile rt_uint8_t *) (addr + i));\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 38.60406171489332}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\tif (timer == RT_NULL) {\n\t\treturn 0;\n\t}\n\tcyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(cyhal_timer);\n}\n", "CodeBleu_score": 52.091474614054654}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\trt_uint32_t count = 0;\n\tcyhal_timer_t *cy_timer = (cyhal_timer_t *)timer->parent.user_data;\n\n\tif (cy_timer == NULL) {\n\t\treturn 0;\n\t}\n\n\tcount = cyhal_timer_read(cy_timer);\n\treturn count;\n}\n", "CodeBleu_score": 56.67867943185064}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\trt_uint32_t count;\n\tcyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n\tcyhal_timer_read(hal_timer, &count);\n\treturn count;\n}\n", "CodeBleu_score": 50.52048951597374}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void)\twhile (xSemaphoreTake(mutex, portMAX_DELAY)!= pdTRUE) {\n\t\tassert_failed(__FILE__, __LINE__);\n\t}\n}\n", "CodeBleu_score": 6.7071113598014955}, {"code": "void dfs_lock(void)\twhile (1) {\n\t\tif (mutex_trylock(&dfs_mutex) == 0) {\n\t\t\treturn;\n\t\t}\n\t\tassert(0);\n\t}\n}\n", "CodeBleu_score": 8.688982986997889}, {"code": "void dfs_lock(void)\twhile (xSemaphoreTake(mutex, portMAX_DELAY)!= pdTRUE);\n}\n", "CodeBleu_score": 2.7976293582836558}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint i;\n\n\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\tif (fdt->fds[i].flags == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (fdt->maxfd >= FD_TABLE_SIZE) {\n\t\treturn -1;\n\t}\n\n\tfdt->maxfd++;\n\tfdt->fds = realloc(fdt->fds, fdt->maxfd * sizeof(struct dfs_fd));\n\tmemset(fdt->fds + (fdt->maxfd - 1), 0, sizeof(struct dfs_fd));\n\n\treturn fdt->maxfd - 1;\n}\n", "CodeBleu_score": 34.95554481885934}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint i;\n\tfor (i = startfd; i < fdt->fd_max; i++) {\n\t\tif (fdt->fd_table[i] == NULL) {\n\t\t\tfdt->fd_table[i] = malloc(sizeof(struct dfs_fd));\n\t\t\tif (fdt->fd_table[i] == NULL) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdt->fd_table[i]->fd_inode = NULL;\n\t\t\tfdt->fd_table[i]->fd_mode = 0;\n\t\t\tfdt->fd_table[i]->fd_offset = 0;\n\t\t\tfdt->fd_table[i]->fd_refcount = 0;\n\t\t\tfdt->fd_table[i]->fd_inode = NULL;\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n", "CodeBleu_score": 32.64473178617024}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint i;\n\n\t/* Search for an empty slot starting from the specified index. */\n\tfor (i = startfd; i < fdt->max_fd; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\t/* Found an empty slot. */\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t/* Expand the fd table. */\n\tif (fd_table_expand(fdt) == -1) {\n\t\t/* Failed to expand the fd table. */\n\t\treturn -1;\n\t}\n\n\t/* Search for an empty slot starting from the beginning. */\n\tfor (i = 0; i < fdt->max_fd; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\t/* Found an empty slot. */\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t/* Should never reach here. */\n\treturn -1;\n}\n", "CodeBleu_score": 36.11669737424061}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error)\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < NUM_ERRORS; i++) {\n\t\tif (error == errors[i].code) {\n\t\t\treturn errors[i].msg;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}\n", "CodeBleu_score": 45.454564080397695}, {"code": "const char *rt_strerror(rt_err_t error)\tif (error < 0)\n\t\terror = -error;\n\tfor (int i = 0; i < sizeof(rt_err_strings) / sizeof(rt_err_strings[0]); i++) {\n\t\tif (rt_err_strings[i].code == error)\n\t\t\treturn rt_err_strings[i].string;\n\t}\n\treturn \"EUNKNOW\";\n}\n", "CodeBleu_score": 58.96917171083772}, {"code": "const char *rt_strerror(rt_err_t error)\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < NUM_ERRORS; i++) {\n\t\tif (error == errors[i].code) {\n\t\t\treturn errors[i].str;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}\n", "CodeBleu_score": 45.81973950427168}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\t/*\n\t * Lock the idle hook list to ensure thread safety.\n\t */\n\tlevel = rt_hw_interrupt_disable();\n\t/*\n\t * Iterate through the idle hook list to find an empty slot.\n\t */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_NMAX; i++) {\n\t\t/*\n\t\t * If an empty slot is found, assign the hook to that slot and return a success code (RT_EOK).\n\t\t */\n\t\tif (rt_thread_idle_hook_list[i] == RT_NULL) {\n\t\t\trt_thread_idle_hook_list[i] = hook;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If no empty slot is available, return an error code (-RT_EFULL).\n\t\t */\n\t\tif (i == RT_THREAD_IDLE_HOOK_NMAX - 1) {\n\t\t\tresult = -RT_EFULL;\n\t\t}\n\t}\n\t/*\n\t * Release the spinlock and return the result.\n\t */\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}\n", "CodeBleu_score": 49.935203480338316}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_base_t level;\n\trt_err_t result;\n\n\tRT_ASSERT(hook!= RT_NULL);\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_thread_idle_hook_list_num < RT_THREAD_IDLE_HOOK_LIST_SIZE) {\n\t\trt_thread_idle_hook_list[rt_thread_idle_hook_list_num++] = hook;\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 24.867777071630382}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_thread_t thread = rt_thread_self();\n\n\t/*\n\t * If the idle thread is not running, then the hook cannot be set.\n\t * This is because the idle thread is not running, and therefore it is not safe to call the hook.\n\t */\n\tif (thread->stat!= RT_THREAD_INIT) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/*\n\t * Lock the spinlock to ensure thread safety.\n\t * This prevents other threads from modifying the idle hook list at the same time.\n\t */\n\trt_enter_critical(&level, RT_IPC_LOCK_SPIN);\n\n\t/*\n\t * Iterate through the idle hook list to find an empty slot.\n\t * If an empty slot is found, assign the hook to that slot and return a success code.\n\t */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_SIZE; i++) {\n\t\tif (rt_thread_idle_hook_list[i] == RT_NULL) {\n\t\t\trt_thread_idle_hook_list[i] = hook;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If no empty slot is available, return an error code.\n\t */\n\tif (i == RT_THREAD_IDLE_HOOK_SIZE) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/*\n\t * Release the spinlock and return the result.\n\t */\n\trt_exit_critical(&level, RT_IPC_LOCK_SPIN);\n\treturn result;\n}\n", "CodeBleu_score": 51.6830773962592}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_list_t *node;\n\trt_list_t *prev;\n\trt_list_t *next;\n\trt_list_t *list;\n\n\tRT_ASSERT(hook!= RT_NULL);\n\n\tlevel = rt_hw_interrupt_disable();\n\tlist = rt_thread_idle_get_hook_list();\n\tprev = list;\n\tnode = rt_list_next(prev);\n\twhile (node!= list) {\n\t\tnext = rt_list_next(node);\n\t\tif (node->next == hook) {\n\t\t\tprev->next = next;\n\t\t\tnode->next = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t\tprev = node;\n\t\tnode = next;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 37.87013636569006}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\t/* lock the spinlock to ensure thread safety */\n\tlevel = rt_hw_interrupt_disable();\n\t/* iterate through the idle hook list to find the specified hook */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_SIZE; i++) {\n\t\t/* if the hook is found, set the corresponding entry to null and return a success code */\n\t\tif (rt_thread_idle_hook[i] == hook) {\n\t\t\trt_thread_idle_hook[i] = NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* if the hook is not found, return an error code indicating that the operation is not supported */\n\tif (result!= RT_EOK) {\n\t\tresult = -RT_ERROR;\n\t}\n\t/* unlock the spinlock and return the result */\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}\n", "CodeBleu_score": 46.612099002706096}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\tRT_ASSERT(hook!= RT_NULL);\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* find the hook in the idle hook list */\n\tfor (rt_uint8_t i = 0; i < RT_THREAD_IDLE_HOOK_SIZE; i++) {\n\t\tif (rt_thread_idle_hook_list[i] == hook) {\n\t\t\trt_thread_idle_hook_list[i] = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 40.15279010939484}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\trt_thread_t *thread;\n\trt_base_t level;\n\trt_list_t *node;\n\n\t/* Check if the scheduler is locked. */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* Check if the suspension list is empty. */\n\tif (rt_list_isempty(susp_list)) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn RT_EOK;\n\t}\n\n\t/* Dequeue and wake up each thread from the suspension list. */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tnode = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\t\tthread = rt_list_entry(node, struct rt_thread, tlist);\n\t\trt_thread_wakeup(thread);\n\t\trt_list_remove(node);\n\t}\n\n\trt_hw_interrupt_enable(level);\n\treturn thread_error;\n}\n", "CodeBleu_score": 33.926516722881075}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\trt_base_t level;\n\trt_thread_t *thread;\n\n\t/* Ensure the scheduler is unlocked. */\n\trt_enter_critical(&level, RT_IPC_LOCK);\n\n\t/* Dequeue and wake up each thread from the list one by one until the list is empty. */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\t\trt_list_remove(&thread->tlist);\n\t\trt_thread_wakeup(thread);\n\t}\n\n\t/* Return the thread error code. */\n\treturn thread_error;\n}\n", "CodeBleu_score": 30.25180213459694}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\trt_thread_t *thread;\n\trt_uint8_t level;\n\n\tif (susp_list == RT_NULL)\n\t\treturn RT_EINVAL;\n\n\t/* Ensure the scheduler is unlocked */\n\trt_enter_critical(&level);\n\n\t/* Dequeue and wake up each suspended thread from the list one by one until the list is empty */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\t\trt_list_remove(&thread->tlist);\n\t\tthread->error = thread_error;\n\t\trt_thread_ready(thread);\n\t}\n\n\trt_exit_critical(&level);\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 34.23131472953074}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\tif (new_console!= RT_NULL && new_console!= old_console) {\n\t\tif (old_console!= RT_NULL) {\n\t\t\trt_device_close(old_console);\n\t\t}\n\t\trt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAMING);\n\t\trt_console_set_device(new_console);\n\t}\n\treturn old_console;\n}\n", "CodeBleu_score": 40.934758102108646}, {"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t old_console_device = RT_CONSOLE_DEVICE;\n\trt_device_t new_console_device = rt_device_find(name);\n\tif (new_console_device!= RT_NULL && new_console_device!= old_console_device) {\n\t\tif (old_console_device!= RT_NULL) {\n\t\t\trt_device_close(old_console_device);\n\t\t}\n\t\trt_device_open(new_console_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\trt_console_device = new_console_device;\n\t}\n\treturn old_console_device;\n}\n", "CodeBleu_score": 51.24530118976261}, {"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t old_device = RT_NULL;\n\trt_device_t new_device = RT_NULL;\n\trt_err_t result = RT_EOK;\n\n\tif (name == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* save the current console device */\n\told_device = rt_console_get_device();\n\n\t/* find the new console device */\n\tnew_device = rt_device_find(name);\n\tif (new_device == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\t/* check if the new console device is the same as the current device */\n\tif (old_device!= new_device) {\n\t\t/* close the current console device */\n\t\tif (old_device!= RT_NULL) {\n\t\t\tresult = rt_device_close(old_device);\n\t\t\tif (result!= RT_EOK) {\n\t\t\t\treturn old_device;\n\t\t\t}\n\t\t}\n\n\t\t/* open the new console device */\n\t\tresult = rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\tif (result!= RT_EOK) {\n\t\t\treturn old_device;\n\t\t}\n\t}\n\n\t/* set the new console device */\n\trt_console_set_device(new_device);\n\n\treturn old_device;\n}\n", "CodeBleu_score": 55.9522358177692}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type)\tint count = 0;\n\tstruct rt_object *obj;\n\tstruct rt_object_class *class = rt_object_class_get(type);\n\tif (class == NULL) {\n\t\treturn -1;\n\t}\n\trt_spinlock_lock(&class->lock);\n\tlist_for_each_entry(obj, &class->list, list) {\n\t\tcount++;\n\t}\n\trt_spinlock_unlock(&class->lock);\n\treturn count;\n}\n", "CodeBleu_score": 28.8541933378608}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tint length = 0;\n\trt_spinlock_lock(&object_list_lock);\n\tstruct rt_object *object = object_list;\n\twhile (object!= NULL) {\n\t\tif (object->class_type == type) {\n\t\t\tlength++;\n\t\t}\n\t\tobject = object->next;\n\t}\n\trt_spinlock_unlock(&object_list_lock);\n\treturn length;\n}\n", "CodeBleu_score": 28.857054628521063}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tint length = 0;\n\tstruct rt_object_class *class;\n\tstruct rt_object_instance *instance;\n\n\tclass = rt_object_class_get(type);\n\tif (class == NULL) {\n\t\treturn -1;\n\t}\n\n\trt_spinlock_lock(&class->lock);\n\tinstance = class->head;\n\twhile (instance!= NULL) {\n\t\tlength++;\n\t\tinstance = instance->next;\n\t}\n\trt_spinlock_unlock(&class->lock);\n\n\treturn length;\n}\n", "CodeBleu_score": 31.895818345000116}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object)\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* detach hook */\n\tif (object->type & RT_Object_Class) {\n\t\trt_class_detach(object);\n\t} else {\n\t\trt_object_detach(object);\n\t}\n\n\t/* remove from list */\n\trt_list_remove(&object->list);\n\n\t/* unlock */\n\trt_spinlock_release(&object->lock);\n\n\t/* set type to zero */\n\tobject->type = 0;\n}\n", "CodeBleu_score": 40.04516234398414}, {"code": "void rt_object_detach(rt_object_t object)\tRT_ASSERT(object!= RT_NULL);\n\n\t/* call the hook function */\n\tif (object->type & RT_Object_Class_Type) {\n\t\trt_object_class_detach(object);\n\t} else {\n\t\trt_object_detach_hook(object);\n\t}\n\n\t/* detach from the object list */\n\trt_object_list_remove(object);\n\n\t/* unlock the spinlock */\n\trt_spinlock_release(&(object->parent.spinlock));\n\n\t/* set the object type to zero */\n\tobject->type = 0;\n}\n", "CodeBleu_score": 36.718207243800585}, {"code": "void rt_object_detach(rt_object_t object)\trt_object_info_t *object_info;\n\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\tif (object->type == RT_Object_Class) {\n\t\trt_object_class_detach(object);\n\t} else if (object->type == RT_Object_Thread) {\n\t\trt_object_thread_detach(object);\n\t} else if (object->type == RT_Object_Semaphore) {\n\t\trt_object_semaphore_detach(object);\n\t} else if (object->type == RT_Object_Mutex) {\n\t\trt_object_mutex_detach(object);\n\t} else if (object->type == RT_Object_Event) {\n\t\trt_object_event_detach(object);\n\t} else if (object->type == RT_Object_MailBox) {\n\t\trt_object_mailbox_detach(object);\n\t} else if (object->type == RT_Object_MessageQueue) {\n\t\trt_object_messagequeue_detach(object);\n\t} else if (object->type == RT_Object_MemoryPool) {\n\t\trt_object_memorypool_detach(object);\n\t} else if (object->type == RT_Object_Timer) {\n\t\trt_object_timer_detach(object);\n\t} else if (object->type == RT_Object_Device) {\n\t\trt_object_device_detach(object);\n\t} else if (object->type == RT_Object_Semaphore) {\n\t\trt_object_semaphore_detach(object);\n\t} else if (object->type == RT_Object_Mutex) {\n\t\trt_object_mutex_detach(object);\n\t} else if (object->type == RT_Object_Semaphore) {\n\t\trt_object_semaphore_detach(object);\n\t} else if (object->type == RT_Object_Semaphore) {\n\t\trt_object_semaphore_detach(object);\n\t} else if (object->type == RT_Object_Semaphore) {\n\t\trt_object_semaphore_detach(object);\n\t} else if (object->type == RT_Object_Semaphore) {\n\t\trt_object_semaphore_detach(object);\n\t} else if (object->type == RT_Object_", "CodeBleu_score": 33.16952229669647}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_custom_object_t custom_obj = (rt_custom_object_t) obj;\n\trt_err_t ret = RT_ERR_NONE;\n\n\tif (custom_obj == NULL) {\n\t\treturn RT_ERR_INVALID_OBJECT;\n\t}\n\n\tif (custom_obj->class->type!= RT_OBJECT_TYPE_CUSTOM) {\n\t\treturn RT_ERR_INVALID_OBJECT;\n\t}\n\n\tif (custom_obj->class->destroy!= NULL) {\n\t\tret = custom_obj->class->destroy(custom_obj);\n\t}\n\n\trt_object_destroy(custom_obj);\n\n\treturn ret;\n}\n", "CodeBleu_score": 43.989124455837626}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_custom_object_t *custom_obj = (rt_custom_object_t *) obj;\n\trt_err_t ret = RT_EOK;\n\n\tif (custom_obj == NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (custom_obj->class_type!= RT_CUSTOM_OBJECT_CLASS_TYPE) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (custom_obj->destroy!= NULL) {\n\t\tret = custom_obj->destroy(obj);\n\t}\n\n\trt_free(obj);\n\n\treturn ret;\n}\n", "CodeBleu_score": 47.01661328857041}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_custom_object_t custom_obj = (rt_custom_object_t) obj;\n\trt_err_t err = RT_OK;\n\n\tif (custom_obj == NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (custom_obj->class == NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (custom_obj->class->destroy!= NULL) {\n\t\terr = custom_obj->class->destroy(custom_obj);\n\t}\n\n\trt_free(custom_obj);\n\n\treturn err;\n}\n", "CodeBleu_score": 42.54318293877759}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void)\t_thread_t* current = _thread_get_current();\n\t_thread_critical_enter();\n\tcurrent->status = _THREAD_STATUS_DEFUNCT;\n\t_thread_list_remove(current);\n\t_thread_list_add(_thread_defunct_list, current);\n\t_thread_critical_exit();\n\t_scheduler();\n}\n", "CodeBleu_score": 50.72850644637025}, {"code": "static void _thread_exit(void)\t/* Retrieve the current thread */\n\tstruct thread *curr_thread = _thread_current();\n\n\t/* Enter a critical section */\n\t_thread_lock();\n\n\t/* Close the current thread */\n\t_thread_close(curr_thread);\n\n\t/* Add the current thread to the defunct thread list */\n\t_thread_add_to_defunct(curr_thread);\n\n\t/* Exit the critical section */\n\t_thread_unlock();\n\n\t/* Trigger a context switch to the next task */\n\t_scheduler();\n}\n", "CodeBleu_score": 51.40233056347239}, {"code": "static void _thread_exit(void)\tthread_t* thread = _thread_get_current();\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\t_thread_critical_enter();\n\tthread->state = THREAD_STATE_DEFUNCT;\n\t_thread_defunct_add(thread);\n\t_thread_critical_exit();\n\n\t_thread_scheduler();\n}\n", "CodeBleu_score": 51.54128127656511}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter)\tif (parameter == NULL) {\n\t\treturn;\n\t}\n\tthread_t *thread = (thread_t *)parameter;\n\t_thread_lock();\n\tif (thread->state!= THREAD_SUSPENDED) {\n\t\t_thread_unlock();\n\t\treturn;\n\t}\n\tthread->error = ETIMEDOUT;\n\t_thread_remove(thread);\n\t_thread_insert(thread, THREAD_READY);\n\t_thread_unlock();\n\t_thread_reschedule();\n}\n", "CodeBleu_score": 34.72150149486759}, {"code": "static void _thread_timeout(void *parameter)\tthread_t *thread = parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\tif (thread->status!= THREAD_SUSPENDED) {\n\t\treturn;\n\t}\n\tlock_scheduler();\n\tthread->error = ERR_TIMEOUT;\n\t_thread_remove_from_suspend_list(thread);\n\t_thread_insert_into_ready_list(thread);\n\tunlock_scheduler();\n\treschedule();\n}\n", "CodeBleu_score": 32.45470278927339}, {"code": "static void _thread_timeout(void *parameter)\tthread *t = (thread *)parameter;\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->status!= SUSPENDED) {\n\t\treturn;\n\t}\n\tt->error_num = E_TIMEOUT;\n\t_scheduler_lock();\n\t_remove_thread_from_suspend_list(t);\n\t_insert_thread_into_ready_list(t);\n\t_scheduler_unlock();\n}\n", "CodeBleu_score": 30.269082824461474}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\tif (thread->mutex_wait_list_head!= NULL) {\n\t\t_mutex_remove_from_wait_list(thread);\n\t}\n\twhile (thread->mutex_list_head!= NULL) {\n\t\t_mutex_remove_from_list(thread);\n\t}\n\trt_spin_unlock(&thread->spinlock);\n}\n", "CodeBleu_score": 20.41538949132468}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_spinlock_lock(&thread->spinlock);\n\n\tif (thread->mutex_pending) {\n\t\trt_mutex_t mutex = thread->mutex_pending->mutex;\n\t\trt_list_t *node = rt_list_remove(&mutex->waiting_list, thread->mutex_pending);\n\t\trt_assert(node!= RT_NULL);\n\t\trt_free(node);\n\t\tthread->mutex_pending = RT_NULL;\n\t}\n\n\trt_list_t *node = thread->mutex_list.next;\n\twhile (node!= &thread->mutex_list) {\n\t\trt_mutex_t mutex = RT_LIST_ENTRY(node, rt_mutex_t, thread_list);\n\t\trt_list_remove(node, &thread->mutex_list);\n\t\trt_list_init(node);\n\t\tnode = thread->mutex_list.next;\n\t\trt_mutex_release(mutex);\n\t}\n\n\trt_spinlock_unlock(&thread->spinlock);\n}\n", "CodeBleu_score": 41.1139629749804}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_spinlock_lock(&_thread_spinlock);\n\tif (thread->waiting_on_mutex!= NULL) {\n\t\t_mutex_remove_thread_from_waiting_list(thread->waiting_on_mutex, thread);\n\t\tthread->waiting_on_mutex = NULL;\n\t\tthread->pending_object = NULL;\n\t}\n\t_mutex_remove_thread_from_taken_list(thread);\n\trt_spinlock_unlock(&_thread_spinlock);\n}\n", "CodeBleu_score": 23.956453745913887}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\t/*\n\t * 1. \u68c0\u67e5\u7ebf\u7a0b\u662f\u5426\u4e3a\u7a7a\n\t */\n\tif (thread == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/*\n\t * 2. \u68c0\u67e5\u7ebf\u7a0b\u662f\u5426\u5904\u4e8e\u521d\u59cb\u5316\u72b6\u6001\n\t */\n\tif (thread->stat!= RT_THREAD_INIT) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/*\n\t * 3. \u68c0\u67e5\u7ebf\u7a0b\u662f\u5426\u4e3a\u7ebf\u7a0b\u7c7b\u578b\n\t */\n\tif (thread->type!= RT_Thread) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/*\n\t * 4. \u6253\u5370\u7ebf\u7a0b\u7684\u540d\u5b57\u548c\u4f18\u5148\u7ea7\n\t */\n\trt_kprintf(\"thread startup: %s, priority: %d\\n\", thread->name, thread->current_priority);\n\n\t/*\n\t * 5. \u8ba1\u7b97\u7ebf\u7a0b\u7684\u4f18\u5148\u7ea7\u5c5e\u6027\n\t */\n\trt_thread_calculate_priority_attr(thread);\n\n\t/*\n\t * 6. \u5c06\u7ebf\u7a0b\u7684\u72b6\u6001\u8bbe\u7f6e\u4e3a\u6302\u8d77\n\t */\n\trt_thread_suspend(thread);\n\n\t/*\n\t * 7. \u5524\u9192\u7ebf\u7a0b\n\t */\n\trt_thread_resume(thread);\n\n\t/*\n\t * 8. \u5982\u679c\u6709\u7a7a\u95f2\u7ebf\u7a0b\uff0c\u5219\u89e6\u53d1\u8c03\u5ea6\u5668\n\t */\n\tif (rt_thread_ready_priority_table[RT_THREAD_PRIORITY_MAX - 1]!= RT_NULL) {\n\t\trt_schedule();\n\t}\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 46.76731244882942}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\trt_err_t result = RT_EOK;\n\n\t/* check the thread is not null */\n\tif (thread == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check the thread is in the initialization state */\n\tif (thread->stat!= RT_THREAD_INIT) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check the thread is of the correct type */\n\tif (thread->type!= RT_Thread) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* log the thread's name and priority */\n\trt_kprintf(\"thread start up: %s, priority: %d\\n\", thread->name, thread->current_priority);\n\n\t/* calculate the priority attributes */\n\trt_thread_prio_to_tick(thread);\n\n\t/* reset the thread state to suspended */\n\trt_thread_suspend(thread);\n\n\t/* resume the thread */\n\trt_thread_resume(thread);\n\n\t/* trigger a scheduler if available */\n\tif (rt_schedule_get_mode()!= RT_SCHEDULE_NONE) {\n\t\trt_schedule();\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 44.27595182154879}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\trt_err_t result = RT_EOK;\n\n\tif (thread!= RT_NULL) {\n\t\tif (thread->stat == RT_THREAD_INIT) {\n\t\t\trt_kprintf(\"thread: %s, prio: %d\\n\", thread->name, thread->current_priority);\n\t\t\trt_thread_priority_calc(thread);\n\t\t\tthread->stat = RT_THREAD_SUSPEND;\n\t\t\trt_thread_resume(thread);\n\t\t} else {\n\t\t\tresult = -RT_ERROR;\n\t\t}\n\t} else {\n\t\tresult = -RT_ERROR;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 42.44511945998026}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\trt_err_t result;\n\trt_list_t *list;\n\trt_timer_t *timer;\n\trt_tick_t timeout;\n\n\tresult = RT_EOK;\n\tlist = &timer_list[0];\n\ttimeout = 0;\n\n\t/* If the highest level of the timer skip list is not empty, get the first timer entry */\n\tif (!rt_list_isempty(list)) {\n\t\ttimer = (rt_timer_t *) rt_list_entry(list->next, rt_timer_t, timer_node);\n\n\t\t/* If the timer is not in the timer list, return an error code */\n\t\tif (!rt_list_isempty(&timer->timer_node)) {\n\t\t\tresult = -RT_ERROR;\n\t\t} else {\n\t\t\t/* Set the timeout tick to the timer's timeout value */\n\t\t\ttimeout = timer->timeout;\n\t\t}\n\t} else {\n\t\tresult = -RT_ERROR;\n\t}\n\n\t*timeout_tick = timeout;\n\treturn result;\n}\n", "CodeBleu_score": 42.98020893698792}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\trt_tick_t timeout_tick_tmp;\n\trt_list_t *timer_list_tmp;\n\trt_timer_t *timer_tmp;\n\n\t/* Check if the highest level of the timer skip list is not empty */\n\tif (rt_list_isempty(timer_list)) {\n\t\treturn -RT_EBUSY;\n\t}\n\n\t/* Get the first timer entry */\n\ttimer_list_tmp = rt_list_first(timer_list);\n\ttimer_tmp = rt_list_entry(timer_list_tmp, rt_timer_t, timer_list);\n\n\t/* Set the provided timeout tick to the timer's timeout value */\n\ttimeout_tick_tmp = timer_tmp->timeout_tick;\n\t*timeout_tick = timeout_tick_tmp;\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 40.76284677961366}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\trt_list_t *timer_list_head;\n\trt_timer_t *timer;\n\n\ttimer_list_head = (rt_list_t *)timer_list;\n\n\tif (rt_list_isempty(timer_list_head)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\ttimer = (rt_timer_t *)rt_list_entry(timer_list_head->next, rt_timer_t, list);\n\t*timeout_tick = timer->timeout;\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 34.81716228313467}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\trt_timer_t timer;\n\trt_uint8_t i;\n\n\t/* Check the timeout function. */\n\tif (timeout == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Check the time. */\n\tif (time > RT_TICK_MAX || time < 1) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Allocate memory for the timer object. */\n\ttimer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Initialize the timer object. */\n\ttimer->flag = flag;\n\ttimer->init_tick = rt_tick_get();\n\ttimer->time = time;\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->parent.type = RT_Object_Class_Timer;\n\ttimer->parent.flag = RT_Object_Flag_Active;\n\ttimer->parent.name = name;\n\n\t/* Initialize the timer list. */\n\trt_list_init(&timer->list);\n\n\t/* Add the timer to the timer list. */\n\tfor (i = 0; i < RT_TIMER_NUMBER; i++) {\n\t\tif (rt_timer_list[i] == RT_NULL) {\n\t\t\trt_timer_list[i] = timer;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == RT_TIMER_NUMBER) {\n\t\trt_kprintf(\"too many timers\\n\");\n\t\trt_free(timer);\n\t\treturn RT_NULL;\n\t}\n\n\treturn timer;\n}\n", "CodeBleu_score": 51.16457426180976}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\trt_timer_t timer;\n\n\t/* Check if the timeout function is valid */\n\tif (timeout == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Check if the specified time is within a valid range */\n\tif (time < RT_TIMER_TIME_MIN || time > RT_TIMER_TIME_MAX) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Allocate memory for the timer object */\n\ttimer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Initialize the timer with the provided timeout function, parameter, time, and flag */\n\trt_list_init(&(timer->list));\n\ttimer->flag = flag;\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->init_tick = rt_tick_get();\n\ttimer->time = time;\n\n\treturn timer;\n}\n", "CodeBleu_score": 51.60682534073969}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\trt_timer_t timer;\n\trt_err_t result;\n\n\t/* Check the timeout function */\n\tif (timeout == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Check the time */\n\tif (time == 0) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Allocate memory for the timer object */\n\ttimer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* Initialize the timer */\n\ttimer->flag = flag;\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->init_tick = rt_tick_get();\n\ttimer->time = time;\n\ttimer->next = RT_NULL;\n\ttimer->prev = RT_NULL;\n\ttimer->start_tick = 0;\n\n\t/* Insert the timer into the timer list */\n\tresult = rt_hw_interrupt_disable();\n\tif (result == RT_EOK) {\n\t\trt_list_insert_after(&timer_list, &timer->list);\n\t\trt_hw_interrupt_enable();\n\t} else {\n\t\trt_free(timer);\n\t\ttimer = RT_NULL;\n\t}\n\n\treturn timer;\n}\n", "CodeBleu_score": 52.387752299629085}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Create a recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\t// Create a router to handle the request\n\trouter := a.Router(req)\n\t// Serve the request using the router\n\trouter.ServeHTTP(recorder, req)\n\t// Copy the recorder's headers to the original response\n\tfor key, value := range recorder.Header() {\n\t\tres.Header()[key] = value\n\t}\n\t// If the response status is 401, send a \"Not Authorized\" error response\n\tif recorder.Code == 401 {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\t// If the response status is not 401, forward the request to the router for further handling\n\tres.WriteHeader(recorder.Code)\n\t_, err := io.Copy(res, recorder.Body)\n\tif err!= nil {\n\t\tlog.Println(err)\n\t}\n}", "CodeBleu_score": 46.35137160513536}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\ta.Router.ServeHTTP(res, req)\n}", "CodeBleu_score": 4.172795662032863}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Set the default headers\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\t// Create a recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// Create a chain of handlers\n\thandler := httputil.NewSingleHostReverseProxy(a.router.Handler)\n\thandler.ServeHTTP(recorder, req)\n\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range recorder.Header() {\n\t\tres.Header()[k] = v\n\t}\n\n\t// If the response contains an error, send it and stop further processing\n\tif recorder.Code!= http.StatusOK {\n\t\tres.WriteHeader(recorder.Code)\n\t\tres.Write(recorder.Body.Bytes())\n\t\treturn\n\t}\n\n\t// If the response is a \"401 Unauthorized\" status, send a \"Not Authorized\" error response and stop further processing\n\tif recorder.Code == http.StatusUnauthorized {\n\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\tres.Write([]byte(`{\"error\": \"Not authorized\"}`))\n\t\treturn\n\t}\n\n\t// If all handlers pass without unauthorized status, forward the request to the router for further handling\n\thandler.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 57.18293530568883}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// The function \"robeaux\" serves static assets in response to HTTP requests.\n\t// It retrieves the requested asset based on the URL path and checks for errors.\n\t// If the asset is found, it sets the appropriate Content-Type header based on the file extension (js, css, html).\n\t// It then writes the asset content to the response.\n\t// If an error occurs while retrieving the asset, it returns a 404 error.\n\n\t// Retrieve the requested asset from the file system.\n\t// The URL path is used to determine the file path.\n\tpath := req.URL.Path\n\tpath = strings.TrimPrefix(path, \"/\")\n\n\t// Check if the asset exists in the file system.\n\t// If the asset does not exist, return a 404 error.\n\tfile, err := os.Open(path)\n\tif err!= nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Get the file extension of the requested asset.\n\t// This is used to determine the Content-Type header.\n\text := filepath.Ext(path)\n\n\t// Set the Content-Type header based on the file extension.\n\t// If the extension is not recognized, set the Content-Type header to \"application/octet-stream\".\n\tcontentType := \"application/octet-stream\"\n\tswitch ext {\n\tcase \".js\":\n\t\tcontentType = \"application/javascript\"\n\tcase \".css\":\n\t\tcontentType = \"text/css\"\n\tcase \".html\":\n\t\tcontentType = \"text/html\"\n\t}\n\n\t// Set the Content-Type header on the response.\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Copy the asset content to the response.\n\t// If an error occurs, return a 500 error.\n\t_, err = io.Copy(res, file)\n\tif err!= nil {\n\t\thttp.Error(res, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 37.7901332622591}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// Get the requested path\n\tpath := req.URL.Path\n\t// Get the file extension\n\text := path[strings.LastIndex(path, \".\"):]\n\t// Check if the path is a directory\n\tif path[len(path)-1] == '/' {\n\t\t// If the path is a directory, redirect to the index.html\n\t\thttp.Redirect(res, req, path+\"index.html\", http.StatusFound)\n\t\treturn\n\t}\n\t// Check if the path is a static asset\n\tif!strings.HasPrefix(path, \"/static/\") {\n\t\t// If the path is not a static asset, return a 404 error\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Remove the \"/static/\" prefix from the path\n\tpath = path[8:]\n\t// Check if the path is a valid file\n\tif _, err := os.Stat(path); err!= nil {\n\t\t// If the path is not a valid file, return a 404 error\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Read the file content\n\tfile, err := ioutil.ReadFile(path)\n\tif err!= nil {\n\t\t// If an error occurs while reading the file, return a 500 error\n\t\thttp.Error(res, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\t// Set the Content-Type header based on the file extension\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\t// Write the file content to the response\n\tres.Write(file)\n}\n", "CodeBleu_score": 59.60105836425409}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// This function serves static assets in response to HTTP requests.\n\t// It retrieves the requested asset based on the URL path and checks for errors.\n\t// If the asset is found, it sets the appropriate Content-Type header based on the file extension (js, css, html).\n\t// It then writes the asset content to the response.\n\t// If an error occurs while retrieving the asset, it returns a 404 error.\n\n\t// Get the path from the request URL\n\tpath := req.URL.Path\n\n\t// Check if the path is empty\n\tif path == \"/\" {\n\t\t// If the path is empty, set the path to \"index.html\"\n\t\tpath = \"/index.html\"\n\t}\n\n\t// Check if the path is a directory\n\tif strings.HasSuffix(path, \"/\") {\n\t\t// If the path is a directory, set the path to \"index.html\"\n\t\tpath += \"index.html\"\n\t}\n\n\t// Check if the path is a file\n\tif strings.HasSuffix(path, \".js\") || strings.HasSuffix(path, \".css\") || strings.HasSuffix(path, \".html\") {\n\t\t// If the path is a file, check if the file exists\n\t\tif _, err := os.Stat(path); err == nil {\n\t\t\t// If the file exists, open the file and check for errors\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err!= nil {\n\t\t\t\t// If an error occurs while opening the file, return a 404 error\n\t\t\t\tres.WriteHeader(http.StatusNotFound)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Get the file extension\n\t\t\textension := strings.Split(path, \".\")[1]\n\n\t\t\t// Set the appropriate Content-Type header based on the file extension\n\t\t\tswitch extension {\n\t\t\tcase \"js\":\n\t\t\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t\t\tcase \"css\":\n\t\t\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t\t\tcase \"html\":\n\t\t\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\t}\n\n\t\t\t// Copy the file content to the response\n\t\t\tio.Copy(res, file)\n\n\t\t\t// Close the file\n\t\t\tfile.Close()\n\n\t\t\treturn\n\t\t}\n\t", "CodeBleu_score": 51.70403035556437}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Find the robot using the master instance\n\trobot, err := a.master.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the specified name\"})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.GetConnections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// If the connections cannot be converted to JSON, write a JSON error message\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"Internal server error\"})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(jsonConnections)\n}\n", "CodeBleu_score": 36.99158299535069}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract robot name from request URL\n\trobotName := req.URL.Path[len(\"/connections/\"):]\n\n\t// Find robot using master instance\n\trobot, err := a.master.FindRobot(robotName)\n\tif err!= nil {\n\t\t// Robot not found\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"Robot not found\"})\n\t\treturn\n\t}\n\n\t// Convert robot connections to JSON format\n\tconnectionsJSON, err := json.Marshal(robot.Connections)\n\tif err!= nil {\n\t\t// Error converting connections to JSON\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"Error converting connections to JSON\"})\n\t\treturn\n\t}\n\n\t// Write JSON response containing robot connections\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}\n", "CodeBleu_score": 35.53703312228203}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\t// Get the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\t// Find the robot using the master instance\n\trobot, err := a.master.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\tjson.NewEncoder(res).Encode(struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\n\t\t\tError: \"Robot not found\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Get the connections of the robot\n\tconnections := robot.GetConnections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// If there is an error converting the connections to JSON, write a JSON error message\n\t\tjson.NewEncoder(res).Encode(struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\n\t\t\tError: \"Error converting connections to JSON\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Write(jsonConnections)\n}\n", "CodeBleu_score": 36.465436752900295}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\tif len(pair)!= 2 ||!strings.EqualFold(pair[0], username) ||!strings.EqualFold(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t}\n}", "CodeBleu_score": 49.96825351029992}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// If the \"Authorization\" header is not present, return a \"Not Authorized\" response\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the \"Authorization\" header into username and password\n\t\tauthHeaderParts := strings.Split(authHeader, \" \")\n\t\tif len(authHeaderParts)!= 2 || strings.ToLower(authHeaderParts[0])!= \"basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the base64-encoded username and password from the \"Authorization\" header\n\t\tdecodedAuthHeader, err := base64.StdEncoding.DecodeString(authHeaderParts[1])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the username and password into separate strings\n\t\tusernamePassword := strings.Split(string(decodedAuthHeader), \":\")\n\t\tif len(usernamePassword)!= 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password against the provided username and password\n\t\tif usernamePassword[0]!= username || usernamePassword[1]!= password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the username and password match, call the next handler in the chain\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\tw.WriteHeader(http.StatusOK)\n\t", "CodeBleu_score": 45.95338031685211}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif!strings.Contains(r.Header.Get(\"Authorization\"), \"Basic\") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the Basic Authentication credentials\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Invalid Authorization header\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\tif len(pair)!= 2 ||!strings.EqualFold(pair[0], username) ||!strings.EqualFold(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Delegate request to the given handler\n\t\thandler(w, r)\n\t}\n}", "CodeBleu_score": 47.23711730886938}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 51.69589435049284}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMax - (slope * fromMax)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 49.475217220571544}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 51.69589435049284}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\tif!a.connection.SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tvalue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = value\n\ta.lastScaledValue = a.scale(value)\n\n\treturn value, a.lastScaledValue, nil\n}\n", "CodeBleu_score": 49.358245973318546}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\tif a.connection == nil {\n\t\treturn -1, -1.0, errors.New(\"No connection to read from\")\n\t}\n\tif!a.connection.supportsAnalogRead() {\n\t\treturn -1, -1.0, errors.New(\"Connection does not support analog reading\")\n\t}\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\traw, err := a.connection.analogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1.0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scaleValue(raw)\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 43.89473962462539}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the mutex to ensure thread safety.\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Verify that the connection supports analog reading.\n\tif!a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\t// Read the raw value from the specified pin.\n\trawValue, err := a.connection.ReadAnalogPin(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Update the last raw and scaled values.\n\ta.lastRaw = rawValue\n\ta.lastScaled = a.scale(rawValue)\n\n\treturn rawValue, a.lastScaled, nil\n}\n", "CodeBleu_score": 49.56299445352357}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*float64(fromMin)\n\treturn func(value int) float64 {\n\t\treturn slope*float64(value) + intercept\n\t}\n}\n", "CodeBleu_score": 43.83171841882957}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \treturn func(value int) float64 {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\t\treturn toMin + slope*(float64(value)-float64(fromMin))\n\t}\n}\n", "CodeBleu_score": 30.08620164415905}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMax - slope*fromMax\n\n\treturn func(value int) float64 {\n\t\treturn slope*float64(value) + intercept\n\t}\n}\n", "CodeBleu_score": 40.54939221819605}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriverd := NewAnalogSensorDriver(a, pin, opts...)\n\td.Name = \"Grove Piezo Vibration Sensor\"\n\td.AddEvent(VibrationEvent)\n\tif err := d.AddEventListener(\n\t\tVibrationEvent,\n\t\tfunc(e Event) {\n\t\t\tif e.Data.(int) > 1000 {\n\t\t\t\td.PublishEvent(VibrationEvent, e.Data)\n\t\t\t}\n\t\t},\n\t); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 33.82189217432913}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriverd := NewAnalogSensorDriver(a, pin, opts...)\n\td.Name = \"GrovePiezoVibrationSensor\"\n\td.Events = append(d.Events, NewVibrationEvent())\n\tthreshold := 1000\n\tif len(opts) > 0 {\n\t\tswitch v := opts[0].(type) {\n\t\tcase int:\n\t\t\tthreshold = v\n\t\t}\n\t}\n\td.AddEventListener(func(e Event) {\n\t\tif e.Data.(int) > threshold {\n\t\t\td.Events[0].Publish(e.Data)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 28.67003514702544}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriverd := NewAnalogSensorDriver(a, pin, opts...)\n\td.Name = \"GrovePiezoVibrationSensorDriver\"\n\td.AddEvent(VibrationEvent)\n\tvibrationEvent := d.GetEvent(VibrationEvent)\n\tvibrationEvent.SetThreshold(1000)\n\tvibrationEvent.AddEventListener(func(e events.Event) {\n\t\td.Publish(VibrationEvent, e)\n\t})\n\treturn d\n}\n", "CodeBleu_score": 24.205310815533355}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := 1000000.0 / (hz * 2)\n\ttempo := 60000.0 / d.bpm\n\t// Calculate the number of times to repeat the tone based on the duration and tempo.\n\tnumRepeats := int(duration / tempo)\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < numRepeats; i++ {\n\t\t// Turn the buzzer on.\n\t\tif err := d.TurnOn(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sleep for the tone period.\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Microsecond)\n\t\t// Turn the buzzer off.\n\t\tif err := d.TurnOff(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sleep for the tempo minus the tone period.\n\t\ttime.Sleep(time.Duration(tempo-tonePeriod) * time.Microsecond)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 59.31254402989596}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif hz <= 0 || duration <= 0 {\n\t\treturn errors.New(\"Tone: invalid frequency or duration\")\n\t}\n\tif d.pin == nil {\n\t\treturn errors.New(\"Tone: pin is not set\")\n\t}\n\n\td.pin.High()\n\ttime.Sleep(time.Millisecond * time.Duration(duration*1000))\n\td.pin.Low()\n\n\treturn nil\n}\n", "CodeBleu_score": 21.936827676587324}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif hz == 0 {\n\t\treturn errors.New(\"frequency cannot be 0\")\n\t}\n\tif duration == 0 {\n\t\treturn errors.New(\"duration cannot be 0\")\n\t}\n\tif d.Pin == 0 {\n\t\treturn errors.New(\"pin is not set\")\n\t}\n\tif d.Bpm == 0 {\n\t\treturn errors.New(\"bpm cannot be 0\")\n\t}\n\tif d.Pin.IsOutput() {\n\t\treturn errors.New(\"pin is not set to output\")\n\t}\n\tif d.Pin.IsInput() {\n\t\treturn errors.New(\"pin is not set to input\")\n\t}\n\tif d.Pin.IsAnalog() {\n\t\treturn errors.New(\"pin is not set to analog\")\n\t}\n\n\td.Pin.SetOutput()\n\tdefer d.Pin.SetInput()\n\n\t// Calculate tone period (in milliseconds) based on frequency (hz) and tempo (bpm)\n\ttonePeriod := 1000.0 / (hz * 60.0 / d.Bpm)\n\n\t// Calculate number of times to toggle the buzzer on and off based on tone period and duration\n\tnumToggles := int(duration * 1000.0 / tonePeriod)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < numToggles; i++ {\n\t\td.Pin.Set()\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t\td.Pin.Clear()\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 38.847460738908026}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == -1 {\n\t\treturn errors.New(\"Sleep pin not configured\")\n\t}\n\td.stop()\n\td.sleeping = true\n\td.sleepPin.Write(0)\n\treturn nil\n}\n", "CodeBleu_score": 25.948914500541008}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == 0 {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\n\td.stopOperations()\n\td.sleepPin.Low()\n\td.sleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 28.66774014446819}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 29.202148324735344}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"analog pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := gobot.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 51.492164577546085}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map not initialized\")\n\t}\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translateID(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin = a.newAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 54.72604942867705}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := a.newAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 52.06722994461035}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPins.Get(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}\n", "CodeBleu_score": 58.96357636768492}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.pins.Get(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}\n", "CodeBleu_score": 57.46086347765345}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.pinMap[id]\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\treturn nil\n}\n", "CodeBleu_score": 57.08823469830486}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if!a.Connected() {\n\t\treturn nil, errors.New(\"digital pin adaptor not connected\")\n\t}\n\tif len(a.Pins) == 0 {\n\t\treturn nil, errors.New(\"digital pin adaptor has no pins\")\n\t}\n\tif len(opts) == 0 {\n\t\treturn a.Pins[id], nil\n\t}\n\tpin, ok := a.Pins[id]\n\tif!ok {\n\t\tchip, line, err := a.translateID(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = gobot.NewDigitalPin(a, chip, line)\n\t\ta.Pins[id] = pin\n\t}\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\treturn pin, nil\n}\n", "CodeBleu_score": 49.99265987550191}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if a.pins == nil {\n\t\treturn nil, errors.New(\"digital pins adaptor not connected\")\n\t}\n\tpin, err := a.pins.DigitalPin(id, opts...)\n\tif err!= nil {\n\t\tif err == gobot.ErrUnknownPin {\n\t\t\tchip, line, err := a.translatePin(id)\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpin, err = a.pins.NewDigitalPin(id, chip, line, opts...)\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ta.pins.Store(id, pin)\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn pin, nil\n}\n", "CodeBleu_score": 54.25458707762645}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if!a.connected {\n\t\treturn nil, errors.New(a.Name() + \" not connected to any pins\")\n\t}\n\n\tpin, err := a.Pinner.DigitalPin(id)\n\tif err!= nil {\n\t\tpin, err = a.Pinner.DigitalPin(id, opts...)\n\t\tif err!= nil {\n\t\t\tif pin, err = a.createDigitalPin(id, opts...); err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 36.16045690707279}]}
