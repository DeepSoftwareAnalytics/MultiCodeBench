{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> required_files;\n\tstd::vector<std::string> files = GetFilesInFolder(folder);\n\tfor (const auto &file : files) {\n\t\tif (download) {\n\t\t\tstd::string file_path = folder + file;\n\t\t\tif (!FileExists(file_path)) {\n\t\t\t\tLogDownload(file_path);\n\t\t\t\tDownloadFile(file_path);\n\t\t\t} else {\n\t\t\t\tLogCache(file_path);\n\t\t\t}\n\t\t}\n\t\trequired_files.push_back(folder + file);\n\t}\n\treturn required_files;\n}\n", "CodeBleu_score": 43.02470380594855}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> files;\n\tstd::string path = folder;\n\tif (path.back()!= '/') {\n\t\tpath += '/';\n\t}\n\tstd::string fullPath = path;\n\tstd::string fileName;\n\tstd::string command = \"ls \" + path;\n\tstd::string line;\n\tstd::vector<std::string> output;\n\tstd::vector<std::string> output2;\n\tstd::vector<std::string> output3;\n\tstd::vector<std::string> output4;\n\tstd::vector<std::string> output5;\n\tstd::vector<std::string> output6;\n\tstd::vector<std::string> output7;\n\tstd::vector<std::string> output8;\n\tstd::vector<std::string> output9;\n\tstd::vector<std::string> output10;\n\tstd::vector<std::string> output11;\n\tstd::vector<std::string> output12;\n\tstd::vector<std::string> output13;\n\tstd::vector<std::string> output14;\n\tstd::vector<std::string> output15;\n\tstd::vector<std::string> output16;\n\tstd::vector<std::string> output17;\n\tstd::vector<std::string> output18;\n\tstd::vector<std::string> output19;\n\tstd::vector<std::string> output20;\n\tstd::vector<std::string> output21;\n\tstd::vector<std::string> output22;\n\tstd::vector<std::string> output23;\n\tstd::vector<std::string> output24;\n\tstd::vector<std::string> output25;\n\tstd::vector<std::string> output26;\n\tstd::vector<std::string> output27;\n\tstd::vector<std::string> output28;\n\tstd::vector<std::string> output29;\n\tstd::vector<std::string> output30;\n\tstd::vector<std::string> output31;\n\tstd::vector<std::string> output", "CodeBleu_score": 22.367956335671945}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = GetFiles(folder);\n\tfor (const auto &file : files) {\n\t\tif (download) {\n\t\t\tif (!FileExists(file)) {\n\t\t\t\tLog(\"Downloading \" + file);\n\t\t\t\tDownloadFile(file);\n\t\t\t} else {\n\t\t\t\tLog(\"Found \" + file + \" in cache\");\n\t\t\t}\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\treturn requiredFiles;\n}\n", "CodeBleu_score": 46.55872215516942}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)#ifdef _WIN32\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.translation.x!= 0.0 ||\n        transform.translation.y!= 0.0 ||\n        transform.translation.z == 0.0) {\n      std::string msg = \"Warning: SpringArm and SpringArmGhost attachments are ill-formed when the translation is only in the 'z' axis.\";\n      std::cerr << msg << std::endl;\n      rpc::LogMessage(msg);\n    }\n  }", "CodeBleu_score": 33.923508840053586}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)#ifdef _WIN32\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.translation.x == 0.0 && transform.translation.y == 0.0 && transform.translation.z!= 0.0) {\n      std::cerr << \"WARNING: The translation of the spring arm is only in the 'z' axis. This is not allowed. The spring arm will be attached to the parent actor at the origin.\" << std::endl;\n    }\n  }", "CodeBleu_score": 29.797969758921774}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)#ifdef RPC_DEBUG\n  std::cout << \"Client::SpawnActorWithParent\" << std::endl;", "CodeBleu_score": 8.883877159308986}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\trpc::GBufferToken token;\n\ttoken.ActorId = ActorId;\n\ttoken.GBufferId = GBufferId;\n\tSubscribeToGBuffer(token, callback);\n}\n", "CodeBleu_score": 30.959683101022566}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\trpc::GBufferId gBufferId;\n\tgBufferId.set_actorid(ActorId);\n\tgBufferId.set_gbufferid(GBufferId);\n\trpc::GBufferToken token = GetGBufferToken(gBufferId);\n\tstd::shared_ptr<rpc::GBufferToken> token_ptr = std::make_shared<rpc::GBufferToken>(token);\n\trpc::GBufferToken copy = *token_ptr;\n\tSubscribeToGBuffer(copy, callback);\n}\n", "CodeBleu_score": 39.773732241304415}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\trpc::Token token;\n\tauto gbuffer = GetGBuffer(ActorId, GBufferId);\n\tgbuffer.GetToken(token);\n\tauto token_data = token.GetData();\n\tSubscribeToStream(token_data, [callback](Buffer buffer) {\n\t\tcallback(buffer);\n\t});\n}\n", "CodeBleu_score": 43.98316478466825}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (m_walkerNavigation == nullptr) {\n\t\tm_walkerNavigation = std::make_shared<WalkerNavigation>(m_walker);\n\t\tif (!m_walker->SetNavigation(m_walkerNavigation)) {\n\t\t\tm_walkerNavigation = nullptr;\n\t\t}\n\t}\n\treturn m_walkerNavigation;\n}\n", "CodeBleu_score": 42.453576470325636}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (walkerNavigation == nullptr) {\n\t\twalkerNavigation = std::make_shared<WalkerNavigation>();\n\t\tif (!SetWalkerNavigation(walkerNavigation)) {\n\t\t\twalkerNavigation = nullptr;\n\t\t}\n\t}\n\treturn walkerNavigation;\n}\n", "CodeBleu_score": 35.24712730035514}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tstd::shared_ptr<WalkerNavigation> nav = GetWalkerNavigation();\n\tif (nav == nullptr) {\n\t\tnav = std::make_shared<WalkerNavigation>();\n\t\tSetWalkerNavigation(nav);\n\t}\n\treturn nav;\n}\n", "CodeBleu_score": 40.21016017846616}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tconst auto start = steady_clock::now();\n\twhile (episode.current_frame() < frame) {\n\t\tif (steady_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tyield();\n\t}\n\tepisode.tick();\n\treturn true;\n}\n", "CodeBleu_score": 26.777617810684596}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tif (episode.current_frame() >= frame) {\n\t\treturn true;\n\t}\n\tauto start = high_resolution_clock::now();\n\twhile (episode.current_frame() < frame) {\n\t\tif (high_resolution_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tepisode.tick();\n\t\tyield();\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 30.71202336141371}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tauto start = steady_clock::now();\n\tauto end = start + timeout;\n\twhile (episode.GetCurrentFrame() < frame) {\n\t\tif (steady_clock::now() > end) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.Tick();\n\treturn true;\n}\n", "CodeBleu_score": 34.33251484180784}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tif (map_name.empty()) {\n\t\tthrow std::runtime_error(\"Invalid map name.\");\n\t}\n\n\t// Load episode\n\tEpisodeProxy episode;\n\tepisode.id = 0;\n\tepisode.map_name = map_name;\n\tepisode.reset_settings = reset_settings;\n\tepisode.map_layers = map_layers;\n\tepisode.client.connect(m_host, m_port);\n\tepisode.client.call(\"LoadEpisode\", episode.id, episode.map_name, episode.reset_settings, episode.map_layers);\n\n\t// Wait for episode to connect\n\tint attempts = 0;\n\twhile (episode.id == 0) {\n\t\tepisode.client.call(\"GetEpisodeId\", episode.id);\n\t\tattempts++;\n\t\tif (attempts > m_timeout) {\n\t\t\tthrow std::runtime_error(\"Failed to connect to episode.\");\n\t\t}\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t}\n\n\treturn episode;\n}\n", "CodeBleu_score": 38.95464520944948}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\t// Send the request\n\tEpisodeProxy episode_proxy;\n\trpc::Episode episode;\n\tepisode_proxy.episode = &episode;\n\tepisode_proxy.simulator = this;\n\tepisode_proxy.client = client;\n\tepisode_proxy.id = -1;\n\tepisode_proxy.is_done = false;\n\tepisode_proxy.is_connected = false;\n\tepisode_proxy.is_reset = false;\n\tepisode_proxy.is_ready = false;\n\tepisode_proxy.is_running = false;\n\tepisode_proxy.is_paused = false;\n\tepisode_proxy.is_stepping = false;\n\tepisode_proxy.is_closed = false;\n\tepisode_proxy.is_error = false;\n\tepisode_proxy.is_waiting = false;\n\tepisode_proxy.is_waiting_for_reset = false;\n\tepisode_proxy.is_waiting_for_ready = false;\n\tepisode_proxy.is_waiting_for_running = false;\n\tepisode_proxy.is_waiting_for_paused = false;\n\tepisode_proxy.is_waiting_for_stepping = false;\n\tepisode_proxy.is_waiting_for_closed = false;\n\tepisode_proxy.is_waiting_for_error = false;\n\tepisode_proxy.is_waiting_for_done = false;\n\tepisode_proxy.is_waiting_for_status = false;\n\tepisode_proxy.is_waiting_for_step_result = false;\n\tepisode_proxy.is_waiting_for_step_results = false;\n\tepisode_proxy.is_waiting_for_action_space = false;\n\tepisode_proxy.is_waiting_for_observation_space = false;\n\tepisode_proxy.is_waiting_for_observation = false;\n\tepisode_proxy.is_waiting_for_observations = false;\n\tepisode_proxy.is_waiting_for_reward = false;\n\tepisode_proxy.is_waiting_for_rewards = false;\n\tepisode_proxy.is_waiting_for_info = false;\n\tepisode_proxy.is_waiting_for_infos = false;\n\tepisode_proxy.is_waiting_for_map = false;", "CodeBleu_score": 12.579016421041747}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tif (map_name.empty()) {\n\t\tthrow std::invalid_argument(\"map_name cannot be empty\");\n\t}\n\n\t// Check if the episode is already loaded\n\tif (m_episode_id!= 0) {\n\t\tthrow std::runtime_error(\"An episode is already loaded\");\n\t}\n\n\t// Load the episode\n\tm_client.call(\"LoadEpisode\", map_name, reset_settings, map_layers);\n\n\t// Wait for the episode to load\n\tint attempts = 0;\n\twhile (m_episode_id == 0 && attempts < m_max_attempts) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(m_timeout));\n\t\tm_client.call(\"GetEpisodeId\", m_episode_id);\n\t\tattempts++;\n\t}\n\n\t// Check if the episode loaded successfully\n\tif (m_episode_id == 0) {\n\t\tthrow std::runtime_error(\"Failed to load episode within the allowed attempts\");\n\t}\n\n\t// Create the episode object\n\tEpisodeProxy episode(m_client, m_episode_id);\n\n\treturn episode;\n}\n", "CodeBleu_score": 42.30580430077836}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tassert(episode!= nullptr);\n\tauto walker = GetWalker(controller.GetWalkerID());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\tif (episode->GetNavigation() == nullptr) {\n\t\tepisode->CreateNavigation();\n\t}\n\tepisode->GetNavigation()->RegisterWalker(controller.GetWalkerID());\n}\n", "CodeBleu_score": 53.33382331591442}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\t// Get the walker associated with the controller\n\tauto walker = GetWalker(controller.GetWalkerID());\n\t// Assert that the walker is not null\n\tassert(walker!= nullptr);\n\t// Assert that the episode is not null\n\tassert(episode!= nullptr);\n\t// Create navigation if it is missing\n\tif (episode->GetNavigation() == nullptr) {\n\t\tepisode->SetNavigation(new Navigation(episode->GetMap()));\n\t}\n\t// Register the walker with the controller's ID\n\tepisode->GetNavigation()->RegisterWalker(walker, controller.GetID());\n}\n", "CodeBleu_score": 51.93106798066817}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tassert(episode!= nullptr);\n\tassert(episode->GetNavigation()!= nullptr);\n\n\tauto walker = episode->GetWalker(controller.GetID());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\n\tepisode->GetNavigation()->RegisterWalker(controller.GetID());\n}\n", "CodeBleu_score": 54.44042596060049}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)#ifdef BUILD_CLIENT\n  // Make sure the simulator is connected to the server\n  if (!IsConnected()) {\n    throw std::runtime_error(\"Cannot spawn actor without a connection to the server\");\n  }\n\n  // Create the actor creation request\n  rpc::ActorCreationRequest request;\n  request.blueprint = blueprint;\n  request.transform = transform;\n  request.parent_handle = parent? parent->GetHandle() : 0;\n  request.attachment_type = attachment_type;\n  request.garbage_collection_policy = gc;\n  request.socket_name = socket_name;\n\n  // Send the actor creation request to the server\n  rpc::ActorCreationResponse response;\n  if (!SendRequest(request, response)) {\n    throw std::runtime_error(\"Failed to create actor\");\n  }\n\n  // Create the actor from the response\n  SharedPtr<Actor> actor = CreateActor(response.handle, response.blueprint, response.transform);\n\n  // Register the actor in the current episode\n  RegisterActor(actor);\n\n  // Apply the garbage collection policy\n  ApplyGarbageCollectionPolicy(actor, gc);\n\n  // Log the actor creation\n  LogActorCreation(actor, gc);\n\n  // Return the actor\n  return actor;", "CodeBleu_score": 45.21841751891207}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)#ifdef _WIN32\n  // Workaround for Windows:\n  // The RPC server on Windows does not support shared pointers, so we need to\n  // pass the raw pointer of the actor to the RPC server.\n  // The RPC server will then return the raw pointer of the actor.\n  // The RPC server will then call the GarbageCollector to collect the actor.\n  // The GarbageCollector will then delete the actor.\n  // We need to manually delete the actor here.\n  // This is not needed for Linux.\n  // TODO: Remove this workaround once the RPC server supports shared pointers\n  // on Windows.\n  SharedPtr<Actor> actor =\n      std::make_shared<Actor>(blueprint, transform, parent, attachment_type);\n  actor->SetGarbageCollectionPolicy(gc);\n  actor->SetSocketName(socket_name);\n  auto actor_ptr = actor.get();\n  rpc::Call(\"SpawnActor\", actor_ptr, transform, parent, attachment_type);\n  actor.reset();\n  return SharedPtr<Actor>(actor_ptr);", "CodeBleu_score": 37.92703788880436}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)#ifdef BUILD_CLIENT\n  if (blueprint.GetActorDescription().IsSensor()) {\n    // TODO(sibi): Sensor blueprint is not supported in client mode.\n    throw std::runtime_error(\"Sensor blueprint is not supported in client mode.\");\n  }", "CodeBleu_score": 14.870636361707435}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)#if!defined(DISABLE_PYTHON)\n  if (m_python) {\n    m_python->SubscribeToSensor(sensor, callback);\n    return;\n  }", "CodeBleu_score": 20.37535568078181}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)#ifdef _WIN32\n  // Windows has a bug where it doesn't properly handle the thread pool\n  // when a thread is created and destroyed within the same second.\n  // To work around this, we sleep for a second before creating the thread.\n  std::this_thread::sleep_for(std::chrono::seconds(1));", "CodeBleu_score": 10.38578579145614}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)#ifdef _WIN32\n  if (!episode_id.IsValid()) {\n    throw std::runtime_error(\"Episode is not valid.\");\n  }", "CodeBleu_score": 14.402623816563445}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\tif (!episode->GetWalkers().empty()) {\n\t\tauto walkers = episode->GetWalkers();\n\t\tauto state = episode->GetCurrentState();\n\t\tauto walkers_to_remove = std::vector<std::shared_ptr<WalkerController>>();\n\t\tauto vehicles_to_remove = std::vector<Vehicle*>();\n\t\tfor (auto walker : walkers) {\n\t\t\tif (walker->GetActor()->GetController() == nullptr) {\n\t\t\t\twalker->SetActor(nullptr);\n\t\t\t\twalkers_to_remove.push_back(walker);\n\t\t\t}\n\t\t}\n\t\tfor (auto walker : walkers_to_remove) {\n\t\t\twalkers.erase(std::remove(walkers.begin(), walkers.end(), walker), walkers.end());\n\t\t}\n\t\tepisode->SetWalkers(walkers);\n\t\tfor (auto walker : walkers) {\n\t\t\twalker->UpdateVehicle();\n\t\t}\n\t\tepisode->GetCrowd()->update(episode->GetDeltaSeconds(), state.GetVehicles());\n\t\tfor (auto walker : walkers) {\n\t\t\twalker->ApplyState(state);\n\t\t}\n\t\tfor (auto walker : walkers) {\n\t\t\tif (walker->GetActor()->GetController() == nullptr) {\n\t\t\t\tvehicles_to_remove.push_back(walker->GetVehicle());\n\t\t\t\twalker->SetActor(nullptr);\n\t\t\t}\n\t\t}\n\t\tfor (auto vehicle : vehicles_to_remove) {\n\t\t\tstate.RemoveVehicle(vehicle);\n\t\t}\n\t\tfor (auto walker : walkers) {\n\t\t\tif (walker->GetActor()->GetController() == nullptr) {\n\t\t\t\twalker->SetActor(nullptr);\n\t\t\t\twalkers_to_remove.push_back(walker);\n\t\t\t}\n\t\t}\n\t\tfor (auto walker : walkers_to_remove) {\n\t\t\twalkers.erase(std::remove(walkers.begin(), walkers.end(), walker), walkers.end());\n\t\t}\n\t\tepisode->SetWalkers(walkers);\n\t\tfor (auto walker : walkers) {\n\t\t\tif (walker->GetActor()->GetController() == nullptr) {\n\t\t\t\twalker->SetActor(nullptr);\n\t\t\t\twalkers_to_remove.push_back(walker", "CodeBleu_score": 42.09615263248725}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// Get the current walkers\n\tauto walkers = episode->GetWalkers();\n\n\t// If there are no walkers, return\n\tif (walkers.size() == 0) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the episode\n\tauto state = episode->GetCurrentState();\n\n\t// Remove any walkers that no longer exist\n\tfor (auto it = walkers.begin(); it!= walkers.end();) {\n\t\tif (!state->HasWalker(*it)) {\n\t\t\tit = walkers.erase(it);\n\t\t}\n\t\telse {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update the vehicles in the crowd and the crowd itself in the navigation module\n\tfor (auto walker : walkers) {\n\t\tauto vehicle = state->GetWalker(walker)->GetVehicle();\n\t\tauto transform = vehicle->GetTransform();\n\t\tauto speed = vehicle->GetSpeed();\n\t\tauto controller = episode->GetWalkerController(walker);\n\t\tcontroller->Update(transform, speed);\n\t}\n\n\t// For each walker, get their transform and speed, then apply these states in a batch to the simulator\n\tauto transforms = std::vector<Transform>();\n\tauto speeds = std::vector<float>();\n\tfor (auto walker : walkers) {\n\t\tauto vehicle = state->GetWalker(walker)->GetVehicle();\n\t\ttransforms.push_back(vehicle->GetTransform());\n\t\tspeeds.push_back(vehicle->GetSpeed());\n\t}\n\tepisode->GetSimulator()->SetVehicles(walkers, transforms, speeds);\n\n\t// Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead\n\tfor (auto walker : walkers) {\n\t\tif (state->GetWalker(walker)->GetVehicle()->GetHealth() <= 0.0f) {\n\t\t\tepisode->DestroyWalkerController(walker);\n\t\t\tepisode->RemoveWalker(walker);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.56700855724719}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\tif (episode->GetWalkers().empty()) return;\n\tstd::vector<Walker> walkers = episode->GetWalkers();\n\tstd::vector<Walker> toRemove;\n\tfor (Walker walker : walkers) {\n\t\tif (!walker.GetActor()->IsValidLowLevel()) {\n\t\t\ttoRemove.push_back(walker);\n\t\t}\n\t}\n\tfor (Walker walker : toRemove) {\n\t\tepisode->RemoveWalker(walker);\n\t}\n\tepisode->GetNavigationModule()->UpdateVehicles(walkers);\n\tepisode->GetNavigationModule()->UpdateCrowd(walkers);\n\tstd::vector<WalkerState> states;\n\tfor (Walker walker : walkers) {\n\t\tFTransform transform = walker.GetActor()->GetActorTransform();\n\t\tFVector speed = walker.GetActor()->GetVelocity();\n\t\tstates.push_back(WalkerState(transform, speed));\n\t}\n\tepisode->GetSimulator()->SetWalkerStates(states);\n\tfor (Walker walker : walkers) {\n\t\tif (walker.GetActor()->GetVelocity().Size() <= 0.0f) {\n\t\t\twalker.GetController()->Destroy();\n\t\t\tepisode->RemoveWalker(walker);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.511532987791526}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.set_uid(uid_);\n\tdescription.set_id(id_);\n\tdescription.set_blueprint_id(blueprint_id_);\n\tdescription.set_parent_id(parent_id_);\n\tdescription.set_parent_uid(parent_uid_);\n\tdescription.set_blueprint_name(blueprint_name_);\n\tdescription.set_blueprint_version(blueprint_version_);\n\tdescription.set_blueprint_filename(blueprint_filename_);\n\tdescription.set_blueprint_description(blueprint_description_);\n\tdescription.set_blueprint_tags(blueprint_tags_);\n\tdescription.set_blueprint_is_abstract(blueprint_is_abstract_);\n\tdescription.set_blueprint_is_system(blueprint_is_system_);\n\tdescription.set_blueprint_is_static(blueprint_is_static_);\n\tdescription.set_blueprint_is_dynamic(blueprint_is_dynamic_);\n\tdescription.set_blueprint_is_physical(blueprint_is_physical_);\n\tdescription.set_blueprint_is_kinematic(blueprint_is_kinematic_);\n\tdescription.set_blueprint_is_trigger(blueprint_is_trigger_);\n\tdescription.set_blueprint_is_visible(blueprint_is_visible_);\n\tdescription.set_blueprint_is_enabled(blueprint_is_enabled_);\n\tdescription.set_blueprint_is_valid(blueprint_is_valid_);\n\tdescription.set_blueprint_is_static_mesh(blueprint_is_static_mesh_);\n\tdescription.set_blueprint_is_skeletal_mesh(blueprint_is_skeletal_mesh_);\n\tdescription.set_blueprint_is_rigid_body(blueprint_is_rigid_body_);\n\tdescription.set_blueprint_is_actor(blueprint_is_actor_);\n\tdescription.set_blueprint_is_light(blueprint_is_light_);\n\tdescription.set_blueprint_is_camera(blueprint_is_camera_);\n\tdescription.set_blueprint_is_audio(blueprint_is_audio_);\n\tdescription.set_blueprint_is_particle_system(blueprint_is_particle_system_);\n\tdescription.set_blueprint_is_text(blueprint_is_text_);\n\tdescription.set_blueprint", "CodeBleu_score": 30.672992343022965}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.set_blueprint_id(blueprint_id);\n\tdescription.set_blueprint_name(blueprint_name);\n\tdescription.set_blueprint_version(blueprint_version);\n\tdescription.set_blueprint_description(blueprint_description);\n\tdescription.set_blueprint_source(blueprint_source);\n\tdescription.set_blueprint_source_type(blueprint_source_type);\n\tdescription.set_blueprint_source_hash(blueprint_source_hash);\n\tdescription.set_blueprint_source_object_type(blueprint_source_object_type);\n\tdescription.set_blueprint_source_object_name(blueprint_source_object_name);\n\tdescription.set_blueprint_source_object_version(blueprint_source_object_version);\n\tdescription.set_blueprint_source_object_description(blueprint_source_object_description);\n\tdescription.set_blueprint_source_object_source(blueprint_source_object_source);\n\tdescription.set_blueprint_source_object_source_type(blueprint_source_object_source_type);\n\tdescription.set_blueprint_source_object_source_hash(blueprint_source_object_source_hash);\n\tdescription.set_blueprint_source_object_source_object_type(blueprint_source_object_source_object_type);\n\tdescription.set_blueprint_source_object_source_object_name(blueprint_source_object_source_object_name);\n\tdescription.set_blueprint_source_object_source_object_version(blueprint_source_object_source_object_version);\n\tdescription.set_blueprint_source_object_source_object_description(blueprint_source_object_source_object_description);\n\tdescription.set_blueprint_source_object_source_object_source(blueprint_source_object_source_object_source);\n\tdescription.set_blueprint_source_object_source_object_source_type(blueprint_source_object_source_object_source_type);\n\tdescription.set_blueprint_source_object_source_object_source_hash(blueprint_source_object_source_object_source_hash", "CodeBleu_score": 30.466841265591594}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.mutable_attributes()->Reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\trpc::Attribute* attribute_description = description.add_attributes();\n\t\tattribute_description->set_name(attribute.name);\n\t\tattribute_description->set_type(static_cast<rpc::Attribute_AttributeType>(attribute.type));\n\t\tattribute_description->set_value(attribute.value);\n\t}\n\treturn description;\n}\n", "CodeBleu_score": 52.61736928956833}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\tfor (auto &blueprint : *this) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tif (blueprint->GetAttribute(name) == value) {\n\t\t\t\tresult->Add(blueprint);\n\t\t\t} else if (blueprint->HasRecommendedAttribute(name)) {\n\t\t\t\tif (blueprint->GetRecommendedAttribute(name) == value) {\n\t\t\t\t\tresult->Add(blueprint);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 37.83836243784668}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\tfor (auto& blueprint : *this) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tconst std::string& attrValue = blueprint->GetAttributeValue(name);\n\t\t\tif (attrValue == value) {\n\t\t\t\tresult->Add(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 34.312256091824885}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\tfor (auto bp : blueprints) {\n\t\tif (bp->HasAttribute(name)) {\n\t\t\tif (bp->GetAttribute(name) == value) {\n\t\t\t\tresult->Add(bp);\n\t\t\t} else if (bp->GetAttribute(name).find(value)!= std::string::npos) {\n\t\t\t\tresult->Add(bp);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 34.895267663492355}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string full_path = GetFullPath(path);\n\tif (ValidatePath(full_path)) {\n\t\tFILE* file = fopen(full_path.c_str(), \"wb\");\n\t\tif (file!= nullptr) {\n\t\t\tfwrite(content.data(), sizeof(uint8_t), content.size(), file);\n\t\t\tfclose(file);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 35.74310739545648}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullPath = GetFullFilePath(path);\n\tif (ValidatePath(fullPath)) {\n\t\tstd::ofstream file(fullPath, std::ios::binary);\n\t\tif (file.is_open()) {\n\t\t\tfile.write((char*)content.data(), content.size());\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 35.923133536654596}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullPath = GetFullPath(path);\n\tif (!ValidatePath(fullPath)) {\n\t\treturn false;\n\t}\n\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 41.48916270662}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\tconst auto parent_bounds = m_parent->GetBounds(frame);\n\tconst auto location = parent_bounds->GetLocation() + transform.GetLocation();\n\tconst auto extents = transform.GetExtents();\n\tconst auto yaw = transform.GetYaw();\n\tconst auto yaw_sin = sin(yaw);\n\tconst auto yaw_cos = cos(yaw);\n\tconst auto corners = std::vector<geom::Point>{\n\t\tgeom::Point{\n\t\t\tlocation.GetX() + (yaw_cos * extents.GetX() - yaw_sin * extents.GetZ()),\n\t\t\tlocation.GetY(),\n\t\t\tlocation.GetZ() + (yaw_sin * extents.GetX() + yaw_cos * extents.GetZ())\n\t\t},\n\t\tgeom::Point{\n\t\t\tlocation.GetX() + (yaw_cos * extents.GetX() + yaw_sin * extents.GetZ()),\n\t\t\tlocation.GetY(),\n\t\t\tlocation.GetZ() + (-yaw_sin * extents.GetX() + yaw_cos * extents.GetZ())\n\t\t},\n\t\tgeom::Point{\n\t\t\tlocation.GetX() + (-yaw_cos * extents.GetX() + yaw_sin * extents.GetZ()),\n\t\t\tlocation.GetY(),\n\t\t\tlocation.GetZ() + (-yaw_sin * extents.GetX() - yaw_cos * extents.GetZ())\n\t\t},\n\t\tgeom::Point{\n\t\t\tlocation.GetX() + (-yaw_cos * extents.GetX() - yaw_sin * extents.GetZ()),\n\t\t\tlocation.GetY(),\n\t\t\tlocation.GetZ() + (yaw_sin * extents.GetX() - yaw_cos * extents.GetZ())\n\t\t}\n\t};\n\treturn std::make_shared<const Bounds>(frame, corners);\n}\n", "CodeBleu_score": 38.84168234900536}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\t// Get the parent's bounding box\n\tconst auto &parent_bounds = parent_->GetBounds(frame);\n\n\t// Get the location of the bounding box\n\tconst auto &parent_location = parent_bounds->GetLocation();\n\tconst auto &transform_location = transform.GetLocation();\n\tconst auto location = parent_location + transform_location;\n\n\t// Get the extents of the bounding box\n\tconst auto &parent_extents = parent_bounds->GetExtents();\n\tconst auto &transform_extents = transform.GetExtents();\n\tconst auto extents = parent_extents + transform_extents;\n\n\t// Get the yaw angle of the bounding box\n\tconst auto &parent_yaw = parent_bounds->GetYaw();\n\tconst auto &transform_yaw = transform.GetYaw();\n\tconst auto yaw = parent_yaw + transform_yaw;\n\n\t// Get the corners of the bounding box\n\tconst auto &corners = GetCorners(extents, yaw);\n\n\t// Create a new Bounds object and return it\n\treturn std::make_shared<const Bounds>(frame, location, corners);\n}\n", "CodeBleu_score": 34.77653334850684}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\t// Calculate the location by adding the parent's bounding box location to the transform's location.\n\tconst geom::Point3D location = transform.location + m_parent->bounding_box.location;\n\t// Compute the four corners of the bounding box by rotating the extents based on the yaw angle.\n\tconst geom::Point3D corners[] = {\n\t\tgeom::Rotate(location, transform.rotation.yaw, m_parent->bounding_box.extents.x, m_parent->bounding_box.extents.y, m_parent->bounding_box.extents.z),\n\t\tgeom::Rotate(location, transform.rotation.yaw, m_parent->bounding_box.extents.x, m_parent->bounding_box.extents.y, -m_parent->bounding_box.extents.z),\n\t\tgeom::Rotate(location, transform.rotation.yaw, m_parent->bounding_box.extents.x, -m_parent->bounding_box.extents.y, m_parent->bounding_box.extents.z),\n\t\tgeom::Rotate(location, transform.rotation.yaw, m_parent->bounding_box.extents.x, -m_parent->bounding_box.extents.y, -m_parent->bounding_box.extents.z),\n\t\tgeom::Rotate(location, transform.rotation.yaw, -m_parent->bounding_box.extents.x, m_parent->bounding_box.extents.y, m_parent->bounding_box.extents.z),\n\t\tgeom::Rotate(location, transform.rotation.yaw, -m_parent->bounding_box.extents.x, m_parent->bounding_box.extents.y, -m_parent->bounding_box.extents.z),\n\t\tgeom::Rotate(location, transform.rotation.yaw, -m_parent->bounding_box.extents.x, -m_parent->bounding_box.extents.y, m_parent->bounding_box.extents.z),\n\t\tgeom::Rotate(location, transform.rotation.yaw, -m_parent->bounding_box.extents.x, -m_parent->bounding_box.extents.y, -m_parent->bounding_box.extents.", "CodeBleu_score": 34.378853854978054}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()\t// lock the mutex\n\tstd::unique_lock<std::mutex> lock(_mutex);\n\n\t// get the light states from the server\n\tstd::vector<LightState> lightStates = _server->GetLightStates();\n\n\t// iterate through the light states\n\tfor (LightState lightState : lightStates) {\n\t\t// if the light already exists in the _lights map, update it\n\t\tif (_lights.find(lightState.id)!= _lights.end()) {\n\t\t\t_lights[lightState.id]->Update(lightState);\n\t\t}\n\t\t// otherwise, create a new light object\n\t\telse {\n\t\t\tLight* light = new Light(lightState);\n\t\t\t_lights.insert(std::pair<int, Light*>(lightState.id, light));\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.895684478706826}, {"code": "void LightManager::QueryLightsStateToServer()\t_mutex.lock();\n\n\t// Query the server for the current state of the lights\n\t_lightStates = _server->QueryLightsState();\n\n\t// Update the local light states\n\tfor (auto it = _lightStates.begin(); it!= _lightStates.end(); it++) {\n\t\tLightState state = it->second;\n\t\tif (_lights.find(state.id) == _lights.end()) {\n\t\t\t// The light does not exist in the _lights map, so create a new light\n\t\t\tLight* light = new Light(state.id, state.name, state.state, state.brightness, state.color);\n\t\t\t_lights[light->id] = light;\n\t\t} else {\n\t\t\t// The light already exists in the _lights map, so update it\n\t\t\tLight* light = _lights[state.id];\n\t\t\tlight->state = state.state;\n\t\t\tlight->brightness = state.brightness;\n\t\t\tlight->color = state.color;\n\t\t}\n\t}\n\n\t_mutex.unlock();\n}\n", "CodeBleu_score": 33.90237340334561}, {"code": "void LightManager::QueryLightsStateToServer()\t// lock the mutex\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// get the lights from the server\n\tstd::vector<Light> lights = _server->GetLights();\n\n\t// for each light in the server lights\n\tfor (auto &light : lights) {\n\t\t// if the light is not in the local lights map\n\t\tif (_lights.find(light.GetID()) == _lights.end()) {\n\t\t\t// create a new light and add it to the map\n\t\t\t_lights[light.GetID()] = std::make_shared<Light>(light);\n\t\t} else {\n\t\t\t// update the light state\n\t\t\t_lights[light.GetID()]->SetState(light.GetState());\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.93632952554907}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tif (m_dirty) {\n\t\tm_mutex.lock();\n\t\tif (m_dirty) {\n\t\t\tstd::vector<Light> lights = GetLights();\n\t\t\tstd::string message = \"lights \";\n\t\t\tfor (auto& light : lights) {\n\t\t\t\tmessage += light.GetID() + \" \" + std::to_string(light.GetBrightness()) + \" \" + std::to_string(light.GetHue()) + \" \" + std::to_string(light.GetSaturation()) + \" \" + std::to_string(light.GetTemperature()) + \" \" + std::to_string(light.GetColorMode()) + \" \";\n\t\t\t}\n\t\t\tmessage += \"\\n\";\n\t\t\tm_client.Send(message);\n\t\t\tif (discard_client) {\n\t\t\t\tm_client.Discard();\n\t\t\t}\n\t\t\tm_changes.clear();\n\t\t\tm_dirty = false;\n\t\t}\n\t\tm_mutex.unlock();\n\t}\n}\n", "CodeBleu_score": 37.61002414505242}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tif (m_dirty) {\n\t\tm_mutex.lock();\n\t\tif (m_dirty) {\n\t\t\tstd::vector<std::string> messages;\n\t\t\tfor (auto& light : m_lights) {\n\t\t\t\tif (light.second->m_dirty) {\n\t\t\t\t\tmessages.push_back(light.second->GetMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (messages.size() > 0) {\n\t\t\t\tm_client->Send(messages);\n\t\t\t}\n\t\t\tif (discard_client) {\n\t\t\t\tm_client->Discard();\n\t\t\t}\n\t\t\tfor (auto& light : m_lights) {\n\t\t\t\tlight.second->m_dirty = false;\n\t\t\t}\n\t\t\tm_dirty = false;\n\t\t}\n\t\tm_mutex.unlock();\n\t}\n}\n", "CodeBleu_score": 40.15638815634872}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tif (m_dirty) {\n\t\tm_mutex.lock();\n\t\tif (m_dirty) {\n\t\t\tstd::stringstream ss;\n\t\t\tss << \"LIGHTS \";\n\t\t\tfor (auto light : m_lights) {\n\t\t\t\tss << light.second->GetID() << \" \" << light.second->GetColor().r << \" \" << light.second->GetColor().g << \" \" << light.second->GetColor().b << \" \";\n\t\t\t}\n\t\t\tss << \"END\";\n\t\t\tstd::string msg = ss.str();\n\t\t\tm_client->Send(msg.c_str(), msg.length());\n\t\t\tm_dirty = false;\n\t\t}\n\t\tm_mutex.unlock();\n\t}\n}\n", "CodeBleu_score": 29.749136001119687}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)\tif (this->GetID()!= \"sensor.other.v2x_custom\") {\n\t\tDEBUG_MESSAGE(\"ServerSideSensor::Send() called on sensor that is not a v2x_custom sensor. Sensor ID: \" + this->GetID());\n\t\treturn;\n\t}\n\tthis->GetEpisode()->SendMessage(message, this->GetContext());\n}\n", "CodeBleu_score": 32.73687346566177}, {"code": "void ServerSideSensor::Send(std::string message)\tif (m_id!= \"sensor.other.v2x_custom\") {\n\t\tLOG(WARNING) << \"ServerSideSensor::Send() called with an incorrect sensor ID.  It should be \\\"sensor.other.v2x_custom\\\".\";\n\t\treturn;\n\t}\n\tm_context->Send(message);\n}\n", "CodeBleu_score": 40.61750422205426}, {"code": "void ServerSideSensor::Send(std::string message)\tif (this->id == \"sensor.other.v2x_custom\") {\n\t\t// Send the message\n\t\tthis->context->Send(message);\n\t} else {\n\t\t// Log a warning\n\t\tspdlog::warn(\"ServerSideSensor::Send called on a sensor that is not a V2X custom sensor.\");\n\t}\n}\n", "CodeBleu_score": 39.480802169032714}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\tif (m_tmPort!= tm_port) {\n\t\t\tif (m_tmPort!= 0) {\n\t\t\t\tUnRegister();\n\t\t\t}\n\t\t\tm_tmPort = tm_port;\n\t\t\tRegister();\n\t\t}\n\t} else {\n\t\tUnRegister();\n\t\tm_tmPort = 0;\n\t}\n}\n", "CodeBleu_score": 44.2291924387003}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\t// Register with the traffic manager\n\t\tstd::cout << \"Registering vehicle with the traffic manager\" << std::endl;\n\t\t// Create a socket\n\t\tint sock = socket(AF_INET, SOCK_DGRAM, 0);\n\t\tif (sock < 0) {\n\t\t\tstd::cerr << \"Failed to create socket\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t// Bind to port\n\t\tstruct sockaddr_in address;\n\t\taddress.sin_family = AF_INET;\n\t\taddress.sin_addr.s_addr = INADDR_ANY;\n\t\taddress.sin_port = htons(tm_port);\n\t\tint rc = bind(sock, (struct sockaddr *)&address, sizeof(address));\n\t\tif (rc < 0) {\n\t\t\tstd::cerr << \"Failed to bind to port\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t// Create a thread for receiving messages\n\t\tpthread_t thread;\n\t\tpthread_create(&thread, NULL, &Vehicle::ReceiveThread, this);\n\t\t// Send a message to the traffic manager\n\t\tstd::cout << \"Sending a message to the traffic manager\" << std::endl;\n\t\tstruct sockaddr_in tm_address;\n\t\ttm_address.sin_family = AF_INET;\n\t\ttm_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\ttm_address.sin_port = htons(tm_port);\n\t\tVehicleMessage msg;\n\t\tmsg.type = VehicleMessage::REGISTER;\n\t\tmsg.id = id;\n\t\trc = sendto(sock, (const char *)&msg, sizeof(msg), 0, (struct sockaddr *)&tm_address, sizeof(tm_address));\n\t\tif (rc < 0) {\n\t\t\tstd::cerr << \"Failed to send message\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t// Close the socket\n\t\tclose(sock);\n\t\t// Set the autopilot flag\n\t\tautopilot = true;\n\t} else {\n\t\t// Unregister with the traffic manager\n\t\tstd::cout << \"Unregistering vehicle with the traffic manager\" << std::endl;\n\t\t// Create a socket\n\t\tint sock = socket(AF_INET, SOCK", "CodeBleu_score": 35.96932803580843}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\tif (tm_port == 0) {\n\t\t\ttm_port = 8007;\n\t\t}\n\t\tthis->tm = new TrafficManagerClient(tm_port);\n\t\tthis->tm->RegisterVehicle(this);\n\t\tthis->autopilot_enabled = true;\n\t} else {\n\t\tif (this->tm!= NULL) {\n\t\t\tthis->tm->UnregisterVehicle(this);\n\t\t\tdelete this->tm;\n\t\t\tthis->tm = NULL;\n\t\t}\n\t\tthis->autopilot_enabled = false;\n\t}\n}\n", "CodeBleu_score": 32.15678301684425}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()\t//Register the AI controller with the episode\n\tEpisode->RegisterAIController(this);\n\n\t//Get the walker actor\n\tWalker = Cast<AWalker>(GetPawn());\n\n\t//Add the walker to the navigation system\n\tif (Walker) {\n\t\tEpisode->GetNavigationSystem()->AddActorToNavigation(Walker, Walker->GetActorLocation());\n\t}\n\n\t//Disable the physics simulation and collisions for the walker actor\n\tif (Walker) {\n\t\tWalker->SetActorEnableCollision(false);\n\t\tWalker->SetActorHiddenInGame(true);\n\t\tWalker->SetActorTickEnabled(false);\n\t}\n}\n", "CodeBleu_score": 37.07391270882193}, {"code": "void WalkerAIController::Start()\t// Register the AI controller with the episode\n\tEpisode::GetEpisode()->RegisterAIController(this);\n\n\t// Retrieve the walker actor\n\twalkerActor = Cast<AWalkerActor>(GetPawn());\n\tif (walkerActor) {\n\t\t// Add the walker actor to the navigation system with its current location\n\t\twalkerActor->AddActorToNavigationSystem();\n\n\t\t// Disable the physics simulation and collisions for the walker actor\n\t\twalkerActor->DisablePhysics();\n\t\twalkerActor->SetActorEnableCollision(false);\n\t}\n}\n", "CodeBleu_score": 26.686275527262676}, {"code": "void WalkerAIController::Start()\t// Get the walker actor\n\twalker = Cast<AWalker>(GetPawn());\n\t// Register the AI controller with the episode\n\tepisode->RegisterAIController(this);\n\t// Add the walker actor to the navigation system with its current location\n\tepisode->GetNavigationSystem()->AddActorToNavigation(walker, walker->GetActorLocation());\n\t// Disable the physics simulation and collisions for the walker actor\n\twalker->SetActorEnableCollision(false);\n\twalker->SetActorTickEnabled(false);\n\twalker->SetActorHiddenInGame(true);\n}\n", "CodeBleu_score": 32.29548959803522}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tif (auto nav = GetEpisode()->GetNavigation()) {\n\t\tif (auto walker = GetWalker()) {\n\t\t\tif (!nav->SetMaxSpeed(walker, max_speed)) {\n\t\t\t\tLOG_WARNING(\"WalkerAIController::SetMaxSpeed: Failed to set max speed for walker.\");\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_WARNING(\"WalkerAIController::SetMaxSpeed: Walker not found.\");\n\t\t}\n\t} else {\n\t\tLOG_WARNING(\"WalkerAIController::SetMaxSpeed: Navigation instance not found.\");\n\t}\n}\n", "CodeBleu_score": 48.68910209019467}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tif (auto nav_instance = GetEpisode()->GetNavigationInstance()) {\n\t\tif (auto walker = Cast<AWalker>(GetParentActor())) {\n\t\t\tif (!nav_instance->SetMaxSpeed(walker, max_speed)) {\n\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set max speed for walker %s.\"), *walker->GetName());\n\t\t\t}\n\t\t} else {\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to find parent walker.\"));\n\t\t}\n\t} else {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation instance is not valid.\"));\n\t}\n}\n", "CodeBleu_score": 44.87110676821744}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tauto nav_instance = GetEpisode()->GetNavigationInstance();\n\tif (!nav_instance) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed - Navigation instance not found in episode\"));\n\t\treturn;\n\t}\n\tauto walker = Cast<AWalker>(GetParentActor());\n\tif (!walker) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed - Walker not found\"));\n\t\treturn;\n\t}\n\twalker->SetMaxSpeed(nav_instance, max_speed);\n}\n", "CodeBleu_score": 43.99028785026433}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> previous = map->GetPrevious(this->shared_from_this(), distance);\n\tfor (auto i : previous) {\n\t\tSharedPtr<Waypoint> wp = SharedPtr<Waypoint>(new Waypoint(i->GetName(), i->GetLatitude(), i->GetLongitude(), i->GetElevation(), i->GetMap()));\n\t\tresult.push_back(wp);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 57.3386348581949}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> previousWaypoints;\n\tstd::vector<SharedPtr<Waypoint>> waypoints = map->GetPreviousWaypoints(this, distance);\n\tfor (std::vector<SharedPtr<Waypoint>>::iterator it = waypoints.begin(); it!= waypoints.end(); it++) {\n\t\tSharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(*it));\n\t\tpreviousWaypoints.push_back(waypoint);\n\t}\n\treturn previousWaypoints;\n}\n", "CodeBleu_score": 45.420419482036735}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> previousWaypoints = map->GetPreviousWaypoints(this, distance);\n\tstd::vector<SharedPtr<Waypoint>> result;\n\tfor (auto& waypoint : previousWaypoints) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint->GetLatitude(), waypoint->GetLongitude(), waypoint->GetAltitude(), waypoint->GetMap())));\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 50.06489743233913}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tstd::vector<SharedPtr<Signal>> unique_signals;\n\tfor (auto signal : signals) {\n\t\tif (std::find(unique_signals.begin(), unique_signals.end(), signal) == unique_signals.end()) {\n\t\t\tunique_signals.push_back(signal);\n\t\t}\n\t}\n\tfor (auto signal : unique_signals) {\n\t\tSharedPtr<Waypoint> waypoint = signal->GetWaypoint();\n\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(waypoint, signal->GetDistanceFromWaypoint()));\n\t\tresult.push_back(landmark);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 48.07604292845773}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Landmark>> landmarks;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tbool found = false;\n\t\tfor (auto landmark : landmarks) {\n\t\t\tif (landmark->GetSignal()->GetId() == signal->GetId()) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tSharedPtr<Landmark> landmark(new Landmark(signal, this));\n\t\t\tlandmarks.push_back(landmark);\n\t\t}\n\t}\n\treturn landmarks;\n}\n", "CodeBleu_score": 40.96356078820105}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\tstd::vector<SharedPtr<Signal>> unique_signals;\n\tfor (auto signal : signals) {\n\t\tbool found = false;\n\t\tfor (auto unique_signal : unique_signals) {\n\t\t\tif (signal->GetId() == unique_signal->GetId()) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tunique_signals.push_back(signal);\n\t\t}\n\t}\n\tfor (auto signal : unique_signals) {\n\t\tSharedPtr<Waypoint> waypoint = signal->GetWaypoint();\n\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(waypoint, signal));\n\t\tresult.push_back(landmark);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 45.907253996366066}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\t// If the timeout is not set, use the episode's networking timeout\n\tif (timeout == time_duration()) {\n\t\ttimeout = this->episode_settings.networking_timeout;\n\t}\n\n\t// Apply the settings\n\tuint64_t settings_id = this->ApplySettings(settings);\n\n\t// Set the timeout\n\tthis->SetTimeout(settings_id, timeout);\n\n\t// If the settings include a fixed delta time, verify the accuracy of the setting\n\tif (settings.fixed_delta_time) {\n\t\t// Verify the accuracy of the fixed delta time\n\t\tthis->VerifyFixedDeltaTime(settings_id, timeout);\n\t}\n\n\t// Return the settings identifier\n\treturn settings_id;\n}\n", "CodeBleu_score": 20.4091305746704}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\t// Apply the settings\n\tuint64_t id = m_world->apply_settings(settings, timeout);\n\n\t// Set the timeout to the episode networking timeout if it is not set\n\tif (m_timeout == time_duration::zero()) {\n\t\tm_timeout = time_duration(settings.timeout_ms() / 1000, (settings.timeout_ms() % 1000) * 1000000);\n\t}\n\n\t// If the settings include a fixed delta time, verify its accuracy\n\tif (settings.has_fixed_delta_time()) {\n\t\t// Set the fixed delta time\n\t\tm_fixed_delta_time = time_duration(settings.fixed_delta_time_ms() / 1000, (settings.fixed_delta_time_ms() % 1000) * 1000000);\n\n\t\t// Set the number of ticks to verify the fixed delta time\n\t\tuint32_t num_ticks = 10;\n\n\t\t// Set the time between ticks\n\t\ttime_duration tick_time = m_fixed_delta_time / num_ticks;\n\n\t\t// Set the time at the start of the verification\n\t\ttime_point start_time = m_clock->now();\n\n\t\t// Set the total elapsed time\n\t\ttime_duration total_time = time_duration::zero();\n\n\t\t// Set the number of ticks that were not the expected delta time\n\t\tuint32_t num_mismatched_ticks = 0;\n\n\t\t// Iterate through the number of ticks\n\t\tfor (uint32_t i = 0; i < num_ticks; i++) {\n\t\t\t// Sleep for the tick time\n\t\t\tstd::this_thread::sleep_for(tick_time);\n\n\t\t\t// Get the elapsed time\n\t\t\ttime_duration elapsed_time = m_clock->now() - start_time;\n\n\t\t\t// Increment the total time\n\t\t\ttotal_time += elapsed_time;\n\n\t\t\t// If the elapsed time does not match the expected delta time, increment the number of mismatched ticks\n\t\t\tif (elapsed_time!= m_fixed_delta_time) {\n\t\t\t\tnum_mismatched_ticks++;\n\t\t\t}\n\t\t}\n\n\t\t// Calculate the average time between ticks\n\t\ttime_duration", "CodeBleu_score": 42.08153154631751}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\tuint64_t id = GetNextSettingsID();\n\trpc::EpisodeSettings settings_copy = settings;\n\tsettings_copy.id = id;\n\tif (timeout == time_duration::max()) {\n\t\ttimeout = time_duration(settings.networking_timeout);\n\t}\n\tif (settings.fixed_delta_time > 0) {\n\t\tuint32_t attempts = 0;\n\t\twhile (attempts < 5) {\n\t\t\tif (VerifyFixedDeltaTime(settings)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tattempts++;\n\t\t}\n\t\tif (attempts == 5) {\n\t\t\tLOG_WARNING(\"Fixed delta time setting is not accurate.\");\n\t\t}\n\t}\n\tsettings_copy.timeout = timeout;\n\tsettings_copy.networking_timeout = timeout;\n\tsettings_copy.time = GetTime();\n\tsettings_copy.seed = GetRandomSeed();\n\tsettings_copy.random_seed = GetRandomSeed();\n\tsettings_copy.state = rpc::EpisodeSettings::State::kActive;\n\tsettings_copy.tick_duration = time_duration(0);\n\tsettings_copy.tick_time = GetTime();\n\tsettings_copy.tick_count = 0;\n\tsettings_copy.tick_rate = 0;\n\tsettings_copy.tick_rate_average = 0;\n\tsettings_copy.tick_rate_variance = 0;\n\tsettings_copy.tick_rate_standard_deviation = 0;\n\tsettings_copy.tick_rate_minimum = 0;\n\tsettings_copy.tick_rate_maximum = 0;\n\tsettings_copy.tick_rate_window = 0;\n\tsettings_copy.tick_rate_window_average = 0;\n\tsettings_copy.tick_rate_window_variance = 0;\n\tsettings_copy.tick_rate_window_standard_deviation = 0;\n\tsettings_copy.tick_rate_window_minimum = 0;\n\tsettings_copy.tick_rate_window_maximum = 0;\n\tsettings_copy.tick_rate_window_count = 0;\n\tsettings_copy.tick_rate_window_duration = time_duration(0);\n\tsettings", "CodeBleu_score": 36.013119779767}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tconst Vector2f& point,\n\tconst Vector2f& start,\n\tconst Vector2f& end\n} {\n\tVector2f segment = end - start;\n\tfloat squaredLength = segment.LengthSquared();\n\tif (squaredLength == 0.0f) {\n\t\treturn { 0.0f, (point - start).Length() };\n\t}\n\tfloat t = Math::Clamp((point - start).Dot(segment) / squaredLength, 0.0f, 1.0f);\n\tVector2f projection = start + segment * t;\n\treturn { t, (point - projection).Length() };\n}\n", "CodeBleu_score": 39.28613061329693}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tconst Vector2f& segmentStart,\n\tconst Vector2f& segmentEnd,\n\tconst Vector2f& point\n} {\n\tVector2f segmentVector = segmentEnd - segmentStart;\n\tfloat segmentLengthSquared = segmentVector.LengthSquared();\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn { 0.0f, (point - segmentStart).Length() };\n\t}\n\n\tfloat t = Vector2f::Dot(point - segmentStart, segmentVector) / segmentLengthSquared;\n\tt = Math::Clamp(t, 0.0f, 1.0f);\n\tVector2f projection = segmentStart + t * segmentVector;\n\treturn { t, (point - projection).Length() };\n}\n", "CodeBleu_score": 36.763169737993586}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tconst glm::vec2& point,\n\tconst glm::vec2& segmentStart,\n\tconst glm::vec2& segmentEnd\n} {\n\tconst glm::vec2 segment = segmentEnd - segmentStart;\n\tconst float segmentLengthSquared = glm::dot(segment, segment);\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, glm::distance(point, segmentStart));\n\t}\n\n\tconst float projection = glm::dot(point - segmentStart, segment) / segmentLengthSquared;\n\tconst float clampedProjection = glm::clamp(projection, 0.0f, 1.0f);\n\tconst glm::vec2 projectionPoint = segmentStart + clampedProjection * segment;\n\tconst float distanceAlongSegment = glm::distance(segmentStart, projectionPoint);\n\tconst float distanceToPoint = glm::distance(projectionPoint, point);\n\treturn std::make_pair(distanceAlongSegment, distanceToPoint);\n}\n", "CodeBleu_score": 44.78382377988771}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tconst size_t initial_index = m_vertices.size();\n\tm_vertices.insert(m_vertices.end(), vertices.begin(), vertices.end());\n\tfor (size_t i = 0; i < vertices.size() - 2; i++) {\n\t\tm_indices.push_back(initial_index);\n\t\tm_indices.push_back(initial_index + i + 1);\n\t\tm_indices.push_back(initial_index + i + 2);\n\t}\n }\n", "CodeBleu_score": 53.00185861647372}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tconst size_t initial_index = mesh_.vertices.size();\n\tfor (const auto &vertex : vertices) {\n\t\tmesh_.vertices.push_back(vertex);\n\t}\n\tfor (size_t i = 0; i < vertices.size() - 2; ++i) {\n\t\tmesh_.indices.push_back(initial_index);\n\t\tmesh_.indices.push_back(initial_index + i + 1);\n\t\tmesh_.indices.push_back(initial_index + i + 2);\n\t}\n }\n\n /**\n * This function, Mesh::AddTriangleStrip, adds a triangle strip to the mesh using a provided list of vertices.\\nIt first asserts that there are at least three vertices.\\nIt then records the initial index and adds the vertices to the mesh.\\nThe function iteratively adds indices to form triangles, connecting the initial vertex with each subsequent pair of vertices in the list.\n */\n void Mesh::AddTriangleStrip(const std::vector<Mesh::vertex_type> &vertices) {\n\tassert(vertices.size() >= 3);\n\tconst size_t initial_index = mesh_.vertices.size();\n\tfor (const auto &vertex : vertices) {\n\t\tmesh_.vertices.push_back(vertex);\n\t}\n\tfor (size_t i = 0; i < vertices.size() - 2; ++i) {\n\t\tif (i % 2 == 0) {\n\t\t\tmesh_.indices.push_back(initial_index + i);\n\t\t\tmesh_.indices.push_back(initial_index + i + 1);\n\t\t\tmesh_.indices.push_back(initial_index + i + 2);\n\t\t} else {\n\t\t\tmesh_.indices.push_back(initial_index + i);\n\t\t\tmesh_.indices.push_back(initial_index + i + 2);\n\t\t\tmesh_.indices.push_back(initial_index + i + 1);\n\t\t}\n\t}\n }\n\n /**\n * This function, Mesh::AddQuad, adds a quad to the mesh using a provided list of vertices.\\nIt first asserts that there are four vertices.\\nIt then records the initial index and adds the vertices to the mesh.\\nThe function iter", "CodeBleu_score": 46.51522607042966}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tsize_t initialIndex = m_vertices.size();\n\tm_vertices.insert(m_vertices.end(), vertices.begin(), vertices.end());\n\tfor (size_t i = 2; i < vertices.size(); ++i) {\n\t\tm_indices.push_back(initialIndex);\n\t\tm_indices.push_back(initialIndex + i - 1);\n\t\tm_indices.push_back(initialIndex + i);\n\t}\n}\n", "CodeBleu_score": 48.189174693252795}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (!message) {\n\t\tLOG_ERROR(\"Invalid message.\");\n\t\treturn;\n\t}\n\n\tm_strand->post([this, message]() {\n\t\tif (m_socket->is_open()) {\n\t\t\tboost::asio::async_write(\n\t\t\t\t*m_socket,\n\t\t\t\tboost::asio::buffer(message->Data(), message->Size()),\n\t\t\t\tboost::asio::transfer_all(),\n\t\t\t\t[this, message](const boost::system::error_code &error, std::size_t) {\n\t\t\t\t\tHandleSent(error, message);\n\t\t\t\t});\n\t\t} else {\n\t\t\tLOG_ERROR(\"Socket is not open.\");\n\t\t}\n\t});\n}\n", "CodeBleu_score": 27.78610138212798}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (!message) {\n\t\tLOG_ERROR(\"Invalid message\");\n\t\treturn;\n\t}\n\n\tstrand_.post([this, message]() {\n\t\tif (!socket_.is_open()) {\n\t\t\tLOG_ERROR(\"Socket is not open\");\n\t\t\treturn;\n\t\t}\n\n\t\tboost::asio::async_write(socket_, boost::asio::buffer(message->data(), message->size()), [this, message](const boost::system::error_code &ec, std::size_t /*bytes_transferred*/) {\n\t\t\thandle_sent(ec, message);\n\t\t});\n\t});\n}\n", "CodeBleu_score": 27.437507441321284}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (!message->IsValid()) {\n\t\tLOG_ERROR(\"Invalid message.\");\n\t\treturn;\n\t}\n\tstrand_.post([=] {\n\t\tif (socket_.is_open()) {\n\t\t\tsocket_.set_option(boost::asio::ip::tcp::no_delay(true));\n\t\t\tboost::asio::async_write(socket_, message->GetBuffers(), [=](const boost::system::error_code &ec, std::size_t) {\n\t\t\t\thandle_sent(ec);\n\t\t\t});\n\t\t} else {\n\t\t\tLOG_ERROR(\"Socket is not open.\");\n\t\t}\n\t});\n}\n", "CodeBleu_score": 24.54848309907159}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (ec) {\n\t\tstd::cout << \"Error closing session: \" << ec.message() << std::endl;\n\t}\n\tif (socket_.is_open()) {\n\t\tsocket_.close();\n\t}\n\tif (on_closed) {\n\t\ton_closed();\n\t}\n\tstd::cout << \"Session closed\" << std::endl;\n}\n", "CodeBleu_score": 43.06016778124059}, {"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (ec) {\n\t\tif (ec!= boost::asio::error::operation_aborted) {\n\t\t\tstd::cout << \"Error: \" << ec.message() << std::endl;\n\t\t}\n\t\treturn;\n\t}\n\tif (socket_.is_open()) {\n\t\tboost::system::error_code ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\tsocket_.close(ec);\n\t}\n\tif (on_closed) {\n\t\ton_closed(this);\n\t}\n\tstd::cout << \"Session closed\" << std::endl;\n}\n", "CodeBleu_score": 46.98972579476428}, {"code": "void Primary::CloseNow(boost::system::error_code ec)\t// Cancel the deadline timer so that the blocked accept() call will unblock.\n\tdeadline_.cancel();\n\n\tif (!ec) {\n\t\t// No error code means that the connection was closed normally;\n\t\t// the remote host closed the connection or the connection was closed by this host.\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t}\n\n\t// Close the socket.\n\tsocket_.close();\n\n\t// Inform the derived class that the session has been closed.\n\ton_closed();\n\n\t// Log that the session has been closed.\n\tstd::cout << \"Closed session \" << this << std::endl;\n}\n", "CodeBleu_score": 52.225462903548724}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()\tchar* buffer = new char[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\tLogger::Log(buffer, \"Sending\");\n\tRouter::Write(buffer, YOU_ALIVE);\n\tLogger::Log(Router::Read(), \"Received\");\n}\n", "CodeBleu_score": 20.951771008348143}, {"code": "void PrimaryCommands::SendIsAlive()\tchar buffer[50];\n\tchar message[] = \"Are you alive?\";\n\tsprintf(buffer, \"%s\", message);\n\tLog::Write(buffer, 2);\n\tnextRouter->Write(buffer, YOU_ALIVE);\n\tLog::Write(\"Waiting for response...\", 2);\n\tnextRouter->Read(buffer);\n\tLog::Write(buffer, 2);\n}\n", "CodeBleu_score": 34.58018437021008}, {"code": "void PrimaryCommands::SendIsAlive()\tchar buffer[1000];\n\tmemset(buffer, 0, 1000);\n\tstrcpy(buffer, \"Are you alive?\");\n\tLog::Write(\"Sending \\\"Are you alive?\\\" to next router.\");\n\tWrite(buffer, YOU_ALIVE);\n\tLog::Write(\"Waiting for response.\");\n\tWaitForResponse();\n}\n", "CodeBleu_score": 24.580941599563566}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Check if sensor is on any secondary server\n\tbool found = false;\n\tfor (auto &secondary_server : secondary_servers) {\n\t\tif (secondary_server.second.HasSensor(sensor_id)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tROS_ERROR(\"Sensor ID %d not found on any secondary server\", sensor_id);\n\t\treturn;\n\t}\n\n\t// Create buffer\n\tstd::vector<uint8_t> buffer;\n\tbuffer.push_back(ENABLE_ROS);\n\tbuffer.push_back(sensor_id);\n\n\t// Send buffer\n\trouter.Send(buffer);\n\n\t// Wait for and process response\n\tstd::vector<uint8_t> response = router.Receive();\n\tif (response[0] == ENABLE_ROS) {\n\t\tif (response[1] == 0) {\n\t\t\tROS_INFO(\"Sensor ID %d enabled for ROS\", sensor_id);\n\t\t} else {\n\t\t\tROS_ERROR(\"Failed to enable sensor ID %d for ROS\", sensor_id);\n\t\t}\n\t} else {\n\t\tROS_ERROR(\"Unexpected response from server\");\n\t}\n}\n", "CodeBleu_score": 46.42001623658415}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Check if sensor is enabled on any secondary server\n\tif (secondary_servers_list.size() > 0) {\n\t\t// Create buffer\n\t\tstd::vector<uint8_t> buffer;\n\t\tbuffer.push_back(ENABLE_ROS);\n\t\tbuffer.push_back(sensor_id);\n\t\t// Send buffer to server\n\t\tfor (auto &secondary_server : secondary_servers_list) {\n\t\t\tif (secondary_server.second.find(sensor_id)!= secondary_server.second.end()) {\n\t\t\t\trouter.send(secondary_server.first, buffer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Wait for server response\n\t\tstd::vector<uint8_t> response = router.recv();\n\t\tif (response.size() > 0) {\n\t\t\t// Check for error\n\t\t\tif (response[0] == ERROR) {\n\t\t\t\tlog_error(\"Error: \" + std::string((char*)response.data() + 1));\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tlog_error(\"Error: Sensor \" + std::to_string(sensor_id) + \" not found on any secondary server\");\n\t}\n}\n", "CodeBleu_score": 47.94192052045286}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Check if the sensor is activated on any secondary server\n\tbool sensor_found = false;\n\tfor (int i = 0; i < secondary_server_count; i++) {\n\t\tif (secondary_servers[i].activated_sensors[sensor_id] == true) {\n\t\t\tsensor_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sensor_found) {\n\t\t// Create buffer with sensor ID\n\t\tchar buffer[5];\n\t\tbuffer[0] = ENABLE_ROS;\n\t\tbuffer[1] = (sensor_id >> 24) & 0xFF;\n\t\tbuffer[2] = (sensor_id >> 16) & 0xFF;\n\t\tbuffer[3] = (sensor_id >> 8) & 0xFF;\n\t\tbuffer[4] = sensor_id & 0xFF;\n\n\t\t// Send ENABLE_ROS command to server using router\n\t\trouter.Send(buffer, 5);\n\n\t\t// Wait for and process server's response\n\t\tchar response[1];\n\t\trouter.Receive(response, 1);\n\t\tif (response[0] == ENABLE_ROS) {\n\t\t\t// Sensor enabled\n\t\t\tROS_INFO(\"Sensor %d enabled for ROS\", sensor_id);\n\t\t} else {\n\t\t\t// Error\n\t\t\tROS_ERROR(\"Error enabling sensor %d for ROS\", sensor_id);\n\t\t}\n\t} else {\n\t\t// Sensor not found on any server\n\t\tROS_ERROR(\"Sensor %d not found on any secondary server\", sensor_id);\n\t}\n}\n", "CodeBleu_score": 39.9724065304285}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\ttoken_type token;\n\tif (sensors_tokens.find(sensor_id)!= sensors_tokens.end()) {\n\t\ttoken = sensors_tokens[sensor_id];\n\t\tLOG_INFO(\"Sensor \" << sensor_id << \" already activated with token \" << token);\n\t} else {\n\t\tLOG_INFO(\"Activating sensor \" << sensor_id << \" on secondary server\");\n\t\ttoken = secondary_server->EnableSensor(sensor_id);\n\t\tsensors_tokens[sensor_id] = token;\n\t\ttokens_sensors[token] = sensor_id;\n\t\tLOG_INFO(\"Sensor \" << sensor_id << \" activated with token \" << token);\n\t}\n\treturn token;\n}\n", "CodeBleu_score": 44.129922218789055}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\ttoken_type token;\n\tif (active_sensors.find(sensor_id)!= active_sensors.end()) {\n\t\ttoken = active_sensors[sensor_id];\n\t\tcout << \"Token for sensor \" << sensor_id << \" is \" << token << endl;\n\t\treturn token;\n\t} else {\n\t\tcout << \"Sensor \" << sensor_id << \" is not activated. Activating it now...\" << endl;\n\t\ttoken = secondary_server->ActivateSensor(sensor_id);\n\t\tactive_sensors[sensor_id] = token;\n\t\tsensor_tokens[sensor_id] = token;\n\t\tcout << \"Token for sensor \" << sensor_id << \" is \" << token << endl;\n\t\treturn token;\n\t}\n}\n", "CodeBleu_score": 46.79807837452643}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\tif (sensor_id == 0) {\n\t\treturn 0;\n\t}\n\tif (sensor_id == 1) {\n\t\treturn 1;\n\t}\n\tif (sensor_id == 2) {\n\t\treturn 2;\n\t}\n\tif (sensor_id == 3) {\n\t\treturn 3;\n\t}\n\tif (sensor_id == 4) {\n\t\treturn 4;\n\t}\n\tif (sensor_id == 5) {\n\t\treturn 5;\n\t}\n\tif (sensor_id == 6) {\n\t\treturn 6;\n\t}\n\tif (sensor_id == 7) {\n\t\treturn 7;\n\t}\n\tif (sensor_id == 8) {\n\t\treturn 8;\n\t}\n\tif (sensor_id == 9) {\n\t\treturn 9;\n\t}\n\tif (sensor_id == 10) {\n\t\treturn 10;\n\t}\n\tif (sensor_id == 11) {\n\t\treturn 11;\n\t}\n\tif (sensor_id == 12) {\n\t\treturn 12;\n\t}\n\tif (sensor_id == 13) {\n\t\treturn 13;\n\t}\n\tif (sensor_id == 14) {\n\t\treturn 14;\n\t}\n\tif (sensor_id == 15) {\n\t\treturn 15;\n\t}\n\tif (sensor_id == 16) {\n\t\treturn 16;\n\t}\n\tif (sensor_id == 17) {\n\t\treturn 17;\n\t}\n\tif (sensor_id == 18) {\n\t\treturn 18;\n\t}\n\tif (sensor_id == 19) {\n\t\treturn 19;\n\t}\n\tif (sensor_id == 20) {\n\t\treturn 20;\n\t}\n\tif (sensor_id == 21) {\n\t\treturn 21;\n\t}\n\tif (sensor_id == 22) {\n\t\treturn 22;\n\t}\n\tif (", "CodeBleu_score": 10.221378378211742}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::in | std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> buffer;\n\tfile.seekg(0, std::ios::end);\n\tbuffer.resize(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read(&buffer[0], buffer.size());\n\tfile.close();\n\treturn Load(buffer);\n}\n", "CodeBleu_score": 55.72087609838026}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename.c_str(), std::ios::binary);\n\tif (!file) {\n\t\treturn false;\n\t}\n\n\tstd::vector<unsigned char> data;\n\tfile.seekg(0, std::ios::end);\n\tdata.resize(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read((char *) &data[0], data.size());\n\tfile.close();\n\n\treturn Load(data);\n}\n", "CodeBleu_score": 50.28149931410787}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open())\n\t\treturn false;\n\tstd::vector<unsigned char> data;\n\tfile.seekg(0, std::ios::end);\n\tdata.resize(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read((char*)&data[0], data.size());\n\tfile.close();\n\treturn Load(data);\n}\n", "CodeBleu_score": 44.560322457884425}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!m_ready) {\n\t\treturn false;\n\t}\n\n\tassert(m_crowd!= nullptr);\n\n\tauto walkerIt = m_walkerIds.find(id);\n\tif (walkerIt!= m_walkerIds.end()) {\n\t\tm_walkerManager->RemoveWalker(walkerIt->second);\n\t\tm_walkerIds.erase(walkerIt);\n\t\treturn true;\n\t}\n\n\tauto vehicleIt = m_vehicleIds.find(id);\n\tif (vehicleIt!= m_vehicleIds.end()) {\n\t\tm_vehicleManager->RemoveVehicle(vehicleIt->second);\n\t\tm_vehicleIds.erase(vehicleIt);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 43.692080351971995}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\tassert(m_crowd!= nullptr);\n\n\tint idx = -1;\n\tfor (int i = 0; i < m_walkers.size(); i++) {\n\t\tif (m_walkers[i].id == id) {\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idx == -1) {\n\t\tfor (int i = 0; i < m_vehicles.size(); i++) {\n\t\t\tif (m_vehicles[i].id == id) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (idx == -1) {\n\t\treturn false;\n\t}\n\n\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\tm_crowd->removeAgent(idx);\n\n\tif (idx < m_walkers.size()) {\n\t\tm_walkers.erase(m_walkers.begin() + idx);\n\t}\n\telse {\n\t\tm_vehicles.erase(m_vehicles.begin() + idx - m_walkers.size());\n\t}\n\n\tm_ids.erase(id);\n\n\treturn true;\n}\n", "CodeBleu_score": 50.44220705513274}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!m_ready || m_crowd == NULL) {\n\t\treturn false;\n\t}\n\n\tint index = -1;\n\tfor (int i = 0; i < m_walkers.size(); ++i) {\n\t\tif (m_walkers[i].id == id) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index!= -1) {\n\t\tm_walkers.erase(m_walkers.begin() + index);\n\t\tm_walkerManager->RemoveAgent(id);\n\t\tm_walkerIds.erase(id);\n\t\treturn true;\n\t}\n\n\tfor (int i = 0; i < m_vehicles.size(); ++i) {\n\t\tif (m_vehicles[i].id == id) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index!= -1) {\n\t\tm_vehicles.erase(m_vehicles.begin() + index);\n\t\tm_vehicleManager->RemoveAgent(id);\n\t\tm_vehicleIds.erase(id);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 44.74348075979048}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<uint32_t> currentVehicles;\n\n\tfor (auto& vehicle : vehicles) {\n\t\tcurrentVehicles.insert(vehicle.id);\n\t\tauto it = _vehicles.find(vehicle.id);\n\t\tif (it == _vehicles.end()) {\n\t\t\t_vehicles.insert({ vehicle.id, vehicle });\n\t\t}\n\t\telse {\n\t\t\tit->second = vehicle;\n\t\t}\n\t}\n\n\tfor (auto it = _vehicles.begin(); it!= _vehicles.end();) {\n\t\tif (currentVehicles.find(it->first) == currentVehicles.end()) {\n\t\t\tit = _vehicles.erase(it);\n\t\t}\n\t\telse {\n\t\t\tit->second.updated = false;\n\t\t\tit++;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 47.73746899391059}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> currentVehicles;\n\tfor (auto& vehicle : vehicles) {\n\t\tcurrentVehicles.insert(vehicle.id);\n\t\tauto it = m_vehicles.find(vehicle.id);\n\t\tif (it == m_vehicles.end()) {\n\t\t\tm_vehicles.insert(std::make_pair(vehicle.id, vehicle));\n\t\t} else {\n\t\t\tit->second = vehicle;\n\t\t}\n\t}\n\tfor (auto it = m_vehicles.begin(); it!= m_vehicles.end();) {\n\t\tif (currentVehicles.find(it->first) == currentVehicles.end()) {\n\t\t\tit = m_vehicles.erase(it);\n\t\t} else {\n\t\t\tit->second.updated = false;\n\t\t\tit++;\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 47.6821070293656}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> current_ids;\n\tfor (auto &vehicle : vehicles) {\n\t\tcurrent_ids.insert(vehicle.id);\n\t\tauto it = vehicles_.find(vehicle.id);\n\t\tif (it!= vehicles_.end()) {\n\t\t\tit->second.updated = true;\n\t\t\tit->second.collision_info = vehicle;\n\t\t} else {\n\t\t\tvehicles_.insert(std::make_pair(vehicle.id, VehicleInfo(vehicle)));\n\t\t}\n\t}\n\tfor (auto it = vehicles_.begin(); it!= vehicles_.end();) {\n\t\tif (it->second.updated) {\n\t\t\tit->second.updated = false;\n\t\t\tit++;\n\t\t} else {\n\t\t\tit = vehicles_.erase(it);\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 45.532416507363806}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tauto self = GetWalker(id);\n\tif (self == nullptr) {\n\t\tself = GetVehicle(id);\n\t}\n\tif (self == nullptr) {\n\t\treturn false;\n\t}\n\n\tconst auto self_location = self->GetLocation();\n\tconst auto self_direction = self->GetForwardVector();\n\n\tconst auto angle = std::acos(self_direction.Dot(direction) / (self_direction.Length() * direction.Length()));\n\tconst auto squared_distance = distance * distance;\n\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\tfor (const auto &walker : _walkers) {\n\t\tif (walker.first!= id) {\n\t\t\tconst auto walker_location = walker.second->GetLocation();\n\t\t\tconst auto walker_direction = walker.second->GetForwardVector();\n\t\t\tif (walker_location.DistanceSquared(self_location) < squared_distance &&\n\t\t\t\tstd::acos(walker_direction.Dot(direction) / (walker_direction.Length() * direction.Length())) < angle) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const auto &vehicle : _vehicles) {\n\t\tif (vehicle.first!= id) {\n\t\t\tconst auto vehicle_location = vehicle.second->GetLocation();\n\t\t\tconst auto vehicle_direction = vehicle.second->GetForwardVector();\n\t\t\tif (vehicle_location.DistanceSquared(self_location) < squared_distance &&\n\t\t\t\tstd::acos(vehicle_direction.Dot(direction) / (vehicle_direction.Length() * direction.Length())) < angle) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _crowd->HasVehicleNear(self_location, distance, direction);\n}\n", "CodeBleu_score": 46.03198779584126}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tif (id == 0) {\n\t\treturn false;\n\t}\n\tif (distance == 0.0f) {\n\t\treturn false;\n\t}\n\tauto &walker = GetWalker(id);\n\tif (walker.IsValid()) {\n\t\treturn false;\n\t}\n\tauto &vehicle = GetVehicle(id);\n\tif (!vehicle.IsValid()) {\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto vehicle_location = vehicle.GetLocation();\n\tauto squared_distance = distance * distance;\n\tfor (auto &walker : _walkers) {\n\t\tif (walker.IsValid()) {\n\t\t\tauto walker_location = walker.GetLocation();\n\t\t\tif (walker_location.DistanceSquared(vehicle_location) < squared_distance) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tauto &crowd = GetCrowd();\n\tauto crowd_location = vehicle_location.ToCrowd();\n\tauto crowd_direction = direction.ToCrowd();\n\tauto crowd_distance = distance;\n\tauto crowd_vehicle = crowd.QueryNearestVehicle(crowd_location, crowd_direction, crowd_distance);\n\treturn crowd_vehicle!= nullptr;\n}\n", "CodeBleu_score": 45.84729709754667}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tif (id == 0) {\n\t\treturn false;\n\t}\n\tauto actor = GetActor(id);\n\tif (actor == nullptr) {\n\t\treturn false;\n\t}\n\tif (actor->IsVehicle()) {\n\t\treturn true;\n\t}\n\tauto location = actor->GetLocation();\n\tauto direction_norm = direction.Normalize();\n\tauto distance_sq = distance * distance;\n\tauto distance_sq_direction = distance_sq * 0.01;\n\tauto direction_dot = direction_norm.Dot(location.GetForwardVector());\n\tauto direction_dot_sq = direction_dot * direction_dot;\n\tauto distance_sq_direction_dot = distance_sq_direction * direction_dot_sq;\n\tauto distance_sq_direction_dot_inv = 1.0 / distance_sq_direction_dot;\n\tauto direction_dot_inv = 1.0 / direction_dot;\n\tauto distance_sq_direction_inv = 1.0 / distance_sq_direction;\n\tauto direction_dot_inv_sq = direction_dot_inv * direction_dot_inv;\n\tauto distance_sq_direction_dot_inv_sq = distance_sq_direction_dot_inv * distance_sq_direction_dot_inv;\n\tauto distance_sq_direction_inv_sq = distance_sq_direction_inv * distance_sq_direction_inv;\n\tauto direction_dot_inv_sq_sq = direction_dot_inv_sq * direction_dot_inv_sq;\n\tauto distance_sq_direction_dot_inv_sq_sq = distance_sq_direction_dot_inv_sq * distance_sq_direction_dot_inv_sq;\n\tauto distance_sq_direction_inv_sq_sq = distance_sq_direction_inv_sq * distance_sq_direction_inv_sq;\n\tauto direction_dot_inv_sq_sq_sq = direction_dot_inv_sq_sq * direction_dot_inv_sq_sq;\n\tauto distance_sq_direction_dot_inv_sq_sq_sq = distance_sq_direction_dot_inv_sq_sq * distance_sq_direction_dot_inv_sq_sq;", "CodeBleu_score": 37.74002386290699}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\t// Retrieve the current route point for the walker\n\tauto current_route_point = info.route.at(info.current_route_point);\n\t// Create a WalkerEventVisitor with the current context\n\tWalkerEventVisitor visitor(info, delta);\n\t// Process the event at the current route point using boost::variant2::visit\n\treturn boost::variant2::visit(visitor, current_route_point.event);\n}\n", "CodeBleu_score": 46.588019947173244}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\t// Get the current route point\n\tauto routePoint = info.route->GetCurrentRoutePoint();\n\t// Create a WalkerEventVisitor with the current context\n\tWalkerEventVisitor visitor(routePoint, info.route, delta);\n\t// Execute the event at the current route point\n\treturn boost::variant2::visit(visitor, routePoint.event);\n}\n", "CodeBleu_score": 50.74347719363077}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tauto &route = info.route;\n\tauto &route_point = info.route_point;\n\tauto &current_route_point = route[route_point];\n\tauto &current_event = current_route_point.event;\n\tWalkerEventVisitor visitor{id, delta, info};\n\treturn boost::variant2::visit(visitor, current_event);\n}\n", "CodeBleu_score": 49.30241400478278}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)#ifdef LIBCARLA_DEBUG_LANE_PARSER\n  const auto start = std::chrono::high_resolution_clock::now();", "CodeBleu_score": 5.310438092933918}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n#ifdef DEBUG_LANES\n  std::cout << \"LaneParser::Parse\" << std::endl;", "CodeBleu_score": 7.000021682905211}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n#ifdef DEBUG_XML_PARSER\n  std::cout << \"Parsing lane data\" << std::endl;", "CodeBleu_score": 7.000041039853381}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.current_count_change == 1) {\n\t\t// A new match was detected\n\t\tmatched_count_ = info.total_count;\n\t\tfirst_connection_ = true;\n\t} else if (info.current_count_change == -1) {\n\t\t// A match was lost\n\t\tmatched_count_ = info.total_count;\n\t} else {\n\t\t// Invalid count change\n\t\tEFD_LOG(efd::efdError, \"CarlaListenerImpl::on_publication_matched: invalid count change %d\\n\", info.current_count_change);\n\t}\n}\n", "CodeBleu_score": 67.34587998269255}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.current_count_change == 1) {\n\t\tmatchedCount_ = info.total_count;\n\t\tfirstConnection_ = true;\n\t} else if (info.current_count_change == -1) {\n\t\tmatchedCount_ = info.total_count;\n\t} else {\n\t\tstd::cout << \"CarlaListenerImpl::on_publication_matched: invalid current count change: \" << info.current_count_change << std::endl;\n\t}\n}\n", "CodeBleu_score": 71.32190163103778}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.current_count_change == 1) {\n\t\tmatched_ = info.total_count;\n\t\tfirst_connection_ = true;\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_ = info.total_count;\n\t\tfirst_connection_ = false;\n\t} else {\n\t\t//log_error(\"CarlaListenerImpl::on_publication_matched: invalid current_count_change: %d\", info.current_count_change);\n\t}\n}\n", "CodeBleu_score": 57.07623346230481}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\t// If the subscription count changes, update the count and log the change.\n\tif (info.current_count_change == 1) {\n\t\t// A new subscription matched.\n\t\t++mMatchedCount;\n\t\tif (mMatchedCount == 1) {\n\t\t\t// The first subscription is connected.\n\t\t\tmFirstConnected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t// A subscription was unmatched.\n\t\t--mMatchedCount;\n\t\tif (mMatchedCount == 0) {\n\t\t\t// The last subscription has unmatched.\n\t\t\tmSubscriber->delete_contained_entities();\n\t\t\tmSubscriber->set_listener(NULL, efd::StatusMask::STATUS_MASK_NONE);\n\t\t\tmSubscriber->set_qos(mSubscriberQos);\n\t\t\tmSubscriber->set_listener(this, efd::StatusMask::STATUS_MASK_SUBSCRIPTION_MATCHED);\n\t\t\tmSubscriber->enable();\n\t\t\tmFirstConnected = false;\n\t\t}\n\t} else {\n\t\t// The change count is invalid.\n\t\tEFD_LOG(efd::efdError, \"CarlaSubscriberListenerImpl::on_subscription_matched: invalid change count %d\\n\", info.current_count_change);\n\t}\n}\n", "CodeBleu_score": 51.191865156565456}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\tif (info.current_count_change > 0) {\n\t\tm_matchedCount++;\n\t\tm_firstConnected = true;\n\t} else if (info.current_count_change < 0) {\n\t\tm_matchedCount--;\n\t\tif (m_matchedCount == 0) {\n\t\t\tm_subscriber->delete_contained_entities();\n\t\t\tm_subscriber->set_listener(NULL, efd::StatusMask::STATUS_MASK_NONE);\n\t\t\tm_subscriber->destroy();\n\t\t\tm_subscriber = NULL;\n\t\t}\n\t} else {\n\t\tEFD_FAIL(\"CarlaSubscriberListenerImpl::on_subscription_matched: received an invalid subscription matched status\");\n\t}\n}\n", "CodeBleu_score": 47.037858584709205}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\tif (info.current_count_change == 1) {\n\t\t++mMatchedCount;\n\t\tif (mMatchedCount == 1) {\n\t\t\tmFirstConnected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t--mMatchedCount;\n\t\tif (mMatchedCount == 0) {\n\t\t\tdestroy_subscriber();\n\t\t}\n\t} else {\n\t\tEFD_LOG(efd::efdError, \"CarlaSubscriberListenerImpl::on_subscription_matched: invalid change count %d\\n\", info.current_count_change);\n\t}\n}\n", "CodeBleu_score": 53.640693860825614}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\tif (data == nullptr) return false;\n\tif (handle == nullptr) return false;\n\n\tCarlaCollisionEvent* key = static_cast<CarlaCollisionEvent*>(data);\n\n\t// Obtain serialized size\n\teprosima::fastcdr::FastBuffer fastbuffer(0);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tsize_t init_serialized_size = ser.getSerializedDataLength();\n\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16384) {\n\t\tser.serialize_encapsulation();\n\t\tser.serialize_character(0);\n\t} else {\n\t\tser.serialize_encapsulation();\n\t}\n\n\ttry {\n\t\t// Call to the serialization function.\n\t\tser.serialize(*key);\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\t// Obtain the size of the serialized data.\n\tsize_t end_serialized_size = ser.getSerializedDataLength();\n\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16384) {\n\t\t// Compute MD5 hash.\n\t\tMD5 md5;\n\t\tmd5.update((unsigned char*)ser.getBuffer(), static_cast<unsigned int>(end_serialized_size - init_serialized_size));\n\t\tmd5.finalize();\n\t\tfor (int i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = md5.digest[i];\n\t\t}\n\t} else {\n\t\t// Copy serialized data into handle.\n\t\tmemcpy(handle->value, ser.getBuffer() + init_serialized_size, end_serialized_size - init_serialized_size);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 58.490888544880605}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t}\n\telse {\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 93.83602363831909}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t}\n\telse {\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 93.83602363831909}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\t// Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\t// Serialize encapsulation.\n\tser.serialize_encapsulation();\n\ttry {\n\t\t// Serialize the object.\n\t\tp_type->serialize(ser);\n\t}\n\tcatch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\t// Get the serialized data.\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\treturn true;\n}\n", "CodeBleu_score": 92.9717816393292}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\ttry {\n\t\tser.serialize(p_type->engine_rpm);\n\t\tser.serialize(p_type->gear);\n\t\tser.serialize(p_type->brake);\n\t\tser.serialize(p_type->hand_brake);\n\t\tser.serialize(p_type->throttle);\n\t\tser.serialize(p_type->reverse);\n\t\tser.serialize(p_type->steering);\n\t\tser.serialize(p_type->manual_gear);\n\t\tser.serialize(p_type->gear_list);\n\t\tser.serialize(p_type->gear_count);\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\treturn true;\n}\n", "CodeBleu_score": 82.03503726799985}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\t// Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\t// Serialize encapsulation.\n\tser.serialize_encapsulation();\n\ttry {\n\t\t// Serialize the object.\n\t\tp_type->serialize(ser);\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\t// Get the serialized data.\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\treturn true;\n}\n", "CodeBleu_score": 92.98821057436415}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\ttarget_compid = msg.compid;\n\t\t\tsend_request_stream_target();\n\t\t}\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\ttarget_compid = msg.compid;\n\t\t\tsend_request_stream_target();\n\t\t}\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_GPS_RAW_INT:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\ttarget_compid = msg.compid;\n\t\t\tsend_request_stream_target();\n\t\t}\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\ttarget_compid = msg.compid;\n\t\t\tsend_request_stream_target();\n\t\t}\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_VFR_HUD:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\ttarget_compid = msg.compid;\n\t\t\tsend_request_stream_target();\n\t\t}\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_SYS_STATUS:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\ttarget_compid = msg.compid;\n\t\t\tsend_request_stream_target();\n\t\t}\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\ttarget_compid = msg.compid;", "CodeBleu_score": 41.079892531791074}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\tif (target_set)\n\t\treturn;\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_EXTRA1, 10, 1);\n\t\t}\n\t\ttarget_set = true;\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_EXTRA1, 10, 1);\n\t\t}\n\t\ttarget_set = true;\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_GPS_RAW_INT:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_EXTRA1, 10, 1);\n\t\t}\n\t\ttarget_set = true;\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_GPS2_RAW:\n\t\tif (msg.sysid!= target_sysid) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\trequest_data_stream(target_sysid, MAV_DATA_STREAM_EXTRA1, 10, 1);\n\t\t}\n\t\ttarget_set = true;\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_VFR_HUD:\n\t\tif (msg", "CodeBleu_score": 38.28495828661793}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// check if message is from the target\n\tif (msg.sysid!= target_sysid) {\n\t\treturn;\n\t}\n\n\t// check if message is a supported message\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\tcase MAVLINK_MSG_ID_VFR_HUD:\n\tcase MAVLINK_MSG_ID_GPS_RAW_INT:\n\tcase MAVLINK_MSG_ID_RAW_PRESSURE:\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE:\n\tcase MAVLINK_MSG_ID_SYS_STATUS:\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\tcase MAVLINK_MSG_ID_MISSION_CURRENT:\n\tcase MAVLINK_MSG_ID_MISSION_REQUEST:\n\tcase MAVLINK_MSG_ID_MISSION_ITEM:\n\tcase MAVLINK_MSG_ID_MISSION_COUNT:\n\tcase MAVLINK_MSG_ID_MISSION_ACK:\n\tcase MAVLINK_MSG_ID_MISSION_ITEM_REACHED:\n\tcase MAVLINK_MSG_ID_MISSION_REQUEST_LIST:\n\tcase MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST:\n\tcase MAVLINK_MSG_ID_MISSION_SET_CURRENT:\n\tcase MAVLINK_MSG_ID_MISSION_CLEAR_ALL:\n\tcase MAVLINK_MSG_ID_MISSION_ITEM_INT:\n\tcase MAVLINK_MSG_ID_MISSION_REQUEST_INT:\n\tcase MAVLINK_MSG_ID_MISSION_REQUEST_LIST_INT:\n\tcase MAVLINK_MSG_ID_MISSION_ACK_INT:\n\tcase MAVLINK_MSG_ID_MISSION_ITEM_REACHED:\n\tcase MAVLINK_MSG_ID_MISSION_CURRENT:\n\tcase MAVLINK_MSG_ID_MISSION_REQUEST:\n\tcase MAVLINK_MSG_ID_MISSION_ITEM:\n\tcase MAVLINK_MSG_ID_MISSION_COUNT:\n\tcase MAVL", "CodeBleu_score": 23.95771582074872}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\tMAV_RESULT result = GCS_MAVLINK_Base::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibrate_needed = true;\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 62.65490773773378}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\tMAV_RESULT result = GCS_MAVLINK_Tracker::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 52.49508494114971}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\tMAV_RESULT result = _handle_command_preflight_calibration_base(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 46.88160932259129}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tif (packet.param1 == 1.0) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\telse if (packet.param1 == 0) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\telse {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 42.38844586686078}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tif (packet.param1 == 1.0) {\n\t\t// arm servos\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0) {\n\t\t// disarm servos\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 42.3023279179324}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tif (packet.param1 == 1.0) {\n\t\t// arm\n\t\tif (g.arming_check(true) == ARMING_CHECK_ARMABLE) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_TEMPORARILY_REJECTED;\n\t\t}\n\t} else if (packet.param1 == 0) {\n\t\t// disarm\n\t\tif (g.arming_check(false) == ARMING_CHECK_ARMABLE) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_TEMPORARILY_REJECTED;\n\t\t}\n\t} else {\n\t\t// unsupported\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 47.6152670812889}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\tfor (int i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\tif (_gcs[i]!= NULL && _gcs[i]->available_payload_space() >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN) {\n\t\t\t// request position updates at 5Hz\n\t\t\t_gcs[i]->send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, MAV_DATA_STREAM_POSITION, 5, 1);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.826041829347496}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\tfor (int i = 0; i < _num_gcs; i++) {\n\t\tif (_gcs[i]!= NULL && _gcs[i]->available_payload_space() >= MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN) {\n\t\t\t_gcs[i]->send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.89132797313901}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\tfor (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\tif (gcs[i].available()) {\n\t\t\tif (gcs[i].get_free_tx_space() > 100) {\n\t\t\t\tgcs[i].send_message(msg_request_datastream_position(sysid, compid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 39.52214999898968}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\t// Get the AHRS instance\n\tAHRS* ahrs = AHRS::getInstance();\n\n\t// Check for a zero pitch cosine to avoid division by zero\n\tif (ahrs->get_cos_pitch()!= 0) {\n\t\t// Calculate the earth frame pitch and yaw using trigonometric conversions\n\t\tef_pitch = atan2(ahrs->get_sin_pitch(), ahrs->get_cos_pitch() * ahrs->get_cos_roll());\n\t\tef_yaw = atan2(ahrs->get_sin_yaw(), ahrs->get_cos_yaw());\n\n\t\t// Return true\n\t\treturn true;\n\t}\n\n\t// Return false if the pitch cosine is zero\n\treturn false;\n}\n", "CodeBleu_score": 40.73321958896725}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\t// get AHRS instance\n\tAHRS *ahrs = AHRS::get_instance();\n\n\t// check for zero pitch cosine\n\tif (fabsf(ahrs->cos_pitch) > 0.0001f) {\n\t\t// calculate earth frame pitch and yaw\n\t\tef_pitch = atan2f(ahrs->sin_roll * sinf(pitch) + ahrs->cos_roll * ahrs->cos_pitch * cosf(yaw), ahrs->cos_roll * cosf(yaw));\n\t\tef_yaw = atan2f(-ahrs->sin_roll * cosf(pitch) + ahrs->cos_roll * ahrs->cos_pitch * sinf(yaw), ahrs->sin_pitch);\n\n\t\t// return true\n\t\treturn true;\n\t}\n\n\t// return false\n\treturn false;\n}\n", "CodeBleu_score": 50.3987323938826}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\tAHRS* ahrs = AHRS::getInstance();\n\tif (ahrs->get_pitch_cosine() == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = pitch - ahrs->get_pitch();\n\tef_yaw = yaw - ahrs->get_yaw();\n\treturn true;\n}\n", "CodeBleu_score": 43.55533133968773}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)\t// update target yaw and pitch\n\tfloat yaw_target = 0.0f;\n\tfloat pitch_target = 0.0f;\n\tfloat yaw_error = 0.0f;\n\tfloat pitch_error = 0.0f;\n\tfloat target_distance = 0.0f;\n\tfloat target_distance_error = 0.0f;\n\n\t// update yaw and pitch\n\tif (nav.get_status() == Navigation::Status::OK) {\n\t\tyaw_target = nav.get_target_yaw();\n\t\tpitch_target = nav.get_target_pitch();\n\t\ttarget_distance = nav.get_target_distance();\n\t} else {\n\t\tyaw_target = 0.0f;\n\t\tpitch_target = 0.0f;\n\t\ttarget_distance = 0.0f;\n\t}\n\n\t// check if direction is reversed\n\tif (reverse_direction) {\n\t\tyaw_target = -yaw_target;\n\t\tpitch_target = -pitch_target;\n\t}\n\n\t// compute yaw and pitch errors\n\tyaw_error = yaw_target - yaw.get_angle();\n\tpitch_error = pitch_target - pitch.get_angle();\n\n\t// convert errors from earth frame to body frame\n\tyaw_error = yaw_error + yaw.get_angle();\n\tpitch_error = pitch_error + pitch.get_angle();\n\n\t// check if target distance is valid or no minimum distance is set\n\tif (target_distance < min_distance || min_distance == 0.0f) {\n\t\t// update pitch and yaw servos\n\t\tpitch.set_target(pitch_error);\n\t\tyaw.set_target(yaw_error);\n\t} else {\n\t\t// compute distance error\n\t\ttarget_distance_error = target_distance - distance.get_distance();\n\n\t\t// update pitch and yaw servos\n\t\tpitch.set_target(pitch_error);\n\t\tyaw.set_target(yaw_error);\n\t\tdistance.set_target(target_distance_error);\n\t}\n}\n", "CodeBleu_score": 39.417657151474685}, {"code": "void Mode::update_auto(void)\tfloat yaw_angle = 0;\n\tfloat pitch_angle = 0;\n\tfloat yaw_error = 0;\n\tfloat pitch_error = 0;\n\tfloat yaw_error_body = 0;\n\tfloat pitch_error_body = 0;\n\tfloat yaw_error_body_prev = 0;\n\tfloat pitch_error_body_prev = 0;\n\tfloat yaw_error_body_diff = 0;\n\tfloat pitch_error_body_diff = 0;\n\tfloat yaw_error_body_diff_prev = 0;\n\tfloat pitch_error_body_diff_prev = 0;\n\tfloat yaw_error_body_diff_rate = 0;\n\tfloat pitch_error_body_diff_rate = 0;\n\tfloat yaw_error_body_diff_rate_prev = 0;\n\tfloat pitch_error_body_diff_rate_prev = 0;\n\tfloat yaw_error_body_diff_rate_diff = 0;\n\tfloat pitch_error_body_diff_rate_diff = 0;\n\tfloat yaw_error_body_diff_rate_diff_prev = 0;\n\tfloat pitch_error_body_diff_rate_diff_prev = 0;\n\tfloat yaw_error_body_diff_rate_diff_rate = 0;\n\tfloat pitch_error_body_diff_rate_diff_rate = 0;\n\tfloat yaw_error_body_diff_rate_diff_rate_prev = 0;\n\tfloat pitch_error_body_diff_rate_diff_rate_prev = 0;\n\tfloat yaw_error_body_diff_rate_diff_rate_diff = 0;\n\tfloat pitch_error_body_diff_rate_diff_rate_diff = 0;\n\tfloat yaw_error_body_diff_rate_diff_rate_diff_prev = 0;\n\tfloat pitch_error_body_diff_rate_diff_rate_diff_prev = 0;\n\tfloat yaw_error_body_diff_rate_diff_rate_diff_rate = 0;\n\tfloat pitch_error_body_diff_rate_diff_rate_", "CodeBleu_score": 4.803392962411565}, {"code": "void Mode::update_auto(void)\t// Update the yaw and pitch for the tracker based on navigation status and parameters\n\tif (nav_status.nav_state == NAV_STATE_TRACK) {\n\t\t// Calculate the yaw and pitch in centidegrees\n\t\tfloat yaw = nav_status.yaw;\n\t\tfloat pitch = nav_status.pitch;\n\t\t// Check if the direction is reversed\n\t\tif (nav_status.nav_direction == NAV_DIRECTION_REVERSE) {\n\t\t\tyaw += 18000.0;\n\t\t\tpitch = -pitch;\n\t\t}\n\t\t// Calculate the angle error\n\t\tfloat yaw_error = yaw - yaw_servo.get_position();\n\t\tfloat pitch_error = pitch - pitch_servo.get_position();\n\t\t// Convert the errors from earth frame to body frame\n\t\tfloat yaw_error_body = yaw_error * cosf(nav_status.roll / 100.0) - pitch_error * sinf(nav_status.roll / 100.0);\n\t\tfloat pitch_error_body = pitch_error * cosf(nav_status.roll / 100.0) + yaw_error * sinf(nav_status.roll / 100.0);\n\t\t// If the target distance is valid or no minimum distance is set\n\t\tif (nav_status.distance >= 0.0 || min_distance <= 0.0) {\n\t\t\t// Update the pitch and yaw servos accordingly\n\t\t\tpitch_servo.set_position(pitch_servo.get_position() + pitch_error_body);\n\t\t\tyaw_servo.set_position(yaw_servo.get_position() + yaw_error_body);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 39.67987163540441}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)\t// Update GPS\n\tgps.update();\n\n\t// Check if the last message time has changed and if the GPS status is at least 3D fix\n\tif (gps.last_message_time!= last_message_time && gps.status >= 3) {\n\t\t// Set the last message time to the current message time\n\t\tlast_message_time = gps.last_message_time;\n\n\t\t// Check if the ground start countdown is not at zero\n\t\tif (ground_start_countdown!= 0) {\n\t\t\t// Decrement the countdown\n\t\t\tground_start_countdown--;\n\n\t\t\t// Check if the countdown has reached zero\n\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t// Check if the current location is valid\n\t\t\t\tif (gps.location.lat!= 0 && gps.location.lng!= 0) {\n\t\t\t\t\t// Set the home location to the current location\n\t\t\t\t\thome_location.lat = gps.location.lat;\n\t\t\t\t\thome_location.lng = gps.location.lng;\n\t\t\t\t} else {\n\t\t\t\t\t// Reset the ground start countdown\n\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.883856278615475}, {"code": "void Tracker::update_GPS(void)\t// Update the GPS\n\tGPS.update();\n\n\t// If the last message time has changed\n\tif (GPS.lastMessageTime!= lastMessageTime) {\n\t\tlastMessageTime = GPS.lastMessageTime;\n\n\t\t// If the GPS status is at least 3D fix\n\t\tif (GPS.status >= 3) {\n\t\t\t// If the ground start countdown is not complete\n\t\t\tif (groundStartCountdown > 0) {\n\t\t\t\t// If the current location is valid\n\t\t\t\tif (GPS.isValid()) {\n\t\t\t\t\t// Decrement the ground start countdown\n\t\t\t\t\tgroundStartCountdown--;\n\n\t\t\t\t\t// If the ground start countdown is complete\n\t\t\t\t\tif (groundStartCountdown == 0) {\n\t\t\t\t\t\t// Set the home location\n\t\t\t\t\t\thomeLocation.latitude = GPS.latitude;\n\t\t\t\t\t\thomeLocation.longitude = GPS.longitude;\n\t\t\t\t\t\thomeLocation.altitude = GPS.altitude;\n\n\t\t\t\t\t\t// Set the home location altitude to zero\n\t\t\t\t\t\thomeLocation.altitude -= GPS.altitude;\n\n\t\t\t\t\t\t// Set the home location to the current location\n\t\t\t\t\t\tcurrentLocation.latitude = GPS.latitude;\n\t\t\t\t\t\tcurrentLocation.longitude = GPS.longitude;\n\t\t\t\t\t\tcurrentLocation.altitude = GPS.altitude;\n\n\t\t\t\t\t\t// Set the home location to the current location\n\t\t\t\t\t\tcurrentLocation.latitude = GPS.latitude;\n\t\t\t\t\t\tcurrentLocation.longitude = GPS.longitude;\n\t\t\t\t\t\tcurrentLocation.altitude = GPS.altitude;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the current location is invalid\n\t\t\t\telse {\n\t\t\t\t\t// Reset the ground start countdown\n\t\t\t\t\tgroundStartCountdown = GROUND_START_COUNTDOWN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.94188568473651}, {"code": "void Tracker::update_GPS(void)\tuint32_t tnow = millis();\n\tif (tnow - _last_GPS_time > GPS_TIMEOUT) {\n\t\t_GPS_status = 0;\n\t}\n\tif (_GPS_status >= 3) {\n\t\tif (_GPS_countdown == 0) {\n\t\t\t_GPS_countdown = 10;\n\t\t}\n\t\tif (_GPS_countdown == 1) {\n\t\t\tif (GPS.fix) {\n\t\t\t\t_home_lat = GPS.latitude;\n\t\t\t\t_home_lon = GPS.longitude;\n\t\t\t\t_home_alt = GPS.altitude;\n\t\t\t\t_home_set = true;\n\t\t\t\t_GPS_countdown = 0;\n\t\t\t} else {\n\t\t\t\t_GPS_countdown = 10;\n\t\t\t}\n\t\t}\n\t\tif (_GPS_countdown > 1) {\n\t\t\t_GPS_countdown--;\n\t\t}\n\t}\n\t_last_GPS_time = tnow;\n}\n", "CodeBleu_score": 34.21025194475318}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch > 0) {\n\t\tif (pitch > 10) {\n\t\t\tpitch = 10;\n\t\t}\n\t\tpitch_onoff_servo.write(90 - pitch);\n\t} else {\n\t\tif (pitch < -10) {\n\t\t\tpitch = -10;\n\t\t}\n\t\tpitch_onoff_servo.write(90 - pitch);\n\t}\n}\n", "CodeBleu_score": 15.919093195477696}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif(pitch > 0.0f) {\n\t\t// Pitch up, turn on\n\t\tif(pitch > 10.0f) {\n\t\t\t// Pitch up, turn on\n\t\t\tpitch_onoff_servo.write(180);\n\t\t}\n\t\telse {\n\t\t\t// Pitch up, turn off\n\t\t\tpitch_onoff_servo.write(0);\n\t\t}\n\t}\n\telse {\n\t\t// Pitch down, turn off\n\t\tpitch_onoff_servo.write(0);\n\t}\n}\n", "CodeBleu_score": 15.177706858908987}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch < 0) {\n\t\tpwmWrite(this->pitch_onoff_servo_pin, 1000);\n\t} else {\n\t\tpwmWrite(this->pitch_onoff_servo_pin, 2000);\n\t}\n}\n", "CodeBleu_score": 10.908316090240639}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}", "CodeBleu_score": 13.669417614329937}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\t// check barometer reference\n\tif (!super::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tif (g.arming_check_baro &&!barometer_alt_check(display_failure)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 18.895601580367803}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\t// run the base class's checks\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// if the ARMING_CHECK_BARO is enabled, check the barometer reference and compare the barometer altitude with the inertial navigation altitude\n\tif (g.arming_check & ARMING_CHECK_BARO) {\n\t\t// check the barometer reference\n\t\tif (!barometer_reference_valid()) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Barometer reference not valid\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check the barometer altitude\n\t\tfloat baro_alt = barometer.get_altitude();\n\t\tfloat inertial_alt = inertial_nav.get_altitude();\n\t\tfloat delta = fabsf(baro_alt - inertial_alt);\n\t\tif (delta > g.arming_baro_max_diff) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Baro alt: %.1f, Inertial alt: %.1f\"), baro_alt, inertial_alt);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if we made it here then all is well\n\treturn true;\n}\n", "CodeBleu_score": 46.10609272639565}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (g.terrain_source == TERRAIN_SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\tif (g.rtl_altitude_type == RTL_ALTITUDE_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 50.01036152671525}, {"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (g.rtl_altitude_source == RTL_ALT_SOURCE_TERRAIN && g.rtl_altitude_type == RTL_ALT_TYPE_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 42.89020437866832}, {"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (g.rtl_altitude_source == RTL_ALTITUDE_SOURCE_TERRAIN_DATABASE) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 31.01953396665168}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()\t// set loop time for rate controller\n\trate_controller_set_loop_time(scheduler.get_last_loop_time());\n\n\t// run rate controllers that only require IMU data\n\trate_controller_run();\n}\n", "CodeBleu_score": 14.53255455245889}, {"code": "void Copter::run_rate_controller()\t// set loop time for attitude, position, and motor controllers\n\t// using the last loop time from the scheduler\n\tset_loop_times();\n\n\t// run the low-level rate controllers that require only IMU data\n\tattitude_control.rate_controller_run();\n}\n", "CodeBleu_score": 13.927088314363093}, {"code": "void Copter::run_rate_controller()\t// set the loop time for the rate controllers\n\trate_controller_set_loop_time(loop_time);\n\t// run the rate controllers\n\trate_controller_run();\n}\n", "CodeBleu_score": 11.179582760133291}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\t// Check if we have a new waypoint\n\tif (new_loc == old_loc) {\n\t\t// No new waypoint\n\t\treturn false;\n\t}\n\n\t// Check if the altitude frame is the same\n\tif (new_loc.alt_frame()!= old_loc.alt_frame()) {\n\t\t// Altitude frame changed\n\t\treturn false;\n\t}\n\n\t// Set the new target\n\t_target_location = new_loc;\n\n\treturn true;\n}\n", "CodeBleu_score": 47.99756903120683}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\t// check if the old location matches the next waypoint\n\tif (old_loc.lat == _mission.get_next_item().lat && old_loc.lng == _mission.get_next_item().lng) {\n\t\t// check if the altitude frames are the same\n\t\tif (old_loc.alt_frame == new_loc.alt_frame) {\n\t\t\t// set the new location as the target\n\t\t\t_target_loc = new_loc;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 49.2712816328867}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng) {\n\t\t// no change in location\n\t\treturn false;\n\t}\n\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\t// different altitude frames\n\t\treturn false;\n\t}\n\n\t// set new target\n\t_target_location = new_loc;\n\n\treturn true;\n}\n", "CodeBleu_score": 41.994736541926855}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\t// If the switch is in the HIGH position, attempt to set the mode\n\tif (ch_flag == AUX_HIGH) {\n\t\t// If the mode is not already set, attempt to set it\n\t\tif (mode!= get_mode()) {\n\t\t\tset_mode(mode);\n\t\t}\n\t}\n\t// If the switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n\telse if (mode == get_mode()) {\n\t\trc().reset_mode_switch();\n\t}\n}\n", "CodeBleu_score": 52.81839688103588}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (aux_switch_pos == ch_flag) {\n\t\tif (mode == get_mode()) {\n\t\t\trc().reset_mode_switch();\n\t\t} else {\n\t\t\tset_mode(mode);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.26649720915101}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (aux_switch_pos == ch_flag) {\n\t\tif (mode == get_mode()) {\n\t\t\t// We are in the correct mode, reset the mode switch\n\t\t\trc().reset_mode_switch();\n\t\t} else {\n\t\t\t// We are not in the correct mode, set it\n\t\t\tset_mode(mode);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.26649720915101}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()\t// save the roll and pitch trim values\n\t// this function is called from the GCS\n\t// the trim values are saved in the AHRS trim\n\t// the trim values are calculated from the control inputs of the roll and pitch channels\n\t// the trim values are converted to radians\n\t// the trim values are added to the AHRS trim\n\t// the event is logged\n\t// the confirmation message is sent\n\t// if the trim values are saved successfully, the confirmation message is sent with MAV_SEVERITY_INFO\n\t// if the trim values are not saved successfully, the confirmation message is sent with MAV_SEVERITY_CRITICAL\n\n\t// calculate the trim values from the control inputs of the roll and pitch channels\n\tfloat trim_roll = _roll_input_channel.get_control_in() * DEG_TO_RAD;\n\tfloat trim_pitch = _pitch_input_channel.get_control_in() * DEG_TO_RAD;\n\n\t// convert the trim values to radians\n\ttrim_roll *= DEG_TO_RAD;\n\ttrim_pitch *= DEG_TO_RAD;\n\n\t// add the trim values to the AHRS trim\n\tahrs.set_trim(trim_roll, trim_pitch, 0);\n\n\t// log the event\n\tLog_Write_Event(DATA_TRIM_SAVE, trim_roll, trim_pitch);\n\n\t// send a confirmation message with MAV_SEVERITY_INFO\n\tsend_message(MSG_TRIM_SAVED);\n}\n", "CodeBleu_score": 40.746879863378766}, {"code": "void Copter::save_trim()\t// save the current trim values\n\t_ahrs.set_trim(roll_trim_cd, pitch_trim_cd);\n\n\t// log the event\n\tLog_Write_Event(DATA_TRIM_SAVE);\n\n\t// send a confirmation message\n\tgcs_send_text_P(MAV_SEVERITY_INFO, PSTR(\"Trim saved\"));\n}\n", "CodeBleu_score": 14.758195892630205}, {"code": "void Copter::save_trim()\t// check if we are in a mode that allows us to save trim\n\tif (control_mode == MANUAL || control_mode == STABILIZE || control_mode == ACRO) {\n\t\t// save roll trim\n\t\tfloat roll_trim_value = (g.rc_1.control_in - g.rc_1.radio_trim) / g.rc_1.radio_max;\n\t\tahrs.set_roll_trim(roll_trim_value);\n\t\t// save pitch trim\n\t\tfloat pitch_trim_value = (g.rc_2.control_in - g.rc_2.radio_trim) / g.rc_2.radio_max;\n\t\tahrs.set_pitch_trim(pitch_trim_value);\n\t\t// log event\n\t\tLog_Write_Event(DATA_TRIM_SAVE);\n\t\t// send confirmation message\n\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Trim saved\"));\n\t}\n}\n", "CodeBleu_score": 39.46133592593276}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()\tfloat yaw = 0;\n\tfloat vel_sq = 0;\n\n\tif (m_pos_valid) {\n\t\tvel_sq = _vel_est.vel_xy_d.length_squared();\n\t}\n\n\tif (vel_sq > 1.0f) {\n\t\tyaw = math::constrain(math::atan2(_vel_est.vel_xy_d.y, _vel_est.vel_xy_d.x), -M_PI_2, M_PI_2);\n\t}\n\n\treturn yaw;\n}\n", "CodeBleu_score": 33.844598072150944}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\t// calculate the speed squared\n\tfloat speed_squared = _velocity.length_squared();\n\n\t// if the position is valid and the speed is above the minimum threshold, update the look-ahead yaw angle\n\tif (_position.is_valid() && speed_squared > sq(LOOK_AHEAD_MIN_SPEED)) {\n\t\t_look_ahead_yaw = atan2f(_velocity.y, _velocity.x);\n\t}\n\n\t// return the computed look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}\n", "CodeBleu_score": 37.35283798665202}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\t// get velocity\n\tVector3f vel = _v_control_mode.get_velocity();\n\t// calculate speed squared\n\tfloat vel_sq = vel.length_squared();\n\n\t// if position is valid and speed is above minimum threshold\n\tif (_position_ok && vel_sq > sq(0.1f)) {\n\t\t// update look-ahead yaw angle\n\t\t_look_ahead_yaw = atan2f(vel.y, vel.x);\n\t}\n\n\treturn _look_ahead_yaw;\n}\n", "CodeBleu_score": 40.95609969748808}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (method == AP_Arming::RUDDER) {\n\t\tif (rudder_arming_disabled || _throttle_zero) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::WATCHDOG || _watchdog_armed) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 34.02182683026627}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (method == AP_Arming::RUDDER) {\n\t\t// rudder arming disabled\n\t\tif (g.arming_check == ARMING_CHECK_RUDDER_DISABLED) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// rudder arming enabled, check throttle\n\t\tif (g.arming_check == ARMING_CHECK_RUDDER_ENABLED) {\n\t\t\tif (ap.throttle_zero()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// watchdog arming disabled\n\tif (g.arming_check == ARMING_CHECK_WATCHDOG_DISABLED) {\n\t\treturn true;\n\t}\n\n\t// watchdog arming enabled, check watchdog\n\tif (g.arming_check == ARMING_CHECK_WATCHDOG_ENABLED) {\n\t\tif (ap.watchdog_armed()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// perform standard arming checks\n\treturn AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 51.121286268572554}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (method == AP_Arming::RUDDER) {\n\t\tif (g.arming_check & ARMING_CHECK_RUDDER) {\n\t\t\tif (channel_throttle->get_control_in() > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (method == AP_Arming::WATCHDOG) {\n\t\tif (g.arming_check & ARMING_CHECK_WATCHDOG) {\n\t\t\tif (watchdog_armed) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 46.58355703293975}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\t// if we are already armed, do nothing\n\tif (arming_state == ARMED) {\n\t\treturn false;\n\t}\n\n\t// if we are in pre-arm checks, do nothing\n\tif (arming_state == PRE_ARMED) {\n\t\treturn false;\n\t}\n\n\t// if we are not in pre-arm checks, do nothing\n\tif (arming_state!= PRE_ARM) {\n\t\treturn false;\n\t}\n\n\t// if we are not in a state to arm, do nothing\n\tif (method!= AP_Arming::Method::ARM_SWITCH && method!= AP_Arming::Method::RC_ARM) {\n\t\treturn false;\n\t}\n\n\t// if we are in a state to arm, do nothing\n\tif (method == AP_Arming::Method::ARM_SWITCH &&!g.arming_check) {\n\t\treturn false;\n\t}\n\n\t// if we are in a state to arm, do nothing\n\tif (method == AP_Arming::Method::RC_ARM &&!g.rc_arm) {\n\t\treturn false;\n\t}\n\n\t// if we are in a state to arm, do nothing\n\tif (method == AP_Arming::Method::RC_ARM &&!g.rc_arm_override) {\n\t\treturn false;\n\t}\n\n\t// if we are in a state to arm, do nothing\n\tif (method == AP_Arming::Method::RC_ARM &&!g.rc_arm_hysteresis) {\n\t\treturn false;\n\t}\n\n\t// if we are in a state to arm, do nothing\n\tif (method == AP_Arming::Method::RC_ARM &&!g.rc_arm_extreme) {\n\t\treturn false;\n\t}\n\n\t// if we are in a state to arm, do nothing\n\tif (method == AP_Arming::Method::RC_ARM &&!g.rc_arm_extreme_hysteresis) {\n\t\treturn false;\n\t}\n\n\t// if we are in a state to arm, do nothing\n\tif (method == AP_Arming::Method::RC_ARM &&!g.rc_arm_extreme_extreme) {\n\t\treturn false;\n", "CodeBleu_score": 42.21677012776504}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\tbool success;\n\tbool armed_status_changed = false;\n\n\t// check if we are already armed\n\tif (_armed.armed) {\n\t\t// already armed\n\t\treturn false;\n\t}\n\n\t// do arming checks\n\tif (do_arming_checks) {\n\t\tif (!do_arming_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// check if we are allowed to arm\n\tif (_arming_checks.get_state() == AP_ArmingChecks::ARMING_CHECK_FAILED) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_checks.is_mode_allowed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows us to arm\n\tif (!_arming_", "CodeBleu_score": 30.290363963837663}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\t// check if already armed\n\tif (armed.armed) {\n\t\t// already armed\n\t\treturn false;\n\t}\n\n\t// run arming checks if required\n\tif (do_arming_checks) {\n\t\tif (!arming_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// set home location\n\tg.home.set_and_save();\n\n\t// update current location\n\tg.home.set_position(g.location);\n\n\t// set armed state\n\tarmed.armed = true;\n\n\t// set delay arming flag\n\tarmed.delay_arming = true;\n\n\t// send status text\n\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"THR armed\"));\n\n\t// return success\n\treturn true;\n}\n", "CodeBleu_score": 46.43814616863475}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\tif (_parent->armed.get()) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\tif (disarm_button_enabled()) {\n\t\t// disarm button enabled, do standard pre-arm checks\n\t\treturn _parent->pre_arm_checks(display_failure);\n\t}\n\n\tif (display_failure) {\n\t\t// disarm button not enabled, display failure message\n\t\t_parent->notify->printf(\"Disarm button not enabled\");\n\t}\n\n\t// disarm button not enabled, return failure\n\treturn false;\n}\n", "CodeBleu_score": 55.827572551550645}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\t// if we are already armed, return true\n\tif (_armed.armed) {\n\t\treturn true;\n\t}\n\n\t// if we have no disarm button configured, we can't disarm\n\tif (_disarm_button_pin == -1) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_failure = true;\n\t\t\tAP_Notify::flags.arming_failure_flags |= AP_Notify::ARMING_FAILURE_DISARM_BUTTON;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// perform the standard pre-arm checks\n\treturn _super.pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 53.64257984091807}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\t// if already armed, just return\n\tif (ap.armed.armed) {\n\t\treturn true;\n\t}\n\n\t// if we have a disarm button, do the standard pre-arm checks\n\tif (disarm_button_enabled()) {\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\n\t// if we don't have a disarm button, return true\n\treturn true;\n}\n", "CodeBleu_score": 50.09012416869747}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat yaw = ahrs.getYaw();\n\tfloat ne_x = x * cos(yaw) - y * sin(yaw);\n\tfloat ne_y = x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 62.12598398339072}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat ne_x = x*cos(ahrs->yaw) + y*sin(ahrs->yaw);\n\tfloat ne_y = -x*sin(ahrs->yaw) + y*cos(ahrs->yaw);\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 56.352286572856045}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat yaw = ahrs->getYaw();\n\tfloat ne_x = x * cos(yaw) - y * sin(yaw);\n\tfloat ne_y = x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 61.93556142758519}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// Check if the yaw angle and param4 values are within acceptable ranges\n\tif (packet.param1 >= -180 && packet.param1 <= 180 && packet.param4 >= -180 && packet.param4 <= 180) {\n\t\t// Set the yaw heading using the provided parameters\n\t\t// TODO: Implement the yaw heading adjustment\n\t\t// Return MAV_RESULT_ACCEPTED to indicate that the command was successfully processed\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\t// Return MAV_RESULT_DENIED to indicate that the command was not processed due to invalid parameters\n\t\treturn MAV_RESULT_DENIED;\n\t}\n}\n", "CodeBleu_score": 38.199060208607136}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// Check if the yaw angle is within acceptable range\n\tif (packet.param1 < -180 || packet.param1 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the param4 value is within acceptable range\n\tif (packet.param4 < -180 || packet.param4 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters\n\tyaw_heading = packet.param1;\n\tyaw_heading_relative = packet.param4;\n\n\t// Return MAV_RESULT_ACCEPTED\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 46.37869600901102}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// yaw angle\n\tfloat yaw_angle = packet.param1;\n\t// yaw angle speed\n\tfloat yaw_speed = packet.param2;\n\t// direction\n\tint direction = packet.param3;\n\t// relative\n\tint relative = packet.param4;\n\n\t// check if yaw angle is within acceptable range\n\tif (yaw_angle < -180.0f || yaw_angle > 180.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if yaw speed is within acceptable range\n\tif (yaw_speed < 0.0f || yaw_speed > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if direction is within acceptable range\n\tif (direction < 0 || direction > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if relative is within acceptable range\n\tif (relative < 0 || relative > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set yaw heading using provided parameters\n\t// TODO: Implement yaw heading adjustment using the provided parameters\n\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 34.71145444450838}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn _high_latency_tgt_heading;\n}\n", "CodeBleu_score": 5.801350011259761}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn _high_latency_tgt_heading;\n}\n", "CodeBleu_score": 5.801350011259761}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn high_latency_tgt_heading_;\n}\n", "CodeBleu_score": 5.809873968526187}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.time = Sub::Get_Time();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tLog_Write_Packet(packet);\n\t}\n}\n", "CodeBleu_score": 36.9875244608863}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tLog_Write_Packet(packet);\n\t}\n}\n", "CodeBleu_score": 34.79306428936547}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.time = Get_Time();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tLog_Write_Packet(packet);\n\t}\n}\n", "CodeBleu_score": 36.1498584717882}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (motors_armed) {\n\t\tset_home_to_current_location();\n\t} else {\n\t\tset_home_to_current_location(true);\n\t}\n}\n", "CodeBleu_score": 25.222782754091295}, {"code": "void Sub::update_home_from_EKF()\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (motors_armed) {\n\t\tset_home_to_current_location();\n\t} else {\n\t\tset_home_to_current_location_no_arm();\n\t}\n}\n", "CodeBleu_score": 25.45137910716326}, {"code": "void Sub::update_home_from_EKF()\tif (this->home_set) {\n\t\treturn;\n\t}\n\n\tif (this->motors_armed) {\n\t\tthis->set_home_to_current_location();\n\t} else {\n\t\tthis->set_home_to_current_location_no_arm();\n\t}\n}\n", "CodeBleu_score": 22.015926681799897}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()\t// If motors are not armed, set throttle to zero, relax attitude controllers, and exit\n\tif (!motors_armed) {\n\t\tset_throttle(0);\n\t\trelax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t// Set spool state to unlimited throttle\n\tset_spool_state(SPOOL_UNLIMITED_THROTTLE);\n\n\t// Convert pilot inputs to desired body frame rates\n\tfloat roll_rate_desired = 0;\n\tfloat pitch_rate_desired = 0;\n\tfloat yaw_rate_desired = 0;\n\tif (pilot_roll_input!= 0) {\n\t\troll_rate_desired = pilot_roll_input * (float)PI / 180.0f;\n\t}\n\tif (pilot_pitch_input!= 0) {\n\t\tpitch_rate_desired = pilot_pitch_input * (float)PI / 180.0f;\n\t}\n\tif (pilot_yaw_input!= 0) {\n\t\tyaw_rate_desired = pilot_yaw_input * (float)PI / 180.0f;\n\t}\n\n\t// Run attitude controller\n\trun_attitude_controller(roll_rate_desired, pitch_rate_desired, yaw_rate_desired);\n\n\t// Output pilot's throttle input without angle boost and set forward and lateral motor inputs based on pilot controls\n\tset_throttle(pilot_throttle_input);\n\tset_forward_motor_input(pilot_throttle_input);\n\tset_lateral_motor_input(pilot_throttle_input);\n}\n", "CodeBleu_score": 34.82376038590146}, {"code": "void ModeAcro::run()\tif (motors->armed()) {\n\t\tspool->setState(Spool::State::UNLIMITED);\n\t\tif (input->getThrottle() > 0.0f) {\n\t\t\t// Convert pilot inputs to desired body frame rates\n\t\t\tfloat rollRate = input->getRoll() * 0.5f;\n\t\t\tfloat pitchRate = input->getPitch() * 0.5f;\n\t\t\tfloat yawRate = input->getYaw() * 0.5f;\n\t\t\t// Run the attitude controller with these rates\n\t\t\tattitude->setDesiredBodyFrameRates(rollRate, pitchRate, yawRate);\n\t\t\tattitude->run();\n\t\t\t// Output the pilot's throttle input without angle boost\n\t\t\tmotors->setThrottle(input->getThrottle());\n\t\t\t// Set the forward and lateral motor inputs based on pilot controls\n\t\t\tfloat forward = input->getForward();\n\t\t\tfloat lateral = input->getLateral();\n\t\t\tmotors->setForward(forward);\n\t\t\tmotors->setLateral(lateral);\n\t\t} else {\n\t\t\t// Relax the attitude controllers\n\t\t\tattitude->relax();\n\t\t\t// Output the pilot's throttle input without angle boost\n\t\t\tmotors->setThrottle(0.0f);\n\t\t\t// Set the forward and lateral motor inputs to zero\n\t\t\tmotors->setForward(0.0f);\n\t\t\tmotors->setLateral(0.0f);\n\t\t}\n\t} else {\n\t\t// Relax the attitude controllers\n\t\tattitude->relax();\n\t\t// Set the throttle to zero\n\t\tmotors->setThrottle(0.0f);\n\t\t// Set the forward and lateral motor inputs to zero\n\t\tmotors->setForward(0.0f);\n\t\tmotors->setLateral(0.0f);\n\t\t// Adjust the spool state\n\t\tspool->adjust();\n\t}\n}", "CodeBleu_score": 47.12376992333711}, {"code": "void ModeAcro::run()\tif (!motors_armed) {\n\t\t// Motors not armed.\n\t\t// Set throttle to zero and exit.\n\t\tthrottle_out = 0;\n\t\treturn;\n\t}\n\n\t// Motors are armed.\n\t// Set spool state to unlimited throttle.\n\tset_spool_state(SPOOL_UNLIMITED);\n\n\t// Convert pilot inputs to desired body frame rates.\n\tfloat roll_rate_desired = pilot_roll_input * MAX_ROLL_RATE;\n\tfloat pitch_rate_desired = pilot_pitch_input * MAX_PITCH_RATE;\n\tfloat yaw_rate_desired = pilot_yaw_input * MAX_YAW_RATE;\n\n\t// Run the attitude controller with these rates.\n\tattitude_controller.run(roll_rate_desired, pitch_rate_desired, yaw_rate_desired);\n\n\t// Output the pilot's throttle input without angle boost.\n\tthrottle_out = pilot_throttle_input;\n\n\t// Set the forward and lateral motor inputs based on pilot controls.\n\tif (pilot_throttle_input < 0.1) {\n\t\t// Throttle input is low.\n\t\t// Set forward and lateral motor inputs to zero.\n\t\tforward_motor_input = 0;\n\t\tlateral_motor_input = 0;\n\t} else {\n\t\t// Throttle input is high.\n\t\t// Set forward motor input based on pilot's pitch input.\n\t\tforward_motor_input = pilot_pitch_input;\n\n\t\t// Set lateral motor input based on pilot's roll input.\n\t\tlateral_motor_input = pilot_roll_input;\n\t}\n}\n", "CodeBleu_score": 34.00605255052419}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()\t// Set the mode to position control\n\tset_mode(MODE_POSCTL);\n\n\t// Initialize the waypoint controller\n\t_waypoint_controller.init();\n\n\t// Set the stopping point as the waypoint destination\n\t_waypoint_controller.set_destination(_stopping_point);\n\n\t// Initialize the yaw using the default auto yaw mode\n\t_yaw_mode = _param_mpc_yaw_mode.get();\n\t_yaw_sp = _stopping_point.yaw();\n}\n", "CodeBleu_score": 30.872127465105205}, {"code": "void ModeGuided::guided_pos_control_start()\t// Set to position control mode\n\t_pos_control_mode = PosControlMode::POS_CONTROL_MODE_POS_YAW;\n\n\t// Initialize the waypoint controller\n\t_waypoint_controller.initialize_takeoff(get_global_position(), get_global_velocity(), get_home_position(), get_home_velocity(), get_home_yaw(), get_home_yaw_rate());\n\n\t// Set the stopping point as the waypoint destination\n\t_waypoint_controller.set_destination(get_global_position(), get_global_velocity(), get_home_yaw(), get_home_yaw_rate());\n\n\t// Initialize the yaw using the default auto yaw mode\n\t_yaw_controller.reset(get_global_position(), get_global_velocity(), get_home_yaw(), get_home_yaw_rate());\n}\n", "CodeBleu_score": 27.762981933532593}, {"code": "void ModeGuided::guided_pos_control_start()\t// set to position control mode\n\tset_mode(MODE_POSCTL);\n\n\t// initialize waypoint controller\n\t_wp_controller.init();\n\n\t// set stopping point as waypoint destination\n\t_stopping_point.valid = true;\n\t_stopping_point.yaw = _stopping_point.yaw_valid = true;\n\t_stopping_point.yaw_body = _stopping_point.yaw;\n\t_stopping_point.yaw_valid = true;\n\t_stopping_point.yaw_body_valid = true;\n\t_stopping_point.loiter_radius = 0.0f;\n\t_stopping_point.acceptance_radius = 0.0f;\n\t_stopping_point.pos_valid = true;\n\t_stopping_point.type = Waypoint::WP_STOPPING;\n\t_stopping_point.pos = _stopping_point_local;\n\t_stopping_point.time_inside = 0.0f;\n\t_stopping_point.time_inside_valid = true;\n\t_stopping_point.nav_cmd = NAV_CMD_NONE;\n\t_stopping_point.nav_cmd_valid = true;\n\t_stopping_point.velocity_valid = false;\n\t_stopping_point.velocity = Vector3f(0.0f, 0.0f, 0.0f);\n\t_stopping_point.acceleration_valid = false;\n\t_stopping_point.acceleration = Vector3f(0.0f, 0.0f, 0.0f);\n\t_stopping_point.jerk_valid = false;\n\t_stopping_point.jerk = Vector3f(0.0f, 0.0f, 0.0f);\n\t_stopping_point.yaw_speed_valid = false;\n\t_stopping_point.yaw_speed = 0.0f;\n\t_stopping_point.takeoff_heading_valid = false;\n\t_stopping_point.takeoff_heading = 0.0f;\n\t_stopping_point.acceptance_radius_valid = false;\n\t_stopping_point.acceptance_radius = 0.0f;\n\t_stopping_point.cruising_speed_valid", "CodeBleu_score": 35.714215357252385}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()\t// initialize vertical speed controller\n\tvel_controller_z.init(z_vel_max, z_vel_max_up, z_vel_max_down, z_vel_accel_up, z_vel_accel_down, 0.0f);\n\n\t// initialize horizontal speed controller\n\tvel_controller_xy.init(xy_vel_max, xy_vel_max, xy_vel_accel, xy_vel_accel);\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tyaw_control_mode = AUTO_YAW_HOLD;\n}\n", "CodeBleu_score": 26.02044704759233}, {"code": "void ModeGuided::guided_vel_control_start()\t// Set vertical speed limits\n\tif (mode_sub.get_param_float(\"VEL_UP_MAX\", &_vel_up_max) == false) {\n\t\t_vel_up_max = 1.0f;\n\t}\n\tif (mode_sub.get_param_float(\"VEL_DOWN_MAX\", &_vel_down_max) == false) {\n\t\t_vel_down_max = 1.0f;\n\t}\n\tif (mode_sub.get_param_float(\"VEL_UP_ACC\", &_vel_up_acc) == false) {\n\t\t_vel_up_acc = 1.0f;\n\t}\n\tif (mode_sub.get_param_float(\"VEL_DOWN_ACC\", &_vel_down_acc) == false) {\n\t\t_vel_down_acc = 1.0f;\n\t}\n\n\t// Initialize vertical velocity controller\n\t_vel_controller_v.set_max_speed(_vel_up_max);\n\t_vel_controller_v.set_max_acceleration(_vel_up_acc);\n\t_vel_controller_v.set_min_speed(-_vel_down_max);\n\t_vel_controller_v.set_min_acceleration(-_vel_down_acc);\n\t_vel_controller_v.set_integral_zone(0.0f);\n\t_vel_controller_v.reset_I();\n\n\t// Initialize horizontal velocity controller\n\t_vel_controller_h.set_max_speed(1.0f);\n\t_vel_controller_h.set_max_acceleration(1.0f);\n\t_vel_controller_h.set_min_speed(-1.0f);\n\t_vel_controller_h.set_min_acceleration(-1.0f);\n\t_vel_controller_h.set_integral_zone(0.0f);\n\t_vel_controller_h.reset_I();\n\n\t// Set yaw control mode to AUTO_YAW_HOLD\n\t_yaw_control_mode = AUTO_YAW_HOLD;\n}\n", "CodeBleu_score": 40.378832677936}, {"code": "void ModeGuided::guided_vel_control_start()\t// set vertical speed limits\n\tfloat max_climb_rate = _params.guided_vel_z_max_up;\n\tfloat max_sink_rate = _params.guided_vel_z_max_down;\n\tfloat max_climb_rate_auto = _params.guided_vel_z_max_up_auto;\n\tfloat max_sink_rate_auto = _params.guided_vel_z_max_down_auto;\n\n\t// set vertical acceleration limits\n\tfloat max_climb_accel = _params.guided_vel_z_accel_up;\n\tfloat max_sink_accel = _params.guided_vel_z_accel_down;\n\tfloat max_climb_accel_auto = _params.guided_vel_z_accel_up_auto;\n\tfloat max_sink_accel_auto = _params.guided_vel_z_accel_down_auto;\n\n\t// initialize vertical velocity controller\n\t_vel_controller_z.set_max_climb_rate(max_climb_rate);\n\t_vel_controller_z.set_max_sink_rate(max_sink_rate);\n\t_vel_controller_z.set_max_climb_rate_auto(max_climb_rate_auto);\n\t_vel_controller_z.set_max_sink_rate_auto(max_sink_rate_auto);\n\t_vel_controller_z.set_max_climb_accel(max_climb_accel);\n\t_vel_controller_z.set_max_sink_accel(max_sink_accel);\n\t_vel_controller_z.set_max_climb_accel_auto(max_climb_accel_auto);\n\t_vel_controller_z.set_max_sink_accel_auto(max_sink_accel_auto);\n\t_vel_controller_z.set_auto_mode(false);\n\t_vel_controller_z.set_auto_throttle_out(0.0f);\n\t_vel_controller_z.set_auto_throttle_slew_rate(0.0f);\n\n\t// initialize horizontal velocity controller\n\t_vel_controller_xy.", "CodeBleu_score": 32.86877486223905}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()\tbool ret = false;\n\tif (guided_start_time == 0) {\n\t\tguided_start_time = AP_HAL::millis();\n\t}\n\tif (guided_start_time + guided_timeout < AP_HAL::millis()) {\n\t\t// timeout\n\t\tret = true;\n\t}\n\tif (guided_min_altitude!= 0 && guided_min_altitude > current_loc.alt) {\n\t\t// minimum altitude\n\t\tret = true;\n\t}\n\tif (guided_max_altitude!= 0 && guided_max_altitude < current_loc.alt) {\n\t\t// maximum altitude\n\t\tret = true;\n\t}\n\tif (guided_max_distance!= 0 && guided_max_distance < get_distance(guided_start_loc, current_loc)) {\n\t\t// maximum distance\n\t\tret = true;\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 34.55369918965914}, {"code": "bool ModeGuided::guided_limit_check()\tbool result = false;\n\tif (millis() > guided_timeout) {\n\t\tresult = true;\n\t}\n\tif (guided_alt_min!= 0 && guided_alt_min > current_loc.alt) {\n\t\tresult = true;\n\t}\n\tif (guided_alt_max!= 0 && guided_alt_max < current_loc.alt) {\n\t\tresult = true;\n\t}\n\tif (guided_distance_max!= 0 && guided_distance_max < get_distance(current_loc, guided_wp_loc)) {\n\t\tresult = true;\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 30.1607565109386}, {"code": "bool ModeGuided::guided_limit_check()\t// Check timeout\n\tif (millis() - _guided_start_time > _guided_timeout) {\n\t\t// Timeout\n\t\treturn true;\n\t}\n\n\t// Check altitude\n\tif (_guided_altitude_limit_enabled) {\n\t\tif (_guided_altitude_limit_min && _current_loc.alt < _guided_altitude_limit_min) {\n\t\t\t// Below minimum altitude\n\t\t\treturn true;\n\t\t}\n\t\tif (_guided_altitude_limit_max && _current_loc.alt > _guided_altitude_limit_max) {\n\t\t\t// Above maximum altitude\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Check distance moved\n\tif (_guided_distance_limit_enabled && _guided_distance_moved > _guided_distance_limit) {\n\t\t// Distance moved exceeds limit\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 33.3233967995577}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()\tif (motor_test_request_received_ && (ros::Time::now() - motor_test_request_received_time_).toSec() < 2) {\n\t\treturn true;\n\t} else {\n\t\tmotor_test_request_received_ = false;\n\t\tmotor_test_timeout_ = true;\n\t\tmotor_test_pass_ = false;\n\t\tmotor_test_ = false;\n\t\tarming_state_ = false;\n\t\tfailure_time_ = ros::Time::now();\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 37.88437640147813}, {"code": "bool Sub::verify_motor_test()\tif (motor_test_timeout_flag) {\n\t\tmotor_test_timeout_flag = false;\n\t\tmotor_test_timeout_timer.stop();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tmotor_test_timeout_", "CodeBleu_score": 23.880995447808168}, {"code": "bool Sub::verify_motor_test()\t// Check if motor test requests are received at least every 2 Hz\n\tif (motor_test_requests_received < 2) {\n\t\t// Timeout\n\t\tsend_timeout_msg(MOTOR_TEST_TIMEOUT);\n\t\tpass = false;\n\t\tdisable_motor_test();\n\t\tdisarm();\n\t\trecord_failure_time();\n\t\treturn false;\n\t} else {\n\t\t// Passed\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 18.887733589747548}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target = wp_nav.roll_target;\n\tfloat pitch_target = wp_nav.pitch_target;\n\n\t// constrain roll and pitch targets to max angles\n\troll_target = constrain_float(roll_target, -max_angle, max_angle);\n\tpitch_target = constrain_float(pitch_target, -max_angle, max_angle);\n\n\t// normalize roll and pitch targets\n\troll_target = roll_target / max_angle;\n\tpitch_target = pitch_target / max_angle;\n\n\t// assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}\n", "CodeBleu_score": 42.24593525741364}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target = wp_nav.roll;\n\tfloat pitch_target = wp_nav.pitch;\n\tfloat roll_max = 1000;\n\tfloat pitch_max = 1000;\n\tfloat roll_min = -1000;\n\tfloat pitch_min = -1000;\n\tfloat roll_range = roll_max - roll_min;\n\tfloat pitch_range = pitch_max - pitch_min;\n\tfloat roll_normalized = (roll_target - roll_min) / roll_range;\n\tfloat pitch_normalized = (pitch_target - pitch_min) / pitch_range;\n\tfloat roll_out = roll_normalized * 2 - 1;\n\tfloat pitch_out = pitch_normalized * 2 - 1;\n\tlateral_out = roll_out;\n\tforward_out = pitch_out;\n}\n", "CodeBleu_score": 29.522043150795163}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target_cd = 0.0;\n\tfloat pitch_target_cd = 0.0;\n\tfloat roll_target = 0.0;\n\tfloat pitch_target = 0.0;\n\n\troll_target_cd = wp_nav.roll_target_cd;\n\tpitch_target_cd = wp_nav.pitch_target_cd;\n\n\t// Constrain roll and pitch targets to a maximum angle range\n\tif (roll_target_cd > roll_max_cd) {\n\t\troll_target_cd = roll_max_cd;\n\t} else if (roll_target_cd < -roll_max_cd) {\n\t\troll_target_cd = -roll_max_cd;\n\t}\n\tif (pitch_target_cd > pitch_max_cd) {\n\t\tpitch_target_cd = pitch_max_cd;\n\t} else if (pitch_target_cd < -pitch_max_cd) {\n\t\tpitch_target_cd = -pitch_max_cd;\n\t}\n\n\t// Normalize roll and pitch targets to a range of -1 to 1\n\troll_target = (float) roll_target_cd / roll_max_cd;\n\tpitch_target = (float) pitch_target_cd / pitch_max_cd;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}\n", "CodeBleu_score": 34.914563215940106}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()\t// Read barometer data\n\tif (barometer.read()) {\n\t\t// Update barometer calibration if altitude is above zero\n\t\tif (barometer.get_altitude() > 0) {\n\t\t\t// Update barometer calibration\n\t\t\tbarometer.calibrate();\n\t\t\t// Update barometer calibration flag\n\t\t\tbarometer_calibrated = true;\n\t\t}\n\t\t// Update barometer health\n\t\tif (depth_sensor_present) {\n\t\t\tif (barometer.get_health() == 0) {\n\t\t\t\tbarometer_healthy = true;\n\t\t\t} else {\n\t\t\t\tbarometer_healthy = false;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 53.0780262326932}, {"code": "void Sub::read_barometer()\t// Read the barometer\n\tif (baro->read()) {\n\t\t// Update the barometer calibration if the altitude is above zero\n\t\tif (baro->get_altitude() > 0) {\n\t\t\tbaro_calibration = baro->get_altitude();\n\t\t}\n\n\t\t// Update the depth sensor health status\n\t\tif (depth_sensor_present) {\n\t\t\tif (baro->get_health() == 0) {\n\t\t\t\tdepth_sensor_health = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdepth_sensor_health = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 52.07782937443054}, {"code": "void Sub::read_barometer()\tif (barometer_present) {\n\t\tbarometer_data = barometer.read();\n\t\tif (barometer_data.altitude > 0) {\n\t\t\tbarometer_calibration_data = barometer.read_calibration();\n\t\t}\n\t\tif (depth_sensor_present) {\n\t\t\tif (barometer_data.health == 1) {\n\t\t\t\tdepth_sensor_health = 1;\n\t\t\t} else {\n\t\t\t\tdepth_sensor_health = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.35808572343818}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()\tbool ret = false;\n\n\tif (ekf_position_valid()) {\n\t\tif (motors_armed()) {\n\t\t\tif (ekf_in_constant_position_mode() == false) {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ekf_in_constant_position_mode() == false) {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 28.357554614881646}, {"code": "bool Sub::ekf_position_ok()\t// check if EKF position is valid\n\tif (!ekf_position_valid()) {\n\t\treturn false;\n\t}\n\n\t// if motors are disarmed, accept predicted horizontal position\n\tif (!motors_armed()) {\n\t\treturn true;\n\t}\n\n\t// if motors are armed, require good absolute position and ensure EKF is not in constant position mode\n\tif (ekf_abs_pos_valid() &&!ekf_const_pos_mode()) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 14.747156679492127}, {"code": "bool Sub::ekf_position_ok()\tif (!ekf_position_valid()) {\n\t\treturn false;\n\t}\n\tif (motors_armed()) {\n\t\tif (!ekf_abs_pos_valid()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ekf_const_pos_mode()) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (ekf_pred_hor_pos_valid()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 14.610034213500755}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tbool result = AP_Arming::gps_checks(display_failure);\n\tif (!result) {\n\t\treturn false;\n\t}\n\n\t// check if AHRS is ready\n\tif (!_ahrs->healthy()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_gps_ahrs_check_failed = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (_ahrs->ekf_failsafe_active()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_gps_ekf_check_failed = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if position estimate is valid\n\tif (!_ahrs->get_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_gps_pos_check_failed = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 42.597307531114126}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\t// no GPS checks required for manual modes\n\tif(control_mode == AP_MOTORS_STABILIZE || control_mode == AP_MOTORS_ACRO) {\n\t\treturn true;\n\t}\n\n\t// call parent class's gps checks\n\tif(!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if AHRS is ready\n\tif(!ahrs.healthy) {\n\t\tif(display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"AHRS not ready\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif(ahrs.ekf_check_failsafe()) {\n\t\tif(display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"EKF failsafe active\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if position estimate is valid\n\tif(!ahrs.get_position_ok()) {\n\t\tif(display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Position estimate invalid\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// all checks passed\n\treturn true;\n}\n", "CodeBleu_score": 49.86358644703523}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs.healthy()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"EKF not healthy\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (ahrs.get_ekf_fail_status()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"EKF failsafe\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!ahrs.get_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"EKF position not OK\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 48.85011574145213}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\t// do not arm if already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// do not arm if not in a mode that allows arming\n\tif (mode_requires_arming() == false) {\n\t\treturn false;\n\t}\n\n\t// do not arm if motors are already enabled\n\tif (motors.armed()) {\n\t\treturn false;\n\t}\n\n\t// do not arm if we are not in a mode that allows arming\n\tif (mode_allows_arming() == false) {\n\t\treturn false;\n\t}\n\n\t// do not arm if we are not in a mode that allows arming\n\tif (mode_allows_arming() == false) {\n\t\treturn false;\n\t}\n\n\t// do not arm if the throttle is not at the bottom\n\tif (method == AP_Arming::THROTTLE &&!motors.get_throttle_lowered()) {\n\t\treturn false;\n\t}\n\n\t// do not arm if the throttle is not at the bottom\n\tif (method == AP_Arming::THROTTLE &&!motors.get_throttle_lowered()) {\n\t\treturn false;\n\t}\n\n\t// do not arm if the throttle is not at the bottom\n\tif (method == AP_Arming::THROTTLE &&!motors.get_throttle_lowered()) {\n\t\treturn false;\n\t}\n\n\t// do not arm if the throttle is not at the bottom\n\tif (method == AP_Arming::THROTTLE &&!motors.get_throttle_lowered()) {\n\t\treturn false;\n\t}\n\n\t// do not arm if the throttle is not at the bottom\n\tif (method == AP_Arming::THROTTLE &&!motors.get_throttle_lowered()) {\n\t\treturn false;\n\t}\n\n\t// do not arm if the throttle is not at the bottom\n\tif (method == AP_Arming::THROTTLE &&!motors.get_throttle_lowered()) {\n\t\treturn false;\n\t}\n\n\t// do not arm if the throttle is not at the bottom\n\tif (method == AP_Arming::THROTTLE &&!motors.get_", "CodeBleu_score": 41.40049438743087}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\t// if we are already armed, do nothing\n\tif (armed.armed) {\n\t\treturn false;\n\t}\n\n\t// if arming checks are required, perform them\n\tif (do_arming_checks &&!arming_checks()) {\n\t\treturn false;\n\t}\n\n\t// set the home location\n\tif (g.home_is_set) {\n\t\thome.set_location(g.home);\n\t} else {\n\t\thome.set_location(inertial_nav.get_position());\n\t}\n\n\t// set the home altitude\n\thome.set_altitude(g.home.alt);\n\n\t// set the home heading\n\thome.set_heading(ahrs.yaw_sensor);\n\n\t// set the simple mode heading\n\tsimple_mode_heading = ahrs.yaw_sensor;\n\n\t// set the home position for sail boats\n\tif (g.sailboat_enabled) {\n\t\thome_position_for_sailboat = inertial_nav.get_position();\n\t}\n\n\t// set the home heading for sail boats\n\tif (g.sailboat_enabled) {\n\t\thome_heading_for_sailboat = ahrs.yaw_sensor;\n\t}\n\n\t// set the home altitude for sail boats\n\tif (g.sailboat_enabled) {\n\t\thome_altitude_for_sailboat = g.home.alt;\n\t}\n\n\t// set the home position for boats\n\tif (g.boat_enabled) {\n\t\thome_position_for_boat = inertial_nav.get_position();\n\t}\n\n\t// set the home heading for boats\n\tif (g.boat_enabled) {\n\t\thome_heading_for_boat = ahrs.yaw_sensor;\n\t}\n\n\t// set the home altitude for boats\n\tif (g.boat_enabled) {\n\t\thome_altitude_for_boat = g.home.alt;\n\t}\n\n\t// set the home position for submarines\n\tif (g.submarine_enabled) {\n\t\thome_position_for_submarine = inertial_nav.get_position();\n\t}", "CodeBleu_score": 41.98715966848188}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\t// don't arm if we are already armed\n\tif (_armed.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in failsafe\n\tif (_failsafe.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a guided mode\n\tif (_guided_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a mission\n\tif (_mission_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a loiter\n\tif (_loiter_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a land\n\tif (_land_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a rtl\n\tif (_rtl_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a circle\n\tif (_circle_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a takeoff\n\tif (_takeoff_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a follow target\n\tif (_follow_target_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a position hold\n\tif (_position_hold_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a land\n\tif (_land_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a auto\n\tif (_auto_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a acro\n\tif (_acro_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a stabilize\n\tif (_stabilize_mode.get()) {\n\t\treturn false;\n\t}\n\n\t// don't arm if we are in a alt hold\n\tif (_alt_hold_mode.get()) {\n\t\treturn false;\n", "CodeBleu_score": 19.37603453497977}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tif (!should_charge) {\n\t\t\t\tdisableCharging();\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_enabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (should_charge) {\n\t\t\t\tenableCharging();\n\t\t\t\tcharging_enabled = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tdisableCharging();\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_enabled_time = millis();\n\t\t} else {\n\t\t\tif (millis() - charging_enabled_time > CHARGING_RETRY_DELAY) {\n\t\t\t\tenableCharging();\n\t\t\t\tcharging_enabled = true;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.64618225781137}, {"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\t// Charging is allowed, but should not continue.\n\t\t\tdisableCharging();\n\t\t} else {\n\t\t\t// Charging is allowed and should continue.\n\t\t\tenableCharging();\n\t\t}\n\t} else {\n\t\t// Charging is not allowed.\n\t\tif (charging_enabled) {\n\t\t\t// Charging is not allowed, but should continue.\n\t\t\tdisableCharging();\n\t\t} else {\n\t\t\t// Charging is not allowed, and should not continue.\n\t\t\t// Wait for a specified delay before trying to enable charging again.\n\t\t\tif (millis() - last_charging_disable_time >= CHARGING_RETRY_DELAY) {\n\t\t\t\tenableCharging();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 25.121543943590986}, {"code": "void updateChargingEnabled()\tif (charging_allowed &&!charging_enabled) {\n\t\tcharging_enabled = true;\n\t\tcharging_disabled_time = 0;\n\t\tenableCharging();\n\t} else if (!charging_allowed && charging_enabled) {\n\t\tcharging_enabled = false;\n\t\tcharging_disabled_time = millis();\n\t\tdisableCharging();\n\t} else if (!charging_allowed &&!charging_enabled && millis() - charging_disabled_time > CHARGING_RETRY_DELAY) {\n\t\tcharging_disabled_time = 0;\n\t\tenableCharging();\n\t}\n}\n", "CodeBleu_score": 37.955878921094545}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)\tif (size >= 4) {\n\t\tuint16_t crc = crc16(message, size);\n\t\tsize += 2;\n\t\tuint8_t *message_with_crc = (uint8_t *) malloc(size);\n\t\tmemcpy(message_with_crc, message, size - 2);\n\t\tmemcpy(message_with_crc + size - 2, &crc, 2);\n\t\tpacketSerial.send(message_with_crc, size);\n\t\tfree(message_with_crc);\n\t}\n}\n", "CodeBleu_score": 44.73343857195577}, {"code": "void sendMessage(void *message, size_t size)\tif(ros::ok() && size >= 4) {\n\t\tuint16_t crc = CRC16_CCITT(message, size);\n\t\tuint8_t *msg = (uint8_t *)message;\n\t\tmsg[size] = crc & 0xFF;\n\t\tmsg[size+1] = (crc >> 8) & 0xFF;\n\t\tpacketSerial.send(msg, size+2);\n\t}\n}\n", "CodeBleu_score": 53.19694947324167}, {"code": "void sendMessage(void *message, size_t size)\tif (ros::isInitialized() && size >= 4) {\n\t\tuint16_t crc = CRC16::calculate((uint8_t *)message, size);\n\t\tuint8_t *crc_bytes = (uint8_t *)&crc;\n\t\t*(uint16_t *)((uint8_t *)message + size) = crc;\n\t\tpacketSerial.send((uint8_t *)message, size + 2);\n\t}\n}\n", "CodeBleu_score": 42.464595264031004}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()\tSerial.begin(9600);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0x02);\n\tSerial.write(0x3F);\n\tSerial.write(0xEF);\n\tdelay(500);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0x02);\n\tSerial.write(0x49);\n\tSerial.write(0xEF);\n\tdelay(500);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0x03);\n\tSerial.write(0x41);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(500);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0x02);\n\tSerial.write(0x45);\n\tSerial.write(0xEF);\n\tdelay(500);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0x02);\n\tSerial.write(0x4E);\n\tSerial.write(0xEF);\n\tdelay(500);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0x03);\n\tSerial.write(0x42);\n\tSerial.write(0x01);\n\tSerial.write(0xEF);\n\tdelay(500);\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0x02);\n\tSerial.write(0x43);\n\tSerial.write(0xEF);\n\tdelay(500);\n\twhile (", "CodeBleu_score": 39.23541935606322}, {"code": "bool MP3Sound::begin()\t// Initialize the serial communication\n\tSerial.begin(9600);\n\n\t// Clear the buffer\n\tclearBuffer();\n\n\t// Initialize the sound module\n\tsendCommand(CMD_SEL_DEV, DEV_TF);\n\tdelay(100);\n\tsendCommand(CMD_SET_VOLUME, 0xFE);\n\tdelay(100);\n\tsendCommand(CMD_SET_VOLUME, 0xFE);\n\tdelay(100);\n\n\t// Get the number of sound files available\n\t_numFiles = getNumFiles();\n\n\t// Return true if there are one or more sound files available\n\treturn (_numFiles > 0);\n}\n", "CodeBleu_score": 36.13771993430593}, {"code": "bool MP3Sound::begin()\t_serial->begin(9600);\n\t_serial->flush();\n\tdelay(100);\n\t_serial->write(0x7E);\n\t_serial->write(0x04);\n\t_serial->write(0xA0);\n\t_serial->write(0x00);\n\t_serial->write(0x7E);\n\tdelay(100);\n\tif (readResponse() == 0x3A) {\n\t\t_serial->write(0x7E);\n\t\t_serial->write(0x02);\n\t\t_serial->write(0x3F);\n\t\t_serial->write(0xEF);\n\t\tdelay(100);\n\t\tif (readResponse() == 0x3A) {\n\t\t\t_serial->write(0x7E);\n\t\t\t_serial->write(0x03);\n\t\t\t_serial->write(0x49);\n\t\t\t_serial->write(0x00);\n\t\t\t_serial->write(0xEF);\n\t\t\tdelay(100);\n\t\t\tif (readResponse() == 0x3A) {\n\t\t\t\t_serial->write(0x7E);\n\t\t\t\t_serial->write(0x02);\n\t\t\t\t_serial->write(0x48);\n\t\t\t\t_serial->write(0xEF);\n\t\t\t\tdelay(100);\n\t\t\t\tif (readResponse() == 0x3A) {\n\t\t\t\t\t_serial->write(0x7E);\n\t\t\t\t\t_serial->write(0x03);\n\t\t\t\t\t_serial->write(0x47);\n\t\t\t\t\t_serial->write(0x00);\n\t\t\t\t\t_serial->write(0xEF);\n\t\t\t\t\tdelay(100);\n\t\t\t\t\tif (readResponse() == 0x3A) {\n\t\t\t\t\t\t_serial->write(0x7E);\n\t\t\t\t\t\t_serial->write(0x02);\n\t\t\t\t\t\t_serial->write(0x44);\n\t\t\t\t\t\t_serial->write(0xEF);\n\t\t\t\t\t\tdelay(100);\n\t\t\t\t\t\tif (readResponse() == 0x3A) {\n\t\t\t\t\t\t\t_serial->write(0x7E);\n\t\t\t\t\t\t\t_serial->write(0x03);\n\t\t\t\t\t\t\t_serial->write(0x45", "CodeBleu_score": 37.62309115755333}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()\t// If there are no active sounds or if an MP3 is currently playing, return the number of active sounds.\n\tif (activeSounds.size() == 0 || currentMP3!= NULL) {\n\t\treturn activeSounds.size();\n\t}\n\n\t// Retrieve and play the last sound from the active sounds list.\n\tSound *sound = activeSounds.back();\n\tsound->play();\n\n\t// Remove the sound from the active sounds list.\n\tactiveSounds.pop_back();\n\n\t// Return the updated number of active sounds.\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 35.036492317087244}, {"code": "int MP3Sound::processSounds()\tint numSounds = activeSounds.size();\n\tif (numSounds == 0 || currentMP3!= 0)\n\t\treturn numSounds;\n\tMP3Sound *sound = activeSounds[numSounds - 1];\n\tif (sound->play()) {\n\t\tactiveSounds.remove(numSounds - 1);\n\t\tnumSounds--;\n\t}\n\treturn numSounds;\n}\n", "CodeBleu_score": 42.53749574276575}, {"code": "int MP3Sound::processSounds()\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (isPlaying) {\n\t\treturn activeSounds.size();\n\t}\n\telse {\n\t\tint soundID = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tplay(soundID);\n\t\treturn activeSounds.size();\n\t}\n}\n", "CodeBleu_score": 41.634890613632955}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)#ifdef _WIN32\n  return false;", "CodeBleu_score": 6.679403285874605}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_handle_command: %d\\n\", command);", "CodeBleu_score": 7.370427897270286}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)#ifdef DEBUG_CAMERA_COMMANDS\n  printf(\"abstract camera command: %d\\n\", command);", "CodeBleu_score": 7.289316697626217}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_get_height(%p)\\n\", d);", "CodeBleu_score": 3.768706748438798}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)#ifdef DEBUG_ABSTRACT_CAMERA\n  printf(\"wb_abstract_camera_get_height(%p)\\n\", d);", "CodeBleu_score": 4.059469806247215}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_get_height(%p)\\n\", d);", "CodeBleu_score": 3.768706748438798}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\\n\", tag);", "CodeBleu_score": 4.00681142378618}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\\n\", tag);", "CodeBleu_score": 4.00681142378618}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\\n\", tag);", "CodeBleu_score": 4.00681142378618}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\twb_free(dms);\n\treturn dmsString;\n}\n", "CodeBleu_score": 39.19167561218329}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dmsString);\n\twb_free(dmsString);\n\treturn result;\n}\n", "CodeBleu_score": 40.59624561039804}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar* dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dmsString);\n\tfree(dmsString);\n\treturn result;\n}\n", "CodeBleu_score": 40.193841363694716}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdUASSERT (g && dGeomGetClass (g) == dBoxClass, \"argument not a box\");\n\tdAASSERT (plane);\n\tconst dxBox* box = (const dxBox*) g;\n\tdReal dx = x - box->posr.pos[0];\n\tdReal dy = y - box->posr.pos[1];\n\tdReal dz = z - box->posr.pos[2];\n\tdReal px, py, pz;\n\tdReal pd = dFabs (dx*box->side[0]) + dFabs (dy*box->side[1]) + dFabs (dz*box->side[2]);\n\tif (pd < 0.0001) {\n\t\t// point is inside the box, so just return the normal of the closest face\n\t\tdReal p = dFabs (dx) - box->side[0];\n\t\tdReal q = dFabs (dy) - box->side[1];\n\t\tdReal r = dFabs (dz) - box->side[2];\n\t\tif (p < q) {\n\t\t\tif (p < r) {\n\t\t\t\tpx = (dx < 0)? -1 : 1;\n\t\t\t\tpy = 0;\n\t\t\t\tpz = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpx = 0;\n\t\t\t\tpy = 0;\n\t\t\t\tpz = (dz < 0)? -1 : 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (q < r) {\n\t\t\t\tpx = 0;\n\t\t\t\tpy = (dy < 0)? -1 : 1;\n\t\t\t\tpz = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpx = 0;\n\t\t\t\tpy = 0;\n\t\t\t\tpz = (dz < 0)? -1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// point is outside the box, so just return the normal of the closest face\n\t\tdReal p = dFabs (dx) - box->side[0];\n\t\tdReal q = dFabs (dy) - box->side[1];\n\t\tdReal r = dFabs (dz) - box->side[2];\n\t\tif (p < q", "CodeBleu_score": 33.9181353398989}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdUASSERT (g && dGeomGetClass(g) == dBoxClass, \"argument not a box\");\n\tdxBox *b = (dxBox*) g;\n\tdVector3 p;\n\tp[0] = x - b->posr->pos[0];\n\tp[1] = y - b->posr->pos[1];\n\tp[2] = z - b->posr->pos[2];\n\tdMULTIPLY1_331 (p,b->posr->R,p);\n\tdReal xd = p[0] - 0.5*b->side[0];\n\tdReal yd = p[1] - 0.5*b->side[1];\n\tdReal zd = p[2] - 0.5*b->side[2];\n\tdReal xd2 = p[0] + 0.5*b->side[0];\n\tdReal yd2 = p[1] + 0.5*b->side[1];\n\tdReal zd2 = p[2] + 0.5*b->side[2];\n\tdReal xdabs = xd > 0.0? xd : -xd;\n\tdReal ydabs = yd > 0.0? yd : -yd;\n\tdReal zdabs = zd > 0.0? zd : -zd;\n\tdReal xd2abs = xd2 > 0.0? xd2 : -xd2;\n\tdReal yd2abs = yd2 > 0.0? yd2 : -yd2;\n\tdReal zd2abs = zd2 > 0.0? zd2 : -zd2;\n\tif (xdabs < ydabs) {\n\t\tif (xdabs < zdabs) {\n\t\t\tif (xdabs < yd2abs) {\n\t\t\t\tif (xdabs < zd2abs) {\n\t\t\t\t\tplane[0] = xd > 0.0? 1.0 : -1.0;\n\t\t\t\t\tplane[1] = 0.0;\n\t\t\t\t\tplane[2] = 0.0;\n\t\t\t\t\tplane[3] = x", "CodeBleu_score": 36.14972598843428}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\tdReal side[3];\n\tconst dReal *p = g->posr.pos;\n\tconst dReal *R = g->posr.R;\n\tconst dReal *side_ = dGeomBoxGetLengths (g);\n\tside[0] = side_[0]*0.5f;\n\tside[1] = side_[1]*0.5f;\n\tside[2] = side_[2]*0.5f;\n\tdVector3 p_rel;\n\tp_rel[0] = x - p[0];\n\tp_rel[1] = y - p[1];\n\tp_rel[2] = z - p[2];\n\tdReal dist = dInfinity;\n\tdVector3 normal;\n\tnormal[0] = 0;\n\tnormal[1] = 0;\n\tnormal[2] = 0;\n\tif (p_rel[0] > side[0]) {\n\t\tdReal dist_ = p_rel[0] - side[0];\n\t\tif (dist_ < dist) {\n\t\t\tdist = dist_;\n\t\t\tnormal[0] = 1;\n\t\t}\n\t} else if (p_rel[0] < -side[0]) {\n\t\tdReal dist_ = side[0] + p_rel[0];\n\t\tif (dist_ < dist) {\n\t\t\tdist = dist_;\n\t\t\tnormal[0] = -1;\n\t\t}\n\t}\n\tif (p_rel[1] > side[1]) {\n\t\tdReal dist_ = p_rel[1] - side[1];\n\t\tif (dist_ < dist) {\n\t\t\tdist = dist_;\n\t\t\tnormal[1] = 1;\n\t\t}\n\t} else if (p_rel[1] < -side[1]) {\n\t\tdReal dist_ = side[1] + p_rel[1];\n\t\tif (dist_ < dist) {\n\t\t\tdist = dist_;\n\t\t\tnormal[1] = -1;\n\t\t}\n\t}\n\tif (p_rel[2] > side[2]) {\n\t\tdReal dist_ = p", "CodeBleu_score": 36.76770871619483}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tdUASSERT (box->body, \"dImmerseBox: box has no body\");\n\tdUASSERT (flags & (dIMMERSE_INSIDE|dIMMERSE_OUTSIDE), \"dImmerseBox: invalid flags\");\n\tsBoxImmersionData data (box, fluidPlane, flags, immersion);\n\treturn dImmerse (box->geom, &data);\n}\n", "CodeBleu_score": 55.84207093502113}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tdUASSERT (box->body, \"dImmerseBox: box has no body\");\n\tdUASSERT (flags & (dImmersionFlagsValid | dImmersionFlagsFluidPlaneValid), \"dImmerseBox: invalid flags\");\n\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\n\treturn dImmerse (box->body, &data, sBoxImmersionData::check);\n}\n", "CodeBleu_score": 47.9337693466005}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tdAASSERT (box);\n\tdAASSERT (box->body);\n\tdAASSERT (flags >= 0);\n\tdAASSERT (flags < 32);\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\tdata.immersion->flags = 0;\n\tdata.immersion->depth = 0;\n\tdata.immersion->normal[0] = 0;\n\tdata.immersion->normal[1] = 0;\n\tdata.immersion->normal[2] = 0;\n\tdata.immersion->point[0] = 0;\n\tdata.immersion->point[1] = 0;\n\tdata.immersion->point[2] = 0;\n\tdata.immersion->velocity[0] = 0;\n\tdata.immersion->velocity[1] = 0;\n\tdata.immersion->velocity[2] = 0;\n\tdata.immersion->angularVelocity[0] = 0;\n\tdata.immersion->angularVelocity[1] = 0;\n\tdata.immersion->angularVelocity[2] = 0;\n\tdata.immersion->fluidVelocity[0] = 0;\n\tdata.immersion->fluidVelocity[1] = 0;\n\tdata.immersion->fluidVelocity[2] = 0;\n\tdata.immersion->fluidAngularVelocity[0] = 0;\n\tdata.immersion->fluidAngularVelocity[1] = 0;\n\tdata.immersion->fluidAngularVelocity[2] = 0;\n\tdata.immersion->fluidDensity = 0;\n\tdata.immersion->fluidViscosity = 0;\n\tdata.immersion->fluidSurfaceTension = 0;\n\tdata.immersion->fluidViscosity = 0;\n\tdata.immersion->fluidPressure = 0;\n\tdata.immersion->fluidTemperature = 0;\n\tdata.immersion->fluidSurfaceTension = 0;\n\tdata.immersion->fluidViscosity = 0;\n\tdata.immersion->", "CodeBleu_score": 39.06733015649987}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdUASSERT (o1->type == dBoxClass, \"Argument not a box\");\n\tdUASSERT (o2->type == dCapsuleClass, \"Argument not a capsule\");\n\tdUASSERT (immersion, \"Argument not an immersion geometry\");\n\tdUASSERT (immersion->immersion_plane, \"Immersion plane not allocated\");\n\tdUASSERT (immersion->immersion_point, \"Immersion point not allocated\");\n\tdUASSERT (immersion->immersion_normal, \"Immersion normal not allocated\");\n\tdUASSERT (immersion->immersion_depth, \"Immersion depth not allocated\");\n\tdUASSERT (immersion->immersion_point2, \"Second immersion point not allocated\");\n\tdUASSERT (immersion->immersion_normal2, \"Second immersion normal not allocated\");\n\tdUASSERT (immersion->immersion_depth2, \"Second immersion depth not allocated\");\n\tdUASSERT (immersion->immersion_point3, \"Third immersion point not allocated\");\n\tdUASSERT (immersion->immersion_normal3, \"Third immersion normal not allocated\");\n\tdUASSERT (immersion->immersion_depth3, \"Third immersion depth not allocated\");\n\tdUASSERT (immersion->immersion_point4, \"Fourth immersion point not allocated\");\n\tdUASSERT (immersion->immersion_normal4, \"Fourth immersion normal not allocated\");\n\tdUASSERT (immersion->immersion_depth4, \"Fourth immersion depth not allocated\");\n\tdUASSERT (immersion->immersion_point5, \"Fifth immersion point not allocated\");\n\tdUASSERT (immersion->immersion_normal5, \"Fifth immersion normal not allocated\");\n\tdUASSERT (immersion->immersion_depth5, \"Fifth immersion depth not allocated\");\n\tdUASSERT (immersion->immersion_point6, \"Sixth immersion point not allocated\");\n\tdUASSERT (immersion->immersion_normal6, \"Sixth immersion normal not allocated\");\n\tdUASSERT (immersion->immersion_depth6, \"Sixth immersion depth not allocated\");\n\tdUASSERT (immersion->immersion_point7", "CodeBleu_score": 17.9743536906762}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdUASSERT (immersion, \"immersion is NULL\");\n\tdUASSERT (immersion->contact, \"immersion->contact is NULL\");\n\tdUASSERT (immersion->normal, \"immersion->normal is NULL\");\n\tdUASSERT (immersion->depth, \"immersion->depth is NULL\");\n\tdUASSERT (immersion->contact_count, \"immersion->contact_count is NULL\");\n\n\tdUASSERT (o1 && o1->type == dBoxClass, \"argument o1 is not a box\");\n\tdUASSERT (o2 && o2->type == dCapsuleClass, \"argument o2 is not a capsule\");\n\tdUASSERT (o1->body && o2->body, \"one of the objects is static\");\n\n\tdxBox *b = (dxBox *) o1;\n\tdxCapsule *c = (dxCapsule *) o2;\n\tdVector3 p1, p2;\n\tdVector3 dir;\n\tdVector3 normal;\n\tdReal depth;\n\tint contact_count;\n\n\t// compute the immersion plane of the capsule\n\tdMULTIPLY1_331 (p1, c->final_posr, c->p1);\n\tdMULTIPLY1_331 (p2, c->final_posr, c->p2);\n\tdSubtractVectors3 (dir, p2, p1);\n\tdNormalize3 (dir);\n\tdCopyVector3 (normal, dir);\n\tdepth = c->length + c->radius;\n\n\t// compute the immersion of the box in the fluid\n\tcontact_count = dImmerseBox (o1, o2, flags, immersion);\n\n\t// set the immersion parameters\n\tdCopyVector3 (immersion->normal, normal);\n\timmersion->depth = depth;\n\timmersion->contact_count = contact_count;\n\n\treturn contact_count;\n}\n", "CodeBleu_score": 47.07460492121576}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdUASSERT (o1->type == dBoxClass, \"argument not a box\");\n\tdUASSERT (o2->type == dCapsuleClass, \"argument not a capsule\");\n\tdUASSERT (immersion, \"argument not a valid immersion structure\");\n\n\tif (o1->body && o2->body && dAreConnectedExcluding (o1->body, o2->body, dJointTypeContact))\n\t\treturn 0;\n\n\t// Get the box and capsule parameters\n\tconst dVector3 side = {o1->size[0], o1->size[1], o1->size[2]};\n\tconst dVector3 center = {o1->posr.pos[0], o1->posr.pos[1], o1->posr.pos[2]};\n\tconst dMatrix3 R = o1->posr.R;\n\tconst dReal radius = o2->size[0];\n\tconst dReal length = o2->size[1];\n\tconst dVector3 center2 = {o2->posr.pos[0], o2->posr.pos[1], o2->posr.pos[2]};\n\tconst dMatrix3 R2 = o2->posr.R;\n\n\t// Check for collision between the box and the capsule\n\tdVector3 normal;\n\tdReal depth;\n\tif (!dCollideBoxCapsule (side, center, R, radius, length, center2, R2, &depth, normal))\n\t\treturn 0;\n\n\t// Set the immersion parameters\n\timmersion->depth = depth;\n\timmersion->normal[0] = normal[0];\n\timmersion->normal[1] = normal[1];\n\timmersion->normal[2] = normal[2];\n\timmersion->point[0] = center[0] + depth * normal[0];\n\timmersion->point[1] = center[1] + depth * normal[1];\n\timmersion->point[2] = center[2] + depth * normal[2];\n\n\t// Compute the immersion plane for the capsule\n\tdVector3 plane;\n\tdVector3 axis;\n\tdVector3 center_to_point;\n\tcenter_to_point", "CodeBleu_score": 38.444034588405735}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal tanTheta1 = tanTheta0 + zIOverR;\n\tdReal sinTheta0 = dSqrt(1.0 + tanTheta0 * tanTheta0);\n\tdReal cosTheta0 = 1.0 / sinTheta0;\n\tdReal cosTheta1 = 1.0 / dSqrt(1.0 + tanTheta1 * tanTheta1);\n\tdReal sinTheta2 = sinTheta0 * sinTheta1;\n\tdReal cosTheta2 = cosTheta0 * cosTheta1;\n\tdReal tanTheta2 = tanTheta0 * tanTheta1;\n\tdReal sinTheta3 = sinTheta2 * sinTheta1;\n\tdReal cosTheta3 = cosTheta2 * cosTheta1;\n\tdReal tanTheta3 = tanTheta2 * tanTheta1;\n\tdReal sinTheta4 = sinTheta3 * sinTheta1;\n\tdReal cosTheta4 = cosTheta3 * cosTheta1;\n\tdReal tanTheta4 = tanTheta3 * tanTheta1;\n\tdReal sinTheta5 = sinTheta4 * sinTheta1;\n\tdReal cosTheta5 = cosTheta4 * cosTheta1;\n\tdReal tanTheta5 = tanTheta4 * tanTheta1;\n\tdReal sinTheta6 = sinTheta5 * sinTheta1;\n\tdReal cosTheta6 = cosTheta5 * cosTheta1;\n\tdReal tanTheta6 = tanTheta5 * tanTheta1;\n\tdReal sinTheta7 = sinTheta6 * sinTheta1;\n\tdReal cosTheta7 = cosTheta6 * cosTheta1;\n\tdReal tanTheta7 = tanTheta6 * tanTheta1;\n\tdReal sinTheta8 = sinTheta7 * sinTheta1;\n\tdReal cosTheta8 = cosTheta7 * cosTheta1;\n\tdReal tanTheta8 = tanTheta7 * tanTheta1;\n\tdReal sinTheta9 = sinTheta8 * sinTheta1;\n\tdReal cosTheta9 = cosTheta8 * cosTheta1;\n\tdReal tanTheta9 = tanTheta8 * tanTheta1;\n\tdReal sinTheta10 = sinTheta9 * sinTheta1;\n\tdReal cosTheta10 = cosTheta9 * cosTheta1;\n\tdReal tanTheta10 = tan", "CodeBleu_score": 34.44697180541426}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal z = zIOverR * radius;\n\tdReal r = radius;\n\tdReal tanTheta1 = tanTheta0 + (z - z0) / r;\n\tdReal sinTheta0 = dSqrt(tanTheta0 * tanTheta0 + 1);\n\tdReal cosTheta0 = 1 / sinTheta0;\n\tdReal cosTheta1 = 1 / dSqrt(tanTheta1 * tanTheta1 + 1);\n\tdReal sinTheta2 = sinTheta1 * cosTheta0 + cosTheta1 * sinTheta0;\n\tdReal cosTheta2 = cosTheta1 * cosTheta0 - sinTheta1 * sinTheta0;\n\tdReal tanTheta2 = sinTheta2 / cosTheta2;\n\tdReal sinTheta3 = sinTheta2 * cosTheta0 + cosTheta2 * sinTheta0;\n\tdReal cosTheta3 = cosTheta2 * cosTheta0 - sinTheta2 * sinTheta0;\n\tdReal tanTheta3 = sinTheta3 / cosTheta3;\n\tdReal sinTheta4 = sinTheta3 * cosTheta0 + cosTheta3 * sinTheta0;\n\tdReal cosTheta4 = cosTheta3 * cosTheta0 - sinTheta3 * sinTheta0;\n\tdReal tanTheta4 = sinTheta4 / cosTheta4;\n\tdReal sinTheta5 = sinTheta4 * cosTheta0 + cosTheta4 * sinTheta0;\n\tdReal cosTheta5 = cosTheta4 * cosTheta0 - sinTheta4 * sinTheta0;\n\tdReal tanTheta5 = sinTheta5 / cosTheta5;\n\tdReal sinTheta6 = sinTheta5 * cosTheta0 + cosTheta5 * sinTheta0;\n\tdReal cosTheta6 = cosTheta5 * cosTheta0 - sinTheta5 * sinTheta0;\n\tdReal tanTheta6 = sinTheta6 / cosTheta6;\n\tdReal sinTheta7 = sinTheta6 * cosTheta0 + cosTheta6 * sinTheta0;\n\tdReal cosTheta7 = cosTheta6 * cosTheta0 - sinTheta6 * sinTheta0;\n\tdReal tanTheta7 = sinTheta7 / cosTheta7;\n\tdReal sinTheta8 = sinTheta7 * cosTheta0 + cosTheta7 * sinTheta0;\n", "CodeBleu_score": 34.01851657184814}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal z = zIOverR * m_radius;\n\tdReal r = m_radius;\n\tdReal tanTheta1 = z / (r - z);\n\tdReal sinTheta0 = tanTheta0 * sqrt(1.0 + tanTheta0 * tanTheta0);\n\tdReal cosTheta0 = 1.0 / sqrt(1.0 + tanTheta0 * tanTheta0);\n\tdReal cosTheta1 = 1.0 / sqrt(1.0 + tanTheta1 * tanTheta1);\n\tdReal sinTheta2 = sqrt(1.0 - cosTheta1 * cosTheta1);\n\tdReal cosTheta2 = cosTheta0 * cosTheta1 + sinTheta0 * sinTheta1 * sinTheta2;\n\tdReal sinTheta3 = sqrt(1.0 - cosTheta2 * cosTheta2);\n\tdReal cosTheta3 = cosTheta0 * cosTheta2 + sinTheta0 * sinTheta1 * sinTheta3;\n\tdReal sinTheta4 = sqrt(1.0 - cosTheta3 * cosTheta3);\n\tdReal cosTheta4 = cosTheta0 * cosTheta3 + sinTheta0 * sinTheta1 * sinTheta4;\n\tdReal sinTheta5 = sqrt(1.0 - cosTheta4 * cosTheta4);\n\tdReal cosTheta5 = cosTheta0 * cosTheta4 + sinTheta0 * sinTheta1 * sinTheta5;\n\tdReal sinTheta6 = sqrt(1.0 - cosTheta5 * cosTheta5);\n\tdReal cosTheta6 = cosTheta0 * cosTheta5 + sinTheta0 * sinTheta1 * sinTheta6;\n\tdReal sinTheta7 = sqrt(1.0 - cosTheta6 * cosTheta6);\n\tdReal cosTheta7 = cosTheta0 * cosTheta6 + sinTheta0 * sinTheta1 * sinTheta7;\n\tdReal sinTheta8 = sqrt(1.0 - cosTheta7 * cosTheta7);\n\tdReal cosTheta8 = cosTheta0 * cosTheta7 + sinTheta0 * sinTheta1 * sinTheta8;\n\tdReal sinTheta9 = sqrt(1.0 - cosTheta8 * cosTheta8);\n\tdReal cosTheta9 = cosTheta0 * cosTheta8 + sinTheta0 * sin", "CodeBleu_score": 34.85248844352505}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal z = zIOverR * m_radius;\n\tdReal r = m_radius;\n\tdReal x = r * cos(asin(z / r));\n\tdReal x0 = r * cos(asin(zIOverR * m_length / 2.0));\n\tdReal x1 = r * cos(asin(zIOverR * m_length));\n\tdReal x2 = r * cos(asin(zIOverR * m_length / 2.0 + zIOverR * m_radius));\n\tdReal x3 = r * cos(asin(zIOverR * m_length / 2.0 - zIOverR * m_radius));\n\tdReal x4 = r * cos(asin(zIOverR * m_length / 2.0 + zIOverR * m_radius / 2.0));\n\tdReal x5 = r * cos(asin(zIOverR * m_length / 2.0 - zIOverR * m_radius / 2.0));\n\tdReal x6 = r * cos(asin(zIOverR * m_length / 2.0 + zIOverR * m_radius / 4.0));\n\tdReal x7 = r * cos(asin(zIOverR * m_length / 2.0 - zIOverR * m_radius / 4.0));\n\tdReal x8 = r * cos(asin(zIOverR * m_length / 2.0 + zIOverR * m_radius / 8.0));\n\tdReal x9 = r * cos(asin(zIOverR * m_length / 2.0 - zIOverR * m_radius / 8.0));\n\tdReal x10 = r * cos(asin(zIOverR * m_length / 2.0 + zIOverR * m_radius / 16.0));\n\tdReal x11 = r * cos(asin(zIOverR * m_length / 2.0 - zIOverR * m_radius / 16.0));\n\tdReal x12 = r * cos(asin(zIOverR *", "CodeBleu_score": 34.89774932600432}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal x = 0.0;\n\tdReal z = 0.0;\n\tdReal dz = 0.0;\n\tdReal sinTheta = 0.0;\n\tdReal cosTheta = 0.0;\n\tdReal dTheta = 0.0;\n\tdReal theta = 0.0;\n\tdReal theta0 = 0.0;\n\tdReal theta1 = 0.0;\n\tdReal r = 0.0;\n\tdReal r2 = 0.0;\n\tdReal r3 = 0.0;\n\tdReal r4 = 0.0;\n\tdReal r5 = 0.0;\n\tdReal r6 = 0.0;\n\tdReal r7 = 0.0;\n\tdReal r8 = 0.0;\n\tdReal r9 = 0.0;\n\tdReal r10 = 0.0;\n\tdReal r11 = 0.0;\n\tdReal r12 = 0.0;\n\tdReal r13 = 0.0;\n\tdReal r14 = 0.0;\n\tdReal r15 = 0.0;\n\tdReal r16 = 0.0;\n\tdReal r17 = 0.0;\n\tdReal r18 = 0.0;\n\tdReal r19 = 0.0;\n\tdReal r20 = 0.0;\n\tdReal r21 = 0.0;\n\tdReal r22 = 0.0;\n\tdReal r23 = 0.0;\n\tdReal r24 = 0.0;\n\tdReal r25 = 0.0;\n\tdReal r26 = 0.0;\n\tdReal r27 = 0.0;\n\tdReal r28 = 0.0;\n\tdReal r29 = 0.0;\n\tdReal r30 = 0.0;\n\tdReal r31 = 0.0;\n\tdReal r32 = 0.0;\n\td", "CodeBleu_score": 10.52891344348167}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal x = 0;\n\tdReal x0 = 0;\n\tdReal x1 = 0;\n\tdReal x2 = 0;\n\tdReal x3 = 0;\n\tdReal x4 = 0;\n\tdReal x5 = 0;\n\tdReal x6 = 0;\n\tdReal x7 = 0;\n\tdReal x8 = 0;\n\tdReal x9 = 0;\n\tdReal x10 = 0;\n\tdReal x11 = 0;\n\tdReal x12 = 0;\n\tdReal x13 = 0;\n\tdReal x14 = 0;\n\tdReal x15 = 0;\n\tdReal x16 = 0;\n\tdReal x17 = 0;\n\tdReal x18 = 0;\n\tdReal x19 = 0;\n\tdReal x20 = 0;\n\tdReal x21 = 0;\n\tdReal x22 = 0;\n\tdReal x23 = 0;\n\tdReal x24 = 0;\n\tdReal x25 = 0;\n\tdReal x26 = 0;\n\tdReal x27 = 0;\n\tdReal x28 = 0;\n\tdReal x29 = 0;\n\tdReal x30 = 0;\n\tdReal x31 = 0;\n\tdReal x32 = 0;\n\tdReal x33 = 0;\n\tdReal x34 = 0;\n\tdReal x35 = 0;\n\tdReal x36 = 0;\n\tdReal x37 = 0;\n\tdReal x38 = 0;\n\tdReal x39 = 0;\n\tdReal x40 = 0;\n\tdReal x41 = 0;\n\tdReal x42 = 0;\n\tdReal x43 = 0;\n\tdReal x44 = 0;\n\tdReal x45 = 0;\n\tdReal x46 =", "CodeBleu_score": 9.731577001764387}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdVector3 p1, p2, p3;\n\tdVector3 v1, v2, v3;\n\tdVector3 v12, v13, v23;\n\tdVector3 n12, n13, n23;\n\tdVector3 c12, c13, c23;\n\tdVector3 c123, c123_c13;\n\tdVector3 p12, p13, p23;\n\tdVector3 p123, p123_p13;\n\tdVector3 p123_p23;\n\tdVector3 p123_p13_p23;\n\tdVector3 p123_p13_p23_p12;\n\tdVector3 p123_p13_p23_p12_p1;\n\tdVector3 p123_p13_p23_p12_p1_p2;\n\tdVector3 p123_p13_p23_p12_p1_p2_p3;\n\tdVector3 p123_p13_p23_p12_p1_p2_p3_p123;\n\tdVector3 p123_p13_p23_p12_p1_p2_p3_p123_p12;\n\tdVector3 p123_p13_p23_p12_p1_p2_p3_p123_p12_p1;\n\tdVector3 p123_p13_p23_p12_p1_p2_p3_p123_p12_p1_p2;\n\tdVector3 p123_p13_p23_p12_p1_p2_p3_p123_p12_p1_p2_p3;\n\tdVector3 p123_p13_p23_p12_p1_p2", "CodeBleu_score": 7.664506074681772}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdVector3 pos1, pos2;\n\tdMatrix3 R1, R2;\n\tdVector3 normal;\n\tdVector3 pos;\n\tdVector3 v;\n\tdReal depth, depth2;\n\tdReal depth_ratio;\n\tdReal radius;\n\tdReal x_buoyancy_center;\n\tdReal y_buoyancy_center;\n\tdReal z_buoyancy_center;\n\tdReal volume;\n\tdReal volume_ratio;\n\tdReal cos_initial_angle;\n\tdReal cos_final_angle;\n\tdReal sin_initial_angle;\n\tdReal sin_final_angle;\n\tdReal tan_initial_angle;\n\tdReal tan_final_angle;\n\tdReal tan_final_angle2;\n\tdReal tan_final_angle3;\n\tdReal tan_final_angle4;\n\tdReal tan_final_angle5;\n\tdReal tan_final_angle6;\n\tdReal tan_final_angle7;\n\tdReal tan_final_angle8;\n\tdReal tan_final_angle9;\n\tdReal tan_final_angle10;\n\tdReal tan_final_angle11;\n\tdReal tan_final_angle12;\n\tdReal tan_final_angle13;\n\tdReal tan_final_angle14;\n\tdReal tan_final_angle15;\n\tdReal tan_final_angle16;\n\tdReal tan_final_angle17;\n\tdReal tan_final_angle18;\n\tdReal tan_final_angle19;\n\tdReal tan_final_angle20;\n\tdReal tan_final_angle21;\n\tdReal tan_final_angle22;\n\tdReal tan_final_angle23;\n\tdReal tan_final_angle24;\n\tdReal tan_final_angle25;\n\tdReal tan_final_angle26;\n\tdReal tan_final_angle27;\n\tdReal tan_final_angle28;\n\tdReal tan_final_angle29;\n\tdReal tan_final_angle", "CodeBleu_score": 7.488442512709735}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdUASSERT (o1->type == dCapsuleClass, \"dImmerseCapsuleTrimesh: o1 is not a capsule.\");\n\tdUASSERT (o2->type == dTriMeshClass, \"dImmerseCapsuleTrimesh: o2 is not a trimesh.\");\n\tdUASSERT (immersion, \"dImmerseCapsuleTrimesh: immersion is NULL.\");\n\tdUASSERT (immersion->capsule, \"dImmerseCapsuleTrimesh: immersion->capsule is NULL.\");\n\tdUASSERT (immersion->trimesh, \"dImmerseCapsuleTrimesh: immersion->trimesh is NULL.\");\n\tdUASSERT (immersion->capsule->type == dCapsuleClass, \"dImmerseCapsuleTrimesh: immersion->capsule is not a capsule.\");\n\tdUASSERT (immersion->trimesh->type == dTriMeshClass, \"dImmerseCapsuleTrimesh: immersion->trimesh is not a trimesh.\");\n\n\tdxCapsule *capsule = (dxCapsule*) o1;\n\tdxTriMesh *trimesh = (dxTriMesh*) o2;\n\tdCapsule *capsule_geom = capsule->geom;\n\tdTriMeshData *trimesh_geom = trimesh->geom;\n\tdCapsuleImmersionData *capsule_immersion_data = capsule->immersion_data;\n\tdTriMeshImmersionData *trimesh_immersion_data = trimesh->immersion_data;\n\n\t// Get the capsule's radius and length.\n\tconst dReal radius = capsule_geom->radius;\n\tconst dReal length = capsule_geom->length;\n\n\t// Get the capsule's rotation matrix.\n\tconst dMatrix3 R = capsule_geom->final_posr.R;\n\n\t// Get the capsule's position.\n\tconst dVector3 position = capsule_geom->final_posr.pos;\n\n\t// Get the capsule's rotation matrix transposed.\n\tdMatrix3 R_transpose;\n\tdRSetIdentity (R_transpose);\n\tdRFromAxisAndAngle (R_transpose, 0, 1, 0, M_PI);\n\tdMultiply", "CodeBleu_score": 34.24124031739694}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()\t// Retrieve the sleep duration in milliseconds from the input\n\tconst auto& sleep_duration = input()->get<double>(0);\n\tif (sleep_duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tstatus(NodeStatus::RUNNING);\n\n\t// Start a timer and set a callback to emit a wake-up signal when the timer expires\n\ttimer_waiting_ = true;\n\ttimer_ = std::make_unique<Timer>(\n\t\tstd::chrono::milliseconds(static_cast<int64_t>(sleep_duration)),\n\t\t[this]() {\n\t\t\ttimer_waiting_ = false;\n\t\t\temitWakeUp();\n\t\t}\n\t);\n\n\treturn NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 42.75129604519196}, {"code": "NodeStatus SleepNode::onStart()\tif (input_ports_[0].hasMsg()) {\n\t\tauto msg = input_ports_[0].getMsg<std::string>();\n\t\tif (msg->empty()) {\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\ttry {\n\t\t\tint duration = std::stoi(*msg);\n\t\t\tif (duration > 0) {\n\t\t\t\tstatus_ = NodeStatus::RUNNING;\n\t\t\t\ttimer_waiting_ = true;\n\t\t\t\ttimer_.start(duration);\n\t\t\t\ttimer_.setCallback(std::bind(&SleepNode::onTimer, this));\n\t\t\t\treturn NodeStatus::RUNNING;\n\t\t\t}\n\t\t} catch (std::invalid_argument& e) {\n\t\t\tLOG_ERROR(\"Invalid sleep duration: %s\", msg->c_str());\n\t\t} catch (std::out_of_range& e) {\n\t\t\tLOG_ERROR(\"Invalid sleep duration: %s\", msg->c_str());\n\t\t}\n\t}\n\treturn NodeStatus::SUCCESS;\n}\n", "CodeBleu_score": 36.99591783585424}, {"code": "NodeStatus SleepNode::onStart()\t// Retrieve sleep duration from input\n\tdouble sleep_duration;\n\tgetInput(\"sleep_duration\", sleep_duration);\n\n\t// If duration is missing or non-positive, return SUCCESS\n\tif (sleep_duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start timer\n\ttimer_waiting_ = true;\n\ttimer_.start(sleep_duration);\n\n\t// Set callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallback(std::bind(&SleepNode::onTimer, this));\n\n\treturn NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 44.43236464695396}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()\tif (!blackboard_->isEntryRegistered(entry_name_)) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tauto entry = blackboard_->getEntry(entry_name_);\n\tentry->lock();\n\n\tif (entry->getSequenceId()!= sequence_id_) {\n\t\tsequence_id_ = entry->getSequenceId();\n\t\tentry->unlock();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\tentry->unlock();\n\treturn NodeStatus::FAILURE;\n}\n\n} /* namespace BT */\n} /* namespace B0 */", "CodeBleu_score": 44.68309606090403}, {"code": "NodeStatus EntryUpdatedAction::tick()\t// Retrieve entry from blackboard\n\tif (blackboard->isEntryPresent(entryName)) {\n\t\t// Lock entry mutex\n\t\tblackboard->lockEntry(entryName);\n\t\t// Check if the entry has been updated\n\t\tif (blackboard->getSequenceId(entryName)!= lastSequenceId) {\n\t\t\t// Update last sequence ID\n\t\t\tlastSequenceId = blackboard->getSequenceId(entryName);\n\t\t\t// Unlock entry mutex\n\t\t\tblackboard->unlockEntry(entryName);\n\t\t\t// Return success\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\t// Unlock entry mutex\n\t\tblackboard->unlockEntry(entryName);\n\t}\n\t// Return failure\n\treturn NodeStatus::FAILURE;\n}\n\n} /* namespace BT */", "CodeBleu_score": 34.0762472651704}, {"code": "NodeStatus EntryUpdatedAction::tick()\tif (blackboard->isEntryPresent(entryName)) {\n\t\tauto entry = blackboard->getEntry(entryName);\n\t\tentry->lock();\n\t\tif (entry->getSequenceID()!= sequenceID) {\n\t\t\tsequenceID = entry->getSequenceID();\n\t\t\tentry->unlock();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\tentry->unlock();\n\t}\n\treturn NodeStatus::FAILURE;\n}\n\n} /* namespace BT */", "CodeBleu_score": 36.0487630762183}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const\tif (m_successThreshold < 0) {\n\t\treturn static_cast<size_t>(m_children.size()) + m_successThreshold;\n\t}\n\treturn static_cast<size_t>(m_successThreshold);\n}\n", "CodeBleu_score": 50.92385468576611}, {"code": "size_t ParallelNode::successThreshold() const\tif (m_successThreshold < 0) {\n\t\treturn static_cast<size_t>(-m_successThreshold * m_children.size());\n\t}\n\treturn static_cast<size_t>(m_successThreshold);\n}\n", "CodeBleu_score": 49.8160027874194}, {"code": "size_t ParallelNode::successThreshold() const\tif (m_successThreshold < 0) {\n\t\treturn m_children.size() + m_successThreshold;\n\t}\n\treturn m_successThreshold;\n}\n", "CodeBleu_score": 45.974352234685846}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (this->heartbeat_status) {\n\t\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - this->last_heartbeat_time).count() > 1000) {\n\t\t\t\tthis->heartbeat_status = false;\n\t\t\t\tthis->enableAllBreakpoints(false);\n\t\t\t}\n\t\t} else {\n\t\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - this->last_heartbeat_time).count() < 1000) {\n\t\t\t\tthis->heartbeat_status = true;\n\t\t\t\tthis->enableAllBreakpoints(true);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 31.513144236432044}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (!this->stopHeartbeatLoop) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (this->serverHeartbeatStatus!= this->serverHeartbeatStatusOld) {\n\t\t\tthis->serverHeartbeatStatusOld = this->serverHeartbeatStatus;\n\t\t\tif (this->serverHeartbeatStatus) {\n\t\t\t\tthis->enableAllBreakpoints();\n\t\t\t} else {\n\t\t\t\tthis->disableAllBreakpoints();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 17.771447098928714}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\tboost::this_thread::sleep(boost::posix_time::milliseconds(10));\n\n\t\t// Check heartbeat status\n\t\tif (heartbeatActive) {\n\t\t\tif (ros::Time::now() - heartbeatTime > ros::Duration(0.5)) {\n\t\t\t\theartbeatActive = false;\n\t\t\t\tenableAllBreakpoints(false);\n\t\t\t}\n\t\t} else {\n\t\t\tif (ros::Time::now() - heartbeatTime < ros::Duration(0.5)) {\n\t\t\t\theartbeatActive = true;\n\t\t\t\tenableAllBreakpoints(true);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.79456176676749}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\t// Split the input string into a vector of blackboard names\n\tstd::vector<std::string> blackboard_names = splitString(bb_list, ',');\n\t// Create a JSON object to store the blackboards\n\tjson blackboards_json;\n\t// Iterate through the blackboard names\n\tfor (const auto& blackboard_name : blackboard_names) {\n\t\t// Find the corresponding subtree\n\t\tauto subtree = groot2_tree->findSubtree(blackboard_name);\n\t\t// If the subtree is valid, lock it and export the blackboard to JSON\n\t\tif (subtree) {\n\t\t\tsubtree->lock();\n\t\t\tblackboards_json[blackboard_name] = subtree->exportToJson();\n\t\t\tsubtree->unlock();\n\t\t}\n\t}\n\t// Convert the JSON object to MessagePack format\n\tstd::vector<uint8_t> message;\n\tblackboards_json.dumpToMsgPack(message);\n\t// Return the MessagePack data as a vector of uint8_t\n\treturn message;\n}\n", "CodeBleu_score": 42.14579289588829}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> ret;\n\tstd::string bb_name;\n\tstd::stringstream ss(bb_list);\n\n\twhile (std::getline(ss, bb_name, ',')) {\n\t\tif (bb_name.empty()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttry {\n\t\t\tauto subtree = blackboard->getBlackboard(bb_name);\n\t\t\tif (subtree) {\n\t\t\t\tsubtree->lock();\n\t\t\t\tauto json = subtree->to_json();\n\t\t\t\tsubtree->unlock();\n\t\t\t\tret.insert(ret.end(), json.begin(), json.end());\n\t\t\t}\n\t\t} catch (const std::exception& e) {\n\t\t\tLOG_ERROR(\"Blackboard {} not found\", bb_name);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n} /* namespace groot */", "CodeBleu_score": 43.541646966147916}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> result;\n\tstd::string bb_name;\n\tstd::istringstream iss(bb_list);\n\twhile (std::getline(iss, bb_name, ',')) {\n\t\tauto bb = groot2::Blackboard::getBlackboard(bb_name);\n\t\tif (bb) {\n\t\t\tbb->lock();\n\t\t\tauto json = bb->toJson();\n\t\t\tbb->unlock();\n\t\t\tif (json.is_object()) {\n\t\t\t\tresult.insert(result.end(), json.dump().begin(), json.dump().end());\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 41.111357922092765}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\tif (pos.node_uid!= node_uid) {\n\t\treturn false;\n\t}\n\n\tif (pos.node_uid == 0 || pos.node_uid > nodes.size()) {\n\t\treturn false;\n\t}\n\n\tif (nodes[pos.node_uid] == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (nodes[pos.node_uid]->getHook() == nullptr) {\n\t\treturn false;\n\t}\n\n\tnodes[pos.node_uid]->getHook()->lock();\n\n\tif (nodes[pos.node_uid]->getHook()->getMode() == Hook::BREAKPOINT) {\n\t\tnodes[pos.node_uid]->getHook()->setStatus(result);\n\t\tnodes[pos.node_uid]->getHook()->setRemove(remove);\n\t\tnodes[pos.node_uid]->getHook()->setReady(true);\n\t\tnodes[pos.node_uid]->getHook()->notifyAll();\n\t}\n\n\tnodes[pos.node_uid]->getHook()->unlock();\n\n\treturn true;\n}\n", "CodeBleu_score": 33.41065273762036}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\tif (node_uid == 0) {\n\t\treturn false;\n\t}\n\tif (!m_nodes.count(node_uid)) {\n\t\treturn false;\n\t}\n\tif (!m_nodes[node_uid]->is_valid()) {\n\t\treturn false;\n\t}\n\tif (m_nodes[node_uid]->get_type()!= NodeType::HOOK) {\n\t\treturn false;\n\t}\n\tHook *hook = (Hook *) m_nodes[node_uid];\n\thook->lock();\n\tif (hook->get_status() == NodeStatus::BREAKPOINT) {\n\t\thook->set_status(result);\n\t\thook->set_remove(remove);\n\t\thook->set_ready(true);\n\t\thook->notify_all();\n\t}\n\thook->unlock();\n\treturn true;\n}\n", "CodeBleu_score": 34.683695946028976}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Search for the node\n\tauto node = getNode(pos, node_uid);\n\n\t// Check if the node exists and is valid\n\tif (!node ||!node->isValid()) {\n\t\treturn false;\n\t}\n\n\t// Retrieve the associated hook\n\tauto hook = node->getHook();\n\n\t// Lock the hook's mutex\n\thook->lock();\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (hook->getMode() == HookMode::BREAKPOINT) {\n\t\t// Set the desired status and removal flag\n\t\thook->setStatus(result);\n\t\thook->setRemove(remove);\n\n\t\t// Mark the hook as ready\n\t\thook->setReady();\n\n\t\t// Notify all waiting threads\n\t\thook->notifyAll();\n\t}\n\n\t// Unlock the hook's mutex\n\thook->unlock();\n\n\treturn true;\n}\n", "CodeBleu_score": 36.6298464405118}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()\tif (status() == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tthread_ = std::thread(&ThreadedAction::tickThread, this);\n\t}\n\n\tif (thread_.joinable()) {\n\t\tthread_.join();\n\n\t\tif (!halt_requested_) {\n\t\t\tstatus_ = status_tick_;\n\t\t}\n\t}\n\n\tif (exception_) {\n\t\ttry {\n\t\t\tstd::rethrow_exception(exception_);\n\t\t} catch (const std::exception& e) {\n\t\t\tLOG_ERROR << \"Exception in ThreadedAction: \" << e.what() << std::endl;\n\t\t}\n\n\t\tstatus_ = NodeStatus::IDLE;\n\t\texception_ = std::exception_ptr();\n\t}\n\n\treturn status();\n}\n", "CodeBleu_score": 40.56829985402216}, {"code": "NodeStatus BT::ThreadedAction::executeTick()\tif (status() == NodeStatus::IDLE) {\n\t\thalt_requested_ = false;\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\tthread_ = std::thread(&ThreadedAction::tickThread, this);\n\t}\n\n\tif (thread_.joinable()) {\n\t\tthread_.join();\n\t}\n\n\tif (exception_) {\n\t\ttry {\n\t\t\tstd::rethrow_exception(exception_);\n\t\t} catch (const std::exception& e) {\n\t\t\tLOG_ERROR << \"ThreadedAction::executeTick: exception caught: \" << e.what() << std::endl;\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\n\treturn status_;\n}\n", "CodeBleu_score": 30.39209713138911}, {"code": "NodeStatus BT::ThreadedAction::executeTick()\tif (status() == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\ttry {\n\t\t\ttick_thread_ = std::thread(&ThreadedAction::tick, this);\n\t\t\ttick_thread_.detach();\n\t\t} catch (const std::exception& e) {\n\t\t\tLOG_ERROR << \"ThreadedAction::executeTick: \" << e.what();\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\thalt_requested_ = false;\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (exception_) {\n\t\t\tstd::exception_ptr ex = exception_;\n\t\t\texception_ = std::exception_ptr();\n\t\t\tstd::rethrow_exception(ex);\n\t\t}\n\t}\n\treturn status();\n}\n", "CodeBleu_score": 43.19708443282281}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tauto print_node = [&stream](const TreeNode* node, int depth) {\n\t\tstream << std::string(depth * 2,'') << node->getName() << '\\n';\n\t\tif (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control_node->getChildren()) {\n\t\t\t\tprint_node(child, depth + 1);\n\t\t\t}\n\t\t} else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tprint_node(decorator_node->getChild(), depth + 1);\n\t\t}\n\t};\n\n\tstream << \"=====================================\\n\";\n\tprint_node(root_node, 0);\n\tstream << \"=====================================\\n\";\n}\n", "CodeBleu_score": 34.68318339080299}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tstream << \"====================================\" << std::endl;\n\tstream << \"Tree structure:\" << std::endl;\n\tstream << \"====================================\" << std::endl;\n\tauto print_node = [&stream](const TreeNode* node, int depth) {\n\t\tstream << std::string(depth,'') << node->getName() << std::endl;\n\t\tif (node->getType() == TreeNode::Type::CONTROL) {\n\t\t\tfor (auto child : node->getChildren()) {\n\t\t\t\tprint_node(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (node->getType() == TreeNode::Type::DECORATOR) {\n\t\t\tprint_node(node->getChild(), depth + 1);\n\t\t}\n\t};\n\tprint_node(root_node, 0);\n\tstream << \"====================================\" << std::endl;\n}\n", "CodeBleu_score": 37.195324892605406}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\t// Define a recursive lambda function to handle the printing\n\tauto printNode = [&stream](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"    \";\n\t\t}\n\t\t// Print the node's name\n\t\tstream << node->name << std::endl;\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (node->type == TreeNode::Type::Control) {\n\t\t\tfor (const auto& child : node->children) {\n\t\t\t\tprintNode(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (node->type == TreeNode::Type::Decorator) {\n\t\t\tprintNode(node->child, depth + 1);\n\t\t}\n\t};\n\t// Begin and end with separator lines\n\tstream << \"=========================\" << std::endl;\n\tprintNode(root_node, 0);\n\tstream << \"=========================\" << std::endl;\n}\n", "CodeBleu_score": 42.20548952078105}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow LogicError(\"Cannot apply a visitor to a null tree node\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->isControlNode()) {\n\t\tconst ControlNode* controlNode = static_cast<const ControlNode*>(node);\n\t\tconst std::vector<TreeNode*> children = controlNode->getChildren();\n\t\tfor (std::vector<TreeNode*>::const_iterator child = children.cbegin(); child!= children.cend(); ++child) {\n\t\t\tapplyRecursiveVisitor(*child, visitor);\n\t\t}\n\t} else if (node->isDecoratorNode()) {\n\t\tconst DecoratorNode* decoratorNode = static_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decoratorNode->getChild(), visitor);\n\t}\n}\n", "CodeBleu_score": 55.44806537226421}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow LogicError(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (node->getType() == ControlNode::Type) {\n\t\tconst ControlNode* controlNode = dynamic_cast<const ControlNode*>(node);\n\t\tfor (const TreeNode* child : controlNode->getChildren()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->getType() == DecoratorNode::Type) {\n\t\tconst DecoratorNode* decoratorNode = dynamic_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decoratorNode->getChild(), visitor);\n\t}\n}\n", "CodeBleu_score": 56.870958808384955}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow LogicError(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (node->getType() == TreeNode::CONTROL_NODE) {\n\t\tconst ControlNode* controlNode = static_cast<const ControlNode*>(node);\n\t\tfor (const TreeNode* child : controlNode->getChildren()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->getType() == TreeNode::DECORATOR_NODE) {\n\t\tconst DecoratorNode* decoratorNode = static_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decoratorNode->getChild(), visitor);\n\t}\n}\n", "CodeBleu_score": 56.05130642166725}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tauto it = _builders.find(manifest.registration_ID);\n\tif (it!= _builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder already registered: \" + manifest.registration_ID);\n\t}\n\n\t_builders[manifest.registration_ID] = builder;\n\t_manifests[manifest.registration_ID] = manifest;\n}\n", "CodeBleu_score": 53.1191095023529}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tconst std::string& registration_id = manifest.registration_id;\n\n\tif (builders_.find(registration_id)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with registration ID \" + registration_id + \" already registered.\");\n\t}\n\n\tbuilders_.insert(std::make_pair(registration_id, builder));\n\tmanifests_.insert(std::make_pair(registration_id, manifest));\n}\n\n}", "CodeBleu_score": 41.75325911025853}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tauto it = builders_.find(manifest.registration_ID);\n\tif (it!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"The ID '\" + manifest.registration_ID + \"' is already registered\");\n\t}\n\tbuilders_[manifest.registration_ID] = builder;\n\tmanifests_[manifest.registration_ID] = manifest;\n}\n", "CodeBleu_score": 53.64703147504122}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)#if defined(BT_DEBUG_LOG)\n  std::cout << \"Registering SimpleActionNode with ID: \" << ID << std::endl;", "CodeBleu_score": 14.73642742183734}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)#ifdef BT_DEBUG_LOG\n    if (ID.empty()) {\n        throw LogicError(\"BehaviorTreeFactory::registerSimpleAction: ID cannot be empty\");\n    }", "CodeBleu_score": 16.274872163255612}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)#ifdef BT_DEBUG_LOG\n  std::cout << \"Registering SimpleActionNode with ID: \" << ID << std::endl;", "CodeBleu_score": 14.580564873152499}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.subtrees.size());\n\tfor (auto& subtree : tree.subtrees) {\n\t\tauto backup = subtree->blackboard->Clone();\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}\n", "CodeBleu_score": 56.83704202147969}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.GetSubtrees().size());\n\tfor (const auto& subtree : tree.GetSubtrees()) {\n\t\tBlackboard::Ptr backup = subtree->GetBlackboard()->Clone();\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}\n", "CodeBleu_score": 52.30024287415136}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.GetSubtrees().size());\n\tfor (const auto& subtree : tree.GetSubtrees()) {\n\t\tauto backup = subtree->GetBlackboard()->Clone();\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}\n", "CodeBleu_score": 52.14992363393215}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn executor.error();\n\t}\n\treturn executor->Execute(env);\n}\n", "CodeBleu_score": 56.56552772168565}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn std::move(executor.error());\n\t}\n\treturn executor->Execute(env);\n}\n\n} // namespace Ast", "CodeBleu_score": 64.24973400589455}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn executor.error();\n\t}\n\treturn executor->Execute(env);\n}\n\n}", "CodeBleu_score": 57.1372680209693}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_handle) {\n\t\tthrow RuntimeError(\"Shared library already loaded.\");\n\t}\n\tm_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!m_handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tm_path = path;\n}\n", "CodeBleu_score": 47.1783523847218}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (handle) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tthis->path = path;\n}\n", "CodeBleu_score": 49.29610554154354}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (handle_) {\n\t\tthrow RuntimeError(\"Shared library already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle_) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tpath_ = path;\n}\n", "CodeBleu_score": 46.342482827084005}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.strip_edges();\n\tif (stripped[0]!= '{' || stripped[stripped.length() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer!= nullptr) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.length() - 2);\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 23.874721981831744}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.trim_whitespace();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 25.931360303285008}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.trim();\n\tif (stripped.length() < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped[0]!= '{' || stripped[stripped.length() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.length() - 2);\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 25.284840081332767}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble cost = 0.0;\n\tLineIterator line(x0, y0, x1, y1);\n\tfor (int i = 0; i < line.num_steps(); ++i, ++line) {\n\t\tdouble point_cost = pointCost(line.getX(), line.getY());\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tcost = std::max(cost, point_cost);\n\t}\n\treturn cost;\n}\n", "CodeBleu_score": 52.5905186861525}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble line_cost = 0.0;\n\tLineIterator line(x0, y0, x1, y1);\n\tfor (LineIterator::iterator it = line.begin(); it!= line.end(); ++it) {\n\t\tdouble point_cost = pointCost(it->x, it->y);\n\t\tif (point_cost < 0)\n\t\t\treturn point_cost;\n\t\tline_cost = std::max(line_cost, point_cost);\n\t}\n\treturn line_cost;\n}\n", "CodeBleu_score": 57.233435492078556}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble line_cost = 0.0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (LineIterator it = line; it!= line.end(); ++it) {\n\t\tdouble point_cost = pointCost(it->x, it->y);\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tline_cost = std::max(line_cost, point_cost);\n\t}\n\treturn line_cost;\n}\n\n} /* namespace costmap_2d */", "CodeBleu_score": 56.69297357605144}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}\n", "CodeBleu_score": 83.0224146170396}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\n\t\t// Extracting the path in a form that can be used by the Path message.\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\n\t\tpub.publish(gui_path);\n\t}\n}\n", "CodeBleu_score": 83.0224146170396}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}\n", "CodeBleu_score": 83.0224146170396}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\treturn (base_odom.twist.twist.angular.x <= rot_stopped_velocity && base_odom.twist.twist.angular.y <= rot_stopped_velocity && base_odom.twist.twist.angular.z <= rot_stopped_velocity && base_odom.twist.twist.linear.x <= trans_stopped_velocity && base_odom.twist.twist.linear.y <= trans_stopped_velocity && base_odom.twist.twist.linear.z <= trans_stopped_velocity);\n}\n", "CodeBleu_score": 49.8822643145556}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\treturn (base_odom.twist.twist.angular.x <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.angular.y <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.angular.z <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.y <= trans_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.z <= trans_stopped_velocity);\n}\n", "CodeBleu_score": 49.30055569197269}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\treturn (base_odom.twist.twist.angular.z <= rot_stopped_velocity && base_odom.twist.twist.angular.z >= -rot_stopped_velocity && base_odom.twist.twist.linear.x <= trans_stopped_velocity && base_odom.twist.twist.linear.x >= -trans_stopped_velocity);\n}\n", "CodeBleu_score": 54.94726504075835}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (setup_ && restore_defaults) {\n\t\tconfig = default_limits_;\n\t} else if (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tlimits_ = config;\n\tlimits_.acc_lim_theta = std::abs(limits_.acc_lim_theta);\n\tlimits_.acc_lim_x = std::abs(limits_.acc_lim_x);\n\tlimits_.acc_lim_y = std::abs(limits_.acc_lim_y);\n\tlimits_.max_vel_theta = std::abs(limits_.max_vel_theta);\n\tlimits_.min_vel_theta = -limits_.max_vel_theta;\n\tlimits_.min_vel_x = 0.0;\n\tlimits_.min_vel_y = 0.0;\n\tlimits_.max_vel_x = std::abs(limits_.max_vel_x);\n\tlimits_.max_vel_y = std::abs(limits_.max_vel_y);\n\tlimits_.min_in_place_vel_theta = std::abs(limits_.min_in_place_vel_theta);\n\tlimits_.yaw_goal_tolerance = std::abs(limits_.yaw_goal_tolerance);\n\tlimits_.xy_goal_tolerance = std::abs(limits_.xy_goal_tolerance);\n\tlimits_.prune_plan = std::abs(limits_.prune_plan);\n\tlimits_.sim_time = std::abs(limits_.sim_time);\n\tlimits_.sim_granularity = std::abs(limits_.sim_granularity);\n\tlimits_.angular_sim_granularity = std::abs(limits_.angular_sim_granularity);\n\tlimits_.vx_samples = std::abs(limits_.vx_samples);\n\tlimits_.vtheta_samples = std::abs(limits_.vtheta_samples);\n\tlimits_.occdist_scale = std::abs(limits_.occdist_scale);\n\tlimits_.path_distance_bias = std::abs(limits_.path_distance_bias);\n\tlimits_.goal_distance_bias = std::abs(limits_.goal_distance_bias);\n\tlimits_.pdist_scale = std::abs(limits_.pdist_scale", "CodeBleu_score": 55.95011972100292}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\tlimits_set_ = false;\n\t}\n\n\tif (!limits_set_) {\n\t\tdefault_limits_ = config;\n\t\tlimits_set_ = true;\n\t}\n\n\tconfig.acc_lim_x = fabs(config.acc_lim_x);\n\tconfig.acc_lim_y = fabs(config.acc_lim_y);\n\tconfig.acc_lim_theta = fabs(config.acc_lim_theta);\n\tconfig.acc_lim_trans = fabs(config.acc_lim_trans);\n\n\tconfig.max_vel_x = fabs(config.max_vel_x);\n\tconfig.min_vel_x = -1.0 * fabs(config.min_vel_x);\n\tconfig.max_vel_y = fabs(config.max_vel_y);\n\tconfig.min_vel_y = -1.0 * fabs(config.min_vel_y);\n\tconfig.max_vel_trans = fabs(config.max_vel_trans);\n\tconfig.min_vel_trans = -1.0 * fabs(config.min_vel_trans);\n\tconfig.max_vel_theta = fabs(config.max_vel_theta);\n\tconfig.min_vel_theta = -1.0 * fabs(config.min_vel_theta);\n\n\tconfig.min_in_place_vel_theta = fabs(config.min_in_place_vel_theta);\n\tconfig.escape_vel = -1.0 * fabs(config.escape_vel);\n\n\tconfig.xy_goal_tolerance = fabs(config.xy_goal_tolerance);\n\tconfig.yaw_goal_tolerance = fabs(config.yaw_goal_tolerance);\n\tconfig.latch_xy_goal_tolerance = config.latch_xy_goal_tolerance;\n\n\tconfig.sim_time = fabs(config.sim_time);\n\tconfig.sim_granularity = fabs(config.sim_granularity);\n\tconfig.angular_sim_granularity = fabs(config.angular_sim_granularity);\n\n\tconfig.vx_samples = abs(config.vx_samples);\n\tconfig.vtheta_samples = abs(", "CodeBleu_score": 47.52780834948266}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (setup_ && restore_defaults) {\n\t\t//restore to defaults\n\t\tconfig = default_limits_;\n\t}\n\n\tif (!setup_) {\n\t\t//initialize from config\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\t//lock and update limits\n\tlimits_configuration_mutex_.lock();\n\tlimits_ = config;\n\tlimits_configuration_mutex_.unlock();\n}\n", "CodeBleu_score": 66.27258784368853}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\tif (check_cell->isObstacle()) {\n\t\tcheck_cell->setTargetDistance(MAX_COST);\n\t\treturn false;\n\t}\n\n\t// Check if we can actually move to this cell\n\tif (costmap.getCost(check_cell->getPoint().x, check_cell->getPoint().y) == costmap_2d::NO_INFORMATION) {\n\t\tcheck_cell->setTargetDistance(MAX_COST);\n\t\treturn false;\n\t}\n\n\tdouble new_target_distance = current_cell->getTargetDistance() + 1.0;\n\tif (new_target_distance < check_cell->getTargetDistance()) {\n\t\tcheck_cell->setTargetDistance(new_target_distance);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 49.50383192338851}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\tif (check_cell->getCost() >= costmap.getObstacleCost() || check_cell->getCost() == costmap.getUnknownCost()) {\n\t\tcheck_cell->setTargetDistance(costmap.getObstacleCost());\n\t\treturn false;\n\t}\n\n\tdouble new_target_distance = current_cell->getTargetDistance() + 1;\n\tif (new_target_distance < check_cell->getTargetDistance()) {\n\t\tcheck_cell->setTargetDistance(new_target_distance);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 42.82751884315598}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false.\n\tif (check_cell->isObstacle() || check_cell->getCost() == NO_INFORMATION) {\n\t\tcheck_cell->setTargetDistance(MAX_OBSTACLE_COST);\n\t\treturn false;\n\t}\n\t// Calculate the new target distance by adding the current cell's target distance and the cost of the cell.\n\tdouble new_target_distance = current_cell->getTargetDistance() + check_cell->getCost();\n\t// If the new target distance is shorter than the current target distance, update the target distance and return true.\n\tif (new_target_distance < check_cell->getTargetDistance()) {\n\t\tcheck_cell->setTargetDistance(new_target_distance);\n\t\treturn true;\n\t}\n\t// If the new target distance is not shorter than the current target distance, return false.\n\treturn false;\n}\n\n}\n", "CodeBleu_score": 40.94067755018069}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tdouble cost = 0.0;\n\tdouble scale = 1.0;\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"No footprint specification for obstacle cost function.\");\n\t\treturn -1.0;\n\t}\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i).pose.position.x, traj.getPoint(i).pose.position.y, traj.getPoint(i).velocity.linear.x);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost * scale;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost * scale);\n\t\t\t}\n\t\t}\n\t\tscale *= scale_gain_;\n\t}\n\treturn cost;\n}\n\n} /* namespace sbpl_lattice_planner */", "CodeBleu_score": 49.00422619799753}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tdouble cost = 0.0;\n\tdouble scale = 1.0;\n\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"No footprint points received for obstacle cost calculation\");\n\t\treturn -9.0;\n\t}\n\n\t//check if the robot is within its footprint\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble x = traj.getPoint(i).pose.position.x;\n\t\tdouble y = traj.getPoint(i).pose.position.y;\n\n\t\tdouble footprint_cost = footprintCost(x, y);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost * scale;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost * scale);\n\t\t}\n\t}\n\n\treturn cost;\n}\n", "CodeBleu_score": 53.893073800217586}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"No footprint specified for obstacle cost function.\");\n\t\treturn -9.0;\n\t}\n\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i), footprint_spec_, inscribed_radius_, circumscribed_radius_);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\tif (sum_scores_) {\n\t\t\tcost += scaling_factor * footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, scaling_factor * footprint_cost);\n\t\t}\n\t}\n\treturn cost;\n}\n\n} /* namespace base_local_planner */", "CodeBleu_score": 51.92702404517946}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\t// scale the footprint points by the given scale factor\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tfootprint_spec[i].x *= scale;\n\t\tfootprint_spec[i].y *= scale;\n\t}\n\t// compute the footprint cost using a world model\n\tdouble cost = world_model->footprintCost(x, y, th, footprint_spec);\n\t// if the cost is negative, return -6.0\n\tif (cost < 0) {\n\t\treturn -6.0;\n\t}\n\t// if the position is off the map, return -7.0\n\tunsigned int cell_x, cell_y;\n\tif (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n\t\treturn -7.0;\n\t}\n\t// return the maximum cost between the footprint cost and the cell cost at the given position\n\tdouble cell_cost = costmap->getCost(cell_x, cell_y);\n\treturn std::max(cost, cell_cost);\n}\n", "CodeBleu_score": 61.90296165795548}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\t// Scale the footprint points by the scale factor\n\tfor (unsigned int i = 0; i < footprint_spec.size(); i++) {\n\t\tfootprint_spec[i].x *= scale;\n\t\tfootprint_spec[i].y *= scale;\n\t}\n\t// Compute the footprint cost\n\tdouble cost = world_model->footprintCost(x, y, th, footprint_spec);\n\t// If the cost is negative, return -6.0\n\tif (cost < 0) {\n\t\treturn -6.0;\n\t}\n\t// If the position is off the map, return -7.0\n\tunsigned int cell_x, cell_y;\n\tif (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n\t\treturn -7.0;\n\t}\n\t// Return the maximum cost between the footprint cost and the cell cost at the given position\n\treturn std::max(cost, costmap->getCost(cell_x, cell_y));\n}\n", "CodeBleu_score": 58.37839308267526}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\t// scale the footprint\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tfootprint_spec[i].x *= scale;\n\t\tfootprint_spec[i].y *= scale;\n\t}\n\n\t// calculate cost of the footprint at (x, y, th)\n\tdouble footprint_cost = world_model->footprintCost(x, y, th, footprint_spec, costmap);\n\n\t// if the footprint cost is negative, return -6.0\n\tif (footprint_cost < 0) {\n\t\treturn -6.0;\n\t}\n\n\t// get the cell cost at (x, y)\n\tunsigned int cell_x, cell_y;\n\tcostmap->worldToMap(x, y, cell_x, cell_y);\n\tdouble cell_cost = costmap->getCost(cell_x, cell_y);\n\n\t// if the cell cost is unknown, return -7.0\n\tif (costmap->getCost(cell_x, cell_y) == costmap_2d::NO_INFORMATION) {\n\t\treturn -7.0;\n\t}\n\n\t// return the maximum cost between the footprint cost and the cell cost\n\treturn std::max(footprint_cost, cell_cost);\n}\n", "CodeBleu_score": 63.1986760276128}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic!= _odom_topic) {\n\t\t_odom_topic = odom_topic;\n\t\tif (_odom_topic.empty()) {\n\t\t\tif (_odom_sub) {\n\t\t\t\t_odom_sub.shutdown();\n\t\t\t}\n\t\t} else {\n\t\t\t_odom_sub = _nh.subscribe(_odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.46395578167119}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic_.empty()) {\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.715911814377286}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic.compare(odom_topic_)!= 0) {\n\t\todom_topic_ = odom_topic;\n\t\tif (odom_topic_.size() > 0) {\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.346022868676044}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tfloat dx = pos.x() - prev.x();\n\tfloat dy = pos.y() - prev.y();\n\tfloat dz = pos.z() - prev.z();\n\tfloat squared_distance = dx * dx + dy * dy + dz * dz;\n\tif (squared_distance > squared_distance_threshold_) {\n\t\tif (reset_oscillation_flags_) {\n\t\t\t// reset oscillation flags\n\t\t\toscillation_x_ = false;\n\t\t\toscillation_y_ = false;\n\t\t\toscillation_z_ = false;\n\t\t\toscillation_xy_ = false;\n\t\t\toscillation_xyz_ = false;\n\t\t}\n\t\treturn;\n\t}\n\n\tfloat angle = fabs(atan2(dy, dx));\n\tif (angle > angle_threshold_) {\n\t\tif (reset_oscillation_flags_) {\n\t\t\t// reset oscillation flags\n\t\t\toscillation_x_ = false;\n\t\t\toscillation_y_ = false;\n\t\t\toscillation_z_ = false;\n\t\t\toscillation_xy_ = false;\n\t\t\toscillation_xyz_ = false;\n\t\t}\n\t\treturn;\n\t}\n\n\tangle = fabs(atan2(dz, sqrt(dx * dx + dy * dy)));\n\tif (angle > angle_threshold_) {\n\t\tif (reset_oscillation_flags_) {\n\t\t\t// reset oscillation flags\n\t\t\toscillation_x_ = false;\n\t\t\toscillation_y_ = false;\n\t\t\toscillation_z_ = false;\n\t\t\toscillation_xy_ = false;\n\t\t\toscillation_xyz_ = false;\n\t\t}\n\t\treturn;\n\t}\n}\n", "CodeBleu_score": 37.232070183407664}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tfloat dx = pos.x() - prev.x();\n\tfloat dy = pos.y() - prev.y();\n\tfloat dz = pos.z() - prev.z();\n\tfloat squared_dist = dx * dx + dy * dy + dz * dz;\n\n\tif (squared_dist > squared_distance_threshold_) {\n\t\tfloat yaw = tf::getYaw(tf::createQuaternionFromYaw(tf::getYaw(tf::createQuaternionFromRPY(0, 0, pos.z()))));\n\t\tfloat prev_yaw = tf::getYaw(tf::createQuaternionFromYaw(tf::getYaw(tf::createQuaternionFromRPY(0, 0, prev.z()))));\n\t\tfloat yaw_diff = angles::shortest_angular_distance(yaw, prev_yaw);\n\t\tif (fabs(yaw_diff) > yaw_threshold_) {\n\t\t\toscillation_flags_.reset();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.37840841750384}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\t// Check if the robot has moved far enough\n\tfloat dist_sq = (pos - prev).squaredNorm();\n\tif (dist_sq < min_dist_sq_) {\n\t\t// The robot has not moved far enough\n\t\treturn;\n\t}\n\n\t// Check if the robot has turned enough\n\tfloat yaw_diff = fabs(angles::shortest_angular_distance(tf::getYaw(prev.head<3>()), tf::getYaw(pos.head<3>())));\n\tif (yaw_diff < min_angle_) {\n\t\t// The robot has not turned enough\n\t\treturn;\n\t}\n\n\t// Reset the oscillation flags\n\toscillation_ = false;\n\toscillation_reset_ = false;\n}\n\n} /* namespace global_planner */", "CodeBleu_score": 30.577143784870298}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// determine grid coordinates\n\tint x = (pt.x - min_x_) / cell_size_;\n\tint y = (pt.y - min_y_) / cell_size_;\n\n\t// if point is outside the grid bounds, return\n\tif (x < 0 || x >= width_ || y < 0 || y >= height_)\n\t\treturn;\n\n\t// if point is too close to its nearest neighbor, return\n\tif (min_dist_ > 0) {\n\t\t// determine nearest neighbor\n\t\tgeometry_msgs::Point32 nn;\n\t\tif (getNearestNeighbor(pt, nn)) {\n\t\t\tdouble dist = sqrt(pow(pt.x - nn.x, 2) + pow(pt.y - nn.y, 2));\n\t\t\tif (dist < min_dist_)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// calculate grid index\n\tint index = y * width_ + x;\n\n\t// insert point into the corresponding cell\n\tcells_[index].push_back(pt);\n}\n", "CodeBleu_score": 42.192318579108566}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// Check if the point is within the grid bounds\n\tif (pt.x < x_min_ || pt.x > x_max_ || pt.y < y_min_ || pt.y > y_max_) {\n\t\treturn;\n\t}\n\n\t// Check if the point is too close to its nearest neighbor\n\tdouble dist = std::numeric_limits<double>::max();\n\tfor (auto& pt_near : points_near_) {\n\t\tdouble dist_temp = sqrt(pow(pt.x - pt_near.x, 2) + pow(pt.y - pt_near.y, 2));\n\t\tif (dist_temp < dist) {\n\t\t\tdist = dist_temp;\n\t\t}\n\t}\n\tif (dist < min_dist_) {\n\t\treturn;\n\t}\n\n\t// Get the grid coordinates\n\tint x_coord = (pt.x - x_min_) / cell_size_;\n\tint y_coord = (pt.y - y_min_) / cell_size_;\n\n\t// Get the grid index\n\tint index = x_coord + y_coord * num_cells_x_;\n\n\t// Insert the point into the grid\n\tgrid_[index].push_back(pt);\n}\n", "CodeBleu_score": 36.96347541661337}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// get grid coordinates\n\tint x = getGridCoord(pt.x);\n\tint y = getGridCoord(pt.y);\n\n\t// check if point is inside grid\n\tif (x < 0 || x >= grid_width_ || y < 0 || y >= grid_height_)\n\t\treturn;\n\n\t// check if point is too close to its nearest neighbor\n\tif (getNearestNeighbor(pt) < min_dist_)\n\t\treturn;\n\n\t// calculate grid index\n\tint index = x + y * grid_width_;\n\n\t// insert point\n\tgrid_[index].push_back(pt);\n}\n", "CodeBleu_score": 47.22229036303764}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel(i) > vel(i)) {\n\t\t\tnew_vel(i) = std::min(sample_target_vel(i), vel(i) + acclimits(i) * dt);\n\t\t} else if (sample_target_vel(i) < vel(i)) {\n\t\t\tnew_vel(i) = std::max(sample_target_vel(i), vel(i) - acclimits(i) * dt);\n\t\t} else {\n\t\t\tnew_vel(i) = vel(i);\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 62.16774247453463}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel(i) > vel(i)) {\n\t\t\tnew_vel(i) = std::min(sample_target_vel(i), vel(i) + acclimits(i) * dt);\n\t\t} else {\n\t\t\tnew_vel(i) = std::max(sample_target_vel(i), vel(i) - acclimits(i) * dt);\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 63.76161024856544}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\n\treturn new_vel;\n}\n", "CodeBleu_score": 75.18591071566837}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble best_dist = DBL_MAX;\n\tdouble best_angle = 0.0;\n\tdouble best_x = 0.0;\n\tdouble best_y = 0.0;\n\tdouble angle_to_goal = 0.0;\n\tint n = costmap_2d::NO_INFORMATION;\n\tint i = costmap_2d_.getSizeInCellsX() * costmap_2d_.getSizeInCellsY();\n\n\t//iterate through the global plan in reverse order\n\twhile (i--) {\n\t\t//get the map coordinates of the current point in the plan\n\t\tint mx = costmap_2d_.getOriginX() + costmap_2d_.getSizeInCellsX() / 2 + costmap_2d_.getCostmap()->getCostmap2D()->getSizeInCellsX() / 2 - cell_x;\n\t\tint my = costmap_2d_.getOriginY() + costmap_2d_.getSizeInCellsY() / 2 + costmap_2d_.getCostmap()->getCostmap2D()->getSizeInCellsY() / 2 - cell_y;\n\n\t\t//check if the current point is within the costmap\n\t\tif (mx < 0 || my < 0 || mx >= costmap_2d_.getSizeInCellsX() || my >= costmap_2d_.getSizeInCellsY())\n\t\t\tcontinue;\n\n\t\t//get the cost of the current point in the costmap\n\t\tn = costmap_2d_.getCost(mx, my);\n\n\t\t//if the cost is not lethal, check if the line of sight to the current point is clear\n\t\tif (n!= costmap_2d::LETHAL_OBSTACLE && n!= costmap_2d::NO_INFORMATION && n!= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\t\t//get the world coordinates of the current point\n\t\t\tdouble world_x = costmap_2d_.getOriginX() + (mx + 0.5) * costmap_2d_.getResolution();\n\t\t\tdouble world_y = costmap_2d_.getOriginY() + (my + 0.5) * costmap_2d_.getResolution();\n\n\t\t\t//check", "CodeBleu_score": 27.71729601728945}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble goal_x, goal_y, dx, dy, angle;\n\tdouble max_dist = 0;\n\tdouble max_angle = 0;\n\tbool valid = false;\n\tdouble theta = tf::getYaw(global_plan[0].pose.orientation);\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\tint x = global_plan[i].pose.position.x;\n\t\tint y = global_plan[i].pose.position.y;\n\t\tif (path_map[y][x] == 0) {\n\t\t\tgoal_x = global_plan[i].pose.position.x;\n\t\t\tgoal_y = global_plan[i].pose.position.y;\n\t\t\tdx = goal_x - x;\n\t\t\tdy = goal_y - y;\n\t\t\tangle = atan2(dy, dx);\n\t\t\tif (angle < 0)\n\t\t\t\tangle += 2 * M_PI;\n\t\t\tdouble dist = sqrt(pow(dx, 2) + pow(dy, 2));\n\t\t\tif (dist > max_dist) {\n\t\t\t\tmax_dist = dist;\n\t\t\t\tmax_angle = angle;\n\t\t\t\tvalid = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (valid) {\n\t\tgoal_x = costmap_2d::Costmap2D::MAP_TO_WORLD(goal_x);\n\t\tgoal_y = costmap_2d::Costmap2D::MAP_TO_WORLD(goal_y);\n\t\tdx = goal_x - x;\n\t\tdy = goal_y - y;\n\t\tangle = atan2(dy, dx);\n\t\tif (angle < 0)\n\t\t\tangle += 2 * M_PI;\n\t\tdouble diff = fabs(angle - heading);\n\t\tif (diff > M_PI)\n\t\t\tdiff = 2 * M_PI - diff;\n\t\treturn diff;\n\t} else\n\t\treturn DBL_MAX;\n}\n", "CodeBleu_score": 47.63347527263772}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\t// Get the current cell coordinates\n\tint current_cell_x = cell_x;\n\tint current_cell_y = cell_y;\n\n\t// Get the current heading\n\tdouble current_heading = heading;\n\n\t// Get the global plan\n\tstd::vector<geometry_msgs::PoseStamped> global_plan = planner_.getPlan();\n\n\t// Iterate through the global plan in reverse\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\t// Get the current pose in the global plan\n\t\tgeometry_msgs::PoseStamped pose = global_plan[i];\n\n\t\t// Convert the pose to map coordinates\n\t\tint goal_cell_x = costmap_ros_->getCostmap()->getCostmapCellCoord(pose.pose.position.x, pose.pose.position.y, current_cell_x, current_cell_y);\n\n\t\t// Check if the goal cell is valid\n\t\tif (goal_cell_x >= 0 && goal_cell_y >= 0) {\n\t\t\t// Convert the goal cell coordinates to world coordinates\n\t\t\tdouble goal_x = costmap_ros_->getCostmap()->getCostmap()->getOriginX() + goal_cell_x * costmap_ros_->getCostmap()->getCostmap()->getResolution();\n\t\t\tdouble goal_y = costmap_ros_->getCostmap()->getCostmap()->getOriginY() + goal_cell_y * costmap_ros_->getCostmap()->getCostmap()->getResolution();\n\n\t\t\t// Calculate the direction to the goal point\n\t\t\tdouble direction = atan2(goal_y - y, goal_x - x);\n\n\t\t\t// Calculate the shortest angular distance between the current heading and the direction to the goal point\n\t\t\tdouble diff = angles::shortest_angular_distance(current_heading, direction);\n\n\t\t\t// Return the absolute value of the shortest angular distance\n\t\t\treturn std::abs(diff);\n\t\t}\n\t}\n\n\t// If no valid point is found, return DBL_MAX\n\treturn DBL_MAX;\n}\n", "CodeBleu_score": 46.15111878262092}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t}\n\tROS_WARN(\"Invalid Trajectory: x: %.2f, y: %.2f, theta: %.2f, vx: %.2f, vy: %.2f, vtheta: %.2f, vx_samp: %.2f, vy_samp: %.2f, vtheta_samp: %.2f, cost: %.2f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n\treturn false;\n}\n", "CodeBleu_score": 74.96829018207197}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\t// Compute the cost of the trajectory\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n\t// If the cost is non-negative, the trajectory is valid\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\t// The trajectory is invalid, log a warning\n\t\tROS_WARN(\"Invalid trajectory: x=%f, y=%f, theta=%f, vx=%f, vy=%f, vtheta=%f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f, cost=%f\",\n\t\t\t\tx, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 72.47213462238426}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN(\"Invalid Trajectory: x: %.2f, y: %.2f, theta: %.2f, vx: %.2f, vy: %.2f, vtheta: %.2f, vx_samp: %.2f, vy_samp: %.2f, vtheta_samp: %.2f, cost: %.2f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 73.02963816173245}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not set the global_costmap and local_costmap parameters of the node.\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside the area to clear\");\n\t} else {\n\t\tROS_WARN(\"Clearing inside the area to clear\");\n\t}\n\n\tif (clear_global_costmap_) {\n\t\tROS_INFO(\"Clearing global costmap\");\n\t\tglobal_costmap_->clearArea(clear_point_.x, clear_point_.y, clear_radius_, clear_radius_);\n\t}\n\n\tif (clear_local_costmap_) {\n\t\tROS_INFO(\"Clearing local costmap\");\n\t\tlocal_costmap_->clearArea(clear_point_.x, clear_point_.y, clear_radius_, clear_radius_);\n\t}\n\n\tif (force_update_) {\n\t\tROS_INFO(\"Forcing a map update\");\n\t\tlocal_costmap_->updateMap();\n\t\tglobal_costmap_->updateMap();\n\t}\n}\n\n} /* namespace clear_costmap_recovery */", "CodeBleu_score": 43.32553990567439}, {"code": "void ClearCostmapRecovery::runBehavior()\tif(!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif(global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not set the global_costmap and local_costmap parameters.\");\n\t\treturn;\n\t}\n\n\tif(invert_area_to_clear_) {\n\t\tROS_WARN(\"The invert_area_to_clear parameter is set to true. The area to be cleared will be inside the specified bounds instead of outside.\");\n\t}\n\n\tros::Time start = ros::Time::now();\n\n\tif(affected_maps_ & CLEAR_GLOBAL_MAP) {\n\t\tif(invert_area_to_clear_) {\n\t\t\tglobal_costmap_->clearAreaOutsideBounds(min_x_, min_y_, max_x_, max_y_);\n\t\t} else {\n\t\t\tglobal_costmap_->clearAreaInsideBounds(min_x_, min_y_, max_x_, max_y_);\n\t\t}\n\n\t\tif(force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t}\n\n\tif(affected_maps_ & CLEAR_LOCAL_MAP) {\n\t\tif(invert_area_to_clear_) {\n\t\t\tlocal_costmap_->clearAreaOutsideBounds(min_x_, min_y_, max_x_, max_y_);\n\t\t} else {\n\t\t\tlocal_costmap_->clearAreaInsideBounds(min_x_, min_y_, max_x_, max_y_);\n\t\t}\n\n\t\tif(force_update_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t}\n\n\tros::Time end = ros::Time::now();\n\tROS_INFO(\"Clearing costmap took %f seconds\", (end - start).toSec());\n}\n\n} /* namespace clear_costmap_recovery */", "CodeBleu_score": 52.29899417656573}, {"code": "void ClearCostmapRecovery::runBehavior()\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not set the costmaps from within the constructor of the recovery behavior, but in the initialize function.\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside of the specified area\");\n\t} else {\n\t\tROS_WARN(\"Clearing inside of the specified area\");\n\t}\n\n\tif (clear_global_costmap_) {\n\t\tROS_INFO(\"Clearing global costmap\");\n\t\tglobal_costmap_->resetLayers();\n\t}\n\n\tif (clear_local_costmap_) {\n\t\tROS_INFO(\"Clearing local costmap\");\n\t\tlocal_costmap_->resetLayers();\n\t}\n\n\tif (force_update_) {\n\t\tROS_INFO(\"Forcing a map update\");\n\t\tglobal_costmap_->updateMap();\n\t\tlocal_costmap_->updateMap();\n\t}\n}\n\n} /* namespace clear_costmap_recovery */\n\n\treturn 0;\n}", "CodeBleu_score": 38.57837756941157}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tpolygon_cells.clear();\n\tPolygonOutlineCells collector(polygon_cells);\n\tfor (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(polygon[i], polygon[i + 1], collector);\n\t}\n\traytraceLine(polygon.back(), polygon.front(), collector);\n}\n", "CodeBleu_score": 49.19528584522314}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tPolygonOutlineCells collector(this, polygon_cells);\n\tfor (size_t i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(polygon[i], polygon[i + 1], collector);\n\t}\n\traytraceLine(polygon.back(), polygon.front(), collector);\n}\n", "CodeBleu_score": 45.35372252503966}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tPolygonOutlineCells collector(polygon_cells);\n\tif (!polygon.empty()) {\n\t\tfor (unsigned int i = 1; i < polygon.size(); ++i) {\n\t\t\traytraceLine(polygon[i - 1], polygon[i], collector);\n\t\t}\n\t\traytraceLine(polygon.back(), polygon.front(), collector);\n\t}\n}\n", "CodeBleu_score": 38.904123333391574}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\tROS_DEBUG(\"New subscriber.\");\n\tif (!prepareGrid()) {\n\t\tROS_ERROR(\"Failed to prepare grid.\");\n\t\treturn;\n\t}\n\n\tpub.publish(grid_);\n}\n", "CodeBleu_score": 55.351883614026654}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t// prepare the grid\n\tprepareGrid();\n\t// publish the grid\n\tpub.publish(grid_);\n}\n", "CodeBleu_score": 69.99328108777213}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t// Prepare the grid data\n\tprepareGrid();\n\n\t// Publish the grid data\n\tpub.publish(grid_);\n}\n", "CodeBleu_score": 68.7925970289949}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tresolution_ = costmap_->getResolution();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.info.resolution = resolution_;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\torigin_x_ = costmap_->getOriginX();\n\torigin_y_ = costmap_->getOriginY();\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tunsigned char* char_map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = char_to_grid_[char_map[i]];\n\t}\n}\n", "CodeBleu_score": 66.24190163885957}, {"code": "void Costmap2DPublisher::prepareGrid()\tcostmap_2d::Costmap2D* costmap = costmap_ros_->getCostmap();\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap->getMutex()));\n\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_ros_->getGlobalFrameID();\n\n\tgrid_.info.resolution = costmap->getResolution();\n\tgrid_.info.width = costmap->getSizeInCellsX();\n\tgrid_.info.height = costmap->getSizeInCellsY();\n\n\tdouble wx, wy;\n\tcostmap->mapToWorld(0, 0, wx, wy);\n\tgrid_.info.origin.position.x = wx - grid_.info.resolution / 2;\n\tgrid_.info.origin.position.y = wy - grid_.info.resolution / 2;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\torigin_x_ = wx;\n\torigin_y_ = wy;\n\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\tfor (unsigned int i = 0; i < grid_.info.width * grid_.info.height; ++i) {\n\t\tgrid_.data[i] = costmap->getCharMap()[i];\n\t}\n}\n", "CodeBleu_score": 65.96093017129414}, {"code": "void Costmap2DPublisher::prepareGrid()\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tresolution_ = costmap_->getResolution();\n\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.info.resolution = resolution_;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\tdouble wx, wy;\n\tcostmap_->mapToWorld(0, 0, wx, wy);\n\tgrid_.info.origin.position.x = wx - resolution_ / 2;\n\tgrid_.info.origin.position.y = wy - resolution_ / 2;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\torigin_x_ = wx;\n\torigin_y_ = wy;\n\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\tunsigned char* char_map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.info.width * grid_.info.height; ++i) {\n\t\tgrid_.data[i] = char_to_int[char_map[i]];\n\t}\n}\n", "CodeBleu_score": 78.687930541672}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\tif (new_config.footprint!= old_config.footprint || new_config.robot_radius!= old_config.robot_radius) {\n\t\tstd::vector<geometry_msgs::Point> new_footprint;\n\t\tif (!new_config.footprint.empty()) {\n\t\t\tif (costmap_2d::parseFootprintMsg(new_config.footprint, new_footprint)) {\n\t\t\t\tsetFootprint(new_footprint);\n\t\t\t} else {\n\t\t\t\tROS_ERROR(\"Failed to parse the footprint string.\");\n\t\t\t}\n\t\t} else {\n\t\t\tsetRobotFootprintCost(new_config.robot_radius);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 54.89770626903265}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.size() > 0) {\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (costmap_2d::convertToFootprint(new_config.footprint, footprint)) {\n\t\t\tsetFootprint(footprint);\n\t\t} else {\n\t\t\tROS_ERROR(\"Failed to parse footprint parameter\");\n\t\t}\n\t} else {\n\t\tsetRobotFootprintRadius(new_config.robot_radius);\n\t}\n}\n", "CodeBleu_score": 61.32083794961349}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\tif (new_config.footprint!= old_config.footprint) {\n\t\tif (new_config.footprint.empty()) {\n\t\t\tstd::vector<geometry_msgs::Point> new_footprint;\n\t\t\tdouble radius = new_config.robot_radius;\n\t\t\tnew_footprint.push_back(geometry_msgs::Point());\n\t\t\tnew_footprint.push_back(geometry_msgs::Point());\n\t\t\tnew_footprint.push_back(geometry_msgs::Point());\n\t\t\tnew_footprint.push_back(geometry_msgs::Point());\n\t\t\tnew_footprint[0].x = radius;\n\t\t\tnew_footprint[0].y = radius;\n\t\t\tnew_footprint[1].x = radius;\n\t\t\tnew_footprint[1].y = -radius;\n\t\t\tnew_footprint[2].x = -radius;\n\t\t\tnew_footprint[2].y = -radius;\n\t\t\tnew_footprint[3].x = -radius;\n\t\t\tnew_footprint[3].y = radius;\n\t\t\tsetFootprint(new_footprint);\n\t\t} else {\n\t\t\tstd::vector<geometry_msgs::Point> new_footprint;\n\t\t\tif (costmap_2d::parseFootprintString(new_config.footprint, new_footprint)) {\n\t\t\t\tsetFootprint(new_footprint);\n\t\t\t} else {\n\t\t\t\tROS_ERROR(\"Failed to parse the footprint string \\\"%s\\\"\", new_config.footprint.c_str());\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.70993485705062}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\ttf::Stamped<tf::Pose> new_pose;\n\tif (!tf_.getRobotPose(new_pose)) {\n\t\tROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\t//we also want to check if the pose has changed enough to matter to our costmaps\n\tif (new_pose.frame_id_!= global_frame_) {\n\t\tROS_WARN(\"The costmap's global frame (%s) is different than the robot's frame (%s)!  This means that the costmap isn't connected to the robot's pose.  This error often happens when a user fails to set the robot's pose on the parameter server.  For more information, see http://wiki.ros.org/navigation/Tutorials/RobotSetup/TF\", global_frame_.c_str(), new_pose.frame_id_.c_str());\n\t\treturn;\n\t}\n\n\tdouble x = new_pose.getOrigin().x();\n\tdouble y = new_pose.getOrigin().y();\n\n\tif (last_pose_set_ && (x == last_pose_.x) && (y == last_pose_.y)) {\n\t\treturn;\n\t}\n\n\tlast_pose_.x = x;\n\tlast_pose_.y = y;\n\tlast_pose_set_ = true;\n\n\t//we need to be able to publish a tf for the pose we're projecting into the past\n\ttf::Stamped<tf::Pose> ident (tf::Transform(tf::createIdentityQuaternion(), tf::Vector3(x,y,0.0)), ros::Time::now(), global_frame_);\n\ttf_.sendTransform(ident);\n\n\t//we also want to check if the pose has changed enough to matter to our costmaps\n\tif (!layered_costmap_->isCurrent()) {\n\t\tlayered_costmap_->updateMap(last_pose_.x, last_pose_.y, last_pose_.theta);\n\t}\n}\n", "CodeBleu_score": 46.53670011264394}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\ttf::Stamped<tf::Pose> new_pose;\n\tif (!tf_.getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Could not get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\t//we also want to check if the pose has changed enough to matter to our costmaps\n\tif (new_pose.frame_id_!= current_pose_.frame_id_ ||!tolerantCompare(new_pose.getOrigin(), current_pose_.getOrigin())\n\t\t\t||!tolerantCompare(new_pose.getRotation(), current_pose_.getRotation())) {\n\t\tcurrent_pose_ = new_pose;\n\t\treconfigureCB(reconfigure_server_, config_);\n\t}\n}\n", "CodeBleu_score": 62.68040936186304}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\t//get the robot's pose\n\tgeometry_msgs::PoseStamped new_pose;\n\ttf::Stamped<tf::Pose> tf_pose;\n\tif(!tf_.waitForTransform(global_frame_, robot_base_frame_, ros::Time(), ros::Duration(0.1))){\n\t\tROS_WARN(\"Could not get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\ttry {\n\t\ttf_.lookupTransform(global_frame_, robot_base_frame_, ros::Time(), tf_pose);\n\t} catch(tf::TransformException &ex) {\n\t\tROS_WARN(\"%s\",ex.what());\n\t\treturn;\n\t}\n\tposeStampedTFToMsg(tf_pose, new_pose);\n\n\t//we also want to check if the new pose has changed enough to warrant a replan\n\tif(planner_!= NULL){\n\t\tif(planner_->checkTrajectory(old_pose_, new_pose)){\n\t\t\t//if the planner changes the old_pose we'll want to plan again\n\t\t\told_pose_ = new_pose;\n\t\t\tplanner_plan(new_pose, default_goal_);\n\t\t}\n\t}\n\told_pose_ = new_pose;\n}\n", "CodeBleu_score": 50.754054432816446}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()\tif (!stopped_) {\n\t\treturn;\n\t}\n\n\t// activate plugins\n\tfor (unsigned int i = 0; i < plugins_.size(); ++i) {\n\t\tplugins_[i]->activate();\n\t}\n\n\tstopped_ = false;\n\n\tstop_updates_ = false;\n\n\t// wait for initialization\n\twhile (ros::ok() &&!initialized_) {\n\t\tROS_DEBUG(\"Waiting for costmap initialization...\");\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// wait for the map update thread to start\n\twhile (ros::ok() &&!map_update_thread_ &&!stop_updates_) {\n\t\tROS_DEBUG(\"Waiting for map update thread to start...\");\n\t\tros::Duration(0.1).sleep();\n\t}\n}\n", "CodeBleu_score": 41.53893674850352}, {"code": "void Costmap2DROS::start()\tif (stopped_) {\n\t\tstd::vector<boost::shared_ptr<Layer> > plugins = layered_costmap_->getPlugins();\n\t\tBOOST_FOREACH(boost::shared_ptr<Layer> plugin, plugins) {\n\t\t\tplugin->activate();\n\t\t}\n\t\tstopped_ = false;\n\t}\n\tstop_updates_ = false;\n\n\t// wait for costmap to be ready\n\tros::Rate r(10);\n\twhile (!layered_costmap_->isCurrent() && ros::ok()) {\n\t\tROS_DEBUG(\"Waiting for costmap to become available...\");\n\t\tr.sleep();\n\t}\n\n\tif (ros::ok()) {\n\t\tmap_update_thread_ = boost::shared_ptr<boost::thread>(\n\t\t\t\tnew boost::thread(boost::bind(&Costmap2DROS::updateMap, this)));\n\t}\n}\n", "CodeBleu_score": 54.11914769699698}, {"code": "void Costmap2DROS::start()\tboost::unique_lock<boost::recursive_mutex> lock_plugins(*plugin_mutex_);\n\tif (stopped_) {\n\t\tROS_INFO(\"Starting costmap\");\n\t\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin!= plugins_.end(); ++plugin) {\n\t\t\t(*plugin)->activate();\n\t\t}\n\t\tstopped_ = false;\n\t}\n\tlock_plugins.unlock();\n\tstop_updates_ = false;\n\twhile (!ros::ok() ||!layered_costmap_->isInitialized() ||!layered_costmap_->isSizeLocked()) {\n\t\tif (!ros::ok()) {\n\t\t\tROS_ERROR(\"Costmap2DROS is shutting down. Do not call start() after the first call to shutdown().\");\n\t\t\treturn;\n\t\t}\n\t\tif (!layered_costmap_->isInitialized()) {\n\t\t\tROS_WARN_STREAM_THROTTLE(1.0, \"Costmap2DROS: Waiting for the layered_costmap to be initialized. \" << layered_costmap_->getLayeredCostmap()->getCurrentBounds());\n\t\t}\n\t\tif (!layered_costmap_->isSizeLocked()) {\n\t\t\tROS_WARN_STREAM_THROTTLE(1.0, \"Costmap2DROS: Waiting for the size to be locked by the layered_costmap. \" << layered_costmap_->getLayeredCostmap()->getCurrentBounds());\n\t\t}\n\t\tros::Duration(0.1).sleep();\n\t}\n\tupdateLoop();\n}\n", "CodeBleu_score": 54.50222876237203}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\tif (observation_list_.size() > 1) {\n\t\t\tobservation_list_.erase(observation_list_.begin() + 1,\n\t\t\t\t\tobservation_list_.end());\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i < observation_list_.size(); i++) {\n\t\t\tif (observation_list_[i].timestamp()\n\t\t\t\t\t+ observation_keep_time_ >= ros::Time::now().toSec()) {\n\t\t\t\tobservation_list_.erase(observation_list_.begin() + i,\n\t\t\t\t\t\tobservation_list_.end());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.92077905727042}, {"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\tif (observation_list_.size() > 1) {\n\t\t\tobservation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n\t\t}\n\t} else {\n\t\tuint64_t oldest_valid_time = observation_list_.back().timestamp - observation_keep_time_;\n\t\tauto it = observation_list_.begin();\n\t\twhile (it!= observation_list_.end()) {\n\t\t\tif (it->timestamp >= oldest_valid_time) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tit = observation_list_.erase(it);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 39.92068949550638}, {"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\tobservation_list_.clear();\n\t} else {\n\t\tauto it = observation_list_.begin();\n\t\twhile (it!= observation_list_.end()) {\n\t\t\tif (it->timestamp < (ros::Time::now() - observation_keep_time_)) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n} /* namespace observation_buffer */", "CodeBleu_score": 30.462951449245146}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\t// Get the yaw angle at the start and end indices\n\tdouble start_yaw = tf::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble angle_diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in angle for each pose in the specified range\n\tdouble angle_increment = angle_diff / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t// Update the yaw angle for the current pose\n\t\tdouble current_yaw = start_yaw + angle_increment * (i - start_index);\n\n\t\t// Update the orientation of the current pose\n\t\tpath[i].pose.orientation = tf::createQuaternionMsgFromYaw(current_yaw);\n\t}\n}\n", "CodeBleu_score": 63.781399887353395}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\t// Calculate the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between the start and end yaw angles\n\tdouble shortest_angular_distance = getShortestAngularDistance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose\n\tdouble incremental_change = shortest_angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t// Calculate the new yaw angle for the current pose\n\t\tdouble new_yaw = start_yaw + (i - start_index) * incremental_change;\n\n\t\t// Update the orientation of the current pose\n\t\tpath[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), new_yaw));\n\t}\n}\n", "CodeBleu_score": 58.36833002851301}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\t// Calculate the yaw angle at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble angular_distance = std::remainder(end_yaw - start_yaw, 2 * M_PI);\n\n\t// Calculate the incremental change in angle for each pose\n\tdouble increment = angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble current_yaw = start_yaw + increment * (i - start_index);\n\t\ttf2::Quaternion current_orientation;\n\t\tcurrent_orientation.setRPY(0, 0, current_yaw);\n\t\tpath[i].pose.orientation = tf2::toMsg(current_orientation);\n\t}\n}\n", "CodeBleu_score": 60.42902980422822}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tgeometry_msgs::PoseStamped start;\n\tgeometry_msgs::PoseStamped goal;\n\n\tstart.header.stamp = ros::Time::now();\n\tstart.header.frame_id = \"map\";\n\tstart.pose = req.start;\n\n\tgoal.header.stamp = ros::Time::now();\n\tgoal.header.frame_id = \"map\";\n\tgoal.pose = req.goal;\n\n\tmakePlan(start, goal, resp.plan);\n\n\tresp.code = resp.plan.poses.size() > 0? 1 : 0;\n\n\treturn true;\n}\n", "CodeBleu_score": 46.10918323037064}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\t// set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\t// call makePlan to generate a path\n\tmakePlan(req.start, req.goal, resp.plan);\n\t// update the response with the success status and the generated path\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\t// return true to indicate that the service was processed\n\treturn true;\n}\n", "CodeBleu_score": 49.73977591489568}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tgeometry_msgs::PoseStamped start;\n\tgeometry_msgs::PoseStamped goal;\n\tstart.header.frame_id = goal.header.frame_id = \"map\";\n\tstart.pose = req.start;\n\tgoal.pose = req.goal;\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tbool result = makePlan(start, goal, plan);\n\tresp.plan.poses.resize(plan.size());\n\tfor (unsigned int i = 0; i < plan.size(); i++) {\n\t\tresp.plan.poses[i] = plan[i];\n\t}\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\treturn result;\n}\n", "CodeBleu_score": 45.18475386243083}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\tROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n    costmap_ros_ = cmap;\n    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, boost::bind(&PlannerWithCostmap::goalCB, this, _1));\n}\n", "CodeBleu_score": 60.49846680207549}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\tros::NodeHandle private_nh(\"~/\" + name);\n\tplan_pub_ = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n\tgoal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n\tmake_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\t//initialize the planner\n\tinitialize(name, cmap->getCostmap(), cmap->getGlobalFrameID());\n}\n", "CodeBleu_score": 60.60220028361489}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())//\tROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n    costmap_ros_ = cmap;\n    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\",\n            &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1,\n            boost::bind(&PlannerWithCostmap::goalCB, this, _1));\n}\n", "CodeBleu_score": 58.54979758168}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tdouble origin_x = costmap_ros_->getCostmap()->getOriginX(), origin_y = costmap_ros_->getCostmap()->getOriginY();\n\tdouble resolution = costmap_ros_->getCostmap()->getResolution();\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\tif (mx < costmap_ros_->getCostmap()->getSizeInCellsX() && my < costmap_ros_->getCostmap()->getSizeInCellsY())\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n", "CodeBleu_score": 71.32933825230398}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tdouble origin_x = costmap_ros_->getCostmap()->getOriginX(),\n\t\t\torigin_y = costmap_ros_->getCostmap()->getOriginY();\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / costmap_ros_->getCostmap()->getResolution();\n\tmy = (wy - origin_y) / costmap_ros_->getCostmap()->getResolution();\n\n\tif (mx < costmap_ros_->getCostmap()->getSizeInCellsX() && my\n\t\t\t< costmap_ros_->getCostmap()->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}\n", "CodeBleu_score": 66.02463559297907}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tdouble origin_x = costmap_ros_->getCostmap()->getOriginX(),\n\t\t\torigin_y = costmap_ros_->getCostmap()->getOriginY();\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / costmap_ros_->getCostmap()->getResolution();\n\tmy = (wy - origin_y) / costmap_ros_->getCostmap()->getResolution();\n\n\tif (mx < costmap_ros_->getCostmap()->getSizeInCellsX() && my\n\t\t\t< costmap_ros_->getCostmap()->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}\n", "CodeBleu_score": 66.02463559297907}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}\n\n} /* namespace global_planner */", "CodeBleu_score": 86.16823750201227}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 85.10682183623015}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}\n\n} //end namespace global_planner", "CodeBleu_score": 86.16823750201227}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tactionlib_msgs::GoalID g;\n\tg.stamp = ros::Time::now();\n\tgoalID = g.id;\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal_id = g;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 65.44555778896624}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG_NAMED(\"move_base\",\"In ROS goal callback, wrapping the PoseStamped in the action message and re-publishing to the server.\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 92.52238800895097}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-publishing to the action server.\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 89.86432489995777}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tdouble distance = pow(current_pose.x - start_pose.x, 2) + pow(current_pose.y - start_pose.y, 2);\n\tif (distance > pow(limited_distance, 2)) {\n\t\tROS_INFO(\"Robot has moved far enough, removing speed limit.\");\n\t\tif (remove_limit_thread!= NULL) {\n\t\t\tremove_limit_thread->join();\n\t\t\tdelete remove_limit_thread;\n\t\t}\n\t\tremove_limit_thread = new std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistance_check_timer.stop();\n\t}\n}\n", "CodeBleu_score": 56.85515157529456}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tif (pow(distance, 2) > pow(limitedDistance, 2)) {\n\t\tROS_INFO(\"Robot has moved far enough, removing speed limit.\");\n\t\tjoinAndDeleteThread();\n\t\tstartRemoveLimitThread();\n\t\tdistanceCheckTimer.stop();\n\t}\n}\n", "CodeBleu_score": 32.02537534990772}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tdouble currentDistance = (pow(this->currentPose.x - this->startPose.x, 2) + pow(this->currentPose.y - this->startPose.y, 2));\n\tif (currentDistance >= this->limitedDistance) {\n\t\tROS_INFO(\"Robot has moved far enough. Removing speed limit.\");\n\t\tif (this->removeLimitThread!= NULL) {\n\t\t\tthis->removeLimitThread->join();\n\t\t\tdelete this->removeLimitThread;\n\t\t}\n\t\tthis->removeLimitThread = new std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tthis->distanceCheckTimer.stop();\n\t}\n}\n", "CodeBleu_score": 39.310369504800946}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\t//ROS_INFO(\"PoseCallback\");\n\t//ROS_INFO(\"Goal x: %f, y: %f\", goal->pose.position.x, goal->pose.position.y);\n\ttf::Stamped<tf::Pose> goal_tf;\n\ttf::poseStampedMsgToTF(*goal, goal_tf);\n\n\ttf::Stamped<tf::Pose> global_pose;\n\tgetRobotPose(global_pose);\n\n\t//we want to publish a path that is just the downsampled global plan\n\t//rm::Path path;\n\t//path.header.frame_id = global_frame_;\n\t//path.header.stamp = ros::Time::now();\n\n\t//if the global plan passed in is empty... we won't do anything\n\tif(goal->header.frame_id!= global_frame_) {\n\t\tROS_ERROR(\"This planner as configured will only accept goals in the %s frame, but a goal was sent in the %s frame.\", global_frame_.c_str(), goal->header.frame_id.c_str());\n\t\treturn;\n\t}\n\n\ttf::Stamped<tf::Pose> goal_tf_global;\n\tgoal_tf_global = goal_tf;\n\tgoal_tf_global.frame_id_ = global_frame_;\n\n\t//we assume the global goal is given in the frame of the planner\n\tstd::vector<rm::PoseStamped> global_plan;\n\tif(!planner_->makePlan(global_pose, goal_tf_global, global_plan)) {\n\t\tROS_ERROR(\"Failed to find a plan to point (%.2f, %.2f)\", goal->pose.position.x, goal->pose.position.y);\n\t\treturn;\n\t}\n\n\t//publish the plan for visualization purposes\n\t//publishPlan(global_plan, path);\n\n\t//ROS_INFO(\"PoseCallback end\");\n}\n", "CodeBleu_score": 41.34366514262725}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\tROS_INFO(\"NavfnWithCostmap::poseCallback: New pose received\");\n\t// Get the pose of the robot\n\trm::PoseStamped robotPose;\n\tgetRobotPose(robotPose);\n\n\t// Create a plan from the robot's pose to the goal pose\n\tstd::vector<rm::PoseStamped> plan;\n\tmakePlan(robotPose, *goal, plan);\n\n\t// Publish the plan\n\tpublishPlan(plan);\n}\n", "CodeBleu_score": 50.56273742372063}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\tROS_INFO(\"Pose Callback\");\n\t// get the current pose of the robot\n\trm::PoseStamped robot_pose;\n\tgetRobotPose(robot_pose);\n\t// generate a path from the current pose to the goal pose\n\tstd::vector<rm::PoseStamped> path;\n\tmakePlan(robot_pose, *goal, path);\n}\n", "CodeBleu_score": 57.631968985206484}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_srv.request.param_type = param_set.param_type;\n\tif (param_set_client_.call(param_set_srv)) {\n\t\tROS_INFO(\"Gimbal Param Set: %s\", param_set_srv.response.success? \"Success\" : \"Failed\");\n\t} else {\n\t\tROS_ERROR(\"Gimbal Param Set: Failed to call service\");\n\t}\n}\n", "CodeBleu_score": 49.65965346699719}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_srv.request.param_type = param_set.param_type;\n\n\tif (param_set_client_.call(param_set_srv)) {\n\t\tROS_INFO(\"Gimbal Parameter Set\");\n\t} else {\n\t\tROS_ERROR(\"Failed to set gimbal parameter\");\n\t}\n}\n", "CodeBleu_score": 51.02952400033137}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\tif (param_set_client_.call(srv)) {\n\t\tROS_INFO(\"Gimbal param set success\");\n\t} else {\n\t\tROS_ERROR(\"Gimbal param set failed\");\n\t}\n}\n", "CodeBleu_score": 63.74119249149073}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()\tint server_fd;\n\tint new_socket;\n\tint valread;\n\tstruct sockaddr_in address;\n\tint opt = 1;\n\tint addrlen = sizeof(address);\n\tchar buffer[1024] = {0};\n\n\t// Creating socket file descriptor\n\tif ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n\t\tperror(\"socket failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Forcefully attaching socket to the port 8080\n\tif (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n\t\tperror(\"setsockopt\");\n\t\texit(EXIT_FAILURE);\n\t}\n\taddress.sin_family = AF_INET;\n\taddress.sin_addr.s_addr = INADDR_ANY;\n\taddress.sin_port = htons( PORT );\n\n\t// Forcefully attaching socket to the port 8080\n\tif (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0) {\n\t\tperror(\"bind failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (listen(server_fd, 3) < 0) {\n\t\tperror(\"listen\");\n\t\texit(EXIT_FAILURE);\n\t}\n\twhile(true) {\n\t\tif ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\twhile(true) {\n\t\t\tvalread = read( new_socket, buffer, 1024);\n\t\t\tif(valread <= 0) {\n\t\t\t\tROS_ERROR(\"ERROR: Server: Could not read from socket\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//ROS_INFO(\"Server: Received %d bytes\", valread);\n\t\t\t//ROS_INFO(\"Server: Received: %s\", buffer);\n\n\t\t\t// Decode the message\n\t\t\tmavros_msgs::Mavlink msg;\n\t\t\tmsg.sysid = 1;\n\t\t\tmsg.compid = 1;\n\t\t\tmsg.msgid", "CodeBleu_score": 46.64138731564601}, {"code": "void CommunicationBridge::serverFun()\tROS_INFO(\"Starting server\");\n\tint server_fd, new_socket;\n\tstruct sockaddr_in address;\n\tint addrlen = sizeof(address);\n\tint opt = 1;\n\tint valread;\n\tstruct sockaddr_in serv_addr;\n\tchar buffer[1024] = {0};\n\n\t// Creating socket file descriptor\n\tif ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n\t\tperror(\"socket failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Forcefully attaching socket to the port 8080\n\tif (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n\t\tperror(\"setsockopt\");\n\t\texit(EXIT_FAILURE);\n\t}\n\taddress.sin_family = AF_INET;\n\taddress.sin_addr.s_addr = INADDR_ANY;\n\taddress.sin_port = htons(port);\n\n\t// Forcefully attaching socket to the port 8080\n\tif (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n\t\tperror(\"bind failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (listen(server_fd, 3) < 0) {\n\t\tperror(\"listen\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\twhile (true) {\n\t\tif ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tROS_INFO(\"Accepted connection\");\n\n\t\tvalread = read(new_socket, buffer, 1024);\n\t\tif (valread <= 0) {\n\t\t\tROS_ERROR(\"Read failed\");\n\t\t\tclose(new_socket);\n\t\t\tcontinue;\n\t\t}\n\n\t\tROS_INFO(\"Received %d bytes\", valread);\n\n\t\tmavlink_message_t msg;\n\t\tmavlink_status_t status;\n\n\t\tfor (int i = 0; i < valread; i++) {\n\t\t\tif", "CodeBleu_score": 49.017565878879275}, {"code": "void CommunicationBridge::serverFun()\tint sockfd, newsockfd;\n\tsocklen_t clilen;\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tint n;\n\tif ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n\t\tROS_ERROR(\"ERROR opening socket\");\n\t\treturn;\n\t}\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(port);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tROS_ERROR(\"ERROR on binding\");\n\t\treturn;\n\t}\n\tlisten(sockfd, 5);\n\tclilen = sizeof(cli_addr);\n\twhile (ros::ok()) {\n\t\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\t\tif (newsockfd < 0) {\n\t\t\tROS_ERROR(\"ERROR on accept\");\n\t\t\treturn;\n\t\t}\n\t\twhile (ros::ok()) {\n\t\t\tchar buffer[1024];\n\t\t\tbzero(buffer, 1024);\n\t\t\tn = read(newsockfd, buffer, 1024);\n\t\t\tif (n < 0) {\n\t\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (n <= 0) {\n\t\t\t\tROS_ERROR(\"ERROR: Received message length is zero or less\");\n\t\t\t\tclose(newsockfd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n > 0) {\n\t\t\t\tstd::string msg = buffer;\n\t\t\t\tROS_INFO(\"Received message: %s\", msg.c_str());\n\t\t\t\tstd::vector<std::string> msg_split = split(msg, ',');\n\t\t\t\tif (msg_split.size() == 4) {\n\t\t\t\t\tif (msg_split[0] == \"GPS\") {\n\t\t\t\t\t\tstd_msgs::String msg_gps;\n\t\t\t\t\t\tmsg_gps.data = msg;\n\t\t\t\t\t\tgps_pub.publish(msg_gps", "CodeBleu_score": 42.005055652331684}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\t// If in simulation mode, find the UAV by ID and publish the command to the matching UAV\n\tif (simulation_mode_) {\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (uav_cmd.uav_id == swarm_control_simulation_[i].uav_id) {\n\t\t\t\t// Publish the command to the UAV\n\t\t\t\tswarm_control_simulation_[i].publishCommand(uav_cmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t// If not in simulation mode, publish the command to a single UAV using uav_basic_\n\telse {\n\t\tuav_basic_.publishCommand(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 42.43266938388549}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (simulation_mode_) {\n\t\t// Find UAV by ID\n\t\tif (uav_cmd.id >= swarm_control_simulation_->uavs.size()) {\n\t\t\tstd::cout << \"UAV ID out of range.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t// Publish UAV command\n\t\tswarm_control_simulation_->uavs[uav_cmd.id].publishCommand(uav_cmd);\n\t} else {\n\t\t// Publish UAV command\n\t\tuav_basic_->publishCommand(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 32.63293698453345}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (!simulation_mode_) {\n\t\tuav_basic_.publishCommand(uav_cmd);\n\t} else {\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (uav_cmd.uav_id == swarm_control_simulation_[i].uav_id) {\n\t\t\t\tswarm_control_simulation_[i].publishCommand(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.57773955502099}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"shutdown now\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}\n", "CodeBleu_score": 49.07206677243308}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else {\n\t\tif (mode_selection.use_mode) {\n\t\t\tcreateMode(mode_selection);\n\t\t} else {\n\t\t\tdeleteMode(mode_selection);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 53.24892796168961}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\t// if the mode is REBOOTNX, execute the system command to reboot NX\n\tif (mode_selection.mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t}\n\t// if the mode is EXITNX, execute the system command to exit NX\n\telse if (mode_selection.mode == EXITNX) {\n\t\tsystem(\"killall NX\");\n\t}\n\t// if the mode is CREATEMODE, call createMode\n\telse if (mode_selection.mode == CREATEMODE) {\n\t\tcreateMode(mode_selection);\n\t}\n\t// if the mode is DELETEMODE, call deleteMode\n\telse if (mode_selection.mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}\n", "CodeBleu_score": 63.02048010511923}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\tif (heartbeat_count == prev_heartbeat_count) {\n\t\tif (heartbeat_count == 0) {\n\t\t\tif (vehicle_type == \"swarm\") {\n\t\t\t\tROS_ERROR(\"No heartbeat received from any vehicle in the swarm.\");\n\t\t\t\tROS_ERROR(\"Disconnecting from all vehicles in the swarm.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else if (vehicle_type == \"uav\") {\n\t\t\t\tROS_ERROR(\"No heartbeat received from the UAV.\");\n\t\t\t\tROS_ERROR(\"Disconnecting from the UAV.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else if (vehicle_type == \"ugv\") {\n\t\t\t\tROS_ERROR(\"No heartbeat received from the UGV.\");\n\t\t\t\tROS_ERROR(\"Disconnecting from the UGV.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (vehicle_type == \"swarm\") {\n\t\t\t\tROS_ERROR(\"No heartbeat received from all vehicles in the swarm.\");\n\t\t\t\tROS_ERROR(\"Disconnecting from all vehicles in the swarm.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else if (vehicle_type == \"uav\") {\n\t\t\t\tROS_ERROR(\"No heartbeat received from the UAV.\");\n\t\t\t\tROS_ERROR(\"Disconnecting from the UAV.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else if (vehicle_type == \"ugv\") {\n\t\t\t\tROS_ERROR(\"No heartbeat received from the UGV.\");\n\t\t\t\tROS_ERROR(\"Disconnecting from the UGV.\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t}\n\t\t}\n\t}\n\tprev_heartbeat_count = heartbeat_count;\n}\n", "CodeBleu_score": 36.102310217912404}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\tif (heartbeat_count == last_heartbeat_count) {\n\t\theartbeat_count = 0;\n\t\tlast_heartbeat_count = 0;\n\t\tROS_ERROR(\"Heartbeat error\");\n\t\tif (vehicle_type == \"swarm\") {\n\t\t\tROS_ERROR(\"Swarm vehicle lost connection\");\n\t\t\tdisconnect_flag = true;\n\t\t} else if (vehicle_type == \"UAV\") {\n\t\t\tROS_ERROR(\"UAV vehicle lost connection\");\n\t\t\tdisconnect_flag = true;\n\t\t} else if (vehicle_type == \"UGV\") {\n\t\t\tROS_ERROR(\"UGV vehicle lost connection\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t}\n\tlast_heartbeat_count = heartbeat_count;\n}\n", "CodeBleu_score": 33.28188687805736}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\tif (heartbeat_count == prev_heartbeat_count) {\n\t\tif (heartbeat_count!= 0) {\n\t\t\tROS_ERROR(\"Heartbeat error, no communication for %d attempts\", heartbeat_count);\n\t\t\tif (vehicle_type == \"swarm\") {\n\t\t\t\tROS_ERROR(\"Swarm disconnected\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else if (vehicle_type == \"uav\") {\n\t\t\t\tROS_ERROR(\"UAV disconnected\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else if (vehicle_type == \"ugv\") {\n\t\t\t\tROS_ERROR(\"UGV disconnected\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprev_heartbeat_count = heartbeat_count;\n\t}\n}\n", "CodeBleu_score": 36.50342054802336}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\tif (msg->bsplines.size() == 0) {\n\t\treturn;\n\t}\n\n\t// multi-trajectory\n\tprometheus_msgs::MultiBsplines bsplines_msg;\n\tbsplines_msg.header = msg->header;\n\tbsplines_msg.drone_id = msg->drone_id;\n\tbsplines_msg.bsplines.resize(msg->bsplines.size());\n\n\t// for each trajectory\n\tfor (int i = 0; i < msg->bsplines.size(); i++) {\n\t\t// initialize bspline struct\n\t\tBspline bspline;\n\t\tbspline.id = msg->bsplines[i].id;\n\t\tbspline.num_points = msg->bsplines[i].num_points;\n\t\tbspline.order = msg->bsplines[i].order;\n\t\tbspline.knots.resize(msg->bsplines[i].knots.size());\n\t\tbspline.points.resize(msg->bsplines[i].points.size());\n\t\tbspline.yaw_points.resize(msg->bsplines[i].yaw_points.size());\n\n\t\t// set knots\n\t\tfor (int j = 0; j < msg->bsplines[i].knots.size(); j++) {\n\t\t\tbspline.knots[j] = msg->bsplines[i].knots[j];\n\t\t}\n\n\t\t// set position points\n\t\tfor (int j = 0; j < msg->bsplines[i].points.size(); j++) {\n\t\t\tbspline.points[j].x = msg->bsplines[i].points[j].x;\n\t\t\tbspline.points[j].y = msg->bsplines[i].points[j].y;\n\t\t\tbspline.points[j].z = msg->bsplines[i].points[j].z;\n\t\t}\n\n\t\t// set yaw points\n\t\tfor (int j = 0; j < msg->bsplines[i].yaw_points.size(); j++) {\n\t\t\tbspline.yaw_points[j] = msg->bsplines[i].yaw_points[j];\n\t\t}\n\n\t\t// encode data\n\t\tuint8_t *data = (uint8_t *)malloc(bspline.", "CodeBleu_score": 62.01655368827962}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb\");\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->id: %d\", msg->id);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_bspline: %d\", msg->num_bspline);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_knots: %d\", msg->num_knots);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_points: %d\", msg->num_points);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_yaw: %d\", msg->num_yaw);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_yaw: %d\", msg->num_yaw);\n\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->id: %d\", msg->id);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_bspline: %d\", msg->num_bspline);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_knots: %d\", msg->num_knots);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_points: %d\", msg->num_points);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_yaw: %d\", msg->num_yaw);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num_yaw: %d\", msg->num_yaw);\n\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->id: %d\", msg->id);\n\t// ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb, msg->num", "CodeBleu_score": 1.237583335904242}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a multitraj msg from %s\", msg->header.frame_id.c_str());\n\t//", "CodeBleu_score": 1.2362962958546304}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZRGB>(cloud));\n\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_out(new pcl::PointCloud<pcl::PointXYZRGB>);\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree(compression_level_);\n\toctree.setInputCloud(cloud_ptr);\n\toctree.encodePointCloud(cloud_out);\n\tsensor_msgs::PointCloud2 msg_out;\n\tpcl::toROSMsg(*cloud_out, msg_out);\n\tmsg_out.header.frame_id = msg.header.frame_id;\n\tmsg_out.header.stamp = msg.header.stamp;\n\treturn msg_out;\n}\n", "CodeBleu_score": 33.239196559392525}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Create a new PointCloud2 message to hold the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = msg.height;\n\tcompressed_msg.width = msg.width;\n\tcompressed_msg.fields = msg.fields;\n\tcompressed_msg.is_bigendian = msg.is_bigendian;\n\tcompressed_msg.point_step = msg.point_step;\n\tcompressed_msg.row_step = msg.row_step;\n\tcompressed_msg.is_dense = msg.is_dense;\n\n\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Compress the point cloud\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(compression_level_);\n\toctree.encodePointCloud(cloud, compressed_msg.data);\n\n\t// Release dynamically allocated memory\n\toctree.deleteTree();\n\n\treturn compressed_msg;\n}\n", "CodeBleu_score": 30.942980508891832}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Create a pcl::PointCloud2 object from the input sensor_msgs::PointCloud2 message\n\tpcl::PCLPointCloud2 pcl_pc2;\n\tpcl_conversions::toPCL(msg, pcl_pc2);\n\n\t// Create a pcl::PointCloud object from the pcl::PointCloud2 object\n\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n\tpcl::fromPCLPointCloud2(pcl_pc2, *cloud);\n\n\t// Create an OctreePointCloudCompression object with a resolution of 0.01\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree(0.01);\n\n\t// Set the point cloud data to the OctreePointCloudCompression object\n\toctree.setInputCloud(cloud);\n\n\t// Encode the point cloud data and store the compressed data in a std::vector<char>\n\tstd::vector<char> compressed_data;\n\toctree.encodePointCloud(compressed_data);\n\n\t// Create a new PointCloud2 message\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Set the header of the compressed message\n\tcompressed_msg.header = msg.header;\n\n\t// Set the data of the compressed message to the compressed data\n\tcompressed_msg.data = compressed_data;\n\n\t// Set the point step of the compressed message to 12\n\tcompressed_msg.point_step = 12;\n\n\t// Set the row step of the compressed message to 0\n\tcompressed_msg.row_step = 0;\n\n\t// Set the width of the compressed message to 1\n\tcompressed_msg.width = 1;\n\n\t// Set the height of the compressed message to 1\n\tcompressed_msg.height = 1;\n\n\t// Set the is_dense field of the compressed message to false\n\tcompressed_msg.is_dense = false;\n\n\t// Set the fields of the compressed message to the fields of the input message\n\tcompressed_msg.fields = msg.fields;\n\n\t// Set the is_bigendian field of the compressed message to the is_bigendian field of the input message\n\tcompressed_msg.is_bigendian = msg.is_bigendian;\n\n\t// Set the point cloud format of the compressed message", "CodeBleu_score": 41.8333623518856}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (uav_state.id == multi_uav_state_[i].id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n\tROS_ERROR(\"UAV %d not found in multi_uav_state_.\", uav_state.id);\n}\n", "CodeBleu_score": 54.11921413294949}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].id == uav_state.id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.67737556156291}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 53.33089651166092}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\tMultiUGVState multi_ugv_state_msg;\n\tint ugv_count = 0;\n\n\tfor (int i = 0; i < m_multi_ugv_state.num_ugvs; i++) {\n\t\tUGVState ugv_state_msg;\n\t\tugv_state_msg.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n\t\tugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n\t\tugv_state_msg.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n\n\t\tmulti_ugv_state_msg.ugv_state.push_back(ugv_state_msg);\n\t\tugv_count++;\n\t}\n\n\tmulti_ugv_state_msg.num_ugvs = ugv_count;\n\n\tall_ugv_state_pub_.publish(multi_ugv_state_msg", "CodeBleu_score": 42.94067657961688}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\tMultiUGVState ugv_state_msg;\n\tUGVState ugv_state;\n\tint ugv_count = 0;\n\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state.size(); i++) {\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.pos_x = m_multi_ugv_state.ugv_state[i].pos_x;\n\t\tugv_state.pos_y = m_multi_ugv_state.ugv_state[i].pos_y;\n\t\tugv_state.pos_z = m_multi_ugv_state.ugv_state[i].pos_z;\n\t\tugv_state.vel_x = m_multi_ugv_state.ugv_state[i].vel_x;\n\t\tugv_state.vel_y = m_multi_ugv_state.ugv_state[i].vel_y;\n\t\tugv_state.vel_z = m_multi_ugv_state.ugv_state[i].vel_z;\n\t\tugv_state.yaw = m_multi_ugv_state.ugv_state[i].yaw;\n\t\tugv_state.pitch = m_multi_ugv_state.ugv_state[i].pitch;\n\t\tugv_state.roll = m_multi_ugv_state.ugv_state[i].roll;\n\t\tugv_state_msg.ugv_state.push_back(ugv_state);\n\t\tugv_count++;\n\t}\n\n\tugv_state_msg.ugv_count = ugv_count;\n\n\tall_ugv_state_pub.publish(ugv_state_msg);\n}\n", "CodeBleu_score": 45.33718441436417}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\t// Initialize a MultiUGVState message\n\tmavros_msgs::MultiUGVState multi_ugv_state;\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (auto const& ugv_state : m_multi_ugv_state.ugv_states) {\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tmavros_msgs::UGVState state;\n\t\tstate.id = ugv_state.id;\n\t\tstate.battery = ugv_state.battery;\n\t\tstate.position.x = ugv_state.position.x;\n\t\tstate.position.y = ugv_state.position.y;\n\t\tstate.position.z = ugv_state.position.z;\n\t\tstate.velocity.x = ugv_state.velocity.x;\n\t\tstate.velocity.y = ugv_state.velocity.y;\n\t\tstate.velocity.z = ugv_state.velocity.z;\n\t\tstate.attitude.x = ugv_state.attitude.x;\n\t\tstate.attitude.y = ugv_state.attitude.y;\n\t\tstate.attitude.z = ugv_state.attitude.z;\n\n\t\t// Increment the UGV count and add each UGVState to the MultiUGVState message\n\t\tmulti_ugv_state.ugv_count++;\n\t\tmulti_ugv_state.ugv_states.push_back(state);\n\t}\n\n\t// Publish the assembled MultiUGVState message\n\tall_ugv_state_pub_.publish(multi_ugv_state);\n}\n", "CodeBleu_score": 38.58760345132477}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// calculate the cost and gradient of a B-spline trajectory concerning moving objects\n\t// q is the vector of control points, which is a column vector\n\t// cost is the cost of the B-spline trajectory\n\t// gradient is the gradient of the cost function\n\t//\n\t// Note:\n\t// 1. The function is called by calcCostAndGradient\n\t// 2. The function is called by calcCostAndGradient_new\n\t// 3. The function is called by calcCostAndGradient_new_new\n\t// 4. The function is called by calcCostAndGradient_new_new_new\n\n\t// clear the cost and gradient\n\tcost = 0.0;\n\tgradient.setZero();\n\n\t// iterate through control points of the B-spline\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// get the position of the ith control point\n\t\tdouble x_i = q(i, 0);\n\t\tdouble y_i = q(i, 1);\n\n\t\t// compute the predicted positions of moving objects\n\t\tdouble x_pred, y_pred;\n\t\tpredictMovingObjPos(x_i, y_i, x_pred, y_pred);\n\n\t\t// evaluate the distance between the ith control point and the predicted positions of moving objects\n\t\tdouble dist = sqrt(pow(x_i - x_pred, 2) + pow(y_i - y_pred, 2));\n\n\t\t// if the distance is less than a specified clearance, update the cost and gradient\n\t\tif (dist < clearance) {\n\t\t\t// update the cost\n\t\t\tcost += pow(dist - clearance, 2);\n\n\t\t\t// update the gradient\n\t\t\tgradient(i, 0) += 2 * (x_i - x_pred) * (dist - clearance) / dist;\n\t\t\tgradient(i, 1) += 2 * (y_i - y_pred) * (dist - clearance) / dist;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.31495223867872}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tint n = q.cols();\n\tint m = moving_obj_list.size();\n\n\tdouble clearance = 0.2;\n\tdouble clearance_sq = clearance * clearance;\n\n\t// iterate through control points\n\tfor (int i = 0; i < n; i++) {\n\t\t// compute predicted positions of moving objects\n\t\tEigen::Vector3d q_i = q.col(i);\n\t\tstd::vector<Eigen::Vector3d> q_pred_list;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tq_pred_list.push_back(moving_obj_list[j]->predictPosition(q_i, i * dt));\n\t\t}\n\n\t\t// evaluate distance between control points and moving objects\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tEigen::Vector3d q_diff = q_i - q_pred_list[j];\n\t\t\tdouble dist_sq = q_diff.squaredNorm();\n\t\t\tif (dist_sq < clearance_sq) {\n\t\t\t\tdouble dist = sqrt(dist_sq);\n\t\t\t\tcost += 0.5 * (clearance - dist) * (clearance - dist);\n\t\t\t\tgradient.col(i) -= (clearance - dist) / dist * q_diff;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.462553987117175}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tEigen::MatrixXd q_tmp(q.rows(), 1);\n\tdouble dist_err;\n\tdouble dist_err_tmp;\n\tdouble dist_err_tmp_sqr;\n\tdouble dist_err_tmp_sqr_inv;\n\tdouble dist_err_tmp_sqr_inv_sqr;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr_inv_sqr;\n\tdouble dist_err_tmp_sqr_inv_sqr_inv_sqr_inv_", "CodeBleu_score": 10.785500718463998}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// Initialize the cost and gradient to zero\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through the control points of the trajectory\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// Compute the positional error relative to reference points\n\t\tEigen::Vector3d err = q.col(i) - _reference_points.col(i);\n\t\t// Compute a velocity vector\n\t\tEigen::Vector3d v = _reference_points.col((i + 1) % _reference_points.cols()) - _reference_points.col(i);\n\t\t// Compute the cost function\n\t\tdouble c = (err.dot(err) / _a2) + (err.dot(v) / _b2);\n\t\t// Update the cost\n\t\tcost += c;\n\n\t\t// Compute the derivatives for the gradient\n\t\tEigen::Vector3d d_err_dq = 2 * err;\n\t\tEigen::Vector3d d_v_dq = _reference_points.col((i + 2) % _reference_points.cols()) - 2 * _reference_points.col((i + 1) % _reference_points.cols()) + _reference_points.col(i);\n\n\t\tEigen::Vector3d d_c_dq = (d_err_dq / _a2) + (d_v_dq / _b2);\n\t\t// Update the gradient\n\t\tgradient.col(i) += d_c_dq;\n\t}\n}\n", "CodeBleu_score": 32.79260826404568}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\tEigen::Vector3d pos_error;\n\tEigen::Vector3d vel_vector;\n\tEigen::Vector3d vel_vector_prev;\n\tEigen::Vector3d vel_vector_next;\n\tEigen::Vector3d vel_vector_prev_next;\n\tEigen::Vector3d vel_vector_next_prev;\n\tEigen::Vector3d vel_vector_prev_next_prev;\n\tEigen::Vector3d vel_vector_next_prev_next;\n\tEigen::Vector3d vel_vector_next_next;\n\tEigen::Vector3d vel_vector_prev_prev;\n\tEigen::Vector3d vel_vector_prev_next_next;\n\tEigen::Vector3d vel_vector_next_prev_prev;\n\tEigen::Vector3d vel_vector_next_next_next;\n\tEigen::Vector3d vel_vector_prev_prev_prev;\n\tEigen::Vector3d vel_vector_next_prev_prev_next;\n\tEigen::Vector3d vel_vector_next_next_prev_next;\n\tEigen::Vector3d vel_vector_prev_next_next_next;\n\tEigen::Vector3d vel_vector_next_prev_prev_prev;\n\tEigen::Vector3d vel_vector_prev_prev_next_next;\n\tEigen::Vector3d vel_vector_next_next_prev_prev;\n\tEigen::Vector3d vel_vector_prev_next_prev_prev_next;\n\tEigen::Vector3d vel_vector_next_prev_next_next_next;\n\tEigen::Vector3d vel_vector_next_next_next_prev_next;\n\tEigen::Vector3d vel_vector_next_next_prev_prev_prev;\n\tEigen::Vector3d vel_vector_prev_prev_prev_next_next;\n\tEigen::Vector3d vel_vector_next_next_next_next_prev;\n\tEigen::Vector3d vel_vector_prev_prev_next_next_next;\n\tEigen::Vector3d vel_vector_next_next_prev", "CodeBleu_score": 10.812378160818973}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// Initialize cost to zero\n\tcost = 0;\n\t// Initialize gradient to zero\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// Compute positional error relative to reference points\n\t\tEigen::Vector3d err = q.col(i) - refPoints[i];\n\n\t\t// Compute velocity vector\n\t\tEigen::Vector3d vel = Eigen::Vector3d::Zero();\n\t\tif (i > 0) {\n\t\t\tvel = (q.col(i) - q.col(i - 1)) / timeStep;\n\t\t}\n\n\t\t// Compute cost function\n\t\tcost += err.dot(err) / a2 + vel.cross(vel).norm() / b2;\n\n\t\t// Compute gradient\n\t\tgradient.col(i) = 2 * err / a2;\n\t\tif (i > 0) {\n\t\t\tgradient.col(i) -= 2 * (q.col(i) - q.col(i - 1)) / (timeStep * a2);\n\t\t\tgradient.col(i - 1) += 2 * (q.col(i) - q.col(i - 1)) / (timeStep * a2);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.81899333518366}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()\tint i, j;\n\tdouble jerk = 0;\n\tdouble *knots = new double[degree + 1];\n\tdouble *control = new double[degree + 1];\n\tdouble *temp = new double[degree + 1];\n\tdouble *temp2 = new double[degree + 1];\n\tdouble *temp3 = new double[degree + 1];\n\n\t// compute the third derivative of the spline\n\tfor (i = 0; i < degree + 1; i++) {\n\t\ttemp[i] = 0;\n\t\ttemp2[i] = 0;\n\t\ttemp3[i] = 0;\n\t}\n\tfor (i = 0; i < degree + 1; i++) {\n\t\tfor (j = 0; j < degree + 1; j++) {\n\t\t\ttemp[i] += pow(knots[j], degree - j) * pow(1 - knots[j], j);\n\t\t\ttemp2[i] += pow(knots[j], degree - j - 1) * pow(1 - knots[j], j);\n\t\t\ttemp3[i] += pow(knots[j], degree - j - 2) * pow(1 - knots[j], j);\n\t\t}\n\t}\n\tfor (i = 0; i < degree + 1; i++) {\n\t\tcontrol[i] = (temp[i] * pow(knots[i], 3) + temp2[i] * pow(knots[i], 2) + temp3[i] * knots[i]) * 6;\n\t}\n\n\t// retrieve the knot times and control points of the jerk trajectory\n\tfor (i = 0; i < degree + 1; i++) {\n\t\tknots[i] = control[i];\n\t\tcontrol[i] = knots[i];\n\t}\n\n\t// iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tfor (i = 0; i < degree + 1; i++) {\n\t\tfor (j = 0; j < dimension; j++) {\n\t\t\tjerk", "CodeBleu_score": 35.688808163659886}, {"code": "double UniformBspline::getJerk()\t// Compute the third derivative of the spline\n\tUniformBspline jerk = this->getDerivative(3);\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tvector<double> knots = jerk.getKnots();\n\tvector<vector<double>> controlPoints = jerk.getControlPoints();\n\n\t// Initialize the total jerk value\n\tdouble totalJerk = 0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < controlPoints.size(); i++) {\n\t\tfor (int j = 0; j < controlPoints[i].size(); j++) {\n\t\t\t// Calculate the squared control point value multiplied by the difference in knot times\n\t\t\tdouble jerkValue = controlPoints[i][j] * (knots[i + 4] - knots[i]);\n\n\t\t\t// Add the squared control point value multiplied by the difference in knot times to the total jerk value\n\t\t\ttotalJerk += jerkValue * jerkValue;\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn totalJerk;\n}\n", "CodeBleu_score": 46.24008944226839}, {"code": "double UniformBspline::getJerk()\tstd::vector<std::vector<double>> jerk_traj = this->getThirdDerivative();\n\tstd::vector<double> knot_times = jerk_traj[0];\n\tstd::vector<std::vector<double>> control_points = jerk_traj[1];\n\tdouble jerk = 0;\n\tfor (int i = 0; i < control_points.size(); i++) {\n\t\tfor (int j = 0; j < control_points[i].size(); j++) {\n\t\t\tjerk += control_points[i][j] * (knot_times[i + 1] - knot_times[i]);\n\t\t}\n\t}\n\treturn jerk;\n}\n", "CodeBleu_score": 43.35756339621391}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tEigen::Vector4d pos;\n\tpos << (u-cx_)*depth/fx_, (v-cy_)*depth/fy_, depth, 1;\n\treturn pos;\n}\n", "CodeBleu_score": 36.211967178244855}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \t// calculate the 4D position vector in the camera frame\n\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) / fx_ * depth;\n\tpos(1) = (v - cy_) / fy_ * depth;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}\n", "CodeBleu_score": 66.55245815011503}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}\n", "CodeBleu_score": 71.99319910207987}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\tint droneID = stoi(odom.child_frame_id.substr(4, 1));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"Error processing drone odometry message: %s\", e.what());\n\t}\n}\n", "CodeBleu_score": 49.01264527906254}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\trcvDroneOdomCallbackBase(odom, extractDroneID(odom.child_frame_id));\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"%s\", e.what());\n\t}\n}\n", "CodeBleu_score": 36.056334826813355}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneID(odom.child_frame_id));\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"%s\", e.what());\n\t}\n}\n", "CodeBleu_score": 34.233614274365046}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// Get the pose of the drone in the camera frame\n\tEigen::Vector3d drone_pose_cam = getDronePose(drone_id);\n\t// Check if the drone is in the camera frame\n\tif (drone_pose_cam(2) < 0) {\n\t\t// Update the debug result\n\t\tdebug_result.drone_id = drone_id;\n\t\tdebug_result.true_pixel = true_pixel;\n\t\tdebug_result.found = false;\n\t\tdebug_result.pose_error = Eigen::Vector3d::Zero();\n\t\t// Publish the debug result\n\t\tdebug_result_pub.publish(debug_result);\n\t\treturn;\n\t}\n\t// Get the true pose of the drone in the world frame\n\tEigen::Vector3d drone_pose_world = cam_pose_world * drone_pose_cam;\n\t// Get the pixel position of the drone in the image\n\tEigen::Vector2i drone_pixel = getPixelPosition(drone_pose_world);\n\t// Check if the drone is in the image\n\tif (drone_pixel(0) < 0 || drone_pixel(0) > img_width || drone_pixel(1) < 0 || drone_pixel(1) > img_height) {\n\t\t// Update the debug result\n\t\tdebug_result.drone_id = drone_id;\n\t\tdebug_result.true_pixel = true_pixel;\n\t\tdebug_result.found = false;\n\t\tdebug_result.pose_error = Eigen::Vector3d::Zero();\n\t\t// Publish the debug result\n\t\tdebug_result_pub.publish(debug_result);\n\t\treturn;\n\t}\n\t// Compute the pose error\n\tEigen::Vector3d pose_error = drone_pose_world - getDronePose(drone_pixel);\n\t// Update the debug result\n\tdebug_result.drone_id = drone_id;\n\tdebug_result.true_pixel = true_pixel;\n\tdebug_result.found = true;\n\tdebug_result.pose_error = pose_error;\n\t// Publish the debug result\n\tdebug_result_pub.publish(debug_result);\n}\n", "CodeBleu_score": 34.39986645536568}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// Compute the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose_cam = getDronePose(drone_id, true_pixel);\n\n\t// Check for its presence\n\tif (true_pose_cam(2) > 0) {\n\t\t// Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d pose_error = true_pose_cam - pose_cam_world_;\n\n\t\t// Update the debug result\n\t\tdebug_result_.drone_id = drone_id;\n\t\tdebug_result_.true_pixel = true_pixel;\n\t\tdebug_result_.true_pose_cam = true_pose_cam;\n\t\tdebug_result_.pose_error = pose_error;\n\t\tdebug_result_.found = true;\n\n\t\t// Publish the pose error\n\t\tpose_error_pub_.publish(pose_error);\n\t} else {\n\t\t// Update the debug result to indicate failure\n\t\tdebug_result_.drone_id = drone_id;\n\t\tdebug_result_.true_pixel = true_pixel;\n\t\tdebug_result_.true_pose_cam = true_pose_cam;\n\t\tdebug_result_.found = false;\n\t}\n\n\t// Publish the debug result\n\tdebug_result_pub_.publish(debug_result_);\n}\n", "CodeBleu_score": 36.19859977809965}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// Get the drone pose in the camera frame\n\tEigen::Vector3d cam_pose;\n\tbool found = getDronePose(drone_id, cam_pose);\n\n\t// Check if the drone was found\n\tif (found) {\n\t\t// Compute the true pose in the world frame\n\t\tEigen::Vector3d world_pose = cam_pose + cam_to_world_ * true_pixel;\n\n\t\t// Compute the pose error\n\t\tEigen::Vector3d error = world_pose - true_pose_;\n\n\t\t// Update the debug result\n\t\tdebug_result_.found = true;\n\t\tdebug_result_.pose_error = error;\n\t} else {\n\t\t// Update the debug result\n\t\tdebug_result_.found = false;\n\t}\n\n\t// Publish the pose error\n\tpose_error_pub_.publish(debug_result_);\n}\n", "CodeBleu_score": 33.52844082359926}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 80.66503328961358}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current!= start) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n", "CodeBleu_score": 73.5227250945459}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 80.66503328961358}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert the start and end points to grid indices\n\tif (!ConvertToIndex(start_pt, start_idx) ||!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// If the start point is inside an obstacle, adjust it away from the end point until it is not in an obstacle\n\tif (IsObstacle(start_idx)) {\n\t\tVector3i dir = (end_idx - start_idx).normalized();\n\t\tVector3i new_start_idx = start_idx;\n\t\twhile (IsObstacle(new_start_idx)) {\n\t\t\tnew_start_idx += dir;\n\t\t}\n\t\tstart_idx = new_start_idx;\n\t}\n\n\t// If the end point is inside an obstacle, adjust it away from the start point until it is not in an obstacle\n\tif (IsObstacle(end_idx)) {\n\t\tVector3i dir = (start_idx - end_idx).normalized();\n\t\tVector3i new_end_idx = end_idx;\n\t\twhile (IsObstacle(new_end_idx)) {\n\t\t\tnew_end_idx += dir;\n\t\t}\n\t\tend_idx = new_end_idx;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 43.980197994794544}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert start and end points to indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// If start or end point is inside an obstacle, adjust it by moving it away from the other point\n\t// until it is no longer in an obstacle\n\twhile (IsObstacle(start_idx)) {\n\t\tVector3d diff = end_pt - start_pt;\n\t\tif (diff.norm() < 1e-3) {\n\t\t\treturn false;\n\t\t}\n\t\tstart_pt += diff.normalized() * 1e-3;\n\t\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\twhile (IsObstacle(end_idx)) {\n\t\tVector3d diff = start_pt - end_pt;\n\t\tif (diff.norm() < 1e-3) {\n\t\t\treturn false;\n\t\t}\n\t\tend_pt += diff.normalized() * 1e-3;\n\t\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 48.007640166351514}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\tif (!ConvertToIndex(start_pt, start_idx) ||!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\tif (!IsPointInsideObstacle(start_idx)) {\n\t\treturn true;\n\t}\n\tVector3i start_idx_copy = start_idx;\n\tVector3i end_idx_copy = end_idx;\n\tVector3d start_pt_copy = start_pt;\n\tVector3d end_pt_copy = end_pt;\n\tVector3d start_pt_copy_prev = start_pt;\n\tVector3d end_pt_copy_prev = end_pt;\n\tVector3d start_pt_copy_prev_prev = start_pt;\n\tVector3d end_pt_copy_prev_prev = end_pt;\n\tVector3d start_pt_copy_prev_prev_prev = start_pt;\n\tVector3d end_pt_copy_prev_prev_prev = end_pt;\n\tVector3d start_pt_copy_prev_prev_prev_prev = start_pt;\n\tVector3d end_pt_copy_prev_prev_prev_prev = end_pt;\n\tVector3d start_pt_copy_prev_prev_prev_prev_prev = start_pt;\n\tVector3d end_pt_copy_prev_prev_prev_prev_prev = end_pt;\n\tVector3d start_pt_copy_prev_prev_prev_prev_prev_prev = start_pt;\n\tVector3d end_pt_copy_prev_prev_prev_prev_prev_prev = end_pt;\n\tVector3d start_pt_copy_prev_prev_prev_prev_prev_prev_prev = start_pt;\n\tVector3d end_pt_copy_prev_prev_prev_prev_prev_prev_prev = end_pt;\n\tVector3d start_pt_copy_prev_prev_prev_prev_prev_prev_prev_prev = start_pt;\n\tVector3d end_pt_copy_prev_prev_prev_prev_prev_prev_prev_prev = end_pt;\n\tVector3d start_pt_", "CodeBleu_score": 31.70972401468073}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\tEigen::Vector3i min_id = worldToGrid(min_pos);\n\tEigen::Vector3i max_id = worldToGrid(max_pos);\n\tfor (int i = min_id(0); i <= max_id(0); i++) {\n\t\tfor (int j = min_id(1); j <= max_id(1); j++) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t\tdistance_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.223630861534495}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\tEigen::Vector3i min_id, max_id;\n\tworldToMap(min_pos, min_id);\n\tworldToMap(max_pos, max_id);\n\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t\tdistance_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.69019851672641}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\t// Get the min and max grid coordinates\n\tEigen::Vector3i min_id = worldToGrid(min_pos);\n\tEigen::Vector3i max_id = worldToGrid(max_pos);\n\n\t// Iterate over the grid coordinates and set the occupancy buffer to zero\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 45.00398180922664}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d max_diff = diff.cwiseMax(Eigen::Vector3d::Zero());\n\tEigen::Vector3d min_diff = diff.cwiseMin(Eigen::Vector3d::Zero());\n\tEigen::Vector3d max_diff_inv = max_diff.cwiseInverse();\n\tEigen::Vector3d min_diff_inv = min_diff.cwiseInverse();\n\tEigen::Vector3d max_scale = max_diff_inv.cwiseQuotient(min_diff_inv);\n\tEigen::Vector3d min_scale = max_diff_inv.cwiseQuotient(max_diff_inv);\n\tEigen::Vector3d scale = min_scale.cwiseMin(max_scale);\n\tEigen::Vector3d scale_inv = scale.cwiseInverse();\n\tEigen::Vector3d new_pt = camera_pt + scale_inv.cwiseProduct(diff);\n\treturn new_pt;\n}\n", "CodeBleu_score": 31.928909344397695}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_max = (double) (map_width - 1) / (double) resolution;\n\tdouble x_min = (double) 0.0;\n\tdouble y_max = (double) (map_height - 1) / (double) resolution;\n\tdouble y_min = (double) 0.0;\n\tdouble z_max = (double) (map_depth - 1) / (double) resolution;\n\tdouble z_min = (double) 0.0;\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\tif (diff(0)!= 0.0) {\n\t\tx_scale = (diff(0) > 0.0)? (x_max - camera_pt(0)) / diff(0) : (x_min - camera_pt(0)) / diff(0);\n\t}\n\tif (diff(1)!= 0.0) {\n\t\ty_scale = (diff(1) > 0.0)? (y_max - camera_pt(1)) / diff(1) : (y_min - camera_pt(1)) / diff(1);\n\t}\n\tif (diff(2)!= 0.0) {\n\t\tz_scale = (diff(2) > 0.0)? (z_max - camera_pt(2)) / diff(2) : (z_min - camera_pt(2)) / diff(2);\n\t}\n\tdouble scale = std::min(std::min(x_scale, y_scale), z_scale);\n\tEigen::Vector3d new_pt = camera_pt + scale * diff;\n\treturn new_pt;\n}\n", "CodeBleu_score": 34.464470760074285}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d max_coeff = diff.cwiseQuotient(max_pt - camera_pt);\n\tEigen::Vector3d min_coeff = diff.cwiseQuotient(min_pt - camera_pt);\n\tdouble min_coeff_max = min_coeff.maxCoeff();\n\tdouble max_coeff_min = max_coeff.minCoeff();\n\tdouble coeff = 1.0;\n\tif (min_coeff_max > 0.0) {\n\t\tcoeff = min_coeff_max;\n\t} else if (max_coeff_min < 1.0) {\n\t\tcoeff = max_coeff_min;\n\t}\n\treturn camera_pt + coeff * diff;\n}\n", "CodeBleu_score": 40.353948390656235}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// Update the last occupancy update time\n\tlast_occupancy_update_time_ = ros::Time::now();\n\n\t// If an update is needed\n\tif (update_occupancy_grid_) {\n\t\t// Clear the local map\n\t\tlocal_map_.clear();\n\n\t\t// If the local map has been updated\n\t\tif (local_map_updated_) {\n\t\t\t// Clear the local map\n\t\t\tlocal_map_.clear();\n\n\t\t\t// Inflates the local map\n\t\t\tlocal_map_.inflate();\n\n\t\t\t// Clear the local map update flag\n\t\t\tlocal_map_updated_ = false;\n\t\t}\n\n\t\t// If the depth image is not empty\n\t\tif (!depth_image_.empty()) {\n\t\t\t// Projects the depth image into points\n\t\t\tprojectDepthImageIntoPoints();\n\n\t\t\t// Processes the points with raycasting\n\t\t\tprocessPointsWithRaycasting();\n\t\t}\n\n\t\t// If the depth image is empty\n\t\telse {\n\t\t\t// If the depth image has been updated\n\t\t\tif (depth_image_updated_) {\n\t\t\t\t// Clears the points\n\t\t\t\tpoints_.clear();\n\n\t\t\t\t// Clear the depth image update flag\n\t\t\t\tdepth_image_updated_ = false;\n\t\t\t}\n\t\t}\n\n\t\t// Clears the update occupancy grid flag\n\t\tupdate_occupancy_grid_ = false;\n\t}\n\n\t// If the odometry data is empty\n\tif (odometry_.empty()) {\n\t\t// If the odometry data has been updated\n\t\tif (odometry_updated_) {\n\t\t\t// Clears the odometry data\n\t\t\todometry_.clear();\n\n\t\t\t// Clear the odometry update flag\n\t\t\todometry_updated_ = false;\n\t\t}\n\n\t\t// If the odometry data has not been updated\n\t\telse {\n\t\t\t// If the odometry data has not been updated for more than 5 seconds\n\t\t\tif ((ros::Time::now() - last_odometry_update_time_).toSec() > 5.0) {\n\t\t\t\t// Sets the odometry timeout flag\n\t\t\t\todometry_timeout_ = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the depth image is empty\n\tif (depth_image_.empty()) {\n\t\t// If the depth image has been updated\n\t\tif (depth_image_updated_) {\n\t\t", "CodeBleu_score": 36.44074829592833}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t//ROS_INFO(\"Updating occupancy grid.\");\n\tlast_update_time_ = ros::Time::now();\n\n\t// Check if we have a new depth image\n\tif (depth_image_sub_.getNumPublishers() > 0) {\n\t\tif (depth_image_sub_.getTopic()!= depth_image_topic_) {\n\t\t\tdepth_image_topic_ = depth_image_sub_.getTopic();\n\t\t\tROS_INFO(\"Subscribed to new depth image topic: %s\", depth_image_topic_.c_str());\n\t\t}\n\t\tif (depth_image_sub_.getNumPublishers() == 0) {\n\t\t\tROS_WARN(\"Depth image topic '%s' has no publishers.\", depth_image_topic_.c_str());\n\t\t}\n\t}\n\n\t// Check if we have a new odometry\n\tif (odom_sub_.getNumPublishers() > 0) {\n\t\tif (odom_sub_.getTopic()!= odom_topic_) {\n\t\t\todom_topic_ = odom_sub_.getTopic();\n\t\t\tROS_INFO(\"Subscribed to new odometry topic: %s\", odom_topic_.c_str());\n\t\t}\n\t\tif (odom_sub_.getNumPublishers() == 0) {\n\t\t\tROS_WARN(\"Odometry topic '%s' has no publishers.\", odom_topic_.c_str());\n\t\t}\n\t}\n\n\t// Check if we have a new camera info\n\tif (camera_info_sub_.getNumPublishers() > 0) {\n\t\tif (camera_info_sub_.getTopic()!= camera_info_topic_) {\n\t\t\tcamera_info_topic_ = camera_info_sub_.getTopic();\n\t\t\tROS_INFO(\"Subscribed to new camera info topic: %s\", camera_info_topic_.c_str());\n\t\t}\n\t\tif (camera_info_sub_.getNumPublishers() == 0) {\n\t\t\tROS_WARN(\"Camera info topic '%s' has no publishers.\", camera_info_topic_.c_str());\n\t\t}\n\t}\n\n\t// Check if we have a new depth image and odometry\n\tif (new_depth_image_ && new_odom_) {\n\t\tnew_depth_image_ = false", "CodeBleu_score": 34.21172474507556}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// Update last occupancy update time\n\tlastOccupancyUpdate = ros::Time::now();\n\n\t// Check if an update is needed\n\tif (depth_image_sub.getNumPublishers() > 0 && odom_sub.getNumPublishers() > 0) {\n\t\t// Check if the local map has been updated\n\t\tif (localMapUpdated) {\n\t\t\t// Clear and inflate the local map\n\t\t\tlocalMap.clear();\n\t\t\tlocalMap.inflate();\n\t\t\tlocalMapUpdated = false;\n\t\t}\n\n\t\t// Get the depth image\n\t\tcv::Mat depthImage;\n\t\tif (depth_image_sub.getNumPublishers() > 0) {\n\t\t\tdepthImage = depthImageSub.getDepthImage();\n\t\t} else {\n\t\t\tdepthImage = cv::Mat(depthImageSub.getHeight(), depthImageSub.getWidth(), CV_16UC1);\n\t\t}\n\n\t\t// Check if the depth image is valid\n\t\tif (depthImage.empty()) {\n\t\t\t// Set the depth image timeout flag\n\t\t\tdepthImageTimeout = true;\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Clear the depth image timeout flag\n\t\t\tdepthImageTimeout = false;\n\t\t}\n\n\t\t// Get the current odometry\n\t\tgeometry_msgs::Pose pose;\n\t\tif (odom_sub.getNumPublishers() > 0) {\n\t\t\tpose = odomSub.getPose();\n\t\t} else {\n\t\t\tpose = geometry_msgs::Pose();\n\t\t}\n\n\t\t// Check if the odometry is valid\n\t\tif (pose.orientation.x == 0 && pose.orientation.y == 0 && pose.orientation.z == 0 && pose.orientation.w == 0) {\n\t\t\t// Set the odometry timeout flag\n\t\t\todomTimeout = true;\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Clear the odometry timeout flag\n\t\t\todomTimeout = false;\n\t\t}\n\n\t\t// Project the depth image into points\n\t\tstd::vector<cv::Point3f> points;\n\t\tdepthImageSub.projectDepthImageIntoPoints(points, depthImage);\n\n\t\t// Process the points with raycasting\n\t\tfor (unsigned int i = 0; i < points.size(); i++) {\n\t\t\t// Get the point\n\t\t\tcv::Point3f point =", "CodeBleu_score": 30.151676078986622}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat f_measure = 0.0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tf_measure += ellipse_evaluate(image_fns[i], gt_fns[i], dt_fns[i], gt_angle_radians);\n\t}\n\treturn f_measure / image_fns.size();\n}\n", "CodeBleu_score": 44.644199515749634}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat total_fmeasure = 0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tEllipseGroundTruth gt;\n\t\tgt.loadFromTextFile(gt_fns[i]);\n\t\tEllipseDetectionResult dt;\n\t\tdt.loadFromTextFile(dt_fns[i]);\n\t\tfloat fmeasure = ellipse_fmeasure(gt, dt, gt_angle_radians);\n\t\ttotal_fmeasure += fmeasure;\n\t}\n\treturn total_fmeasure / image_fns.size();\n}\n", "CodeBleu_score": 55.34902049849746}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tint n = image_fns.size();\n\tfloat f_measure = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tf_measure += ellipse_evaluate(image_fns[i], gt_fns[i], dt_fns[i], gt_angle_radians);\n\t}\n\treturn f_measure / n;\n}\n", "CodeBleu_score": 40.142968956508795}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tfloat angle1, angle2;\n\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\tangle1 = atan2(y, x - foci[0]);\n\tangle2 = atan2(y, x - foci[1]);\n\treturn angle1 - angle2;\n}\n", "CodeBleu_score": 27.266594855446254}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tif (foci!= NULL) {\n\t\tfloat angle_1 = atan2f(y - foci[0], x - foci[2]);\n\t\tfloat angle_2 = atan2f(y - foci[1], x - foci[3]);\n\t\tfloat normal_angle = angle_2 - angle_1;\n\t\tif (normal_angle > M_PI) {\n\t\t\tnormal_angle -= 2 * M_PI;\n\t\t} else if (normal_angle < -M_PI) {\n\t\t\tnormal_angle += 2 * M_PI;\n\t\t}\n\t\treturn normal_angle;\n\t} else {\n\t\treturn 0.0f;\n\t}\n}\n", "CodeBleu_score": 43.93283715293135}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tif (foci!= NULL) {\n\t\tfloat angle1 = atan2f(y - foci[0], x - foci[1]);\n\t\tfloat angle2 = atan2f(y - foci[2], x - foci[3]);\n\t\tfloat normal_angle = angle1 - angle2;\n\t\tif (normal_angle > M_PI) {\n\t\t\tnormal_angle -= 2 * M_PI;\n\t\t} else if (normal_angle < -M_PI) {\n\t\t\tnormal_angle += 2 * M_PI;\n\t\t}\n\t\treturn normal_angle;\n\t}\n\treturn 0.0f;\n}\n", "CodeBleu_score": 42.01776400452735}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)\tint i, j, k, l;\n\tdouble x_min, x_max, y_min, y_max;\n\tdouble integral_above, integral_below;\n\tdouble x_start, x_end, y_start, y_end;\n\tdouble x_left, x_right, y_left, y_right;\n\tdouble x_left_min, x_left_max, y_left_min, y_left_max;\n\tdouble x_right_min, x_right_max, y_right_min, y_right_max;\n\tdouble integral_left_above, integral_left_below, integral_right_above, integral_right_below;\n\tdouble x_left_start, x_left_end, y_left_start, y_left_end;\n\tdouble x_right_start, x_right_end, y_right_start, y_right_end;\n\n\t// Find the minimum and maximum x and y coordinates of the points in the section\n\tx_min = x_max = vp1[start].x;\n\ty_min = y_max = vp1[start].y;\n\tfor (i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < x_min) x_min = vp1[i].x;\n\t\tif (vp1[i].x > x_max) x_max = vp1[i].x;\n\t\tif (vp1[i].y < y_min) y_min = vp1[i].y;\n\t\tif (vp1[i].y > y_max) y_max = vp1[i].y;\n\t}\n\n\t// Compute the integral above and below the polygon section\n\tintegral_above = integral_below = 0.0;\n\tfor (i = start; i < end - 1; i++) {\n\t\tx_start = vp1[i].x;\n\t\tx_end = vp1[i + 1].x;\n\t\ty_start = vp1[i].y;\n\t\ty_end = vp1[i + 1].y;\n\t\tif (x_start > x_end) {\n\t\t\tx_left =", "CodeBleu_score": 32.03480945249482}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\tdouble x_min, x_max, y_min, y_max;\n\tx_min = x_max = vp1[start].x;\n\ty_min = y_max = vp1[start].y;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < x_min)\n\t\t\tx_min = vp1[i].x;\n\t\tif (vp1[i].x > x_max)\n\t\t\tx_max = vp1[i].x;\n\t\tif (vp1[i].y < y_min)\n\t\t\ty_min = vp1[i].y;\n\t\tif (vp1[i].y > y_max)\n\t\t\ty_max = vp1[i].y;\n\t}\n\tdouble integral_above = 0, integral_below = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tdouble x1 = vp1[i].x, y1 = vp1[i].y, x2 = vp1[i + 1].x, y2 = vp1[i + 1].y;\n\t\tdouble a = y1 - y2, b = x2 - x1, c = x1 * y2 - x2 * y1;\n\t\tdouble x_int = -c / b, y_int = -c / a;\n\t\tif (x_int >= x_min && x_int <= x_max) {\n\t\t\tif (y_int >= y_min && y_int <= y_max) {\n\t\t\t\tif (y_int > vp1[i].y)\n\t\t\t\t\tintegral_above += (y_int - vp1[i].y) * (vp1[i + 1].x - vp1[i].x);\n\t\t\t\telse\n\t\t\t\t\tintegral_below += (vp1[i].y - y_int) * (vp1[i + 1].x - vp1[i].x);\n\t\t\t}\n\t\t}\n\t}\n\tif (integral_above < integral_below)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n", "CodeBleu_score": 43.133686668839815}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\tint i;\n\tdouble x_min = 1000000, x_max = -1000000, y_min = 1000000, y_max = -1000000;\n\tdouble integral_above = 0, integral_below = 0;\n\tdouble x1, x2, y1, y2;\n\n\tfor (i = start; i < end; i++) {\n\t\tif (vp1[i].x < x_min)\n\t\t\tx_min = vp1[i].x;\n\t\tif (vp1[i].x > x_max)\n\t\t\tx_max = vp1[i].x;\n\t\tif (vp1[i].y < y_min)\n\t\t\ty_min = vp1[i].y;\n\t\tif (vp1[i].y > y_max)\n\t\t\ty_max = vp1[i].y;\n\t}\n\n\tfor (i = start; i < end - 1; i++) {\n\t\tx1 = vp1[i].x;\n\t\tx2 = vp1[i + 1].x;\n\t\ty1 = vp1[i].y;\n\t\ty2 = vp1[i + 1].y;\n\n\t\tif (x1 > x2) {\n\t\t\tdouble temp;\n\t\t\ttemp = x1;\n\t\t\tx1 = x2;\n\t\t\tx2 = temp;\n\t\t\ttemp = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = temp;\n\t\t}\n\n\t\tif (x1 < x_max && x2 > x_min) {\n\t\t\tif (y1 < y2) {\n\t\t\t\tif (x1 < x_min)\n\t\t\t\t\tx1 = x_min;\n\t\t\t\tif (x2 > x_max)\n\t\t\t\t\tx2 = x_max;\n\t\t\t\tintegral_above += (y2 - y1) * (x2 - x1);\n\t\t\t} else {\n\t\t\t\tif (x1 < x_min)\n\t\t\t\t\tx1 = x_min;\n\t\t\t\tif (x2 > x_max)\n\t\t\t\t\tx2 = x_max;\n\t\t\t\tintegral_below += (y1 - y2) * (x2 - x1", "CodeBleu_score": 34.50123460796585}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].id == \"T\") {\n\t\t\tellipse_det.num_lost = 0;\n\t\t\tellipse_det.num_regain++;\n\t\t\tif (ellipse_det.num_regain > VISION_THRES) {\n\t\t\t\tellipse_det.is_detected = true;\n\t\t\t}\n\t\t} else {\n\t\t\tellipse_det.num_regain = 0;\n\t\t\tellipse_det.num_lost++;\n\t\t\tif (ellipse_det.num_lost > VISION_THRES) {\n\t\t\t\tellipse_det.is_detected = false;\n\t\t\t}\n\t\t}\n\t}\n\tellipse_det.sight_angle = msg->detection_infos[0].distance;\n}\n", "CodeBleu_score": 38.75218646335228}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tellipse_det.center.x = msg->detection_infos[i].center.x;\n\t\t\tellipse_det.center.y = msg->detection_infos[i].center.y;\n\t\t\tellipse_det.center.z = msg->detection_infos[i].center.z;\n\t\t\tellipse_det.size.x = msg->detection_infos[i].size.x;\n\t\t\tellipse_det.size.y = msg->detection_infos[i].size.y;\n\t\t\tellipse_det.size.z = msg->detection_infos[i].size.z;\n\t\t\tellipse_det.orientation.x = msg->detection_infos[i].orientation.x;\n\t\t\tellipse_det.orientation.y = msg->detection_infos[i].orientation.y;\n\t\t\tellipse_det.orientation.z = msg->detection_infos[i].orientation.z;\n\t\t\tellipse_det.orientation.w = msg->detection_infos[i].orientation.w;\n\t\t\tellipse_det.sight_angle = msg->detection_infos[i].sight_angle;\n\t\t\tellipse_det.name = msg->detection_infos[i].name;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 53.71865674177347}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\t// ROS_INFO(\"ellipse_det_cb\");\n\tif (msg->detection_infos.size() > 0) {\n\t\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\t\tnum_regain++;\n\t\t\t\tnum_lost = 0;\n\t\t\t} else {\n\t\t\t\tnum_regain = 0;\n\t\t\t\tnum_lost++;\n\t\t\t}\n\t\t\tif (num_lost > VISION_THRES) {\n\t\t\t\tis_detected = false;\n\t\t\t}\n\t\t\tif (num_regain > VISION_THRES) {\n\t\t\t\tis_detected = true;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 53.24025122255569}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}\n", "CodeBleu_score": 44.198719218951375}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\t// check the safety of the current position\n\tbool safe = Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n\treturn safe;\n}\n", "CodeBleu_score": 60.676225861454256}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\tEigen::Vector3d cur_pos_vec(cur_pos(0), cur_pos(1), cur_pos(2));\n\treturn Occupy_map_ptr->check_safety(cur_pos_vec, safe_distance);\n}\n", "CodeBleu_score": 49.58213347418963}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)\tNodePtr current_node = end_node;\n\tpath_nodes_.clear();\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 55.905843104590936}, {"code": "void Astar::retrievePath(NodePtr end_node)\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 53.82250977125761}, {"code": "void Astar::retrievePath(NodePtr end_node)\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 52.3892347514089}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \tif(id < 0 || id >= nei_num)\n\t\treturn;\n\n\tif(sim_mode) {\n\t\tif(sqrt(pow(odom->pose.pose.position.x - start_pose.position.x, 2) + pow(odom->pose.pose.position.y - start_pose.position.y, 2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n\n\tstate_nei[id][0] = odom->pose.pose.position.x;\n\tstate_nei[id][1] = odom->pose.pose.position.y;\n\tstate_nei[id][2] = tf::getYaw(odom->pose.pose.orientation);\n}\n", "CodeBleu_score": 55.18874269138041}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \tif (id == 0) {\n\t\tstate_nei[0] = odom->pose.pose.position.x;\n\t\tstate_nei[1] = odom->pose.pose.position.y;\n\t\tstate_nei[2] = odom->pose.pose.position.z;\n\t\tget_nei_state = true;\n\t\tif (sim_mode) {\n\t\t\tdouble dist = sqrt(pow(state_nei[0] - start_pos_x, 2) + pow(state_nei[1] - start_pos_y, 2));\n\t\t\tif (dist > 5.0) {\n\t\t\t\tget_nei_state = false;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.43991375398026}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \tdouble nei_x = odom->pose.pose.position.x;\n\tdouble nei_y = odom->pose.pose.position.y;\n\tdouble nei_z = odom->pose.pose.position.z;\n\tdouble nei_roll, nei_pitch, nei_yaw;\n\ttf::Quaternion q(odom->pose.pose.orientation.x, odom->pose.pose.orientation.y, odom->pose.pose.orientation.z, odom->pose.pose.orientation.w);\n\ttf::Matrix3x3 m(q);\n\tm.getRPY(nei_roll, nei_pitch, nei_yaw);\n\n\tstate_nei[id][0] = nei_x;\n\tstate_nei[id][1] = nei_y;\n\tstate_nei[id][2] = nei_z;\n\tstate_nei[id][3] = nei_roll;\n\tstate_nei[id][4] = nei_pitch;\n\tstate_nei[id][5] = nei_yaw;\n\n\tif (sim_mode) {\n\t\tdouble distance = sqrt(pow(nei_x - start_x, 2) + pow(nei_y - start_y, 2));\n\t\tif (distance > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n}\n", "CodeBleu_score": 56.831775162706975}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (!odom_ready) {\n\t\treturn;\n\t}\n\n\tif (sensor_ready) {\n\t\treturn;\n\t}\n\n\tif (update_count < 5) {\n\t\tupdate_count++;\n\t\treturn;\n\t}\n\n\tupdate_count = 0;\n\n\tsensor_msgs::PointCloud2 cloud;\n\tpcl_ros::transformPointCloud(frame_id, *msg, cloud, tf_listener);\n\n\tpcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n\tpcl::fromROSMsg(cloud, pcl_cloud);\n\n\tif (pcl_cloud.size() == 0) {\n\t\treturn;\n\t}\n\n\tstd::vector<pcl::PointXYZ> points;\n\tfor (pcl::PointXYZ point : pcl_cloud) {\n\t\tif (point.x > 100 || point.y > 100 || point.x < -100 || point.y < -100) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpoints.push_back(point);\n\t}\n\n\tif (points.size() == 0) {\n\t\treturn;\n\t}\n\n\tstd::vector<pcl::PointXYZ> cloud_points = points;\n\n\tpcl::PointXYZ min_point, max_point;\n\tpcl::getMinMax3D(cloud_points, min_point, max_point);\n\n\tdouble min_x = min_point.x;\n\tdouble max_x = max_point.x;\n\tdouble min_y = min_point.y;\n\tdouble max_y = max_point.y;\n\n\tdouble width = max_x - min_x;\n\tdouble height = max_y - min_y;\n\n\tif (width == 0 || height == 0) {\n\t\treturn;\n\t}\n\n\tdouble x_scale = 100 / width;\n\tdouble y_scale = 100 / height;\n\n\tdouble min_x_scaled = min_x * x_scale;\n\tdouble min_y_scaled = min_y * y_scale;\n\n\tstd::vector<pcl::PointXYZ> scaled_points;\n\tfor (pcl::PointXYZ point : points) {\n\t\tpcl::PointXYZ scaled_point", "CodeBleu_score": 43.520478245176065}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tif (sensor_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter == 5) {\n\t\tupdate_counter = 0;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\t\tpcl::fromROSMsg(*msg, cloud);\n\t\tfor (int i = 0; i < cloud.points.size(); i++) {\n\t\t\tif (cloud.points[i].x < 0.0 || cloud.points[i].x > 10.0 || cloud.points[i].y < 0.0 || cloud.points[i].y > 10.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint x = (int) (cloud.points[i].x * 100.0);\n\t\t\tint y = (int) (cloud.points[i].y * 100.0);\n\t\t\tastar_map[x][y] = 1;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 49.477732372407814}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (!odom_ready) {\n\t\treturn;\n\t}\n\n\tsensor_ready = true;\n\tupdate_count++;\n\n\tpcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n\tpcl::fromROSMsg(*msg, pcl_cloud);\n\n\tif (update_count % 5 == 0) {\n\t\tupdate_count = 0;\n\t\tupdateMap(pcl_cloud);\n\t}\n}\n", "CodeBleu_score": 50.94047071583635}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, global_pcl);\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl2;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl3;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl4;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl5;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl6;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl7;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl8;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl9;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl10;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl11;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl12;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl13;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl14;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl15;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl16;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl17;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl18;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl19;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl20;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl21;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl22;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl23;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl24;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl25;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl26;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_pcl27;\n\t\tpcl::PointCloud<pcl::PointXYZ> temp_", "CodeBleu_score": 32.205274147608655}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp);\n\t\tpcl::VoxelGrid<pcl::PointXYZ> vg;\n\t\tvg.setInputCloud(gpcl_tmp);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f);\n\t\tvg.filter(*gpcl);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp2(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp2);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp3(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp3);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp4(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp4);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp5(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp5);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp6(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp6);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp7(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp7);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp8(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp8);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_tmp9(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_tmp9);", "CodeBleu_score": 43.07414102940657}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl) {\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tget_gpcl = false;\n\t\tgpcl_inflated = false;\n\t\tgpcl_inflated_pub = false;\n\t}\n}\n", "CodeBleu_score": 25.4433336383665}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// Get the laser scan in a PointCloud2 format\n\tsensor_msgs::PointCloud2 cloud;\n\tprojector_.transformLaserScanToPointCloud(\"base_link\", *local_point, cloud, tfListener_);\n\n\t// Convert the PointCloud2 to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl;\n\tpcl::fromROSMsg(cloud, cloud_pcl);\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif(!simulation_mode_) {\n\t\t// Get the odometry information\n\t\ttf::StampedTransform odom_trans;\n\t\ttry {\n\t\t\ttfListener_.lookupTransform(\"map\", \"base_link\", ros::Time(0), odom_trans);\n\t\t}\n\t\tcatch (tf::TransformException ex) {\n\t\t\tROS_ERROR(\"%s\",ex.what());\n\t\t\treturn;\n\t\t}\n\n\t\t// Transform the local map into the global frame\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_transformed;\n\t\tpcl_ros::transformPointCloud(cloud_pcl, cloud_transformed, odom_trans);\n\n\t\t// Merge the local map with the global map\n\t\tpcl::PointCloud<pcl::PointXYZ> merged_cloud;\n\t\tpcl::concatenatePointCloud(cloud_transformed, *global_map_, merged_cloud);\n\n\t\t// Convert the merged map to a PointCloud2\n\t\tpcl::toROSMsg(merged_cloud, cloud);\n\t}\n\n\t// Update the occupancy map\n\tmap_update(cloud);\n}\n", "CodeBleu_score": 44.22188008925401}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// Convert the laser scan to a point cloud\n\tsensor_msgs::PointCloud2 cloud_msg;\n\tprojector_.transformLaserScanToPointCloud(\"base_link\", *local_point, cloud_msg, tfListener_);\n\n\t// Convert the point cloud to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(cloud_msg, cloud);\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif (!simulation_mode_) {\n\t\t// Get the current robot pose\n\t\ttf::StampedTransform robot_pose;\n\t\ttfListener_.lookupTransform(\"map\", \"base_link\", ros::Time(0), robot_pose);\n\n\t\t// Update the map\n\t\tupdate_map(cloud, robot_pose);\n\t}\n\t// If in simulation mode, just update the map\n\telse {\n\t\tupdate_map(cloud);\n\t}\n}\n", "CodeBleu_score": 48.91973994549074}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// If in simulation mode, we just update the map\n\tif (simulation_mode) {\n\t\t// Get the laser scan in a PointCloud2 format\n\t\tpcl::PCLPointCloud2 pcl_pc2;\n\t\tpcl_conversions::toPCL(*local_point, pcl_pc2);\n\n\t\t// Convert the PointCloud2 to a pcl::PointCloud\n\t\tpcl::PointCloud<pcl::PointXYZ> pcl_pc;\n\t\tpcl::fromPCLPointCloud2(pcl_pc2, pcl_pc);\n\n\t\t// Update the occupancy grid\n\t\tupdate_map(pcl_pc, odom);\n\t}\n\t// Otherwise, we merge the local map with the provided odometry data\n\telse {\n\t\t// Get the laser scan in a PointCloud2 format\n\t\tpcl::PCLPointCloud2 pcl_pc2;\n\t\tpcl_conversions::toPCL(*local_point, pcl_pc2);\n\n\t\t// Convert the PointCloud2 to a pcl::PointCloud\n\t\tpcl::PointCloud<pcl::PointXYZ> pcl_pc;\n\t\tpcl::fromPCLPointCloud2(pcl_pc2, pcl_pc);\n\n\t\t// Get the current odometry data\n\t\ttf::Quaternion q(odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z, odom.pose.pose.orientation.w);\n\t\ttf::Matrix3x3 m(q);\n\t\tdouble roll, pitch, yaw;\n\t\tm.getRPY(roll, pitch, yaw);\n\t\tEigen::Matrix4f sensor_pose = Eigen::Matrix4f::Identity();\n\t\tsensor_pose(0, 0) = cos(yaw);\n\t\tsensor_pose(0, 1) = -sin(yaw);\n\t\tsensor_pose(1, 0) = sin(yaw);\n\t\tsensor_pose(1, 1) = cos(yaw);\n\t\tsensor_pose(0, 3) = odom.pose.pose.position.x;\n\t\tsensor_pose(1, 3) = odom.pose.pose.position.y;\n\n\t\t// Update the occupancy grid\n\t\tupdate_map(pcl_pc, sensor_pose);\n\t}\n}\n", "CodeBleu_score": 44.373126054427416}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t//ROS_INFO(\"pub_pcl_cb\");\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> inflate_pcl;\n\tpcl::PointXYZ pt;\n\n\tfor(int i=0; i<map_size; i++) {\n\t\tfor(int j=0; j<map_size; j++) {\n\t\t\tif(global_map[i][j]!= -1) {\n\t\t\t\tpt.x = i;\n\t\t\t\tpt.y = j;\n\t\t\t\tpt.z = 0;\n\t\t\t\tglobal_pcl.push_back(pt);\n\t\t\t\tif(global_map[i][j] == 1) {\n\t\t\t\t\tinflate_pcl.push_back(pt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsensor_msgs::PointCloud2 msg;\n\tpcl::toROSMsg(global_pcl, msg);\n\tmsg.header.frame_id = \"world\";\n\tmsg.header.stamp = ros::Time::now();\n\tglobal_pcl_pub.publish(msg);\n\n\tpcl::toROSMsg(inflate_pcl, msg);\n\tmsg.header.frame_id = \"world\";\n\tmsg.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(msg);\n}\n", "CodeBleu_score": 51.85915037796025}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\tpcl::PointCloud<pcl::PointXYZI> pcl_map;\n\tpcl::PointCloud<pcl::PointXYZI> pcl_map_inflate;\n\n\tpcl_map.header.frame_id = \"world\";\n\tpcl_map_inflate.header.frame_id = \"world\";\n\n\tpcl_map.height = 1;\n\tpcl_map_inflate.height = 1;\n\n\tpcl_map.width = map.size();\n\tpcl_map_inflate.width = map_inflate.size();\n\n\tpcl_map.points.resize(pcl_map.width * pcl_map.height);\n\tpcl_map_inflate.points.resize(pcl_map_inflate.width * pcl_map_inflate.height);\n\n\tfor (int i = 0; i < pcl_map.points.size(); i++) {\n\t\tpcl_map.points[i].x = map[i].x;\n\t\tpcl_map.points[i].y = map[i].y;\n\t\tpcl_map.points[i].z = 0;\n\t\tpcl_map.points[i].intensity = map[i].occupancy;\n\t}\n\n\tfor (int i = 0; i < pcl_map_inflate.points.size(); i++) {\n\t\tpcl_map_inflate.points[i].x = map_inflate[i].x;\n\t\tpcl_map_inflate.points[i].y = map_inflate[i].y;\n\t\tpcl_map_inflate.points[i].z = 0;\n\t\tpcl_map_inflate.points[i].intensity = map_inflate[i].occupancy;\n\t}\n\n\tglobal_pcl_pub.publish(pcl_map);\n\tinflate_pcl_pub.publish(pcl_map_inflate);\n}\n", "CodeBleu_score": 48.80754174758651}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\tpcl::PointCloud<pcl::PointXYZ> pcl_map;\n\tpcl::PointCloud<pcl::PointXYZ> pcl_inflate_map;\n\tpcl_map.header.frame_id = \"world\";\n\tpcl_inflate_map.header.frame_id = \"world\";\n\tpcl_map.header.stamp = ros::Time::now();\n\tpcl_inflate_map.header.stamp = ros::Time::now();\n\tfor(int i = 0; i < map_size_x; i++) {\n\t\tfor(int j = 0; j < map_size_y; j++) {\n\t\t\tif(map[i][j] == 1) {\n\t\t\t\tpcl::PointXYZ pcl_point;\n\t\t\t\tpcl_point.x = (float)i;\n\t\t\t\tpcl_point.y = (float)j;\n\t\t\t\tpcl_point.z = 0.0;\n\t\t\t\tpcl_map.push_back(pcl_point);\n\t\t\t}\n\t\t\tif(inflate_map[i][j] == 1) {\n\t\t\t\tpcl::PointXYZ pcl_point;\n\t\t\t\tpcl_point.x = (float)i;\n\t\t\t\tpcl_point.y = (float)j;\n\t\t\t\tpcl_point.z = 0.0;\n\t\t\t\tpcl_inflate_map.push_back(pcl_point);\n\t\t\t}\n\t\t}\n\t}\n\tpcl_pub.publish(pcl_map);\n\tinflate_pcl_pub.publish(pcl_inflate_map);\n}\n", "CodeBleu_score": 46.16702309452009}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS", "CodeBleu_score": 8.229838962512142}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\t//ROS_INFO(\"Received pointcloud\");\n\tif (!sensor_ready) {\n\t\t//ROS_INFO(\"Sensor ready\");\n\t\tsensor_ready = true;\n\t}\n\tif (msg->width == 0) {\n\t\tROS_WARN(\"Pointcloud empty\");\n\t\treturn;\n\t}\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(*msg, cloud);\n\n\tif (!odom_ready) {\n\t\tROS_INFO(\"Waiting for odometry\");\n\t\treturn;\n\t}\n\n\t//ROS_INFO(\"Updating map\");\n\tupdateMap(cloud);\n\t//ROS_INFO(\"Map updated\");\n}\n", "CodeBleu_score": 52.0981353228745}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t}\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(*msg, cloud);\n\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered;\n\tpcl::VoxelGrid<pcl::PointXYZ> vg;\n\tvg.setInputCloud(cloud.makeShared());\n\tvg.setLeafSize(0.1f, 0.1f, 0.1f);\n\tvg.filter(cloud_filtered);\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud_filtered));\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_filtered(new pcl::PointCloud<pcl::PointXYZ>(cloud_filtered));\n\n\tsensor_msgs::PointCloud2 cloud_ros;\n\tpcl::toROSMsg(*cloud_ptr_filtered, cloud_ros);\n\tcloud_ros.header.frame_id = \"odom\";\n\tcloud_pub.publish(cloud_ros);\n\n\t// update the A* algorithm's map\n\tfor (int i = 0; i < cloud_ptr_filtered->points.size(); i++) {\n\t\tpcl::PointXYZ p = cloud_ptr_filtered->points[i];\n\t\tif (p.x < 0 || p.y < 0 || p.x > map_width || p.y > map_height)\n\t\t\tcontinue;\n\t\tmap[(int) p.y][(int) p.x] = 1;\n\t}\n}\n", "CodeBleu_score": 42.09951661150789}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Get current pose\n\tEigen::Vector3d current_pose = body_controller_->getPose();\n\n\t// Get desired pose\n\tEigen::Vector3d desired_pose = body_controller_->getDesiredPose();\n\n\t// Get current pose error\n\tEigen::Vector3d pose_error = body_controller_->getPoseError();\n\n\t// Get desired twist\n\tEigen::Vector3d desired_twist = body_controller_->getDesiredTwist();\n\n\t// Get current twist\n\tEigen::Vector3d current_twist = body_controller_->getTwist();\n\n\t// Get current twist error\n\tEigen::Vector3d twist_error = body_controller_->getTwistError();\n\n\t// Get desired acceleration\n\tEigen::Vector3d desired_acceleration = body_controller_->getDesiredAcceleration();\n\n\t// Get current acceleration\n\tEigen::Vector3d current_acceleration = body_controller_->getAcceleration();\n\n\t// Get current acceleration error\n\tEigen::Vector3d acceleration_error = body_controller_->getAccelerationError();\n\n\t// Get desired jerk\n\tEigen::Vector3d desired_jerk = body_controller_->getDesiredJerk();\n\n\t// Get current jerk\n\tEigen::Vector3d current_jerk = body_controller_->getJerk();\n\n\t// Get current jerk error\n\tEigen::Vector3d jerk_error = body_controller_->getJerkError();\n\n\t// Get desired snap\n\tEigen::Vector3d desired_snap = body_controller_->getDesiredSnap();\n\n\t// Get current snap\n\tEigen::Vector3d current_snap = body_controller_->getSnap();\n\n\t// Get current snap error\n\tEigen::Vector3d snap_error = body_controller_->getSnapError();\n\n\t// Get desired yaw\n\tdouble desired_yaw = body_controller_->getDesiredYaw();\n\n\t// Get current yaw\n\tdouble current_yaw = body_controller_->getYaw();\n\n\t// Get current yaw error\n\tdouble yaw_error = body_controller_->getYawError();\n\n\t// Get desired yaw rate\n\tdouble desired_yaw_rate = body_controller_->getDesiredYawRate();\n\n\t// Get current yaw rate\n\t", "CodeBleu_score": 20.541780942029902}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get the time step\n\tdouble dt = event.current_real.toSec() - event.last_real.toSec();\n\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Get the current pose of the robot\n\tEigen::Vector3d current_position;\n\tEigen::Quaterniond current_orientation;\n\tEigen::Vector3d current_velocity;\n\tEigen::Vector3d current_angular_velocity;\n\tEigen::Vector3d current_acceleration;\n\tEigen::Vector3d current_angular_acceleration;\n\tEigen::Vector3d current_jerk;\n\tEigen::Vector3d current_angular_jerk;\n\trobot_->getPose(current_position, current_orientation);\n\trobot_->getVelocity(current_velocity, current_angular_velocity);\n\trobot_->getAcceleration(current_acceleration, current_angular_acceleration);\n\trobot_->getJerk(current_jerk, current_angular_jerk);\n\n\t// Get the desired pose of the robot\n\tEigen::Vector3d desired_position;\n\tEigen::Quaterniond desired_orientation;\n\tEigen::Vector3d desired_velocity;\n\tEigen::Vector3d desired_angular_velocity;\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d desired_angular_acceleration;\n\tEigen::Vector3d desired_jerk;\n\tEigen::Vector3d desired_angular_jerk;\n\trobot_->getCommand(desired_position, desired_orientation, desired_velocity, desired_angular_velocity, desired_acceleration, desired_angular_acceleration, desired_jerk, desired_angular_jerk);\n\n\t// Compute the desired body velocity\n\tEigen::Vector3d desired_body_velocity;\n\tEigen::Vector3d desired_body_acceleration;\n\tEigen::Vector3d desired_body_jerk;\n\tbody_controller_->computeDesiredBodyVelocity(current_position, current_orientation, current_velocity, current_angular_velocity, current_acceleration, current_angular_acceleration, current_jerk, current_angular_jerk, desired_position, desired_orientation, desired_velocity, desired_angular_velocity, desired_acceleration, desired_angular_acceleration, desired_jerk, desired_", "CodeBleu_score": 37.9310534047696}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get the current time\n\tros::Time now = ros::Time::now();\n\n\t// Compute the time since the last control loop iteration\n\tdouble dt = (now - last_time_).toSec();\n\n\t// Check if the control loop is running too slowly\n\tif (dt > 0.03) {\n\t\tROS_WARN_STREAM(\"Control loop running slowly! Time since last iteration: \" << dt);\n\t}\n\n\t// Store the current time for the next iteration\n\tlast_time_ = now;\n\n\t// Get the current robot pose\n\tquadruped_msgs::Pose robot_pose;\n\tif (!quadruped_interface_->getPose(robot_pose)) {\n\t\tROS_ERROR(\"Failed to get robot pose!\");\n\t\treturn;\n\t}\n\n\t// Get the current robot state\n\tquadruped_msgs::State robot_state;\n\tif (!quadruped_interface_->getState(robot_state)) {\n\t\tROS_ERROR(\"Failed to get robot state!\");\n\t\treturn;\n\t}\n\n\t// Get the current foot contact state\n\tquadruped_msgs::FootState foot_state;\n\tif (!quadruped_interface_->getFootState(foot_state)) {\n\t\tROS_ERROR(\"Failed to get foot state!\");\n\t\treturn;\n\t}\n\n\t// Get the current joint state\n\tquadruped_msgs::JointState joint_state;\n\tif (!quadruped_interface_->getJointState(joint_state)) {\n\t\tROS_ERROR(\"Failed to get joint state!\");\n\t\treturn;\n\t}\n\n\t// Get the current joint torques\n\tquadruped_msgs::JointTorque joint_torque;\n\tif (!quadruped_interface_->getJointTorque(joint_torque)) {\n\t\tROS_ERROR(\"Failed to get joint torque!\");\n\t\treturn;\n\t}\n\n\t// Get the current joint positions\n\tquadruped_msgs::JointPosition joint_position;\n\tif (!quadruped_interface_->getJointPosition(joint_position)) {\n\t\tROS_ERROR(\"Failed to get joint position!\");\n\t\treturn;\n\t}\n\n\t// Get the current joint velocities\n\tquadruped_msgs::JointVelocity joint_velocity;\n\tif (!quadruped_", "CodeBleu_score": 37.10897457606587}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\tif (foot_contacts_publisher_.getNumSubscribers() > 0 &&!gazebo_sim_) {\n\t\tquadruped_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = robot_frame_;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts.push_back(quadruped_msgs::Contact());\n\t\t\tcontacts_msg.contacts[i].leg_index = i;\n\t\t\tcontacts_msg.contacts[i].contact = foot_contacts[i];\n\t\t}\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}\n", "CodeBleu_score": 51.51808747835575}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\tif (foot_contacts_publisher_ && foot_contacts_publisher_->getNumSubscribers() > 0) {\n\t\tif (!gazebo_interface_) {\n\t\t\t// Create ContactsStamped message\n\t\t\tros::Time current_time = ros::Time::now();\n\t\t\tcontacts_stamped_msg_.header.stamp = current_time;\n\t\t\tcontacts_stamped_msg_.header.frame_id = \"world\";\n\n\t\t\t// Populate ContactsStamped message\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tcontacts_stamped_msg_.contacts[i].header.stamp = current_time;\n\t\t\t\tcontacts_stamped_msg_.contacts[i].header.frame_id = \"world\";\n\t\t\t\tcontacts_stamped_msg_.contacts[i].name = foot_names_[i];\n\t\t\t\tcontacts_stamped_msg_.contacts[i].state = foot_contacts[i];\n\t\t\t}\n\n\t\t\t// Publish ContactsStamped message\n\t\t\tfoot_contacts_publisher_->publish(contacts_stamped_msg_);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 45.1869825731396}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\tif (!gazebo_mode_) {\n\t\t\tquadruped_msgs::ContactsStamped contacts_msg;\n\t\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\t\tcontacts_msg.header.frame_id = \"base_link\";\n\t\t\tcontacts_msg.contacts.resize(4);\n\t\t\tcontacts_msg.contacts[0].state = foot_contacts[0];\n\t\t\tcontacts_msg.contacts[1].state = foot_contacts[1];\n\t\t\tcontacts_msg.contacts[2].state = foot_contacts[2];\n\t\t\tcontacts_msg.contacts[3].state = foot_contacts[3];\n\t\t\tcontacts_msg.contacts[0].phase = current_gait_phase_[0];\n\t\t\tcontacts_msg.contacts[1].phase = current_gait_phase_[1];\n\t\t\tcontacts_msg.contacts[2].phase = current_gait_phase_[2];\n\t\t\tcontacts_msg.contacts[3].phase = current_gait_phase_[3];\n\t\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.237286827654096}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)\tdef joints_msg = new Joints()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_msg.position = joints.position.take(12)\n\tself.joints_pub.publish(joints_msg)\n\n\tdef joint_trajectory = new JointTrajectory()\n\tjoint_trajectory.header.stamp = rospy.Time.now()\n\tjoint_trajectory.joint_names = self.joint_names\n\tdef point = new JointTrajectoryPoint()\n\tpoint.positions = joints.position.take(12)\n\tpoint.time_from_start = rospy.Duration.from_sec(0.5)\n\tjoint_trajectory.points = [point]\n\tself.joint_trajectory_pub.publish(joint_trajectory)\n}\n", "CodeBleu_score": 54.04404135196729}, {"code": "def joints_cmd_callback(self, joints)\tdef joints_msg = new JointState()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_msg.name = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n\tjoints_msg.position = joints.position[0..11]\n\tjoints_msg.velocity = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\tjoints_msg.effort = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\tself.joints_pub.publish(joints_msg)\n\n\tdef joint_trajectory = new JointTrajectory()\n\tjoint_trajectory.header.stamp = rospy.Time.now()\n\tjoint_trajectory.joint_names = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n\tdef joint_trajectory_point = new JointTrajectoryPoint()\n\tjoint_trajectory_point.positions = joints.position[0..11]\n\tjoint_trajectory_point.velocities = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\tjoint_trajectory_point.accelerations = [0.0, 0.0, 0.0, 0.0, 0.0, 0.", "CodeBleu_score": 35.897421665476145}, {"code": "def joints_cmd_callback(self, joints)\t// ROS_INFO(\"Received joints command\")\n\t// ROS_INFO(\"Joints: %f %f %f %f %f %f %f %f %f %f %f %f\", joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11])\n\n\t// Create a minimal joints message\n\tminimal_joints = Joints()\n\tminimal_joints.header.stamp = rospy.Time.now()\n\tminimal_joints.position = joints.position[0:12]\n\tself.joints_pub.publish(minimal_joints)\n\n\t// Construct a joint trajectory message\n\tjoint_trajectory = JointTrajectory()\n\tjoint_trajectory.header.stamp = rospy.Time.now()\n\tjoint_trajectory.joint_names = self.joint_names\n\tjoint_trajectory.points = [JointTrajectoryPoint()]\n\tjoint_trajectory.points[0].positions = joints.position[0:12]\n\tjoint_trajectory.points[0].time_from_start = rospy.Duration(self.duration)\n\tself.joint_trajectory_pub.publish(joint_trajectory)\n}\n", "CodeBleu_score": 47.63403488570809}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)\t// Initialize foot contact states to false.\n\tfor (int i = 0; i < 4; i++)\n\t\tfootContactStates[i] = false;\n\n\t// For each contact in the message, split the collision string to identify the contact link.\n\t// If a contact matches one of the foot links, set the corresponding foot contact state to true.\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> split = splitString(collision, \"::\");\n\n\t\tif (split.size() > 1) {\n\t\t\tstd::string link = split[1];\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (link == footLinks[j]) {\n\t\t\t\t\tfootContactStates[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 64.8850532671154}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\t// Initialize foot contact states to false\n\tcontact_states_.left_foot = false;\n\tcontact_states_.right_foot = false;\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> link_names = splitString(_msg->contact(i).collision1(), \"::\");\n\t\tstd::string link_name = link_names.back();\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (link_name == \"left_foot_link\") {\n\t\t\tcontact_states_.left_foot = true;\n\t\t} else if (link_name == \"right_foot_link\") {\n\t\t\tcontact_states_.right_foot = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.64923542762492}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\t// Initialize foot contact states to false\n\tfor (int i = 0; i < 4; i++) {\n\t\tfootContact[i] = false;\n\t}\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::string collision = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (collision.find(\"foot_contact_link\")!= std::string::npos) {\n\t\t\tif (collision.find(\"left_front_foot_contact_link\")!= std::string::npos) {\n\t\t\t\tfootContact[0] = true;\n\t\t\t} else if (collision.find(\"right_front_foot_contact_link\")!= std::string::npos) {\n\t\t\t\tfootContact[1] = true;\n\t\t\t} else if (collision.find(\"left_rear_foot_contact_link\")!= std::string::npos) {\n\t\t\t\tfootContact[2] = true;\n\t\t\t} else if (collision.find(\"right_rear_foot_contact_link\")!= std::string::npos) {\n\t\t\t\tfootContact[3] = true;\n\t\t\t}\n\t\t} else if (collision2.find(\"foot_contact_link\")!= std::string::npos) {\n\t\t\tif (collision2.find(\"left_front_foot_contact_link\")!= std::string::npos) {\n\t\t\t\tfootContact[0] = true;\n\t\t\t} else if (collision2.find(\"right_front_foot_contact_link\")!= std::string::npos) {\n\t\t\t\tfootContact[1] = true;\n\t\t\t} else if (collision2.find(\"left_rear_foot_contact_link\")!= std::string::npos) {\n\t\t\t\tfootContact[2] = true;\n\t\t\t} else if (collision2.find(\"right_rear_foot_contact_link\")!= std::string::npos) {\n\t\t\t\tfootContact[3] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 48.8825262945004}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\tassert(rotor_velocities!= nullptr);\n\tassert(rotor_velocities->size() == kRotorCount);\n\tassert(rotor_velocities_matrix_.size() == kRotorCount);\n\n\tif (!is_active_) {\n\t\t*rotor_velocities = Eigen::VectorXd::Zero(kRotorCount);\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration = Eigen::Vector3d::Zero();\n\tEigen::Vector3d angular_acceleration = Eigen::Vector3d::Zero();\n\n\tCalculateDesiredAcceleration(&acceleration);\n\tCalculateDesiredAngularAcceleration(&angular_acceleration);\n\n\tEigen::Vector3d thrust = mass_ * acceleration;\n\tthrust.z() += mass_ * gravity_acceleration_;\n\n\tEigen::Vector3d moments = inertia_ * angular_acceleration;\n\n\tEigen::Vector3d desired_accelerations = Eigen::Vector3d::Zero();\n\tdesired_accelerations.x() = thrust.x() + moments.x();\n\tdesired_accelerations.y() = thrust.y() + moments.y();\n\tdesired_accelerations.z() = thrust.z() + moments.z();\n\n\tEigen::VectorXd rotor_velocities_squared = rotor_velocities_matrix_ * desired_accelerations;\n\n\tfor (int i = 0; i < kRotorCount; ++i) {\n\t\trotor_velocities_squared(i) = std::max(rotor_velocities_squared(i), 0.0);\n\t}\n\n\t*rotor_velocities = rotor_velocities_squared.array().sqrt();\n}\n", "CodeBleu_score": 47.33152356451923}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\tif (!is_active_ ||!is_initialized_) {\n\t\trotor_velocities->fill(0.0);\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration = acceleration_cmd_;\n\tEigen::Vector3d angular_acceleration = angular_acceleration_cmd_;\n\n\t// Project acceleration onto body z-axis.\n\tacceleration.z() -= constants::GRAVITY;\n\n\t// Combine acceleration and angular acceleration.\n\tEigen::Vector3d combined_acceleration = acceleration + angular_acceleration.cross(k_p_ * (position_ - position_cmd_) + k_d_ * (velocity_ - velocity_cmd_));\n\n\t// Calculate the total thrust from the combined acceleration.\n\tdouble total_thrust = combined_acceleration.dot(Eigen::Vector3d::UnitZ());\n\n\t// Calculate the desired angular acceleration about the body z-axis.\n\tdouble desired_angular_acceleration = total_thrust / k_p_.z() / k_d_.z() / rotor_velocity_cmd_;\n\n\t// Calculate the desired rotor velocities.\n\tEigen::Vector4d desired_rotor_velocities;\n\tdesired_rotor_velocities << rotor_velocity_cmd_, rotor_velocity_cmd_, rotor_velocity_cmd_, rotor_velocity_cmd_;\n\tdesired_rotor_velocities += rotor_velocity_cmd_ * desired_angular_acceleration * rotor_velocity_matrix_.inverse() * Eigen::Vector4d::UnitZ();\n\tdesired_rotor_velocities = desired_rotor_velocities.cwiseMax(Eigen::Vector4d::Zero());\n\tdesired_rotor_velocities = desired_rotor_velocities.cwiseSqrt();\n\n\t// Return the desired rotor velocities.\n\t*rotor_velocities = desired_rotor_velocities;\n}\n", "CodeBleu_score": 40.278995639096024}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == kRotorCount);\n\tassert(is_active_);\n\tassert(is_initialized_);\n\n\tEigen::Vector3d acceleration = CalculateDesiredAcceleration();\n\tEigen::Vector3d angular_acceleration = CalculateDesiredAngularAcceleration();\n\tEigen::Vector3d thrust = mass_ * acceleration + mass_ * kGravityVector + moments_of_inertia_ * angular_acceleration;\n\tEigen::Vector3d thrust_body = rotation_matrix_ * thrust;\n\n\tEigen::Vector4d desired_rotor_velocities;\n\tdesired_rotor_velocities << thrust_body(2), thrust_body(2), thrust_body(2), thrust_body(2);\n\n\t*rotor_velocities = rotor_velocity_matrix_ * desired_rotor_velocities;\n\tfor (int i = 0; i < rotor_velocities->size(); ++i) {\n\t\t(*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 0.0);\n\t\t(*rotor_velocities)(i) = std::sqrt((*rotor_velocities)(i));\n\t}\n}\n", "CodeBleu_score": 46.5449960924705}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// Compute the position and velocity errors.\n\tEigen::Vector3d position_error = position_command_ - state_.position;\n\tEigen::Vector3d velocity_error = velocity_command_ - state_.velocity;\n\n\t// Transform the velocity error to the world frame.\n\tEigen::Vector3d velocity_error_world = state_.orientation * velocity_error;\n\n\t// Compute the desired acceleration.\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error_world;\n\n\t// Adjust for vehicle mass, gravity, and commanded acceleration.\n\t*acceleration += state_.orientation * Eigen::Vector3d(0.0, 0.0, -gravity_) + acceleration_command_;\n}\n", "CodeBleu_score": 34.82850755984865}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// Compute the position and velocity errors.\n\tEigen::Vector3d position_error = position_command_ - state_.position;\n\tEigen::Vector3d velocity_error = velocity_command_ - state_.velocity;\n\n\t// Compute the desired acceleration.\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error;\n\n\t// Adjust for vehicle mass and gravity.\n\t*acceleration = *acceleration - Eigen::Vector3d(0, 0, mass_ * kGravity);\n\n\t// Adjust for commanded acceleration.\n\t*acceleration = *acceleration + acceleration_command_;\n}\n", "CodeBleu_score": 29.42170791376246}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// Get the current position and velocity from the odometry data\n\tconst Eigen::Vector3d position = odometry_data_.pose.position;\n\tconst Eigen::Vector3d velocity = odometry_data_.twist.linear;\n\n\t// Transform the velocity to the world frame\n\tconst Eigen::Vector3d velocity_world =\n\t\t\todometry_data_.pose.orientation * velocity;\n\n\t// Compute the position and velocity errors\n\tconst Eigen::Vector3d position_error =\n\t\t\tcommand_trajectory_.position - position;\n\tconst Eigen::Vector3d velocity_error =\n\t\t\tcommand_trajectory_.velocity - velocity_world;\n\n\t// Compute the desired acceleration\n\t*acceleration = position_gain_ * position_error + velocity_gain_\n\t\t\t* velocity_error;\n\tacceleration->z() -= mass_ * gravity_;\n\t*acceleration += command_trajectory_.acceleration;\n\t*acceleration /= mass_;\n}\n", "CodeBleu_score": 49.44403001864065}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\tassert(rotor_velocities!= nullptr);\n\tassert(rotor_velocities->size() == kRotorCount);\n\n\t// TODO: Calculate the desired rotor velocities here\n\tEigen::VectorXd desired_accelerations(kRotorCount);\n\tdesired_accelerations = rotor_velocities_cmd_ + rotor_accelerations_cmd_;\n\n\t// TODO: Calculate the rotor velocities here\n\tEigen::MatrixXd rotor_velocities_matrix(kRotorCount, kRotorCount);\n\trotor_velocities_matrix << 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1;\n\t*rotor_velocities = rotor_velocities_matrix * desired_accelerations;\n\n\t// TODO: Ensure that the rotor velocities are nonnegative\n\tfor (int i = 0; i < kRotorCount; i++) {\n\t\tif ((*rotor_velocities)(i) < 0) {\n\t\t\t(*rotor_velocities)(i) = 0;\n\t\t}\n\t}\n\n\t// TODO: Ensure that the rotor velocities are at least one\n\tfor (int i = 0; i < kRotorCount; i++) {\n\t\tif ((*rotor_velocities)(i) < 1) {\n\t\t\t(*rotor_velocities)(i) = 1;\n\t\t}\n\t}\n\n\t// TODO: Take the square root of the rotor velocities\n\tfor (int i = 0; i < kRotorCount; i++) {\n\t\t(*rotor_velocities)(i) = sqrt((*rotor_velocities)(i));\n\t}\n}\n", "CodeBleu_score": 44.92875880656783}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\tif (rotor_velocities == nullptr) {\n\t\tstd::cerr << \"Invalid pointer for rotor velocities\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (rotor_velocities->size()!= kRotorVelocityCount) {\n\t\tstd::cerr << \"Invalid size for rotor velocities\" << std::endl;\n\t\treturn;\n\t}\n\n\tEigen::VectorXd angular_accelerations(kRotorVelocityCount);\n\tangular_accelerations = kAngularAccelerationGain * (kThrustGain * kThrustRef + kMomentGain * kMomentRef);\n\n\tEigen::MatrixXd rotor_velocity_matrix(kRotorVelocityCount, kRotorVelocityCount);\n\trotor_velocity_matrix << 0.5, 0.5, 0.5, 0.5,\n\t\t\t\t\t\t\t0.5, -0.5, -0.5, 0.5,\n\t\t\t\t\t\t\t0.5, -0.5, 0.5, -0.5,\n\t\t\t\t\t\t\t0.5, 0.5, -0.5, -0.5;\n\n\t*rotor_velocities = rotor_velocity_matrix * angular_accelerations;\n\n\tfor (int i = 0; i < kRotorVelocityCount; i++) {\n\t\tif ((*rotor_velocities)(i) < 1.0) {\n\t\t\t(*rotor_velocities)(i) = 1.0;\n\t\t}\n\n\t\t(*rotor_velocities)(i) = sqrt((*rotor_velocities)(i));\n\t}\n}", "CodeBleu_score": 40.49031076680907}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Check if the input is valid\n\tif (!rotor_velocities) {\n\t\treturn;\n\t}\n\n\t// Check if the parameters are valid\n\tif (rotor_velocities->size()!= kRotorCount) {\n\t\treturn;\n\t}\n\n\t// Calculate the desired angular acceleration\n\tEigen::VectorXd angular_acceleration = attitude_thrust_to_angular_acceleration_.inverse() * thrust_reference_;\n\n\t// Combine the desired angular acceleration and thrust reference\n\tEigen::VectorXd desired_acceleration = Eigen::VectorXd::Zero(kRotorCount);\n\tdesired_acceleration.head(kRotorCount - 1) = angular_acceleration;\n\tdesired_acceleration.tail(1) = thrust_reference_;\n\n\t// Calculate the rotor velocities\n\t*rotor_velocities = rotor_velocity_gains_ * desired_acceleration;\n\n\t// Ensure the rotor velocities are at least one\n\t*rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(kRotorCount));\n\n\t// Take the square root of each component\n\t*rotor_velocities = rotor_velocities->array().sqrt();\n}\n", "CodeBleu_score": 48.32559002347402}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    # Find the corresponding indices for the start and end times\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    sliced_object.time = self.time[start_index:end_index]\n    sliced_object.data = self.data[start_index:end_index]\n\n    # Return the copied and sliced object\n    return sliced_object\n\n", "CodeBleu_score": 25.520545490239716}, {"code": "def slice(self, start_time, end_time)\n    # Find the corresponding indices for the start and end times\n    start_index = self.time.searchsorted(start_time)\n    end_index = self.time.searchsorted(end_time)\n    # Make a deep copy of the object\n    sliced_obj = copy.deepcopy(self)\n    # Update each attribute of the copied object to contain only the sliced data\n    sliced_obj.time = self.time[start_index:end_index]\n    sliced_obj.data = self.data[start_index:end_index]\n    sliced_obj.label = self.label\n    sliced_obj.unit = self.unit\n    sliced_obj.metadata = self.metadata\n    # Return the copied and sliced object\n    return sliced_obj", "CodeBleu_score": 24.166930251200945}, {"code": "def slice(self, start_time, end_time)\n    start_index = self.time.searchsorted(start_time)\n    end_index = self.time.searchsorted(end_time)\n    new_obj = copy.deepcopy(self)\n    new_obj.time = self.time[start_index:end_index]\n    new_obj.data = self.data[start_index:end_index]\n    return new_obj\n\n", "CodeBleu_score": 24.812672730450537}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    yaw = euler[2]\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is None or self.last_waypoint!= point or self.last_yaw!= yaw:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaws.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n        # Update the last waypoint and yaw\n        self.last_waypoint = point\n        self.last_yaw = yaw\n", "CodeBleu_score": 27.22483306202934}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation from the message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    euler_angles = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object with the position and yaw\n    point = Point(position.x, position.y, position.z, euler_angles[2])\n    # Check if the current waypoint is different from the last one\n    if len(self.waypoints) > 0 and point.equals(self.waypoints[-1]):\n        return\n    # Append the new point, yaw, and corresponding times to their respective arrays\n    self.waypoints.append(point)\n    self.waypoints_time.append(msg_time)\n    self.bag_time.append(bag_time)\n    # Update the waypoint count\n    self.waypoint_count += 1\n", "CodeBleu_score": 22.634325227125704}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion(\n        [rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if len(self.waypoints) > 0:\n        last_point = self.waypoints[-1]\n        last_yaw = self.waypoints_yaw[-1]\n        if point.x!= last_point.x or point.y!= last_point.y or point.z!= last_point.z or euler[2]!= last_yaw:\n            # Append the new point, yaw, and corresponding times to their respective arrays\n            self.waypoints.append(point)\n            self.waypoints_yaw.append(euler[2])\n            self.waypoints_time.append(msg_time)\n            self.waypoints_bag_time.append(bag_time)\n\n", "CodeBleu_score": 31.939865280230904}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == '/imu/data':\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_linear_acceleration_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_linear_acceleration_bag_time.append(bag_time)\n", "CodeBleu_score": 31.169397984673974}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu/data\":\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_linear_acceleration_time.append(msg.header.stamp.to_sec())\n        self.imu_linear_acceleration_bag_time.append(bag_time)\n", "CodeBleu_score": 32.43881892961153}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == '/imu/data':\n      self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n      self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n      self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n      self.imu_time.append(msg.header.stamp.secs)\n      self.imu_bag_time.append(bag_time)\n\n  def extract_gps_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract_gps_topics, appends GPS topic message content to latitude, longitude, and altitude attributes.\\nIt converts the message timestamp to seconds.\\nFor each GPS topic, if the topic matches, it appends the latitude, longitude, and altitude data to the corresponding attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n    if topic == '/fix':\n      self.gps_latitude.append(msg.latitude)\n      self.gps_longitude.append(msg.longitude)\n      self.gps_altitude.append(msg.altitude)\n      self.gps_time.append(msg.header.stamp.secs)\n      self.gps_bag_time.append(bag_time)\n\n  def extract_gps_velocity_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract_gps_velocity_topics, appends GPS velocity topic message content to velocity attributes.\\nIt converts the message timestamp to seconds.\\nFor each GPS velocity topic, if the topic matches, it appends the velocity data to the corresponding attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n    if topic == '/gps_velocity':\n      self.gps_velocity_x.append(msg.twist.twist.linear.x)\n      self.gps_velocity_y.append(msg.twist.twist.linear.y)\n      self.gps_velocity_z.append(msg.twist.twist.linear.z)\n      self.gps_velocity_time.append(msg.header.stamp.secs)\n      self.gps_velocity_bag_time.append(bag_time)\n\n  def extract_gps_heading_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract", "CodeBleu_score": 26.545002830777985}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n    if self.save_plots:\n        filename = self.plot_prefix + \"_accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n    fig = plt.figure(figsize=(10, 6))\n    fig.suptitle(\"Accelerations\")\n    for i, acc in enumerate(self.accelerations):\n        ax = fig.add_subplot(1, 1, 1)\n        ax.plot(self.times, acc[:, 0], label=\"x\")\n        ax.plot(self.times, acc[:, 1], label=\"y\")\n        ax.plot(self.times, acc[:, 2], label=\"z\")\n        ax.set_xlabel(\"Time (s)\")\n        ax.set_ylabel(\"Acceleration (m/s^2)\")\n        ax.legend()\n    if self.save_plots:\n        plt.savefig(filename)\n    plt.show()\n", "CodeBleu_score": 40.928277419625836}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    if self.save_plots:\n        # Construct a filename based on a prefix and optional suffix\n        filename = f\"accelerations_{plot_suffix}.png\" if plot_suffix else \"accelerations.png\"\n        # Save the plot as a PNG file\n        self.fig.savefig(filename, dpi=300)\n", "CodeBleu_score": 12.336017241660539}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    if self.save_plots:\n        # Create a figure and set its title\n        fig = plt.figure()\n        fig.suptitle(\"Acceleration Data\")\n        # Create a subplot for accelerations\n        ax = fig.add_subplot(111)\n        # Plot x, y, and z components of accelerations over time\n        ax.plot(self.time, self.accel_x, label=\"X Acceleration\")\n        ax.plot(self.time, self.accel_y, label=\"Y Acceleration\")\n        ax.plot(self.time, self.accel_z, label=\"Z Acceleration\")\n        # Add labels for the x and y axes\n        ax.set_xlabel(\"Time (s)\")\n        ax.set_ylabel(\"Acceleration (m/s^2)\")\n        # Add a legend\n        ax.legend()\n        # Save the plot as a PNG file\n        if plot_suffix is None:\n            filename = f\"{self.plot_prefix}_accelerations.png\"\n        else:\n            filename = f\"{self.plot_prefix}_accelerations_{plot_suffix}.png\"\n        plt.savefig(filename)\n        plt.close()\n", "CodeBleu_score": 37.68411879396657}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        raise ValueError(\"Please provide at least two pose indices to compare.\")\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 40.87724712814992}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"At least two pose indices are required to compare the positions of multiple poses.\")\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 45.76413815169379}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n      print('Error: compare_positions requires at least two pose indices to perform comparisons.')\n      return None\n    for i in range(len(pose_indeces)):\n      for j in range(i + 1, len(pose_indeces)):\n        self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n  def compare_two_xyz(self, pose_index1, pose_index2):\n    \"\"\"This function, compare_two_xyz, compares the positions of two poses based on their indices.\\nIt requires two pose indices to perform comparisons.\\nIt compares the position of the first pose with the position of the second pose using the compare_xyz function.\"\"\"\n    if pose_index1 >= len(self.pose_list):\n      print('Error: compare_two_xyz requires a valid pose index for the first pose.')\n      return None\n    if pose_index2 >= len(self.pose_list):\n      print('Error: compare_two_xyz requires a valid pose index for the second pose.')\n      return None\n    self.compare_xyz(self.pose_list[pose_index1], self.pose_list[pose_index2])\n\n  def compare_xyz(self, pose1, pose2):\n    \"\"\"This function, compare_xyz, compares the positions of two poses.\\nIt requires two poses to perform comparisons.\\nIt compares the positions of the first pose with the positions of the second pose using the compare_two_xyz_values function.\"\"\"\n    if pose1 == None:\n      print('Error: compare_xyz requires a valid pose for the first pose.')\n      return None\n    if pose2 == None:\n      print('Error: compare_xyz requires a valid pose for the second pose.')\n      return None\n    self.compare_two_xyz_values(pose1.x, pose1.y, pose1.z, pose2.x, pose2.y, pose2.z)\n\n  def compare_two_xyz_values(self, x1, y1, z1, x2, y2, z2):\n    \"\"\"This function, compare_two_xyz_values, compares the positions of two poses based on their x, y, and z values.\\nIt requires six values to perform comparisons.\\nIt compares the", "CodeBleu_score": 32.22541319208856}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 31.42459542711393}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n      if time >= start_time and time <= end_time:\n        collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.50957194743766}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    end_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n", "CodeBleu_score": 30.97332787703203}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    # Calculate absolute settling time\n    abs_settling_time = start_time + settling_time\n    # Call analyze_bag.plot_angular_velocities\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix,\n                                        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 34.86608921122654}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    # Calculate the absolute settling time\n    absolute_settling_time = start_time + settling_time\n    # Call analyze_bag.plot_angular_velocities with the specified start time, end time, settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5]\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, y_range=(-1.5, 1.5))\n", "CodeBleu_score": 29.673207576430862}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (data == nullptr) {\n\t\treturn;\n\t}\n\n\tconst float multiplier = 1.0f / (1 << 16);\n\tconst uint32_t size = width * height;\n\tEigen::Map<Eigen::VectorXf> depth(data, size);\n\tdepth *= multiplier;\n\n\tconst float rms = ComputeRms(depth);\n\tconst float noise = rms * ComputeNoise(size);\n\n\tfor (uint32_t i = 0; i < size; i++) {\n\t\tif (depth(i) > 0.0f && depth(i) < 10.0f) {\n\t\t\tdepth(i) += noise;\n\t\t} else {\n\t\t\tdepth(i) = 0.0f;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.879783227299676}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (data == nullptr) {\n\t\treturn;\n\t}\n\tconst float multiplier = 1.0f / (1 << 16);\n\tEigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\tconst float rms_noise = ComputeRmsNoise(width, height);\n\tconst float noise_multiplier = sqrt(2.0f) * rms_noise;\n\tconst float noise_offset = rms_noise * rms_noise;\n\tfor (uint32_t i = 0; i < width * height; ++i) {\n\t\tif (data[i] > 0) {\n\t\t\tdata[i] += noise_multiplier * Randn(noise_offset) * multiplier;\n\t\t} else {\n\t\t\tdata[i] = bad_point_value_;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.22271397080821}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (!data) {\n\t\treturn;\n\t}\n\n\tfloat multiplier = 1.0f / 1000.0f;\n\tEigen::VectorXf data_vec(width * height);\n\tdata_vec.setZero();\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tdata_vec(i) = data[i] * multiplier;\n\t}\n\n\tfloat rms_noise = ComputeRMSNoise(width, height, data_vec);\n\tfloat *noise_values = new float[width * height];\n\tComputeNoiseValues(width, height, rms_noise, noise_values);\n\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tif (data_vec(i) >= min_range_ && data_vec(i) <= max_range_) {\n\t\t\tdata[i] = data_vec(i) + noise_values[i];\n\t\t} else {\n\t\t\tdata[i] = bad_point_;\n\t\t}\n\t}\n\n\tdelete[] noise_values;\n}\n", "CodeBleu_score": 44.938301406949286}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\t// Get current simulation time\n\tros::Time current_time = ros::Time::now();\n\n\t// Write trajectory message to bag file\n\tbag_writer_.write(trajectory_msg_topic_, current_time, *trajectory_msg);\n}\n", "CodeBleu_score": 35.953701731702424}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\t// Get the current simulation time and convert it to ROS time\n\tcommon::Time sim_time = this->world->GetSimTime();\n\tros::Time ros_time(sim_time.sec, sim_time.nsec);\n\n\t// Write the trajectory message to a bag file using the specified namespace and waypoint topic\n\tthis->waypoint_bag.write(this->waypoint_topic_ns, ros_time, *trajectory_msg);\n}\n", "CodeBleu_score": 47.886939884831456}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\t// Retrieve the current simulation time and convert it to ROS time\n\tros::Time current_time = ros::Time::now();\n\n\t// Write the trajectory message to a bag file using the specified namespace and waypoint topic\n\twaypoint_bag_.write(waypoint_topic_ns_, current_time, *trajectory_msg);\n}\n", "CodeBleu_score": 35.89658589642899}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\tros::Time time(now.sec, now.nsec);\n\tmav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n\tactuator_msg->angular_velocities.resize(num_motors_);\n\n\tfor (int i = 0; i < num_motors_; i++) {\n\t\tdouble rot_vel = motor_joints_[i]->GetVelocity(0);\n\t\tactuator_msg->angular_velocities[i] = rot_vel / motor_rotor_velocity_slowdown_factors_[i];\n\t}\n\n\tactuator_msg->header.stamp = time;\n\n\tactuator_msg->header.frame_id = \"base_link\";\n\tactuator_msg->header.seq = motor_vel_seq_;\n\tmotor_vel_seq_++;\n\n\tmotor_vel_pub_.publish(actuator_msg);\n\tmotor_vel_bag_.Write(motor_vel_topic_ns_, actuator_msg);\n}\n", "CodeBleu_score": 45.85537763615781}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\t// Get the simulation time\n\tdouble sim_time = now.Double();\n\n\t// Convert the simulation time to ROS time\n\tros::Time ros_time(sim_time);\n\n\t// Prepare a message for actuator velocities\n\tmav_msgs::Actuators actuator_msg;\n\tactuator_msg.angular_velocities.resize(motor_joint_names_.size());\n\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < motor_joint_names_.size(); i++) {\n\t\t// Get the joint pointer\n\t\tphysics::JointPtr motor_joint = model_->GetJoint(motor_joint_names_[i]);\n\n\t\t// Calculate the slowed-down rotational velocities\n\t\tdouble motor_velocity = motor_joint->GetVelocity(0) * motor_speed_ratio_;\n\n\t\t// Assign the motor velocity to the message\n\t\tactuator_msg.angular_velocities[i] = motor_velocity;\n\t}\n\n\t// Set the message timestamp\n\tactuator_msg.header.stamp = ros_time;\n\n\t// Write the data to a bag file using the specified namespace and motor topic\n\tmotor_bag_.write(motor_topic_, actuator_msg);\n}\n", "CodeBleu_score": 47.540145369050926}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\t// Convert the simulation time to ROS time\n\tros::Time ros_time(now.sec, now.nsec);\n\n\t// Prepare a message for actuator velocities\n\tmav_msgs::ActuatorsPtr actuator_velocities(new mav_msgs::Actuators);\n\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < motor_joints_.size(); i++) {\n\t\t// Calculate the slowed-down rotational velocities\n\t\tdouble rotational_velocity = motor_joints_[i]->GetVelocity(0);\n\t\tdouble slowed_down_rotational_velocity = rotational_velocity * motor_velocity_slowdown_factor_;\n\n\t\t// Assign the slowed-down rotational velocities to the message\n\t\tactuator_velocities->angular_velocities[i] = slowed_down_rotational_velocity;\n\t}\n\n\t// Set the message timestamp\n\tactuator_velocities->header.stamp = ros_time;\n\n\t// Write the data to a bag file using the specified namespace and motor topic\n\tmotor_bag_.write(motor_topic_, actuator_velocities);\n}\n", "CodeBleu_score": 43.563064285434635}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)\tif (debug_printing_) {\n\t\tprintf(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\\n\");\n\t}\n\t// Convert normalized input values to control surface angles.\n\tdouble roll_angle = roll_pitch_yawrate_thrust_msg->roll * max_aileron_angle_;\n\tdouble pitch_angle = roll_pitch_yawrate_thrust_msg->pitch * max_elevator_angle_;\n\tdouble rudder_angle = roll_pitch_yawrate_thrust_msg->yaw_rate * max_rudder_angle_;\n\t// Set the throttle value.\n\tdouble throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\t// Set the control surface angles and throttle.\n\tSetControlSurfaceAngles(roll_angle, pitch_angle, rudder_angle);\n\tSetThrottle(throttle);\n}\n", "CodeBleu_score": 33.28031686737851}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)\tif (debug_printing) {\n\t\tstd::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called.\" << std::endl;\n\t}\n\t// Convert normalized roll, pitch, and yaw rate to control surface angles.\n\tdouble aileron_angle = roll_pitch_yawrate_thrust_msg->roll * (max_aileron_angle - min_aileron_angle) + min_aileron_angle;\n\tdouble elevator_angle = roll_pitch_yawrate_thrust_msg->pitch * (max_elevator_angle - min_elevator_angle) + min_elevator_angle;\n\tdouble rudder_angle = roll_pitch_yawrate_thrust_msg->yaw_rate * (max_rudder_angle - min_rudder_angle) + min_rudder_angle;\n\t// Set the throttle value.\n\tdouble throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\t// Send the control surface angles and throttle to the dynamics model.\n\tdynamics_model_ptr->SetControlSurfaces(aileron_angle, elevator_angle, rudder_angle, throttle);\n}\n", "CodeBleu_score": 38.37126932933106}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)\tif (debug_print_) {\n\t\tstd::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\" << std::endl;\n\t}\n\n\t// Convert normalized roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively\n\tdouble roll_rad = roll_pitch_yawrate_thrust_msg->roll * max_aileron_rad_;\n\tdouble pitch_rad = roll_pitch_yawrate_thrust_msg->pitch * max_elevator_rad_;\n\tdouble yaw_rate_rad = roll_pitch_yawrate_thrust_msg->yaw_rate * max_rudder_rad_;\n\n\t// Set the throttle value from the thrust message\n\tdouble thrust = roll_pitch_yawrate_thrust_msg->thrust;\n\n\t// Set the control surface angles and throttle\n\tSetControlSurfaces(roll_rad, pitch_rad, yaw_rate_rad, thrust);\n}\n", "CodeBleu_score": 34.05270319498679}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#if (defined(ENABLE_MAVLINK_INTERFACE_LOGGING) && ENABLE_MAVLINK_INTERFACE_LOGGING)\n  gzdbg << \"pollForMAVLinkMessages: \" << _dt << \" \" << _timeoutMs << \"\\n\";", "CodeBleu_score": 7.535495515876874}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#if GAZEBO_MAJOR_VERSION >= 9\n  // Poll for MAVLink messages.\n  gazebo::common::Time timeout(_timeoutMs / 1000.0);\n  gazebo::common::Time start = gazebo::common::Time::GetWallTime();\n  while (gazebo::common::Time::GetWallTime() - start < timeout) {\n    if (this->poll()) {\n      break;\n    }\n  }", "CodeBleu_score": 12.399932683840253}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#if GAZEBO_MAJOR_VERSION >= 7\n  common::Time timeout = common::Time(_timeoutMs / 1000.0);", "CodeBleu_score": 4.260331917794153}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() \tboost::mutex::scoped_lock lock(this->io_mutex);\n\tif (this->io_service_thread.joinable())  {\n\t\tthis->io_service_thread.join();\n\t}\n\tif (this->serial_port->is_open())  {\n\t\tthis->serial_port->cancel();\n\t\tthis->serial_port->close();\n\t}\n}\n", "CodeBleu_score": 27.076841510793937}, {"code": "void GazeboMavlinkInterface::close() \t// Lock the mutex to ensure thread safety\n\tboost::mutex::scoped_lock lock(this->interface_mutex);\n\n\t// Check if the interface is open\n\tif (this->interface_open)  {\n\t\t// Stop the I/O service\n\t\tthis->io_service->stop();\n\n\t\t// Close the serial device\n\t\tthis->serial_device->close();\n\n\t\t// If the I/O thread is joinable, join the thread to clean up resources\n\t\tif (this->io_thread.joinable())  {\n\t\t\tthis->io_thread.join();\n\t\t}\n\n\t\t// Set the interface open flag to false\n\t\tthis->interface_open = false;\n\t}\n}\n", "CodeBleu_score": 26.071110491655467}, {"code": "void GazeboMavlinkInterface::close() \tif (this->isOpen())  {\n\t\tthis->io_service.stop();\n\t\tthis->serial_port.close();\n\t\tif (this->io_thread.joinable())  {\n\t\t\tthis->io_thread.join();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 29.73930341475304}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\tdouble x, y, z, x1, y1, z1, x2, y2, z2, value1, value2;\n\tignition::math::Vector3d result;\n\tx = _position.X();\n\ty = _position.Y();\n\tz = _position.Z();\n\tx1 = _lower_bound.X();\n\ty1 = _lower_bound.Y();\n\tz1 = _lower_bound.Z();\n\tx2 = _upper_bound.X();\n\ty2 = _upper_bound.Y();\n\tz2 = _upper_bound.Z();\n\tvalue1 = _lower_value;\n\tvalue2 = _upper_value;\n\tresult.X() = value1 + (value2 - value1) * ((x - x1) / (x2 - x1));\n\tresult.Y() = value1 + (value2 - value1) * ((y - y1) / (y2 - y1));\n\tresult.Z() = value1 + (value2 - value1) * ((z - z1) / (z2 - z1));\n\treturn result;\n}\n", "CodeBleu_score": 30.932189443291502}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\t(const ignition::math::Vector3d& p1, const ignition::math::Vector3d& p2, const ignition::math::Vector3d& p3, const ignition::math::Vector3d& p4, const ignition::math::Vector3d& pos) {\n\t\tignition::math::Vector3d result;\n\t\tignition::math::Vector3d p1p2 = p2 - p1;\n\t\tignition::math::Vector3d p3p4 = p4 - p3;\n\t\tignition::math::Vector3d p1p3 = p3 - p1;\n\t\tignition::math::Vector3d p2p4 = p4 - p2;\n\t\tignition::math::Vector3d p1p = pos - p1;\n\t\tignition::math::Vector3d p3p = pos - p3;\n\t\tdouble a = p1p.Dot(p1p2) / p1p2.Dot(p1p2);\n\t\tdouble b = p1p.Dot(p3p4) / p3p4.Dot(p3p4);\n\t\tdouble c = p1p3.Dot(p1p2) / p1p2.Dot(p1p2);\n\t\tdouble d = p2p4.Dot(p1p2) / p1p2.Dot(p1p2);\n\t\tresult = (1 - a - b) * p1 + a * p2 + (1 - c - d) * p3 + c * p4;\n\t\treturn result;\n\t}\n};\n", "CodeBleu_score": 34.88387592597307}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\tconst ignition::math::Vector3d& pos_1,\n\tconst ignition::math::Vector3d& pos_2,\n\tconst ignition::math::Vector3d& val_1,\n\tconst ignition::math::Vector3d& val_2,\n\tconst ignition::math::Vector3d& pos\n} {\n\tdouble t = (pos - pos_1).Length() / (pos_2 - pos_1).Length();\n\treturn val_1 + t * (val_2 - val_1);\n}\n", "CodeBleu_score": 39.21046944459115}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)\tif (m_loop) {\n\t\tm_time = fmod(_time, m_length);\n\t} else {\n\t\tm_time = std::clamp(_time, 0.0, m_length);\n\t}\n\n\tif (m_time!= _time) {\n\t\tm_dirty = true;\n\t}\n}\n", "CodeBleu_score": 30.13666645493629}, {"code": "void Animation::SetTime(double _time)\tif (m_time!= _time) {\n\t\tm_time = _time;\n\t\tm_dirty = true;\n\t}\n\tif (m_looping) {\n\t\tm_time = fmod(m_time, m_length);\n\t} else {\n\t\tm_time = std::max(0.0, std::min(m_time, m_length));\n\t}\n}\n", "CodeBleu_score": 31.20639298137106}, {"code": "void Animation::SetTime(double _time)\tif (_time!= time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\twhile (time > length) {\n\t\t\t\ttime -= length;\n\t\t\t}\n\t\t} else {\n\t\t\ttime = Math::Clamp(time, 0.0, length);\n\t\t}\n\t\tUpdate();\n\t}\n}\n", "CodeBleu_score": 31.550990987243928}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n    self.set_frame(1)\n    self.set_type(0)\n    self.target_motion = Motion.Motion(self.current_position, self.current_yaw)\n    self.print_flight_mode()\n\n  def loiter(self):\n    \"\"\"This function, loiter, sets the vehicle's coordinate frame to 1 and motion type to 1.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame(1)\n    self.set_type(1)\n    self.target_motion = Motion.Motion(self.current_position, self.current_yaw)\n    self.print_flight_mode()\n\n  def return_to_launch(self):\n    \"\"\"This function, return_to_launch, sets the vehicle's coordinate frame to 1 and motion type to 2.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame(1)\n    self.set_type(2)\n    self.target_motion = Motion.Motion(self.current_position, self.current_yaw)\n    self.print_flight_mode()\n\n  def land(self):\n    \"\"\"This function, land, sets the vehicle's coordinate frame to 1 and motion type to 3.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame(1)\n    self.set_type(3)\n    self.target_motion = Motion.Motion(self.current_position, self.current_yaw)\n    self.print_flight_mode()\n\n  def takeoff(self, altitude):\n    \"\"\"This function, takeoff, sets the vehicle's coordinate frame to 1 and motion type to 4.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame(1)\n    self.set_type(4)\n    self.target_motion = Motion.Motion(self.current_position, self.current_yaw)\n    self.print_flight_mode()\n\n  def set_frame(self, frame):\n    \"\"\"This function,", "CodeBleu_score": 22.6425579740578}, {"code": "def hover(self)\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.target_motion = self.get_current_motion()\n    print(\"Vehicle Type: \" + str(self.vehicle_type) + \"\\nVehicle ID: \" + str(self.vehicle_id) + \"\\nFlight Mode: Hover\")\n\n  def takeoff(self, height):\n    \"\"\"This function, takeoff, sets the vehicle's coordinate frame to 1 and motion type to 0.\\nIt constructs a target motion using the current position, yaw, and height.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.target_motion = self.get_current_motion()\n    self.target_motion.z = height\n    print(\"Vehicle Type: \" + str(self.vehicle_type) + \"\\nVehicle ID: \" + str(self.vehicle_id) + \"\\nFlight Mode: Takeoff\")\n\n  def land(self):\n    \"\"\"This function, land, sets the vehicle's coordinate frame to 1 and motion type to 0.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.target_motion = self.get_current_motion()\n    print(\"Vehicle Type: \" + str(self.vehicle_type) + \"\\nVehicle ID: \" + str(self.vehicle_id) + \"\\nFlight Mode: Land\")\n\n  def set_frame(self, frame):\n    \"\"\"This function, set_frame, sets the vehicle's coordinate frame to the specified frame.\\nIt then prints the vehicle type, vehicle ID, and the new coordinate frame.\"\"\"\n    self.coordinate_frame = frame\n    print(\"Vehicle Type: \" + str(self.vehicle_type) + \"\\nVehicle ID: \" + str(self.vehicle_id) + \"\\nCoordinate Frame: \" + str(self.coordinate_frame))\n\n  def set_motion_type(self, motion_type):\n    \"\"\"This function, set_motion_type, sets the vehicle's motion type to the specified motion type.\\nIt then prints the vehicle type, vehicle ID, and the", "CodeBleu_score": 25.55455220200575}, {"code": "def hover(self)\n    self.set_frame_type(1)\n    self.set_motion_type(0)\n    target_motion = Motion(self.get_current_position(), self.get_current_yaw())\n    self.send_target_motion(target_motion)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: Hover\")\n\n  def land(self):\n    \"\"\"This function, land, sets the vehicle's coordinate frame to 1 and motion type to 1.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame_type(1)\n    self.set_motion_type(1)\n    target_motion = Motion(self.get_current_position(), self.get_current_yaw())\n    self.send_target_motion(target_motion)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: Land\")\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, sets the vehicle's coordinate frame to 1 and motion type to 2.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame_type(1)\n    self.set_motion_type(2)\n    target_motion = Motion(self.get_current_position(), self.get_current_yaw())\n    self.send_target_motion(target_motion)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: Takeoff\")\n\n  def move_by_velocity(self, x_velocity, y_velocity, z_velocity, yaw_velocity, duration):\n    \"\"\"This function, move_by_velocity, sets the vehicle's coordinate frame to 1 and motion type to 3.\\nIt constructs a target motion using the current position and yaw.\\nIt then adds the given velocities to the target motion.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame_type", "CodeBleu_score": 27.460370204435623}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        self.hover_flag = 0\n        self.flightModeService.request.custom_mode = self.flight_mode\n        if self.flightModeService(self.flightModeService.request) == True:\n            rospy.loginfo(\"Mode switched to %s\", self.flight_mode)\n            return True\n        else:\n            rospy.loginfo(\"Failed to switch mode to %s\", self.flight_mode)\n            return False\n\n", "CodeBleu_score": 41.53363005774908}, {"code": "def flight_mode_switch(self)\n    # Check if the flight mode is 'HOVER'\n    if self.flight_mode == 'HOVER':\n        # Set the hover flag to 1\n        self.hover_flag = 1\n        # Call the hover method\n        self.hover()\n        # Return True\n        return True\n    # Attempt to switch modes using flightModeService\n    try:\n        # Set the mode to the desired mode\n        self.flightModeService(self.flight_mode)\n        # Print a success message\n        print('Mode switch successful!')\n        # Return True\n        return True\n    # Handle any exceptions that may occur\n    except rospy.ServiceException as e:\n        # Print a failure message\n        print('Mode switch failed: %s' % e)\n        # Return False\n        return False\n\n", "CodeBleu_score": 58.51422767707341}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print('Switched to'+ self.flight_mode +'mode.')\n            return True\n        except rospy.ServiceException as e:\n            print('Service call failed: %s' % e)\n            return False\n", "CodeBleu_score": 46.115700307416994}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    if self.hover_flag == True:\n        self.hover_state_transition(msg.linear.x, msg.angular.z)\n    elif self.hold_flag == True:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.angular.z, 0, 0, 0]\n    self.cmd_vel_enu_flag = True\n    self.cmd_vel_enu_time = rospy.get_time()\n", "CodeBleu_score": 50.55943047699728}, {"code": "def cmd_vel_enu_callback(self, msg)\n    if self.hover_flag == 0:\n        self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if self.hold_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = Motion(msg.linear.x, msg.angular.z, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n", "CodeBleu_score": 62.73240850896491}, {"code": "def cmd_vel_enu_callback(self, msg)\n    if self.hover_flag == 0:\n        self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if self.hold_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.angular.z]\n", "CodeBleu_score": 58.67019942952724}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n    if self.flight_mode!= \"HOVER\":\n      if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.set_flight_mode(\"OFFBOARD\")\n        print(\"OFFBOARD\")\n      else:\n        self.hover_flag = 1\n        self.set_flight_mode(\"HOVER\")\n        self.hover()\n        print(\"HOVER\")\n\n  def hover(self):\n    \"\"\"This function, hover, initiates the hover action by setting the position to 0, 0, 0 and the yaw to 0.\"\"\"\n    self.set_position(0, 0, 0)\n    self.set_yaw(0)\n\n  def set_position(self, x, y, z):\n    \"\"\"This function, set_position, sets the position of the drone in the x, y, and z axes.\\nIt sets the x, y, and z values of the position variable to the given x, y, and z values, respectively.\\nIt then sets the position variable to the new position and sends the position to the drone.\"\"\"\n    self.position[0] = x\n    self.position[1] = y\n    self.position[2] = z\n    self.set_local_position(self.position[0], self.position[1], self.position[2])\n\n  def set_yaw(self, w):\n    \"\"\"This function, set_yaw, sets the yaw of the drone.\\nIt sets the w value of the yaw variable to the given w value.\\nIt then sets the yaw variable to the new yaw and sends the yaw to the drone.\"\"\"\n    self.yaw = w\n    self.set_attitude(self.yaw, 0, 0, 0)\n\n  def set_flight_mode(self, mode):\n    \"\"\"This function, set_flight_mode, sets the flight mode of the drone.\\nIt sets the flight_mode variable to the given mode.\\nIt then sets the flight mode to the new mode and sends the flight mode to the drone.\"\"\"\n    self.flight_mode = mode\n    self.set_mode(self.flight_mode)\n\n  def set_local_position(self,", "CodeBleu_score": 52.898163670775475}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.current_flight_mode!= \"HOVER\":\n      if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_flight_mode(\"OFFBOARD\")\n      else:\n        self.hover_flag = 1\n        self.set_flight_mode(\"HOVER\")\n        self.hover()\n\n  def hover(self):\n    \"\"\"This function, hover, initiates the hover action. It sets the current_flight_mode to \"HOVER\" and initiates the hover action by sending a set_position_target_local_ned command with the current local position, yaw angle, and a body frame.\"\"\"\n    self.current_flight_mode = \"HOVER\"\n    msg = self.set_position_target_local_ned(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.connection.send_message(msg)\n\n  def set_position_target_local_ned(self, x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate, force_body, l, m, n, x_body, y_body, z_body):\n    \"\"\"This function, set_position_target_local_ned, sets the local NED position target for the drone. It takes in the x, y, z, vx, vy, vz, afx, afy, afz, yaw, yaw_rate, force_body, l, m, n, x_body, y_body, and z_body values and sets the current_flight_mode to \"POSITION_CONTROL\" and sends a mavlink message to the drone with the appropriate values.\"\"\"\n    self.current_flight_mode = \"POSITION_CONTROL\"\n    msg = self.vehicle.message_factory.set_position_target_local_ned_encode(0, 0, 0, mavutil.mavlink.MAV_FRAME_LOCAL_NED, 0b00001", "CodeBleu_score": 52.405602361541035}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode('OFFBOARD')\n    if (self.flight_mode!= 'HOVER' and self.hover_flag == 1):\n        self.hover_flag = 0\n        self.set_mode('HOVER')\n        self.hover()\n", "CodeBleu_score": 53.6328385971181}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n", "CodeBleu_score": 17.485641283375248}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    self.set_coordinate_frame(self.coordinate_frame)\n    self.set_motion_type(self.motion_type)\n    self.target_motion = self.get_target_motion(self.position, self.yaw)\n    self.print_vehicle_info()\n\n  def land(self):\n    \"\"\"This function, land, sets the vehicle to land mode.\\nIt updates the coordinate frame and motion type.\\nIt constructs a target motion using the current position and yaw values.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_coordinate_frame(self.coordinate_frame)\n    self.set_motion_type(self.motion_type)\n    self.target_motion = self.get_target_motion(self.position, self.yaw)\n    self.print_vehicle_info()\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, sets the vehicle to takeoff mode.\\nIt updates the coordinate frame and motion type.\\nIt constructs a target motion using the current position and yaw values.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_coordinate_frame(self.coordinate_frame)\n    self.set_motion_type(self.motion_type)\n    self.target_motion = self.get_target_motion(self.position, self.yaw)\n    self.print_vehicle_info()\n\n  def set_coordinate_frame(self, coordinate_frame):\n    \"\"\"This function, set_coordinate_frame, sets the vehicle's coordinate frame.\\nIt sets the coordinate frame to the given value.\\nIt also prints the coordinate frame.\"\"\"\n    self.coordinate_frame = coordinate_frame\n    print(\"Coordinate frame: \", self.coordinate_frame)\n\n  def set_motion_type(self, motion_type):\n    \"\"\"This function, set_motion_type, sets the vehicle's motion type.\\nIt sets the motion type to the given value.\\nIt also prints the motion type.\"\"\"\n    self.motion_type = motion_type\n    print(\"Motion type: \", self.motion_type)\n\n  def get_target_motion(self, position, yaw):\n    \"\"\"This function, get_target_motion, constructs a target motion using the given position and yaw.\\nIt returns the constructed target motion.\"\"\"\n    return {\"position\": position, \"yaw\": yaw", "CodeBleu_score": 28.640328613956655}, {"code": "def hover(self)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(2)\n    while True:\n      if self.vehicle.location.global_relative_frame.alt>=1.95:\n        break\n      time.sleep(1)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(2)\n    while True:\n      if self.vehicle.location.global_relative_frame.alt>=1.95:\n        break\n      time.sleep(1)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(2)\n    while True:\n      if self.vehicle.location.global_relative_frame.alt>=1.95:\n        break\n      time.sleep(1)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(2)\n    while True:\n      if self.vehicle.location.global_relative_frame.alt>=1.95:\n        break\n      time.sleep(1)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(2)\n    while True:\n      if self.vehicle.location.global_relative_frame.alt>=1.95:\n        break\n      time.sleep(1)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(2)\n    while True:\n      if self.vehicle.location.global_relative_frame.alt>=1.95:\n        break\n      time.sleep(1)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(2)\n    while True:\n      if self.vehicle.location.global_relative_frame.alt>=1.95:\n        break\n      time.sleep(1)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(2)\n    while", "CodeBleu_score": 19.125690737752507}, {"code": "def hover(self)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.altitude)\n    self.vehicle.mode = Vehicle", "CodeBleu_score": 17.71381466760687}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n      self.hover_flag = True\n      self.hover()\n    else:\n      self.hover_flag = False\n      self.flight_mode = self.flightModeService(self.flight_mode)\n      if self.flight_mode!= \"\":\n        print(\"Flight mode set to: \" + self.flight_mode)\n        return True\n      else:\n        print(\"Failed to set flight mode\")\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the vehicle's velocity to zero and hovers it in place.\"\"\"\n    self.set_velocity(0, 0, 0)\n    self.set_yaw_rate(0)\n    self.set_arm(True)\n    self.set_takeoff_alt(self.takeoff_alt)\n    self.set_flight_mode(\"HOVER\")\n    self.set_hover_flag(True)\n    self.set_takeoff_flag(False)\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, sets the vehicle's velocity to zero and takes off to a specified altitude.\"\"\"\n    self.set_velocity(0, 0, 0)\n    self.set_yaw_rate(0)\n    self.set_arm(True)\n    self.set_takeoff_alt(self.takeoff_alt)\n    self.set_flight_mode(\"TAKEOFF\")\n    self.set_takeoff_flag(True)\n    self.set_hover_flag(False)\n\n  def land(self):\n    \"\"\"This function, land, sets the vehicle's velocity to zero and lands the vehicle.\"\"\"\n    self.set_velocity(0, 0, 0)\n    self.set_yaw_rate(0)\n    self.set_arm(True)\n    self.set_takeoff_alt(self.takeoff_alt)\n    self.set_flight_mode(\"LAND\")\n    self.set_takeoff_flag(False)\n    self.set_hover_flag(False)\n\n  def set_arm(self, arm):\n    \"\"\"This function, set_arm, sets the arm state of a vehicle.\\nIf the arm state is True, it arms the vehicle.\\nOtherwise, it disarms the vehicle.\\nIf successful, it prints the new arm state and returns True.\\nIf unsuccessful", "CodeBleu_score": 25.63119484200727}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n    else:\n        try:\n            self.flightModeService.request(self.flight_mode)\n            rospy.loginfo('Flight mode set to %s', self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            rospy.logerr('Service call failed: %s', e)\n            return False\n", "CodeBleu_score": 50.118914511184784}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            rospy.loginfo('Changed flight mode to %s', self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.logerr('Failed to change flight mode to %s', self.flight_mode)\n            return False\n", "CodeBleu_score": 51.60720451289872}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward for the current assignment, algorithm, play, and rond.\"\"\"\n    self.total_reward = 0\n    for i in range(self.rond):\n      self.total_reward += self.assignment[i][self.play[i][self.algorithm[i]]]\n\n  def visualize(self):\n    \"\"\"This function, visualize, visualizes the current assignment, algorithm, play, and rond.\"\"\"\n    plt.figure(figsize=(12, 6))\n    plt.title('Assignment, Algorithm, Play, and Rond')\n    plt.xlabel('Rond')\n    plt.ylabel('Player')\n    plt.plot(self.assignment, label='Assignment')\n    plt.plot(self.algorithm, label='Algorithm')\n    plt.plot(self.play, label='Play')\n    plt.legend()\n    plt.show()\n", "CodeBleu_score": 51.23531431007223}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward for the given assignment, algorithm, play, and rond.\\nIt does this by calling the get_reward method for each of the 1000000 steps and adding the result to the total reward.\"\"\"\n    self.total_reward = 0\n    for i in range(1000000):\n      self.total_reward += self.get_reward()\n\n  def get_reward(self):\n    \"\"\"This function, get_reward, calculates the reward for a single step in the simulation.\\nIt does this by calling the get_reward_from_assignment method for the given assignment and adding the result to the total reward.\"\"\"\n    self.total_reward += self.get_reward_from_assignment(self.assignment)\n\n  def get_reward_from_assignment(self, assignment):\n    \"\"\"This function, get_reward_from_assignment, calculates the reward for a single step in the simulation for the given assignment.\\nIt does this by calling the get_reward_from_algorithm method for the given algorithm and adding the result to the total reward.\"\"\"\n    self.total_reward += self.get_reward_from_algorithm(self.algorithm)\n\n  def get_reward_from_algorithm(self, algorithm):\n    \"\"\"This function, get_reward_from_algorithm, calculates the reward for a single step in the simulation for the given algorithm.\\nIt does this by calling the get_reward_from_play method for the given play and adding the result to the total reward.\"\"\"\n    self.total_reward += self.get_reward_from_play(self.play)\n\n  def get_reward_from_play(self, play):\n    \"\"\"This function, get_reward_from_play, calculates the reward for a single step in the simulation for the given play.\\nIt does this by calling the get_reward_from_rond method for the given rond and adding the result to the total reward.\"\"\"\n    self.total_reward += self.get_reward_from_rond(self.rond)\n\n  def get", "CodeBleu_score": 50.694905546916026}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.gcs_command == \"TAKEOFF\":\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose.pose.position.z = self.takeoff_target_pose.pose.position.z + self.takeoff_bias\n        elif self.gcs_command == \"HOVER\":\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z = self.hover_target_pose.pose.position.z + self.hover_bias\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.global_bias.pose.position.x\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.global_bias.pose.position.y\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.global_bias.pose.position.z\n        self.global_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.global_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.global_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.global_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n", "CodeBleu_score": 22.02991066942814}, {"code": "def local_pose_callback(self, msg, i)\n    if msg.id == self.id:\n      self.local_pose = msg\n      self.global_pose.position.x = self.local_pose.position.x + self.x_bias\n      self.global_pose.position.y = self.local_pose.position.y + self.y_bias\n      self.global_pose.position.z = self.local_pose.position.z + self.z_bias\n      if self.gcs_command == 0:\n        self.takeoff_target_pose.position.x = self.local_pose.position.x\n        self.takeoff_target_pose.position.y = self.local_pose.position.y\n        self.takeoff_target_pose.position.z = self.local_pose.position.z + 1.0\n        self.hover_target_pose.position.x = self.local_pose.position.x\n        self.hover_target_pose.position.y = self.local_pose.position.y\n        self.hover_target_pose.position.z = self.local_pose.position.z + 1.0\n      elif self.gcs_command == 1:\n        self.takeoff_target_pose.position.x = self.local_pose.position.x\n        self.takeoff_target_pose.position.y = self.local_pose.position.y\n        self.takeoff_target_pose.position.z = self.local_pose.position.z + 1.0\n        self.hover_target_pose.position.x = self.local_pose.position.x\n        self.hover_target_pose.position.y = self.local_pose.position.y\n        self.hover_target_pose.position.z = self.local_pose.position.z + 1.0\n      elif self.gcs_command == 2:\n        self.takeoff_target_pose.position.x = self.local_pose.position.x\n        self.takeoff_target_pose.position.y = self.local_pose.position.y\n        self.takeoff_target_pose.position.z = self.local_pose.position.z + 1.0\n        self.hover_target_pose.position.x = self.local", "CodeBleu_score": 15.415828087534472}, {"code": "def local_pose_callback(self, msg, i)\n    if i == self.id:\n        self.local_pose = msg\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x + self.x_bias\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y + self.y_bias\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z + self.z_bias\n        self.global_pose = self.local_to_global_pose(self.local_pose)\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose = self.local_pose\n        if self.gcs_command == 'hover':\n            self.hover_target_pose = self.local_pose\n", "CodeBleu_score": 30.7674481576916}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    if self.local_position[2] > 0.2 and self.arm_state:\n        return True\n    else:\n        return False", "CodeBleu_score": 72.95794663016015}, {"code": "def takeoff_detection(self)\n    if self.global_position[2] > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 72.14935422989501}, {"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == 1:\n      return True\n    else:\n      return False\n\n  def landing_detection(self):\n    \"\"\"This function, landing_detection, checks if a UAV has landed.\\nIt returns True if the UAV's altitude is less than 0.2 meters and the arm_state is inactive.\\nOtherwise, it returns False.\"\"\"\n    if self.altitude < 0.2 and self.arm_state == 0:\n      return True\n    else:\n      return False\n\n  def get_altitude(self):\n    \"\"\"This function, get_altitude, returns the UAV's altitude.\"\"\"\n    return self.altitude\n\n  def get_roll(self):\n    \"\"\"This function, get_roll, returns the UAV's roll.\"\"\"\n    return self.roll\n\n  def get_pitch(self):\n    \"\"\"This function, get_pitch, returns the UAV's pitch.\"\"\"\n    return self.pitch\n\n  def get_yaw(self):\n    \"\"\"This function, get_yaw, returns the UAV's yaw.\"\"\"\n    return self.yaw\n\n  def get_arm_state(self):\n    \"\"\"This function, get_arm_state, returns the UAV's arm state.\"\"\"\n    return self.arm_state\n\n  def get_battery(self):\n    \"\"\"This function, get_battery, returns the UAV's battery.\"\"\"\n    return self.battery\n\n  def get_mode(self):\n    \"\"\"This function, get_mode, returns the UAV's mode.\"\"\"\n    return self.mode\n\n  def get_velocity(self):\n    \"\"\"This function, get_velocity, returns the UAV's velocity.\"\"\"\n    return self.velocity\n\n  def get_position(self):\n    \"\"\"This function, get_position, returns the UAV's position.\"\"\"\n    return self.position\n\n  def get_local_position(self):\n    \"\"\"This function, get_local_position, returns the UAV's local position.\"\"\"\n    return self.local_position\n\n  def get_global_position(self):\n    \"\"\"This function, get_global_position, returns the UAV's global position.\"\"\"\n    return self.global_position\n\n  def get_local_velocity(self):\n    \"\"\"This function, get_local_velocity, returns the UAV's local velocity.\"\"\"\n    return self.local_velocity\n\n  def get_global_velocity(self):\n    \"\"\"This function, get", "CodeBleu_score": 51.1946106628349}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    # Initialize a distance matrix with the dimensions of the original formation\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Iterate over the UAVs in the original formation\n    for i in range(len(orig_formation)):\n        # Iterate over the UAVs in the changed formation\n        for j in range(len(change_formation)):\n            # Calculate the pairwise distance between the UAVs\n            dist = np.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust the distance by subtracting it from 50 and converting it to an integer\n            dist = int(50 - dist)\n            # Store the adjusted distance in the distance matrix\n            dist_matrix[i, j] = dist\n    # Return the distance matrix\n    return dist_matrix\n", "CodeBleu_score": 27.071361814635576}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # build a distance matrix\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i, j] = 50 - np.linalg.norm(orig_formation[i] - change_formation[j])\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n", "CodeBleu_score": 26.318588653877345}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # Build graph\n    graph = np.zeros((self.num_uavs, self.num_uavs))\n    for i in range(self.num_uavs):\n        for j in range(self.num_uavs):\n            if i == j:\n                graph[i, j] = 0\n            else:\n                graph[i, j] = int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n    return graph\n\n", "CodeBleu_score": 26.905293886930504}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    if self.left_visited[i]:\n        return False\n    self.left_visited[i] = True\n    for j in range(self.n_right):\n        if self.right_visited[j]:\n            continue\n        gap = self.left_labels[i] + self.right_labels[j] - self.weights[i][j]\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.right_match[j] < 0 or self.find_path(self.right_match[j]):\n                self.left_match[i] = j\n                self.right_match[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 45.06343164261223}, {"code": "def find_path(self, i)\n    if self.left_visited[i]:\n        return False\n    self.left_visited[i] = True\n    for j in self.graph[i]:\n        if self.right_visited[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - self.weight[i][j]\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.right_match[j] == -1 or self.find_path(self.right_match[j]):\n                self.left_match[i] = j\n                self.right_match[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 30.96855649319471}, {"code": "def find_path(self, i)\n    if self.visited[i]:\n      return False\n    self.visited[i] = True\n    for j in self.adj[i]:\n      if self.match[j] == -1 or self.find_path(self.match[j]):\n        self.match[j] = i\n        return True\n    return False\n\n  def update_labels(self):\n    \"\"\"This function, update_labels, updates the labels of the left and right vertices based on the slack values.\\nIt iterates through all the right vertices and updates the label of the left vertex if the gap between the label and the match weight is greater than the slack value.\\nIt also updates the label of the right vertex if the gap between the label and the match weight is less than the slack value.\"\"\"\n    x = sys.maxsize\n    for i in range(self.n):\n      if not self.visited[i]:\n        x = min(x, self.slack[i])\n    for i in range(self.n):\n      if self.visited[i]:\n        self.label[i] += x\n      else:\n        self.slack[i] -= x\n\n  def solve(self):\n    \"\"\"This function, solve, solves the maximum weight matching problem in a bipartite graph.\\nIt initializes the match and label arrays to -1 and 0 respectively.\\nIt then iterates through all the left vertices and finds an augmenting path.\\nIf an augmenting path is found, it updates the match and label arrays.\\nIf no augmenting path is found, it updates the labels of the left and right vertices.\"\"\"\n    self.match = [-1] * self.n\n    self.label = [0] * self.n\n    self.slack = [0] * self.n\n    for i in range(self.n):\n      while True:\n        self.visited = [False] * self.n\n        if self.find_path(i):\n          break\n        self.update_labels()\n    return sum(self.label)\n", "CodeBleu_score": 36.91621445099938}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n    match = [-1] * self.num_UAVs\n    for uav in range(self.num_UAVs):\n      slack = [float('inf')] * self.num_UAVs\n      visited = [False] * self.num_UAVs\n      self.KM_dfs(uav, match, visited, slack)\n    return match\n\n  def KM_dfs(self, uav, match, visited, slack):\n    \"\"\"This function, KM_dfs, performs a depth-first search to find a path from a given UAV to an unmatched UGV in the bipartite graph.\\nIt initializes the visited array to keep track of which UGVs have been visited.\\nIt then recursively searches for a path using the KM_dfs_helper function.\\nIf a path is found, it updates the match array to reflect the new matching.\\nIf no path is found, it adjusts the labels based on the minimum slack value.\\nThis process continues until a path is found or the UAV has no more unmatched UGVs.\"\"\"\n    visited[uav] = True\n    for ugv in range(self.num_UGVs):\n      if self.cost_matrix[uav][ugv] - self.label_uav[uav] - self.label_ugv[ugv] == 0:\n        if match[ugv] == -1 or self.KM_dfs_helper(match[ugv], match, visited, slack):\n          match[ugv] = uav\n          return True\n    for ugv in range(self.num_UGVs):\n      if self.cost_matrix[uav][ugv] - self.label_uav[uav] - self.label_ugv[ugv] < slack[ugv]:\n        slack[ugv] = self.cost_matrix[uav][ugv] - self.label_uav[uav] - self.label_ugv[ugv]\n    return False\n\n  def KM_dfs_helper(self, uav, match, visited, slack):\n    \"\"\"This function, KM_dfs_helper, performs a depth-first search to find a path from a given UAV to an unmatched UGV in the bipartite graph.\\nIt initializes the visited array to keep track of which UAVs have", "CodeBleu_score": 21.72788252102856}, {"code": "def KM(self)\n    for i in range(self.n):\n      self.U[i] = 0\n      self.V[i] = 0\n      self.P[i] = -1\n      self.Q[i] = -1\n      self.S[i] = 0\n      self.T[i] = 0\n      self.slack[i] = float('inf')\n\n    for i in range(self.n):\n      for j in range(self.n):\n        self.slack[j] = min(self.slack[j], self.C[i][j] - self.U[i] - self.V[j])\n      self.S[i] = 1\n      self.T[self.slack.index(min(self.slack))] = 1\n\n    while sum(self.T) < self.n:\n      for k in range(self.n):\n        if self.T[k] == 1:\n          for l in range(self.n):\n            if self.S[l] == 0:\n              self.slack[l] = min(self.slack[l], self.C[k][l] - self.U[k] - self.V[l])\n      delta = min(self.slack)\n      for i in range(self.n):\n        if self.S[i] == 1:\n          self.U[i] += delta\n        if self.T[i] == 1:\n          self.V[i] -= delta\n      for i in range(self.n):\n        if self.slack[i] == 0 and self.T[i] == 0:\n          self.T[i] = 1\n          if self.P[i]!= -1:\n            self.S[self.P[i]] = 1\n            self.slack[self.P[i]] = float('inf')\n          else:\n            j = i\n            while self.P[j]!= -1:\n              self.Q[j] = self.P[j]\n              j = self.P[j]\n            self.Q[j] = -2\n            break\n      for i in range(self.n):\n        if self.Q[i] == -1 and self.T[i] == 0:\n          self.Q[i] = -2\n\n    return self.Q\n", "CodeBleu_score": 25.580698119224664}, {"code": "def KM(self)\n    # Initialize the match array\n    match = [-1 for _ in range(len(self.UAVs))]\n    # Iterate over UAVs\n    for uav in range(len(self.UAVs)):\n        # Initialize the slack array\n        slack = [float(\"inf\") for _ in range(len(self.UAVs))]\n        # Initialize the visited array\n        visited = [False for _ in range(len(self.UAVs))]\n        # Initialize the path array\n        path = [-1 for _ in range(len(self.UAVs))]\n        # Find a matching path for the current UAV\n        while True:\n            # Initialize the current UAV's label\n            label = 0\n            # Initialize the current UAV's path index\n            path_index = 0\n            # Initialize the current UAV's path length\n            path_length = 0\n            # Find a matching path for the current UAV\n            while path_index < len(self.UAVs) and not visited[path_index]:\n                # Update the current UAV's label\n                label = max(label, self.UAVs[uav].cost[path_index] - self.UAVs[uav].label - self.UAVs[path_index].label)\n                # Update the current UAV's path index\n                path_index += 1\n            # Update the current UAV's path length\n            path_length = path_index\n            # Initialize the current UAV's path index\n            path_index = 0\n            # Update the current UAV's path\n            while path_index < path_length:\n                # Update the current UAV's path\n                if not visited[path_index]:\n                    # Update the current UAV's path\n                    path[path_index] = uav\n                    # Update the current UAV's path index\n                    path_index += 1\n                # Update the current UAV's path index\n                path_index += 1\n            # Initialize the current UAV's path index\n            path_index = 0\n            # Update the current UAV's path\n            while path_index < path_length:\n                # Update the current UAV's path\n                visited[path_index] = True\n                # Update the current UAV's path index\n                path_index += 1\n            # Initialize the current UAV's path index\n            path_index = 0\n            # Update the current UAV's path\n           ", "CodeBleu_score": 26.927096707855743}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    yellow_image = cv2.bitwise_and(image, image, mask=mask)\n    return yellow_image\n", "CodeBleu_score": 24.981197942921547}, {"code": "def yellow_dectection(image)\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Define the lower and upper bounds for the yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # Create a mask for the yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 25.555609057231816}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription\tconst std::string& id,\n\tTagDescriptionContainer& descriptionContainer,\n\tbool printWarning = true", "CodeBleu_score": 1.0490512245129846}, {"code": "bool TagDetector::findStandaloneTagDescription\tconst std::string &id,\n\tStandaloneTagDescriptionContainer &descriptionContainer,\n\tbool printWarning", "CodeBleu_score": 0.957065600465885}, {"code": "bool TagDetector::findStandaloneTagDescription\tstd::string descriptionContainer;\n\tif (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tLOG_WARN(\"Tag description for ID \" << id << \" not found.\");\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = standalone_tag_descriptions_.at(id);\n\treturn true;\n}\n", "CodeBleu_score": 34.279684808533176}]}
