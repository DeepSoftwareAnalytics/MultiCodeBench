{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_iface_desc_t UDC_DESC_STORAGE * iface_desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc;\n\n\tiface_desc = (usb_iface_desc_t UDC_DESC_STORAGE *) desc;\n\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t\n\t\t\tUDC_DESC_STORAGE *) iface_desc + iface_desc->bLength);\n\n\twhile (next_desc->bLength) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t\n\t\t\t\tUDC_DESC_STORAGE *) next_desc + next_desc->bLength);\n\t}\n\n\treturn NULL;\n}\n", "CodeBleu_score": 40.51715514073795}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\twhile (desc->bLength) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc + desc->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 32.23880207939971}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_iface_desc_t UDC_DESC_STORAGE * iface_desc;\n\tusb_endp_desc_t UDC_DESC_STORAGE * endp_desc;\n\n\tiface_desc = (usb_iface_desc_t UDC_DESC_STORAGE *) desc;\n\tif (iface_desc->bDescriptorType == USB_DESC_INTERFACE) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + iface_desc->bLength);\n\t\twhile (desc->bDescriptorType!= USB_DESC_END_OF_CFG) {\n\t\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\t\treturn desc;\n\t\t\t}\n\t\t\tendp_desc = (usb_endp_desc_t UDC_DESC_STORAGE *) desc;\n\t\t\tif (desc->bDescriptorType == USB_DESC_ENDPOINT) {\n\t\t\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + endp_desc->bLength);\n\t\t\t} else {\n\t\t\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + desc->bLength);\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 49.158373730031016}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tconst struct usb_configuration_descriptor *config_desc;\n\tconst struct usb_interface_descriptor *iface_desc;\n\tuint8_t iface_count;\n\tuint8_t setting_count;\n\n\tif (!udc_is_valid_config()) {\n\t\treturn false;\n\t}\n\n\tconfig_desc = udc_get_config_desc();\n\tiface_count = config_desc->bNumInterfaces;\n\n\tif (iface_num >= iface_count) {\n\t\treturn false;\n\t}\n\n\tiface_desc = udc_get_iface_desc(iface_num, 0);\n\n\tif (iface_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tsetting_count = iface_desc->bNumEndpoints;\n\n\tif (setting_num >= setting_count) {\n\t\treturn false;\n\t}\n\n\tiface_desc = udc_get_iface_desc(iface_num, setting_num);\n\n\tif (iface_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tudc_iface_desc = iface_desc;\n\n\treturn true;\n}\n", "CodeBleu_score": 32.36056587829003}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tconst struct usb_configuration_descriptor *config_desc = udc_get_config_desc();\n\tconst struct usb_interface_descriptor *iface_desc = NULL;\n\tconst uint8_t *desc = (const uint8_t *) config_desc;\n\tconst uint8_t *end = desc + le16_to_cpu(config_desc->wTotalLength);\n\n\tif (config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tdesc += config_desc->bLength;\n\n\twhile (desc < end) {\n\t\tconst struct usb_descriptor_header *header = (const struct usb_descriptor_header *) desc;\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tiface_desc = (const struct usb_interface_descriptor *) desc;\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdesc += header->bLength;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 35.170077683032176}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (config_desc == NULL)\n\t\treturn false;\n\n\tif (iface_num >= config_desc->bNumInterfaces)\n\t\treturn false;\n\n\tuint8_t *desc = (uint8_t *) config_desc;\n\tuint8_t *end = desc + config_desc->wTotalLength;\n\tuint8_t *iface_desc = NULL;\n\n\twhile (desc < end) {\n\t\tif (desc[1] == USB_DESC_INTERFACE) {\n\t\t\tiface_desc = desc;\n\t\t\tif (iface_desc[2] == iface_num) {\n\t\t\t\tif (iface_desc[3] == setting_num)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdesc += desc[0];\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 30.65372969147403}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void)\tif (setup_pkt->wLength!= 2) {\n\t\treturn false;\n\t}\n\n\tuint8_t ep_num = setup_pkt->wIndex & 0x0F;\n\tuint8_t ep_status = 0;\n\n\tif (ep_num == 0) {\n\t\tep_status = udc_ep_get_status(ep_num);\n\t} else {\n\t\tep_status = udc_ep_get_status(ep_num) << 1;\n\t}\n\n\tudc_setup_response(ep_status, 2);\n\n\treturn true;\n}\n", "CodeBleu_score": 21.264125961432416}, {"code": "static bool udc_req_std_ep_get_status(void)\t/* check if the request length matches the size of the endpoint status variable */\n\tif (req->wLength!= 2) {\n\t\treturn false;\n\t}\n\n\t/* determine the status of the specified endpoint, setting the status to \"halted\" if the endpoint is halted, or \"0\" if it is not */\n\tuint8_t status = 0;\n\tif (ep_is_halted(req->wIndex)) {\n\t\tstatus = 1;\n\t}\n\n\t/* set up the response payload with the endpoint status */\n\tuint8_t *data = req->data;\n\tdata[0] = status;\n\tdata[1] = 0;\n\n\treturn true;\n}\n", "CodeBleu_score": 29.69113461519186}, {"code": "static bool udc_req_std_ep_get_status(void)\tif (setup_pkt.wLength!= 2) {\n\t\treturn false;\n\t}\n\tuint8_t ep_idx = EP_IDX(setup_pkt.wIndex);\n\tif (ep_idx >= UDC_EP_NUM) {\n\t\treturn false;\n\t}\n\tuint16_t status = 0;\n\tif (udc_ep_is_halted(ep_idx)) {\n\t\tstatus = 1;\n\t}\n\tudc_set_setup_payload(setup_pkt.wLength, &status);\n\treturn true;\n}\n", "CodeBleu_score": 34.081823441495686}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void)\tuint8_t iface_nb = udi_req->wIndex;\n\tbool zlp = false;\n\n\tif (udc_get_state() < UDC_STATE_ADDRESSED) {\n\t\treturn false;\n\t}\n\n\tif (iface_nb >= UDI_NB) {\n\t\treturn false;\n\t}\n\n\tif (udi_get_desc_iface_handler(iface_nb) == NULL) {\n\t\treturn false;\n\t}\n\n\tif (udi_get_desc_iface_handler(iface_nb)->\n\t\t\tget_nb_interfaces(iface_nb) == 0) {\n\t\treturn false;\n\t}\n\n\tif (udi_get_desc_iface_handler(iface_nb)->\n\t\t\tget_nb_endpoints(iface_nb, 0) == 0) {\n\t\treturn false;\n\t}\n\n\tif (udi_get_desc_iface_handler(iface_nb)->\n\t\t\tget_nb_endpoints(iface_nb, udi_req->wValue) == 0) {\n\t\treturn false;\n\t}\n\n\tif (udi_get_desc_iface_handler(iface_nb)->\n\t\t\tget_setting(iface_nb, udi_req->wValue) == 0) {\n\t\treturn false;\n\t}\n\n\tif (udi_get_desc_iface_handler(iface_nb)->\n\t\t\tget_setting(iface_nb, 0) == 0) {\n\t\treturn false;\n\t}\n\n\tif (udi_get_desc_iface_handler(iface_nb)->\n\t\t\tget_setting(iface_nb, udi_req->wValue) == 0) {\n\t\treturn false;\n\t}\n\n\tif (udi_get_desc_iface_handler(iface_nb)->\n\t\t\tget_setting(iface_nb, 0) == 0) {\n\t\treturn false;\n\t}\n\n\t/* Update interface descriptor to default setting */\n\tif (udi_get_desc_iface_handler(iface_nb)->\n\t\t\tset_altsetting(iface_nb, 0) == false) {\n\t\treturn false;\n\t}\n\n\t/* Update interface descriptor to current alternate setting */\n\tif (udi_get_desc_iface_handler(iface_", "CodeBleu_score": 45.79362629062249}, {"code": "static bool udc_req_iface(void)\tuint8_t iface = udi_req->wIndex;\n\tuint8_t alt = udi_req->wValue;\n\n\tif (iface >= UDI_NB_IFACES) {\n\t\treturn false;\n\t}\n\n\tif (alt > UDI_IFACE_NB_ALTERNATE(iface)) {\n\t\treturn false;\n\t}\n\n\tif (udi_desc_iface_get(iface, &udi_req_desc_iface) == false) {\n\t\treturn false;\n\t}\n\n\tif (alt!= udi_req_desc_iface.bAlternateSetting) {\n\t\tudi_req_desc_iface.bAlternateSetting = alt;\n\t\tif (udi_desc_iface_set(iface, &udi_req_desc_iface) == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (udi_req_desc_iface.bAlternateSetting!= alt) {\n\t\treturn false;\n\t}\n\n\treturn udi_req_handler_set(iface);\n}\n", "CodeBleu_score": 49.70193170662582}, {"code": "static bool udc_req_iface(void)\tuint8_t iface_num = udi_req->wIndex;\n\tuint8_t iface_alt = udi_req->wValue;\n\tuint8_t iface_pos;\n\tbool ret;\n\n\tif (udc_get_state()!= UDC_STATE_CONFIGURED) {\n\t\tTRACE_INFO_WP(\"iface %d not configured\\n\\r\", iface_num);\n\t\treturn false;\n\t}\n\n\tiface_pos = udc_find_iface_pos(iface_num);\n\tif (iface_pos == UDI_NOT_FOUND) {\n\t\tTRACE_INFO_WP(\"iface %d not found\\n\\r\", iface_num);\n\t\treturn false;\n\t}\n\n\tif (iface_alt!= 0) {\n\t\tTRACE_INFO_WP(\"iface %d alt %d not supported\\n\\r\", iface_num, iface_alt);\n\t\treturn false;\n\t}\n\n\tif (iface_alt!= udc_ifaces[iface_pos].setting_cur) {\n\t\tif (iface_alt!= udc_ifaces[iface_pos].setting_def) {\n\t\t\tTRACE_INFO_WP(\"iface %d alt %d not supported\\n\\r\", iface_num, iface_alt);\n\t\t\treturn false;\n\t\t}\n\n\t\tret = udc_set_iface_setting(iface_pos, iface_alt);\n\t\tif (!ret) {\n\t\t\tTRACE_INFO_WP(\"iface %d alt %d not supported\\n\\r\", iface_num, iface_alt);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (iface_alt!= udc_ifaces[iface_pos].setting_cur) {\n\t\tret = udc_set_iface_setting(iface_pos, iface_alt);\n\t\tif (!ret) {\n\t\t\tTRACE_INFO_WP(\"iface %d alt %d not supported\\n\\r\", iface_num, iface_alt);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tret = udi_req->setup(udi_req);\n\tif (!ret) {\n\t\tTRACE_INFO_WP(\"iface %d alt %d setup failed\\n\\r\", iface_num, iface_alt);\n\t\treturn false;", "CodeBleu_score": 41.23910312468212}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void)\t// Initialize the LUNs\n\tudi_msc_lun_init();\n\n\t// Check if the LUNs are available\n\tif (udi_msc_get_nb_lun() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check if the external enable function is available\n\tif (!udi_msc_enable_ext()) {\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tudi_msc_unload_medium();\n\n\t// Start the MSC process\n\tudi_msc_process_start();\n\n\treturn true;\n}\n", "CodeBleu_score": 14.098134662144279}, {"code": "bool udi_msc_enable(void)\t// Set initial states for several flags\n\tmsc_b_cbw_enable = false;\n\tmsc_b_data_enable = false;\n\tmsc_b_data_direction = 0;\n\tmsc_b_state = UDI_MSC_STATE_CBW_WAIT;\n\tmsc_b_substate = UDI_MSC_SUBSTATE_NONE;\n\tmsc_b_cbw_error = UDI_MSC_CBW_NO_ERROR;\n\tmsc_b_cbw_state = UDI_MSC_CBW_IDLE;\n\tmsc_b_cbw_data_to_transfer = 0;\n\tmsc_b_cbw_data_transfered = 0;\n\tmsc_b_cbw_data_remaining = 0;\n\tmsc_b_cbw_data_current_address = NULL;\n\tmsc_b_cbw_data_size = 0;\n\tmsc_b_cbw_data_size_multi = 0;\n\tmsc_b_cbw_data_size_multi_current = 0;\n\tmsc_b_cbw_data_size_multi_nb = 0;\n\tmsc_b_cbw_data_size_multi_nb_current = 0;\n\tmsc_b_cbw_data_size_multi_nb_remaining = 0;\n\tmsc_b_cbw_data_size_multi_nb_size = 0;\n\tmsc_b_cbw_data_size_multi_nb_size_current = 0;\n\tmsc_b_cbw_data_size_multi_nb_size_remaining = 0;\n\tmsc_b_cbw_data_size_multi_nb_size_size = 0;\n\tmsc_b_cbw_data_size_multi_nb_size_size_current = 0;\n\tmsc_b_cbw_data_size_multi_nb_size_size_remaining = 0;\n\tmsc_b_cbw_data_size_multi_nb_size_size_size = 0;\n\tmsc_b_cbw_data_size_multi_nb_size_size_size_current =", "CodeBleu_score": 24.303857796095414}, {"code": "bool udi_msc_enable(void)\t// Initialize the MSC interface\n\tudi_msc_init();\n\n\t// Set the initial states for the flags\n\tudi_msc_b_cbw_enable = false;\n\tudi_msc_b_data_enable = false;\n\tudi_msc_b_stall_data = false;\n\tudi_msc_b_stall_cbw = false;\n\n\t// Retrieve the number of LUNs\n\tudi_msc_nb_lun = udi_msc_get_nb_lun();\n\n\t// Check if there are any LUNs available\n\tif (!udi_msc_nb_lun) {\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tfor (uint8_t i = 0; i < udi_msc_nb_lun; i++) {\n\t\tudi_msc_unload_medium(i);\n\t}\n\n\t// Start the MSC process by waiting for a CBW reception\n\tudi_msc_process_start();\n\n\treturn true;\n}\n", "CodeBleu_score": 41.90336496705783}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t/* Transfer aborted, reset the MSC */\n\t\tudi_msc_reset();\n\t} else {\n\t\t/* Update the sense data */\n\t\tudi_msc_update_sense_data(nb_sent);\n\t\t/* Decrease the data residue in the CSW by the amount of data sent */\n\t\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\t\t/* Process the updated CSW */\n\t\tudi_msc_process_csw();\n\t}\n}\n", "CodeBleu_score": 59.52811915671463}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t/* Transfer aborted by the host */\n\t\t/* Wait for a MSC setup reset to restart CBW reception */\n\t\treturn;\n\t}\n\n\t/* Update the sense data */\n\tudi_msc_update_sense_data(UDI_MSC_SENSE_DATA_OK);\n\n\t/* Decrease the data residue in the CSW by the amount of data sent */\n\tudi_msc_cbw_data_residue -= nb_sent;\n\n\t/* Process the updated CSW */\n\tudi_msc_process_csw();\n}\n", "CodeBleu_score": 58.45587668850721}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_reset_cbw();\n\t\treturn;\n\t}\n\n\tudi_msc_cbw.dCBWDataResidue -= nb_sent;\n\n\tif (udi_msc_cbw.dCBWDataResidue == 0) {\n\t\tudi_msc_process_csw();\n\t} else {\n\t\tudi_msc_trans_data();\n\t}\n}\n", "CodeBleu_score": 53.3603624837205}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void)\t// If there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\tif (udi_msc_cbw.dCBWDataTransferLength!= udi_msc_cbw.dCBWDataResidue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_FLAG_DIR_IN) {\n\t\t\tudi_msc_stall_ep_in();\n\t\t} else {\n\t\t\tudi_msc_stall_ep_out();\n\t\t}\n\t}\n\n\t// Prepare the CSW by setting its tag and converting the data residue to little-endian format.\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataResidue;\n\n\t// Send the CSW.\n\tudi_msc_send_csw();\n}\n", "CodeBleu_score": 49.68412119436446}, {"code": "static void udi_msc_csw_process(void)\tif (udi_msc_cbw.dCBWDataTransferLength!= udi_msc_cbw_data_residue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_FLAG_IN) {\n\t\t\tudi_msc_stall_ep_in();\n\t\t} else {\n\t\t\tudi_msc_stall_ep_out();\n\t\t}\n\t} else {\n\t\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\t\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw_data_residue;\n\t\tudi_msc_csw.bCSWStatus = udi_msc_cbw_status;\n\t\tudi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_CMD_PASSED;\n\t\tudi_msc_cbw_status = UDI_MSC_CSW_STATUS_CMD_PASSED;\n\t\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\t\tudi_msc_csw_send();\n\t}\n}\n", "CodeBleu_score": 49.44343663944589}, {"code": "static void udi_msc_csw_process(void)\tif (udi_msc_cbw.dCBWDataTransferLength!= 0) {\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIR_IN) {\n\t\t\tudi_msc_ep_in_stall();\n\t\t} else {\n\t\t\tudi_msc_ep_out_stall();\n\t\t}\n\t}\n\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n\tudi_msc_csw.bCSWStatus = udi_msc_cbw.bCBWLUN;\n\n\tudi_msc_ep_in_run(udi_msc_csw.bCSWSignature, sizeof(udi_msc_csw));\n}\n", "CodeBleu_score": 50.54330446842255}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\t/* Update DTR status */\n\ts_cdc_dtr[port] = b_enable;\n\n\t/* If DTR is disabled and the rate is 1200, schedule a delayed system reset */\n\tif (!b_enable && (s_cdc_rate[port] == 1200)) {\n\t\t/* Schedule a delayed system reset */\n\t\tinitiateReset();\n\t}\n\n\t/* If DTR is enabled, cancel any scheduled reset */\n\tif (b_enable) {\n\t\tcancelReset();\n\t}\n}\n", "CodeBleu_score": 20.712382673968037}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (port >= USB_PORT_COUNT) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\tusb_port_dtr[port] = true;\n\t\tif (usb_port_baudrate[port] == 1200) {\n\t\t\tusb_port_reset_scheduled[port] = true;\n\t\t\tscheduleReset(port);\n\t\t}\n\t} else {\n\t\tusb_port_dtr[port] = false;\n\t\tif (usb_port_baudrate[port] == 1200) {\n\t\t\tcancelReset(port);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.742518895672376}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (port >= USB_PORT_COUNT) {\n\t\treturn;\n\t}\n\tif (b_enable) {\n\t\tif (usb_cdc_line_coding[port].dwDTERate!= 1200) {\n\t\t\treturn;\n\t\t}\n\t\tusb_cdc_line_coding[port].b_dtr = true;\n\t\tcancelReset();\n\t} else {\n\t\tusb_cdc_line_coding[port].b_dtr = false;\n\t\tif (usb_cdc_line_coding[port].dwDTERate == 1200) {\n\t\t\tscheduleReset();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.43020201232402}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)\tuint8_t *payload = NULL;\n\tuint16_t size = 0;\n\n\tif (USB_ControlRequest.bmRequestType!= (REQDIR_HOSTTODEVICE | REQTYPE_VENDOR | REQREC_DEVICE)) {\n\t\treturn false;\n\t}\n\n\tswitch (USB_ControlRequest.bRequest) {\n\t\tcase 0x04:\n\t\t\tpayload = (uint8_t *)MS_CompatID_Descriptor;\n\t\t\tsize = sizeof(MS_CompatID_Descriptor);\n\t\t\tbreak;\n\n\t\tcase 0x05:\n\t\t\tpayload = (uint8_t *)MS_ExtendedConfigDesc_Configuration;\n\t\t\tsize = sizeof(MS_ExtendedConfigDesc_Configuration);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\tUSB_ControlRequest.bmRequestType = REQDIR_DEVICETOHOST;\n\tUSB_ControlRequest.bRequest = REQ_GETDESCRIPTOR;\n\tUSB_ControlRequest.wValue = (DESC_CONFIGURATION << 8) | 0x00;\n\tUSB_ControlRequest.wIndex = 0x00;\n\tUSB_ControlRequest.wLength = size;\n\tUSB_ControlRequest.pData = payload;\n\n\treturn true;\n}\n", "CodeBleu_score": 34.549839617380506}, {"code": "bool usb_task_other_requests(void)\tif ((usb_setup.bmRequestType & USB_SETUP_TYPE_MASK) == USB_SETUP_TYPE_VENDOR) {\n\t\tswitch (usb_setup.bRequest) {\n\t\tcase 0x04:\n\t\t\tusb_control_request_payload = (uint8_t *) &usb_ms_compat_id_descriptor;\n\t\t\tusb_control_request_size = sizeof(usb_ms_compat_id_descriptor);\n\t\t\treturn true;\n\t\tcase 0x05:\n\t\t\tusb_control_request_payload = (uint8_t *) &usb_ms_extended_compat_id_descriptor;\n\t\t\tusb_control_request_size = sizeof(usb_ms_extended_compat_id_descriptor);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 24.161669220207145}, {"code": "bool usb_task_other_requests(void)\t// Check if the request is a vendor-specific request\n\tif (USB_SetupPacket.RequestType!= 0x40) {\n\t\treturn false;\n\t}\n\n\t// Check the request index\n\tif (USB_SetupPacket.Request == 0x04) {\n\t\t// Set the pointer to the Microsoft-compatible ID descriptor\n\t\tUSB_ControlRequest.Ptr = (uint8_t*) &microsoft_compatible_id_descriptor;\n\t\t// Set the size of the Microsoft-compatible ID descriptor\n\t\tUSB_ControlRequest.Size = sizeof(microsoft_compatible_id_descriptor);\n\t\t// Return true to indicate the request is processed\n\t\treturn true;\n\t} else if (USB_SetupPacket.Request == 0x05) {\n\t\t// Set the pointer to the extended properties descriptor\n\t\tUSB_ControlRequest.Ptr = (uint8_t*) &extended_properties_descriptor;\n\t\t// Set the size of the extended properties descriptor\n\t\tUSB_ControlRequest.Size = sizeof(extended_properties_descriptor);\n\t\t// Return true to indicate the request is processed\n\t\treturn true;\n\t}\n\n\t// Return false if the request index is not recognized\n\treturn false;\n}\n", "CodeBleu_score": 21.079702831929055}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0)\n\t\treturn;\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPDR = 0xFF;\n\t\twhile (!(SPSR & (1 << SPIF)))\n\t\t\t;\n\t\tbuf[i] = SPDR;\n\t}\n\tbuf[i] = spiRec();\n}\n", "CodeBleu_score": 46.12400050716019}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0) return;\n\tuint8_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPDR = 0xFF;\n\t\twhile (!(SPSR & (1 << SPIF)));\n\t\tbuf[i] = SPDR;\n\t}\n\tbuf[i] = spiRec();\n}\n", "CodeBleu_score": 46.315456015554965}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0) return;\n\tfor (uint16_t i = 0; i < nbyte - 1; i++) {\n\t\tSPDR = 0xFF;\n\t\twhile (!(SPSR & (1 << SPIF)));\n\t\tbuf[i] = SPDR;\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}\n", "CodeBleu_score": 50.18756597346855}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\t// Get the address of the relocated interrupt vector table\n\tconst IRQn_Type *irq_table = (const IRQn_Type *)SCB->VTOR;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Get the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = (pfnISR_Handler)irq_table[irq];\n\n\t// Replace the current handler with the new handler\n\tirq_table[irq] = (IRQn_Type)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}\n", "CodeBleu_score": 47.825452717649064}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler;\n\tuint32_t *vectTable = (uint32_t *)SCB->VTOR;\n\toldHandler = (pfnISR_Handler)vectTable[irq + 16];\n\t__disable_irq();\n\tvectTable[irq + 16] = (uint32_t)newHandler;\n\t__enable_irq();\n\treturn oldHandler;\n}\n", "CodeBleu_score": 57.16003756644182}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler = NULL;\n\tuint32_t *vectorTable = (uint32_t *)SCB->VTOR;\n\t__disable_irq();\n\toldHandler = (pfnISR_Handler)vectorTable[irq];\n\tvectorTable[irq] = (uint32_t)newHandler;\n\t__enable_irq();\n\treturn oldHandler;\n}\n", "CodeBleu_score": 50.084307147887195}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek()#if ENABLED(SERIAL_USB)\n  if (usb_cdc_configured) {\n    int c = usb_cdc_rx_peek();\n    if (c >= 0) {\n      if (emergency_parser_enabled)\n        emergency_parser(c);\n      return c;\n    }\n  }", "CodeBleu_score": 34.318367527268684}, {"code": "int MarlinSerialUSB::peek()#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser_enabled) {\n    if (emergency_parser_index < EMERGENCY_PARSER_SIZE) {\n      if (emergency_parser_buffer[emergency_parser_index] == '\\n') {\n        emergency_parser_enabled = false;\n        return emergency_parser_buffer[emergency_parser_index++];\n      }\n      return emergency_parser_buffer[emergency_parser_index++];\n    }\n    emergency_parser_enabled = false;\n  }", "CodeBleu_score": 25.649464917834074}, {"code": "int MarlinSerialUSB::peek()#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser_enabled) {\n    while (available() && emergency_parser_enabled) emergency_parse_char(read());\n    return -1;\n  }", "CodeBleu_score": 21.427763806717806}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read()\tif (peek() >= 0) return _rx_buffer[_rx_buffer_head];\n\tif (!usb_configured() ||!usb_serial_get_control()) return -1;\n\tif (usb_serial_available() == 0) return -1;\n\tint16_t c = usb_serial_getchar();\n\tif (c < 0) return -1;\n\tif (c == '\\r') c = '\\n';\n\tif (c == '\\n') {\n\t\tif (emergency_parser.enabled) {\n\t\t\temergency_parser.parse(emergency_parser.buffer);\n\t\t\temergency_parser.buffer[0] = '\\0';\n\t\t}\n\t}\n\telse {\n\t\tif (emergency_parser.enabled) {\n\t\t\tstrcat(emergency_parser.buffer, (char*)&c);\n\t\t\tif (strlen(emergency_parser.buffer) >= MAX_CMD_SIZE) {\n\t\t\t\temergency_parser.parse(emergency_parser.buffer);\n\t\t\t\temergency_parser.buffer[0] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n", "CodeBleu_score": 33.50403272653584}, {"code": "int MarlinSerialUSB::read()#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser_enabled) {\n    if (emergency_parser_index >= 0) {\n      if (emergency_parser_index == 0) {\n        emergency_parser_crc = 0;\n      }\n      emergency_parser_crc = CRC16::calc(emergency_parser_buffer[emergency_parser_index], emergency_parser_crc);\n      if (++emergency_parser_index >= sizeof(emergency_parser_buffer)) {\n        emergency_parser_index = -1;\n        if (emergency_parser_crc == 0) {\n          return emergency_parser_buffer[0];\n        }\n      }\n    }\n  }", "CodeBleu_score": 37.85172663915628}, {"code": "int MarlinSerialUSB::read()#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available()) return emergency_parser.read();", "CodeBleu_score": 16.697161374759656}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available()\tif (usb_cdc_is_enabled()) {\n\t\treturn usb_cdc_available();\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 15.845010998828645}, {"code": "int MarlinSerialUSB::available()\tint count = 0;\n\tif (CDC_Device_BytesReceived(&VirtualSerial_CDC_Interface)) {\n\t\tcount = CDC_Device_BytesReceived(&VirtualSerial_CDC_Interface);\n\t} else {\n\t\tif (USB_DeviceState == DEVICE_STATE_Configured) {\n\t\t\tcount = -1;\n\t\t} else {\n\t\t\tcount = 0;\n\t\t}\n\t}\n\treturn count;\n}\n", "CodeBleu_score": 33.36621276242636}, {"code": "int MarlinSerialUSB::available()\treturn serial_rx_buffer_count();\n}\n", "CodeBleu_score": 7.526207144800992}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tif (pos < 0 || pos >= size) {\n\t\treturn false;\n\t}\n\tif (value == nullptr) {\n\t\treturn false;\n\t}\n\tif (size == 0) {\n\t\treturn false;\n\t}\n\tif (crc == nullptr) {\n\t\treturn false;\n\t}\n\tif (writing) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tvalue[i] = read_byte(pos);\n\t\t\t*crc = CRC16::update(*crc, value[i]);\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tvalue[i] = 0;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 44.048978991524876}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tfor (size_t i = 0; i < size; ++i) {\n\t\tif (writing) {\n\t\t\tif (value!= nullptr) {\n\t\t\t\t*value = read_byte(pos);\n\t\t\t} else {\n\t\t\t\tread_byte(pos);\n\t\t\t}\n\t\t} else {\n\t\t\tif (value!= nullptr) {\n\t\t\t\t*value = read_byte(pos);\n\t\t\t} else {\n\t\t\t\tread_byte(pos);\n\t\t\t}\n\t\t}\n\t\tif (crc!= nullptr) {\n\t\t\t*crc = CRC16::update(*crc, read_byte(pos));\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 44.74499170681423}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tif (pos < 0 || pos >= storage_size) {\n\t\treturn false;\n\t}\n\tif (pos + size > storage_size) {\n\t\tsize = storage_size - pos;\n\t}\n\tif (size == 0) {\n\t\treturn false;\n\t}\n\tif (writing) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tif (value!= nullptr) {\n\t\t\t\tvalue[i] = storage[pos + i];\n\t\t\t}\n\t\t\tif (crc!= nullptr) {\n\t\t\t\t*crc = crc16_update(*crc, storage[pos + i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tif (value!= nullptr) {\n\t\t\t\tstorage[pos + i] = value[i];\n\t\t\t}\n\t\t\tif (crc!= nullptr) {\n\t\t\t\t*crc = crc16_update(*crc, value[i]);\n\t\t\t}\n\t\t}\n\t}\n\tpos += size;\n\treturn false;\n}\n", "CodeBleu_score": 41.37935701588811}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\t// check if pin is valid\n\tif (pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\t// check if pin supports PWM\n\tif (!digitalPinHasPWM(pin)) {\n\t\treturn;\n\t}\n\t// check if pin supports hardware PWM\n\tif (digitalPinToTimer(pin)!= NOT_ON_TIMER) {\n\t\t// check if hardware PWM is already set up\n\t\tif (ledcSetup(pin, freq, res)) {\n\t\t\t// set PWM value\n\t\t\tledcWrite(pin, value);\n\t\t}\n\t\treturn;\n\t}\n\t// check if pin supports software PWM\n\tif (digitalPinToSoftPWM(pin)!= NOT_ON_SOFT_PWM) {\n\t\t// check if software PWM is already set up\n\t\tif (softPWMSetup(pin, freq, res)) {\n\t\t\t// set PWM value\n\t\t\tsoftPWMWrite(pin, value);\n\t\t}\n\t\treturn;\n\t}\n\t// no PWM support found\n}\n", "CodeBleu_score": 24.096577884378874}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\tif (value > 0) {\n\t\tif (pwm_channels[pin].timer_index == -1) {\n\t\t\tpwm_channels[pin].timer_index = allocateTimer(pin, freq, res);\n\t\t}\n\t\tledcWrite(pwm_channels[pin].channel, value);\n\t} else {\n\t\tif (pwm_channels[pin].timer_index!= -1) {\n\t\t\tledcDetachPin(pin);\n\t\t\tpwm_channels[pin].timer_index = -1;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 26.146587430673808}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\tif (pin == 0) return;\n\tif (pin < 32) {\n\t\tif (pin == 25 || pin == 26) {\n\t\t\t// DAC\n\t\t\tdacWrite(pin, value);\n\t\t\treturn;\n\t\t}\n\t\tif (pin == 4 || pin == 12 || pin == 13 || pin == 14 || pin == 27 || pin == 28 || pin == 29 || pin == 32 || pin == 33) {\n\t\t\t// LEDC\n\t\t\tledcSetup(pin, freq, res);\n\t\t\tledcWrite(pin, value);\n\t\t\treturn;\n\t\t}\n\t}\n\t// Software PWM\n\tif (value == 0) {\n\t\t// Turn off\n\t\tif (pwm_state[pin]) {\n\t\t\tpwm_state[pin]->enabled = false;\n\t\t\tpwm_state[pin]->count--;\n\t\t\tif (pwm_state[pin]->count == 0) {\n\t\t\t\t// No more PWM pins using this timer, so stop the timer\n\t\t\t\ttimerStop(pwm_state[pin]->timer);\n\t\t\t\tdelete pwm_state[pin]->timer;\n\t\t\t\tpwm_state[pin]->timer = nullptr;\n\t\t\t}\n\t\t\tdelete pwm_state[pin];\n\t\t\tpwm_state[pin] = nullptr;\n\t\t}\n\t\treturn;\n\t}\n\t// Turn on\n\tif (!pwm_state[pin]) {\n\t\t// Create a new PWM state\n\t\tpwm_state[pin] = new PWMState();\n\t\tpwm_state[pin]->timer = nullptr;\n\t\tpwm_state[pin]->count = 0;\n\t\tpwm_state[pin]->enabled = false;\n\t}\n\t// Set the PWM value\n\tpwm_state[pin]->value = value;\n\t// Set the PWM frequency\n\tif (pwm_state[pin]->freq!= freq) {\n\t\tpwm_state[pin]->freq = freq;\n\t\tif (pwm_state[pin]->timer) {\n\t\t\t// Timer already exists, so stop it and delete it\n\t\t\ttimerStop(pwm_state[pin]->timer);\n\t\t\tdelete pwm_state[pin]->timer;\n\t\t\tpwm_state[pin]->timer = nullptr;\n\t\t}\n\t\t// Create a new timer\n\t\tpwm_", "CodeBleu_score": 32.74987067226576}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value)\tstatic_assert(sizeof(delay) == 8 * sizeof(int), \"Invalid delay array length\");\n\n\tif (servo.attach(pin)) {\n\t\tservo.write(value);\n\t\tdelayMicroseconds(delay[channel]);\n\t}\n\n\t#if DEACTIVATE_SERVOS_AFTER_MOVE\n\t\tservo.detach();\n\t#endif\n}", "CodeBleu_score": 41.75711595385006}, {"code": "void Servo::move(const int value)\tstatic_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == 4, \"Servo delay array size must be 4.\");\n\n\tif (servo_attached) {\n\t\tservo.write(value);\n\t\tdelay(servo_delay[servo_channel]);\n", "CodeBleu_score": 43.69899417789107}, {"code": "void Servo::move(const int value)\tstatic_assert(SERVO_DELAYS_LENGTH == 8, \"Servo delays array length is not 8!\");\n\tif (this->attach()) {\n\t\tthis->write(value);\n\t\tdelay(SERVO_DELAYS[this->channel]);\n\t\t#if DEACTIVATE_SERVOS_AFTER_MOVE\n\t\tthis->detach();\n\t\t#endif\n\t}\n}\n", "CodeBleu_score": 28.518400185022774}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample()\tuint32_t port_data = 0;\n\tuint32_t i;\n\tfor (i = 0; i < I2S_NUM_PINS; i++) {\n\t\tif (i2s_pin[i].duty_count == 0) {\n\t\t\ti2s_pin[i].state =!i2s_pin[i].state;\n\t\t\ti2s_pin[i].duty_count = i2s_pin[i].duty;\n\t\t}\n\t\ti2s_pin[i].duty_count--;\n\t\tif (i2s_pin[i].state) {\n\t\t\tport_data |= i2s_pin[i].pin_mask;\n\t\t}\n\t}\n\ti2s_dma_buffer[i2s_dma_buffer_pos] = port_data;\n\ti2s_dma_buffer_pos++;\n\tif (i2s_dma_buffer_pos >= I2S_DMA_BUFFER_LEN) {\n\t\ti2s_dma_buffer_pos = 0;\n\t}\n}\n", "CodeBleu_score": 25.79041888137499}, {"code": "void i2s_push_sample()\tuint8_t *p = (uint8_t *)dma_buffer;\n\tuint8_t *end = p + DMA_BUFFER_SIZE;\n\tuint32_t port_data = 0;\n\tfor (int i = 0; i < NUM_PINS; i++) {\n\t\tif (pin_data[i].duty_cycle) {\n\t\t\tif (pin_data[i].tick_count == 0) {\n\t\t\t\tpin_data[i].state =!pin_data[i].state;\n\t\t\t\tpin_data[i].tick_count = pin_data[i].duty_cycle;\n\t\t\t} else {\n\t\t\t\tpin_data[i].tick_count--;\n\t\t\t}\n\t\t\tport_data |= pin_data[i].state << pin_data[i].gpio_bit;\n\t\t}\n\t}\n\t*p++ = port_data;\n\tif (p >= end) {\n\t\tp = (uint8_t *)dma_buffer;\n\t}\n\tdma_buffer_position = p;\n}\n", "CodeBleu_score": 23.835965924519424}, {"code": "void i2s_push_sample()\tuint32_t i, j, k, data;\n\tuint32_t *buffer = (uint32_t *)i2s_tx_buffer;\n\tuint32_t *buffer_end = (uint32_t *)i2s_tx_buffer + I2S_DMA_BUFFER_SIZE / 4;\n\n\tfor (i = 0; i < I2S_NUM_PINS; i++) {\n\t\tif (i2s_pin_duty[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2s_pin_tick[i] == 0) {\n\t\t\ti2s_pin_tick[i] = i2s_pin_duty[i];\n\t\t\ti2s_pin_state[i] =!i2s_pin_state[i];\n\t\t}\n\t\ti2s_pin_tick[i]--;\n\t}\n\n\tdata = 0;\n\tfor (i = 0; i < I2S_NUM_PINS; i++) {\n\t\tif (i2s_pin_state[i]) {\n\t\t\tdata |= (1 << i);\n\t\t}\n\t}\n\n\tif (buffer < buffer_end) {\n\t\t*buffer++ = data;\n\t}\n}\n", "CodeBleu_score": 30.233475068278565}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\thal_timer_t timer = (hal_timer_t) timer_num;\n\n\tswitch (timer) {\n\tcase HAL_TIMER_0:\n\t\treturn TIMER0->TCNT;\n\tcase HAL_TIMER_1:\n\t\treturn TIMER1->TCNT;\n\tcase HAL_TIMER_2:\n\t\treturn TIMER2->TCNT;\n\tcase HAL_TIMER_3:\n\t\treturn TIMER3->TCNT;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n", "CodeBleu_score": 26.97297679233178}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\tif (timer_num >= NUM_OF_TIMERS) {\n\t\treturn 0;\n\t}\n\treturn timer_list[timer_num].count;\n}\n", "CodeBleu_score": 19.450612929334127}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\tuint32_t count = 0;\n\tif (timer_num < NUM_TIMERS) {\n\t\tcount = timer_config[timer_num].timer->CNT;\n\t}\n\treturn count;\n}\n", "CodeBleu_score": 34.46958068343454}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tfor (size_t i = 0; i < size; i++) {\n\t\tif (pos >= EEPROM_SIZE) {\n\t\t\treturn false;\n\t\t}\n\t\tvalue[i] = EEPROM.read(pos++);\n\t\tif (writing) {\n\t\t\tupdate_crc(crc, value[i]);\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 55.250229576414014}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\n\tfor (int i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos + i);\n\t\tif (writing) {\n\t\t\t*crc = crc16_update(*crc, value[i]);\n\t\t}\n\t}\n\tpos += size;\n\treturn true;\n}\n", "CodeBleu_score": 59.35666863553175}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t byte = read_byte(pos);\n\t\tif (crc!= nullptr) {\n\t\t\tupdate_crc(byte, crc);\n\t\t}\n\t\tif (writing) {\n\t\t\tvalue[i] = byte;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 58.65459724409171}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (sdio_handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\t// Try to write the block, retrying up to a defined number of times if the write operation fails\n\tfor (int i = 0; i < SDIO_WRITE_RETRY_COUNT; i++) {\n\t\tif (HAL_SD_WriteBlocks(sdio_handle, (uint8_t *) src, block, 1, SDIO_BLOCK_SIZE) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// If all retries fail, print an error message and return false\n\tprintf(\"Error: Failed to write block %lu to SD card.\\n\", block);\n\treturn false;\n}\n", "CodeBleu_score": 34.63017180341497}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (hsdio == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\tHAL_SD_WriteBlocks(hsdio, (uint8_t*)src, block, 1, 1000);\n\tif (hsdio->ErrorCode!= HAL_SD_ERROR_NONE) {\n\t\tprintf(\"SDIO_WriteBlock: %s\\n\", SD_ErrorToString(hsdio->ErrorCode));\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 28.75770971038232}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (sdio_handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tif (HAL_SD_WriteBlocks_DMA(sdio_handle, (uint8_t*) src, block, 1) == HAL_OK) {\n\t\treturn true;\n\t}\n\n\tint retries = 0;\n\twhile (retries < 3) {\n\t\tif (HAL_SD_WriteBlocks_DMA(sdio_handle, (uint8_t*) src, block, 1) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t\tretries++;\n\t}\n\n\tprintf(\"SDIO_WriteBlock failed\\n\");\n\treturn false;\n}\n", "CodeBleu_score": 39.0064839707639}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\tuint32_t timer_clock;\n\tuint32_t timer_prescale;\n\tuint32_t timer_period;\n\tuint32_t timer_priority;\n\tuint32_t timer_irq;\n\tuint32_t timer_base;\n\tuint32_t timer_channel;\n\n\tswitch (timer_num) {\n\t\tcase TIMER_TEMP:\n\t\t\ttimer_clock = HAL_timer_get_clock(TIMER_TEMP);\n\t\t\ttimer_prescale = HAL_timer_get_prescale(TIMER_TEMP);\n\t\t\ttimer_period = HAL_timer_get_period(TIMER_TEMP, frequency);\n\t\t\ttimer_priority = HAL_timer_get_priority(TIMER_TEMP);\n\t\t\ttimer_irq = HAL_timer_get_irq(TIMER_TEMP);\n\t\t\ttimer_base = HAL_timer_get_base(TIMER_TEMP);\n\t\t\ttimer_channel = HAL_timer_get_channel(TIMER_TEMP);\n\t\t\tbreak;\n\t\tcase TIMER_STEP:\n\t\t\ttimer_clock = HAL_timer_get_clock(TIMER_STEP);\n\t\t\ttimer_prescale = HAL_timer_get_prescale(TIMER_STEP);\n\t\t\ttimer_period = HAL_timer_get_period(TIMER_STEP, frequency);\n\t\t\ttimer_priority = HAL_timer_get_priority(TIMER_STEP);\n\t\t\ttimer_irq = HAL_timer_get_irq(TIMER_STEP);\n\t\t\ttimer_base = HAL_timer_get_base(TIMER_STEP);\n\t\t\ttimer_channel = HAL_timer_get_channel(TIMER_STEP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert_param(0);\n\t\t\tbreak;\n\t}\n\n\t// Stop timer\n\tHAL_timer_stop(timer_num);\n\n\t// Set timer clock\n\ttimer_clock /= 1000000;\n\ttimer_clock -= 1;\n\ttimer_clock &= 0x000000FF;\n\ttimer_clock |= 0x00007000;\n\ttimer_clock |= 0x00000C00;\n\ttimer_clock |= 0x00000300;\n\ttimer_clock |= ", "CodeBleu_score": 26.754114092469866}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\tASSERT(timer_num < TIMER_CHANNEL_COUNT);\n\tASSERT(frequency > 0);\n\n\t// Set the timer prescale\n\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\t// Set the temperature timer prescale\n\t\tHAL_timer_set_prescale(TIMER_CHANNEL_TEMPERATURE, HAL_timer_get_prescale_for_frequency(TIMER_CHANNEL_TEMPERATURE, frequency));\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\t// Set the stepper timer prescale\n\t\tHAL_timer_set_prescale(TIMER_CHANNEL_STEPPER, HAL_timer_get_prescale_for_frequency(TIMER_CHANNEL_STEPPER, frequency));\n\t}\n\n\t// Start the timer\n\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\t// Start the temperature timer\n\t\tHAL_timer_start_temperature();\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\t// Start the stepper timer\n\t\tHAL_timer_start_stepper();\n\t}\n}\n", "CodeBleu_score": 42.96228272291916}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\tif (timer_num == TIMER_CHANNEL_TEMP) {\n\t\tHAL_timer_start_temp(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_STEP) {\n\t\tHAL_timer_start_step(frequency);\n\t} else {\n\t\tASSERT(false);\n\t}\n}\n", "CodeBleu_score": 24.305230718056325}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start()\t// open file\n\tEEPROM_file = fopen(EEPROM_file_name, \"r+b\");\n\n\t// if file does not exist or cannot be opened, return false\n\tif (EEPROM_file == NULL) {\n\t\treturn false;\n\t}\n\n\t// get file size\n\tfseek(EEPROM_file, 0, SEEK_END);\n\tint file_size = ftell(EEPROM_file);\n\n\t// if file is smaller than expected EEPROM size, fill remainder of buffer with default erase value\n\tif (file_size < EEPROM_size) {\n\t\tfor (int i = file_size; i < EEPROM_size; i++) {\n\t\t\tEEPROM_buffer[i] = EEPROM_default_erase_value;\n\t\t}\n\t}\n\n\t// read file contents into buffer\n\tfseek(EEPROM_file, 0, SEEK_SET);\n\tfread(EEPROM_buffer, 1, EEPROM_size, EEPROM_file);\n\n\t// close file\n\tfclose(EEPROM_file);\n\n\t// return true\n\treturn true;\n}\n", "CodeBleu_score": 40.31757175960961}, {"code": "bool PersistentStore::access_start()\t// Open EEPROM file\n\tif (eeprom_file.open(EEPROM_FILE_NAME, O_RDWR | O_CREAT)!= 0) {\n\t\treturn false;\n\t}\n\n\t// Get file size\n\toff_t file_size = eeprom_file.size();\n\tif (file_size < 0) {\n\t\treturn false;\n\t}\n\n\t// Check file size\n\tif (file_size < EEPROM_SIZE) {\n\t\t// Fill remainder of buffer with default erase value\n\t\tmemset(&buffer[file_size], EEPROM_DEFAULT_ERASE_VALUE, EEPROM_SIZE - file_size);\n\t}\n\n\t// Read file contents into buffer\n\tif (eeprom_file.read(buffer, EEPROM_SIZE) < 0) {\n\t\treturn false;\n\t}\n\n\t// Close file\n\teeprom_file.close();\n\n\treturn true;\n}\n", "CodeBleu_score": 29.662989005371976}, {"code": "bool PersistentStore::access_start()\t// Open EEPROM file\n\tif (file.open(EEPROM_FILENAME, O_RDWR) < 0) {\n\t\t// File does not exist or cannot be opened\n\t\treturn false;\n\t}\n\n\t// Check file size\n\tif (file.size() < EEPROM_SIZE) {\n\t\t// File is smaller than expected EEPROM size\n\t\t// Fill remainder of buffer with default erase value\n\t\tmemset(buffer + file.size(), EEPROM_ERASE_VALUE, EEPROM_SIZE - file.size());\n\t}\n\n\t// Read file contents into buffer\n\tfile.read(buffer, EEPROM_SIZE);\n\n\t// Close file\n\tfile.close();\n\n\treturn true;\n}\n", "CodeBleu_score": 17.27513467654414}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i, ret = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n\t\t}\n\t\tb <<= 1;\n\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\t\tret <<= 1;\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN)) {\n\t\t\tret |= 0x01;\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\t}\n\n\tHAL_Delay(1);\n\treturn ret;\n}\n", "CodeBleu_score": 37.98441977663104}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i;\n\tuint8_t r = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tr <<= 1;\n\t\tr |= HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin);\n\t\tb <<= 1;\n\t\tHAL_Delay(1);\n\t}\n\treturn r;\n}\n", "CodeBleu_score": 38.80759916298192}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i;\n\tuint8_t rx = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\trx = rx << 1;\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin))\n\t\t\trx |= 0x01;\n\t\tb = b << 1;\n\t}\n\tHAL_Delay(1);\n\treturn rx;\n}\n", "CodeBleu_score": 39.350370909230506}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 73.71358658894387}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 73.71358658894387}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 73.71358658894387}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)\tif (obj->index == 0) {\n\t\tobj->head = 0;\n\t\tobj->tail = 0;\n\t}\n\n\tif (obj->index < RX_BUFFER_SIZE) {\n\t\tobj->buffer[obj->head] = obj->rx_buffer;\n\t\tobj->head = (obj->head + 1) % RX_BUFFER_SIZE;\n\t\tobj->index++;\n\t}\n\n\tif (obj->index == RX_BUFFER_SIZE) {\n\t\tobj->overflow = true;\n\t}\n}\n", "CodeBleu_score": 33.466039384899325}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)#if defined(ARDUINO_ARCH_SAM) || defined(ARDUINO_ARCH_SAMD)\n  if (obj->serial.USART->STATUS.bit.PERR) {\n    obj->serial.USART->STATUS.reg = SERCOM_USART_INT_STATUS_PERR;\n  } else {\n    if (obj->serial.USART->INTFLAG.bit.RXC) {\n      uint8_t c = obj->serial.USART->DATA.reg;\n      if (obj->serial.USART->INTFLAG.bit.ERROR) {\n        if (obj->serial.USART->STATUS.bit.FERR) {\n          obj->serial.USART->INTFLAG.bit.ERROR = 1;\n          obj->serial.USART->STATUS.reg = SERCOM_USART_INT_STATUS_FERR;\n          c = 0;\n        } else if (obj->serial.USART->STATUS.bit.BUFOVF) {\n          obj->serial.USART->INTFLAG.bit.ERROR = 1;\n          obj->serial.USART->STATUS.reg = SERCOM_USART_INT_STATUS_BUFOVF;\n          c = 0;\n        }\n      }\n      uint8_t i = (uint8_t)(obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n      if (i!= obj->rx_buffer_tail) {\n        obj->rx_buffer[obj->rx_buffer_head] = c;\n        obj->rx_buffer_head = i;\n      }\n      if (obj->rx_buffer_head == obj->rx_buffer_tail) {\n        obj->rx_buffer_overflow = 1;\n      }\n      if (obj->rx_callback) {\n        obj->rx_callback(obj);\n      }\n    }\n  }", "CodeBleu_score": 45.4593873108405}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)\t// If we are not using the emergency parser, we can ignore the parity error.\n\tif (obj->emergency_parser == NULL) {\n\t\tif (obj->parity_error) {\n\t\t\tobj->parity_error = false;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Read the received byte.\n\tuint8_t byte = obj->serial->read();\n\n\t// If we are using the emergency parser, we need to pass the byte to it.\n\tif (obj->emergency_parser!= NULL) {\n\t\tobj->emergency_parser->process_char(byte);\n\t\treturn;\n\t}\n\n\t// If the receive buffer is full, we need to discard the received byte.\n\tif (obj->rx_buffer_head == obj->rx_buffer_tail) {\n\t\treturn;\n\t}\n\n\t// Store the received byte in the receive buffer.\n\tobj->rx_buffer[obj->rx_buffer_head] = byte;\n\n\t// Update the receive buffer head pointer.\n\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n}\n", "CodeBleu_score": 38.44706613589361}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (timer_step.initialized &&!timer_step.interrupt_attached) {\n\t\t\ttimer_step.interrupt_attached = true;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (timer_temp.initialized &&!timer_temp.interrupt_attached) {\n\t\t\ttimer_temp.interrupt_attached = true;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.4040862229066}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tswitch (timer_num) {\n\tcase MF_TIMER_STEP:\n\t\tif (timer_step_initialized &&!timer_step_has_interrupt) {\n\t\t\ttimer_step_has_interrupt = 1;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t\tbreak;\n\tcase MF_TIMER_TEMP:\n\t\tif (timer_temp_initialized &&!timer_temp_has_interrupt) {\n\t\t\ttimer_temp_has_interrupt = 1;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n", "CodeBleu_score": 38.41313953795093}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.06327589924418}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\n\t// Rabin-Karp search\n\thsep := hashStr(sep)\n\th := hashStr(s[n-m:])\n\tif h == hsep && equalStr(s[n-m:], sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th = rollHash(h, s[i+m], s[i])\n\t\tif h == hsep && equalStr(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 42.13595383609444}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\thashsep, pow := hashStr(sep)\n\th := hashStr(s[n-m:])\n\tif h == hashsep && equalStr(s[n-m:], sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th *= primeRK\n\t\th += int(s[i])\n\t\th -= int(s[i+m]) * pow\n\t\tif h == hashsep && equalStr(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 47.524808023054476}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn 0\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\thsep := hash(sep)\n\th := hash(s[n-m:])\n\tif h == hsep && equal(s[n-m:], sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th *= primeRK\n\t\th += int(s[i])\n\t\th -= int(s[i+m]) * hm\n\t\tif h == hsep && equal(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 46.6736792919224}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush()\t// Disable interrupts\n\tmask := atomic.LoadInt32(&usbcdc.irqMask)\n\tatomic.StoreInt32(&usbcdc.irqMask, 0)\n\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txc.Len() > 0 {\n\t\t// Send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data available, so set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore the interrupt mask\n\tatomic.StoreInt32(&usbcdc.irqMask, mask)\n}\n", "CodeBleu_score": 53.47999510298408}, {"code": "func (usbcdc *USBCDC) Flush()\t// Disable interrupts\n\tirqmask := DisableInterrupts()\n\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txc.Len() > 0 {\n\t\t// Send data to the USB endpoint\n\t\tSendUSBInPacket(usbcdc.txc.Bytes(), usbcdc.epnum)\n\n\t\t// Clear the transmit buffer\n\t\tusbcdc.txc.Reset()\n\t} else {\n\t\t// No data available, set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore interrupt mask\n\tRestoreInterrupts(irqmask)\n}\n", "CodeBleu_score": 40.862792937936085}, {"code": "func (usbcdc *USBCDC) Flush()\t// Disable interrupts\n\tinterrupts := intc.GetEnabledInterrupts()\n\tintc.DisableInterrupts()\n\n\t// If there is data in the transmit buffer, send it to the USB endpoint\n\tif len(usbcdc.txBuffer) > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// If there is no data, set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore the interrupt mask\n\tintc.SetEnabledInterrupts(interrupts)\n}\n", "CodeBleu_score": 42.53332002909346}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool)\t// Set the interrupt flag to clear it\n\ti2c.reg.IF.Set(0)\n\t// Set the start flag to send a start condition\n\ti2c.reg.CMD.SetBits(i2c.reg.CMD.Start())\n\t// Enable the I2C module\n\ti2c.reg.ENABLE.Set(1)\n\t// Wait for the start condition to be transmitted\n\tfor i2c.reg.IF.HasBits(i2c.reg.IF.Start()) == 0 {\n\t}\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed\n\ti2c.reg.TXDATA.Set(uint32(address<<1) | uint32(!write))\n\t// Send the address\n\ti2c.reg.CMD.SetBits(i2c.reg.CMD.Start())\n\t// Wait for the address to be sent\n\tfor i2c.reg.IF.HasBits(i2c.reg.IF.ACK()) == 0 {\n\t}\n}\n", "CodeBleu_score": 32.24937358510076}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.I2C_CR1.SetBits(i2c.I2C_CR1.Bits() & ^i2c.I2C_CR1.Mask | i2c.I2C_CR1.Bits()&i2c.I2C_CR1.Mask)\n\ti2c.I2C_CR2.SetBits(i2c.I2C_CR2.Bits() & ^i2c.I2C_CR2.Mask | i2c.I2C_CR2.Bits()&i2c.I2C_CR2.Mask)\n\ti2c.I2C_CR1.SetBits(i2c.I2C_CR1.Bits() & ^i2c.I2C_CR1.Mask | i2c.I2C_CR1.Bits()&i2c.I2C_CR1.Mask)\n\tfor i2c.I2C_SR1.Load()&i2c.I2C_SR1.Mask == 0 {\n\t}\n\ti2c.I2C_DR.SetBits(i2c.I2C_DR.Bits() & ^i2c.I2C_DR.Mask | i2c.I2C_DR.Bits()&i2c.I2C_DR.Mask)\n\ti2c.I2C_CR1.SetBits(i2c.I2C_CR1.Bits() & ^i2c.I2C_CR1.Mask | i2c.I2C_CR1.Bits()&i2c.I2C_CR1.Mask)\n\tfor i2c.I2C_SR1.Load()&i2c.I2C_SR1.Mask == 0 {\n\t}\n\ti2c.I2C_DR.SetBits(i2c.I2C_DR.Bits() & ^i2c.I2C_DR.Mask | i2c.I2C_DR.Bits()&i2c.I2C_DR.Mask)\n\ti2c.I2C_CR1.SetBits(i2c.I2C_CR", "CodeBleu_score": 29.665312448857094}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.reg.C1 |= 1\n\ti2c.reg.C1 |= 0x80\n\tfor i2c.reg.S & 0x01 == 0 {\n\t}\n\ti2c.reg.D = (address << 1) | (1 - uint8(write))\n\tfor i2c.reg.S & 0x01 == 0 {\n\t}\n}\n", "CodeBleu_score": 28.972953201608952}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\t// Calculate the start address based on the block number and block size\n\tstartAddress := int(start) * f.blockSize\n\n\t// Wait for any ongoing flash operations to complete\n\tf.flash.WaitUntilReady()\n\n\t// Configure flash for erasing\n\tf.flash.SetMode(driver.FlashModeErase)\n\n\t// Erase each block\n\tfor i := int64(0); i < len; i++ {\n\t\t// Calculate the block address\n\t\tblockAddress := startAddress + int(i)*f.blockSize\n\n\t\t// Erase the block\n\t\tf.flash.EraseBlock(blockAddress)\n\n\t\t// Wait until the flash is no longer busy\n\t\tf.flash.WaitUntilReady()\n\t}\n\n\t// Set flash back to read mode\n\tf.flash.SetMode(driver.FlashModeRead)\n\n\treturn nil\n}\n", "CodeBleu_score": 41.09076511582484}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\t// Calculate the start address based on the block number and block size\n\tstartAddress := start * f.blockSize\n\n\t// Wait for any ongoing flash operations to complete\n\tf.flash.Wait()\n\n\t// Configure the flash for erasing\n\tf.flash.Configure(driver.FlashConfig{\n\t\tMode:        driver.FlashErase,\n\t\tSectorSize:  f.blockSize,\n\t\tSectorCount: 1,\n\t})\n\n\t// Erase each block\n\tfor i := int64(0); i < len; i++ {\n\t\t// Calculate the address of the current block\n\t\taddress := startAddress + i*f.blockSize\n\n\t\t// Erase the block\n\t\tf.flash.Erase(address)\n\n\t\t// Wait until the flash is no longer busy\n\t\tf.flash.Wait()\n\t}\n\n\t// Set the flash back to read mode\n\tf.flash.Configure(driver.FlashConfig{\n\t\tMode: driver.FlashRead,\n\t})\n\n\t// Return nil indicating successful completion\n\treturn nil\n}\n", "CodeBleu_score": 34.53782482172096}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tif start < 0 {\n\t\treturn errors.New(\"flashBlockDevice.EraseBlocks: start < 0\")\n\t}\n\tif len <= 0 {\n\t\treturn errors.New(\"flashBlockDevice.EraseBlocks: len <= 0\")\n\t}\n\tif start+len > f.numBlocks {\n\t\treturn errors.New(\"flashBlockDevice.EraseBlocks: start+len > numBlocks\")\n\t}\n\n\tstartAddress := start * f.blockSize\n\tendAddress := startAddress + len*f.blockSize - 1\n\n\t// Wait for any ongoing flash operations to complete\n\tf.waitUntilReady()\n\n\t// Configure flash for erasing\n\tf.flash.WriteRegister(flash.CR, flash.CR_PER)\n\tf.flash.WriteRegister(flash.AR, uint32(startAddress))\n\tf.flash.WriteRegister(flash.CR, flash.CR_STRT|flash.CR_PER)\n\n\t// Erase each block\n\tfor address := startAddress; address <= endAddress; address += f.blockSize {\n\t\t// Wait until the flash is no longer busy\n\t\tf.waitUntilReady()\n\n\t\t// Erase the block\n\t\tf.flash.WriteRegister(flash.CR, flash.CR_PER)\n\t\tf.flash.WriteRegister(flash.AR, uint32(address))\n\t\tf.flash.WriteRegister(flash.CR, flash.CR_STRT|flash.CR_PER)\n\t}\n\n\t// Set the flash back to read mode\n\tf.flash.WriteRegister(flash.CR, 0)\n\n\treturn nil\n}\n", "CodeBleu_score": 38.263492676437075}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"write exceeds flash bounds\")\n\t}\n\tstart := int(off % int64(f.writeBlockSize))\n\tp = append(make([]byte, start), p...)\n\tp = append(p, make([]byte, f.writeBlockSize-len(p)%f.writeBlockSize)...)\n\tf.flash.EnableWrite()\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\tif err := f.flash.WriteBlock(p[i:i+f.writeBlockSize], int(off)+i); err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif err := f.flash.WaitReady(); err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 34.15740645612754}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 {\n\t\treturn 0, errors.New(\"invalid offset\")\n\t}\n\tif int64(len(p)) > f.Size()-off {\n\t\treturn 0, errors.New(\"write exceeds flash bounds\")\n\t}\n\n\tstart := uint32(off)\n\tp = pad(p, f.writeBlockSize)\n\tf.flash.EnableWrite()\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\tf.flash.Write(start, p[i:i+f.writeBlockSize])\n\t\tstart += uint32(f.writeBlockSize)\n\t\tf.flash.WaitForReady()\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 28.913721708874473}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 || off > int64(f.size) {\n\t\treturn 0, errors.New(\"WriteAt: offset out of bounds\")\n\t}\n\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, errors.New(\"WriteAt: write exceeds flash memory bounds\")\n\t}\n\tstartAddr := uint32(off)\n\tp = pad(p, f.writeBlockSize)\n\tf.flashCtrl.EnableWrite()\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\tf.flashCtrl.Write(startAddr, p[i:i+f.writeBlockSize])\n\t\tstartAddr += uint32(f.writeBlockSize)\n\t\tif!f.flashCtrl.IsReady() {\n\t\t\treturn i, errors.New(\"WriteAt: flash memory not ready\")\n\t\t}\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 32.39218688420408}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tdirfd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdirp, err := syscall.Fdopendir(dirfd)\n\t\tif err == nil {\n\t\t\treturn dirp, \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\t_ = syscall.Close(dirfd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}\n", "CodeBleu_score": 55.878247403476465}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tr0, _, e1 := syscall.Syscall(syscall.SYS_DUP, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\treturn 0, \"\", syscall.Errno(e1)\n\t}\n\tfd = syscallFd(r0)\n\tfor {\n\t\tr0, _, e1 := syscall.Syscall(syscall.SYS_FDATASYNC, uintptr(fd), 0, 0)\n\t\tif e1 == 0 {\n\t\t\treturn r0, \"\", nil\n\t\t}\n\t\tif e1!= syscall.EINTR {\n\t\t\tsyscall.Close(fd)\n\t\t\treturn 0, \"\", syscall.Errno(e1)\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.640481655387326}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tr0, _, e1 := syscall.Syscall(syscall.SYS_DUP, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\treturn 0, \"\", fmt.Errorf(\"dup: %w\", e1)\n\t}\n\tfd = syscallFd(r0)\n\tfor {\n\t\tr0, _, e1 := syscall.Syscall(syscall.SYS_FDATASYNC, uintptr(fd), 0, 0)\n\t\tif e1 == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif e1!= syscall.EINTR {\n\t\t\tsyscall.Close(int(fd))\n\t\t\treturn 0, \"\", fmt.Errorf(\"fdatasync: %w\", e1)\n\t\t}\n\t}\n\tr0, _, e1 := syscall.Syscall(syscall.SYS_FDATASYNC, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\tsyscall.Close(int(fd))\n\t\treturn 0, \"\", fmt.Errorf(\"fdatasync: %w\", e1)\n\t}\n\tr0, _, e1 = syscall.Syscall(syscall.SYS_FDATASYNC, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\tsyscall.Close(int(fd))\n\t\treturn 0, \"\", fmt.Errorf(\"fdatasync: %w\", e1)\n\t}\n\tr0, _, e1 = syscall.Syscall(syscall.SYS_FDATASYNC, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\tsyscall.Close(int(fd))\n\t\treturn 0, \"\", fmt.Errorf(\"fdatasync: %w\", e1)\n\t}\n\tr0, _, e1 = syscall.Syscall(syscall.SYS_FDATASYNC, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\tsyscall.Close(int(fd))\n\t\treturn 0, \"\", fmt.Errorf(\"fdatasync: %w\", e1)\n\t}\n\tr0, _, e1 = syscall.Syscall(syscall.SYS_FDATASYNC, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\t", "CodeBleu_score": 36.49609429243878}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response)\tesp_app_desc_t app_desc;\n\tesp_image_metadata_t metadata;\n\tesp_image_verify_bootloader_data();\n\tesp_image_verify_data(ESP_IMAGE_VERIFY, &metadata);\n\tesp_app_get_description(&app_desc);\n\tif (response) {\n\t\treturn app_desc.image_len - metadata.image_len;\n\t}\n\treturn metadata.image_len;\n}\n", "CodeBleu_score": 35.006450177613466}, {"code": "static uint32_t sketchSize(sketchSize_t response)\tesp_app_desc_t app_desc;\n\tesp_app_get_description(&app_desc);\n\tif (response == FREE_SPACE) {\n\t\treturn (app_desc.flash_size - app_desc.image_len);\n\t} else {\n\t\treturn app_desc.image_len;\n\t}\n}\n", "CodeBleu_score": 25.741136216542593}, {"code": "static uint32_t sketchSize(sketchSize_t response)\tesp_app_desc_t app_desc;\n\tesp_image_metadata_t metadata;\n\tesp_image_get_metadata(ESP_IMAGE_FLASH_SIZE, 0, &metadata);\n\tesp_app_get_description(&app_desc);\n\tif (response) {\n\t\treturn app_desc.image_len;\n\t} else {\n\t\treturn metadata.image_len;\n\t}\n}\n", "CodeBleu_score": 31.761361194333247}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\t// Calculate the number of sectors needed for the disk\n\tuint32_t sectors_per_cluster = 1;\n\tuint32_t sectors_per_fat = 2;\n\tuint32_t root_directory_entries = 1;\n\tuint32_t total_sectors = 128;\n\tuint32_t reserved_sectors = 1;\n\tuint32_t sectors_per_track = 1;\n\tuint32_t number_of_heads = 1;\n\tuint32_t hidden_sectors = 0;\n\tuint32_t bytes_per_sector = 512;\n\tuint32_t sectors_per_fat32 = 0;\n\tuint32_t sectors_per_fat16 = 0;\n\n\t// Calculate the number of sectors needed for the disk\n\tuint32_t sectors_per_fat_table = sectors_per_fat * 9;\n\tuint32_t root_directory_sectors = ((root_directory_entries * 32) + (bytes_per_sector - 1)) / bytes_per_sector;\n\tuint32_t total_sectors_for_clusters = total_sectors - (reserved_sectors + sectors_per_fat_table + root_directory_sectors);\n\tuint32_t total_clusters = total_sectors_for_clusters / sectors_per_cluster;\n\n\t// Calculate the number of sectors needed for the disk\n\tif (total_clusters < 4085) {\n\t\tsectors_per_fat16 = total_sectors_for_clusters + 2;\n\t\tsectors_per_fat32 = 0;\n\t} else {\n\t\tsectors_per_fat16 = 0;\n\t\tsectors_per_fat32 = ((total_clusters * 4) + (bytes_per_sector - 1)) / bytes_per_sector;\n\t}\n\n\t// Allocate memory for the disk sectors\n\tuint8_t *disk_sectors = (uint8_t *)malloc(total_sectors * bytes_per", "CodeBleu_score": 36.79147763603762}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\tuint32_t sectors_per_cluster;\n\tuint32_t sectors_per_fat;\n\tuint32_t sectors_per_root_dir;\n\tuint32_t total_sectors;\n\tuint32_t total_clusters;\n\tuint32_t root_dir_sectors;\n\tuint32_t data_sectors;\n\tuint32_t fat_sectors;\n\tuint32_t first_data_sector;\n\tuint32_t first_fat_sector;\n\tuint32_t first_root_dir_sector;\n\tuint32_t bytes_per_sector;\n\tuint32_t sectors_per_track;\n\tuint32_t number_of_heads;\n\tuint32_t bytes_per_cluster;\n\tuint32_t bytes_per_root_dir;\n\tuint32_t bytes_per_fat;\n\tuint32_t fat_size;\n\tuint32_t fat_offset;\n\tuint32_t root_dir_offset;\n\tuint32_t data_offset;\n\tuint32_t cluster_offset;\n\tuint32_t cluster_size;\n\tuint32_t root_dir_size;\n\tuint32_t root_dir_cluster;\n\tuint32_t root_dir_sector;\n\tuint32_t root_dir_sector_offset;\n\tuint32_t root_dir_entry;\n\tuint32_t root_dir_entry_offset;\n\tuint32_t root_dir_entry_size;\n\tuint32_t root_dir_entry_cluster;\n\tuint32_t root_dir_entry_cluster_offset;\n\tuint32_t root_dir_entry_cluster_size;\n\tuint32_t root_dir_entry_cluster_sector;\n\tuint32_t root_dir_entry_cluster_sector_offset;\n\tuint32_t root_dir_entry_cluster_sector_size;\n\tuint32_t root_dir_entry_cluster_sector_", "CodeBleu_score": 7.94382903573653}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\t// Calculate the number of sectors required for the RAM disk\n\tuint32_t disk_sectors = 0;\n\tif (msc_update_firmware_size) {\n\t\tdisk_sectors = msc_update_firmware_size / MSC_UPDATE_SECTOR_SIZE;\n\t\tif (msc_update_firmware_size % MSC_UPDATE_SECTOR_SIZE) {\n\t\t\tdisk_sectors++;\n\t\t}\n\t}\n\tdisk_sectors += MSC_UPDATE_SECTORS_PER_FAT * MSC_UPDATE_FAT_COUNT;\n\tdisk_sectors += MSC_UPDATE_SECTORS_PER_BOOT;\n\tdisk_sectors += MSC_UPDATE_SECTORS_PER_ROOT;\n\n\t// Allocate memory for the RAM disk\n\tmsc_update_disk = (uint8_t *)malloc(disk_sectors * MSC_UPDATE_SECTOR_SIZE);\n\tif (msc_update_disk == NULL) {\n\t\tMSC_UPDATE_LOG_ERROR(\"Unable to allocate memory for RAM disk\");\n\t\treturn false;\n\t}\n\n\t// Set up the boot sector\n\tmemset(msc_update_disk, 0, MSC_UPDATE_SECTOR_SIZE);\n\tmsc_update_disk[0] = 0xEB;\n\tmsc_update_disk[1] = 0x3C;\n\tmsc_update_disk[2] = 0x90;\n\tmemcpy(&msc_update_disk[3], \"MSDOS5.0\", 8);\n\tmsc_update_disk[11] = 0x02;\n\tmsc_update_disk[13] = MSC_UPDATE_SECTORS_PER_FAT;\n\tmsc_update_disk[14] = 0x02;\n\tmsc_update_disk[16] = 0x02;\n\tmsc_update_disk[17] = 0x00;\n\tmsc_update_disk[18] = 0x02;\n\tmsc_update_disk[19] = 0x00;\n\tmsc_update_disk[21] = 0x00;\n\tmsc_update_disk[22]", "CodeBleu_score": 23.739660749089627}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tESP_LOGD(TAG, \"update write: partition=%p offset=0x%x data=%p size=%d\", partition, offset, data, size);\n\n\t// check if the offset is aligned with the flash sector size\n\tif (offset % ESP_PARTITION_ALIGN!= 0) {\n\t\tESP_LOGE(TAG, \"offset 0x%x is not aligned with the flash sector size\", offset);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\t// erase the sector containing the offset\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"failed to erase the sector containing offset 0x%x\", offset);\n\t\treturn err;\n\t}\n\n\t// write the data to the specified offset\n\treturn esp_partition_write(partition, offset, data, size);\n}\n", "CodeBleu_score": 50.90721261807377}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tESP_LOGD(TAG, \"msc_update_write: offset 0x%x, size %d\", offset, size);\n\n\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"msc_update_write: offset 0x%x is not aligned with sector size %d\", offset, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (size % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"msc_update_write: size %d is not aligned with sector size %d\", size, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"msc_update_write: esp_partition_erase_range failed with error 0x%x\", err);\n\t\treturn err;\n\t}\n\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"msc_update_write: esp_partition_write failed with error 0x%x\", err);\n\t\treturn err;\n\t}\n\n\treturn ESP_OK;\n}\n", "CodeBleu_score": 48.45930869437759}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tuint32_t sector_size = partition->erase_size;\n\tuint32_t sector_index = offset / sector_size;\n\tuint32_t sector_offset = offset % sector_size;\n\tuint32_t sector_address = sector_index * sector_size;\n\tuint32_t sector_end_address = sector_address + sector_size;\n\n\tif (sector_offset!= 0) {\n\t\tESP_LOGW(TAG, \"Offset %u is not aligned with sector size %u\", offset, sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tesp_err_t err = esp_partition_erase_range(partition, sector_address, sector_size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector at offset %u (0x%08x): %s\", sector_address, sector_address, esp_err_to_name(err));\n\t\treturn err;\n\t}\n\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write data at offset %u (0x%08x): %s\", offset, offset, esp_err_to_name(err));\n\t\treturn err;\n\t}\n\n\treturn ESP_OK;\n}\n", "CodeBleu_score": 46.912460709570865}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i, j;\n\tfor (i = j = 0; i < maxlen && in[i]; i++) {\n\t\tint c = in[i];\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tc -= '0';\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tc -= 'a' - 10;\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tc -= 'A' - 10;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i & 1) {\n\t\t\tout[j++] |= c;\n\t\t} else {\n\t\t\tout[j] = c << 4;\n\t\t}\n\t}\n\treturn j;\n}\n", "CodeBleu_score": 45.19075850016301}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i, j;\n\tfor (i = 0, j = 0; j < maxlen && in[i]; i++) {\n\t\tint c = in[i];\n\t\tif (c >= '0' && c <= '9')\n\t\t\tc -= '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tc -= 'a' - 10;\n\t\telse if (c >= 'A' && c <= 'F')\n\t\t\tc -= 'A' - 10;\n\t\telse\n\t\t\tcontinue;\n\t\tif (i % 2 == 0)\n\t\t\tout[j] = c << 4;\n\t\telse\n\t\t\tout[j++] |= c;\n\t}\n\treturn j;\n}\n", "CodeBleu_score": 38.82645463503902}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i = 0;\n\twhile (*in && i < maxlen) {\n\t\tunsigned char c = 0;\n\t\tif (*in >= '0' && *in <= '9') {\n\t\t\tc = *in - '0';\n\t\t} else if (*in >= 'a' && *in <= 'f') {\n\t\t\tc = *in - 'a' + 10;\n\t\t} else if (*in >= 'A' && *in <= 'F') {\n\t\t\tc = *in - 'A' + 10;\n\t\t} else {\n\t\t\tin++;\n\t\t\tcontinue;\n\t\t}\n\t\tin++;\n\t\tif (*in >= '0' && *in <= '9') {\n\t\t\tc = (c << 4) + (*in - '0');\n\t\t} else if (*in >= 'a' && *in <= 'f') {\n\t\t\tc = (c << 4) + (*in - 'a' + 10);\n\t\t} else if (*in >= 'A' && *in <= 'F') {\n\t\t\tc = (c << 4) + (*in - 'A' + 10);\n\t\t} else {\n\t\t\tin++;\n\t\t\tcontinue;\n\t\t}\n\t\tin++;\n\t\tout[i] = c;\n\t\ti++;\n\t}\n\treturn i;\n}\n", "CodeBleu_score": 36.63441843465482}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void)\tif (txRingBuffer == NULL || txRingBufferLock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(txRingBufferLock, TX_RING_BUFFER_LOCK_TIMEOUT) == pdTRUE) {\n\t\tint free = txRingBuffer->availableForWrite();\n\t\txSemaphoreGive(txRingBufferLock);\n\t\treturn free;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 57.28157085468424}, {"code": "int HWCDC::availableForWrite(void)\tif (txRingBuffer == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(txRingBufferLock, (TickType_t) 10) == pdTRUE) {\n\t\tsize_t free = txRingBuffer->getFreeSize();\n\t\txSemaphoreGive(txRingBufferLock);\n\t\treturn free;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 53.74354838355517}, {"code": "int HWCDC::availableForWrite(void)\tif (!txRingBuffer ||!txLock) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(txLock, 1000) == pdTRUE) {\n\t\tint size = txRingBuffer->availableForWrite();\n\t\txSemaphoreGive(txLock);\n\t\treturn size;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 46.82040758322395}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\t_mutex.lock();\n\t_onReceiveCB = function;\n\tif (_onReceiveCB) {\n\t\t_rxTimeout = 10;\n\t\t_rxTimeoutOnly = onlyOnTimeout;\n\t\t_fifo.setFullThreshold(1);\n\t\tif (!_eventTask) {\n\t\t\t_eventTask = new EventTask(this, &HardwareSerial::eventTask);\n\t\t\t_eventTask->start(100);\n\t\t}\n\t} else {\n\t\t_rxTimeout = 0;\n\t\t_rxTimeoutOnly = false;\n\t\tif (_eventTask) {\n\t\t\t_eventTask->stop();\n\t\t\tdelete _eventTask;\n\t\t\t_eventTask = NULL;\n\t\t}\n\t}\n\t_mutex.unlock();\n}\n", "CodeBleu_score": 43.568693446274956}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\tmutex.lock();\n\t_onReceiveCB = function;\n\t_rxTimeout = onlyOnTimeout;\n\tif (_onReceiveCB) {\n\t\t_fifo.setFullThreshold(1);\n\t\tif (!_eventTask) {\n\t\t\t_eventTask = new EventTask(this);\n\t\t}\n\t} else {\n\t\tif (_eventTask) {\n\t\t\tdelete _eventTask;\n\t\t\t_eventTask = NULL;\n\t\t}\n\t}\n\tmutex.unlock();\n}\n", "CodeBleu_score": 40.47263149340026}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\n\tif (_onReceiveCB) {\n\t\t// Set FIFO full threshold to 1 byte\n\t\t_serial->setFifoThreshold(1);\n\n\t\tif (!_eventTask) {\n\t\t\t_eventTask = new SerialEventTask(this);\n\t\t}\n\t} else {\n\t\tif (_eventTask) {\n\t\t\tdelete _eventTask;\n\t\t\t_eventTask = nullptr;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.607078790465}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index++] = (char) c;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}\n", "CodeBleu_score": 72.65039527675106}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tindex++;\n\t}\n\treturn index;\n}\n", "CodeBleu_score": 79.26788400212831}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index++] = (char) c;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}\n", "CodeBleu_score": 78.04295748999657}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\tlog_i(\"tone\", \"Pin: %d, Frequency: %d, Duration: %d\", pin, frequency, duration);\n\tif (pin == 255) {\n\t\tlog_e(\"tone\", \"Pin 255 is not a valid pin\");\n\t\treturn;\n\t}\n\tif (pin_status[pin] == 0) {\n\t\tpin_status[pin] = 1;\n\t\ttone_t* tone = (tone_t*) malloc(sizeof(tone_t));\n\t\ttone->pin = pin;\n\t\ttone->frequency = frequency;\n\t\ttone->duration = duration;\n\t\txQueueSend(tone_queue, &tone, 0);\n\t} else {\n\t\tlog_e(\"tone\", \"Pin %d is already in use, stop the current tone on the pin first\", pin);\n\t}\n}\n", "CodeBleu_score": 45.86465725190035}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\tif (pin == 0) {\n\t\tlog_error(\"Pin 0 is not available for tone generation.\");\n\t\treturn;\n\t}\n\tif (pin > 15) {\n\t\tlog_error(\"Pin %d is not available for tone generation.\", pin);\n\t\treturn;\n\t}\n\tif (pin_state[pin] == 0) {\n\t\tpin_state[pin] = 1;\n\t\tlog_debug(\"Generating tone on pin %d with frequency %d and duration %d.\", pin, frequency, duration);\n\t\ttone_init(pin, frequency, duration);\n\t\txQueueSend(tone_queue, &tone_start, 0);\n\t} else {\n\t\tlog_error(\"Pin %d is already in use. Stop the current tone on the pin first.\", pin);\n\t}\n}\n", "CodeBleu_score": 41.44138352131593}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\t// log the pin, frequency, and duration\n\tlog_info(\"Tone: pin %d, freq %d, duration %d\", pin, frequency, duration);\n\n\t// check if the pin is available or already in use\n\tif (pin_is_available(pin) || pin_is_in_use(pin)) {\n\t\t// initialize the tone\n\t\ttone_init(pin);\n\n\t\t// send a start command with the pin, frequency, and duration to a queue\n\t\txQueueSend(tone_queue, &tone_command_t{\n\t\t\t.type = TONE_COMMAND_START,\n\t\t\t.pin = pin,\n\t\t\t.frequency = frequency,\n\t\t\t.duration = duration,\n\t\t}, 0);\n\t} else {\n\t\t// log an error message instructing to stop the current tone on the pin first\n\t\tlog_error(\"Tone: pin %d is in use\", pin);\n\t}\n}\n", "CodeBleu_score": 46.690805625277264}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled)\tif (started) {\n\t\treturn false;\n\t}\n\twebusb = enabled;\n\tif (enabled) {\n\t\tif (version < 0x0210) {\n\t\t\tversion = 0x0210;\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 50.492468663931554}, {"code": "bool ESPUSB::webUSB(bool enabled)\tif (!usbStarted) {\n\t\twebUSBEnabled = enabled;\n\t\tif (enabled) {\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 53.9044460540398}, {"code": "bool ESPUSB::webUSB(bool enabled)\tif (!started) {\n\t\twebusb = enabled;\n\t\tif (enabled) {\n\t\t\tif (version < 0x0210) {\n\t\t\t\tversion = 0x0210;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 54.1157509053732}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX()\tuint8_t data;\n\tuint32_t len = 0;\n\twhile (CDC_Device_BytesReceived(this->device)) {\n\t\tif (CDC_Device_ReceiveByte(this->device, &data)!= ENDPOINT_RWSTREAM_NoError) {\n\t\t\tthis->onOverflow(len);\n\t\t\tthis->onError(USB_ERROR_RX);\n\t\t\tbreak;\n\t\t}\n\t\tif (!this->rxQueue.push(data)) {\n\t\t\tthis->onOverflow(len);\n\t\t\tthis->onError(USB_ERROR_RX);\n\t\t\tbreak;\n\t\t}\n\t\tlen++;\n\t}\n\tif (len) {\n\t\tthis->onReceive(len);\n\t}\n}\n", "CodeBleu_score": 13.140696423272283}, {"code": "void USBCDC::_onRX()\tuint32_t bytes_read;\n\tuint32_t bytes_dropped = 0;\n\tuint8_t buffer[64];\n\n\twhile (1) {\n\t\tbytes_read = CDC_Device_ReceivePacket(&CDC_Interface, buffer, sizeof(buffer));\n\n\t\tif (bytes_read == 0)\n\t\t\tbreak;\n\n\t\tfor (uint32_t i = 0; i < bytes_read; i++) {\n\t\t\tif (rx_queue.isFull()) {\n\t\t\t\tbytes_dropped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trx_queue.push(buffer[i]);\n\t\t}\n\n\t\tif (bytes_dropped) {\n\t\t\tpostEvent(EVENT_RX_OVERFLOW, bytes_dropped);\n\t\t\tlogError(\"CDC RX overflow: %d bytes dropped\", bytes_dropped);\n\t\t}\n\n\t\tpostEvent(EVENT_RX, bytes_read);\n\t}\n}\n", "CodeBleu_score": 32.161665778220794}, {"code": "void USBCDC::_onRX()\tuint8_t buf[64];\n\tuint32_t len = 0;\n\tuint32_t i = 0;\n\tuint32_t dropped = 0;\n\n\t// read data from USB\n\tlen = USBD_CDC_ReadData(buf, 64);\n\n\t// send data to queue\n\tfor (i = 0; i < len; i++) {\n\t\tif (!xQueueSend(_rxQueue, &buf[i], 0)) {\n\t\t\tdropped++;\n\t\t}\n\t}\n\n\t// post overflow event\n\tif (dropped) {\n\t\tpostEvent(EVENT_RX_OVERFLOW, dropped);\n\t\tlogError(ERR_RX_OVERFLOW, dropped);\n\t}\n\n\t// post receive event\n\tif (len) {\n\t\tpostEvent(EVENT_RX, len);\n\t}\n}\n", "CodeBleu_score": 21.407906605184614}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusNotFound, fmt.Sprintf(\"No robot found with name %s\", robotName))\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\tdevicesJSON, err := json.Marshal(devices)\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusInternalServerError, fmt.Sprintf(\"Error marshalling devices: %v\", err))\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(devicesJSON)\n}\n", "CodeBleu_score": 37.054198534539715}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\ta.error(res, http.StatusNotFound, err)\n\t\treturn\n\t}\n\tdevices, err := a.db.GetRobotDevices(robot.ID)\n\tif err!= nil {\n\t\ta.error(res, http.StatusInternalServerError, err)\n\t\treturn\n\t}\n\ta.writeJSON(res, http.StatusOK, devices)\n}\n", "CodeBleu_score": 31.561421125474766}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the URL path\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Get the robot from the database\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\ta.logger.Error(err)\n\t\thttp.Error(res, fmt.Sprintf(`{\"error\": \"No robot found with name %q\"}`, robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the devices for the robot\n\tdevices, err := a.db.GetDevicesForRobot(robotName)\n\tif err!= nil {\n\t\ta.logger.Error(err)\n\t\thttp.Error(res, fmt.Sprintf(`{\"error\": \"Error getting devices for robot %q\"}`, robotName), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the devices as JSON to the response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(devices)\n}\n", "CodeBleu_score": 38.53810977671312}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\tname := mux.Vars(req)[\"name\"]\n\n\t// Check if the robot exists\n\trobot, ok := a.robots[name]\n\tif!ok {\n\t\t// If the robot is not found, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %s found.\\n\", name)\n\t\treturn\n\t}\n\n\t// If the robot is found, iterate through its connections, convert them to JSON format, and write them to the HTTP response\n\tconnections := make([]string, len(robot.connections))\n\tfor i, connection := range robot.connections {\n\t\tconnections[i] = connection.name\n\t}\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error converting connections to JSON: %v\\n\", err)\n\t\treturn\n\t}\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(jsonConnections)\n}\n", "CodeBleu_score": 34.45232866632956}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Check if the robot exists\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\t// If the robot is not found, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot with the name %s was found\", robotName)))\n\t\treturn\n\t}\n\n\t// If the robot is found, iterate through its connections, convert them to JSON format, and write them to the HTTP response\n\tconnections := make([]Connection, 0, len(robot.connections))\n\tfor _, connection := range robot.connections {\n\t\tconnections = append(connections, Connection{\n\t\t\tName: connection.name,\n\t\t\tURL:  connection.url,\n\t\t})\n\t}\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(fmt.Sprintf(\"Error converting connections to JSON: %v\", err)))\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonConnections)\n}\n", "CodeBleu_score": 42.15939152936208}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\thttp.Error(res, \"No robot with this name\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections := robot.GetConnections()\n\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\thttp.Error(res, \"Error converting connections to JSON\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonConnections)\n}\n", "CodeBleu_score": 32.93709557095518}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\tdeviceName := vars[\"device\"]\n\tcommand := vars[\"command\"]\n\n\trobot := a.robots[robotName]\n\tif robot == nil {\n\t\ta.writeJSONError(res, \"robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.GetDevice(deviceName)\n\tif device == nil {\n\t\ta.writeJSONError(res, \"device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\terr := device.Command(command)\n\tif err!= nil {\n\t\ta.writeJSONError(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ta.writeJSON(res, map[string]string{\"status\": \"ok\"})\n}\n", "CodeBleu_score": 40.31524901919384}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\tif robotName == \"\" {\n\t\ta.writeError(res, \"Missing robot name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif deviceName == \"\" {\n\t\ta.writeError(res, \"Missing device name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif command == \"\" {\n\t\ta.writeError(res, \"Missing command\", http.StatusBadRequest)\n\t\treturn\n\t}\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\ta.writeError(res, fmt.Sprintf(\"Robot '%s' not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tdevice := robot.GetDevice(deviceName)\n\tif device == nil {\n\t\ta.writeError(res, fmt.Sprintf(\"Device '%s' not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\terr := robot.Command(device, command)\n\tif err!= nil {\n\t\ta.writeError(res, fmt.Sprintf(\"Error executing command '%s' on device '%s': %s\", command, deviceName, err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\ta.writeJSON(res, map[string]string{\"status\": \"ok\"})\n}\n", "CodeBleu_score": 42.71814897924145}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\tdeviceName := vars[\"device\"]\n\tcommand := vars[\"command\"]\n\n\trobot := a.getRobot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.GetDevice(deviceName)\n\tif device == nil {\n\t\thttp.Error(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\terr := robot.RunDeviceCommand(device, command)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(map[string]string{\"status\": \"success\"})\n}\n", "CodeBleu_score": 39.74622302593943}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || user!= username || pass!= password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.26716069416255}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || user!= username || pass!= password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 50.03102253462225}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || subtle.ConstantTimeCompare([]byte(user), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 50.84938246686887}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the sensor for reading\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\t// Read the raw value from the sensor\n\traw, err := a.connection.AnalogRead()\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaled := float64(raw) * a.sensor.Scale / float64(a.sensor.Max)\n\n\t// Update the last read values\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\t// Return both the raw and scaled values\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 45.95313420405686}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\tif err := a.sensor.Lock(); err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tdefer a.sensor.Unlock()\n\n\tif!a.sensor.Connection().SupportsAnalog() {\n\t\treturn 0, 0, errors.New(\"sensor does not support analog reading\")\n\t}\n\n\traw, err := a.sensor.Connection().AnalogRead(a.sensor.GetPort())\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.sensor.GetScaleFactor() * float64(raw)\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 42.972289623615765}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif!a.connection.SupportsAnalog() {\n\t\treturn 0, 0, errors.New(\"sensor does not support analog reading\")\n\t}\n\n\tvalue, err := a.connection.AnalogRead(a.port)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(value) * a.scale\n\ta.lastReadRaw = value\n\ta.lastReadScaled = scaled\n\n\treturn value, scaled, nil\n}\n", "CodeBleu_score": 44.57080860646683}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriverreturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}\n", "CodeBleu_score": 35.37524968042367}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriverreturn &GroveSoundSensorDriver{AnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...)}\n}\n", "CodeBleu_score": 23.578559769339023}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriverreturn &GroveSoundSensorDriver{AnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...)}\n}\n", "CodeBleu_score": 23.578559769339023}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error\td.WriteRegister(CommandReg, PCD_RESETPHASE)\n\ttime.Sleep(time.Millisecond * 1)\n\tif d.ReadRegister(CommandReg)&(1<<5)!= 0 {\n\t\treturn errors.New(\"timeout\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 20.186752331578255}, {"code": "func (d *MFRC522Common) softReset() error\td.writeRegister(MFRC522_CommandReg, MFRC522_CommandReg_SoftReset)\n\ttime.Sleep(MFRC522_InitializationTime)\n\tif d.readRegister(MFRC522_CommandReg)&MFRC522_CommandReg_PowerDown!= 0 {\n\t\treturn fmt.Errorf(\"initialization timed out\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 26.470101963874388}, {"code": "func (d *MFRC522Common) softReset() error\t// Reset baud rates\n\td.writeRegister(MFRC522_REG_TXMODE, 0x00)\n\td.writeRegister(MFRC522_REG_RXMODE, 0x00)\n\t// Reset ModWidthReg\n\td.writeRegister(MFRC522_REG_MODWIDTH, 0x26)\n\n\t// When communicating with a PICC we need a timeout if something goes wrong.\\nFor example if the PICC is not connected to the reader.\\nUsually the PICC is connected through a 1k resistor.\\nThis resistor should not be removed.\\nThe timeout is set for 5ms.\n\t// Reset TimeoutTimer\n\td.writeRegister(MFRC522_REG_TMOUT, 0x0D)\n\td.writeRegister(MFRC522_REG_TUPL, 0x00)\n\td.writeRegister(MFRC522_REG_TUPH, 0x00)\n\t// Reset the CRC\n\td.writeRegister(MFRC522_REG_DIVIRQ, 0x04)\n\td.writeRegister(MFRC522_REG_CRCCON, 0x63)\n\t// Reset the control register\n\td.writeRegister(MFRC522_REG_CONTROL, 0x00)\n\t// Reset the status register\n\td.writeRegister(MFRC522_REG_STATUS2, 0x00)\n\t// Reset the FIFO\n\td.writeRegister(MFRC522_REG_FIFODATA, 0x00)\n\t// Reset the IRQ request register\n\td.writeRegister(MFRC522_REG_COMMIRQ, 0x7F)\n\t// Reset the IRQ enable register\n\td.writeRegister(MFRC522_REG_COMMIEN, 0x80)\n\t// Reset the bit framing register\n\td.writeRegister(MFRC522_REG_BITFRAMING, 0x00)\n\t// Clear the internal buffer\n\td.writeRegister(MFRC", "CodeBleu_score": 13.595028372894882}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tif len(backData) == 0 {\n\t\treturn 0, errors.New(\"empty byte slice provided\")\n\t}\n\tn := d.readRegister(FIFOLevelReg)\n\tif n > uint8(len(backData)) {\n\t\treturn 0, errors.New(\"FIFO buffer size is too small\")\n\t}\n\tif n == 0 {\n\t\treturn 0, errors.New(\"FIFO buffer is empty\")\n\t}\n\td.writeRegister(CommandReg, PCD_Mem)\n\tfor i := uint8(0); i < n; i++ {\n\t\tbackData[i] = d.readRegister(FIFODataReg)\n\t}\n\tlastBits := d.readRegister(ControlReg) & 0x07\n\treturn lastBits, nil\n}\n", "CodeBleu_score": 35.99111075463569}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Sanity check\n\tif len(backData) == 0 {\n\t\treturn 0, errors.New(\"empty backData in readFifo\")\n\t}\n\n\t// Calculate the number of uint8s that will be read\n\tn := len(backData)\n\n\t// Perform the read\n\tfifoLevel, err := d.readRegister(FIFOLevelReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tfifoCount := int(fifoLevel & 0x7F)\n\tif fifoCount == 0 {\n\t\treturn 0, errors.New(\"empty FIFO in readFifo\")\n\t}\n\tif fifoCount > n {\n\t\treturn 0, errors.New(\"too many bytes in FIFO in readFifo\")\n\t}\n\tfor i := 0; i < fifoCount; i++ {\n\t\tdata, err := d.readRegister(FIFODataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = data\n\t}\n\n\t// Read the last bits\n\tlastBits, err := d.readRegister(ControlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tlastBits = lastBits & 0x07\n\n\treturn lastBits, nil\n}\n", "CodeBleu_score": 52.92932891924487}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tif len(backData) == 0 {\n\t\treturn 0, nil\n\t}\n\tn := d.readRegister(FIFOLevelReg)\n\tif n > len(backData) {\n\t\treturn 0, fmt.Errorf(\"fifo buffer size=%d < expected=%d\", n, len(backData))\n\t}\n\td.writeRegister(CommandReg, PCD_Mem)\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readRegister(FIFODataReg)\n\t}\n\treturn d.readRegister(ControlReg) & 0x07, nil\n}\n", "CodeBleu_score": 35.46843917488786}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error\tif d.debug {\n\t\tlog.Printf(\"piccHalt()\")\n\t}\n\n\t// Build command buffer\n\tcmd := []byte{PICC_CMD_HALT, 0}\n\td.calculateCRC(cmd)\n\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\n\t//\t\tHALT command, this response shall be interpreted as 'not acknowledge'.\n\t// We interpret that this is only true if the caller expects a response.\n\tif err := d.sendCommand(cmd, true); err!= nil {\n\t\treturn err\n\t}\n\n\t// Set back the fields as in the initialisation\n\tif err := d.writeRegister(CommandReg, PCD_IDLE); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait 1 ms after the command\n\ttime.Sleep(1 * time.Millisecond)\n\n\treturn nil\n}\n", "CodeBleu_score": 34.87083396261156}, {"code": "func (d *MFRC522Common) piccHalt() error\tif d.debug {\n\t\tlog.Println(\"piccHalt\")\n\t}\n\n\t// Build command buffer\n\tcmd := []byte{PICC_CMD_HALT, 0}\n\td.calculateCRC(cmd)\n\n\t// Send the command.\n\t// The standard says:\n\t// Halt = 50 \u00b5s + the time needed for the PCD to send 1 byte.\n\t// Wait 5 ms for the PCD to finish.\n\tif err := d.write(cmd); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Millisecond * 5)\n\n\t// Set the Cascade Level back to 'none' since the\n\t// BAL is now in'stopped' state.\n\td.cascadeLevel = PICC_CMD_IDLE\n\n\t// Wait for the command to execute.\n\tif err := d.waitForReady(); err!= nil {\n\t\treturn err\n\t}\n\n\t// We expect a status response with MF1_ACK.\n\tstatus := []byte{0}\n\tif err := d.read(status); err!= nil {\n\t\treturn err\n\t}\n\n\tif status[0]!= MF1_ACK {\n\t\treturn errors.New(\"piccHalt: Unexpected response\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 38.65646335178817}, {"code": "func (d *MFRC522Common) piccHalt() error\tvar err error\n\tif d.debug {\n\t\td.log(\"piccHalt\")\n\t}\n\tvar command [2]byte\n\tcommand[0] = PICC_CMD_HALT\n\tcommand[1] = 0\n\tcrc := d.calculateCRC(command[:])\n\tcommand[1] = crc[0]\n\tcommand[2] = crc[1]\n\terr = d.writeRaw(command[:])\n\tif err!= nil {\n\t\treturn err\n\t}\n\t_, err = d.readRaw(1)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 28.958408571697213}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tbuffer := make([]byte, 16)\n\tstatus := d.piccReadRaw(block, buffer)\n\tif status!= StatusOk {\n\t\treturn nil, status\n\t}\n\treturn buffer, nil\n}\n", "CodeBleu_score": 19.032696477441913}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tif err := d.piccWakeupA(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Build command buffer\n\tcmd := make([]byte, 6)\n\tcmd[0] = piccCmdRead\n\tcmd[1] = block\n\tcrc := d.calculateCRC(cmd[:2])\n\tcmd[2] = crc[0]\n\tcmd[3] = crc[1]\n\n\t// Send the command\n\tif err := d.write(cmd); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Receive the response\n\tresp, err := d.read(26)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check response\n\tif resp[0]!= 0x00 || resp[1]!= 0x00 {\n\t\treturn nil, fmt.Errorf(\"piccRead: invalid response: %v\", resp)\n\t}\n\n\t// Check CRC\n\tcrc = d.calculateCRC(resp[:22])\n\tif crc[0]!= resp[22] || crc[1]!= resp[23] {\n\t\treturn nil, fmt.Errorf(\"piccRead: invalid CRC: %v\", resp)\n\t}\n\n\t// Return data\n\treturn resp[2:22], nil\n}\n", "CodeBleu_score": 42.21417464182758}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tif block > 0x3F {\n\t\treturn nil, errors.New(\"invalid block number\")\n\t}\n\n\t// Build command buffer\n\tcmd := []byte{PICC_CMD_MF_READ, block}\n\tif err := d.calculateCRC(cmd); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Send the command to the card\n\tif err := d.sendCommand(cmd); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Receive response from the card\n\tresp, err := d.receiveResponse(18)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check for errors\n\tif resp[0]!= 0x0A {\n\t\treturn nil, errors.New(\"invalid response\")\n\t}\n\n\t// Check for CRC errors\n\tif resp[16]!= 0x00 || resp[17]!= 0x00 {\n\t\treturn nil, errors.New(\"invalid CRC\")\n\t}\n\n\t// Return data\n\treturn resp[2:16], nil\n}\n", "CodeBleu_score": 40.69454016973933}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// Verify the answer buffer has at least 2 bytes of space\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer has less than 2 bytes of space\")\n\t}\n\n\t// Clear the collision register\n\tif err := d.ClearBitMask(MFRC522_CollReg, 0x80); err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request mode\n\tif err := d.WriteRegister(MFRC522_BitFramingReg, reqMode); err!= nil {\n\t\treturn err\n\t}\n\n\t// Transceive the request\n\tif err := d.transceive(answer); err!= nil {\n\t\treturn err\n\t}\n\n\t// Check the answer buffer for errors\n\tif answer[0]!= 0x10 {\n\t\treturn errors.New(\"piccRequest: invalid answer\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 57.56311926407543}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer too small\")\n\t}\n\t// Clear the collision register\n\td.clearRegister(MFRC522_COLL)\n\t// Set the right bit in the collision register\n\tswitch reqMode {\n\tcase MFRC522_PICC_REQIDL:\n\t\td.writeRegister(MFRC522_BITFRAMING, 0x07)\n\tcase MFRC522_PICC_REQALL:\n\t\td.writeRegister(MFRC522_BITFRAMING, 0x87)\n\t}\n\t// Transmit the request command\n\terr := d.transceive(MFRC522_PICC_REQA, answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Return the status of the response\n\treturn nil\n}\n", "CodeBleu_score": 53.97392300143078}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// Valid modes are:\n\t//\t\tPICC_REQIDL\t\t= 0x26\t\t// Find an ID card, return its type\n\t//\t\tPICC_REQALL\t\t= 0x52\t\t// Find all cards, return card type\n\t//\t\tPICC_ANTICOLL\t= 0x93\t\t// Anti collision/Select, return card serial number\n\t//\t\tPICC_AUTHENT1A\t= 0x60\t\t// Authentication with key A\n\t//\t\tPICC_AUTHENT1B\t= 0x61\t\t// Authentication with key B\n\t//\t\tPICC_READ\t\t= 0x30\t\t// Read block\n\t//\t\tPICC_WRITE\t\t= 0xA0\t\t// Write block\n\t//\t\tPICC_DECREMENT\t= 0xC0\t\t// Decrement value block\n\t//\t\tPICC_INCREMENT\t= 0xC1\t\t// Increment value block\n\t//\t\tPICC_RESTORE\t= 0xC2\t\t// Restore value block\n\t//\t\tPICC_TRANSFER\t= 0xB0\t\t// Transfer value block\n\t//\t\tPICC_HALT\t\t= 0x50\t\t// Halt/sleep\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"piccRequest: answer buffer too short\")\n\t}\n\t// Clear the collision register\n\td.writeRegister(RegColl, 0x80)\n\t// Set the request mode\n\td.writeRegister(RegBitFraming, (reqMode << 4) | 0x80)\n\t// Transceive the request\n\treturn d.transceive(answer, 2)\n}\n", "CodeBleu_score": 26.952707729961016}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.StepPin.DigitalWrite(false); err!= nil {\n\t\treturn err\n\t}\n\n\tif err := time.Sleep(d.StepDelay); err!= nil {\n\t\treturn err\n\t}\n\n\tif err := d.StepPin.DigitalWrite(true); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.Direction {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 62.75845210561801}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.DigitalWrite(false)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\terr = d.stepPin.DigitalWrite(true)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 59.63366872586743}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif err := d.stepPin.DigitalWrite(false); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\tif err := d.stepPin.DigitalWrite(true); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 61.85664969951262}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitorChan = make(chan struct{})\n\td.distanceMonitorWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWaitGroup.Done()\n\n\t\tticker := time.NewTicker(d.distanceMonitorInterval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitorChan:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\terr := d.measureDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\tlog.Printf(\"error measuring distance: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\treturn nil\n}\n", "CodeBleu_score": 48.00034675674066}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWg.Done()\n\n\t\tticker := time.NewTicker(d.distanceMonitorInterval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tlog.Printf(\"distance monitor: %v\\n\", err)\n\t\t\t\t}\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\treturn nil\n}\n", "CodeBleu_score": 48.99215286700752}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\tif d.stopCh!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.stopCh = make(chan struct{})\n\td.wg.Add(1)\n\tgo d.monitorDistance(d.stopCh)\n\treturn nil\n}\n", "CodeBleu_score": 23.647648414041942}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar startTime time.Duration\n\treturn func(pin int, timestamp time.Duration, state string, value uint32, pulseDuration uint32) {\n\t\tif state == \"rising\" {\n\t\t\tstartTime = timestamp\n\t\t} else if state == \"falling\" {\n\t\t\td.durationChannel <- timestamp - startTime\n\t\t\tstartTime = 0\n\t\t}\n\t}\n}\n", "CodeBleu_score": 48.228141843806775}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tstart := time.Now()\n\treturn func(pin int, timestamp time.Duration, state string, value uint32, pulseDuration uint32) {\n\t\tif state == \"rising\" {\n\t\t\tstart = timestamp\n\t\t} else if state == \"falling\" {\n\t\t\td.ch <- timestamp.Sub(start)\n\t\t\tstart = time.Now()\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.98167140203942}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tstart := time.Now()\n\treturn func(pin int, timestamp time.Duration, state string, value uint32, timestamp2 uint32) {\n\t\tif state == \"rising\" {\n\t\t\tstart = timestamp\n\t\t} else {\n\t\t\td.duration <- timestamp.Sub(start)\n\t\t\tstart = time.Now()\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.38075729397334}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.trigger(); err!= nil {\n\t\treturn err\n\t}\n\n\tif err := d.wait(); err!= nil {\n\t\treturn err\n\t}\n\n\td.measuredTime = d.pulseIn.GetTime()\n\n\treturn nil\n}\n", "CodeBleu_score": 51.14618002271818}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\tif err := d.trigger(); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measurementComplete:\n\t\t// Measurement completed successfully, store the measured time in microseconds\n\t\td.measuredTime = time.Since(d.measurementStartTime)\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// Timeout occurred, return an error\n\t\treturn errors.New(\"HCSR04: measurement timed out\")\n\t}\n}\n", "CodeBleu_score": 49.438712604607495}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerSensor(); err!= nil {\n\t\treturn err\n\t}\n\n\tif err := d.waitForMeasurement(); err!= nil {\n\t\treturn err\n\t}\n\n\td.lastMeasurement = time.Now()\n\treturn nil\n}\n", "CodeBleu_score": 49.978139632677866}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n    if \"AUTHORIZATION_TOKEN\" in os.environ:\n        return os.environ[\"AUTHORIZATION_TOKEN\"]\n    else:\n        state = self.get_state()\n        if state is not None:\n            if state[\"expires_at\"] < time.time():\n                if state[\"refresh_token\"] is not None:\n                    try:\n                        new_state = self.fetch_new_authentication_token(\n                            state[\"refresh_token\"]\n                        )\n                        self.update_state(new_state)\n                        return new_state[\"access_token\"]\n                    except Exception as e:\n                        print(e)\n                        raise AccountNotAuthorized(\n                            \"Access token expired and no refresh token available\"\n                        )\n            else:\n                return state[\"access_token\"]\n        raise AccountNotAuthorized(\"No valid access token found\")\n\n", "CodeBleu_score": 33.939868446465915}, {"code": "def fetch_authentication_token(self)\n    try:\n        return os.environ[\"AUTH_TOKEN\"]\n    except KeyError:\n        try:\n            with open(self.local_state_file, \"r\") as f:\n                local_state = json.load(f)\n                if local_state[\"expires_at\"] < time.time():\n                    if \"refresh_token\" in local_state:\n                        try:\n                            response = requests.post(\n                                self.token_url,\n                                data={\n                                    \"grant_type\": \"refresh_token\",\n                                    \"refresh_token\": local_state[\"refresh_token\"],\n                                    \"client_id\": self.client_id,\n                                    \"client_secret\": self.client_secret,\n                                },\n                            )\n                            response.raise_for_status()\n                            data = response.json()\n                            local_state[\"access_token\"] = data[\"access_token\"]\n                            local_state[\"refresh_token\"] = data[\"refresh_token\"]\n                            local_state[\"expires_at\"] = time.time() + data[\"expires_in\"]\n                            with open(self.local_state_file, \"w\") as f:\n                                json.dump(local_state, f)\n                            return local_state[\"access_token\"]\n                        except requests.exceptions.HTTPError as e:\n                            raise AccountNotAuthorized(e)\n                    else:\n                        raise AccountNotAuthorized(\n                            \"No refresh token available in local state\"\n                        )\n                else:\n                    return local_state[\"access_token\"]\n        except FileNotFoundError:\n            raise AccountNotAuthorized(\"Local state file not found\")\n        except KeyError:\n            raise AccountNotAuthorized(\"Invalid local state file\")\n        except requests.exceptions.HTTPError as e:\n            raise AccountNotAuthorized(e)\n\n", "CodeBleu_score": 35.20503389917294}, {"code": "def fetch_authentication_token(self)\n    if self.token is None:\n      try:\n        self.token = os.environ[\"TWILIO_AUTH_TOKEN\"]\n      except KeyError:\n        try:\n          with open(self.state_file, \"r\") as f:\n            state = json.load(f)\n          if state[\"expires\"] < time.time():\n            if state[\"refresh_token\"] is not None:\n              try:\n                response = requests.post(\n                  \"https://api.twilio.com/2010-04-01/Accounts/{}/Tokens\".format(self.account_sid),\n                  auth=(self.account_sid, self.token),\n                  data={\"grant_type\": \"refresh_token\", \"refresh_token\": state[\"refresh_token\"]},\n                  headers={\"Accept\": \"application/json\"}\n                )\n                if response.status_code == 200:\n                  self.token = response.json()[\"token\"]\n                  self.refresh_token = response.json()[\"refresh_token\"]\n                  self.expires = time.time() + response.json()[\"expires_in\"]\n                  with open(self.state_file, \"w\") as f:\n                    json.dump({\n                      \"expires\": self.expires,\n                      \"refresh_token\": self.refresh_token\n                    }, f)\n                else:\n                  raise AccountNotAuthorized()\n              except (requests.exceptions.RequestException, json.decoder.JSONDecodeError):\n                raise AccountNotAuthorized()\n            else:\n              raise AccountNotAuthorized()\n          else:\n            self.token = state[\"token\"]\n            self.refresh_token = state[\"refresh_token\"]\n            self.expires = state[\"expires\"]\n        except (KeyError, FileNotFoundError, json.decoder.JSONDecodeError):\n          raise AccountNotAuthorized()\n    return self.token\n\n  def send_message(self, to, body):\n    \"\"\"The function \"send_message\" sends a text message to the specified recipient.\\nIt first checks if the recipient is a valid phone number.\\nIf not, it raises an \"InvalidPhoneNumber\" exception.\\nIt then fetches the authentication token for the application.\\nIt then attempts to send a text message to the recipient using the Twilio API.\\nIf successful, it returns the message SID.\\nIf unsuccessful, it raises an \"MessageSendingFailed\" exception.\"\"\"\n    if not re.match(\"^\\+?[1-9]\\d{1,14}$\",", "CodeBleu_score": 30.579561456011806}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n    try:\n      refresh_token = self.get_refresh_token()\n      self.delete_session()\n      self.post(\"/v1/logout\", data = {\"refresh_token\": refresh_token})\n      return True\n    except AccountError:\n      return True\n\n  def get_refresh_token(self):\n    \"\"\"The function \"get_refresh_token\" retrieves the refresh token from the local session.\\nIf the refresh token is not found, it raises an AccountError.\\nThe function returns the refresh token as a string.\"\"\"\n    if \"refresh_token\" in self.session:\n      return self.session[\"refresh_token\"]\n    else:\n      raise AccountError(\"Refresh token not found\")\n\n  def delete_session(self):\n    \"\"\"The function \"delete_session\" deletes the local session.\\nThe function returns \"None\".\"\"\"\n    self.session.clear()\n    return None\n\n  def get_session(self):\n    \"\"\"The function \"get_session\" retrieves the local session.\\nThe function returns the local session as a dictionary.\"\"\"\n    return self.session\n\n  def set_session(self, session):\n    \"\"\"The function \"set_session\" sets the local session to the provided session.\\nThe function returns \"None\".\"\"\"\n    self.session = session\n    return None\n\n  def get_headers(self):\n    \"\"\"The function \"get_headers\" retrieves the headers from the local session.\\nThe function returns the headers as a dictionary.\"\"\"\n    return self.session[\"headers\"]\n\n  def set_headers(self, headers):\n    \"\"\"The function \"set_headers\" sets the headers in the local session to the provided headers.\\nThe function returns \"None\".\"\"\"\n    self.session[\"headers\"] = headers\n    return None\n\n  def get_access_token(self):\n    \"\"\"The function \"get_access_token\" retrieves the access token from the local session.\\nIf the access token is not found, it raises an AccountError.\\nThe function returns the access token as a string.\"\"\"\n    if \"access_token\" in self.session[\"headers\"]:\n      return self.session[\"headers\"][\"access_token\"]\n    else:\n      raise AccountError(\"Access token not found\")\n\n  def set_access_token(self, access_token):\n    \"\"\"The function \"set_access_token\" sets the access token in the local session to the provided access token.\\nThe function returns \"None\".\"\"\"\n    self.session[\"headers\"][\"", "CodeBleu_score": 43.75614379019787}, {"code": "def logout(self)\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n        return True\n    except AccountError:\n        return True", "CodeBleu_score": 54.47108980250952}, {"code": "def logout(self)\n    try:\n      self.refresh_token = self.get_refresh_token()\n      self.session.clear()\n      response = requests.post(self.base_url + \"/v1/logout\", data={\"refresh_token\": self.refresh_token})\n      if response.status_code == 200:\n        return True\n      else:\n        return False\n    except AccountError:\n      return True\n\n  def get_refresh_token(self):\n    \"\"\"The function \"get_refresh_token\" retrieves the refresh token from the local session, if it exists. If the refresh token is not found, it raises an AccountError.\\nThe function returns the refresh token if it is found.\"\"\"\n    try:\n      return self.session[\"refresh_token\"]\n    except KeyError:\n      raise AccountError(\"No refresh token found\")\n\n  def get_access_token(self):\n    \"\"\"The function \"get_access_token\" retrieves the access token from the local session, if it exists. If the access token is not found, it raises an AccountError.\\nThe function returns the access token if it is found.\"\"\"\n    try:\n      return self.session[\"access_token\"]\n    except KeyError:\n      raise AccountError(\"No access token found\")\n\n  def get_user_id(self):\n    \"\"\"The function \"get_user_id\" retrieves the user ID from the local session, if it exists. If the user ID is not found, it raises an AccountError.\\nThe function returns the user ID if it is found.\"\"\"\n    try:\n      return self.session[\"user_id\"]\n    except KeyError:\n      raise AccountError(\"No user ID found\")\n\n  def get_user_info(self):\n    \"\"\"The function \"get_user_info\" retrieves the user information from the local session, if it exists. If the user information is not found, it raises an AccountError.\\nThe function returns the user information if it is found.\"\"\"\n    try:\n      return self.session[\"user_info\"]\n    except KeyError:\n      raise AccountError(\"No user information found\")\n\n  def get_user_info_from_id(self, user_id):\n    \"\"\"The function \"get_user_info_from_id\" retrieves the user information from the server by sending a GET request to the \"/v1/users/{user_id}\" endpoint with the specified user ID.\\nIf the request is successful, it updates the local session with the", "CodeBleu_score": 36.561374728968055}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n    # TODO: add support for other package managers\n    if self.package_manager == \"pip\":\n      packages = self.get_pip_packages()\n      for package in packages:\n        if not package.optional:\n          package_name = package.name\n          package_version = package.version\n          if package.external:\n            package_source = package.source\n          else:\n            package_source = None\n          self.used_packages.append((package_name, package_version, package_source))\n      return self.used_packages\n    else:\n      return None\n\n  def get_pip_packages(self):\n    \"\"\"The function \"get_pip_packages\" returns a list of PipPackage objects.\\nIt iterates through the packages, creates a PipPackage object for each, and adds it to the list.\\nFinally, it returns the list of PipPackage objects.\"\"\"\n    packages = []\n    for package in self.packages:\n      packages.append(PipPackage(package))\n    return packages\n", "CodeBleu_score": 26.373109659774137}, {"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_name = package.name\n        package_version = package.version\n        if package.external:\n            package_source = package.source\n        else:\n            package_source = None\n        packages.append({\n            \"name\": package_name,\n            \"version\": package_version,\n            \"source\": package_source\n        })\n    return packages\n", "CodeBleu_score": 25.887924484160195}, {"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n        if not package.is_optional:\n            metadata = package.get_metadata()\n            package_name = metadata.get(\"name\")\n            package_version = metadata.get(\"version\")\n            package_source = metadata.get(\"source\")\n            if package_source:\n                package_source = package_source.get(\"url\")\n            package_info = {\n                \"name\": package_name,\n                \"version\": package_version,\n                \"source\": package_source,\n            }\n            packages.append(package_info)\n    return packages\n\n", "CodeBleu_score": 28.70012193454805}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if env in cls.platforms:\n        platform_spec = cls.platforms[env]\n        instance = cls(platform_spec, autoinstall=autoinstall)\n        instance.project = cls.project\n        instance.configure_packages(targets)\n        return instance\n    else:\n        raise UndefinedEnvPlatformError(env)\n\n", "CodeBleu_score": 37.07258414019854}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if not env:\n        raise UndefinedEnvNameError(env)\n    env_platform = cls.get_platform(env)\n    if not env_platform:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(env_platform, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 41.59485522084581}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if targets is None:\n        targets = []\n    platform = env.get(\"platform\", None)\n    if platform is None:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.set_project_env(env)\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 39.76846662538932}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tWire.beginTransmission(AXP192_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}\n", "CodeBleu_score": 60.251326150585626}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tWire.beginTransmission(AXP192_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}\n", "CodeBleu_score": 60.251326150585626}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tWire.beginTransmission(AXP192_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}\n", "CodeBleu_score": 60.251326150585626}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us)\tSetSleep();\n\tif (time_in_us!= 0) {\n\t\tSetTimer(time_in_us);\n\t} else {\n\t\tDisableTimer();\n\t}\n\tSetDeepSleep();\n}\n", "CodeBleu_score": 39.18621850812363}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)\t// Prepare the device for sleep\n\tSetSleep();\n\n\t// Enable or disable the timer wakeup source\n\tif (time_in_us > 0) {\n\t\tSetTimer(time_in_us);\n\t} else {\n\t\tDisableTimer();\n\t}\n\n\t// Initiate deep sleep\n\tif (time_in_us > 0) {\n\t\t// Wait for the specified duration\n\t\tusleep(time_in_us);\n\t}\n\t// Initiate deep sleep immediately\n\tDeepSleep();\n}\n", "CodeBleu_score": 47.89882377563838}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tEnableTimer(time_in_us);\n\t} else {\n\t\tDisableTimer();\n\t}\n\tDeepSleep();\n}\n", "CodeBleu_score": 40.509796221469315}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)\tint y_old = y;\n\tif (tteBar) {\n\t\ty_old = y - TTE_FIXED_TOP;\n\t\ty = y_old + TTE_FIXED_BOTTOM;\n\t}\n\tif (y >= (height - TTE_FIXED_BOTTOM)) {\n\t\ty = TTE_FIXED_TOP;\n\t}\n\tdraw_rectangle(0, y_old, width, TTE_FIXED_BOTTOM, color);\n\tscroll_addr = (y_old * width) + x;\n\treturn y_old;\n}\n", "CodeBleu_score": 20.799653605632056}, {"code": "int Display::scroll_line(uint32_t color)\tint y = scroll_y;\n\tif (y >= (TFT_HEIGHT - TFT_FIXED_AREA)) {\n\t\ty = TFT_TOP_FIXED_AREA;\n\t\ttteBar = true;\n\t}\n\ttft.fillRect(0, y, TFT_WIDTH, TFT_FONT_HEIGHT, color);\n\tscroll_y += TFT_FONT_HEIGHT;\n\tif (scroll_y >= (TFT_HEIGHT - TFT_FIXED_AREA)) {\n\t\tscroll_y = TFT_TOP_FIXED_AREA + TFT_FONT_HEIGHT;\n\t\ttteBar = true;\n\t}\n\treturn y;\n}\n", "CodeBleu_score": 26.167415345170586}, {"code": "int Display::scroll_line(uint32_t color)\tint y = scroll_address;\n\tuint32_t top_fixed_area = tteBar? TTE_FIXED_AREA_TOP_ALT : TTE_FIXED_AREA_TOP;\n\tuint32_t bottom_fixed_area = tteBar? TTE_FIXED_AREA_BOTTOM_ALT : TTE_FIXED_AREA_BOTTOM;\n\tif (y >= (height - bottom_fixed_area)) {\n\t\ty = top_fixed_area;\n\t} else {\n\t\ty += TTE_FONT_HEIGHT;\n\t}\n\tfillRectangle(0, y - TTE_FONT_HEIGHT, width, TTE_FONT_HEIGHT, color);\n\tscroll_address = y;\n\treturn y;\n}\n", "CodeBleu_score": 23.780904424871313}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\tif(!this->setup_access_points(access_points)) {\n\t\treturn false;\n\t}\n\tif(!this->setup_html_content(ssids)) {\n\t\treturn false;\n\t}\n\tthis->start();\n\treturn true;\n}\n", "CodeBleu_score": 56.861459632251}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\tif (!setAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\tif (!setHtmlContent(ssids)) {\n\t\treturn false;\n\t}\n\tstart();\n\treturn true;\n}\n", "CodeBleu_score": 56.7012338025457}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\tif (!this->set_access_points(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->set_html_content(ssids)) {\n\t\treturn false;\n\t}\n\tthis->start();\n\treturn true;\n}\n", "CodeBleu_score": 58.113029494376114}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\tif (queue == NULL) {\n\t\t\tqueue = new Queue<char>();\n\t\t}\n\t\tif (text == NULL) {\n\t\t\ttext = new char[100];\n\t\t}\n\t\tif (text_in == NULL) {\n\t\t\ttext_in = new char[100];\n\t\t}\n\t} else {\n\t\tqueue_enabled_flag = true;\n\t\tif (queue!= NULL) {\n\t\t\tqueue->flush();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 12.257625756320282}, {"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\tif (queue_init_flag) {\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tqueue_init_flag = true;\n\t\t\tqueue_text = \"\";\n\t\t\tqueue_text_in = \"\";\n\t\t}\n\t}\n\telse {\n\t\tqueue_enabled_flag = true;\n\t\tqueue_init_flag = true;\n\t\tqueue_text = \"\";\n\t\tqueue_text_in = \"\";\n\t\tqueue_flush();\n\t}\n}\n", "CodeBleu_score": 11.354115813467066}, {"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\tif (queue.empty()) {\n\t\t\tqueue.push(text);\n\t\t\tqueue.push(text_in);\n\t\t}\n\t} else {\n\t\tqueue_enabled_flag = true;\n\t\tqueue.flush();\n\t\tqueue.push(text);\n\t\tqueue.push(text_in);\n\t}\n}\n", "CodeBleu_score": 10.802105670431116}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea()\tif (queue_nmea) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new queue<string>();\n}\n", "CodeBleu_score": 35.91810349018931}, {"code": "void GpsInterface::flush_queue_nmea()\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new std::queue<std::string>();\n}\n", "CodeBleu_score": 33.07637011636596}, {"code": "void GpsInterface::flush_queue_nmea()\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = new queue<NmeaSentence>();\n\t} else {\n\t\tqueue_nmea = new queue<NmeaSentence>();\n\t}\n}\n", "CodeBleu_score": 38.90548256747184}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)\t/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n\tint32_t x, y;\n\tfor(y = area->y1; y <= area->y2; y++) {\n\t\tfor(x = area->x1; x <= area->x2; x++) {\n\t\t\tmy_disp_map(x, y, *color_p);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\tlv_disp_flush_ready(disp);\n}\n", "CodeBleu_score": 41.146496426742715}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)\t//printf(\"my_disp_flush\\n\");\n\tuint32_t w = (area->x2 - area->x1 + 1);\n\tuint32_t h = (area->y2 - area->y1 + 1);\n\tuint8_t *p = (uint8_t *)color_p;\n\t//printf(\"my_disp_flush: %d, %d, %d, %d\\n\", area->x1, area->y1, area->x2, area->y2);\n\t//printf(\"my_disp_flush: %d, %d\\n\", w, h);\n\t//printf(\"my_disp_flush: %d, %d, %d, %d\\n\", color_p[0].ch.red, color_p[0].ch.green, color_p[0].ch.blue, color_p[0].ch.alpha);\n\t//printf(\"my_disp_flush: %d, %d, %d, %d\\n\", color_p[1].ch.red, color_p[1].ch.green, color_p[1].ch.blue, color_p[1].ch.alpha);\n\t//printf(\"my_disp_flush: %d, %d, %d, %d\\n\", color_p[2].ch.red, color_p[2].ch.green, color_p[2].ch.blue, color_p[2].ch.alpha);\n\t//printf(\"my_disp_flush: %d, %d, %d, %d\\n\", color_p[3].ch.red, color_p[3].ch.green, color_p[3].ch.blue, color_p[3].ch.alpha);\n\t//printf(\"my_disp_flush: %d, %d, %d, %d\\n\", color_p[4].ch.red, color_p[4].ch.green, color_p[4].ch.blue, color_p[4].ch.alpha);\n\t//printf(\"my_disp_flush: %d, %d, %d, %d\\n\", color_p[5].ch.red, color_p[5].ch", "CodeBleu_score": 18.55287340752951}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)\tuint16_t x, y;\n\tuint16_t w = area->x2 - area->x1 + 1;\n\tuint16_t h = area->y2 - area->y1 + 1;\n\tuint16_t *p = (uint16_t *)color_p;\n\tuint16_t *p2 = (uint16_t *)color_p;\n\tuint16_t color;\n\tuint8_t *p3 = (uint8_t *)color_p;\n\tuint8_t *p4 = (uint8_t *)color_p;\n\tuint8_t *p5 = (uint8_t *)color_p;\n\tuint8_t *p6 = (uint8_t *)color_p;\n\tuint8_t *p7 = (uint8_t *)color_p;\n\tuint8_t *p8 = (uint8_t *)color_p;\n\tuint8_t *p9 = (uint8_t *)color_p;\n\tuint8_t *p10 = (uint8_t *)color_p;\n\tuint8_t *p11 = (uint8_t *)color_p;\n\tuint8_t *p12 = (uint8_t *)color_p;\n\tuint8_t *p13 = (uint8_t *)color_p;\n\tuint8_t *p14 = (uint8_t *)color_p;\n\tuint8_t *p15 = (uint8_t *)color_p;\n\tuint8_t *p16 = (uint8_t *)color_p;\n\tuint8_t *p17 = (uint8_t *)color_p;\n\tuint8_t *p18 = (uint8_t *)color_p;\n\tuint8_t *p19 = (uint8_t *)color_p;\n\tuint8_t *p20 = (uint8_t *)color_p;\n\tuint8_t *p21 = (uint8_t *)color_p;\n\tuint8_t *p22 = (uint8", "CodeBleu_score": 24.978582149973715}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tif (menu == NULL) {\n\t\treturn;\n\t}\n\tMenuNode * node = menu->getFirstNode();\n\twhile (node!= NULL) {\n\t\tfor (int i = 0; i < layer; i++) {\n\t\t\tcout << \"\\t\";\n\t\t}\n\t\tcout << node->getName() << endl;\n\t\tshowMenuList(node->getMenu(), layer + 1);\n\t\tnode = node->getNext();\n\t}\n\tcout << endl;\n}\n", "CodeBleu_score": 42.072210903417286}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tif (menu == NULL) {\n\t\treturn;\n\t}\n\tint i = 0;\n\tfor (i = 0; i < layer; i++) {\n\t\tcout << \"\\t\";\n\t}\n\tcout << menu->getName() << endl;\n\tfor (i = 0; i < menu->getNumOfNodes(); i++) {\n\t\tshowMenuList(menu->getNode(i), layer + 1);\n\t}\n}\n", "CodeBleu_score": 42.87099123927186}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tfor (int i = 0; i < menu->getNodes().size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tstd::cout << \"  \";\n\t\t}\n\t\tstd::cout << menu->getNodes()[i]->getName() << std::endl;\n\t\tif (menu->getNodes()[i]->getType() == 1) {\n\t\t\tshowMenuList(dynamic_cast<Menu*>(menu->getNodes()[i]), layer + 1);\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}\n", "CodeBleu_score": 44.308714436602976}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count)\tint generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tchar *ssid = (char*) malloc(7);\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid[j] = (char) random(65, 91);\n\t\t}\n\t\tssid[6] = 0;\n\t\tint channel = random(1, 14);\n\t\tchar *mac = (char*) malloc(18);\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac[j] = (char) random(65, 91);\n\t\t}\n\t\tmac[6] = 0;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac[j + 7] = (char) random(65, 91);\n\t\t}\n\t\tmac[13] = 0;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac[j + 14] = (char) random(65, 91);\n\t\t}\n\t\tmac[19] = 0;\n\t\tWiFiScan::addSSID(ssid, channel, mac);\n\t\tfree(ssid);\n\t\tfree(mac);\n\t\tgenerated++;\n\t}\n\treturn generated;\n}\n", "CodeBleu_score": 43.779474241352176}, {"code": "int WiFiScan::generateSSIDs(int count)\tif (count < 1) {\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += random(0, 26) + 65;\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac += String(random(0, 16), HEX);\n\t\t}\n\t\tssids.push_back(new SSID(ssid, channel, mac));\n\t\tSerial.println(ssid + \" \" + channel + \" \" + mac);\n\t}\n\n\treturn count;\n}\n", "CodeBleu_score": 39.89129611810138}, {"code": "int WiFiScan::generateSSIDs(int count)\tint generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char) random(65, 91);\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = generateMAC();\n\t\taddSSID(ssid, channel, mac);\n\t\tgenerated++;\n\t}\n\treturn generated;\n}\n", "CodeBleu_score": 35.93666587642282}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 47.75438905838018}, {"code": "def create_topic(project_id, topic_name)\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 48.4204446846163}, {"code": "def create_topic(project_id, topic_name)\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 49.33548033251296}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n    # Create a JSON Web Token (JWT) for authentication purposes\n    # Set the issued time (iat) to the current UTC time\n    # Set the expiration time (exp) to one hour later\n    # Set the audience (aud) field to the provided GCP project ID\n    # Read the private key from the specified file\n    # Create the JWT using the specified algorithm\n    # Return the encoded JWT\n    iat = datetime.utcnow()\n    exp = iat + timedelta(hours=1)\n    aud = project_id\n\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    payload = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": aud,\n    }\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n\n    return encoded_jwt\n\n", "CodeBleu_score": 41.99243294018056}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n    token = {\n        \"iat\": datetime.utcnow(),\n        \"exp\": datetime.utcnow() + timedelta(hours=1),\n        \"aud\": project_id,\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 41.60721292338406}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n    token = {\n        \"iat\": datetime.datetime.utcnow(),\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        \"aud\": project_id,\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 48.843762819610106}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '\" + payload + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        print(\"Taking preview image...\")\n        camera.capture(\"preview.jpg\")\n        print(\"Uploading image to bucket...\")\n        s3.upload_file(\"preview.jpg\", \"your-bucket-name\", \"preview.jpg\")\n        print(\"Publishing to event topic...\")\n        client.publish(\"your-event-topic\", \"https://your-bucket-name.s3.amazonaws.com/preview.jpg\")\n    else:\n        print(\"off\")\n", "CodeBleu_score": 27.661916061986798}, {"code": "def on_message(unused_client, unused_userdata, message)\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('Received on command')\n        capture_preview()\n        upload_file(file_name)\n        publish_file_url(file_name)\n    else:\n        print('Received off command')\n", "CodeBleu_score": 29.87608075345209}, {"code": "def on_message(unused_client, unused_userdata, message)\n    # Print the received message's payload, topic, and QoS\n    print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n\n    # If the payload is \"on\", capture a preview image, upload the file to a specified bucket, and publish the file's URL to an MQTT event topic\n    if message.payload == b'on':\n        # Capture a preview image\n        preview_image = capture_preview_image()\n\n        # Upload the preview image to a specified bucket\n        upload_preview_image(preview_image)\n\n        # Publish the preview image's URL to an MQTT event topic\n        publish_preview_image_url()\n\n    # If the payload is not \"on\", simply print \"off\"\n    else:\n        print(\"off\")\n", "CodeBleu_score": 24.598656518994538}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Pub/Sub subscription name')\n    parser.add_argument(\n        '--service_account_json',\n        help='Path to service account json file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        default='ES256',\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default=os.path.join(os.path.dirname(__file__), 'roots.pem'),\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        type=int,\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event','state'),\n        default='event',\n        help='Message type to publish.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        type=int,\n        default=20,\n        help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event','state'),\n        default='event',\n        help='Message type to publish.')\n    parser.add_argument(\n        '--device_id',\n        required=True,\n        help='Device ID')\n    parser.add_argument(\n        '--registry_id',\n        required=True,\n        help='Device registry ID')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--version',\n        action='version',\n        version='%", "CodeBleu_score": 35.53579024828338}, {"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\"--registry_id\", required=True, help=\"Cloud IoT registry id\")\n    parser.add_argument(\"--device_id\", required=True, help=\"Cloud IoT device id\")\n    parser.add_argument(\"--private_key_file\", required=True, help=\"Path to private key file.\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), default=\"RS256\", help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--message_type\", choices=(\"event\", \"state\"), default=\"event\", help=\"Whether the message to be published is a 'event' or a'state'.\")\n    parser.add_argument(\"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\")\n    parser.add_argument(\"--jwt_expires_minutes\", type=int, default=20, help=\"Expiration time, in minutes, for JWT tokens.\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", type=int, default=8883, help=\"MQTT bridge port.\")\n    parser.add_argument(\"--ca_certs\", default=os.path.join(os.path.dirname(__file__), \"roots.pem\"), help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\"--message\", default=\"Hello World\", help=\"Message to publish.\")\n    parser.add_argument(\"--verbosity\", choices=(\"DEBUG\", \"INFO\", \"ERROR\"), default=\"INFO\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 41.48025636364325}, {"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT device connection.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='GCP cloud region')\n    parser.add_argument(\n        '--registry_id',\n        default='my-registry',\n        help='Cloud IoT Core registry ID')\n    parser.add_argument(\n        '--device_id',\n        default='my-node-device',\n        help='Cloud IoT Core device ID')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        default='ES256',\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--private_key_file',\n        default='rsa_private.pem',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event','state'),\n        default='event',\n        help='Whether the message to be published is a \"event\" or a \"state\".')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        type=int,\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event','state'),\n        default='event',\n        help='Whether the message to be published is a \"event\" or a \"state\".')\n    return parser.parse_args()\n", "CodeBleu_score": 35.937313847882635}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n    # Define the API scopes and version\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n\n    # Scope the credentials to the necessary API scopes\n    scoped_credentials = credentials.with_scopes(scopes)\n\n    # Build and return the client for the Cloud IoT Core service using the discovery API URL\n    return googleapiclient.discovery.build(\n        \"cloudiot\", version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url\n    )\n\n", "CodeBleu_score": 23.523655110550568}, {"code": "def get_client(service_account_json)\n    # Define the API scope (full authorization)\n    api_scope = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Define the API version and discovery URL\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n\n    # Scope the credentials to the necessary API scope\n    scoped_credentials = credentials.with_scopes(api_scope)\n\n    # Build the client for the Cloud IoT Core service using the discovery URL\n    client = googleapiclient.discovery.build(\n        serviceName='cloudiotcore',\n        version=api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials\n    )\n\n    # Return the client\n    return client\n\n", "CodeBleu_score": 31.12499324079}, {"code": "def get_client(service_account_json)\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=api_scopes)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n    discovery_url = '{}?version={}'.format(discovery_url, api_version)\n    return googleapiclient.discovery.build(\n        'cloudiot',\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials)\n\n", "CodeBleu_score": 42.78882845277049}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n    if hash_method =='sha1':\n        asn1_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method =='sha256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method =='sha512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_with_asn1_code = asn1_code + hash_value\n    padded_hash_value = pad_for_signing(hash_value_with_asn1_code)\n    signature = priv_key.encrypt(padded_hash_value, KNOWN_RSA_PADDING)\n    return signature\n\n", "CodeBleu_score": 26.094142856027798}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    asn1_code = get_asn1_code(hash_method)\n    if not asn1_code:\n        raise ValueError(\"Invalid hash method specified.\")\n    hash_value = asn1_code + hash_value\n    padded_hash = pad_for_signing(hash_value)\n    return priv_key.encrypt(padded_hash, padding.PKCS1v15())\n\n", "CodeBleu_score": 21.56627628156923}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    if hash_method == \"sha256\":\n        asn1_code = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"sha384\":\n        asn1_code = b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"sha512\":\n        asn1_code = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise ValueError(\"Invalid hash method.\")\n    hash_value_with_asn1_code = asn1_code + hash_value\n    padded_hash_value = pad_for_signing(hash_value_with_asn1_code)\n    signature = priv_key.sign(padded_hash_value, padding.PKCS1v15(), hashes.SHA256())\n    return signature\n\n", "CodeBleu_score": 26.72654518981199}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n    try:\n        sig_int = int(binascii.hexlify(signature), 16)\n        clear_sig = pow(sig_int, 65537, pub_key)\n        clear_sig_hex = hex(clear_sig)[2:].rstrip(\"L\")\n        if len(clear_sig_hex) % 2:\n            clear_sig_hex = \"0\" + clear_sig_hex\n        clear_sig_bin = binascii.unhexlify(clear_sig_hex)\n        if clear_sig_bin[0:1] == \"\\x00\":\n            if clear_sig_bin[1:2] == \"\\x01\":\n                hash_name, hash_len = _get_hash_algo(clear_sig_bin[2:3])\n                hash_value = clear_sig_bin[3:3 + hash_len]\n                if hash_value == hashlib.new(hash_name, message).digest():\n                    return hash_name\n            else:\n                raise VerificationError(\"Invalid padding\")\n        else:\n            raise VerificationError(\"Invalid padding\")\n    except (ValueError, IndexError, TypeError):\n        raise VerificationError(\"Invalid signature\")", "CodeBleu_score": 35.33538950884176}, {"code": "def verify(message, signature, pub_key)\n    try:\n        # Convert the signature to an integer\n        sig_int = int.from_bytes(signature, byteorder='big')\n        # Decrypt the signature using the public key\n        clear_sig = pow(sig_int, pub_key.e, pub_key.n)\n        # Determine the hash method used\n        hash_method = HASH_METHODS[clear_sig % 256]\n        # Compute the hash of the message\n        message_hash = hash_method(message).digest()\n        # Reconstruct the expected padded hash\n        expected_hash = clear_sig.to_bytes(len(message_hash) + 1, byteorder='big')\n        # Verify the signature\n        if expected_hash!= b'\\x00' + message_hash:\n            raise VerificationError('Invalid signature')\n        return hash_method.__name__\n    except Exception as e:\n        raise VerificationError(e)", "CodeBleu_score": 38.58602562112863}, {"code": "def verify(message, signature, pub_key)\n    # Convert the signature to an integer\n    signature_int = int.from_bytes(signature, \"big\")\n    # Decrypt the signature\n    clear_signature = pow(signature_int, pub_key[1], pub_key[0])\n    # Determine the hash method used\n    hash_method = HASH_METHODS[clear_signature % 3]\n    # Compute the hash of the message\n    message_hash = hash_method(message).digest()\n    # Reconstruct the expected padded hash\n    expected_padded_hash = clear_signature // 3\n    # Check if the expected padded hash matches the clear signature\n    if expected_padded_hash!= message_hash:\n        raise VerificationError(\"Signature is not valid for the given message\")\n    # Return the hash method name\n    return hash_method.__name__\n\n", "CodeBleu_score": 30.616628766975985}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT()\ttime_t now;\n\ttime(&now);\n\tif (now == 0) {\n\t\tprintf(\"Failed to obtain time, using default JWT expiration time.\\n\");\n\t} else {\n\t\tprintf(\"Current time: %s\", ctime(&now));\n\t}\n\tif (generateJWT(now) == 0) {\n\t\tprintf(\"Failed to generate new JWT, using previous JWT.\\n\");\n\t}\n\tconnectToMQTTClient();\n\tmqtt_connected = true;\n\tmqtt_subscribe = true;\n\tprintf(\"Attempting to connect to MQTT server...\\n\");\n}\n", "CodeBleu_score": 39.446878071212744}, {"code": "static void connectMQTT()\t// Get current time\n\ttime_t now;\n\ttime(&now);\n\n\t// If time is valid, update the JWT\n\tif (now > 0) {\n\t\t// Update JWT\n\t\tupdateJWT(now);\n\t}\n\n\t// Connect to MQTT client\n\tmqtt_connect(&client);\n\n\t// Set flag to send MQTT SUBSCRIBE packet after connection is established\n\tsubscribe_after_connect = true;\n\n\t// Print debug message\n\tESP_LOGI(TAG, \"MQTT connection attempt\");\n}\n", "CodeBleu_score": 16.08023195566558}, {"code": "static void connectMQTT()\tif (getTime()) {\n\t\tupdateJWT();\n\t\tconnectMQTTClient();\n\t\tmqtt_subscribe = true;\n\t\tESP_LOGI(TAG, \"MQTT connection attempt\");\n\t}\n}\n", "CodeBleu_score": 13.7700259352246}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t result = 0;\n\tuint32_t digit;\n\tconst uint8_t* p = str;\n\n\tfor (int i = 0; i < width; i++) {\n\t\tdigit = *p - '0';\n\t\tif (digit > 9) {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + digit;\n\t\tp++;\n\t}\n\t*num = result;\n\treturn p;\n}\n", "CodeBleu_score": 24.577363502765444}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (str[i] - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}\n", "CodeBleu_score": 21.106283063498804}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif ((str[i] < '0') || (str[i] > '9')) {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (str[i] - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}\n", "CodeBleu_score": 19.52556749326112}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = 0;\n\tatcacert_def_t* cert_def = build_state->cert_def;\n\tuint8_t* cert_data = build_state->cert_data;\n\tsize_t cert_data_size = build_state->cert_data_size;\n\tsize_t cert_offset = build_state->cert_offset;\n\tsize_t cert_data_used = build_state->cert_data_used;\n\tsize_t cert_template_size = build_state->cert_template_size;\n\tsize_t cert_template_offset = build_state->cert_template_offset;\n\tsize_t cert_template_used = build_state->cert_template_used;\n\tsize_t cert_public_key_size = build_state->cert_public_key_size;\n\tsize_t cert_public_key_offset = build_state->cert_public_key_offset;\n\tsize_t cert_public_key_used = build_state->cert_public_key_used;\n\tsize_t cert_signature_size = build_state->cert_signature_size;\n\tsize_t cert_signature_offset = build_state->cert_signature_offset;\n\tsize_t cert_signature_used = build_state->cert_signature_used;\n\tsize_t cert_private_key_size = build_state->cert_private_key_size;\n\tsize_t cert_private_key_offset = build_state->cert_private_key_offset;\n\tsize_t cert_private_key_used = build_state->cert_private_key_used;\n\tsize_t cert_auth_key_size = build_state->cert_auth_key_size;\n\tsize_t cert_auth_key_offset = build_state->cert_auth_key_offset;\n\tsize_t cert_auth_key_used = build_state->cert_auth_key_used;\n\tsize_t cert_serial_num_size = build_state->cert_serial_num_size;\n\tsize_t cert_serial_num_offset = build_state->cert_serial_num_offset;\n\tsize_", "CodeBleu_score": 13.329004233365854}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = ATCA_SUCCESS;\n\tuint8_t signature[ATCA_SIG_SIZE];\n\tuint8_t public_key[ATCA_PUB_KEY_SIZE];\n\tuint8_t public_key_digest[ATCA_PUB_KEY_SIZE];\n\tuint8_t signer_id[ATCA_PUB_KEY_SIZE];\n\tuint8_t signer_id_digest[ATCA_PUB_KEY_SIZE];\n\tuint8_t signer_cert[ATCA_CERT_SIZE];\n\tuint8_t signer_cert_digest[ATCA_CERT_SIZE];\n\tuint8_t signer_cert_sn[ATCA_SERIAL_NUM_SIZE];\n\tuint8_t signer_cert_sn_digest[ATCA_SERIAL_NUM_SIZE];\n\tuint8_t signer_cert_sn_signer_id_digest[ATCA_SERIAL_NUM_SIZE + ATCA_PUB_KEY_SIZE];\n\tuint8_t signer_cert_sn_signer_id_digest_digest[ATCA_SERIAL_NUM_SIZE + ATCA_PUB_KEY_SIZE];\n\tuint8_t signer_cert_sn_signer_id_digest_digest_signer_cert_digest[ATCA_SERIAL_NUM_SIZE + ATCA_PUB_KEY_SIZE + ATCA_CERT_SIZE];\n\tuint8_t signer_cert_sn_signer_id_digest_digest_signer_cert_digest_public_key_digest[ATCA_SERIAL_NUM_SIZE + ATCA_PUB_KEY_SIZE + ATCA_CERT_SIZE + ATCA_PUB_KEY_SIZE];\n\tuint8_t signer_cert_sn_signer_id_digest_digest_signer_cert_digest_public_key_digest_signature[ATCA_SERIAL_NUM_SIZE + ATCA_PUB_KEY_SIZE + ATCA_CERT_SIZE + ATCA_PUB_KEY_SIZE + ATCA_SIG_SIZE];\n\tuint8_t signer_cert_sn_signer_id_digest_digest_signer_cert_digest_public_key_digest_signature_cert_digest[ATCA_SERIAL_NUM_SIZE + ATCA_PUB_KEY_SIZE + ATCA_CERT_SIZE", "CodeBleu_score": 5.66548086857516}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = ATCA_SUCCESS;\n\tuint8_t* cert_def_public_key_dev_loc = NULL;\n\tuint8_t* cert_def_public_key_ca_loc = NULL;\n\tuint8_t* cert_def_public_key_int_loc = NULL;\n\tuint8_t* cert_def_public_key_loc = NULL;\n\tuint8_t* cert_def_template_loc = NULL;\n\tuint8_t* cert_def_tbs_loc = NULL;\n\tuint8_t* cert_def_sn_source_loc = NULL;\n\tuint8_t* cert_def_expire_years_loc = NULL;\n\tuint8_t* cert_def_expire_months_loc = NULL;\n\tuint8_t* cert_def_expire_days_loc = NULL;\n\tuint8_t* cert_def_expire_hours_loc = NULL;\n\tuint8_t* cert_def_expire_minutes_loc = NULL;\n\tuint8_t* cert_def_expire_seconds_loc = NULL;\n\tuint8_t* cert_def_expire_date_loc = NULL;\n\tuint8_t* cert_def_expire_date_format_loc = NULL;\n\tuint8_t* cert_def_expire_date_format_size_loc = NULL;\n\tuint8_t* cert_def_expire_date_size_loc = NULL;\n\tuint8_t* cert_def_expire_date_offset_loc = NULL;\n\tuint8_t* cert_def_expire_date_default_loc = NULL;\n\tuint8_t* cert_def_expire_date_default_size_loc = NULL;\n\tuint8_t* cert_def_issue_date_format_loc = NULL;\n\tuint8_t* cert_def_issue_date_format_size_loc = NULL;\n\tuint8_t* cert_def_issue_date_size_loc = NULL;\n\tuint8_t* cert_def_issue_date_offset_loc = NULL;\n\tuint8_t* cert_def_issue_date_default_loc", "CodeBleu_score": 7.430037567356432}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])\tint ret = ATCA_SUCCESS;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tsize_t tbs_size;\n\tsize_t signature_size;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest, &tbs_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcah_verify_extern(tbs_digest, tbs_size, signature, signature_size, ca_public_key);\n\treturn ret;\n}\n", "CodeBleu_score": 59.348703143555696}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])\tint ret = ATCA_SUCCESS;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn atcah_verify_extern(ca_public_key, tbs_digest, signature);\n}\n", "CodeBleu_score": 59.09474726933441}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])\tint ret = ATCA_BAD_PARAM;\n\tuint8_t signature[64];\n\tuint8_t digest[32];\n\tsize_t  digest_size;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Get the size of the TBS portion of the certificate\n\tdigest_size = cert_def->cert_template_size + cert_def->std_cert_elements->tbs.size;\n\n\t// Get the signature from the certificate\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get the digest of the TBS portion of the certificate\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Verify the TBS digest against the signature using the CA public key\n\tret = atcah_verify_extern(digest, digest_size, signature, ca_public_key);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ATCA_SUCCESS;\n}\n", "CodeBleu_score": 64.33210725165203}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\t//printf(\"timer: %x\\n\", timer);\n\t//printf(\"list: %x\\n\", *list);\n\tif (timer == NULL || *list == NULL)\n\t\treturn false;\n\ttimerStruct_t *prev = NULL;\n\ttimerStruct_t *cur = *list;\n\twhile (cur!= NULL)\n\t{\n\t\tif (cur == timer)\n\t\t{\n\t\t\tif (prev == NULL)\n\t\t\t{\n\t\t\t\t//printf(\"Deleting head\\n\");\n\t\t\t\t*list = cur->next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//printf(\"Deleting middle\\n\");\n\t\t\t\tprev->next = cur->next;\n\t\t\t}\n\t\t\tfree(cur);\n\t\t\treturn true;\n\t\t}\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\treturn false;\n} }\n", "CodeBleu_score": 39.90720074385696}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\ttimerStruct_t * volatile *prev = list;\n\twhile (*prev) {\n\t\tif (*prev == timer) {\n\t\t\t*prev = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\tprev = &(*prev)->next;\n\t}\n\treturn false;\n}\n}\n", "CodeBleu_score": 17.799405199557285}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\tvolatile timerStruct_t *prev = 0;\n\tvolatile timerStruct_t *current = *list;\n\twhile(current!= 0)\n\t{\n\t\tif(current == timer)\n\t\t{\n\t\t\tif(prev!= 0)\n\t\t\t{\n\t\t\t\tprev->next = current->next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*list = current->next;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprev = current;\n\t\tcurrent = current->next;\n\t}\n\treturn false;\n}\n}\n", "CodeBleu_score": 25.98062750185265}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket)\tint status;\n\tstruct BSD_socket_info *socket_info;\n\tsocket_info = BSD_get_socket_info(socket);\n\tif (socket_info == NULL) {\n\t\terrno = EBADF;\n\t\treturn BSD_ERROR;\n\t}\n\tsocket_info->state = NOT_A_SOCKET;\n\tstatus = close(socket);\n\tif (status == -1) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = EBADF;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == EINTR) {\n\t\t\terrno = EINTR;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == EIO) {\n\t\t\terrno = EIO;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == EISDIR) {\n\t\t\terrno = EISDIR;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse {\n\t\t\terrno = EBADF;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 46.13961068959078}, {"code": "int BSD_close(int socket)\tstruct socket_info *info;\n\n\tinfo = get_socket_info(socket);\n\tif (info == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tinfo->state = NOT_A_SOCKET;\n\tif (close(socket) == -1) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = EBADF;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EINTR) {\n\t\t\terrno = EINTR;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EIO) {\n\t\t\terrno = EIO;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tif (errno == EINVAL) {\n\t\t\terrno = EINVAL;\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 42.96639258169129}, {"code": "int BSD_close(int socket)\tstruct BSD_socket *s;\n\tint ret;\n\n\ts = BSD_get_socket(socket);\n\tif (s == NULL) {\n\t\tBSD_errno = BSD_EBADF;\n\t\treturn BSD_ERROR;\n\t}\n\n\ts->state = NOT_A_SOCKET;\n\n\tret = close(s->sockfd);\n\tif (ret == -1) {\n\t\tBSD_errno = BSD_get_errno();\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 28.698265718718375}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog)\tint result = listen(socket, backlog);\n\tif (result == -1) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = BSD_EBADF;\n\t\t} else if (errno == ENOTSOCK) {\n\t\t\terrno = BSD_ENOTSOCK;\n\t\t} else if (errno == EOPNOTSUPP) {\n\t\t\terrno = BSD_EOPNOTSUPP;\n\t\t} else if (errno == EADDRINUSE) {\n\t\t\terrno = BSD_EADDRINUSE;\n\t\t} else if (errno == EADDRNOTAVAIL) {\n\t\t\terrno = BSD_EADDRNOTAVAIL;\n\t\t} else if (errno == EINVAL) {\n\t\t\terrno = BSD_EINVAL;\n\t\t} else if (errno == ENOBUFS) {\n\t\t\terrno = BSD_ENOBUFS;\n\t\t} else if (errno == ENOMEM) {\n\t\t\terrno = BSD_ENOMEM;\n\t\t} else {\n\t\t\terrno = BSD_EUNKNOWN;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 35.79024005187087}, {"code": "int BSD_listen(int socket, int backlog)\tint response = listen(socket, backlog);\n\tif (response == -1) {\n\t\tswitch (errno) {\n\t\tcase EBADF:\n\t\t\terrno = BSD_EBADF;\n\t\t\tbreak;\n\t\tcase ENOTSOCK:\n\t\t\terrno = BSD_ENOTSOCK;\n\t\t\tbreak;\n\t\tcase EOPNOTSUPP:\n\t\t\terrno = BSD_EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase EADDRINUSE:\n\t\t\terrno = BSD_EADDRINUSE;\n\t\t\tbreak;\n\t\tcase EADDRNOTAVAIL:\n\t\t\terrno = BSD_EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\terrno = BSD_EINVAL;\n\t\t\tbreak;\n\t\tcase ENOBUFS:\n\t\t\terrno = BSD_ENOBUFS;\n\t\t\tbreak;\n\t\tcase ENOMEM:\n\t\t\terrno = BSD_ENOMEM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = BSD_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 38.63247066011394}, {"code": "int BSD_listen(int socket, int backlog)\tint result;\n\n\tresult = listen(socket, backlog);\n\tif (result == -1) {\n\t\tswitch (errno) {\n\t\tcase EBADF:\n\t\t\terrno = BSD_EBADF;\n\t\t\tbreak;\n\t\tcase ENOTSOCK:\n\t\t\terrno = BSD_ENOTSOCK;\n\t\t\tbreak;\n\t\tcase EOPNOTSUPP:\n\t\t\terrno = BSD_EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase EADDRINUSE:\n\t\t\terrno = BSD_EADDRINUSE;\n\t\t\tbreak;\n\t\tcase EADDRNOTAVAIL:\n\t\t\terrno = BSD_EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\terrno = BSD_EINVAL;\n\t\t\tbreak;\n\t\tcase ENOBUFS:\n\t\t\terrno = BSD_ENOBUFS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = BSD_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 38.65205813249661}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tif (addr == NULL) {\n\t\treturn -1;\n\t}\n\tif (addrlen == NULL) {\n\t\treturn -1;\n\t}\n\tstruct sockaddr_in *addr_in = (struct sockaddr_in *)addr;\n\tif (addr_in->sin_family!= AF_INET) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\tint ret = accept(socket, (struct sockaddr *)addr_in, addrlen);\n\tif (ret == -1) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = EINVAL;\n\t\t}\n\t\treturn -1;\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 32.56162303363251}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tstruct sockaddr_in *addr_in = (struct sockaddr_in *)addr;\n\tint ret;\n\tif (addr_in->sin_family!= AF_INET) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\tret = accept(socket, (struct sockaddr *)addr_in, addrlen);\n\tif (ret < 0) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = EBADF;\n\t\t} else if (errno == ENOTSOCK) {\n\t\t\terrno = ENOTSOCK;\n\t\t} else if (errno == EOPNOTSUPP) {\n\t\t\terrno = EOPNOTSUPP;\n\t\t} else if (errno == EFAULT) {\n\t\t\terrno = EFAULT;\n\t\t} else if (errno == EINVAL) {\n\t\t\terrno = EINVAL;\n\t\t} else if (errno == ENOMEM) {\n\t\t\terrno = ENOMEM;\n\t\t} else if (errno == ECONNABORTED) {\n\t\t\terrno = ECONNABORTED;\n\t\t} else if (errno == EPROTO) {\n\t\t\terrno = EPROTO;\n\t\t} else if (errno == EINTR) {\n\t\t\terrno = EINTR;\n\t\t} else if (errno == ECONNRESET) {\n\t\t\terrno = ECONNRESET;\n\t\t} else if (errno == ENOBUFS) {\n\t\t\terrno = ENOBUFS;\n\t\t} else if (errno == ETIMEDOUT) {\n\t\t\terrno = ETIMEDOUT;\n\t\t} else if (errno == ECONNREFUSED) {\n\t\t\terrno = ECONNREFUSED;\n\t\t} else if (errno == EHOSTDOWN) {\n\t\t\terrno = EHOSTDOWN;\n\t\t} else if (errno == EHOSTUNREACH) {\n\t\t\terrno = EHOSTUNREACH;\n\t\t} else if (errno == EADDRINUSE) {\n\t\t\terrno = EADDRINUSE;\n\t\t} else if (errno == EADDRNOTAVAIL) {\n\t\t\terrno = EADDRNOTAVAIL;\n\t\t} else if (errno == EAFNOSUPPORT) {\n\t\t\terrno = EAFNOSUPPORT;\n\t\t} else if (errno == EALREADY) {\n\t\t\terrno = EALREADY;\n\t\t} else if (errno == EACCES) {\n\t\t\terrno = EACCES", "CodeBleu_score": 33.59056565351663}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret;\n\tstruct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n\tstruct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *) addr;\n\tstruct sockaddr_un *addr_un = (struct sockaddr_un *) addr;\n\tstruct sockaddr_storage *addr_storage = (struct sockaddr_storage *) addr;\n\n\tif (addr == NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (addrlen == NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tif (addrlen!= NULL) {\n\t\t\t*addrlen = sizeof(struct sockaddr_in);\n\t\t}\n\t\tret = accept(socket, (struct sockaddr *) addr_in, addrlen);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (addrlen!= NULL) {\n\t\t\t*addrlen = sizeof(struct sockaddr_in6);\n\t\t}\n\t\tret = accept(socket, (struct sockaddr *) addr_in6, addrlen);\n\t\tbreak;\n\tcase AF_UNIX:\n\t\tif (addrlen!= NULL) {\n\t\t\t*addrlen = sizeof(struct sockaddr_un);\n\t\t}\n\t\tret = accept(socket, (struct sockaddr *) addr_un, addrlen);\n\t\tbreak;\n\tcase AF_UNSPEC:\n\t\tif (addrlen!= NULL) {\n\t\t\t*addrlen = sizeof(struct sockaddr_storage);\n\t\t}\n\t\tret = accept(socket, (struct sockaddr *) addr_storage, addrlen);\n\t\tbreak;\n\tdefault:\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\n\tif (ret == -1) {\n\t\tswitch (socket) {\n\t\tcase SOCK_STREAM:\n\t\t\terrno = ENOTCONN;\n\t\t\tbreak;\n\t\tcase SOCK_DGRAM:\n\t\t\terrno = EOPNOTSUPP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = EINVAL;\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 38.559783980287776}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT()\ttime_t now;\n\tstruct tm timeinfo;\n\ttime(&now);\n\tlocaltime_r(&now, &timeinfo);\n\n\tif (timeinfo.tm_year < (2016 - 1900)) {\n\t\tESP_LOGI(TAG, \"Time is not set yet. Connecting to WiFi and getting time over NTP.\");\n\t\tconnectToWiFi();\n\t\tgetTime();\n\t\tupdateJWT();\n\t} else {\n\t\tupdateJWT();\n\t}\n\n\tmqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\tmqttClient.setCallback(mqttCallback);\n\n\tESP_LOGI(TAG, \"Connecting to %s:%d\", MQTT_HOST, MQTT_PORT);\n\tmqttClient.connect(MQTT_CLIENT_ID, MQTT_USER, MQTT_PASS, MQTT_LWT_TOPIC, 0, 1, MQTT_LWT_MSG);\n\tmqttClient.subscribe(MQTT_SUB_TOPIC, 0);\n\tESP_LOGI(TAG, \"Subscribing to %s\", MQTT_SUB_TOPIC);\n}\n", "CodeBleu_score": 35.34249643389761}, {"code": "static void connectMQTT()\tESP_LOGI(TAG, \"Connecting to MQTT...\");\n\tesp_mqtt_client_config_t mqtt_cfg = {\n\t\t.uri = CONFIG_AWS_IOT_MQTT_BROKER_ENDPOINT,\n\t\t.event_handle = mqtt_event_handler,\n\t\t.user_context = NULL,\n\t};\n\tmqtt_client = esp_mqtt_client_init(&mqtt_cfg);\n\tesp_mqtt_client_start(mqtt_client);\n}\n", "CodeBleu_score": 6.800442633951782}, {"code": "static void connectMQTT()\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\tlong long current_time = tv.tv_sec;\n\tif (current_time < 1510592825) {\n\t\tprintf(\"Time is not yet valid. Skipping MQTT connection\\n\");\n\t\treturn;\n\t}\n\tupdateJWT(current_time);\n\tMQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;\n\tMQTTClient_SSLOptions ssl_opts = MQTTClient_SSLOptions_initializer;\n\tMQTTClient_create(&client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL);\n\tconn_opts.keepAliveInterval = 20;\n\tconn_opts.cleansession = 1;\n\tconn_opts.username = TOKEN;\n\tconn_opts.password = ;\n\tssl_opts.enableServerCertAuth = 1;\n\tssl_opts.trustStore = TRUSTSTORE;\n\tconn_opts.ssl = &ssl_opts;\n\tMQTTClient_setCallbacks(client, NULL, connlost, msgarrvd, delivered);\n\tif ((rc = MQTTClient_connect(client, &conn_opts))!= MQTTCLIENT_SUCCESS) {\n\t\tprintf(\"Failed to connect, return code %d\\n\", rc);\n\t\texit(EXIT_FAILURE);\n\t}\n\tprintf(\"Successfully connected\\n\");\n\tsendSubscribe = 1;\n}\n", "CodeBleu_score": 32.43404070391994}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void)\tif (mqtt_client_state == CONNECTED) {\n\t\tMQTTClient_connectionInfo(client, &conn_info);\n\t\tLOG_INFO(\"MQTT client disconnected from %s:%d\", conn_info.host, conn_info.port);\n\t\tMQTTClient_disconnect(client, 10000);\n\t}\n}\n", "CodeBleu_score": 40.191061784145}, {"code": "void CLOUD_disconnect(void)\tif (mqtt_client.is_connected) {\n\t\tconst esp_mqtt_client_config_t *config = esp_mqtt_client_get_config(mqtt_client);\n\t\tESP_LOGD(TAG, \"Disconnecting from MQTT broker %s:%d\", config->uri, config->port);\n\t\tesp_mqtt_client_disconnect(mqtt_client);\n\t}\n}\n", "CodeBleu_score": 34.74856841982263}, {"code": "void CLOUD_disconnect(void)\tif (mqttClient.isConnected()) {\n\t\tCLOUD_log(DEBUG, \"MQTT disconnecting\");\n\t\tCLOUD_log(DEBUG, \"MQTT client info: %s:%d\", mqttClient.getServer(), mqttClient.getPort());\n\t\tmqttClient.disconnect();\n\t}\n}\n", "CodeBleu_score": 41.96003416794182}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\t// Attempt to connect to a Wi-Fi access point using either new credentials or default credentials.\n\tif (passed_wifi_creds == 1) {\n\t\t// Attempt to connect to a Wi-Fi access point using new credentials.\n\t\tif (WiFi.begin(ssid, password) == WL_CONNECTED) {\n\t\t\t// If the connection succeeds, return true.\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// If the connection fails, log an error message, update the networking error status, and return false.\n\t\t\tSerial.println(\"Failed to connect to Wi-Fi access point using new credentials.\");\n\t\t\tnetworking_error_status = 1;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// Attempt to connect to a Wi-Fi access point using default credentials.\n\t\tif (WiFi.begin() == WL_CONNECTED) {\n\t\t\t// If the connection succeeds, return true.\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// If the connection fails, log an error message, update the networking error status, and return false.\n\t\t\tSerial.println(\"Failed to connect to Wi-Fi access point using default credentials.\");\n\t\t\tnetworking_error_status = 1;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 39.26142908181043}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\t// If new credentials are passed, attempt to connect to the access point using the specified SSID, authentication type, and password\n\tif (passed_wifi_creds) {\n\t\tif (WiFi.begin(ssid, auth_type, password)) {\n\t\t\t// If the connection succeeds, return true\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// If the connection fails, log an error message, update the networking error status, and return false\n\t\t\tSerial.println(F(\"Failed to connect to the specified Wi-Fi access point.\"));\n\t\t\tnetworking_error = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If no new credentials are passed, attempt to connect to the access point using the default Wi-Fi settings\n\telse {\n\t\tif (WiFi.begin()) {\n\t\t\t// If the connection succeeds, return true\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// If the connection fails, log an error message, update the networking error status, and return false\n\t\t\tSerial.println(F(\"Failed to connect to the default Wi-Fi access point.\"));\n\t\t\tnetworking_error = true;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.51790771620312}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\tif (passed_wifi_creds) {\n\t\t// Attempt to connect to the specified Wi-Fi access point using the specified SSID, authentication type, and password\n\t\tif (WiFi.begin(ssid, auth_type, password) == WL_CONNECTED) {\n\t\t\tSerial.println(\"Connected to Wi-Fi network\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tSerial.println(\"Failed to connect to Wi-Fi network\");\n\t\t\tnetwork_error = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// Attempt to connect to the default Wi-Fi access point using the default SSID, authentication type, and password\n\t\tif (WiFi.begin(default_ssid, default_auth_type, default_password) == WL_CONNECTED) {\n\t\t\tSerial.println(\"Connected to Wi-Fi network\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tSerial.println(\"Failed to connect to Wi-Fi network\");\n\t\t\tnetwork_error = true;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.02291632264152}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map)\t// Create a new client with the provided API URL\n\tconst client = new ApolloClient({\n\t\turi: \"https://api.netatmo.com/api/getpublicsensors\",\n\t});\n\t// Send a GraphQL query to fetch sensor data\n\tconst { data } = await client.query({\n\t\tquery: gql`\n\t\t\tquery {\n\t\t\t\tsensors {\n\t\t\t\t\t_id\n\t\t\t\t\tplace {\n\t\t\t\t\t\tlocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`,\n\t});\n\t// Log the API response\n\tconsole.log(data);\n\t// If the response contains data, log the retrieval of sensors\n\tif (data) {\n\t\tconsole.log(\"Retrieved sensors\");\n\t\t// Iterate through each sensor\n\t\tdata.sensors.forEach((sensor) => {\n\t\t\t// Create a marker at the sensor's geographical coordinates\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: {\n\t\t\t\t\tlat: sensor.place.location[0],\n\t\t\t\t\tlng: sensor.place.location[1],\n\t\t\t\t},\n\t\t\t\tmap,\n\t\t\t});\n\t\t});\n\t}\n}\n", "CodeBleu_score": 38.045607981683546}, {"code": "async function DisplaySensors(map)\tconst client = new ApolloClient({\n\t\turi: \"https://api.airqo.net/api/v1/graphql\",\n\t\tcache: new InMemoryCache(),\n\t});\n\n\tconst { data } = await client.query({\n\t\tquery: gql`\n\t\t\tquery {\n\t\t\t\tsensors {\n\t\t\t\t\tid\n\t\t\t\t\tname\n\t\t\t\t\tlongitude\n\t\t\t\t\tlatitude\n\t\t\t\t\tlocation\n\t\t\t\t\towner {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`,\n\t});\n\n\tconsole.log(\"Sensors retrieved:\", data);\n\n\tif (data.sensors) {\n\t\tconsole.log(\"Sensors retrieved\");\n\n\t\tdata.sensors.forEach((sensor) => {\n\t\t\tconst marker = new mapboxgl.Marker()\n\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t.addTo(map);\n\n\t\t\tmarker.getElement().addEventListener(\"click\", () => {\n\t\t\t\tconst popup = new mapboxgl.Popup({ closeOnClick: false })\n\t\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t\t.setHTML(\n\t\t\t\t\t\t`<h1>${sensor.name}</h1><p>${sensor.location}</p><p>${sensor.owner.name}</p>`\n\t\t\t\t\t)\n\t\t\t\t\t.addTo(map);\n\n\t\t\t\tmarker.getElement().addEventListener(\"mouseleave\", () => {\n\t\t\t\t\tpopup.remove();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n}\n", "CodeBleu_score": 33.664326360483486}, {"code": "async function DisplaySensors(map)\t// Create a client to send GraphQL queries to the API.\n\tconst client = new GraphQLClient(API_URL, {\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${API_TOKEN}`,\n\t\t},\n\t});\n\n\t// Send a GraphQL query to fetch sensor data.\n\tconst response = await client.request(\n\t\t`query {\n\t\t\tsensors {\n\t\t\t\tid\n\t\t\t\tname\n\t\t\t\tlocation {\n\t\t\t\t\tlatitude\n\t\t\t\t\tlongitude\n\t\t\t\t}\n\t\t\t}\n\t\t}`\n\t);\n\n\t// Log the API response.\n\tconsole.log(response);\n\n\t// If the response contains data, log the retrieval of sensors.\n\tif (response.data) {\n\t\tconsole.log(\"Retrieved sensors:\");\n\t}\n\n\t// Iterate through each sensor in the response data.\n\tfor (const sensor of response.data.sensors) {\n\t\t// Create a marker for the sensor.\n\t\tconst marker = new google.maps.Marker({\n\t\t\tposition: {\n\t\t\t\tlat: sensor.location.latitude,\n\t\t\t\tlng: sensor.location.longitude,\n\t\t\t},\n\t\t\tmap: map,\n\t\t\ttitle: sensor.name,\n\t\t});\n\n\t\t// Add a click event listener to the marker.\n\t\tmarker.addListener(\"click\", () => {\n\t\t\t// Display the sensor's name and ID in a popup.\n\t\t\tconst contentString = `<div>\n\t\t\t\t<h1>${sensor.name}</h1>\n\t\t\t\t<p>ID: ${sensor.id}</p>\n\t\t\t</div>`;\n\t\t\tconst infowindow = new google.maps.InfoWindow({\n\t\t\t\tcontent: contentString,\n\t\t\t});\n\t\t\tinfowindow.open(map, marker);\n\t\t});\n\t}\n}\n", "CodeBleu_score": 41.2033708798022}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.border = `2px solid ${sensor.color}`;\n\treturn marker;\n};\n", "CodeBleu_score": 34.255508917208196}, {"code": "const CreateSensorMarker = (sensor) =>\tlet marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"rgb(0, 0, 0)\";\n\tmarker.style.border = \"1px solid black\";\n\treturn marker;\n};\n", "CodeBleu_score": 32.631165317927326}, {"code": "const CreateSensorMarker = (sensor) =>\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"#000000\";\n\tmarker.style.border = \"3px solid #000000\";\n\treturn marker;\n};\n", "CodeBleu_score": 32.964434432272974}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    if module_name in _MFA_MODULES:\n        return _MFA_MODULES[module_name]\n\n    module_path = f\"homeassistant.components.mfa.{module_name}\"\n\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Failed to import MFA module %s: %s\",\n            module_name,\n            err,\n            exc_info=True,\n        )\n        raise MFAModuleNotFound(module_name) from err\n\n    if not _MFA_MODULES.get(module_name):\n        _MFA_MODULES[module_name] = module\n\n    return module\n\n", "CodeBleu_score": 35.98509293955623}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"homeassistant.components.auth.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import module %s: %s\", module_path, err)\n        raise\n\n    if module.REQUIREMENTS and not _SKIP_PIP:\n        requirements = module.REQUIREMENTS\n        if module.REQUIREMENTS_PROCESSOR:\n            requirements = module.REQUIREMENTS_PROCESSOR(hass)\n        if requirements not in _REQUIREMENTS_PROCESSED:\n            _REQUIREMENTS_PROCESSED.add(requirements)\n            await async_process_requirements(hass, requirements)\n\n    return module\n\n", "CodeBleu_score": 42.374754840406595}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"homeassistant.components.auth.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import module %s: %s\", module_path, err)\n        raise err\n\n    if module.REQUIREMENTS and not skip_pip:\n        requirements = module.REQUIREMENTS\n        if requirements not in processed_requirements:\n            processed_requirements.add(requirements)\n            await hass.async_add_executor_job(\n                pip_install, requirements, _LOGGER, \"auth\"\n            )\n\n    return module\n\n", "CodeBleu_score": 40.58805317992976}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    user_entry = next((entry for entry in self.data if entry[\"user_id\"] == user_id), None)\n    if user_entry:\n        user_entry[\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data.append({\"user_id\": user_id, \"pin\": setup_data[\"pin\"]})\n    return setup_data\n\n", "CodeBleu_score": 40.41474312504442}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n", "CodeBleu_score": 33.71592039459607}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    # Extract the PIN from the setup data\n    pin = setup_data[\"pin\"]\n    # Check if the user already has an entry in the internal data list\n    user_entry = next((entry for entry in self.data if entry[\"user_id\"] == user_id), None)\n    # Update the PIN if the user already has an entry\n    if user_entry:\n        user_entry[\"pin\"] = pin\n    # Add a new entry with the user ID and PIN if the user doesn't have an entry yet\n    else:\n        self.data.append({\"user_id\": user_id, \"pin\": pin})\n    # Return the setup data\n    return setup_data\n\n", "CodeBleu_score": 47.27052893846736}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._loaded:\n            return\n        try:\n            self._data = await self._store.get_data()\n        except Exception as e:\n            logger.warning(\n                f\"Failed to load user settings from store {self._store}: {e}\"\n            )\n            self._data = {}\n        if not isinstance(self._data, dict):\n            logger.warning(\n                f\"Failed to load user settings from store {self._store}: data is not a dict\"\n            )\n            self._data = {}\n        for user_id, data in self._data.items():\n            if not isinstance(user_id, str):\n                logger.warning(\n                    f\"Failed to load user settings from store {self._store}: user_id is not a str\"\n                )\n                continue\n            if not isinstance(data, dict):\n                logger.warning(\n                    f\"Failed to load user settings from store {self._store}: data for user {user_id} is not a dict\"\n                )\n                continue\n            try:\n                self._settings[user_id] = NotifySetting(**data)\n            except Exception as e:\n                logger.warning(\n                    f\"Failed to load user settings from store {self._store}: failed to create NotifySetting for user {user_id}: {e}\"\n                )\n                continue\n        self._loaded = True\n\n", "CodeBleu_score": 27.93707120539778}, {"code": "async def _async_load(self) -> None\n    if self._init_lock.locked():\n        return\n\n    async with self._init_lock:\n        if self._is_loaded:\n            return\n\n        user_data = await self.user_store.get_user_data()\n\n        if not user_data:\n            user_data = {}\n\n        self._users = {\n            user_id: NotifySetting(user_id, user_data.get(str(user_id), {}))\n            for user_id in user_data\n        }\n\n        self._is_loaded = True\n\n", "CodeBleu_score": 39.87248825082323}, {"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._loaded:\n            return\n        data = await self.store.get_data(self._user_settings_key)\n        if not data:\n            data = {}\n        self._user_settings = {}\n        for user_id, user_data in data.items():\n            self._user_settings[user_id] = NotifySetting(user_id, user_data)\n        self._loaded = True\n\n", "CodeBleu_score": 36.06350834185803}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    if not self.user_settings.get(user_id):\n        await self.async_load_user_settings(user_id)\n    if not self.user_settings.get(user_id):\n        return False\n    notification_settings = self.user_settings[user_id][\"notification_settings\"]\n    if not notification_settings:\n        return False\n    otp = user_input[\"otp\"]\n    executor_job = await self.executor.submit(\n        self.validate_otp, otp, notification_settings[\"otp_secret\"]\n    )\n    return executor_job.result()", "CodeBleu_score": 47.70234265822056}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self.async_load_user_settings(user_id)\n    settings = self.get_user_settings(user_id)\n    if not settings:\n        return False\n\n    async def validate_otp(user_input: dict[str, Any]) -> bool:\n        \"\"\"The function \"validate_otp\" asynchronously validates the user input for the OTP code.\\nIt checks if the user input contains the \"otp\" key and its value is a string.\\nIf the OTP code is valid, it returns True. Otherwise, it returns False.\"\"\"\n        if \"otp\" not in user_input or not isinstance(user_input[\"otp\"], str):\n            return False\n\n        return True\n\n    return await self.executor.async_submit(validate_otp, user_input)\n\n", "CodeBleu_score": 49.82774234968906}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self.async_load_user_settings(user_id)\n    user_settings = self.user_settings.get(user_id)\n    if user_settings is None:\n        return False\n    if user_input.get(\"otp\") is None:\n        return False\n    try:\n        await self.executor.async_submit(\n            self.validate_otp, user_settings, user_input[\"otp\"]\n        )\n        return True\n    except OTPValidationError:\n        return False\n\n", "CodeBleu_score": 53.5930878294701}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n    device = entity.device\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    area = area_dict.get(area_id)\n    if area is None:\n        return None\n    return area.value\n\n", "CodeBleu_score": 52.1951147088775}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    area_entry = area_dict.get(area_id)\n    if area_entry is None:\n        return None\n\n    return area_entry.value\n\n", "CodeBleu_score": 64.30506212642176}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.entity_registry.async_get(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.device_registry.async_get(entity.device_id)\n    if not device or not device.area_id:\n        return None\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 50.9474001536815}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [p[category] for p in policies if category in p]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 60.599093078413134}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_category(\n                    [policy[category] for policy in policies]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 61.024998926374984}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: dict[str, dict[str, list[str]]] = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, data in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [policy[category] for policy in policies]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 47.194484470466556}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    module = importlib.import_module(f\"homeassistant.components.auth_providers.{provider}\")\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    requirements = set(module.REQUIREMENTS)\n    if not requirements:\n        return module\n\n    processed_requirements = await async_process_requirements(\n        hass, requirements, \"auth provider\"\n    )\n    module.REQUIREMENTS = list(processed_requirements)\n    return module\n\n", "CodeBleu_score": 31.18494720183894}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(f\"homeassistant.components.auth_providers.{provider}\")\n    except ImportError:\n        _LOGGER.error(\n            \"Unable to import authentication provider %s\",\n            provider,\n            exc_info=True,\n        )\n        raise HomeAssistantError(\n            f\"Unable to import authentication provider {provider}\"\n        ) from None\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    requirements = set(module.REQUIREMENTS)\n    if not requirements:\n        return module\n\n    processed_requirements = hass.config.processed_requirements\n    if processed_requirements is None:\n        _LOGGER.error(\n            \"Unable to import authentication provider %s because it has requirements but the config entry is not set up yet\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"Unable to import authentication provider {provider} because it has requirements but the config entry is not set up yet\"\n        ) from None\n\n    if not processed_requirements.isdisjoint(requirements):\n        _LOGGER.error(\n            \"Unable to import authentication provider %s because it has requirements that are already installed\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"Unable to import authentication provider {provider} because it has requirements that are already installed\"\n        ) from None\n\n    processed_requirements.update(requirements)\n    return module\n\n", "CodeBleu_score": 38.60929561821601}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    if provider in _loaded_auth_providers:\n        return _loaded_auth_providers[provider]\n\n    try:\n        module = importlib.import_module(f\"homeassistant.components.auth.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import authentication provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to import authentication provider {provider}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"async_get_requirements\"):\n        return module\n\n    requirements = await module.async_get_requirements(hass)\n\n    if not requirements:\n        return module\n\n    processed_requirements = await async_process_requirements(\n        hass, requirements, \"auth_provider\"\n    )\n\n    if processed_requirements is not None:\n        _loaded_auth_providers[provider] = module\n\n    return module\n\n", "CodeBleu_score": 52.547963315793126}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n    if not self._store:\n        return\n\n    try:\n        self._users = await self._store.async_load()\n    except StoreUnavailable:\n        self._users = []\n\n    self._users = [\n        User(username=user[\"username\"], password=user[\"\"])\n        for user in self._users\n        if not is_normalized(user[\"username\"])\n    ]\n\n", "CodeBleu_score": 32.642782337512855}, {"code": "async def async_load(self) -> None\n    try:\n        self._users = await self.store.async_load()\n    except FileNotFoundError:\n        self._users = []\n\n    for user in self._users:\n        if user[\"username\"]!= normalize(user[\"username\"]):\n            user[\"username\"] = normalize(user[\"username\"])\n            await self.store.async_save(self._users)\n\n", "CodeBleu_score": 26.91369168642584}, {"code": "async def async_load(self) -> None\n    self.users = await self.store.async_load()\n    if not self.users:\n        self.users = []\n    for user in self.users:\n        if not user[\"username\"]:\n            user[\"username\"] = normalize_username(user[\"username\"])\n    await self.store.async_save(self.users)\n\n", "CodeBleu_score": 24.028849040916207}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n    username = normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(\"utf-8\"), user.password.encode(\"utf-8\")):\n                return\n            else:\n                raise InvalidAuth(f\"Invalid password for user {username}.\")\n    bcrypt.checkpw(b\"dummy\", dummy_hash)\n    raise InvalidAuth(f\"Invalid username {username}.\")", "CodeBleu_score": 38.99681060177409}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = normalize('NFKC', username)\n    dummy_hash = bcrypt.hashpw(b'dummy', bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode('utf-8'), user.password_hash.encode('utf-8')):\n                return\n            else:\n                raise InvalidAuth('Invalid password')\n    bcrypt.checkpw(b'dummy', dummy_hash)\n    raise InvalidAuth('Invalid username')\n", "CodeBleu_score": 36.878585018022285}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b'1', bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password.encode('utf-8')\n            if bcrypt.checkpw(password.encode('utf-8'), stored_hash):\n                return\n            else:\n                raise InvalidAuth()\n    if bcrypt.checkpw(password.encode('utf-8'), dummy_hash):\n        raise InvalidAuth()\n    else:\n        raise InvalidAuth()\n", "CodeBleu_score": 37.61727815939174}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n    username = normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(message=\"user_not_found\")\n", "CodeBleu_score": 30.447577566562973}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 27.737411357011872}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = self.normalize_username(username)\n    if username in self.users:\n        self.users.remove(username)\n    else:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 25.751221828362215}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.data:\n      await self.async_initialize()\n    try:\n      self.data.pop(credentials.data[DOMAIN_USERNAME])\n      await self.async_save_data(self.data)\n    except KeyError:\n      pass\n\n  async def async_update_listener(self, event: Event) -> None:\n    \"\"\"The function \"async_update_listener\" handles the update of the authentication data when the event \"homeassistant.components.sensor.update\" is received.\\nIt then attempts to update the authentication data associated with the given username and save the changes.\\nIf the user is invalid, it catches and ignores the exception.\"\"\"\n    if event.data[DOMAIN_USERNAME] in self.data:\n      self.data[event.data[DOMAIN_USERNAME]] = event.data\n      await self.async_save_data(self.data)\n\n  async def async_save_data(self, data: dict) -> None:\n    \"\"\"The function \"async_save_data\" saves the authentication data in the file \"sensor_data.json\".\"\"\"\n    await self.async_write_json_config_file(DOMAIN_DATA_FILE, data)\n\n  async def async_initialize(self) -> None:\n    \"\"\"The function \"async_initialize\" initializes the authentication data.\\nIf the file \"sensor_data.json\" exists, it reads and stores it.\\nOtherwise, it creates a new file and initializes it with an empty dictionary.\"\"\"\n    self.data = await self.async_read_json_config_file(DOMAIN_DATA_FILE)\n    if not self.data:\n      self.data = {}\n      await self.async_save_data(self.data)\n\n  async def async_get_authentication(self, username: str) -> dict:\n    \"\"\"The function \"async_get_authentication\" returns the authentication data associated with the given username.\\nIf the data is not initialized, it initializes it first.\\nIt then returns the authentication data associated with the given username.\\nIf the user is invalid, it catches and returns an empty dictionary.\"\"\"\n    if not self.data:\n      await self.async_initialize()\n    try:\n      return self.data[username]\n    except KeyError:\n      return {}\n\n  async def async_get_authentication_from_event(self, event: Event) -> dict:\n    \"\"\"The function \"async_get_authentication_from_", "CodeBleu_score": 39.19849284067319}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if self._data is None:\n      await self.async_initialize()\n    try:\n      self._data.remove_user(credentials.data[CONF_USERNAME])\n      await self.async_save_data()\n    except KeyError:\n      pass", "CodeBleu_score": 51.149931340838904}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if self._data is None:\n        await self.async_initialize()\n\n    try:\n        self._data.pop(credentials.username)\n        await self.async_save_data()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 51.0301926971944}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        timeout_for_thread = timeout / len(threads)\n        thread.join(timeout_for_thread)\n        if thread.is_alive():\n            if log:\n                logger.warning(\n                    f\"Thread {thread.name} still running after {timeout_for_thread} seconds\"\n                )\n            thread.raise_exc(SystemExit)\n    return joined\n\n", "CodeBleu_score": 51.010766992468334}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        timeout_thread = timeout / len(threads)\n        thread.join(timeout=timeout_thread)\n        if thread.is_alive():\n            if log:\n                print(f\"Thread {thread.name} is still running after {timeout_thread} seconds.\")\n            thread._stop()\n    return joined\n\n", "CodeBleu_score": 53.98263430205229}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        timeout_ = timeout / len(threads)\n        thread.join(timeout=timeout_)\n        if log and thread.is_alive():\n            log_warning(f\"Thread {thread.name} is still running after {timeout_} seconds\")\n        if thread.is_alive():\n            thread.raise_exc(SystemExit)\n    return joined\n\n", "CodeBleu_score": 53.02037233254615}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n    if not hasattr(threading, \"_shutdown\") or threading._shutdown is None:\n        return\n\n    remaining_threads = threading._active.copy()\n    remaining_threads.pop(threading.get_ident(), None)\n    remaining_threads.pop(threading.main_thread().ident, None)\n    for thread in remaining_threads.values():\n        if thread.is_daemon():\n            continue\n        thread.join(timeout=threading._shutdown / len(remaining_threads))\n        if thread.is_alive():\n            logging.warning(\"Failed to join thread %s\", thread)\n\n", "CodeBleu_score": 35.11087736426439}, {"code": "def deadlock_safe_shutdown() -> None\n    if not threading.current_thread() == threading.main_thread():\n        raise RuntimeError(\"deadlock_safe_shutdown() can only be called from the main thread.\")\n\n    # Get the list of all non-main, non-daemon, alive threads.\n    non_main_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon\n    ]\n\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\n    timeout = _SHUTDOWN_TIMEOUT / len(non_main_threads)\n\n    # Attempt to join each thread within the calculated timeout.\n    for thread in non_main_threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            logging.warning(f\"Thread {thread.name} failed to join within {timeout} seconds.\")\n\n", "CodeBleu_score": 50.44017546581653}, {"code": "def deadlock_safe_shutdown() -> None\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.current_thread() and not thread.daemon\n    ]\n    if threads:\n        logger.warning(\n            \"Attempting to join %d non-daemon threads before shutdown\", len(threads)\n        )\n        for thread in threads:\n            thread.join(timeout=max(0.001, SHUTDOWN_TIMEOUT / len(threads)))\n            if thread.is_alive():\n                logger.warning(\n                    \"Unable to join thread %s, shutting down anyway\", thread.name\n                )\n\n", "CodeBleu_score": 39.991341833737096}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self.async_dispatcher_send(\n            self.signal_internal, remaining_with_setup_started\n        )\n    else:\n        self._remaining_with_setup_started = None\n\n", "CodeBleu_score": 40.97520262978875}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n        self._remaining_setups_with_started_time = remaining_with_setup_started\n        self._async_dispatcher_send(\n            self._async_dispatcher_connect_signal_name, remaining_with_setup_started\n        )\n    else:\n        self._remaining_setups_with_started_time = {}\n    self._has_remaining_setups = bool(remaining_with_setup_started)\n\n", "CodeBleu_score": 36.600918337973766}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self.hass.bus.async_fire(\n            SIGNAL_DISPATCHER_DISPATCH_REMAINING,\n            {ATTR_REMAINING_WITH_SETUP_STARTED: self._remaining_with_setup_started},\n        )\n    else:\n        self._remaining_with_setup_started = {}\n        self.hass.bus.async_fire(SIGNAL_DISPATCHER_DISPATCH_REMAINING, {})\n\n", "CodeBleu_score": 35.52099614070848}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\n    # Check if bluetooth.py is in the configuration cache\n    if \"bluetooth.py\" in config.config_cache:\n        # If it is, read the content of bluetooth.py from the cache\n        bluetooth_content = config.config_cache[\"bluetooth.py\"]\n    else:\n        # If it isn't, read the content of bluetooth.py from the filesystem\n        with open(os.path.join(config.config_dir, \"custom_components\", \"bluetooth.py\"), \"r\", encoding=\"utf-8\") as file:\n            bluetooth_content = file.read()\n\n    # Generate the expected content of bluetooth.py\n    expected_content = generate_content(integrations)\n\n    # Validate the content of bluetooth.py\n    if bluetooth_content!= expected_content:\n        # If the content is different, add an error to the configuration\n        config.add_error(\n            {\n                \"domain\": \"bluetooth\",\n                \"message\": \"The content of bluetooth.py is not up to date. Run 'ha bluetooth validate' to update it.\",\n                \"fixable\": True,\n                \"suggestion\": \"Run 'ha bluetooth validate' to update bluetooth.py.\",\n            }\n        )\n\n", "CodeBleu_score": 44.056313638512336}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\n    # If the integrations are not being validated, read the current content of bluetooth.py and compare it with the generated content\n    if not config.validate_integrations:\n        current_content = get_current_content(config)\n        generated_content = get_generated_content(integrations)\n        if current_content!= generated_content:\n            config.errors.append(\n                {\n                    \"domain\": \"bluetooth\",\n                    \"message\": (\n                        \"bluetooth.py is not up to date. \"\n                        \"Run 'python3 -m script.hassfest --validate-integrations' to fix.\"\n                    ),\n                }\n            )\n            return\n\n    # If the integrations are being validated, generate the content and validate it\n    generated_content = get_generated_content(integrations)\n    validate_content(config, generated_content)\n\n", "CodeBleu_score": 37.55103314143364}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    if config.is_component_disabled(\"bluetooth\"):\n        return\n\n    if not config.is_component_enabled(\"bluetooth\"):\n        config.add_error(\n            \"bluetooth_not_enabled\",\n            \"Bluetooth is not enabled. Please enable it in your configuration.yaml\",\n        )\n        return\n\n    if config.is_component_disabled(\"bluetooth_le_tracker\"):\n        config.add_error(\n            \"bluetooth_le_tracker_not_enabled\",\n            \"Bluetooth LE tracker is not enabled. Please enable it in your configuration.yaml\",\n        )\n        return\n\n    if config.is_component_disabled(\"bluetooth_tracker\"):\n        config.add_error(\n            \"bluetooth_tracker_not_enabled\",\n            \"Bluetooth tracker is not enabled. Please enable it in your configuration.yaml\",\n        )\n        return\n\n    if not integrations:\n        config.add_error(\n            \"bluetooth_no_integrations\",\n            \"No integrations found for bluetooth. Please enable one or more integrations that use bluetooth.\",\n        )\n        return\n\n    config.add_info(\n        \"bluetooth_integration_count\",\n        f\"Bluetooth integration count: {len(integrations)}\",\n    )\n\n    if config.is_component_disabled(\"bluetooth_le_tracker\"):\n        config.add_error(\n            \"bluetooth_le_tracker_not_enabled\",\n            \"Bluetooth LE tracker is not enabled. Please enable it in your configuration.yaml\",\n        )\n        return\n\n    if config.is_component_disabled(\"bluetooth_tracker\"):\n        config.add_error(\n            \"bluetooth_tracker_not_enabled\",\n            \"Bluetooth tracker is not enabled. Please enable it in your configuration.yaml\",\n        )\n        return\n\n    if not integrations:\n        config.add_error(\n            \"bluetooth_no_integrations\",\n            \"No integrations found for bluetooth. Please enable one or more integrations that use bluetooth.\",\n        )\n        return\n\n    config.add_info(\n        \"bluetooth_integration_count\",\n        f\"Bluetooth integration count: {len(integrations)}\",\n    )\n\n    # Generate content\n    content = generate_content(integrations)\n\n    # Check if content is already up to date\n    if config.is_component_enabled(\"bluetooth\") and content == config.cache.get(\n        \"bluetooth.py\"\n    ):\n        return\n\n    # Check if content is outdated\n    if config.is_component_enabled(\"bluetooth\") and content!= config.cache.get(", "CodeBleu_score": 26.618773044195997}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error\t// Create a new HTTP client with the default transport\n\tclient := &http.Client{\n\t\tTransport: http.DefaultTransport,\n\t}\n\n\t// Create a new HTTP request with the POST method, token endpoint URL, and request body\n\treq, err := http.NewRequest(\"POST\", tokenEndpoint, strings.NewReader(\"grant_type=refresh_token&refresh_token=\"+d.refreshToken+\"&client_id=\"+d.appKey+\"&client_secret=\"+d.appSecret))\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\t// Send the HTTP request and handle the response\n\tresp, err := client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Parse the response body as JSON\n\tvar response map[string]interface{}\n\tif err := json.Unmarshal(body, &response); err!= nil {\n\t\treturn err\n\t}\n\n\t// Check if the response contains an access token\n\tif accessToken, ok := response[\"access_token\"]; ok {\n\t\t// Update the access token\n\t\td.accessToken = accessToken.(string)\n\t\treturn nil\n\t}\n\n\t// Log the response body and return an error\n\tlog.Println(\"Failed to refresh token:\", string(body))\n\treturn errors.New(\"failed to refresh token\")\n}\n", "CodeBleu_score": 45.42008157830614}, {"code": "func (d *Dropbox) refreshToken() error\t// Prepare the POST request\n\turl := fmt.Sprintf(\"https://api.dropboxapi.com/oauth2/token?grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.refreshToken, d.appKey, d.appSecret)\n\treq, err := http.NewRequest(\"POST\", url, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Send the request and handle the response\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the status code\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"refreshToken: unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Parse the JSON response\n\tvar response struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\tif err := json.Unmarshal(body, &response); err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.accessToken = response.AccessToken\n\td.expiresIn = response.ExpiresIn\n\n\treturn nil\n}\n", "CodeBleu_score": 45.44547657094199}, {"code": "func (d *Dropbox) refreshToken() error\t// Build the request body.\n\tdata := url.Values{}\n\tdata.Set(\"grant_type\", \"refresh_token\")\n\tdata.Set(\"refresh_token\", d.RefreshToken)\n\tdata.Set(\"client_id\", d.AppKey)\n\tdata.Set(\"client_secret\", d.AppSecret)\n\n\t// Send the request.\n\tresp, err := d.client.PostForm(tokenURL, data)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body.\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check the status code.\n\tif resp.StatusCode!= 200 {\n\t\treturn fmt.Errorf(\"Dropbox: %s\", body)\n\t}\n\n\t// Unmarshal the JSON response.\n\tvar result map[string]interface{}\n\terr = json.Unmarshal(body, &result)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token.\n\td.AccessToken = result[\"access_token\"].(string)\n\treturn nil\n}\n", "CodeBleu_score": 48.0389115510059}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\tvar err error\n\tvar req *http.Request\n\tvar res *http.Response\n\tvar body []byte\n\n\t// Create a new HTTP request with the given method and URL\n\treq, err = http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the authorization header with the access token\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token)\n\n\t// Include parameters for supporting all drives\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\tq.Add(\"includeItemsFromAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\n\t// Customize the request if a callback is provided\n\tif callback!= nil {\n\t\treq, err = callback(req)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Send the request and handle any errors\n\tfor i := 0; i < 2; i++ {\n\t\tres, err = d.client.Do(req)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif res.StatusCode == http.StatusUnauthorized {\n\t\t\t// If the response status code is 401, refresh the token and retry the request\n\t\t\terr = d.refreshToken()\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token)\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\t// Read the response body and close the response\n\tbody, err = ioutil.ReadAll(res.Body)\n\tres.Body.Close()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// If a response structure is provided, set the request result\n\tif resp!= nil {\n\t\terr = json.Unmarshal(body, resp)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Return the response body or an error if the request fails\n\tif res.StatusCode!= http.StatusOK {\n\t\treturn nil, errors.New(string(body))\n\t}\n\treturn body, nil\n}\n", "CodeBleu_score": 46.71162720782108}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\tvar err error\n\tvar body []byte\n\tvar req *http.Request\n\tvar res *http.Response\n\tvar token *oauth2.Token\n\n\ttoken, err = d.oauth.Token()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif req, err = http.NewRequest(method, url, nil); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token.AccessToken)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", \"DriveSync\")\n\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\tif res, err = d.client.Do(req); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\n\tif body, err = ioutil.ReadAll(res.Body); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode == 401 {\n\t\tif token, err = d.oauth.TokenSource.Token(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif req, err = http.NewRequest(method, url, nil); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+token.AccessToken)\n\t\treq.Header.Set(\"Accept\", \"application/json\")\n\t\treq.Header.Set(\"User-Agent\", \"DriveSync\")\n\n\t\tif callback!= nil {\n\t\t\tcallback(req)\n\t\t}\n\n\t\tif res, err = d.client.Do(req); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdefer res.Body.Close()\n\n\t\tif body, err = ioutil.ReadAll(res.Body); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif res.StatusCode!= 200 {\n\t\treturn nil, fmt.Errorf(\"HTTP Error: %d\\n%s\", res.StatusCode, body)\n\t}\n\n\tif resp!= nil {\n\t\tif err = json.Unmarshal(body, resp); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}\n", "CodeBleu_score": 41.137919445665545}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\t// Set the authorization header with the access token\n\theaders := map[string]string{\n\t\t\"Authorization\": \"Bearer \" + d.accessToken,\n\t}\n\n\t// Include parameters for supporting all drives\n\tparams := map[string]string{\n\t\t\"supportsAllDrives\": \"true\",\n\t\t\"includeItemsFromAllDrives\": \"true\",\n\t}\n\n\t// If a callback is provided, it customizes the request\n\tif callback!= nil {\n\t\tcallback(method, url, headers, params)\n\t}\n\n\t// Send the request and handle errors\n\tvar body []byte\n\tvar err error\n\tfor i := 0; i < 3; i++ {\n\t\tbody, err = base.Request(method, url, headers, params)\n\t\tif err!= nil {\n\t\t\t// If a 401 error occurs, refresh the token and retry the request\n\t\t\tif strings.Contains(err.Error(), \"401\") {\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err!= nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tbreak\n\t}\n\n\t// If a response structure is provided, it sets the request result\n\tif resp!= nil {\n\t\terr = json.Unmarshal(body, resp)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}\n", "CodeBleu_score": 47.53466314267315}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\tvar (\n\t\terr  error\n\t\tdone bool\n\t)\n\n\t// calculate chunk size\n\tchunkSize := int64(math.Min(float64(d.chunkSize), float64(stream.Size())))\n\n\t// upload chunks\n\tfor!done {\n\t\t// check context cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// calculate chunk size\n\t\tif stream.Size()-stream.Offset() < chunkSize {\n\t\t\tchunkSize = stream.Size() - stream.Offset()\n\t\t\tdone = true\n\t\t}\n\n\t\t// create chunk reader\n\t\tchunkReader := io.LimitReader(stream, chunkSize)\n\n\t\t// create request\n\t\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, chunkReader)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// set headers\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\treq.Header.Set(\"Content-Length\", strconv.FormatInt(chunkSize, 10))\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", stream.Offset(), stream.Offset()+chunkSize-1, stream.Size()))\n\n\t\t// send request\n\t\tresp, err := d.client.Do(req)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// check response status\n\t\tif resp.StatusCode!= http.StatusOK {\n\t\t\treturn fmt.Errorf(\"upload failed: %s\", resp.Status)\n\t\t}\n\n\t\t// advance stream offset\n\t\tstream.Advance(chunkSize)\n\t}\n\n\treturn err\n}\n", "CodeBleu_score": 39.86174744447852}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate the chunk size based on the file size\n\tchunkSize := int64(1024 * 1024 * 256) // 256 MB\n\tfileSize := stream.Size()\n\tif fileSize < chunkSize {\n\t\tchunkSize = fileSize\n\t}\n\n\t// Create a temporary file to store the uploaded data\n\ttmpFile, err := ioutil.TempFile(\"\", \"chunk-upload-\")\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer os.Remove(tmpFile.Name())\n\n\t// Create a buffer to store the uploaded chunk\n\tbuffer := make([]byte, chunkSize)\n\n\t// Create a progress bar to track the upload progress\n\tprogress := progressbar.New(int(fileSize))\n\n\t// Upload the file in chunks\n\tfor {\n\t\t// Read a chunk from the file\n\t\tn, err := stream.Read(buffer)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the chunk to the temporary file\n\t\t_, err = tmpFile.Write(buffer[:n])\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Update the progress bar\n\t\tprogress.Add(n)\n\n\t\t// Check if the context is canceled\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t}\n\n\t// Close the temporary file\n\ttmpFile.Close()\n\n\t// Open the temporary file for reading\n\tf, err := os.Open(tmpFile.Name())\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\t// Upload the file to Google Drive\n\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, f)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"Content-Length\", strconv.FormatInt(fileSize, 10))\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"X-Upload-Content-Length\", strconv.FormatInt", "CodeBleu_score": 40.888440633196325}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate chunk size\n\tchunkSize := 5 * 1024 * 1024\n\tfileSize := stream.Size()\n\tif fileSize < chunkSize {\n\t\tchunkSize = fileSize\n\t}\n\n\t// Create a new chunked reader\n\tchunkedReader := chunk.New(stream, chunkSize)\n\n\t// Loop through each chunk and upload it\n\tfor {\n\t\t// Check for context cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Read next chunk\n\t\tchunk, err := chunkedReader.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create a new request with the chunk as the body\n\t\treq, err := http.NewRequest(\"PUT\", url, chunk)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the content length and range headers\n\t\treq.ContentLength = chunk.Size()\n\t\treq.Header.Set(\"Content-Length\", strconv.FormatInt(chunk.Size(), 10))\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", chunk.Offset(), chunk.Offset()+chunk.Size()-1, fileSize))\n\n\t\t// Send the request and check for errors\n\t\tresp, err := d.client.Do(req.WithContext(ctx))\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check for non-200 response\n\t\tif resp.StatusCode!= http.StatusOK {\n\t\t\treturn fmt.Errorf(\"non-200 response: %d\", resp.StatusCode)\n\t\t}\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 43.56367825984457}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error\tvar storage models.Storage\n\tif err := ctx.Bind(&storage); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, models.Response{\n\t\t\tCode:    http.StatusBadRequest,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\tif storage.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, models.Response{\n\t\t\tCode:    http.StatusBadRequest,\n\t\t\tMessage: \"mount_point cannot be empty\",\n\t\t})\n\t}\n\tif err := storage.Umount(); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, models.Response{\n\t\t\tCode:    http.StatusInternalServerError,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\tif err := storage.Delete(); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, models.Response{\n\t\t\tCode:    http.StatusInternalServerError,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\treturn ctx.JSON(http.StatusOK, models.Response{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"success\",\n\t})\n}\n", "CodeBleu_score": 47.54136540686079}, {"code": "func UmountStorage(ctx echo.Context) error\t// Bind JSON data from request context\n\tdata := &storage.UmountStorage{}\n\tif err := ctx.Bind(data); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\n\t// Validate mount_point\n\tif data.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point cannot be empty\")\n\t}\n\n\t// Attempt to unmount the storage\n\tif err := storage.Umount(data.MountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\t// Delete corresponding configuration\n\tif err := storage.DeleteConfig(data.MountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"Storage unmounted\")\n}", "CodeBleu_score": 32.16839011003728}, {"code": "func UmountStorage(ctx echo.Context) error\tvar requestBody struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\n\tif err := ctx.Bind(&requestBody); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\n\tif requestBody.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point cannot be empty\")\n\t}\n\n\tif err := unmountStorage(requestBody.MountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\tif err := deleteStorageConfig(requestBody.MountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"Success\")\n}\n", "CodeBleu_score": 31.295541810145146}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error\t// Extract the query parameters from the request\n\tparams := ctx.QueryParams()\n\n\t// Check if the \"path\" parameter is provided\n\tif path, ok := params[\"path\"]; ok {\n\t\t// Check if the file exists\n\t\tif _, err := os.Stat(path[0]); os.IsNotExist(err) {\n\t\t\t// Return a JSON response with an error message\n\t\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t\t}\n\n\t\t// Return the file to the client\n\t\treturn ctx.File(path[0])\n\t}\n\n\t// Return a JSON response with an error message\n\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing path parameter\"})\n}\n", "CodeBleu_score": 36.0187736387988}, {"code": "func GetLocalFile(ctx echo.Context) error\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing file path\"})\n\t}\n\tif!fileExists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"File not found\"})\n\t}\n\treturn ctx.File(filePath)\n}\n", "CodeBleu_score": 29.99090567157593}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing file path\"})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"File does not exist\"})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}\n", "CodeBleu_score": 36.10946696322438}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error\t// Get the \"name\" parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Create a new message map to bind the request body to\n\tvar message map[string]string\n\n\t// Bind the request body to the message map\n\tif err := ctx.Bind(&message); err!= nil {\n\t\t// If binding fails, return a bad request error with the binding error message\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := notify(name, message); err!= nil {\n\t\t// If sending the notification fails, return an internal server error with the error message\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully\"})\n}\n", "CodeBleu_score": 48.01360062609728}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.String(http.StatusBadRequest, \"missing name parameter\")\n\t}\n\n\tvar msg Message\n\tif err := ctx.Bind(&msg); err!= nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\n\tif err := notify(name, msg.Message); err!= nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.String(http.StatusOK, \"notification sent\")\n}\n", "CodeBleu_score": 44.87789519847532}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"missing parameter 'name'\")\n\t}\n\n\tvar message struct {\n\t\tMessage string `json:\"message\"`\n\t}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\tif err := notify.Send(name, message.Message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, nil)\n}", "CodeBleu_score": 45.52233679123352}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Close the connection when the function returns\n\tdefer ws.Close()\n\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start a goroutine to send messages to the WebSocket connection\n\tgo sendMessage()\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\t// If an error occurs, print the error and break the loop\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(\"Message type:\", msg)\n\t\tfmt.Println(\"Message:\", msg)\n\t\tfmt.Println(\"Error:\", err)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tfor i, conn := range connections {\n\t\tif conn == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 43.75464893769483}, {"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running.\n\tif!sendServiceRunning {\n\t\tgo sendService()\n\t}\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv: %s\", msg)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 42.406866008503954}, {"code": "func NotifyWS(ctx echo.Context) error\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tc := &connection{send: make(chan []byte, 256), ws: ws}\n\th.register <- c\n\tdefer func() { h.unregister <- c }()\n\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(mt, message)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 45.25930975916008}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get the drive model\n\tdriveModel, err := getDriveModel()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"message\": \"Failed to get drive model\",\n\t\t})\n\t}\n\n\t// Get the architecture\n\tarchitecture := runtime.GOARCH\n\n\t// Get the CPU information\n\tcpuInfo, err := getCPUInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"message\": \"Failed to get CPU information\",\n\t\t})\n\t}\n\n\t// Return the system hardware information as a JSON response\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\":     \"Success\",\n\t\t\"drive_model\": driveModel,\n\t\t\"architecture\": architecture,\n\t\t\"cpu_info\":    cpuInfo,\n\t})\n}\n", "CodeBleu_score": 22.836237223382135}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tvar driveInfo string\n\tvar cpuInfo string\n\tvar err error\n\n\t// Get drive model and architecture\n\tdriveInfo, err = getDriveInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error getting drive info\")\n\t}\n\n\t// Get CPU model and architecture\n\tcpuInfo, err = getCPUInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error getting CPU info\")\n\t}\n\n\t// Create JSON response\n\thardwareInfo := HardwareInfo{\n\t\tDriveInfo: driveInfo,\n\t\tCPUInfo:   cpuInfo,\n\t}\n\n\t// Return JSON response\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}\n", "CodeBleu_score": 20.256302252869684}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tvar err error\n\n\t// Get the drive model and architecture\n\tdriveModel, driveArchitecture, err := getDriveModelAndArchitecture()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Get the CPU information\n\tcpuInfo, err := getCPUInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Create a JSON response\n\tresponse := struct {\n\t\tDriveModel        string `json:\"drive_model\"`\n\t\tDriveArchitecture string `json:\"drive_architecture\"`\n\t\tCPUInfo           string `json:\"cpu_info\"`\n\t}{\n\t\tDriveModel:        driveModel,\n\t\tDriveArchitecture: driveArchitecture,\n\t\tCPUInfo:           cpuInfo,\n\t}\n\n\treturn ctx.JSON(http.StatusOK, response)\n}\n", "CodeBleu_score": 22.270993518497963}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := systemctl.ListServices(s.c)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}\n", "CodeBleu_score": 70.82284869070834}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif systemctl.IsServiceActive(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}\n", "CodeBleu_score": 58.72419326271778}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}\n", "CodeBleu_score": 70.55378947826327}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Errorf(\"Failed to marshal message map to JSON: %v\", err)\n\t\treturn\n\t}\n\tresp, err := i.client.Publish(context.Background(), &pb.PublishRequest{\n\t\tTopic:   name,\n\t\tMessage: jsonMessage,\n\t})\n\tif err!= nil {\n\t\tlog.Errorf(\"Failed to publish event to message bus: %v\", err)\n\t\treturn\n\t}\n\tif resp.Status!= pb.PublishResponse_OK {\n\t\tlog.Errorf(\"Failed to publish event to message bus: %v\", resp.Message)\n\t}\n}\n", "CodeBleu_score": 36.825604194686605}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tif i.bus == nil {\n\t\treturn\n\t}\n\n\t// Serialize the message map to JSON\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\ti.logger.Error(err, \"Failed to serialize message map to JSON\")\n\t\treturn\n\t}\n\n\t// Publish the notification to the message bus\n\terr = i.bus.Publish(i.topic, &bus.Message{\n\t\tName:    name,\n\t\tMessage: string(messageJSON),\n\t})\n\tif err!= nil {\n\t\ti.logger.Error(err, \"Failed to publish notification to message bus\")\n\t\treturn\n\t}\n\n\ti.logger.Info(\"Sent notification\", \"name\", name, \"message\", message)\n}\n", "CodeBleu_score": 36.394420713780065}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\t// Serialize the message map to JSON\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message for notification '%s': %v\", name, err)\n\t\treturn\n\t}\n\n\t// Publish the message to the message bus\n\terr = i.bus.Publish(name, messageJSON)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to publish notification '%s': %v\", name, err)\n\t\treturn\n\t}\n\n\t// Log the success\n\tlog.Printf(\"Published notification '%s'\", name)\n}\n", "CodeBleu_score": 30.791107145256767}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\treturn message_bus.NewClientWithResponses(c.messageBusAddress, nil)\n}\n", "CodeBleu_score": 7.499142401172448}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClient()\n\tif err := client.Init(); err!= nil {\n\t\tlog.Fatal(err)\n\t}\n\n\taddr, err := client.GetAddress(c.runtimePath)\n\tif err!= nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif addr == \"\" {\n\t\taddr = \"message bus not found\"\n\t}\n\n\tclient.SetServer(addr)\n\n\treturn client\n}\n", "CodeBleu_score": 37.29728106940596}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.messageBus == nil {\n\t\tc.messageBus = message_bus.NewClientWithResponses()\n\t\tc.messageBus.SetServer(c.messageBusAddress())\n\t}\n\treturn c.messageBus\n}\n", "CodeBleu_score": 24.736231436669232}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 52.79684118758402}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 52.79684118758402}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip!= \"\" {\n\t\tips := strings.Split(ip, \",\")\n\t\tif len(ips) > 0 {\n\t\t\tip = strings.TrimSpace(ips[0])\n\t\t}\n\t}\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 67.02471291567086}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\t// Define paths for the modules directory and the entry file\n\tmodulesDir := filepath.Join(c.config.ModulesPath, \"system\")\n\tentryFilePath := filepath.Join(modulesDir, \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tfmt.Println(\"Creating entry.json file...\")\n\t\tif err := os.WriteFile(entryFilePath, []byte(\"[]\"), 0644); err!= nil {\n\t\t\tlog.Fatalln(\"Failed to create entry.json file:\", err)\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tfiles, err := os.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlog.Fatalln(\"Failed to read modules directory:\", err)\n\t}\n\n\tvar entries []systemEntry\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tentryFilePath := filepath.Join(modulesDir, file.Name(), \"entry.json\")\n\t\t\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Read the entry.json file\n\t\t\tentryFile, err := os.ReadFile(entryFilePath)\n\t\t\tif err!= nil {\n\t\t\t\tlog.Fatalln(\"Failed to read entry.json file:\", err)\n\t\t\t}\n\n\t\t\t// Parse the entry.json file as a system entry\n\t\t\tvar entry systemEntry\n\t\t\tif err := json.Unmarshal(entryFile, &entry); err!= nil {\n\t\t\t\tlog.Fatalln(\"Failed to parse entry.json file:\", err)\n\t\t\t}\n\n\t\t\t// Add the system entry to the entries array\n\t\t\tentries = append(entries, entry)\n\t\t}\n\t}\n\n\t// Convert the entries array to JSON\n\tentriesJSON, err := json.Marshal(entries)\n\tif err!= nil {\n\t\tlog.Fatalln(\"Failed to convert entries to JSON:\", err)\n\t}\n\n\t// Write the entries JSON to the entry file\n\tif err := os.WriteFile(entryFilePath, entriesJSON, 0644); err!= nil {\n\t\tlog.Fatalln(\"Failed to write entries JSON to entry file:\", err)\n\t}\n\n\tfmt", "CodeBleu_score": 37.99492401492317}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Define paths for the modules directory and the entry file\n\tmodulesDir := path.Join(c.root, \"modules\")\n\tentryFilePath := path.Join(c.root, \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tif err := os.MkdirAll(entryFilePath, 0755); err!= nil {\n\t\t\tlog.Fatalf(\"Failed to create entry file: %v\", err)\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tfiles, err := ioutil.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlog.Fatalf(\"Failed to read modules directory: %v\", err)\n\t}\n\n\tvar entries []byte\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tentryPath := path.Join(modulesDir, file.Name(), \"entry.json\")\n\t\t\tentry, err := ioutil.ReadFile(entryPath)\n\t\t\tif err!= nil {\n\t\t\t\tlog.Printf(\"Failed to read entry file: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tentries = append(entries, entry...)\n\t\t}\n\t}\n\n\t// Concatenate the content of the entry.json files into a single JSON array\n\tvar entryJSON []byte\n\tif len(entries) > 0 {\n\t\tentryJSON = append(entryJSON, '[')\n\t\tentryJSON = append(entryJSON, entries...)\n\t\tentryJSON = append(entryJSON, ']')\n\t}\n\n\t// Write the concatenated JSON array to the entry file path\n\tif err := ioutil.WriteFile(entryFilePath, entryJSON, 0644); err!= nil {\n\t\tlog.Fatalf(\"Failed to write entry file: %v\", err)\n\t}\n}\n", "CodeBleu_score": 41.11929067860135}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Get the modules directory path\n\tmodulesDirPath := filepath.Join(c.config.GetModulesDir(), \"modules\")\n\t// Get the entry file path\n\tentryFilePath := filepath.Join(c.config.GetModulesDir(), \"entry.json\")\n\t// Create a slice to hold the entry JSON objects\n\tvar entryJSONObjects []map[string]interface{}\n\t// Walk the modules directory\n\terr := filepath.Walk(modulesDirPath, func(path string, info os.FileInfo, err error) error {\n\t\t// Check for errors\n\t\tif err!= nil {\n\t\t\t// Log the error\n\t\t\tlog.Printf(\"Error walking modules directory: %v\\n\", err)\n\t\t\treturn err\n\t\t}\n\t\t// Check if the file is a directory\n\t\tif info.IsDir() {\n\t\t\t// Skip directories\n\t\t\treturn nil\n\t\t}\n\t\t// Check if the file is an entry.json file\n\t\tif filepath.Base(path) == \"entry.json\" {\n\t\t\t// Read the entry.json file\n\t\t\tentryJSONBytes, err := os.ReadFile(path)\n\t\t\tif err!= nil {\n\t\t\t\t// Log the error\n\t\t\t\tlog.Printf(\"Error reading entry.json file: %v\\n\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Unmarshal the JSON bytes into a map\n\t\t\tvar entryJSON map[string]interface{}\n\t\t\terr = json.Unmarshal(entryJSONBytes, &entryJSON)\n\t\t\tif err!= nil {\n\t\t\t\t// Log the error\n\t\t\t\tlog.Printf(\"Error unmarshalling entry.json file: %v\\n\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Append the entry JSON object to the slice\n\t\t\tentryJSONObjects = append(entryJSONObjects, entryJSON)\n\t\t}\n\t\treturn nil\n\t})\n\t// Check for errors during directory walking\n\tif err!= nil {\n\t\t// Log the error\n\t\tlog.Printf(\"Error walking modules directory: %v\\n\", err)\n\t\treturn\n\t}\n\t// Check if the entry file already exists\n\tif _, err := os.Stat(entryFilePath); err == nil {\n\t\t// Delete the existing entry file\n\t\terr = os.Remove(entryFilePath)\n\t\tif err!= nil {\n\t\t\t// Log the error\n\t\t\tlog.Printf(\"Error deleting existing entry", "CodeBleu_score": 40.87252146129421}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) \tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnames, err := c.networkNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}\n", "CodeBleu_score": 57.06170420397242}, {"code": "func (c *systemService) GetMacAddress() (string, error) \t// Get a list of network interfaces\n\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service\n\tnames, err := c.Names()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names\n\tfor _, iface := range ifaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\t// Return the MAC address of the first matching interface\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface is found, return an error\n\treturn \"\", errors.New(\"no matching interface found\")\n}\n", "CodeBleu_score": 56.46752901365939}, {"code": "func (c *systemService) GetMacAddress() (string, error) \t// Get a list of network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif iface.Name == name {\n\t\t\t\t// Return the MAC address of the first matching interface\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface is found, return an error\n\treturn \"\", fmt.Errorf(\"no matching interface found\")\n}\n", "CodeBleu_score": 59.003650550384926}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t iRet = 0;\n\tSTscObj *pTscObjTemp = NULL;\n\tSRequestObj *pRequestTemp = NULL;\n\tSRequestObj *pRequestTemp2 = NULL;\n\tSRequestObj *pRequestTemp3 = NULL;\n\tSRequestObj *pRequestTemp4 = NULL;\n\tSRequestObj *pRequestTemp5 = NULL;\n\tSRequestObj *pRequestTemp6 = NULL;\n\tSRequestObj *pRequestTemp7 = NULL;\n\tSRequestObj *pRequestTemp8 = NULL;\n\tSRequestObj *pRequestTemp9 = NULL;\n\tSRequestObj *pRequestTemp10 = NULL;\n\tSRequestObj *pRequestTemp11 = NULL;\n\tSRequestObj *pRequestTemp12 = NULL;\n\tSRequestObj *pRequestTemp13 = NULL;\n\tSRequestObj *pRequestTemp14 = NULL;\n\tSRequestObj *pRequestTemp15 = NULL;\n\tSRequestObj *pRequestTemp16 = NULL;\n\tSRequestObj *pRequestTemp17 = NULL;\n\tSRequestObj *pRequestTemp18 = NULL;\n\tSRequestObj *pRequestTemp19 = NULL;\n\tSRequestObj *pRequestTemp20 = NULL;\n\tSRequestObj *pRequestTemp21 = NULL;\n\tSRequestObj *pRequestTemp22 = NULL;\n\tSRequestObj *pRequestTemp23 = NULL;\n\tSRequestObj *pRequestTemp24 = NULL;\n\tSRequestObj *pRequestTemp25 = NULL;\n\tSRequestObj *pRequestTemp26 = NULL;\n\tSRequestObj *pRequestTemp27 = NULL;\n\tSRequestObj *pRequestTemp28 = NULL;\n\tSRequestObj *pRequestTemp29 = NULL;\n\tSRequestObj *pRequestTemp30 = NULL;\n\tSRequestObj *pRequestTemp31 = NULL;\n\tSRequestObj *pRequestTemp32 = NULL;\n\tSRequestObj *pRequestTemp33 = NULL;\n\tSRequestObj *pRequestTemp34 = NULL;\n\tSRequestObj *pRequestTemp35 = NULL;\n\tSRequestObj *p", "CodeBleu_score": 5.156498064270784}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t iRet = 0;\n\tSApplicationObj *pAppObj = NULL;\n\tSRequestSummary *pReqSum = NULL;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tiRet = -1;\n\t\tgoto done;\n\t}\n\n\tpRequest->refCount++;\n\tpTscObj->reqCount++;\n\tpAppObj = pTscObj->pAppObj;\n\tif (pAppObj!= NULL) {\n\t\tpReqSum = &pAppObj->reqSum;\n\t\tpReqSum->reqCount++;\n\t\tpReqSum->reqCountCurrent++;\n\t\tpReqSum->reqCountCurrentTsc++;\n\t}\n\n\tif (g_debug) {\n\t\tlog_debug(\"Registering request %p for TSC %p\", pRequest, pTscObj);\n\t}\n", "CodeBleu_score": 24.806097812973643}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t rc = 0;\n\n\tif (pRequest == NULL) {\n\t\trc = -1;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Add a reference to the request object.\n\t */\n\tpRequest->refCount++;\n\n\t/*\n\t * Increment the request count for the associated TSC object.\n\t */\n\tpTscObj->requestCount++;\n\n\t/*\n\t * Update the application's request summary.\n\t */\n\tif (pTscObj->pAppInfo!= NULL) {\n\t\tpTscObj->pAppInfo->requestCount++;\n\t\tpTscObj->pAppInfo->requestCountCurrent++;\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tlogDebug(\"Registered request %s for TSC %s\", pRequest->requestId, pTscObj->tscId);\n", "CodeBleu_score": 19.53151962380532}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tbool ret = true;\n\tif (pRequest->pPrimaryDb && strcmp(pRequest->pPrimaryDb, exceptDb)) {\n\t\tret = false;\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; i < pRequest->iDbCount; i++) {\n\t\t\tchar *pDb = pRequest->pDb[i];\n\t\t\tif (pDb &&!strcmp(pDb, exceptDb)) {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 38.102689924719}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tbool result = true;\n\tif (pRequest->db!= NULL && strcmp(pRequest->db, exceptDb)!= 0) {\n\t\tresult = false;\n\t} else {\n\t\tif (pRequest->dbList!= NULL) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < pRequest->dbList->count; i++) {\n\t\t\t\tchar* db = pRequest->dbList->db[i];\n\t\t\t\tchar* schemaPrefix = strchr(db, '.');\n\t\t\t\tif (schemaPrefix!= NULL) {\n\t\t\t\t\tdb = schemaPrefix + 1;\n\t\t\t\t}\n\t\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 48.54504389714355}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tchar *db = NULL;\n\tchar *p = NULL;\n\tint i;\n\n\tif (pRequest->db) {\n\t\tdb = pRequest->db;\n\t} else {\n\t\tdb = pRequest->primaryDb;\n\t}\n\n\tif (db && strcmp(db, exceptDb)) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->dbList) {\n\t\tfor (i = 0; i < pRequest->dbList->count; i++) {\n\t\t\tp = pRequest->dbList->db[i];\n\t\t\tif (p && strcmp(p, exceptDb)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 43.544254843660276}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tbool ret = false;\n\tif (code == T_ERR_REDIRECT) {\n\t\tswitch (msgType) {\n\t\tcase T_MSG_RFP_REQUEST:\n\t\tcase T_MSG_RFP_RESPONSE:\n\t\tcase T_MSG_RFP_UPDATE:\n\t\tcase T_MSG_RFP_UPDATE_RESPONSE:\n\t\tcase T_MSG_RFP_UPDATE_COMPLETE:\n\t\tcase T_MSG_RFP_UPDATE_COMPLETE_RESPONSE:\n\t\t\tret = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 30.987484345829618}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tif (code == E_NOT_READY && msgType!= TMSG_RPC_REQUEST && msgType!= TMSG_RPC_REQUEST_NO_WAIT && msgType!= TMSG_RPC_REQUEST_NO_WAIT_NO_RESP && msgType!= TMSG_RPC_REQUEST_NO_RESP) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 44.22714314051211}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tif (code == RPC_REDIRECT_ERROR) {\n\t\tif (msgType!= T_RPC_REQUEST && msgType!= T_RPC_REQUEST_NO_REPLY && msgType!= T_RPC_REQUEST_NO_WAIT && msgType!= T_RPC_REQUEST_NO_WAIT_NO_REPLY) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 36.39620496637917}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests)\tint i;\n\tint n;\n\tint rc;\n\tint nReq;\n\tint nStop;\n\tsqlite3_stmt *pStmt;\n\tchar *zSql;\n\tchar *zErr;\n\tchar *zReqId;\n\tchar *zStopId;\n\tchar *zStopSql;\n\tchar *zStopErr;\n\tchar *zStopErr2;\n\tchar *zStopErr3;\n\tchar *zStopErr4;\n\tchar *zStopErr5;\n\tchar *zStopErr6;\n\tchar *zStopErr7;\n\tchar *zStopErr8;\n\tchar *zStopErr9;\n\tchar *zStopErr10;\n\tchar *zStopErr11;\n\tchar *zStopErr12;\n\tchar *zStopErr13;\n\tchar *zStopErr14;\n\tchar *zStopErr15;\n\tchar *zStopErr16;\n\tchar *zStopErr17;\n\tchar *zStopErr18;\n\tchar *zStopErr19;\n\tchar *zStopErr20;\n\tchar *zStopErr21;\n\tchar *zStopErr22;\n\tchar *zStopErr23;\n\tchar *zStopErr24;\n\tchar *zStopErr25;\n\tchar *zStopErr26;\n\tchar *zStopErr27;\n\tchar *zStopErr28;\n\tchar *zStopErr29;\n\tchar *zStopErr30;\n\tchar *zStopErr31;\n\tchar *zStopErr32;\n\tchar *zStopErr33;\n\tchar *zStopErr34;\n\tchar *zStopErr35;\n\tchar *zStopErr36;\n\tchar *zStopErr37;\n\tchar *zStopErr38;\n\tchar *zStopErr39;\n\tchar *zStopErr40;\n\tchar *zStopErr41;\n\tchar *zStopErr42;\n\tchar *zStopErr43;\n\tchar *zStopErr44;\n\tchar *zStopErr4", "CodeBleu_score": 6.13510362050438}, {"code": "void stopAllRequests(SHashObj *pRequests)\tSHashObj *pRequest;\n\tSHashIter sIter;\n\tint i;\n\n\tfor (i = 0; i < pRequests->iBuckets; i++) {\n\t\tpRequest = pRequests->apBuckets[i];\n\t\twhile (pRequest!= NULL) {\n\t\t\tif (pRequest->iKey!= 0) {\n\t\t\t\tpRequest = sHashAcquire(pRequests, pRequest->iKey);\n\t\t\t\tif (pRequest!= NULL) {\n\t\t\t\t\tif (pRequest->pObj!= NULL) {\n\t\t\t\t\t\tif (pRequest->pObj->pQuery!= NULL) {\n\t\t\t\t\t\t\tif (pRequest->pObj->pQuery->iStatus == SQLITE_OK) {\n\t\t\t\t\t\t\t\tpRequest->pObj->pQuery->iStatus = SQLITE_ABORT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsHashRelease(pRequests, pRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpRequest = pRequest->pNext;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.04026473150231}, {"code": "void stopAllRequests(SHashObj *pRequests)\tint i;\n\tint n;\n\tint nReq;\n\tRequest *pReq;\n\n\tnReq = pRequests->nEntry;\n\tfor (i = 0; i < nReq; i++) {\n\t\tpReq = (Request *) pRequests->aEntry[i].pKey;\n\t\tif (pReq!= NULL) {\n\t\t\tif (pReq->pQuery!= NULL) {\n\t\t\t\tif (pReq->pQuery->pStmt!= NULL) {\n\t\t\t\t\tif (sqlite3_stmt_status(pReq->pQuery->pStmt,\n\t\t\t\t\t\t\tSQLITE_STMTSTATUS_FULLSCAN_STEP, 1) == SQLITE_OK) {\n\t\t\t\t\t\tn = sqlite3_stmt_status(pReq->pQuery->pStmt,\n\t\t\t\t\t\t\t\tSQLITE_STMTSTATUS_FULLSCAN_STEP, 0);\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tpReq->pQuery->nStop = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsqlite3_finalize(pReq->pQuery->pStmt);\n\t\t\t\tpReq->pQuery->pStmt = NULL;\n\t\t\t}\n\t\t\treleaseRequest(pReq);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.678247684513025}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport()\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_compare_exchange_strong(&tscClientStop, &tscClientStop, 1)) {\n\t\twhile (tscClientStop) {\n\t\t\ttscSleep(100);\n\t\t}\n\t} else {\n\t\ttscLog(TSC_LOG_INFO, \"Crash report thread is already stopped.\");\n\t}\n}\n", "CodeBleu_score": 52.993009256718324}, {"code": "void tscStopCrashReport()\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\tif (!atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n\t\ttscLogMessage(LOG_INFO, \"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\twhile (clientStop) {\n\t\ttscSleep(1);\n\t}\n}\n", "CodeBleu_score": 59.03523427055353}, {"code": "void tscStopCrashReport()\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_compare_exchange_strong(&tscClientStop, (int*)&tscClientStop, 1)) {\n\t\twhile (tscClientStop) {\n\t\t\tusleep(100000);\n\t\t}\n\t} else {\n\t\tprintf(\"tscCrashReport: already stopped\\n\");\n\t}\n}\n", "CodeBleu_score": 50.82116282102933}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t i, j, k, l, ret = 0;\n\tint32_t numViews = 0;\n\tint32_t numColumns = 0;\n\tint32_t numColumnsInCatalog = 0;\n\tint32_t numColumnsInView = 0;\n\tint32_t numColumnsInCatalogInView = 0;\n\tint32_t numColumnsInViewInCatalog = 0;\n\tint32_t numColumnsToRemove = 0;\n\tint32_t numColumnsToAdd = 0;\n\tint32_t numColumnsToUpdate = 0;\n\tint32_t numColumnsToIgnore = 0;\n\tint32_t numColumnsInCatalogToIgnore = 0;\n\tint32_t numColumnsInViewToIgnore = 0;\n\tint32_t numColumnsInCatalogToUpdate = 0;\n\tint32_t numColumnsInViewToUpdate = 0;\n\tint32_t numColumnsInCatalogToAdd = 0;\n\tint32_t numColumnsInViewToAdd = 0;\n\tint32_t numColumnsInCatalogToRemove = 0;\n\tint32_t numColumnsInViewToRemove = 0;\n\tint32_t numColumnsToProcess = 0;\n\tint32_t numColumnsProcessed = 0;\n\tint32_t numColumnsInCatalogProcessed = 0;\n\tint32_t numColumnsInViewProcessed = 0;\n\tint32_t numColumnsInCatalogToProcess = 0;\n\tint32_t numColumnsInViewToProcess = 0;\n\tint32_t numColumnsInCatalogToProcessInView = 0;\n\tint32_t numColumnsInViewToProcessInCatalog = 0;\n\tint32_t numColumnsInCatalogToProcessInCatalog = 0;\n\tint32_t numColumnsInViewToProcessInView = 0;\n\tint32_t numColumnsInCatalogToProcessInCatalogToAdd = 0;\n\tint32_t numColumnsInViewToProcessInViewToAdd = 0;\n\tint32", "CodeBleu_score": 8.7425016563476}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t i, j, k, n;\n\tint32_t viewId, numColumns;\n\tint32_t numViews;\n\tint32_t numColumnsInView;\n\tint32_t numColumnsInCatalog;\n\tint32_t numColumnsInCatalogView;\n\tint32_t numColumnsInCatalogColumn;\n\tint32_t numColumnsInCatalogColumnInView;\n\tint32_t numColumnsInCatalogColumnInViewInColumn;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalog;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumn;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInView;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumn;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalog;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumn;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInView;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInViewInColumn;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalog;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumn;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInView;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInViewInColumn;\n\tint32_t numColumnsInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalogColumnInViewInColumnInCatalog;\n\tint32_t numColumnsInCatalogColumnInView", "CodeBleu_score": 4.421772232140546}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t nColumns = 0;\n\tint32_t nViews = 0;\n\tint32_t nViewColumns = 0;\n\tint32_t nViewColumns2 = 0;\n\tint32_t nViewColumns3 = 0;\n\tint32_t nViewColumns4 = 0;\n\tint32_t nViewColumns5 = 0;\n\tint32_t nViewColumns6 = 0;\n\tint32_t nViewColumns7 = 0;\n\tint32_t nViewColumns8 = 0;\n\tint32_t nViewColumns9 = 0;\n\tint32_t nViewColumns10 = 0;\n\tint32_t nViewColumns11 = 0;\n\tint32_t nViewColumns12 = 0;\n\tint32_t nViewColumns13 = 0;\n\tint32_t nViewColumns14 = 0;\n\tint32_t nViewColumns15 = 0;\n\tint32_t nViewColumns16 = 0;\n\tint32_t nViewColumns17 = 0;\n\tint32_t nViewColumns18 = 0;\n\tint32_t nViewColumns19 = 0;\n\tint32_t nViewColumns20 = 0;\n\tint32_t nViewColumns21 = 0;\n\tint32_t nViewColumns22 = 0;\n\tint32_t nViewColumns23 = 0;\n\tint32_t nViewColumns24 = 0;\n\tint32_t nViewColumns25 = 0;\n\tint32_t nViewColumns26 = 0;\n\tint32_t nViewColumns27 = 0;\n\tint32_t nViewColumns28 = 0;\n", "CodeBleu_score": 6.826195109672476}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tstruct CallbackData *data = (struct CallbackData *) callbackData;\n\tdata->contentLength = properties->contentLength;\n\treturn S3StatusOK;\n}\n", "CodeBleu_score": 49.44936976856704}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tCallbackData *data = (CallbackData *) callbackData;\n\tdata->contentLength = properties->contentLength;\n\treturn S3StatusOK;\n}\n", "CodeBleu_score": 48.69577357526475}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tif (properties->contentLength > 0) {\n\t\tstruct CallbackData *data = (struct CallbackData *) callbackData;\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tstruct CallbackData *data = (struct CallbackData *) callbackData;\n\t\tdata->contentLength = 0;\n\t}\n\n\treturn S3StatusOK;\n}\n", "CodeBleu_score": 65.50422398264377}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync()\t// Create the checkpoint backup directory if it doesn't exist\n\tif (mkdir(CHECKPOINT_BACKUP_DIR, 0777)!= 0 && errno!= EEXIST) {\n\t\tlog_err(\"Error creating checkpoint backup directory: %s\\n\", strerror(errno));\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDirectories(CHECKPOINT_BACKUP_DIR);\n\n\t// Generate Rsync configuration file\n\tif (generateRsyncConfigFile()) {\n\t\t// Construct command to start Rsync daemon\n\t\tchar command[1024];\n\t\tsnprintf(command, 1024, \"rsync --daemon --no-detach --config=%s --port=%d\", RSYNC_CONFIG_FILE, RSYNC_PORT);\n\n\t\t// Start Rsync daemon\n\t\tif (system(command) == 0) {\n\t\t\tlog_info(\"Rsync server started successfully\\n\");\n\t\t} else {\n\t\t\tlog_err(\"Error starting Rsync server\\n\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 24.524676728623884}, {"code": "void startRsync()\t// Create the checkpoint backup directory\n\tif (mkdir(CHECKPOINT_BACKUP_DIR, 0777) == -1) {\n\t\tlog_error(\"Error creating checkpoint backup directory: %s\\n\", strerror(errno));\n\t}\n\n\t// Remove empty directories\n\tif (system(\"find \" CHECKPOINT_BACKUP_DIR \" -type d -empty -delete\") == -1) {\n\t\tlog_error(\"Error removing empty directories in checkpoint backup directory: %s\\n\", strerror(errno));\n\t}\n\n\t// Generate Rsync configuration file\n\tif (generateRsyncConfig()) {\n\t\t// Construct and execute command to start Rsync daemon\n\t\tchar command[MAX_COMMAND_LENGTH];\n\t\tsprintf(command, \"rsync --daemon --config=%s --port=%d\", RSYNC_CONFIG_FILE, RSYNC_PORT);\n\t\tif (system(command) == -1) {\n\t\t\tlog_error(\"Error starting Rsync server: %s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tlog_info(\"Rsync server started successfully\\n\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 29.03803331911919}, {"code": "void startRsync()\t// Create checkpoint backup directory\n\tif (mkdir(CHECKPOINT_BACKUP_DIR, 0755) == -1) {\n\t\tlog_err(\"Error creating checkpoint backup directory: %s\\n\", strerror(errno));\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDirectories(CHECKPOINT_BACKUP_DIR);\n\n\t// Generate Rsync configuration file\n\tif (generateRsyncConfFile()) {\n\t\tlog_err(\"Error generating Rsync configuration file\\n\");\n\t\treturn;\n\t}\n\n\t// Construct and execute command to start Rsync daemon\n\tchar *cmd = malloc(sizeof(char) * (strlen(RSYNC_DAEMON_CMD) + strlen(RSYNC_CONF_FILE) + strlen(RSYNC_PORT) + 2));\n\tsprintf(cmd, \"%s %s %s\", RSYNC_DAEMON_CMD, RSYNC_CONF_FILE, RSYNC_PORT);\n\tsystem(cmd);\n\tfree(cmd);\n\n\tlog_info(\"Rsync server started successfully\\n\");\n}\n", "CodeBleu_score": 23.214710650388845}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId)\tif (dispatcherId == null) {\n\t\tthrow new IllegalArgumentException(\"The dispatcher ID cannot be null\");\n\t}\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"The dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n}\n", "CodeBleu_score": 43.8683070568614}, {"code": "public void destroyDispatcher(String dispatcherId)\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\tif (dispatcher!= null) {\n\t\tdispatcher.shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID '\" + dispatcherId + \"' is not registered.\");\n\t}\n}", "CodeBleu_score": 64.98441068737077}, {"code": "public void destroyDispatcher(String dispatcherId)\tif (this.dispatchers.containsKey(dispatcherId)) {\n\t\tthis.dispatchers.get(dispatcherId).shutdown();\n\t\tthis.dispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n\t}\n}\n", "CodeBleu_score": 45.63169609541407}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)\tTbActorId[] children = mChildren.get(parent);\n\tif (children == null) {\n\t\tlog.warn(\"Broadcasting to children of unknown parent actor \" + parent);\n\t\treturn;\n\t}\n\tfor (TbActorId child : children) {\n\t\tif (childFilter.test(child)) {\n\t\t\tsend(child, msg, highPriority);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 45.92127641629482}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)\tList<TbActorId> children = parent.getChildren();\n\tif (children == null) {\n\t\tlog.warn(\"broadcastToChildren: parent {} has no children\", parent);\n\t\treturn;\n\t}\n\tfor (TbActorId child : children) {\n\t\tif (childFilter.test(child)) {\n\t\t\ttry {\n\t\t\t\tif (highPriority)\n\t\t\t\t\tsendHighPriority(child, msg);\n\t\t\t\telse\n\t\t\t\t\tsend(child, msg);\n\t\t\t} catch (TbActorId.ActorNotRegisteredException e) {\n\t\t\t\tlog.warn(\"broadcastToChildren: child {} not registered\", child);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.25977011453824}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)\tList<TbActorId> children = getChildren(parent);\n\tif (children == null) {\n\t\tlog.warning(\"No children registered for actor \" + parent.getActorName());\n\t\treturn;\n\t}\n\tfor (TbActorId child : children) {\n\t\tif (childFilter.test(child)) {\n\t\t\ttry {\n\t\t\t\tif (highPriority) {\n\t\t\t\t\tsendHighPriority(child, msg);\n\t\t\t\t} else {\n\t\t\t\t\tsend(child, msg);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warning(\"Unable to send message to child \" + child.getActorName());\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.84539305681155}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (!isDestroying()) {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\ttryProcessQueue();\n\t} else if (msg instanceof RULE_NODE_UPDATED_MSG) {\n\t\tif (isInitializing()) {\n\t\t\treinitialize();\n\t\t} else {\n\t\t\tmsg.notifyActorStopped(this);\n\t\t}\n\t} else {\n\t\tmsg.notifyActorStopped(this);\n\t}\n}", "CodeBleu_score": 35.524536059967716}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (destroying) {\n\t\tif (msg instanceof RULE_NODE_UPDATED_MSG && ((RULE_NODE_UPDATED_MSG)msg).isHighPriority()) {\n\t\t\tif (failedInit) {\n\t\t\t\tfailedInit = false;\n\t\t\t\tinit();\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.notifyStopped();\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t}\n}\n", "CodeBleu_score": 39.37165760174374}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (msg.getMsgId() == RULE_NODE_UPDATED_MSG &&!highPriority && destroying) {\n\t\t// If we're in the process of destroying the actor, and we receive a RULE_NODE_UPDATED_MSG,\n\t\t// we may need to reinitialize the actor if it failed during initialization.\n\t\tif (reinitAfterDestroy) {\n\t\t\treinitAfterDestroy = false;\n\t\t\tif (msg.getMsg() instanceof RuleNode) {\n\t\t\t\tRuleNode rn = (RuleNode) msg.getMsg();\n\t\t\t\tif (rn.isRuleNode()) {\n\t\t\t\t\tif (rn.getRuleNodeState() == RuleNode.STATE_FAILED) {\n\t\t\t\t\t\t// If the node failed during initialization, reinitialize it.\n\t\t\t\t\t\treinitialize(rn);\n\t\t\t\t\t} else if (rn.getRuleNodeState() == RuleNode.STATE_ACTIVE) {\n\t\t\t\t\t\t// If the node is active, we're done.\n\t\t\t\t\t\tdestroying = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise, we're not done, so keep waiting.\n\t\t\t\t\t\treinitAfterDestroy = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// If we're not in the process of reinitializing the actor, we're done.\n\t\t\tdestroying = false;\n\t\t}\n\t} else if (msg.getMsgId() == RULE_NODE_UPDATED_MSG && highPriority && destroying) {\n\t\t// If we're in the process of destroying the actor, and we receive a high-priority RULE_NODE_UPDATED_MSG,\n\t\t// we may need to reinitialize the actor if it failed during initialization.\n\t\tif (reinitAfterDestroy) {\n\t\t\treinitAfterDestroy = false;\n\t\t\tif (msg.getMsg() instanceof RuleNode) {\n\t\t\t\tRuleNode rn = (RuleNode) msg.getMsg();\n\t\t\t\tif (rn.isRuleNode()) {\n\t\t\t\t\tif (rn.getRuleNodeState() == RuleNode.STATE_FAILED) {\n\t\t\t\t\t\t// If the node failed during initialization, reinitialize it.\n\t\t\t\t\t\treinitialize(rn);\n\t\t\t\t\t} else if (rn.getRuleNodeState() == RuleNode.STATE_ACTIVE) {\n\t\t\t\t\t\t// If the node is active, we're done.\n\t\t\t\t\t\tdestroying = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise,", "CodeBleu_score": 39.588437744393225}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox()\tif (this.status!= Status.RUNNING) {\n\t\treturn;\n\t}\n\tif (this.mailbox.isEmpty()) {\n\t\tthis.status = Status.FREE;\n\t\tthis.scheduleProcessMailbox();\n\t\treturn;\n\t}\n\tfinal Message message = this.mailbox.poll();\n\ttry {\n\t\tif (message.isHighPriority()) {\n\t\t\tthis.processHighPriorityMessage(message);\n\t\t} else {\n\t\t\tthis.processNormalPriorityMessage(message);\n\t\t}\n\t} catch (final InitializationException e) {\n\t\tthis.setStopReason(e);\n\t\tthis.destroy();\n\t} catch (final Exception e) {\n\t\tthis.logProcessException(message, e);\n\t\tthis.applyProcessFailureStrategy(message, e);\n\t}\n\tif (this.mailbox.isEmpty()) {\n\t\tthis.status = Status.FREE;\n\t\tthis.scheduleProcessMailbox();\n\t} else {\n\t\tthis.processMailbox();\n\t}\n}\n", "CodeBleu_score": 15.825378323188588}, {"code": "private void processMailbox()\tif (actor == null) {\n\t\treturn;\n\t}\n\tif (actor.isStopped()) {\n\t\treturn;\n\t}\n\tif (actor.isSuspended()) {\n\t\treturn;\n\t}\n\tif (actor.isTerminated()) {\n\t\treturn;\n\t}\n\tif (actor.isKilled()) {\n\t\treturn;\n\t}\n\tif (actor.isSuspending()) {\n\t\treturn;\n\t}\n\tif (actor.isTerminating()) {\n\t\treturn;\n\t}\n\tif (actor.isKilling()) {\n\t\treturn;\n\t}\n\tif (actor.isStopping()) {\n\t\treturn;\n\t}\n\tif (actor.isRestarting()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessing()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailbox()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxHigh()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxNormal()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxLow()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxHighPriority()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxNormalPriority()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxLowPriority()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxHighPriorityMessage()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxNormalPriorityMessage()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxLowPriorityMessage()) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxHighPriorityMessage(message)) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxNormalPriorityMessage(message)) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxLowPriorityMessage(message)) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxHighPriorityMessage(message, messagePriority)) {\n\t\treturn;\n\t}\n\tif (actor.isProcessingMailboxNormalPriorityMessage(message, messagePriority)) {\n\t\treturn;\n\t}\n\t", "CodeBleu_score": 13.971933700457113}, {"code": "private void processMailbox()\tif (actor.getStopReason()!= null) {\n\t\treturn;\n\t}\n\t// Process messages from high priority queue.\n\tif (actor.getHighPriorityQueue().size() > 0) {\n\t\tif (actor.getStatus() == ActorStatus.BUSY) {\n\t\t\treturn;\n\t\t}\n\t\tactor.setStatus(ActorStatus.BUSY);\n\t\ttry {\n\t\t\tactor.process(actor.getHighPriorityQueue().remove(0));\n\t\t} catch (InitializationFailureException e) {\n\t\t\tactor.setStopReason(e);\n\t\t\tactor.destroy();\n\t\t} catch (Exception e) {\n\t\t\tactor.getProcessFailureStrategy().apply(actor, e);\n\t\t\tif (actor.getStopReason()!= null) {\n\t\t\t\tactor.destroy();\n\t\t\t}\n\t\t}\n\t\tif (actor.getHighPriorityQueue().size() > 0) {\n\t\t\tactor.getScheduler().schedule(actor.getProcessMailboxTask(), actor.getProcessMailboxDelay());\n\t\t} else {\n\t\t\tactor.setStatus(ActorStatus.FREE);\n\t\t}\n\t\treturn;\n\t}\n\t// Process messages from normal priority queue.\n\tif (actor.getNormalPriorityQueue().size() > 0) {\n\t\tif (actor.getStatus() == ActorStatus.BUSY) {\n\t\t\treturn;\n\t\t}\n\t\tactor.setStatus(ActorStatus.BUSY);\n\t\ttry {\n\t\t\tactor.process(actor.getNormalPriorityQueue().remove(0));\n\t\t} catch (InitializationFailureException e) {\n\t\t\tactor.setStopReason(e);\n\t\t\tactor.destroy();\n\t\t} catch (Exception e) {\n\t\t\tactor.getProcessFailureStrategy().apply(actor, e);\n\t\t\tif (actor.getStopReason()!= null) {\n\t\t\t\tactor.destroy();\n\t\t\t}\n\t\t}\n\t\tif (actor.getNormalPriorityQueue().size() > 0) {\n\t\t\tactor.getScheduler().schedule(actor.getProcessMailboxTask(), actor.getProcessMailboxDelay());\n\t\t} else {\n\t\t\tactor.setStatus(ActorStatus.FREE);\n\t\t}\n\t\treturn;\n\t}\n\t// Set actor status to free and schedule a queue processing attempt.\n\tactor.setStatus(ActorStatus.FREE);\n\tactor.getScheduler().schedule(actor.getProcessMailboxTask(),", "CodeBleu_score": 24.841990869782965}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause)\tif (destroying) {\n\t\treturn;\n\t}\n\tdestroying = true;\n\tif (stopReason == null) {\n\t\tstopReason = new StopReason(cause);\n\t}\n\tdispatcher.executor().execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\treadiness.set(NOT_READY);\n\t\t\t\tdestroy(stopReason.cause);\n\t\t\t\tfor (Message<?> message : queuedMessages) {\n\t\t\t\t\tmessage.notifyStop(stopReason);\n\t\t\t\t}\n\t\t\t\tqueuedMessages.clear();\n\t\t\t\tif (dispatcher.isShutdown()) {\n\t\t\t\t\tdispatcher.remove(Actor.this);\n\t\t\t\t}\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlogger.log(Level.WARNING, \"Error during destruction of actor \" + Actor.this, t);\n\t\t\t}\n\t\t}\n\t});\n}", "CodeBleu_score": 37.366823882582715}, {"code": "public void destroy(Throwable cause)\tif (cause == null) {\n\t\tthrow new NullPointerException();\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tif (!isDestroyed()) {\n\t\tisDestroyed = true;\n\t\ttry {\n\t\t\tdispatcher.executor.execute(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treadiness = Readiness.NotReady;\n\t\t\t\t\t\tdestroy(stopReason);\n\t\t\t\t\t\tnotifyAllMessages(stopReason);\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlog.warning(\"Exception during destruction of actor \" + Actor.this, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (Throwable e) {\n\t\t\tlog.warning(\"Exception during destruction of actor \" + Actor.this, e);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.512600947057365}, {"code": "public void destroy(Throwable cause)\tif (destroying) {\n\t\treturn;\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tdestroying = true;\n\tif (dispatcher.executor().isShutdown()) {\n\t\treturn;\n\t}\n\tdispatcher.executor().execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tsetNotReady();\n\t\t\t\tdestroy(stopReason);\n\t\t\t\tnotifyAllMessages(stopReason);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlogger.log(Level.WARNING, \"Exception during actor destruction\", t);\n\t\t\t}\n\t\t}\n\t});\n}\n", "CodeBleu_score": 34.33605403761464}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\tif (tenantId.equals(Tenant.SYSTEM_TENANT)) {\n\t\treturn true;\n\t}\n\tTenantProfile profile = null;\n\ttry {\n\t\tprofile = tenantProfileService.getProfile(tenantId);\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow e;\n\t}\n\tRateLimitConfiguration rateLimitConfiguration = profile.getRateLimitConfiguration();\n\tif (rateLimitConfiguration == null) {\n\t\treturn true;\n\t}\n\tRateLimit rateLimit = rateLimitConfiguration.getRateLimit(api, level);\n\tif (rateLimit == null) {\n\t\treturn true;\n\t}\n\tif (rateLimit.getLimit() == 0) {\n\t\treturn true;\n\t}\n\tRateLimitState rateLimitState = rateLimitStateService.get(tenantId, api, level);\n\tif (rateLimitState == null) {\n\t\trateLimitState = new RateLimitState(tenantId, api, level);\n\t\trateLimitState.setCount(0);\n\t\trateLimitState.setLastRequestTime(System.currentTimeMillis());\n\t\trateLimitStateService.put(rateLimitState);\n\t}\n\tif (rateLimitState.getCount() >= rateLimit.getLimit()) {\n\t\tif (rateLimit.getNotification()!= null) {\n\t\t\trateLimitNotificationService.process(tenantId, api, level, rateLimitState.getCount(), rateLimit.getLimit());\n\t\t}\n\t\treturn false;\n\t}\n\trateLimitState.setCount(rateLimitState.getCount() + 1);\n\trateLimitState.setLastRequestTime(System.currentTimeMillis());\n\trateLimitStateService.put(rateLimitState);\n\treturn true;\n}\n", "CodeBleu_score": 40.76071041781641}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\tif (tenantId.isSystemTenantId()) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileService.getProfile(tenantId, ignoreTenantNotFound);\n\tRateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n\tif (rateLimitConfiguration == null) {\n\t\treturn true;\n\t}\n\tRateLimit rateLimit = rateLimitConfiguration.getRateLimit(api, level);\n\tif (rateLimit == null) {\n\t\treturn true;\n\t}\n\tif (rateLimit.isUnlimited()) {\n\t\treturn true;\n\t}\n\tRateLimitState rateLimitState = rateLimitStateService.getRateLimitState(tenantId, api, level);\n\tif (rateLimitState == null) {\n\t\treturn true;\n\t}\n\tif (rateLimitState.isWithinLimit(rateLimit)) {\n\t\treturn true;\n\t}\n\tprocessRateLimitNotification(tenantId, api, level, rateLimit, rateLimitState);\n\treturn false;\n}", "CodeBleu_score": 41.60798820380236}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\tif (tenantId == null) {\n\t\tthrow new IllegalArgumentException(\"Parameter 'tenantId' is null\");\n\t}\n\tif (api == null) {\n\t\tthrow new IllegalArgumentException(\"Parameter 'api' is null\");\n\t}\n\tif (level == null) {\n\t\tthrow new IllegalArgumentException(\"Parameter 'level' is null\");\n\t}\n\tif (tenantId.equals(Tenant.DEFAULT_TENANT_ID)) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = getTenantProfile(tenantId, ignoreTenantNotFound);\n\tRateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n\tRateLimitCheckResult result = rateLimitConfiguration.checkRateLimit(api, level);\n\tif (result.isExceeded()) {\n\t\tprocessRateLimitNotification(tenantId, api, level, result.getLimit(), result.getRemaining());\n\t}\n\treturn!result.isExceeded();\n}", "CodeBleu_score": 36.978229366837375}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions()\t// TODO: implement\n}\n", "CodeBleu_score": 1.4734253005940088}, {"code": "public void evictTimeoutSessions()\t// TODO: implement\n}", "CodeBleu_score": 1.4734253005940088}, {"code": "public void evictTimeoutSessions()\t// TODO: implement\n}", "CodeBleu_score": 1.4734253005940088}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tfor (JsonNode value : values) {\n\t\t\ttsKvEntries.add(new TsKvEntry(key, value));\n\t\t}\n\t}\n\treturn tsKvEntries;\n}", "CodeBleu_score": 33.93379880561508}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tif (timeseries.isEmpty()) {\n\t\treturn new ArrayList<TsKvEntry>();\n\t}\n\tList<TsKvEntry> result = new ArrayList<TsKvEntry>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tList<TsKvValue> tsKvValues = new ArrayList<TsKvValue>();\n\t\tfor (JsonNode value : values) {\n\t\t\ttsKvValues.add(new TsKvValue(value.get(\"time\").asLong(), value.get(\"value\").asDouble()));\n\t\t}\n\t\tresult.add(new TsKvEntry(key, tsKvValues));\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 32.43138949029058}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\n\treturn timeseries.entrySet().stream()\n\t\t.map(e -> {\n\t\t\tString key = e.getKey();\n\t\t\tList<JsonNode> values = e.getValue();\n\n\t\t\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\n\t\t\tvalues.forEach(value -> {\n\t\t\t\tString timestamp = value.get(\"timestamp\").asText();\n\t\t\t\tString valueStr = value.get(\"value\").asText();\n\n\t\t\t\ttsKvEntries.add(new TsKvEntry(key, timestamp, valueStr));\n\t\t\t});\n\n\t\t\treturn tsKvEntries;\n\t\t})\n\t\t.flatMap(List::stream)\n\t\t.collect(Collectors.toList());\n}", "CodeBleu_score": 40.582964523978916}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken()\t// Create a request map containing the current refresh token\n\tMap<String, String> request = new HashMap<>();\n\trequest.put(\"refresh_token\", refreshToken);\n\n\t// Send a POST request to the authentication endpoint\n\tResponse response = Unirest.post(authEndpoint)\n\t\t.header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\t.header(\"Authorization\", \"Basic \" + auth)\n\t\t.field(\"grant_type\", \"refresh_token\")\n\t\t.field(\"refresh_token\", refreshToken)\n\t\t.asJson();\n\n\t// Update the token information with the current timestamp and the response body\n\taccessToken = response.getBody().getObject().getString(\"access_token\");\n\trefreshToken = response.getBody().getObject().getString(\"refresh_token\");\n\ttokenTimestamp = System.currentTimeMillis();\n}", "CodeBleu_score": 46.44495283519937}, {"code": "public void refreshToken()\t// Create request map\n\tMap<String, String> request = new HashMap<String, String>();\n\trequest.put(\"refresh_token\", this.refreshToken);\n\n\t// Send POST request to authentication endpoint\n\tString response = this.sendRequest(\"POST\", this.authenticationEndpoint, request);\n\n\t// Update token information\n\tthis.token = response.get(\"access_token\");\n\tthis.refreshToken = response.get(\"refresh_token\");\n\tthis.tokenExpiration = System.currentTimeMillis() / 1000 + Integer.parseInt(response.get(\"expires_in\"));\n}\n", "CodeBleu_score": 37.6732765186449}, {"code": "public void refreshToken()\tMap<String, Object> request = new HashMap<>();\n\trequest.put(\"refresh_token\", this.refreshToken);\n\trequest.put(\"grant_type\", \"refresh_token\");\n\trequest.put(\"client_id\", this.clientId);\n\trequest.put(\"client_secret\", this.clientSecret);\n\trequest.put(\"scope\", \"openid\");\n\n\tMap<String, Object> response = this.sendRequest(this.authenticationEndpoint, request);\n\n\tthis.updateTokenInfo(response);\n}", "CodeBleu_score": 37.1979498015126}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin() long timestamp = System.currentTimeMillis();\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", );\n Response response = Unirest.post(AUTH_ENDPOINT + \"/api/auth/login\")", "CodeBleu_score": 59.184333115558815}, {"code": " private void doLogin() long timestamp = System.currentTimeMillis();\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", );\n try {\n String response = sendPostRequest(\"/api/auth/login\", loginRequest);\n updateTokenInfo(response, timestamp);\n } catch (IOException e) {\n e.printStackTrace();\n }\n }\n", "CodeBleu_score": 62.25198174801366}, {"code": " private void doLogin() long timestamp = System.currentTimeMillis();\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", );\n String response = restTemplate.postForObject(\n \"http://localhost:8080/api/auth/login\",\n loginRequest,\n String.class\n );\n token = response;\n timestamp = timestamp;\n }\n}", "CodeBleu_score": 66.4501670435438}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\tString url = baseUrl + \"/api/device/\" + deviceId;\n\ttry {\n\t\tResponse response = client.target(url).request().get();\n\t\tif (response.getStatus() == 200) {\n\t\t\treturn Optional.of(response.readEntity(Device.class));\n\t\t} else if (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Unexpected response: \" + response.getStatus());\n\t\t}\n\t} catch (WebApplicationException e) {\n\t\tthrow e;\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 54.03009236912767}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\ttry {\n\t\treturn Optional.of(restTemplate.getForObject(\n\t\t\t\t\"http://localhost:8080/api/device/\" + deviceId,\n\t\t\t\tDevice.class));\n\t} catch (HttpClientErrorException ex) {\n\t\tif (ex.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow ex;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.4296492413731}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\ttry {\n\t\tResponseEntity<Device> response = restTemplate.getForEntity(\n\t\t\t\t\"/api/device/{deviceId}\", Device.class, deviceId.getId());\n\t\tif (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 68.36254446187947}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\t// Create a request object containing the device and its credentials\n\tDeviceWithCredentialsRequest request = new DeviceWithCredentialsRequest(device, credentials);\n\n\t// Attempt to send the request\n\ttry {\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(API_URL + \"/device-with-credentials\", request, Device.class);\n\n\t\t// If successful, return an Optional containing the saved device\n\t\tif (response.getStatusCode() == HttpStatus.OK) {\n\t\t\treturn Optional.of(response.getBody());\n\t\t}\n\t} catch (HttpStatusCodeException e) {\n\t\t// If a 404 error occurs, return an empty Optional\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t}\n\n\t// Rethrow any other exceptions encountered\n\tthrow e;\n}", "CodeBleu_score": 68.38886832431737}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\ttry {\n\t\tDeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(apiUrl + \"/device-with-credentials\", deviceWithCredentials, Device.class);\n\t\treturn Optional.ofNullable(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 71.3682053768114}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\t// Create a request object containing the device and its credentials\n\tDeviceWithCredentialsRequest request = new DeviceWithCredentialsRequest(device, credentials);\n\n\t// Attempt to send the request\n\ttry {\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(BASE_URL + \"/api/device-with-credentials\", request, Device.class);\n\t\treturn Optional.ofNullable(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 76.71928884680574}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val)\tif (arguments.length === 1) {\n\t\tthis.setBrightness(addr);\n\t} else {\n\t\tthis.setBrightness(addr, val);\n\t}\n\treturn this;\n}\n", "CodeBleu_score": 39.8423516455279}, {"code": "brightness(addr, val)\tif (arguments.length === 1) {\n\t\tthis.setBrightness(addr);\n\t} else {\n\t\tthis.setBrightness(addr, val);\n\t}\n\treturn this;\n}\n", "CodeBleu_score": 39.8423516455279}, {"code": "brightness(addr, val)\tif (arguments.length === 1) {\n\t\tfor (let i = 0; i < this.devices.length; i++) {\n\t\t\tthis.devices[i].brightness(addr);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tthis.devices[addr].brightness(val);\n\t}\n\treturn this;\n}\n", "CodeBleu_score": 42.62484793829313}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr)\tlet led = Object.create(this);\n\tfor (let key in led) {\n\t\tif (led.hasOwnProperty(key) && typeof led[key] === 'function') {\n\t\t\tled[key] = led[key].bind(led, addr);\n\t\t}\n\t}\n\treturn led;\n}\n", "CodeBleu_score": 25.285598660123515}, {"code": "device(addr)\tlet obj = Object.create(LedControl.prototype);\n\tObject.assign(obj, this);\n\tfor (let key in obj) {\n\t\tif (typeof obj[key] === \"function\") {\n\t\t\tobj[key] = obj[key].bind(obj, addr);\n\t\t}\n\t}\n\treturn obj;\n}\n", "CodeBleu_score": 25.94188401630041}, {"code": "device(addr)\tlet device = Object.create(LedControl.prototype);\n\tdevice.address = addr;\n\tfor (let key in device) {\n\t\tif (typeof device[key] === \"function\") {\n\t\t\tdevice[key] = device[key].bind(device);\n\t\t}\n\t}\n\treturn device;\n}\n", "CodeBleu_score": 24.091754680238175}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => \tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function');\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tthis.forEach(item => {\n\t\t\t\tconst promise = item[method]();\n\t\t\t\tif (promise && promise.then) {\n\t\t\t\t\tpromises.push(promise);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn Promise.all(promises).then(() => callback());\n\t\t};\n\t});\n};\n", "CodeBleu_score": 45.06672213110774}, {"code": "Collection.installCallbackReconciliation = (target, methods) => \tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === \"function\") {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== \"function\") {\n\t\t\t\tthrow new Error(\"Callback is not a function\");\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tthis.forEach(element => {\n\t\t\t\tpromises.push(element[method](duration));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => callback());\n\t\t};\n\t});\n};\n", "CodeBleu_score": 42.271068711248525}, {"code": "Collection.installCallbackReconciliation = (target, methods) => \tif (!Array.isArray(methods)) {\n\t\tthrow new Error(\"The argument'methods' must be an array\");\n\t}\n\n\tmethods.forEach(method => {\n\t\tif (typeof method!== \"string\") {\n\t\t\tthrow new Error(\"The argument'methods' must be an array of strings\");\n\t\t}\n\n\t\tif (typeof target[method]!== \"function\") {\n\t\t\tthrow new Error(`The method '${method}' does not exist on the target object`);\n\t\t}\n\n\t\ttarget[method] = function() {\n\t\t\tconst args = Array.from(arguments);\n\t\t\tconst duration = typeof args[args.length - 2] === \"number\"? args.pop() : 1000;\n\t\t\tconst callback = typeof args[args.length - 1] === \"function\"? args.pop() : null;\n\n\t\t\tif (typeof callback!== \"function\") {\n\t\t\t\tthrow new Error(\"The last argument must be a function\");\n\t\t\t}\n\n\t\t\tconst promises = this.map(element => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\telement[method].apply(element, args);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, duration);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tPromise.all(promises).then(callback);\n\t\t};\n\t});\n};\n", "CodeBleu_score": 30.38308636070338}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen()\t// initialize an empty input string\n\tlet input = '';\n\n\t// start a read loop on the specified serial port\n\tthis.serialPort.on('data', (data) => {\n\t\t// append the data to the input string\n\t\tinput += data.toString();\n\n\t\t// split the input string into sentences based on the \"\\r\\n\" delimiter\n\t\tlet sentences = input.split(\"\\r\\n\");\n\n\t\t// process all complete sentences\n\t\tfor (let i = 0; i < sentences.length - 1; i++) {\n\t\t\t// call \"parseNmeaSentence\" for each complete sentence\n\t\t\tthis.parseNmeaSentence(sentences[i]);\n\t\t}\n\n\t\t// retain any incomplete sentence for the next read\n\t\tinput = sentences[sentences.length - 1];\n\t});\n}\n", "CodeBleu_score": 50.596822808873455}, {"code": "listen()\t// Initialize an empty input string\n\tlet input = \"\";\n\n\t// Start a read loop on the serial port\n\tport.on(\"data\", (data) => {\n\t\t// Append the received data to the input string\n\t\tinput += data.toString();\n\n\t\t// Split the input string into sentences based on the \"\\r\\n\" delimiter\n\t\tconst sentences = input.split(\"\\r\\n\");\n\n\t\t// Process all complete sentences\n\t\tfor (let i = 0; i < sentences.length - 1; i++) {\n\t\t\t// Call \"parseNmeaSentence\" for each complete sentence\n\t\t\tparseNmeaSentence(sentences[i]);\n\t\t}\n\n\t\t// Retain any incomplete sentence for the next read\n\t\tinput = sentences[sentences.length - 1];\n\t});\n}\n", "CodeBleu_score": 46.92442605300555}, {"code": "listen()\tlet input = \"\";\n\tlet port = new SerialPort(this.portName, {\n\t\tbaudRate: 4800,\n\t\tparser: SerialPort.parsers.readline(\"\\r\\n\")\n\t});\n\tport.on(\"open\", () => {\n\t\tport.on(\"data\", data => {\n\t\t\tinput += data;\n\t\t\tlet sentences = input.split(\"\\r\\n\");\n\t\t\tinput = sentences.pop();\n\t\t\tfor (let sentence of sentences) {\n\t\t\t\tthis.parseNmeaSentence(sentence);\n\t\t\t}\n\t\t});\n\t});\n}\n", "CodeBleu_score": 39.717289948226046}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *cfg = dev->config;\n\tconst struct adc_ad559x_data *data = dev->data;\n\tint buffer_size = 0;\n\tint num_channels = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tnum_channels++;\n\t\t\tbuffer_size += cfg->resolution / 8;\n\t\t}\n\t}\n\n\tif (buffer_size > data->buffer_size) {\n\t\tLOG_ERR(\"Insufficient memory for ADC sequence\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 38.15723642590398}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tint num_active_channels = 0;\n\tint i;\n\n\tfor (i = 0; i < data->num_channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tnum_active_channels++;\n\t\t}\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Options not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size <\n\t    (num_active_channels * sizeof(uint16_t))) {\n\t\tLOG_ERR(\"Insufficient memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 42.33574544509655}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels = 0;\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id!= ADC_CHANNEL_ID_UNUSED) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tif (active_channels == 0) {\n\t\tLOG_ERR(\"No active channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options->buffer_size <\n\t    active_channels * config->data_size) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 36.73417270312035}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_ad559x_config *config = dev->config;\n\tuint16_t buffer[16];\n\tuint8_t channel_count = 0;\n\tuint8_t channel_list[16];\n\tuint8_t channel_mask = 0;\n\tuint8_t channel_mask_index = 0;\n\tint ret;\n\n\tif (sequence->channels!= 1) {\n\t\tLOG_ERR(\"Only single channel reads are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution!= 12) {\n\t\tLOG_ERR(\"Only 12-bit resolution is supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > 16) {\n\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels > 16) {\n\t\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels > 16) {\n\t\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels > 16) {\n\t\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels > 16) {\n\t\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels > 16) {\n\t\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels > 16) {\n\t\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels > 16) {\n\t\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels > 16) {\n\t\t\tLOG_ERR(\"Only 16 channels are", "CodeBleu_score": 30.825925674240462}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tint ret;\n\n\tif (sequence->resolution!= 12) {\n\t\tLOG_ERR(\"Unsupported ADC resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels_list[i] > 7) {\n\t\t\tLOG_ERR(\"Invalid ADC channel %d\", sequence->channels_list[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < sequence->channels * sizeof(uint16_t)) {\n\t\tLOG_ERR(\"Insufficient ADC read buffer size %d\", sequence->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->buffer_pos = 0;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not start ADC read context\");\n\t\treturn ret;\n\t}\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}\n", "CodeBleu_score": 63.1723850333632}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\t/* Validate the ADC sequence */\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"The ADC sequence resolution does not match the expected resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1U) {\n\t\tLOG_ERR(\"Only single channel ADC sequences are supported", "CodeBleu_score": 31.17054945123127}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = DEV_DATA(ctx->dev);\n\tstruct adc_config *config = &data->config;\n\tstruct adc_repeat_buffer *repeat_buffer = &data->repeat_buffer;\n\tuint8_t channel_mask = 0;\n\tint i;\n\n\tfor (i = 0; i < ctx->channels; i++) {\n\t\tchannel_mask |= BIT(ctx->channel_list[i]);\n\t}\n\n\tconfig->channel_mask = channel_mask;\n\trepeat_buffer->data = ctx->buffer;\n\trepeat_buffer->length = ctx->buffer_size;\n\n\tk_sem_give(&data->sem);\n}\n", "CodeBleu_score": 31.983004472710626}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = DEV_DATA(ctx->dev);\n\tstruct adc_device_config *config = DEV_CFG(ctx->dev);\n\tuint8_t channel_mask = 0;\n\tuint8_t channel_id;\n\tuint8_t channel_count = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < ctx->channels_count; i++) {\n\t\tchannel_id = ctx->channels[i];\n\t\tchannel_mask |= BIT(channel_id);\n\t\tchannel_count++;\n\t}\n\n\t/* set the channels to be sampled */\n\tdata->adc_config.channel_mask = channel_mask;\n\n\t/* initialize the repeat buffer */\n\tadc_repeat_buffer_init(&data->adc_repeat_buffer, ctx->repeat_buffer, ctx->repeat_buffer_size, channel_count);\n\n\t/* release the semaphore to start sampling */\n\tk_sem_give(&data->sem);\n}\n", "CodeBleu_score": 29.689481363924212}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = ctx->adc_data;\n\tstruct adc_device *adc = data->dev;\n\tstruct adc_sequence *sequence = &data->sequence;\n\tstruct adc_channel_cfg *channel_cfg = data->channel_cfg;\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\n\t/* Set the channels to be sampled */\n\tfor (i = 0, j = 0; i < data->channel_count; i++) {\n\t\tif (data->channel_mask & (1 << i)) {\n\t\t\tchannel_cfg[j].input_positive = data->channel_ids[i];\n\t\t\tchannel_cfg[j].input_negative = ADC_INPUT_NEGATIVE_NONE;\n\t\t\tj++;\n\t\t}\n\t}\n\n\t/* Set the repeat buffer */\n\tsequence->resolution = data->resolution;\n\tsequence->oversampling = data->oversampling;\n\tsequence->calibrate = data->calibrate;\n\tsequence->buffer = data->buffer;\n\tsequence->buffer_size = data->buffer_size;\n\tsequence->channels = j;\n\tsequence->channel_cfg = channel_cfg;\n\tsequence->repeat_count = data->repeat_count;\n\tsequence->bit_width = data->bit_width;\n\tsequence->extra_samplings = data->extra_samplings;\n\n\t/* Start sampling */\n\tfor (k = 0; k < data->repeat_count; k++) {\n\t\tadc_read_async(adc, sequence, NULL);\n\t}\n\n\t/* Release the semaphore to signal the start of sampling */\n\tk_sem_give(&data->sem);\n}\n", "CodeBleu_score": 28.227878631022318}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tstruct adc_data_container *adc_data_container = adc_context_get_data_container(ctx);\n\n\tif (repeat_sampling) {\n\t\tadc_data_container->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tadc_data_container->buffer_pointer = adc_data_container->buffer;\n\t}\n}\n", "CodeBleu_score": 39.8556812890574}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tstruct adc_data *data = adc_context_get_data(ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t} else {\n\t\tdata->buffer = data->sample_buffer;\n\t}\n}\n", "CodeBleu_score": 54.8993884122624}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tstruct adc_data *adc_data = ctx->adc_data;\n\n\tif (adc_data->repeat_buffer!= NULL) {\n\t\tif (repeat_sampling) {\n\t\t\tctx->buffer_ptr = adc_data->repeat_buffer;\n\t\t} else {\n\t\t\tctx->buffer_ptr = adc_data->buffer;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.626258618736742}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tint i;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for a semaphore to be released */\n\t\tret = sem_wait(&data->acquisition_sem);\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tadc_ad559x_log_error(\"sem_wait() failed: %s\", strerror(errno));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Iterate through the active channels */\n\t\tfor (i = 0; i < data->num_channels; i++) {\n\t\t\tif (data->channels[i].active) {\n\t\t\t\t/* Read the ADC value */\n\t\t\t\tret = adc_ad559x_read_channel(data, i, &data->channels[i].value);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tadc_ad559x_log_error(\"adc_ad559x_read_channel() failed: %s\", strerror(errno));\n\t\t\t\t\tdata->status = ADC_AD559X_STATUS_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tif (data->status == ADC_AD559X_STATUS_RUNNING) {\n\t\t\tdata->status = ADC_AD559X_STATUS_DONE;\n\t\t\tsem_post(&data->acquisition_done_sem);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.35541747360486}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tuint8_t i;\n\tuint16_t value;\n\tuint32_t timestamp;\n\tuint8_t channel_count = 0;\n\n\tfor (i = 0; i < data->channel_count; i++) {\n\t\tif (data->channels[i].active) {\n\t\t\tchannel_count++;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\txSemaphoreTake(data->semaphore, portMAX_DELAY);\n\n\t\tfor (i = 0; i < data->channel_count; i++) {\n\t\t\tif (data->channels[i].active) {\n\t\t\t\tif (adc_ad559x_read_channel(data->i2c, data->channels[i].channel, &value)!= ADC_AD559X_OK) {\n\t\t\t\t\tadc_ad559x_set_complete(data, ADC_AD559X_ERROR_READ_FAILED);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttimestamp = xTaskGetTickCount();\n\t\t\t\tadc_ad559x_add_sample(data, i, value, timestamp);\n\t\t\t}\n\t\t}\n\n\t\tif (data->channels[i].active) {\n\t\t\txSemaphoreGive(data->semaphore);\n\t\t} else {\n\t\t\txSemaphoreGive(data->semaphore);\n\t\t\txSemaphoreGive(data->done_semaphore);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.21647668945309}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tstruct adc_ad559x_channel *channel;\n\tuint8_t channel_index;\n\tuint16_t adc_value;\n\tuint8_t adc_value_bytes[2];\n\tuint8_t adc_value_bytes_count;\n\tuint8_t adc_value_bytes_index;\n\tuint8_t channel_count;\n\tuint8_t channel_index_to_read;\n\tuint8_t channel_index_to_read_next;\n\tuint8_t channel_index_to_read_previous;\n\tuint8_t channel_index_to_read_start;\n\tuint8_t channel_index_to_read_stop;\n\tuint8_t channel_index_to_read_stop_next;\n\tuint8_t channel_index_to_read_stop_previous;\n\tuint8_t channel_index_to_read_stop_start;\n\tuint8_t channel_index_to_read_stop_start_next;\n\tuint8_t channel_index_to_read_stop_start_previous;\n\tuint8_t channel_index_to_read_stop_start_start;\n\tuint8_t channel_index_to_read_stop_start_start_next;\n\tuint8_t channel_index_to_read_stop_start_start_previous;\n\tuint8_t channel_index_to_read_stop_start_start_start;\n\tuint8_t channel_index_to_read_stop_start_start_start_next;\n\tuint8_t channel_index_to_read_stop_start_start_start_previous;\n\tuint8_t channel_index_to_read_stop_start_start_start_start;\n\tuint8_t channel_index_to_read_stop_start_start_start_start_next;\n\tuint8_t channel_index_to_read_stop_start_start_start_start_previous;\n\tuint8_t channel_index_to_read_stop_start_start_start_start_start;\n\tuint8_t channel_index_to_read_stop_start", "CodeBleu_score": 6.200713590630865}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev)\tconst struct ads1112_config *cfg = dev->config;\n\tint err;\n\n\t/* Wait for the device to be ready for data reading */\n\tk_sleep(K_MSEC(cfg->ready_time));\n\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &cfg->reg_config);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/* Check the status of the device */\n\twhile (!(cfg->reg_config & ADS1112_REG_CONFIG_RDY)) {\n\t\t/* Sleep for 100 microseconds and check the status again */\n\t\tk_sleep(K_USEC(100));\n\t\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &cfg->reg_config);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 48.17495066735611}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)\tconst struct ads1112_config *cfg = dev->config;\n\tuint8_t reg_data[2];\n\tint ret;\n\n\tk_sleep(K_MSEC(cfg->ready_time));\n\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_data, 2);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\twhile (!(reg_data[0] & ADS1112_CFG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_data, 2);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 57.61296653249052}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)\tint ret;\n\tuint16_t config;\n\tuint8_t ready_time;\n\n\t/* Get the device's ready time */\n\tready_time = ads1112_get_ready_time(dev);\n\n\t/* Wait for the device to be ready */\n\tk_sleep(K_MSEC(ready_time));\n\n\t/* Check the device's status */\n\tret = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* If the device is not ready, wait for 100 microseconds and check again */\n\twhile (!(config & ADS1112_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 59.58080548155402}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tuint8_t num_samplings = sequence->resolution;\n\tuint8_t num_extra_samplings = sequence->extra_samplings;\n\tuint8_t num_channels = sequence->channels;\n\tuint8_t num_bytes_per_sample = sequence->bytes_per_sample;\n\n\tuint8_t required_buffer_size = num_samplings * num_channels * num_bytes_per_sample + num_extra_samplings * num_channels * num_bytes_per_sample;\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tESP_LOGE(TAG, \"Buffer size is too small. Required buffer size: %d, provided buffer size: %d\", required_buffer_size, sequence->buffer_size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\treturn ESP_OK;\n}\n", "CodeBleu_score": 37.745611848163286}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tuint8_t num_samplings = sequence->options->extra_samplings + 1;\n\tuint8_t buffer_size = num_samplings * sizeof(uint16_t);\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Buffer size is too small. Required: %u, Actual: %u\", buffer_size, sequence->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 43.60357811100163}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tif (sequence->resolution > 8) {\n\t\treturn -EINVAL;\n\t}\n\n\tsize_t buffer_size = (sequence->resolution <= 8)? 2 : 3;\n\tbuffer_size *= sequence->channels;\n\tbuffer_size *= sequence->options;\n\tbuffer_size *= sequence->sampling_delay;\n\tbuffer_size *= sequence->oversampling;\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"ADC sequence buffer size is too small\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 49.043419831737886}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_config *cfg = dev->config;\n\tint ret;\n\n\tif (sequence->options) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels!= 1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution!= 16) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling!= 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < sizeof(uint16_t)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels->gain!= ADC_GAIN_1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->reference!= ADC_REF_INTERNAL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->acquisition_time!= ADC_ACQ_TIME_DEFAULT) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->differential) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->positive_input > ADC_CHANNEL_ID_MAX) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->negative_input!= ADC_CHANNEL_ID_GND) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->positive_input == ADC_CHANNEL_ID_GND) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->positive_input == ADC_CHANNEL_ID_TEMP) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->positive_input == ADC_CHANNEL_ID_VDD_DIV2) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->positive_input == ADC_CHANNEL_ID_VDD) {\n\t\treturn -ENOTSUP;\n\t}\n\n\t", "CodeBleu_score": 38.323600681188076}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tconst struct ads1112_config *config = dev->config;\n\tint ret;\n\n\tif (sequence->calibrate) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution!= 12) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels!= 1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling!= 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling!= 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->gain!= ADC_GAIN_1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->reference!= ADC_REF_INTERNAL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels->acquisition_time!= ADC_ACQ_TIME_DEFAULT) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < 2) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels->channel_id!= config->channel) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (data->adc_context.buffer!= NULL) {\n\t\treturn -EBUSY;\n\t}\n\n\tdata->adc_context.buffer = sequence->buffer;\n\tdata->adc_context.buffer_size = sequence->buffer_size;\n\tdata->adc_context.resolution = sequence->resolution;\n\tdata->adc_context.channels = sequence->channels;\n\tdata->adc_context.oversampling = sequence->oversampling;\n\tdata->adc_context.repeat_buffer = sequence->repeat_buffer;\n\tdata->adc_context.calibrate = sequence->calibrate;\n\tdata->adc_context.options = sequence->options;\n\tdata->adc_context.user_data = sequence->user_data;\n\tdata->adc_context.callback = sequence", "CodeBleu_score": 38.45593255279628}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\tif (!data) {\n\t\treturn -ENODEV;\n\t}\n\n\tif (!sequence ||!sequence->channels ||!sequence->calibrate) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->channel_count!= 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->channels[0].channel_id!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->channels[0].gain!= ADC_GAIN_1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->channels[0].reference!= ADC_REF_INTERNAL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->channels[0].acquisition_time!= ADC_ACQ_TIME_DEFAULT) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->channels[0].differential) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->resolution!= 16) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->oversampling!= 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->over_sampling_ratio!= 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->repeat_count!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->oversampling_shift!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->gain!= ADC_GAIN_1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->reference!= ADC_REF_INTERNAL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->acquisition_time!= ADC_ACQ_TIME_DEFAULT) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->resolution!= 16) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate->oversampling!= 1) {\n\t\treturn -EINVAL;\n", "CodeBleu_score": 38.83333018287882}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tstruct device *dev;\n\tconst struct device *codec_dev;\n\tstruct audio_codec_config cfg;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing codec device name\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tcodec_dev = audio_codec_get_device(dev);\n\tif (!codec_dev) {\n\t\tshell_error(sh, \"failed to get codec device\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_get_config(codec_dev, &cfg);\n\tif (ret) {\n\t\tshell_error(sh, \"failed to get codec config\");\n\t\treturn ret;\n\t}\n\n\tif (argc == 2) {\n\t\tshell_print(sh, \"codec device %s\", argv[1]);\n\t\tshell_print(sh, \"  type: %s\", cfg.type == AUDIO_CODEC_TYPE_DAC? \"DAC\" : \"ADC\");\n\t\tshell_print(sh, \"  channel count: %u\", cfg.channels);\n\t\tshell_print(sh, \"  sample rate: %u\", cfg.sample_rate);\n\t\tshell_print(sh, \"  resolution: %u\", cfg.resolution);\n\t\tshell_print(sh, \"  format: %s\", cfg.format == AUDIO_CODEC_FORMAT_I2S? \"I2S\" : \"PDM\");\n\t\tshell_print(sh, \"  dai: %s\", cfg.dai == AUDIO_CODEC_DAI_I2S? \"I2S\" : \"PDM\");\n\t\tshell_print(sh, \"  volume: %u\", cfg.volume);\n\t\treturn 0;\n\t}\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"missing codec property\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (strcmp(argv[2], \"volume\") == 0) {\n\t\tif (argc < 4) {\n\t\t\tshell_error(sh,", "CodeBleu_score": 56.362918005356335}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tstruct device *dev;\n\tint ret;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev, argv[2]);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 56.52654991362921}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tstruct device *dev;\n\tstruct audio_codec_cfg cfg;\n\tstruct audio_codec_config *codec_cfg;\n\n\tcodec_cfg = &cfg.config;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (argc == 3) {\n\t\tcodec_cfg->sample_rate = atoi(argv[2]);\n\t} else if (argc == 4) {\n\t\tcodec_cfg->sample_rate = atoi(argv[2]);\n\t\tcodec_cfg->channels = atoi(argv[3]);\n\t} else if (argc == 5) {\n\t\tcodec_cfg->sample_rate = atoi(argv[2]);\n\t\tcodec_cfg->channels = atoi(argv[3]);\n\t\tcodec_cfg->format = atoi(argv[4]);\n\t} else if (argc == 6) {\n\t\tcodec_cfg->sample_rate = atoi(argv[2]);\n\t\tcodec_cfg->channels = atoi(argv[3]);\n\t\tcodec_cfg->format = atoi(argv[4]);\n\t\tcodec_cfg->frame_size = atoi(argv[5]);\n\t} else if (argc == 7) {\n\t\tcodec_cfg->sample_rate = atoi(argv[2]);\n\t\tcodec_cfg->channels = atoi(argv[3]);\n\t\tcodec_cfg->format = atoi(argv[4]);\n\t\tcodec_cfg->frame_size = atoi(argv[5]);\n\t\tcodec_cfg->frame_count = atoi(argv[6]);\n\t} else {\n\t\tshell_error(sh, \"Too many arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = audio_codec_configure(dev, &cfg);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to configure audio codec\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 49.72881984233998}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Invalid state for start\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tret = mpxxdtyy_i2s_cmd(dev, MPXXDTYY_I2S_CMD_START);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Invalid state for stop\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tret = mpxxdtyy_i2s_cmd(dev, MPXXDTYY_I2S_CMD_STOP);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 54.364713683528706}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\n\tif (data->state == MPXXDTYY_I2S_STATE_STOPPED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"I2S trigger command %d not supported in state %d\",\n\t\t\t\tcmd, data->state);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t} else if (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_ERR(\"I2S trigger command %d not supported in state %d\",\n\t\t\t\tcmd, data->state);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t} else if (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"I2S trigger command %d not supported in state %d\",\n\t\t\t\tcmd, data->state);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"I2S trigger command %d not supported in state %d\",\n\t\t\tcmd, data->state);\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 34.80128113383801}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_PLAYBACK, I2S_CMD_TX_EN);\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_PLAYBACK, I2S_CMD_TX_DIS);\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported trigger command: %d\", cmd);\n\t\tret = -ENOTSUP;\n\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to trigger I2S command %d\", cmd);\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 43.45068701558489}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0;\n\n\tif (data->config->display_mode_command!= 0) {\n\t\tcommand = data->config->display_mode_command;\n\n\t\tif (data->config->display_mode_command_cursor_flag!= 0) {\n\t\t\tif (data->cursor_enabled) {\n\t\t\t\tcommand |= data->config->display_mode_command_cursor_flag;\n\t\t\t}\n\t\t}\n\n\t\tif (data->config->display_mode_command_blink_flag!= 0) {\n\t\t\tif (data->blink_enabled) {\n\t\t\t\tcommand |= data->config->display_mode_command_blink_flag;\n\t\t\t}\n\t\t}\n\n\t\tif (data->config->display_mode_command_display_flag!= 0) {\n\t\t\tif (enabled) {\n\t\t\t\tcommand |= data->config->display_mode_command_display_flag;\n\t\t\t}\n\t\t}\n\n\t\tauxdisplay_hd44780_send_command(dev, command);\n\t}\n}\n", "CodeBleu_score": 37.17975071167094}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tstruct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = config->display_mode_cmd;\n\n\tif (enabled) {\n\t\tcmd |= HD44780_DISPLAY_ON;\n\t} else {\n\t\tcmd &= ~HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= HD44780_CURSOR_ON;\n\t} else {\n\t\tcmd &= ~HD44780_CURSOR_ON;\n\t}\n\n\tif (data->blink_enabled) {\n\t\tcmd |= HD44780_BLINK_ON;\n\t} else {\n\t\tcmd &= ~HD44780_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_send_cmd(dev, cmd);\n}\n", "CodeBleu_score": 61.002680475831774}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = AUXDISPLAY_HD44780_DISPLAY_MODE_COMMAND;\n\n\tif (data->cursor_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ENABLED;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_POSITION_BLINK_ENABLED;\n\t}\n\n\tif (enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ENABLED;\n\t}\n\n\tauxdisplay_hd44780_send_command(dev, command);\n}\n", "CodeBleu_score": 58.20505174297628}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_raw(config->busy_gpio.port, config->busy_gpio.pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO pin status\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 70.09405374149051}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tstruct auxdisplay_itron_data *data = dev->data;\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpio, &data->busy_state);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn data->busy_state;\n}\n", "CodeBleu_score": 72.49711268670931}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\n\tif (config->gpio_busy.port == NULL) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->gpio_busy);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read busy GPIO pin\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 65.88825389737075}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst struct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(data->i2c, buffer, sizeof(buffer), config->i2c_addr);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to write special command to device\");\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->delay_after_command_ms));\n\n\treturn ret;\n}\n", "CodeBleu_score": 62.27013987969706}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint err;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\terr = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tLOG_ERR(\"I2C write failed with error code %d\", err);\n\t\treturn err;\n\t}\n\n\tk_msleep(config->command_delay);\n\n\treturn 0;\n}\n", "CodeBleu_score": 61.59182270341339}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2] = {\n\t\tAUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX,\n\t\tcommand\n\t};\n\tint ret;\n\n\tret = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to send special command %u\", command);\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->delay_ms));\n\n\treturn ret;\n}\n", "CodeBleu_score": 67.60948627754648}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_config *config = dev->config;\n\tuint32_t mem_size = config->mem_size;\n\n\tif (size == 0 || size > mem_size || offset > mem_size - size) {\n\t\tLOG_ERR(\"Invalid read size or offset\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, config->mem + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 55.24044400366762}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Read size exceeds BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\tLOG_ERR(\"Read size exceeds BBRAM data size\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram_data->data + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 62.5573494096881}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (size > config->size) {\n\t\tLOG_ERR(\"Read size %zu is greater than BBRAM size %zu\", size, config->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Read size %zu and offset %zu exceed BBRAM size %zu\", size, offset,\n\t\t\tconfig->size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, config->mem + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 59.31889120187155}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tconst struct bbram_emul_cfg *cfg = dev->config;\n\tstruct bbram_emul_data *data_ = dev->data;\n\tint ret = 0;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tif (data_->write_protected) {\n\t\treturn -EROFS;\n\t}\n\n\tmemcpy(&data_->mem[offset], data, size);\n\n\treturn ret;\n}\n", "CodeBleu_score": 52.909574890154246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (size == 0 || size > bbram_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_data->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bbram_data->data[offset], data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 52.80352835154094}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *const bbram_data = dev->data;\n\tint ret;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_data->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tret = memcpy_to_bbram(dev, offset, size, data);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 48.67269015724379}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tint err;\n\n\tif (argc < 1) {\n\t\tshell_error(sh, \"missing device name\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[0]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"no device %s\", argv[0]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 70.80729126867739}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tif (argc < 1) {\n\t\tshell_error(sh, \"missing argument: bbram device name\");\n\t\treturn -ENOARG;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[0]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"device '%s' not found\", argv[0]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 68.22554980304345}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device name\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device '%s' not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 77.5720778319594}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev)\tstruct h4_context *ctx = dev->data;\n\tuint8_t *hdr_buf = ctx->hdr_buf;\n\tuint8_t *hdr_buf_end = ctx->hdr_buf + sizeof(ctx->hdr_buf);\n\tuint8_t *hdr_buf_ptr = ctx->hdr_buf + ctx->hdr_buf_len;\n\tsize_t hdr_buf_rem = hdr_buf_end - hdr_buf_ptr;\n\tint ret;\n\n\tif (hdr_buf_rem == 0) {\n\t\tLOG_ERR(\"Header buffer is full\");\n\t\treturn;\n\t}\n\n\tret = uart_fifo_read(dev, hdr_buf_ptr, hdr_buf_rem);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read header: %d\", ret);\n\t\treturn;\n\t}\n\n\tctx->hdr_buf_len += ret;\n\thdr_buf_rem -= ret;\n\n\tif (hdr_buf_rem == 0) {\n\t\tLOG_DBG(\"Header buffer is full\");\n\t\treturn;\n\t}\n\n\tif (hdr_buf[0] == 0x00) {\n\t\tLOG_DBG(\"Received HCI packet type 0x%02x\", hdr_buf[0]);\n\t\tctx->pkt_type = BT_HCI_EVT_PKT;\n\t\tctx->acl_len = 0;\n\t\tctx->acl_buf_len = 0;\n\t\tctx->acl_buf = NULL;\n\t\tctx->acl_buf_rem = 0;\n\t} else if (hdr_buf[0] == 0x02) {\n\t\tLOG_DBG(\"Received HCI packet type 0x%02x\", hdr_buf[0]);\n\t\tctx->pkt_type = BT_HCI_ACL_PKT;\n\t\tctx->acl_buf = hdr_buf_ptr;\n\t\tctx->acl_buf_rem = hdr_buf_rem;\n\t\tctx->acl_len = sys_get_le16(&hdr_buf[1]);\n\t\tctx->acl_buf_len = 0;\n\t\tLOG_DBG(\"ACL data length: %d\", ctx->acl_len);\n\t", "CodeBleu_score": 41.7499603794798}, {"code": "static void h4_read_hdr(const struct device *dev)\tstruct h4_dev_data *h4_data = dev->data;\n\tstruct h4_hdr *hdr = &h4_data->hdr;\n\tint bytes_read;\n\n\thdr->len = sys_get_le24(hdr->len_buf);\n\n\tif (hdr->len > CONFIG_BT_H4_TX_BUF_LEN) {\n\t\tLOG_ERR(\"H4: invalid length %u\", hdr->len);\n\t\treturn;\n\t}\n\n\tbytes_read = h4_read(dev, hdr->data, hdr->len);\n\n\tif (bytes_read < 0) {\n\t\tLOG_ERR(\"H4: failed to read header\");\n\t\treturn;\n\t}\n\n\thdr->len -= bytes_read;\n}\n", "CodeBleu_score": 44.54153119824156}, {"code": "static void h4_read_hdr(const struct device *dev)\tstruct h4_dev *h4 = dev->data;\n\tint ret;\n\tint remaining = H4_HDR_SIZE - h4->hdr_cnt;\n\n\tret = uart_fifo_read(h4->uart, &h4->hdr[h4->hdr_cnt], remaining);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read header\");\n\t\treturn;\n\t}\n\th4->hdr_cnt += ret;\n\tremaining -= ret;\n\tif (remaining) {\n\t\tLOG_DBG(\"Read %d bytes, %d remaining\", ret, remaining);\n\t\th4->hdr_cnt = 0;\n\t\treturn;\n\t}\n\tLOG_DBG(\"Read header\");\n\th4->hdr_cnt = 0;\n\th4_process_hdr(dev);\n}\n", "CodeBleu_score": 48.067419554220834}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t read_len = 0;\n\tsize_t discarded_len = 0;\n\n\twhile (discarded_len < len) {\n\t\tread_len = min(len - discarded_len, sizeof(buf));\n\t\tif (uart_fifo_read(uart, buf, read_len)!= read_len) {\n\t\t\tLOG_ERR(\"Failed to read %zu bytes from UART\", read_len);\n\t\t\tbreak;\n\t\t}\n\t\tdiscarded_len += read_len;\n\t}\n\treturn discarded_len;\n}\n", "CodeBleu_score": 32.24272885}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t read_len;\n\tsize_t total_read = 0;\n\n\twhile (len > 0) {\n\t\tread_len = MIN(len, sizeof(buf));\n\t\tif (uart_fifo_read(uart, buf, read_len)!= 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART\");\n\t\t\treturn 0;\n\t\t}\n\t\ttotal_read += read_len;\n\t\tlen -= read_len;\n\t}\n\n\treturn total_read;\n}\n", "CodeBleu_score": 36.83288744795233}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t count = 0;\n\tsize_t read = 0;\n\n\twhile (len > 0) {\n\t\tread = len > sizeof(buf)? sizeof(buf) : len;\n\t\tcount = uart_fifo_read(uart, buf, read);\n\t\tif (count!= read) {\n\t\t\tLOG_ERR(\"Failed to read %zu bytes from UART FIFO\", read);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= count;\n\t}\n\n\treturn count;\n}\n", "CodeBleu_score": 37.055521686155316}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tzbus_lock_channel(chan);\n\tuint8_t highest_priority = 0xFF;\n\tfor (size_t i = 0; i < chan->num_observers; i++) {\n\t\tif (chan->observers[i].priority < highest_priority && chan->observers[i].enabled) {\n\t\t\thighest_priority = chan->observers[i].priority;\n\t\t}\n\t}\n\tchan->highest_observer_priority = highest_priority;\n\tzbus_unlock_channel(chan);\n}\n", "CodeBleu_score": 19.6099414994938}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tint32_t highest_observer_priority = 0;\n\tuint8_t i;\n\tzbus_lock_channel(chan);\n\tfor (i = 0; i < chan->num_observers; i++) {\n\t\tif (chan->observers[i].priority < highest_observer_priority && chan->observers[i].enabled) {\n\t\t\thighest_observer_priority = chan->observers[i].priority;\n\t\t}\n\t}\n\tchan->highest_observer_priority = highest_observer_priority;\n\tzbus_unlock_channel(chan);\n}\n", "CodeBleu_score": 22.947754037217404}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tzbus_channel_lock(chan);\n\tstruct zbus_observer *obs = chan->obs;\n\tuint8_t hop = 0xFF;\n\twhile (obs) {\n\t\tif (obs->enabled && obs->priority < hop) {\n\t\t\thop = obs->priority;\n\t\t}\n\t\tobs = obs->next;\n\t}\n\tchan->highest_observer_priority = hop;\n\tzbus_channel_unlock(chan);\n}\n", "CodeBleu_score": 18.612088472344965}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tfor (int i = 0; i < MAX_CHANNELS; i++) {\n\t\tif (channels[i].observer == obs) {\n\t\t\tupdate_channel_hop(&channels[i]);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 15.211096223512987}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tfor (int i = 0; i < MAX_OBSERVED_CHANNELS; i++) {\n\t\tif (obs->channels[i]!= NULL) {\n\t\t\tif (obs->channels[i]->obs == obs) {\n\t\t\t\tupdate_channel_hop(obs->channels[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 18.583086389344707}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tstruct channel_obs *chan;\n\tfor (chan = channels; chan; chan = chan->next) {\n\t\tif (chan->obs == obs) {\n\t\t\tupdate_channel_hop(chan);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 18.60977866973197}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tif (!obs)\n\t\treturn -1;\n\n\tif (zbus_is_isr())\n\t\treturn -1;\n\n\tspin_lock(&zbus_lock);\n\tobs->priority = zbus_get_min_priority();\n\tzbus_update_channels(obs);\n\tspin_unlock(&zbus_lock);\n\n\treturn 0;\n}\n", "CodeBleu_score": 31.52711403577055}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\tif (obs->thread!= NULL) {\n\t\treturn -2;\n\t}\n\tif (obs->priority > zbus_thread_get_priority(zbus_thread_self())) {\n\t\treturn -3;\n\t}\n\tobs->thread = zbus_thread_self();\n\treturn 0;\n}\n", "CodeBleu_score": 39.02957621440854}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\n\tspin_lock(&zbus_obs_lock);\n\tobs->priority = zbus_thread_get_priority();\n\tzbus_obs_update_channels(obs);\n\tspin_unlock(&zbus_obs_lock);\n\treturn 0;\n}\n", "CodeBleu_score": 44.47403742869216}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tk_timeout_t end_time;\n\tint ret = 0;\n\tint prio;\n\n\tZBUS_ASSERT_MSG(chan!= NULL, \"Channel is NULL\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tend_time = k_uptime_get() + timeout;\n\n\tprio = k_thread_priority_get(k_current_get());\n\tk_thread_priority_set(k_current_get(), K_PRIO_COOP(0));\n\n\tzbus_chan_lock(chan);\n\n\tret = zbus_chan_notify_locked(chan, end_time);\n\n\tzbus_chan_unlock(chan);\n\n\tk_thread_priority_set(k_current_get(), prio);\n\n\treturn ret;\n}\n", "CodeBleu_score": 52.721154733853645}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint err;\n\tstruct zbus_chan_notify_ctx ctx;\n\tk_timeout_t end_time;\n\tk_timeout_t adjusted_timeout;\n\n\tZBUS_ASSERT(chan!= NULL, \"Channel is NULL\");\n\tadjusted_timeout = zbus_adjust_timeout(timeout);\n\tend_time = k_uptime_get() + adjusted_timeout;\n\n\tctx.priority = k_thread_priority_get(k_current_get());\n\tctx.end_time = end_time;\n\tctx.timeout = adjusted_timeout;\n\n\terr = zbus_chan_lock(chan);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = zbus_chan_notify_locked(chan, &ctx);\n\n\tzbus_chan_unlock(chan);\n\treturn err;\n}\n", "CodeBleu_score": 50.09794883620764}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint err;\n\n\t__ASSERT_NO_MSG(chan!= NULL);\n\n\tif (timeout!= K_NO_WAIT) {\n\t\ttimeout = zbus_adjust_timeout(timeout);\n\t}\n\n\tstruct k_sem *sem = &chan->sem;\n\tstruct k_sem *sem_isr = &chan->sem_isr;\n\tstruct k_sem *sem_isr_notify = &chan->sem_isr_notify;\n\tstruct k_sem *sem_isr_notify_done = &chan->sem_isr_notify_done;\n\n\tstruct k_sem *sem_to_use = sem;\n\tstruct k_sem *sem_isr_to_use = sem_isr;\n\tstruct k_sem *sem_isr_notify_to_use = sem_isr_notify;\n\tstruct k_sem *sem_isr_notify_done_to_use = sem_isr_notify_done;\n\n\tif (chan->flags & ZBUS_CHAN_FLAG_NO_ISR_NOTIFY) {\n\t\tsem_isr_to_use = NULL;\n\t\tsem_isr_notify_to_use = NULL;\n\t\tsem_isr_notify_done_to_use = NULL;\n\t}\n\n\tif (chan->flags & ZBUS_CHAN_FLAG_NO_NOTIFY) {\n\t\tsem_to_use = NULL;\n\t}\n\n\terr = zbus_chan_notify_sems(sem_to_use, sem_isr_to_use, sem_isr_notify_to_use,\n\t\t\t\t    sem_isr_notify_done_to_use, timeout);\n\n\treturn err;\n}\n", "CodeBleu_score": 32.18358071868817}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tif (enable) {\n\t\tif (Int & (ETH_IT_NIS | ETH_IT_AIS)) {\n\t\t\tETH->IER |= Int;\n\t\t} else {\n\t\t\tETH->DMAIER |= Int;\n\t\t}\n\t} else {\n\t\tif (Int & (ETH_IT_NIS | ETH_IT_AIS)) {\n\t\t\tETH->IER &= ~Int;\n\t\t} else {\n\t\t\tETH->DMAIER &= ~Int;\n\t\t}\n\t\tif (ETH->IER == 0) {\n\t\t\tETH->DMAIER &= ~ETH_IT_NIS;\n\t\t}\n\t\tif (ETH->DMAIER == 0) {\n\t\t\tETH->DMAIER &= ~ETH_IT_AIS;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.33533402738746}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tif (Int == ETH_INT_NORMAL) {\n\t\tif (enable) {\n\t\t\tETH->IER |= ETH_IER_NIE;\n\t\t} else {\n\t\t\tETH->IER &= ~ETH_IER_NIE;\n\t\t}\n\t} else if (Int == ETH_INT_ABNORMAL) {\n\t\tif (enable) {\n\t\t\tETH->IER |= ETH_IER_AIE;\n\t\t} else {\n\t\t\tETH->IER &= ~ETH_IER_AIE;\n\t\t}\n\t} else {\n\t\tif (enable) {\n\t\t\tETH->IER |= Int;\n\t\t} else {\n\t\t\tETH->IER &= ~Int;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.35081980678202}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_ETH_BOOL(enable));\n\n\tif (enable) {\n\t\t/* Enable the selected Ethernet interrupt */\n\t\tETH->INTEN |= Int;\n\t} else {\n\t\t/* Disable the selected Ethernet interrupt */\n\t\tETH->INTEN &= ~Int;\n\t}\n}\n", "CodeBleu_score": 18.111310394771447}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pDesc;\n\tuint32_t n;\n\n\t/* Get the current Tx descriptor */\n\tpDesc = pTxDesc;\n\n\t/* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */\n\tfor (n = 0; n < ETH_TXBUFNB; n++) {\n\t\tif ((pDesc->Status & ETH_DMATxDesc_OWN) == (uint32_t) RESET) {\n\t\t\t/* Return the descriptor address */\n\t\t\treturn pDesc;\n\t\t} else {\n\t\t\t/* Point to the next descriptor */\n\t\t\tpDesc = (ETH_TX_DESC *) ((uint32_t) pDesc + 0x10 + ETH_TX_BUF_SIZE);\n\t\t}\n\t}\n\n\t/* Return NULL pointer */\n\treturn NULL;\n}\n", "CodeBleu_score": 43.059716554902295}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\t/* Get the current transmit descriptor */\n\tpTxDesc = pTxDescTail;\n\n\t/* Check if the current transmit descriptor is owned by the device */\n\tif (pTxDesc->Status & ETH_TX_DESC_STATUS_OWN) {\n\t\t/* Loop through the transmit descriptor list until a free descriptor is found */\n\t\tfor (i = 0; i < ETH_NUM_TX_DESC; i++) {\n\t\t\t/* Check if the current transmit descriptor is owned by the device */\n\t\t\tif ((pTxDesc->Status & ETH_TX_DESC_STATUS_OWN) == 0) {\n\t\t\t\t/* Return the current transmit descriptor */\n\t\t\t\treturn pTxDesc;\n\t\t\t}\n\n\t\t\t/* Get the next transmit descriptor */\n\t\t\tpTxDesc = (ETH_TX_DESC *)((uint32_t)pTxDesc + ETH_TX_DESC_SIZE);\n\n\t\t\t/* Check if the transmit descriptor list has been looped back to the starting address */\n\t\t\tif (pTxDesc == pTxDescStart) {\n\t\t\t\t/* Return 0 to indicate that no free descriptor was found */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return the current transmit descriptor */\n\treturn pTxDesc;\n}\n", "CodeBleu_score": 45.694790888113275}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\t/* Get the current Tx descriptor */\n\tpTxDesc = pTxDescTab;\n\n\t/* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */\n\tfor (i = 0; i < ETH_TXBUFNB; i++) {\n\t\tif ((pTxDesc->Status & ETH_DMATxDesc_OWN) == (uint32_t) RESET) {\n\t\t\t/* Set Owner (SW) bit */\n\t\t\tpTxDesc->Status |= ETH_DMATxDesc_OWN;\n\n\t\t\t/* Return Descriptor address */\n\t\t\treturn pTxDesc;\n\t\t} else {\n\t\t\tpTxDesc = (ETH_TX_DESC *) ((uint32_t) pTxDesc + 0x10 + ETH_TX_BUF_SIZE);\n\t\t}\n\t}\n\n\t/* No free Tx descriptor to give */\n\treturn (ETH_TX_DESC *) 0;\n}\n", "CodeBleu_score": 43.97327986149613}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\tcy_rslt_t ret;\n\tcy_stc_csd_context_t *context;\n\tcy_stc_csd_config_t config;\n\tcy_stc_csd_config_t *config_ptr;\n\tcy_stc_csd_context_t *context_ptr;\n\tcy_stc_csd_config_t *config_ptr_old;\n\tcy_stc_csd_context_t *context_ptr_old;\n\tcy_stc_csd_config_t *config_ptr_new;\n\tcy_stc_csd_context_t *context_ptr_new;\n\tcy_stc_csd_context_t *context_ptr_new_old;\n\tcy_stc_csd_context_t *context_ptr_old_new;\n\tcy_stc_csd_context_t *context_ptr_new_new;\n\tcy_stc_csd_config_t *config_ptr_new_old;\n\tcy_stc_csd_config_t *config_ptr_old_new;\n\tcy_stc_csd_config_t *config_ptr_new_new;\n\tcy_stc_csd_context_t *context_ptr_new_new_old;\n\tcy_stc_csd_context_t *context_ptr_old_new_new;\n\tcy_stc_csd_context_t *context_ptr_new_old_new;\n\tcy_stc_csd_context_t *context_ptr_new_new_new;\n\tcy_stc_csd_config_t *config_ptr_new_new_old;\n\tcy_stc_csd_config_t *config_ptr_old_new_new;\n\tcy_stc_csd_config_t *config_ptr_new_old_new;\n\tcy_stc_csd_config_t *config_ptr_new_new_new;\n\tcy_stc_csd_context_t *context_ptr_new_new_new_old;\n\tcy_stc_csd_context_t *context_ptr_old_new_new_new;\n\tcy_stc_csd_context_t *context_ptr_new_old_new_new;\n\tcy_", "CodeBleu_score": 15.901948977782226}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\tcy_stc_csd_context_t *context = NULL;\n\tcy_en_csd_status_t status;\n\n\t/* Check if device is null */\n\tif (device == NULL) {\n\t\tLOG_E(\"Device is null\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* Get the context for the device */\n\tcontext = (cy_stc_csd_context_t *)device->parent.user_data;\n\n\t/* Check if context is null */\n\tif (context == NULL) {\n\t\tLOG_E(\"Context is null\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* Check if the value is null */\n\tif (value == NULL) {\n\t\tLOG_E(\"Value is null\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* Convert the value */\n\tstatus = Cy_CSDIDAC_OutputEnable(context, channel, *value);\n\n\t/* Check if the conversion failed */\n\tif (status!= CY_CSD_SUCCESS) {\n\t\tLOG_E(\"Conversion failed with error code %d\", status);\n\t\treturn -RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 46.258041759010155}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\tcyp_adc_t *dac;\n\tcy_rslt_t result;\n\trt_err_t ret = RT_EOK;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tdac = (cyp_adc_t *)device->parent.user_data;\n\n\tresult = Cy_CSDIDAC_OutputEnable(dac->adc, (uint32_t)value[0]);\n\tif (result!= CY_CSDIDAC_SUCCESS) {\n\t\tLOG_E(\"Cy_CSDIDAC_OutputEnable failed, error = %d\", result);\n\t\tret = -RT_ERROR;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 40.269244045044296}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\trt_uint32_t i;\n\trt_uint32_t read_addr;\n\trt_uint32_t read_size;\n\trt_uint8_t *read_buf;\n\n\t/* Check if the read operation would exceed the flash memory's end address */\n\tif ((addr + size) > FLASH_MEM_END_ADDR) {\n\t\trt_kprintf(\"ifx_flash_read_32k: Read address or size exceeds flash memory's end address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read data from flash memory into a buffer */\n\tread_addr = addr;\n\tread_size = size;\n\tread_buf = buf;\n\tfor (i = 0; i < read_size; i++) {\n\t\t*read_buf = *(rt_uint8_t *)read_addr;\n\t\tread_addr++;\n\t\tread_buf++;\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 50.288397172746244}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\trt_uint32_t i;\n\trt_uint32_t end_addr = addr + size;\n\trt_uint32_t end_addr_32k = (addr & 0xFFFF0000) + 0x10000;\n\n\tif (end_addr > end_addr_32k) {\n\t\trt_kprintf(\"Error: ifx_flash_read_32k: address range exceeds 32K boundary\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 39.77948255809916}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\trt_uint32_t i;\n\trt_uint32_t flash_end_addr = FLASH_BASE + FLASH_SIZE;\n\tif (addr + size > flash_end_addr) {\n\t\trt_kprintf(\"ifx_flash_read_32k: address 0x%x + size 0x%x exceeds flash end address 0x%x\\n\", addr, size, flash_end_addr);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t*)(addr + i);\n\t}\n\treturn size;\n}\n", "CodeBleu_score": 48.672032556315216}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\tRT_ASSERT(timer);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}\n", "CodeBleu_score": 23.481013110387867}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\tRT_ASSERT(timer!= RT_NULL);\n\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}\n", "CodeBleu_score": 27.797023439087194}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\tRT_ASSERT(timer);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}\n", "CodeBleu_score": 23.481013110387867}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void)\tint result = pthread_mutex_lock(&dfs_mutex);\n\tif (result!= 0) {\n\t\tassert(result == EBUSY);\n\t}\n}\n", "CodeBleu_score": 8.902359227177255}, {"code": "void dfs_lock(void)\tint res;\n\n\tdo {\n\t\tres = pthread_mutex_lock(&dfs_mutex);\n\t} while (res == EBUSY);\n\tassert(res == 0);\n}\n", "CodeBleu_score": 15.731376656675607}, {"code": "void dfs_lock(void)\tint ret;\n\tdo {\n\t\tret = pthread_mutex_lock(&dfs_mutex);\n\t} while (ret == EBUSY);\n\tassert(ret == 0);\n}\n", "CodeBleu_score": 15.662185083284244}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint fd;\n\tint i;\n\tint j;\n\tint k;\n\tint l;\n\tint m;\n\tint n;\n\tint o;\n\tint p;\n\tint q;\n\tint r;\n\tint s;\n\tint t;\n\tint u;\n\tint v;\n\tint w;\n\tint x;\n\tint y;\n\tint z;\n\tint aa;\n\tint ab;\n\tint ac;\n\tint ad;\n\tint ae;\n\tint af;\n\tint ag;\n\tint ah;\n\tint ai;\n\tint aj;\n\tint ak;\n\tint al;\n\tint am;\n\tint an;\n\tint ao;\n\tint ap;\n\tint aq;\n\tint ar;\n\tint as;\n\tint at;\n\tint au;\n\tint av;\n\tint aw;\n\tint ax;\n\tint ay;\n\tint az;\n\tint ba;\n\tint bb;\n\tint bc;\n\tint bd;\n\tint be;\n\tint bf;\n\tint bg;\n\tint bh;\n\tint bi;\n\tint bj;\n\tint bk;\n\tint bl;\n\tint bm;\n\tint bn;\n\tint bo;\n\tint bp;\n\tint bq;\n\tint br;\n\tint bs;\n\tint bt;\n\tint bu;\n\tint bv;\n\tint bw;\n\tint bx;\n\tint by;\n\tint bz;\n\tint ca;\n\tint cb;\n\tint cc;\n\tint cd;\n\tint ce;\n\tint cf;\n\tint cg;\n\tint ch;\n\tint ci;\n\tint cj;\n\tint ck;\n\tint cl;\n\tint cm;\n\tint cn;\n\tint co;\n\tint cp;\n\tint cq;\n\tint cr;\n\tint cs;\n\tint ct;\n\tint cu;\n\tint cv;\n\tint cw;\n\tint cx;\n\tint cy;\n\tint cz;\n\tint da;\n\tint db;\n\tint dc;\n\tint dd;\n\tint", "CodeBleu_score": 4.779896621430845}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint fd;\n\n\t/* find an empty slot */\n\tfor (fd = startfd; fd < DFS_FD_MAX; fd++) {\n\t\tif (fdt->fd[fd].type == FD_TYPE_NONE) {\n\t\t\tfdt->fd[fd].type = FD_TYPE_ALLOC;\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* expand the fd table */\n\tif (fd_table_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* find an empty slot again */\n\tfor (fd = startfd; fd < DFS_FD_MAX; fd++) {\n\t\tif (fdt->fd[fd].type == FD_TYPE_NONE) {\n\t\t\tfdt->fd[fd].type = FD_TYPE_ALLOC;\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* should never reach here */\n\treturn -1;\n}\n", "CodeBleu_score": 43.25811146518006}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint i;\n\tint fd;\n\n\tif (fdt == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\tif (fdt->fd[i] == NULL) {\n\t\t\tfd = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == fdt->maxfd) {\n\t\tif (fd_table_expand(fdt) == 0) {\n\t\t\tfd = i;\n\t\t} else {\n\t\t\tfd = -1;\n\t\t}\n\t}\n\n\treturn fd;\n}\n", "CodeBleu_score": 43.35461742114111}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error)\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < sizeof(error_table) / sizeof(error_table[0]); i++) {\n\t\tif (error_table[i].num == error) {\n\t\t\treturn error_table[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}\n", "CodeBleu_score": 56.8990475908128}, {"code": "const char *rt_strerror(rt_err_t error)\trt_err_t err;\n\n\tif (error < 0) {\n\t\terr = -error;\n\t} else {\n\t\terr = error;\n\t}\n\n\tfor (int i = 0; i < sizeof(err_table) / sizeof(err_table[0]); i++) {\n\t\tif (err_table[i].err == err) {\n\t\t\treturn err_table[i].err_str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}\n", "CodeBleu_score": 57.6863148685209}, {"code": "const char *rt_strerror(rt_err_t error)\tunsigned int err = (unsigned int) error;\n\tconst char *err_str = \"EUNKNOW\";\n\tint i;\n\n\tfor (i = 0; i < sizeof(err_table) / sizeof(struct err_code); i++) {\n\t\tif (err_table[i].err == err) {\n\t\t\terr_str = err_table[i].err_str;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err_str;\n}\n", "CodeBleu_score": 43.640630183957626}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\t/* take idle lock */\n\tlevel = rt_hw_interrupt_disable();\n\t/* find a empty slot */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n\t\tif (rt_thread_idle_hook[i] == RT_NULL) {\n\t\t\trt_thread_idle_hook[i] = hook;\n\t\t\tbreak;\n\t\t}\n\t\t/* hook is full */\n\t\tif (i == RT_THREAD_IDLE_HOOK_MAX - 1) {\n\t\t\tresult = -RT_EFULL;\n\t\t}\n\t}\n\t/* release idle lock */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 46.47061556093653}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_base_t level;\n\trt_err_t result;\n\n\t/* take idle hook lock */\n\tlevel = rt_hw_interrupt_disable();\n\t/* check if there is empty slot */\n\tif (idle_thread_hook_list.count < RT_THREAD_IDLE_HOOK_MAX) {\n\t\t/* set hook */\n\t\tidle_thread_hook_list.hook[idle_thread_hook_list.count++] = hook;\n\t\tresult = RT_EOK;\n\t} else {\n\t\t/* no empty slot */\n\t\tresult = -RT_EFULL;\n\t}\n\t/* release idle hook lock */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 22.327667674790064}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\tregister rt_base_t temp;\n\trt_err_t result = -RT_EFULL;\n\n\t/* disable interrupt */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* find an empty slot */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n\t\tif (rt_thread_idle_hook[i] == RT_NULL) {\n\t\t\trt_thread_idle_hook[i] = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(temp);\n\n\treturn result;\n}", "CodeBleu_score": 46.98267548296728}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_uint8_t index;\n\trt_err_t result = -RT_ENOSYS;\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* search hook */\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_NUM; index++) {\n\t\tif (rt_thread_idle_hook[index] == hook) {\n\t\t\t/* remove hook */\n\t\t\trt_thread_idle_hook[index] = RT_NULL;\n\n\t\t\t/* return success */\n\t\t\tresult = RT_EOK;\n\n\t\t\t/* break */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\treturn result;\n}\n", "CodeBleu_score": 52.49234077392809}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_base_t level;\n\trt_uint32_t i;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* search hook */\n\tfor (i = 0; i < RT_THREAD_IDLE_HOOK_NUM; i++) {\n\t\tif (idle_hook[i] == hook) {\n\t\t\tidle_hook[i] = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\tif (i < RT_THREAD_IDLE_HOOK_NUM)\n\t\treturn RT_EOK;\n\telse\n\t\treturn -RT_ENOSYS;\n}\n", "CodeBleu_score": 47.92021168904193}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_base_t level;\n\trt_uint32_t index;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* search hook */\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_MAX; index++) {\n\t\tif (idle_hook[index] == hook) {\n\t\t\tidle_hook[index] = RT_NULL;\n\t\t\t/* enable interrupt */\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn -RT_ENOSYS;\n}\n", "CodeBleu_score": 44.612152966219234}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\tregister rt_base_t level;\n\tregister rt_thread_t thread;\n\n\t/* ensure the scheduler is unlocked */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* dequeue and resume each suspended thread */\n\twhile ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist))!= RT_NULL) {\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\t\t/* set error code */\n\t\tthread->error = thread_error;\n\t}\n\n\t/* resume scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 33.4785275712699}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\tregister rt_base_t temp;\n\tregister rt_thread_t thread;\n\tregister rt_list_t *list;\n\n\t/* disable interrupt */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* get the first thread */\n\tlist = susp_list;\n\tthread = rt_list_entry(list, rt_thread_t, tlist);\n\n\t/* resume all thread */\n\twhile (list!= RT_LIST_END(susp_list)) {\n\t\t/* remove thread from suspension list */\n\t\trt_list_remove(list);\n\n\t\t/* set error code */\n\t\tthread->error = thread_error;\n\n\t\t/* resume from suspended thread */\n\t\trt_thread_resume(thread);\n\n\t\t/* get next thread */\n\t\tlist = list->next;\n\t\tthread = rt_list_entry(list, rt_thread_t, tlist);\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(temp);\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 37.524467093343716}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\tregister rt_base_t level;\n\tstruct rt_thread *thread;\n\n\t/* ensure scheduler is unlocked */\n\tlevel = rt_hw_interrupt_disable();\n\t/* resume all threads */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\t/* get the first thread in the list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread,\n\t\t\t\ttlist);\n\t\t/* remove thread from the list */\n\t\trt_list_remove(&(thread->tlist));\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\t\t/* set thread error code */\n\t\tthread->error = thread_error;\n\t}\n\t/* resume scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 35.797552766297684}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t old_console_device;\n\n\t/* save the old console device */\n\told_console_device = rt_console_get_device();\n\n\t/* find the new console device by its name */\n\trt_console_device = rt_device_find(name);\n\n\t/* if the new console device is different and valid */\n\tif (rt_console_device!= old_console_device && rt_console_device!= RT_NULL) {\n\t\t/* close the old console device if it exists */\n\t\tif (old_console_device!= RT_NULL) {\n\t\t\trt_device_close(old_console_device);\n\t\t}\n\n\t\t/* open the new console device with read/write and stream flags */\n\t\trt_device_open(rt_console_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t}\n\n\t/* return the old console device */\n\treturn old_console_device;\n}\n", "CodeBleu_score": 43.1796430647262}, {"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t old_console;\n\trt_device_t new_console;\n\n\t/* save the old console device */\n\told_console = rt_console_get_device();\n\n\t/* find the new console device */\n\tnew_console = rt_device_find(name);\n\tif (new_console!= RT_NULL) {\n\t\t/* if it is different and valid, close the old console device and set the new one */\n\t\tif (new_console!= old_console) {\n\t\t\t/* close the old console device */\n\t\t\tif (old_console!= RT_NULL) {\n\t\t\t\trt_device_close(old_console);\n\t\t\t}\n\n\t\t\t/* open the new console device */\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t/* set the new console device */\n\t\t\t\trt_console_set_device_impl(new_console);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old_console;\n}\n", "CodeBleu_score": 50.44215374897223}, {"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t old;\n\trt_device_t console;\n\n\t/* save old console device */\n\told = rt_console_device;\n\n\t/* get new console device */\n\tconsole = rt_device_find(name);\n\tif (console!= RT_NULL && console!= old) {\n\t\t/* close old console */\n\t\tif (old!= RT_NULL) {\n\t\t\trt_device_close(old);\n\t\t}\n\n\t\t/* set new console device */\n\t\trt_console_device = console;\n\n\t\t/* open new console device */\n\t\tif (rt_device_open(console, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t/* set console device */\n\t\t\trt_set_console(console);\n\t\t} else {\n\t\t\trt_console_device = RT_NULL;\n\t\t}\n\t}\n\n\treturn old;\n}\n", "CodeBleu_score": 53.684028301237085}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type)\tstruct rt_object_class *class = rt_object_get_class(type);\n\tint count = 0;\n\n\tif (class) {\n\t\trt_spinlock_lock(&class->lock);\n\t\tstruct rt_object *obj = class->objects;\n\t\twhile (obj) {\n\t\t\tcount++;\n\t\t\tobj = obj->next;\n\t\t}\n\t\trt_spinlock_unlock(&class->lock);\n\t}\n\n\treturn count;\n}\n", "CodeBleu_score": 30.49464180795368}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tstruct rt_object_class *class;\n\tint count = 0;\n\trt_spinlock_lock(&rt_object_class_lock);\n\tclass = rt_object_class_get_first();\n\twhile (class!= NULL) {\n\t\tif (class->type == type) {\n\t\t\tcount++;\n\t\t}\n\t\tclass = rt_object_class_get_next(class);\n\t}\n\trt_spinlock_unlock(&rt_object_class_lock);\n\treturn count;\n}\n", "CodeBleu_score": 33.54495238857895}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tint length = 0;\n\tstruct rt_object_class *object_class = rt_object_class_get(type);\n\trt_spinlock_lock(&object_class->lock);\n\tstruct rt_object *object = object_class->object_list;\n\twhile (object) {\n\t\tlength++;\n\t\tobject = object->next;\n\t}\n\trt_spinlock_unlock(&object_class->lock);\n\treturn length;\n}\n", "CodeBleu_score": 27.354692382441364}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object)\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\tif (object->type_info!= RT_NULL) {\n\t\t/* invoke detach hook */\n\t\tif (object->type_info->detach_hook!= RT_NULL) {\n\t\t\tobject->type_info->detach_hook(object);\n\t\t}\n\n\t\t/* remove from object list */\n\t\trt_list_remove(&(object->list));\n\n\t\t/* unlock object spinlock */\n\t\trt_spin_unlock(&object->spinlock);\n\n\t\t/* set object type to zero */\n\t\tobject->type = 0;\n\t}\n}\n", "CodeBleu_score": 46.853111397977536}, {"code": "void rt_object_detach(rt_object_t object)\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* invoke detach hook */\n\tif (object->detach_hook) {\n\t\tobject->detach_hook(object);\n\t}\n\n\t/* remove object from list */\n\trt_object_information_t info;\n\tinfo = rt_object_get_information(object->type);\n\trt_spin_lock(&info->list_lock);\n\trt_list_remove(&(object->list));\n\trt_spin_unlock(&info->list_lock);\n\n\t/* set object type to zero */\n\tobject->type = RT_Object_Class_Unknown;\n}\n", "CodeBleu_score": 47.95889772297494}, {"code": "void rt_object_detach(rt_object_t object)\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\tif (object->type_info!= RT_NULL) {\n\t\tif (object->type_info->detach_hook!= RT_NULL) {\n\t\t\tobject->type_info->detach_hook(object);\n\t\t}\n\n\t\trt_enter_critical();\n\t\trt_list_remove(&(object->list));\n\t\trt_exit_critical();\n\n\t\tobject->type = 0;\n\t}\n}\n", "CodeBleu_score": 44.956907378728914}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_err_t err;\n\trt_custom_object_t *cobj;\n\n\tif (obj == NULL) {\n\t\treturn RT_ERR_NULL;\n\t}\n\n\tif (obj->class_id!= RT_CLASS_CUSTOM_OBJECT) {\n\t\treturn RT_ERR_CLASS_ID;\n\t}\n\n\tcobj = (rt_custom_object_t *) obj;\n\n\tif (cobj->destroy!= NULL) {\n\t\terr = cobj->destroy(cobj);\n\t\tif (err!= RT_ERR_OK) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\trt_free(obj);\n\treturn RT_ERR_OK;\n}\n", "CodeBleu_score": 44.983497961098216}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_err_t err = RT_OK;\n\n\tif (obj!= NULL && obj->type == RT_OBJECT_TYPE_CUSTOM) {\n\t\tif (obj->destroy!= NULL) {\n\t\t\terr = obj->destroy(obj);\n\t\t}\n\t\trt_free(obj);\n\t} else {\n\t\terr = RT_ERR_INVALID_VALUE;\n\t}\n\n\treturn err;\n}\n", "CodeBleu_score": 41.01627337703833}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_err_t ret = RT_OK;\n\trt_custom_object_t *cobj;\n\n\tif (obj == NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\tcobj = (rt_custom_object_t *) obj;\n\tif (cobj->destroy!= NULL) {\n\t\tret = cobj->destroy(obj);\n\t}\n\trt_free(obj);\n\treturn ret;\n}\n", "CodeBleu_score": 46.44346001699603}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void)\tthread_t *thread = _thread_get_current();\n\t_thread_enter_critical_section();\n\t_thread_close(thread);\n\t_thread_exit_critical_section();\n\t_thread_schedule();\n}\n", "CodeBleu_score": 24.591634992687784}, {"code": "static void _thread_exit(void)\tthread_t *thread = current_thread();\n\n\tif (thread == NULL)\n\t\treturn;\n\n\t// Enter the critical section\n\t_critical_section_enter();\n\n\t// Close the thread\n\tthread_close(thread);\n\n\t// Add the thread to the defunct thread list\n\t_defunct_thread_add(thread);\n\n\t// Exit the critical section\n\t_critical_section_exit();\n\n\t// Trigger a context switch\n\t_context_switch();\n}\n", "CodeBleu_score": 51.040867913751555}, {"code": "static void _thread_exit(void)\tthread_t* current_thread = _thread_get_current();\n\t_thread_enter_critical_section();\n\t_thread_close(current_thread);\n\t_thread_exit_critical_section();\n\t_scheduler_schedule();\n}\n", "CodeBleu_score": 25.06359339294317}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter)\tstruct thread *thread = (struct thread *) parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\t_scheduler_lock();\n\tif (thread->state == THREAD_STATE_SUSPENDED) {\n\t\tthread->error = THREAD_ERROR_TIMEOUT;\n\t\t_thread_remove_from_suspend_list(thread);\n\t\t_thread_insert_into_ready_list(thread);\n\t}\n\t_scheduler_unlock();\n}\n", "CodeBleu_score": 36.039594559405266}, {"code": "static void _thread_timeout(void *parameter)\tstruct thread *thread = parameter;\n\tassert(thread!= NULL);\n\tassert(thread->magic == THREAD_MAGIC);\n\tassert(thread->state == THREAD_SUSPENDED);\n\tassert(thread->timeout_event!= NULL);\n\tassert(thread->timeout_event->magic == EVENT_MAGIC);\n\tassert(thread->timeout_event->type == EVENT_TIMEOUT);\n\tassert(thread->timeout_event->thread == thread);\n\tassert(thread->timeout_event->timeout!= 0);\n\tassert(thread->timeout_event->timeout_event == thread->timeout_event);\n\tassert(thread->timeout_event->timeout_event->magic == EVENT_MAGIC);\n\tassert(thread->timeout_event->timeout_event->type == EVENT_TIMEOUT);\n\tassert(thread->timeout_event->timeout_event->thread == thread);\n\tassert(thread->timeout_event->timeout_event->timeout!= 0);\n\tassert(thread->timeout_event->timeout_event->timeout_event == thread->timeout_event);\n\tscheduler_lock();\n\tif (thread->state == THREAD_SUSPENDED) {\n\t\tthread->error = ETIMEDOUT;\n\t\tevent_remove(thread->timeout_event);\n\t\tevent_insert(thread->timeout_event);\n\t\tthread_ready(thread);\n\t}\n\tscheduler_unlock();\n}\n", "CodeBleu_score": 37.873113609156576}, {"code": "static void _thread_timeout(void *parameter)\tstruct thread *thread = (struct thread *)parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tscheduler_lock();\n\n\tif (thread->state == THREAD_STATE_SUSPENDED) {\n\t\tthread->error = THREAD_ERROR_TIMEOUT;\n\t\tthread_remove_from_suspend_list(thread);\n\t\tthread_insert_into_ready_list(thread);\n\t}\n\n\tscheduler_unlock();\n}\n", "CodeBleu_score": 35.85786776037729}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_spinlock_lock(&thread->lock);\n\tif (thread->pending_object!= NULL) {\n\t\t_mutex_remove_from_waitlist((rt_mutex_t)thread->pending_object, thread);\n\t\tthread->pending_object = NULL;\n\t}\n\t_mutex_release_all(thread);\n\trt_spinlock_unlock(&thread->lock);\n}\n", "CodeBleu_score": 14.845924448135023}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_spinlock_lock(&thread->spinlock);\n\tif (thread->pending_object) {\n\t\trt_spinlock_lock(&thread->pending_object->spinlock);\n\t\trt_list_remove(&thread->pending_object->waiting_threads, &thread->pending_object_node);\n\t\tthread->pending_object = NULL;\n\t\trt_spinlock_unlock(&thread->pending_object->spinlock);\n\t}\n\trt_spinlock_unlock(&thread->spinlock);\n}\n", "CodeBleu_score": 26.29038141450792}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_object_t object;\n\trt_uint8_t state;\n\trt_uint8_t level;\n\n\t/* lock the thread's spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\tstate = thread->stat;\n\tif (state & RT_THREAD_STAT_SUSPEND) {\n\t\t/* the thread is suspended */\n\t\tthread->stat = state & ~RT_THREAD_STAT_SUSPEND;\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* the thread is not suspended */\n\tif (state & RT_THREAD_STAT_MUTEX) {\n\t\t/* the thread is waiting on a mutex */\n\t\tobject = thread->pending_object;\n\t\t_mutex_remove_thread(object, thread);\n\t\tthread->pending_object = RT_NULL;\n\t\tthread->stat = state & ~RT_THREAD_STAT_MUTEX;\n\t}\n\n\t/* release all mutexes the thread has taken */\n\t_mutex_release_all(thread);\n\n\t/* restore the spinlock state */\n\tthread->stat = state & ~RT_THREAD_STAT_MUTEX;\n\trt_hw_interrupt_enable(level);\n}\n", "CodeBleu_score": 42.97694973412376}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\tregister rt_uint8_t temp;\n\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->type == RT_Object_Class_Thread);\n\n\t/* initialize thread's priority */\n\ttemp = thread->current_priority;\n\tthread->current_priority = thread->init_priority;\n\tthread->number_mask = (1L << thread->current_priority);\n\tthread->stat = RT_THREAD_SUSPEND;\n\t/* start it */\n\trt_thread_resume(thread);\n\t/* if scheduler is running, switch to this thread */\n\tif (rt_scheduler_started()) {\n\t\trt_schedule();\n\t}\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 42.35691436124166}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->parent.list == RT_NULL);\n\n\t/* set startup error number */\n\tthread->error = RT_EOK;\n\n\t/* set the default priority */\n\trt_thread_control(thread, RT_THREAD_CTRL_CHANGE_PRIORITY, &thread->init_priority);\n\n\t/* set thread name */\n\trt_strncpy(thread->name, thread->init_thread_name, RT_NAME_MAX);\n\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* start thread */\n\trt_schedule_remove_thread(thread);\n\trt_list_insert_after(&rt_thread_priority_table[thread->current_priority], &thread->tlist);\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 46.913810884187406}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\trt_err_t result = RT_EOK;\n\n\t/* Check thread */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* Check thread is not in initialization state */\n\tif (thread->stat == RT_THREAD_INIT) {\n\t\t/* Set thread name */\n\t\trt_strncpy(thread->name, thread->parent.name, RT_NAME_MAX);\n\n\t\t/* Set thread number */\n\t\tthread->tid = ++rt_thread_next_number;\n\n\t\t/* Set thread priority */\n\t\trt_thread_init_priority(thread);\n\n\t\t/* Set thread state */\n\t\tthread->stat = RT_THREAD_SUSPEND;\n\n\t\t/* Resume thread */\n\t\trt_thread_resume(thread);\n\n\t\t/* Trigger scheduler */\n\t\trt_schedule();\n\t} else {\n\t\tresult = -RT_ERROR;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 45.726965506666176}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\trt_uint8_t index;\n\n\tfor (index = 0; index < RT_TIMER_SKIP_LIST_LEVEL; index++) {\n\t\tif (!rt_list_isempty(&(timer_list[index]))) {\n\t\t\t*timeout_tick = rt_list_entry(timer_list[index].next, struct rt_timer, row[index])->timeout_tick;\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\treturn -RT_ERROR;\n}\n", "CodeBleu_score": 48.543589377594735}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\tstruct rt_timer *timer;\n\n\t/* get the first timer from the timer list */\n\ttimer = rt_list_entry(timer_list[0].next, struct rt_timer, row[0]);\n\n\t/* check if the timer is valid */\n\tif (timer->parent.list!= RT_NULL) {\n\t\t/* set the timeout tick */\n\t\t*timeout_tick = timer->timeout_tick;\n\n\t\t/* return RT_EOK */\n\t\treturn RT_EOK;\n\t}\n\n\t/* return error code */\n\treturn -RT_ERROR;\n}\n", "CodeBleu_score": 50.4501827075096}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\trt_uint8_t index;\n\trt_list_t *list;\n\trt_timer_t timer;\n\n\tfor (index = 0; index < RT_TIMER_SKIP_LIST_LEVEL; index++) {\n\t\tlist = &timer_list[index];\n\n\t\t/* get the first timer entry */\n\t\ttimer = rt_list_entry(list->next, rt_timer_t, row[index]);\n\n\t\tif (timer!= RT_NULL) {\n\t\t\t/* set timeout tick */\n\t\t\t*timeout_tick = timer->timeout_tick;\n\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\treturn -RT_ERROR;\n}\n", "CodeBleu_score": 39.18911836959086}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\trt_timer_t timer;\n\n\t/* check parameters */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time < RT_TIMER_MAX_TIME);\n\n\ttimer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL)\n\t\treturn RT_NULL;\n\n\t/* initialize timer object */\n\ttimer->parent.type = RT_Object_Class_Timer;\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->init_tick = time;\n\ttimer->timeout_tick = time;\n\ttimer->flag = flag;\n\ttimer->next = RT_NULL;\n\ttimer->previous = RT_NULL;\n\n\t/* initialize timer list */\n\trt_list_init(&(timer->row));\n\n\treturn timer;\n}\n", "CodeBleu_score": 49.91944136126661}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\trt_timer_t timer;\n\n\t/* check parameters */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL)\n\t\treturn RT_NULL;\n\n\t/* initialize object */\n\ttimer->parent.init = RT_Object_Class_Timer;\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->init_tick = time;\n\ttimer->timeout_tick = time;\n\ttimer->flag = flag;\n\n\t/* initialize list */\n\trt_list_init(&(timer->row));\n\n\treturn timer;\n}\n", "CodeBleu_score": 49.6490984890117}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\trt_timer_t timer;\n\n\t/* check parameters */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL)\n\t\treturn RT_NULL;\n\n\t/* initialize object */\n\ttimer->parent.init = RT_NULL;\n\ttimer->parent.cleanup = RT_NULL;\n\n\t/* initialize timer */\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->init_tick = time;\n\ttimer->timeout_tick = time;\n\ttimer->flag = flag;\n\n\t/* insert timer to timer list */\n\trt_list_insert_before(&(rt_timer_list), &(timer->row));\n\n\treturn timer;\n}\n", "CodeBleu_score": 49.57755307736586}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Create a new recorder for capturing the response\n\trecorder := httptest.NewRecorder()\n\n\t// Process the request through the handlers\n\tfor _, handler := range a.handlers {\n\t\t// Capture the response using the recorder\n\t\thandler.ServeHTTP(recorder, req)\n\n\t\t// Copy the recorder's headers to the original response\n\t\tfor key, values := range recorder.HeaderMap {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\n\t\t// If the handler returns a \"401 Unauthorized\" status, send a \"Not Authorized\" error response and stop further processing\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Forward the request to the router for further handling\n\ta.router.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 51.61690308713644}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Create a new recorder to capture the response from each handler\n\trecorder := httptest.NewRecorder()\n\t// Create a new context with the request and recorder\n\tctx := context.WithValue(req.Context(), \"recorder\", recorder)\n\t// Create a new request with the context\n\tnewReq := req.WithContext(ctx)\n\t// Create a new router to handle the request\n\trouter := mux.NewRouter()\n\t// Create a new handler for the request\n\thandler := http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\t// Check if the request is for the \"health\" endpoint\n\t\tif req.URL.Path == \"/health\" {\n\t\t\t// Return a \"200 OK\" response\n\t\t\tres.WriteHeader(http.StatusOK)\n\t\t\tres.Write([]byte(\"OK\"))\n\t\t\treturn\n\t\t}\n\t\t// Delegate the request to the router\n\t\trouter.ServeHTTP(res, req)\n\t})\n\t// Create a new chain of handlers\n\tchain := alice.New(a.authHandler, a.logHandler)\n\t// Apply the chain of handlers to the handler\n\tchain.Then(handler).ServeHTTP(res, newReq)\n}\n", "CodeBleu_score": 34.858777792784196}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// The function \"ServeHTTP\" processes an HTTP request by sequentially passing it through a series of handlers.\\nFor each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\\nIf any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\\nIf all handlers pass without unauthorized status, it forwards the request to the router for further handling.\n\tfor _, handler := range a.Handlers {\n\t\t// The function \"ServeHTTP\" processes an HTTP request by sequentially passing it through a series of handlers.\\nFor each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\\nIf any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\\nIf all handlers pass without unauthorized status, it forwards the request to the router for further handling.\n\t\trecorder := httptest.NewRecorder()\n\t\t// The function \"ServeHTTP\" processes an HTTP request by sequentially passing it through a series of handlers.\\nFor each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\\nIf any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\\nIf all handlers pass without unauthorized status, it forwards the request to the router for further handling.\n\t\thandler.ServeHTTP(recorder, req)\n\t\t// The function \"ServeHTTP\" processes an HTTP request by sequentially passing it through a series of handlers.\\nFor each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\\nIf any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\\nIf all handlers pass without unauthorized status, it forwards the request to the router for further handling.\n\t\tfor k, v := range recorder.HeaderMap {\n\t\t\t// The function \"ServeHTTP\" processes an HTTP request by sequentially passing it through a series of handlers.\\nFor each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\\nIf any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\\", "CodeBleu_score": 29.626468302872578}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// Get the requested asset path from the URL path\n\tassetPath := req.URL.Path[1:]\n\n\t// Check if the asset path is empty or contains a dot (.)\n\tif assetPath == \"\" || strings.Contains(assetPath, \".\") {\n\t\t// If the asset path is empty or contains a dot, return a 404 error\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the absolute path to the asset\n\tassetPath = filepath.Join(a.config.AssetsDir, assetPath)\n\n\t// Check if the asset exists\n\tif _, err := os.Stat(assetPath); os.IsNotExist(err) {\n\t\t// If the asset does not exist, return a 404 error\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Open the asset file for reading\n\tfile, err := os.Open(assetPath)\n\tif err!= nil {\n\t\t// If there is an error opening the asset file, return a 500 error\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Get the file extension from the asset path\n\text := filepath.Ext(assetPath)\n\n\t// Set the Content-Type header based on the file extension\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\t// If the file extension is not recognized, return a 404 error\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Write the asset content to the response\n\t_, err = io.Copy(res, file)\n\tif err!= nil {\n\t\t// If there is an error writing the asset content, return a 500 error\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 50.275849012518215}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tif strings.HasSuffix(path, \"/\") {\n\t\tpath = path + \"index.html\"\n\t}\n\tasset, err := a.asset(path)\n\tif err!= nil {\n\t\thttp.Error(res, \"Not Found\", 404)\n\t\treturn\n\t}\n\tcontentType := \"text/plain\"\n\tif strings.HasSuffix(path, \".html\") {\n\t\tcontentType = \"text/html\"\n\t} else if strings.HasSuffix(path, \".css\") {\n\t\tcontentType = \"text/css\"\n\t} else if strings.HasSuffix(path, \".js\") {\n\t\tcontentType = \"application/javascript\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Write(asset)\n}\n", "CodeBleu_score": 39.45055698051259}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// Retrieve the requested asset based on the URL path.\n\tasset := a.getAsset(req.URL.Path)\n\tif asset == nil {\n\t\t// If the asset is not found, return a 404 error.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension (js, css, html).\n\tswitch filepath.Ext(req.URL.Path) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response.\n\tres.Write(asset)\n}\n", "CodeBleu_score": 38.72577882111716}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\trobot, err := a.master.GetRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": fmt.Sprintf(\"No robot found with name %s\", robotName)})\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 30.86718151854192}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot found with name %s\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections, err := robot.Connections()\n\tif err!= nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Error getting connections: %s\", err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 33.39820679224452}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"name\"]\n\trobot, err := a.master.FindRobot(robotName)\n\tif err!= nil {\n\t\ta.writeError(res, fmt.Sprintf(\"no robot found with name %s\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections, err := robot.GetConnections()\n\tif err!= nil {\n\t\ta.writeError(res, fmt.Sprintf(\"unable to get connections for robot %s\", robotName), http.StatusInternalServerError)\n\t\treturn\n\t}\n\ta.writeJSON(res, connections)\n}\n", "CodeBleu_score": 37.39651907875148}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.727373593509384}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the username and password from the \"Authorization\" header\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\t// If the \"Authorization\" header is empty, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Extract the username and password from the \"Authorization\" header\n\t\tauth := strings.SplitN(authHeader, \" \", 2)\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\t// If the \"Authorization\" header is not in the correct format, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth[1])\n\t\tif err!= nil {\n\t\t\t// If the \"Authorization\" header is not base64-encoded, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the decoded string into username and password\n\t\tcreds := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(creds)!= 2 || creds[0]!= username || creds[1]!= password {\n\t\t\t// If the username or password is incorrect, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the username and password are correct, continue with the request\n\t\t//...\n\t}\n}\n", "CodeBleu_score": 47.50697404272099}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || subtle.ConstantTimeCompare([]byte(user), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.520952391681334}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.48644164721318}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 52.059745983113444}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \t// calculate the slope and intercept for the scaling transformation\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\n\treturn func(input float64) (value int) {\n\t\t// scale the input value to the target range\n\t\tscaled := slope * input + intercept\n\n\t\t// clamp the output to the target range\n\t\tif scaled < float64(toMin) {\n\t\t\tscaled = float64(toMin)\n\t\t} else if scaled > float64(toMax) {\n\t\t\tscaled = float64(toMax)\n\t\t}\n\n\t\t// convert the scaled value to an integer\n\t\tvalue = int(math.Round(scaled))\n\n\t\treturn value\n\t}\n}\n", "CodeBleu_score": 50.38706869531367}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.isValid() {\n\t\treturn 0, 0, errors.New(\"invalid connection\")\n\t}\n\traw, err := a.Connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 44.755906718289744}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.connection.IsAnalogSensor() {\n\t\treturn 0, 0, errors.New(\"connection is not an analog sensor\")\n\t}\n\traw, err := a.connection.AnalogSensorRead()\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 44.589969049592796}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"not connected\")\n\t}\n\tif!a.connection.AnalogSensorReadSupported() {\n\t\treturn 0, 0, errors.New(\"analog reading not supported\")\n\t}\n\traw, err := a.connection.AnalogSensorRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRawValue = raw\n\ta.lastScaledValue = a.scale(raw)\n\treturn raw, a.lastScaledValue, nil\n}\n", "CodeBleu_score": 52.53460662974412}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 49.14030709581015}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 51.88743576444643}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMax - m * float64(fromMax)\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}\n", "CodeBleu_score": 51.73188057815348}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver// Create a new Grove Piezo Vibration Sensor driver\n\tdrv := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"Grove Piezo Vibration Sensor\",\n\t}\n\n\t// Add a vibration event\n\tdrv.AddEvent(\"vibration\")\n\n\t// Set up an event listener for data events\n\tdrv.On(\"Data\", func(data interface{}) {\n\t\t// Convert the data to a float64\n\t\tvalue, ok := data.(float64)\n\t\tif!ok {\n\t\t\treturn\n\t\t}\n\n\t\t// Publish a vibration event if the data exceeds a threshold value of 1000\n\t\tif value > 1000 {\n\t\t\tdrv.Publish(\"vibration\", true)\n\t\t}\n\t})\n\n\t// Return the initialized driver\n\treturn drv\n}\n", "CodeBleu_score": 36.148861508341255}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriverreturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"Grove Piezo Vibration Sensor\",\n\t\tvibration:          drivers.NewEvent(\"vibration\"),\n\t}\n}\n", "CodeBleu_score": 23.255145530146976}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriverreturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"Grove Piezo Vibration Sensor\",\n\t\tvibration:          NewVibrationEvent(),\n\t}\n}\n", "CodeBleu_score": 21.196288742417817}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif err := d.SetFrequency(hz); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.SetTempo(duration); err!= nil {\n\t\treturn err\n\t}\n\n\tperiod := 1.0 / hz\n\tfor i := 0.0; i < duration; i += period {\n\t\tif err := d.SetState(true); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period * 0.5) * time.Second)\n\t\tif err := d.SetState(false); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period * 0.5) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.85106830540664}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\t// Get the buzzer's beats per minute (bpm)\n\tbpm := d.Buzzer.Bpm\n\n\t// Calculate the tone period based on the frequency (hz) and the tempo (bpm)\n\ttonePeriod := 60.0 / bpm * 1000.0 / hz\n\n\t// Calculate the number of cycles needed to match the desired duration\n\tnumCycles := int(duration / tonePeriod)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process for the desired duration\n\tfor i := 0; i < numCycles; i++ {\n\t\t// Turn the buzzer on\n\t\tif err := d.Buzzer.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\n\t\t// Turn the buzzer off\n\t\tif err := d.Buzzer.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.34351669909073}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif d.buzzer == nil {\n\t\treturn fmt.Errorf(\"Buzzer is not initialized\")\n\t}\n\n\t// Calculate the tone period based on the given frequency (hz) and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := 60.0 / d.bpm * 1000.0 / hz\n\n\t// Calculate the number of cycles to play the tone based on the duration and tone period.\n\tnumCycles := int(duration / tonePeriod)\n\n\t// Repeat the tone for the specified duration by toggling the buzzer on and off at intervals determined by the tone period.\n\tfor i := 0; i < numCycles; i++ {\n\t\tif err := d.buzzer.High(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod/2.0) * time.Millisecond)\n\t\tif err := d.buzzer.Low(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod/2.0) * time.Millisecond)\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 50.50362176517854}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"Sleep pin is not set\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 29.395179841371693}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"EasyDriver.sleepWithSleepPin: sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 30.831302756116376}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\n\td.sleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 28.942843966369907}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif!a.pinsInitialized {\n\t\treturn nil, errors.New(\"pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\t// translate ID into path and parameters\n\tpath, params, err := a.translatePin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// create new pin\n\tpin, err := a.newPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// store pin in map\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 47.62326907397318}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.Pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not initialized\")\n\t}\n\n\tif pin, ok := a.Pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params := a.translate(id)\n\n\tif path == \"\" {\n\t\treturn nil, errors.New(\"Invalid analog pin id\")\n\t}\n\n\tpin := NewAnalogPin(path, params)\n\n\ta.Pins[id] = pin\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 40.977676889135864}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif!a.initialized {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params := a.pathParams(id)\n\tif path == \"\" {\n\t\treturn nil, fmt.Errorf(\"No analog pin found for ID: %s\", id)\n\t}\n\tpin, err := NewAnalogPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 46.901248450411806}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, PinDirectionOut)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.DigitalWrite(val)\n}\n", "CodeBleu_score": 64.27525095767118}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getPin(id, pinModeOutput)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}\n", "CodeBleu_score": 60.52471598467384}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.DigitalWrite(val)\n}\n", "CodeBleu_score": 60.16767956125315}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if len(a.Pins) == 0 {\n\t\treturn nil, errors.New(\"Adaptor is not connected to any pins\")\n\t}\n\tfor _, pin := range a.Pins {\n\t\tif pin.ID() == id {\n\t\t\tfor _, opt := range opts {\n\t\t\t\topt(pin)\n\t\t\t}\n\t\t\treturn pin, nil\n\t\t}\n\t}\n\n\tvar chip, line int\n\tif err := a.translateID(id, &chip, &line); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.newDigitalPin(chip, line)\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\ta.Pins = append(a.Pins, pin)\n\treturn pin, nil\n}\n", "CodeBleu_score": 43.04045385372055}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if len(a.digitalPins) == 0 {\n\t\treturn nil, errors.New(\"No digital pins found\")\n\t}\n\n\tfor _, pin := range a.digitalPins {\n\t\tif pin.ID() == id {\n\t\t\tfor _, opt := range opts {\n\t\t\t\topt(pin)\n\t\t\t}\n\t\t\treturn pin, nil\n\t\t}\n\t}\n\n\tvar chip, line int\n\tvar err error\n\n\tif chip, line, err = a.translateID(id); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.newDigitalPin(chip, line)\n\tif err := pin.Init(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\ta.digitalPins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 48.614470602391634}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if!a.connected() {\n\t\treturn nil, errors.New(\"adaptor not connected\")\n\t}\n\n\topts = append(a.digitalPinOptions, opts...)\n\tpin, err := a.pins.Get(id, opts...)\n\tif err!= nil {\n\t\tif err == gobot.ErrPinNotFound {\n\t\t\tchip, line, err := a.translatePinID(id)\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpin, err = a.newDigitalPin(id, chip, line, opts...)\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ta.pins.Add(pin)\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn pin, nil\n}\n", "CodeBleu_score": 50.232017336063095}]}
