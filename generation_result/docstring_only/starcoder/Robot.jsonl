{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> files;\n\tfor (const auto &entry : std::filesystem::directory_iterator(folder)) {\n\t\tconst std::string &path = entry.path().string();\n\t\tif (std::filesystem::is_regular_file(entry.status())) {\n\t\t\tif (download) {\n\t\t\t\tif (!std::filesystem::exists(path)) {\n\t\t\t\t\tLog::GetLog(\"ClientLog\") << \"Downloading required file \\\"\" << path << \"\\\"...\" << std::endl;\n\t\t\t\t\tif (!DownloadFile(path)) {\n\t\t\t\t\t\tLog::GetLog(\"ClientLog\") << \"Failed to download required file \\\"\" << path << \"\\\"!\" << std::endl;\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLog::GetLog(\"ClientLog\") << \"Required file \\\"\" << path << \"\\\" found in cache.\" << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiles.push_back(path);\n\t\t}\n\t}\n\treturn files;\n}\n", "CodeBleu_score": 43.36154104810672}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> files;\n\tstd::string path = folder;\n\tif (path.back()!= '/') {\n\t\tpath += '/';\n\t}\n\tfor (const auto &file : this->required_files) {\n\t\tif (file.find(path) == 0) {\n\t\t\tfiles.push_back(file);\n\t\t\tif (download) {\n\t\t\t\tif (!this->DownloadFile(file)) {\n\t\t\t\t\tthis->Log(\"Error downloading file: \" + file);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis->Log(\"File found in cache: \" + file);\n\t\t\t}\n\t\t}\n\t}\n\treturn files;\n}\n", "CodeBleu_score": 48.119439737099874}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> requiredFiles;\n\tfor (auto &file : std::filesystem::directory_iterator(folder)) {\n\t\trequiredFiles.push_back(file.path().string());\n\t}\n\tif (download) {\n\t\tfor (auto &file : requiredFiles) {\n\t\t\tif (!std::filesystem::exists(file)) {\n\t\t\t\tstd::string fileName = file.substr(file.find_last_of(\"/\") + 1);\n\t\t\t\tstd::string url = \"https://raw.githubusercontent.com/TheOpenBacteriaProject/\" + fileName;\n\t\t\t\tstd::string response = DownloadFile(url);\n\t\t\t\tif (response.empty()) {\n\t\t\t\t\tstd::cout << \"Failed to download file: \" << fileName << std::endl;\n\t\t\t\t} else {\n\t\t\t\t\tstd::cout << \"Downloaded file: \" << fileName << std::endl;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstd::cout << \"Found file in cache: \" << file << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn requiredFiles;\n}\n", "CodeBleu_score": 52.76171624638659}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)#if defined(ION_PRODUCTION)\n  if (parent == kInvalidActorId) {\n    ION_LOG(ERROR) << \"Parent actor ID is invalid\";\n    return kInvalidActorId;\n  }\n  if (attachment_type == rpc::AttachmentType::kSpringArm ||\n      attachment_type == rpc::AttachmentType::kSpringArmGhost) {\n    if (transform.GetTranslation().IsZero() &&\n        transform.GetRotation().GetAxis().IsZero() &&\n        transform.GetRotation().GetAngle() == 0.0) {\n      ION_LOG(WARNING) << \"Attempted to spawn an actor with a zero-length \"\n                        << \"translation and zero-rotation transform. This \"\n                        << \"will result in a zero-length spring arm.\\n\"\n                        << \"Actor Description:\\n\" << description;\n    }\n  }\n  return SpawnActorWithParentInternal(description, transform, parent,\n                                      attachment_type, socket_name);", "CodeBleu_score": 44.90361919346911}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)#ifdef _DEBUG\n  std::cout << \"Client::SpawnActorWithParent\" << std::endl;", "CodeBleu_score": 8.88308807471228}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)#ifdef _DEBUG\n  std::cout << \"Client::SpawnActorWithParent\\n\";", "CodeBleu_score": 8.549819776810905}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)#if defined(RPC_CLIENT_ENABLE_LOGGING)\n  auto start = std::chrono::high_resolution_clock::now();", "CodeBleu_score": 8.759373997409616}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)#ifdef ENABLE_SUBSCRIPTIONS\n  rpc::GBufferSubscriptionRequest request;\n  request.set_actor_id(ActorId);\n  request.set_gbuffer_id(GBufferId);\n  auto response = stub_->SubscribeToGBuffer(request);\n  if (!response.status().ok()) {\n    std::cerr << \"Error: \" << response.status().error_message() << std::endl;\n    return;\n  }\n  auto token = response.token();\n  auto buffer = response.buffer();\n  callback(buffer);\n  stub_->UnsubscribeFromGBuffer(token);", "CodeBleu_score": 41.00067473453664}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)#ifdef _WIN32\n  static_assert(sizeof(rpc::ActorId) == sizeof(uint64_t), \"rpc::ActorId and uint64_t must be the same size\");\n  static_assert(sizeof(rpc::GBufferId) == sizeof(uint32_t), \"rpc::GBufferId and uint32_t must be the same size\");", "CodeBleu_score": 19.065219852791905}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (this->navigation == nullptr) {\n\t\tthis->navigation = std::make_shared<WalkerNavigation>();\n\t\tbool success = this->navigation->SetEpisode(this);\n\t\tif (!success) {\n\t\t\tthis->navigation = nullptr;\n\t\t}\n\t}\n\treturn this->navigation;\n}\n", "CodeBleu_score": 24.51066338039578}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (!m_pWalkerNavigation) {\n\t\tm_pWalkerNavigation = std::shared_ptr<WalkerNavigation>(new WalkerNavigation());\n\t\tif (!m_pWalkerNavigation) {\n\t\t\tthrow std::bad_alloc();\n\t\t}\n\t}\n\treturn m_pWalkerNavigation;\n}\n", "CodeBleu_score": 27.48785937044732}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (m_pWalkerNavigation == nullptr) {\n\t\tm_pWalkerNavigation = std::make_shared<WalkerNavigation>(m_pWorld);\n\t}\n\treturn m_pWalkerNavigation;\n}\n", "CodeBleu_score": 27.130761792091757}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tuint64_t current_frame = 0;\n\tdo {\n\t\tcurrent_frame = episode.get_state().get_traffic_manager().get_current_frame();\n\t\tif (current_frame < frame) {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t}\n\t} while (current_frame < frame && timeout.count() > 0);\n\n\tif (current_frame < frame) {\n\t\treturn false;\n\t}\n\n\tepisode.get_state().get_traffic_manager().on_tick();\n\treturn true;\n}\n", "CodeBleu_score": 33.64872373716936}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tuint64_t current_frame = episode.GetCurrentFrame();\n\twhile (current_frame < frame) {\n\t\tif (timeout.count() <= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\ttimeout -= std::chrono::milliseconds(100);\n\t\tcurrent_frame = episode.GetCurrentFrame();\n\t}\n\t// If we make it here, we have successfully synchronized the frame.\n\t// Advance the simulation by one step, triggering a tick in the traffic manager.\n\tepisode.GetWorld().Step(1.0f / 20.0f);\n\treturn true;\n}\n", "CodeBleu_score": 31.986201887604704}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tconst uint64_t start_frame = episode.GetCurrentFrame();\n\twhile (start_frame + frame > episode.GetCurrentFrame()) {\n\t\tif (timeout!= 0ms) {\n\t\t\tif (episode.GetCurrentFrame() >= start_frame + frame) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (timeout < 1ms) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis_thread::sleep_for(1ms);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 27.28856223596643}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tstd::vector<std::string> map_layer_names;\n\tfor (auto map_layer : map_layers) {\n\t\tmap_layer_names.push_back(map_layer);\n\t}\n\tauto response = client_.call(\"LoadEpisode\", map_name, reset_settings, map_layer_names);\n\treturn response.episode;\n}\n", "CodeBleu_score": 24.467562574381418}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tauto request = SimulatorLoadEpisodeRequest();\n\trequest.map_name = map_name;\n\trequest.reset_settings = reset_settings;\n\trequest.map_layers = map_layers;\n\tauto response = call(\"LoadEpisode\", request);\n\treturn response.episode;\n}\n", "CodeBleu_score": 25.203136669864378}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tauto start = std::chrono::steady_clock::now();\n\tauto timeout = std::chrono::milliseconds(10000);\n\tstd::string old_episode_id = \"\";\n\twhile (std::chrono::steady_clock::now() - start < timeout) {\n\t\tauto response = client_.LoadEpisode(map_name, reset_settings, map_layers);\n\t\tif (response.status().ok()) {\n\t\t\tauto new_episode_id = response.episode_id();\n\t\t\tif (new_episode_id!= old_episode_id) {\n\t\t\t\treturn EpisodeProxy(client_, new_episode_id);\n\t\t\t}\n\t\t\told_episode_id = new_episode_id;\n\t\t}\n\t}\n\tthrow std::runtime_error(\"Simulator::LoadEpisode failed to connect to the new episode within the allowed time.\");\n}\n", "CodeBleu_score": 46.70059282693491}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tif (!controller.episode) {\n\t\tthrow std::runtime_error(\"Controller has no episode\");\n\t}\n\tauto walker = controller.episode->GetWalker(controller.id);\n\tif (!walker) {\n\t\tthrow std::runtime_error(\"Walker not found in episode\");\n\t}\n\tif (!walker->HasComponent<NavigationComponent>()) {\n\t\twalker->CreateComponent<NavigationComponent>();\n\t}\n\tcontroller.episode->RegisterAIController(controller.id);\n}\n", "CodeBleu_score": 42.24687483332657}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tif (controller.GetEpisode() == nullptr) {\n\t\tthrow std::runtime_error(\"AIController::RegisterAIController: controller's episode is null\");\n\t}\n\n\tif (controller.GetEpisode()->GetNavigation() == nullptr) {\n\t\tcontroller.GetEpisode()->SetNavigation(std::make_shared<Navigation>(controller.GetEpisode()));\n\t}\n\n\tcontroller.RegisterWalker(controller.GetEpisode()->GetAgent(controller.GetID()));\n}\n", "CodeBleu_score": 33.00720854177071}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tif (controller.episode == nullptr) {\n\t\tthrow std::runtime_error(\"Controller episode is null\");\n\t}\n\tauto walker = controller.episode->GetAgent(controller.id);\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\tif (walker->navigation == nullptr) {\n\t\twalker->navigation = std::make_shared<Navigation>(walker);\n\t}\n\tcontroller.episode->RegisterAgent(controller.id, walker);\n}\n", "CodeBleu_score": 44.67998008722823}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)#ifndef NDEBUG\n  std::lock_guard<std::mutex> lock(mutex_);", "CodeBleu_score": 7.337098527462992}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n", "CodeBleu_score": 7.401589120242785}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) * @param blueprint The blueprint of the actor to spawn.\n * @param transform The transform of the actor to spawn.\n * @param parent The parent actor to attach the new actor to. If nullptr, the new actor will be a root actor.\n * @param attachment_type The type of attachment to use.\n * @param gc The garbage collection policy to use for the new actor.\n * @param socket_name The name of the socket to attach the new actor to.\n * @return A shared pointer to the newly created actor.\n */", "CodeBleu_score": 37.85504161110288}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)#if defined(ION_PRODUCTION)\n  if (!IsEpisodeValid()) {\n    return;\n  }\n\n  const auto &sensor_name = sensor.name();\n  auto sensor_type = sensor.type();\n\n  const auto &stream_name =\n      std::string(kSensorStreamNamePrefix) + sensor_name;\n\n  if (sensor_type == SensorType::kCameraSensor) {\n    if (sensor_name == kMainCameraSensorName) {\n      camera_sensor_data_ = std::make_shared<sensor::CameraSensorData>();\n      camera_sensor_data_sub_ = client_->SubscribeToStream(\n          stream_name,\n          [this, callback](const std::shared_ptr<Message> &message) {\n            if (message->data_size() == 0) {\n              LOG(ERROR) << \"Empty message received for stream \" << stream_name;\n              return;\n            }\n            if (!camera_sensor_data_->ParseFromString(message->data(0))) {\n              LOG(ERROR) << \"Unable to parse message for stream \"\n                         << stream_name;\n              return;\n            }\n            callback(camera_sensor_data_);\n          });\n    } else if (sensor_name == kDepthCameraSensorName) {\n      depth_camera_sensor_data_ = std::make_shared<sensor::CameraSensorData>();\n      depth_camera_sensor_data_sub_ = client_->SubscribeToStream(\n          stream_name,\n          [this, callback](const std::shared_ptr<Message> &message) {\n            if (message->data_size() == 0) {\n              LOG(ERROR) << \"Empty message received for stream \" << stream_name;\n              return;\n            }\n            if (!depth_camera_sensor_data_->ParseFromString(message->data(0))) {\n              LOG(ERROR) << \"Unable to parse message for stream \"\n                         << stream_name;\n              return;\n            }\n            callback(depth_camera_sensor_data_);\n          });\n    } else {\n      LOG(ERROR) << \"Sensor name \" << sensor_name << \" is not supported\";\n    }\n  } else if (sensor_type == SensorType::kLidarSensor) {\n    if (sensor_name == kLidarSensorName) {\n      lidar_sensor_data_ = std::make_shared<sensor::LidarSensorData>();\n      lidar", "CodeBleu_score": 40.911079573556066}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)#ifdef _WIN32\n  std::wstring sensor_name = sensor.sensor_type.name();\n  std::wstring sensor_id = sensor.sensor_id;", "CodeBleu_score": 18.982694504444986}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback) *\n * 1. Ensure episode is valid\n * 2. Subscribe to stream\n * 3. Set up callback\n *\n * }\n *\n * void Simulator::SubscribeToSensor(\n *       const Sensor &sensor,\n *       std::function<void(SharedPtr<sensor::SensorData>)> callback) {\n *   if (!episode_ ||!episode_->IsCurrent()) {\n *     std::string msg = \"Cannot subscribe to sensor '\" + sensor.name + \"' \"\n *                       \"before starting an episode.\";\n *     throw std::runtime_error(msg);\n *   }\n *\n *   auto sensor_id = sensor.id;\n *   auto sensor_type = sensor.type;\n *\n *   if (sensor_type == sensor::SensorType::LIDAR) {\n *     lidar_sensors_[sensor_id] = callback;\n *   } else if (sensor_type == sensor::SensorType::CAMERA) {\n *     camera_sensors_[sensor_id] = callback;\n *   } else if (sensor_type == sensor::SensorType::RADAR) {\n *     radar_sensors_[sensor_id] = callback;\n *   } else {\n *     std::string msg = \"Sensor type \" + std::to_string(sensor_type) +\n *                       \" is not supported by the simulator\";\n *     throw std::runtime_error(msg);\n *   }\n *\n *   auto *client = world_->GetClient();\n *   auto *server = world_->GetServer();\n *\n *   client->SubscribeToStream(\n *       std::to_string(sensor_id),\n *       [this, sensor_id, sensor_type](const StreamData &stream) {\n *         // Deserialize the incoming stream data.\n *         auto sensor_data = sensor::Deserialize(stream.data, sensor_type);\n *         sensor_data->sensor_id = sensor_id;\n *         sensor_data->sensor_type = sensor_type;\n *\n *         // Associate the data with the current episode.\n *         sensor_data->episode_id = episode_->id;\n *         sensor_data->timestamp = episode_->start_time + stream.timestamp;\n *\n *         // Invoke the callback.\n *         if (", "CodeBleu_score": 39.169376191749905}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// Get the current state of the episode\n\tstd::vector<WalkerState> states = episode->getWalkerStates();\n\n\t// Remove any walkers that no longer exist\n\tfor (auto it = m_walkers.begin(); it!= m_walkers.end();) {\n\t\tif (std::find(states.begin(), states.end(), (*it).second) == states.end()) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tm_crowd->removeAgent((*it).first);\n\t\t\t// Remove the walker from the map\n\t\t\tm_walkers.erase(it++);\n\t\t} else {\n\t\t\tit++;\n\t\t}\n\t}\n\n\t// Update the crowd with the current state of the walkers\n\tm_crowd->update(m_sim->getDeltaTime());\n\n\t// Apply the walker states to the simulator\n\tfor (auto it = m_walkers.begin(); it!= m_walkers.end(); it++) {\n\t\t// Get the current state of the walker\n\t\tWalkerState state = states[it->second];\n\n\t\t// Get the current transform of the walker\n\t\tbtTransform transform;\n\t\ttransform.setIdentity();\n\t\ttransform.setOrigin(state.getPosition());\n\t\ttransform.setRotation(state.getRotation());\n\n\t\t// Get the current speed of the walker\n\t\tfloat speed = state.getSpeed();\n\n\t\t// Set the transform and speed of the walker in the simulator\n\t\tm_sim->setWalkerState(it->first, transform, speed);\n\t}\n\n\t// Check if any walker has been killed\n\tfor (auto it = m_walkers.begin(); it!= m_walkers.end(); it++) {\n\t\tif (m_sim->isDead(it->first)) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tm_crowd->removeAgent(it->first);\n\t\t\t// Remove the walker from the map\n\t\t\tm_walkers.erase(it++);\n\t\t\t// Destroy the walker's controller\n\t\t\tdelete it->first;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.101252414691665}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// Load the current walkers.\n\tstd::vector<Walker> walkers = episode->GetWalkers();\n\n\t// If there are no walkers, return.\n\tif (walkers.size() == 0) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the episode.\n\tint current_state = episode->GetState();\n\n\t// Remove any walkers that no longer exist.\n\tfor (int i = 0; i < walkers.size(); i++) {\n\t\tif (!episode->GetWorldState().WalkerExists(walkers[i].id)) {\n\t\t\twalkers.erase(walkers.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\n\t// Update the crowd and the vehicles.\n\tcrowd->update(episode->GetWorldState().GetWorld());\n\tcrowd->update_vehicles(true);\n\n\t// For each walker, get their transform and speed, then apply these states in a batch to the simulator.\n\tfor (int i = 0; i < walkers.size(); i++) {\n\t\t// Get the transform and speed of the walker.\n\t\tWalker walker = walkers[i];\n\t\tbtTransform transform = walker.transform;\n\t\tfloat speed = walker.speed;\n\n\t\t// Apply the transform and speed to the walker.\n\t\tepisode->GetWorldState().ApplyWalkerState(walker.id, transform, speed);\n\t}\n\n\t// Check if any walker has been killed.\n\tfor (int i = 0; i < walkers.size(); i++) {\n\t\tif (episode->GetWorldState().WalkerKilled(walkers[i].id)) {\n\t\t\t// Remove the walker from the crowd.\n\t\t\tcrowd->remove_agent(walkers[i].agent);\n\n\t\t\t// Destroy the controller.\n\t\t\tif (walkers[i].controller!= nullptr) {\n\t\t\t\tdelete walkers[i].controller;\n\t\t\t\twalkers[i].controller = nullptr;\n\t\t\t}\n\n\t\t\t// Remove the walker from the list.\n\t\t\twalkers.erase(walkers.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\n\t// Update the state of the episode.\n\tif (current_state == Episode::RUNNING) {\n\t\tepisode", "CodeBleu_score": 36.98234943385382}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// Get the current state of the episode\n\tconst auto state = episode->GetState();\n\n\t// Remove any walkers that no longer exist\n\tfor (const auto& walker_id : state.GetRemoved()) {\n\t\tif (m_Walkers.find(walker_id)!= m_Walkers.end()) {\n\t\t\tm_Walkers.erase(walker_id);\n\t\t}\n\t}\n\n\t// Update the crowd with the current state\n\tm_Crowd->Update(state.GetVehicles());\n\n\t// Update the walkers\n\tfor (auto& walker : m_Walkers) {\n\t\t// Get the walker's transform and speed\n\t\tconst auto transform = walker.second.GetTransform();\n\t\tconst auto speed = walker.second.GetSpeed();\n\n\t\t// Apply the transform and speed to the simulator\n\t\tm_Controller->ApplyWalkerState(transform, speed, walker.first);\n\n\t\t// Check if the walker has been killed\n\t\tif (walker.second.IsDead()) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tm_Crowd->RemoveAgent(walker.first);\n\n\t\t\t// Remove the walker from the map\n\t\t\tm_Walkers.erase(walker.first);\n\n\t\t\t// Destroy the controller\n\t\t\tm_Controller->DestroyController(walker.first);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.65446834485286}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto &attr : attributes) {\n\t\tdescription.attributes.emplace_back(attr.name, attr.type, attr.value);\n\t}\n\treturn description;\n}\n", "CodeBleu_score": 70.21761402690251}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.set_uid(uid_);\n\tdescription.set_id(id_);\n\tfor (auto attribute : attributes_) {\n\t\tauto new_attribute = description.add_attributes();\n\t\tnew_attribute->CopyFrom(attribute);\n\t}\n\treturn description;\n}\n", "CodeBleu_score": 53.7913348175856}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.set_uid(uid_);\n\tdescription.set_id(id_);\n\tfor (auto &attr : attributes_) {\n\t\tauto *attr_desc = description.add_attributes();\n\t\tattr_desc->set_name(attr.first);\n\t\tattr_desc->set_type(attr.second.type);\n\t\tattr_desc->set_size(attr.second.size);\n\t\tattr_desc->set_is_dynamic(attr.second.is_dynamic);\n\t}\n\treturn description;\n}\n", "CodeBleu_score": 51.123742383384055}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\"\"\"\n", "CodeBleu_score": 7.8125}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto it = blueprints_.begin(); it!= blueprints_.end(); ++it) {\n\t\tauto blueprint = it->second;\n\t\tauto attributes = blueprint->GetAttributes();\n\t\tif (attributes.find(name)!= attributes.end()) {\n\t\t\tauto attribute = attributes.at(name);\n\t\t\tif (attribute.GetValue() == value) {\n\t\t\t\tresult->AddBlueprint(blueprint->GetName(), blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 43.7716602501585}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const#ifdef _MSC_VER\n  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();", "CodeBleu_score": 8.676933979374}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullPath = path + \"/\" + std::to_string(version) + \".bin\";\n\tif (ValidatePath(fullPath)) {\n\t\tstd::ofstream file(fullPath, std::ios::binary);\n\t\tif (file.is_open()) {\n\t\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 38.17817402194618}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string full_path = GetFullFilePath(path);\n\tif (!ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\tfile.close();\n\treturn true;\n}\n", "CodeBleu_score": 43.098234324622766}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\t// Construct the full file path\n\tstd::string full_path = _GetFullFilePath(path);\n\t// Validate the file path\n\tif (full_path.empty()) {\n\t\treturn false;\n\t}\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\t// Write the content to the file\n\t\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\t\t// Close the file\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 42.534937894439565}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const#ifdef DEBUG_BOUNDS\n  std::cout << \"MakeBounds: frame: \" << frame << \" transform: \" << transform << std::endl;", "CodeBleu_score": 9.580557875947186}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\\tconst auto &location = transform.location();", "CodeBleu_score": 13.354110624234671}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const#if 0\n  std::cout << \"MakeBounds: frame = \" << frame << std::endl;", "CodeBleu_score": 8.07699424805111}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server\n\tstd::vector<LightState> lightStates = _lightManagerClient.QueryLightsState();\n\n\t// For each light state\n\tfor (LightState lightState : lightStates) {\n\t\t// If the light does not exist\n\t\tif (_lights.find(lightState.id) == _lights.end()) {\n\t\t\t// Create a new light object\n\t\t\tLight *light = new Light(lightState.id, lightState.color, lightState.intensity, lightState.position, lightState.direction);\n\n\t\t\t// Add the light to the map\n\t\t\t_lights[lightState.id] = light;\n\t\t}\n\t\telse {\n\t\t\t// Update the light\n\t\t\t_lights[lightState.id]->Update(lightState.color, lightState.intensity, lightState.position, lightState.direction);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.92743473178581}, {"code": "void LightManager::QueryLightsStateToServer()\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_client == nullptr) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the lights from the server\n\tauto response = _client->QueryLightsState();\n\tif (response.IsSuccessful()) {\n\t\t// Update the local light states\n\t\t_lights.clear();\n\t\tfor (auto lightState : response.GetLightStates()) {\n\t\t\tauto light = _lights.find(lightState.GetId());\n\t\t\tif (light == _lights.end()) {\n\t\t\t\t// Create a new light object\n\t\t\t\tauto newLight = std::make_shared<Light>(lightState.GetId(), lightState.GetPosition(), lightState.GetColor(), lightState.GetRadius(), lightState.GetIntensity());\n\t\t\t\t_lights[lightState.GetId()] = newLight;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Update the existing light object\n\t\t\t\tlight->second->SetPosition(lightState.GetPosition());\n\t\t\t\tlight->second->SetColor(lightState.GetColor());\n\t\t\t\tlight->second->SetRadius(lightState.GetRadius());\n\t\t\t\tlight->second->SetIntensity(lightState.GetIntensity());\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.60859972376131}, {"code": "void LightManager::QueryLightsStateToServer()\tstd::lock_guard<std::mutex> lock(_mutex);\n\tstd::vector<LightState> lightStates = _client->QueryLightsState();\n\tfor (LightState lightState : lightStates) {\n\t\t_lights[lightState.id] = lightState;\n\t}\n}\n", "CodeBleu_score": 20.91968249853196}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Check if there are any changes\n\tif (dirty) {\n\t\t// Create a message containing the updated light states\n\t\tLightManager::Message message;\n\t\tfor (auto const &light : lights) {\n\t\t\tmessage.light_states.push_back(light.second.state);\n\t\t}\n\n\t\t// Send the message to the server\n\t\tif (discard_client) {\n\t\t\tNetworkManager::DiscardClient();\n\t\t}\n\t\tNetworkManager::Send(message);\n\n\t\t// Clear the changes and reset the dirty flag\n\t\tdirty = false;\n\t}\n}\n", "CodeBleu_score": 29.471541435463}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tstd::lock_guard<std::mutex> lock(lights_mutex);\n\tif (lights_dirty) {\n\t\tif (discard_client) {\n\t\t\tlights_dirty = false;\n\t\t\treturn;\n\t\t}\n\t\tlights_dirty = false;\n\t\tstd::vector<LightState> light_states;\n\t\tfor (auto &light : lights) {\n\t\t\tLightState state;\n\t\t\tstate.id = light.id;\n\t\t\tstate.x = light.x;\n\t\t\tstate.y = light.y;\n\t\t\tstate.z = light.z;\n\t\t\tstate.r = light.r;\n\t\t\tstate.g = light.g;\n\t\t\tstate.b = light.b;\n\t\t\tstate.radius = light.radius;\n\t\t\tstate.type = light.type;\n\t\t\tlight_states.push_back(state);\n\t\t}\n\t\tLightManagerMessage msg;\n\t\tmsg.type = LightManagerMessage::UPDATE_LIGHTS;\n\t\tmsg.light_states = light_states;\n\t\tclient_socket.Send(msg);\n\t}\n}\n", "CodeBleu_score": 40.089595497356626}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tstd::unique_lock<std::mutex> lock(lights_mutex);\n\tif (lights_dirty) {\n\t\tlights_dirty = false;\n\t\tlock.unlock();\n\t\tstd::vector<Light> lights = GetLights();\n\t\tstd::vector<Light> updated_lights;\n\t\tfor (auto light : lights) {\n\t\t\tif (light.dirty) {\n\t\t\t\tupdated_lights.push_back(light);\n\t\t\t}\n\t\t}\n\t\tif (updated_lights.size() > 0) {\n\t\t\tstd::string message = \"lights_update \" + std::to_string(updated_lights.size());\n\t\t\tfor (auto light : updated_lights) {\n\t\t\t\tmessage += \" \" + std::to_string(light.id) + \" \" + std::to_string(light.type) + \" \" + std::to_string(light.color[0]) + \" \" + std::to_string(light.color[1]) + \" \" + std::to_string(light.color[2]) + \" \" + std::to_string(light.intensity) + \" \" + std::to_string(light.attenuation_constant) + \" \" + std::to_string(light.attenuation_linear) + \" \" + std::to_string(light.attenuation_quadratic) + \" \" + std::to_string(light.position[0]) + \" \" + std::to_string(light.position[1]) + \" \" + std::to_string(light.position[2]) + \" \" + std::to_string(light.direction[0]) + \" \" + std::to_string(light.direction[1]) + \" \" + std::to_string(light.direction[2]);\n\t\t\t}\n\t\t\tif (discard_client) {\n\t\t\t\tclient_socket->Send(message);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tserver_socket->Send(message);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.99328247644408}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)\tif (this->id!= \"sensor.other.v2x_custom\") {\n\t\tstd::cerr << \"WARNING: ServerSideSensor::Send() called with sensor id \\\"\" << this->id << \"\\\". This function should only be called with sensor id \\\"sensor.other.v2x_custom\\\".\" << std::endl;\n\t\treturn;\n\t}\n\tthis->context->send(message);\n}\n", "CodeBleu_score": 29.698038206839644}, {"code": "void ServerSideSensor::Send(std::string message)\tif (this->id!= \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"WARNING: ServerSideSensor::Send called with sensor.other.v2x_custom ID.\" << std::endl;\n\t\treturn;\n\t}\n\tstd::cout << \"Sending message to episode: \" << message << std::endl;\n\tthis->context->send_message(message);\n}\n", "CodeBleu_score": 41.6249489289791}, {"code": "void ServerSideSensor::Send(std::string message)\tif (GetID()!= \"sensor.other.v2x_custom\") {\n\t\tWARN(\"Sensor is not v2x_custom\");\n\t} else {\n\t\tauto c = GetContext();\n\t\tif (c) {\n\t\t\tc->Send(message);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.12453259480852}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\ttm_client.RegisterVehicle(this, tm_port);\n\t}\n\telse {\n\t\ttm_client.DeregisterVehicle(this);\n\t}\n}\n", "CodeBleu_score": 40.80996163214374}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\ttm_client.RegisterVehicle(this, tm_port);\n\t}\n\telse {\n\t\ttm_client.DeregisterVehicle(this);\n\t}\n}\n", "CodeBleu_score": 40.80996163214374}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\ttm_client = std::unique_ptr<carla::client::TrafficManager>(new carla::client::TrafficManager(GetUnrealContext()->GetClient(), tm_port));\n\t\ttm_client->SetAutoLaneChange(false);\n\t\ttm_client->SetHybridPhysicsMode(carla::traffic_manager::TrafficManagerMode::HybridPhysics);\n\t\ttm_client->SetHybridPhysicsRadius(10.0f);\n\t\ttm_client->SetSimulationMode(carla::traffic_manager::TrafficManagerMode::HybridPhysics);\n\t\ttm_client->UpdateVehicleProperties(GetActor()->GetVehicleControl());\n\t\ttm_client->SetActorAutoLaneChange(GetActor(), false);\n\t\ttm_client->SetActorHybridPhysicsMode(GetActor(), carla::traffic_manager::TrafficManagerMode::HybridPhysics);\n\t\ttm_client->SetActorHybridPhysicsRadius(GetActor(), 10.0f);\n\t\ttm_client->SetActorSimulationMode(GetActor(), carla::traffic_manager::TrafficManagerMode::HybridPhysics);\n\t} else {\n\t\ttm_client.reset();\n\t}\n}\n", "CodeBleu_score": 39.447462788513796}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()\tSuper::Start();\n\n\t// Get the Pawn being controlled\n\tWalker = GetPawn();\n\tif (Walker) {\n\t\t// Get the controller's movement component\n\t\tWalker->GetCharacterMovement()->bOrientRotationToMovement = true;\n\n\t\t// Get the controller's mesh component\n\t\tWalkerMesh = GetPawn()->FindComponentByClass<UStaticMeshComponent>();\n\n\t\t// Get the controller's camera component\n\t\tWalkerCamera = GetPawn()->FindComponentByClass<UCameraComponent>();\n\n\t\t// Get the controller's audio component\n\t\tWalkerAudio = GetPawn()->FindComponentByClass<UAudioComponent>();\n\n\t\t// Get the controller's animation component\n\t\tWalkerAnimation = GetPawn()->FindComponentByClass<UAnimationComponent>();\n\n\t\t// Get the controller's skeletal mesh component\n\t\tWalkerSkeletalMesh = GetPawn()->FindComponentByClass<USkeletalMeshComponent>();\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsule = GetPawn()->FindComponentByClass<UCapsuleComponent>();\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent = GetPawn()->FindComponentByClass<UCapsuleComponent>();\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->InitCapsuleSize(42.0f, 96.0f);\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->SetCapsuleHalfHeight(96.0f);\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->SetCapsuleRadius(42.0f);\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->SetGenerateOverlapEvents(true);\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->SetCollisionResponseToAllChannels(ECR_Ignore);\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->SetCollisionResponseToChannel(ECC_Visibility, ECR_Ignore);\n\n\t\t// Get the controller's capsule component\n\t\tWalkerCapsuleComponent->SetCollisionResponseTo", "CodeBleu_score": 26.49091049141155}, {"code": "void WalkerAIController::Start()\tSuper::Start();\n\n\t// Get the Pawn controlled by this Controller\n\tWalker = GetPawn();\n\tif (Walker) {\n\t\t// Disable input to the walker, we will drive it.\n\t\tWalker->DisableInput(PlayerIndex);\n\n\t\t// Start the AI\n\t\tGetWorld()->GetAuthGameMode<AMyGameModeBase>()->StartAI();\n\n\t\t// Add the walker to the navigation system\n\t\tFVector StartLocation = GetActorLocation();\n\t\tUNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(GetWorld());\n\t\tif (NavSys) {\n\t\t\tNavAgentProps.bCanMove = false;\n\t\t\tNavAgentProps.bCanCrouch = false;\n\t\t\tNavAgentProps.bCanJump = false;\n\t\t\tNavAgentProps.bCanFly = false;\n\t\t\tNavAgentProps.bWantsToEverCrouch = false;\n\t\t\tNavAgentProps.bWantsToFire = false;\n\t\t\tNavAgentProps.bWantsToJump = false;\n\t\t\tNavAgentProps.bWantsToSprint = false;\n\t\t\tNavAgentProps.bWantsToSwim = false;\n\t\t\tNavAgentProps.bWantsToWalk = false;\n\t\t\tNavAgentProps.bWantsToUncrouch = false;\n\t\t\tNavAgentProps.bIsFlying = false;\n\t\t\tNavAgentProps.bIsMoving = false;\n\t\t\tNavAgentProps.bUseControllerDesiredRotation = true;\n\t\t\tNavAgentProps.bCanEverAffectNavigation = false;\n\t\t\tNavAgentProps.bAvoidanceEnabled = false;\n\t\t\tNavAgentProps.bIgnoreNavmeshWhenMoving = false;\n\t\t\tNavAgentProps.bIgnoreAgentRadius = false;\n\t\t\tNavAgentProps.bIgnoreDefaultPawnCollision = false;\n\t\t\tNavAgentProps.bIgnoreCustomCollision = false;\n\t\t\tNavAgentProps.bIgnoreTriggerVolumes = false;\n\t\t\tNavAgentProps.bIgnoreStairs = false;\n\t\t\tNavAgentProps.bIgnoreJumpable = false;\n\t\t\tNavAgentProps.bIgnoreLadders = false;\n\t\t\tNavAgentProps.bIgnoreQueryCollision = false;\n\t\t\tNavAgentProps.bCanBrake = false;\n\t\t\tNavAgentProps.bCanTeleport = false;\n\t\t\tNavAgentProps.bCanWalkOn", "CodeBleu_score": 24.076051729912084}, {"code": "void WalkerAIController::Start()\tSuper::Start();\n\n\t// Get the Pawn controlled by this AI controller\n\tWalker = GetPawn();\n\tif (Walker) {\n\t\t// Get the player's start location and set the AI controller to that location\n\t\tStartLocation = GetPlayerStartLocation(0);\n\t\tWalker->SetActorLocation(StartLocation);\n\n\t\t// Disable the simulation and collision for the walker\n\t\tWalker->SetActorEnableCollision(false);\n\t\tWalker->GetCharacterMovement()->SetSimulationEnabled(false);\n\n\t\t// Add the walker to the game world's navigation system\n\t\tUNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(GetWorld());\n\t\tif (NavSys) {\n\t\t\tNavSys->AddNavData(Walker);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.438795119217936}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\t// Retrieve the navigation instance from the current episode\n\tNavigation* navigation = GetEpisode()->GetNavigation();\n\tif (navigation) {\n\t\t// Retrieve the parent walker\n\t\tWalker* walker = GetParent();\n\t\tif (walker) {\n\t\t\t// Set the maximum speed\n\t\t\tif (!navigation->SetMaxSpeed(walker, max_speed)) {\n\t\t\t\t// Failed to set the maximum speed\n\t\t\t\tURHO3D_LOGERROR(\"Failed to set maximum speed for walker.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Failed to find parent walker\n\t\t\tURHO3D_LOGERROR(\"Failed to find parent walker.\");\n\t\t}\n\t}\n\telse {\n\t\t// Failed to find navigation\n\t\tURHO3D_LOGERROR(\"Failed to find navigation.\");\n\t}\n}\n", "CodeBleu_score": 50.89305104152365}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tif (m_pNavMesh) {\n\t\tm_pNavMesh->setMaxSpeed(max_speed);\n\t}\n\telse {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() - No navigation mesh found!\"));\n\t}\n}\n", "CodeBleu_score": 20.00073759907409}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tif (m_pNavMesh == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- No valid navigation mesh instance, cannot set maximum speed\"));\n\t\treturn;\n\t}\n\n\tif (m_pParentActor == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- No valid parent actor instance, cannot set maximum speed\"));\n\t\treturn;\n\t}\n\n\tif (m_pParentActor->GetParent() == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- No valid parent actor instance, cannot set maximum speed\"));\n\t\treturn;\n\t}\n\n\tif (m_pParentActor->GetParent()->GetParent() == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- No valid parent actor instance, cannot set maximum speed\"));\n\t\treturn;\n\t}\n\n\tif (m_pParentActor->GetParent()->GetParent()->GetParent() == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- No valid parent actor instance, cannot set maximum speed\"));\n\t\treturn;\n\t}\n\n\tif (m_pParentActor->GetParent()->GetParent()->GetParent()->GetParent() == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- No valid parent actor instance, cannot set maximum speed\"));\n\t\treturn;\n\t}\n\n\tAActor* parent_actor = m_pParentActor->GetParent()->GetParent()->GetParent()->GetParent();\n\tif (parent_actor == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- No valid parent actor instance, cannot set maximum speed\"));\n\t\treturn;\n\t}\n\n\tif (m_pParentActor->GetParent() == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- No valid parent actor instance, cannot set maximum speed\"));\n\t\treturn;\n\t}\n\n\tif (m_pParentActor->GetParent()->GetParent() == nullptr) {\n\t\tUE_LOG(", "CodeBleu_score": 39.57665637494924}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> result;\n\tfor (auto it = parent_map->waypoints.begin(); it!= parent_map->waypoints.end(); ++it) {\n\t\tif (distance > 0) {\n\t\t\tif (it->second->GetDistance() <= distance) {\n\t\t\t\tresult.push_back(it->second);\n\t\t\t\tdistance -= it->second->GetDistance();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresult.push_back(it->second);\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 43.16905437348182}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> result;\n\tfor (auto it = map.GetWaypoints().begin(); it!= map.GetWaypoints().end(); ++it) {\n\t\tif (it->first == this->id) {\n\t\t\tfor (auto it2 = std::prev(it); it2!= map.GetWaypoints().end(); --it2) {\n\t\t\t\tif (it2->first!= this->id) {\n\t\t\t\t\tresult.push_back(std::make_shared<Waypoint>(it2->second));\n\t\t\t\t\tif (result.back()->GetDistance() > distance) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 51.550137307839506}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<Waypoint*> waypoints;\n\tmap->GetPreviousWaypoints(this->x, this->y, distance, waypoints);\n\tstd::vector<SharedPtr<Waypoint>> result;\n\tfor (auto& wp : waypoints) {\n\t\tresult.push_back(wp);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 45.3209088466504}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\n\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tif (signal->GetLandmark()!= nullptr) {\n\t\t\tresult.push_back(signal->GetLandmark());\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 31.78169751759954}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\nstd::vector<SharedPtr<Landmark>> landmarks;", "CodeBleu_score": 7.608873441278351}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\n\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tif (signal->IsRepeated()) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto new_landmark = MakeShared<Landmark>(signal->GetPosition());\n\t\tnew_landmark->AddSignal(signal);\n\t\tresult.push_back(new_landmark);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 39.50125829811166}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\treturn ApplySettings(settings, timeout, nullptr);\n}\n", "CodeBleu_score": 8.396954222303824}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\tauto settings_id = m_settings_manager->AddSettings(settings);\n\tm_settings_manager->SetLocalTimeout(settings_id, std::max(timeout, m_settings_manager->GetSettings(settings_id).network_settings.timeout));\n\treturn settings_id;\n}\n", "CodeBleu_score": 15.624677346130161}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\t// Check that the settings are valid\n\tif (settings.map_url.empty()) {\n\t\tthrow std::invalid_argument(\"Map URL must be provided\");\n\t}\n\tif (settings.map_url.substr(0, 7)!= \"http://\" && settings.map_url.substr(0, 8)!= \"https://\") {\n\t\tthrow std::invalid_argument(\"Map URL must be a valid HTTP(S) URL\");\n\t}\n\tif (settings.map_url.find(\" \")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain spaces\");\n\t}\n\tif (settings.map_url.find(\"\\n\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain newlines\");\n\t}\n\tif (settings.map_url.find(\"\\r\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain carriage returns\");\n\t}\n\tif (settings.map_url.find(\"\\t\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain tabs\");\n\t}\n\tif (settings.map_url.find(\"\\\\\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain backslashes\");\n\t}\n\tif (settings.map_url.find(\"/\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain forward slashes\");\n\t}\n\tif (settings.map_url.find(\"..\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain relative paths\");\n\t}\n\tif (settings.map_url.find(\"%\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain URL encoded characters\");\n\t}\n\tif (settings.map_url.find(\"?\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not contain query strings\");\n\t}\n\tif (settings.map_url.find(\"#\")!= std::string::npos) {\n\t\tthrow std::invalid_argument(\"Map URL must not", "CodeBleu_score": 21.15910031991543}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tfloat segmentLengthSquared = (segment.end - segment.start).LengthSquared();\n\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\n\tif (segmentLength == 0.0f) {\n\t\treturn {0.0f, (point - segment.start).Length()};\n\t}\n\n\tVector2 segmentDirection = (segment.end - segment.start) / segmentLength;\n\tVector2 pointToSegmentStart = point - segment.start;\n\tfloat dotProduct = Vector2::DotProduct(segmentDirection, pointToSegmentStart);\n\n\tif (dotProduct < 0.0f) {\n\t\treturn {(pointToSegmentStart).Length(), 0.0f};\n\t}\n\n\tif (dotProduct > segmentLengthSquared) {\n\t\treturn {(point - segment.end).Length(), 0.0f};\n\t}\n\n\tVector2 projection = segment.start + segmentDirection * dotProduct;\n\treturn {(projection - point).Length(), (projection - point).Length()};\n}\n", "CodeBleu_score": 34.02739011213233}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\treturn std::make_pair(0.0f, 0.0f);\n}\n", "CodeBleu_score": 2.006401781785062}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\treturn Math::DistanceSegmentToPoint(segment, point);\n}\n", "CodeBleu_score": 1.9422524732743258}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices) assert(vertices.size() >= 3);\n const std::size_t initial_index = vertices_.size();\n vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n for (std::size_t i = 2; i < vertices.size(); ++i) {\n indices_.push_back(initial_index);\n indices_.push_back(initial_index + i - 1);\n indices_.push_back(initial_index + i);\n }\n }\n", "CodeBleu_score": 49.68366977708779}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices) assert(vertices.size() >= 3);\n auto idx = vertices_.size();\n vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n for (size_t i = 2; i < vertices.size(); ++i) {\n indices_.push_back(idx);\n indices_.push_back(idx + i - 1);\n indices_.push_back(idx + i);\n }\n }\n *\n * @param vertices\n * @return\n */", "CodeBleu_score": 47.161293894546645}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices) assert(vertices.size() >= 3);\n for (size_t i = 0; i < vertices.size(); i++) {\n AddVertex(vertices[i]);\n }\n for (size_t i = 2; i < vertices.size(); i++) {\n AddTriangle(0, i - 1, i);\n }\n }\n *\n * This function, Mesh::AddTriangleStrip, adds a triangle strip to the mesh using a provided list of vertices.\\nIt first asserts that there are at least three vertices.\\nIt then records the initial index and adds the vertices to the mesh.\\nThe function iteratively adds indices to form triangles, connecting the initial vertex with each subsequent pair of vertices in the list.\n */\n void Mesh::AddTriangleStrip(const std::vector<Mesh::vertex_type> &vertices) {\n assert(vertices.size() >= 3);\n for (size_t i = 0; i < vertices.size(); i++) {\n AddVertex(vertices[i]);\n }\n for (size_t i = 2; i < vertices.size(); i++) {\n if (i % 2 == 0) {\n AddTriangle(i - 2, i - 1, i);\n } else {\n AddTriangle(i - 1, i - 2, i);\n }\n }\n }\n *\n * This function, Mesh::AddTriangleStrip, adds a triangle strip to the mesh using a provided list of vertices.\\nIt first asserts that there are at least three vertices.\\nIt then records the initial index and adds the vertices to the mesh.\\nThe function iteratively adds indices to form triangles, connecting the initial vertex with each subsequent pair of vertices in the list.\n */\n void Mesh::AddTriangleStrip(const std::vector<Mesh::vertex_type> &vertices, const std::vector<Mesh::texcoord_type> &texcoords) {\n assert(vertices.size() >= 3);\n for (size_t i = 0; i < vertices.size(); i++) {\n AddVertex(vertices[i], texcoords[i]);\n }\n for (size_t i = 2; i < vertices.size(); i++) {\n if (i % 2 == 0) {\n AddTriangle(i - 2, i - 1, i);", "CodeBleu_score": 36.24832440746365}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)#ifdef DEBUG_MESSAGES\n  LOG(INFO) << \"Primary::Write: \" << message;", "CodeBleu_score": 5.811529596416592}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)#ifdef DEBUG_MESSAGES\n  std::cout << \"Primary::Write()\" << std::endl;", "CodeBleu_score": 4.0078758408152195}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\t// Ensure the message is valid.\n\tif (!message) {\n\t\treturn;\n\t}\n\n\t// Post the lambda to the strand to be executed.\n\t_strand.post([this, message]() {\n\t\t// Check if the socket is open.\n\t\tif (!IsOpen()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Set a timeout.\n\t\tSetTimeout();\n\n\t\t// Initiate an asynchronous write.\n\t\tasio::async_write(\n\t\t\t*_socket,\n\t\t\tasio::buffer(message->header, sizeof(message->header) + message->payload_size),\n\t\t\t[this, message](const asio::error_code &error, size_t bytes_transferred) {\n\t\t\t\t// Handle the result.\n\t\t\t\tHandleSent(error, bytes_transferred, message);\n\t\t\t});\n\t});\n}\n", "CodeBleu_score": 23.635114058194034}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (!ec) {\n\t\tdeadline_timer_.cancel();\n\t\tif (socket_.is_open()) {\n\t\t\tsocket_.shutdown(tcp::socket::shutdown_both, ec);\n\t\t\tif (!ec) {\n\t\t\t\tsocket_.close(ec);\n\t\t\t}\n\t\t}\n\t}\n\tif (!ec) {\n\t\tLOG(INFO) << \"Session closed\";\n\t\ton_closed();\n\t} else {\n\t\tLOG(ERROR) << \"Error closing session: \" << ec.message();\n\t}\n}\n", "CodeBleu_score": 53.929919090745294}, {"code": "void Primary::CloseNow(boost::system::error_code ec)\tdeadline_timer_.cancel();\n\tif (!ec && socket_.is_open()) {\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\tsocket_.close(ec);\n\t}\n\tif (on_closed_) {\n\t\ton_closed_();\n\t}\n\tLOG(INFO) << \"Session closed\";\n}\n", "CodeBleu_score": 51.893270790181624}, {"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (ec) {\n\t\treturn;\n\t}\n\n\tdeadline_.cancel();\n\n\tif (socket_.is_open()) {\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\tsocket_.close();\n\t}\n\n\tLOG(INFO) << \"Session closed\";\n\ton_closed();\n}\n", "CodeBleu_score": 32.95743398221179}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()\t// Create a buffer for the message\n\tuint8_t buffer[20];\n\t// Create a message\n\tstd::string message = \"Are you alive?\";\n\t// Write the message to the buffer\n\tmemcpy(buffer, message.c_str(), message.length());\n\t// Log the sending action\n\tstd::cout << \"Sending: \" << message << std::endl;\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\tWrite(buffer, 20, YOU_ALIVE);\n\t// Wait for a response\n\tRead();\n}\n", "CodeBleu_score": 27.901680050741106}, {"code": "void PrimaryCommands::SendIsAlive()\t// Create a buffer from the message\n\tuint8_t buffer[16] = {0};\n\tbuffer[0] = 0x00;\n\tbuffer[1] = 0x00;\n\tbuffer[2] = 0x00;\n\tbuffer[3] = 0x00;\n\tbuffer[4] = 0x00;\n\tbuffer[5] = 0x00;\n\tbuffer[6] = 0x00;\n\tbuffer[7] = 0x00;\n\tbuffer[8] = 0x00;\n\tbuffer[9] = 0x00;\n\tbuffer[10] = 0x00;\n\tbuffer[11] = 0x00;\n\tbuffer[12] = 0x00;\n\tbuffer[13] = 0x00;\n\tbuffer[14] = 0x00;\n\tbuffer[15] = 0x00;\n\t// Log the sending action\n\tSerial.print(\"Sending is alive message: \");\n\tfor (int i = 0; i < 16; i++) {\n\t\tSerial.print(buffer[i], HEX);\n\t\tSerial.print(\" \");\n\t}\n\tSerial.println(\"\");\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\tWriteBuffer(buffer, 16, YOU_ALIVE);\n\t// Wait for and log the response from the system\n\tuint8_t response[16] = {0};\n\tuint8_t responseLength = 0;\n\tuint8_t command = 0;\n\twhile (1) {\n\t\tReadBuffer(response, &responseLength, &command);\n\t\tif (command == YOU_ALIVE) {\n\t\t\tSerial.print(\"Received is alive message: \");\n\t\t\tfor (int i = 0; i < responseLength; i++) {\n\t\t\t\tSerial.print(response[i], HEX);\n\t\t\t\tSerial.print(\" \");\n\t\t\t}\n\t\t\tSerial.println(\"\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.52705581585336}, {"code": "void PrimaryCommands::SendIsAlive()\tchar buffer[100];\n\tsprintf(buffer, \"%s\", \"Are you alive?\");\n\tLogger::Log(\"Sending IsAlive message\");\n\tWrite(buffer, YOU_ALIVE);\n\tLogger::Log(\"Waiting for IsAlive response\");\n\tRead();\n}\n", "CodeBleu_score": 22.842481378820228}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\tif (sensor_id == 0) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < NUMBER_OF_SECONDARY_SERVERS; i++) {\n\t\tif (secondary_servers[i].sensor_id == sensor_id) {\n\t\t\t// Send enable ros command to secondary server\n\t\t\tstream_id buffer_id = SendEnableROS(secondary_servers[i].router_id, sensor_id);\n\t\t\t// Wait for and process response\n\t\t\tProcessEnableROSResponse(buffer_id);\n\t\t\treturn;\n\t\t}\n\t}\n\tROS_ERROR(\"Sensor ID %d not found on any secondary server\", sensor_id);\n}\n", "CodeBleu_score": 31.63318184544577}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\tif (sensor_id == stream_id::STREAM_ID_NONE) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_NONE\");\n\t\treturn;\n\t}\n\tif (sensor_id == stream_id::STREAM_ID_ALL) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_ALL\");\n\t\treturn;\n\t}\n\tif (sensor_id == stream_id::STREAM_ID_ALL_BUT_IMU) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_ALL_BUT_IMU\");\n\t\treturn;\n\t}\n\tif (sensor_id == stream_id::STREAM_ID_ALL_BUT_PRESSURE) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_ALL_BUT_PRESSURE\");\n\t\treturn;\n\t}\n\tif (sensor_id == stream_id::STREAM_ID_ALL_BUT_MAGNETOMETER) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_ALL_BUT_MAGNETOMETER\");\n\t\treturn;\n\t}\n\tif (sensor_id == stream_id::STREAM_ID_ALL_BUT_LINEAR_ACCELERATION) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_ALL_BUT_LINEAR_ACCELERATION\");\n\t\treturn;\n\t}\n\tif (sensor_id == stream_id::STREAM_ID_ALL_BUT_GYROSCOPE) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_ALL_BUT_GYROSCOPE\");\n\t\treturn;\n\t}\n\tif (sensor_id == stream_id::STREAM_ID_ALL_BUT_ROTATION_VECTOR) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_ALL_BUT_ROTATION_VECTOR\");\n\t\treturn;\n\t}\n\tif (sensor_id == stream_id::STREAM_ID_ALL_BUT_GEOMAGNETIC_ROTATION_VECTOR) {\n\t\tLOG_ERROR(\"ERROR: Sensor ID is STREAM_ID_ALL_BUT_GEOMAGNETIC_ROTATION_VECTOR\");\n\t\treturn;\n\t}\n\tif (sensor", "CodeBleu_score": 16.499696626926337}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Check if the sensor is found on any server\n\tbool found = false;\n\tfor (int i = 0; i < NUM_SECONDARY_SERVERS; i++) {\n\t\tif (secondary_server_ids[i] == sensor_id) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If not found, log an error message\n\tif (!found) {\n\t\tprintf(\"ERROR: %s is not found on any secondary server\\n\", stream_id_to_string(sensor_id));\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID and the ENABLE_ROS command\n\tchar* buffer = (char*) malloc(sizeof(char) * 100);\n\tsprintf(buffer, \"%d,%d\", sensor_id, ENABLE_ROS);\n\n\t// Send the buffer to the router\n\trouter_send(buffer, strlen(buffer));\n\n\t// Wait for and process the server's response\n\tchar* response = (char*) malloc(sizeof(char) * 100);\n\tint response_length = router_recv(response, 100);\n\tif (response_length < 0) {\n\t\tprintf(\"ERROR: Could not receive a response from the server\\n\");\n\t\treturn;\n\t}\n\n\t// Parse the response\n\tint response_id, response_command;\n\tsscanf(response, \"%d,%d\", &response_id, &response_command);\n\n\t// If the response is not valid, log an error message\n\tif (response_id!= sensor_id || response_command!= ENABLE_ROS) {\n\t\tprintf(\"ERROR: Received an invalid response from the server\\n\");\n\t\treturn;\n\t}\n\n\t// Log a success message\n\tprintf(\"SUCCESS: ENABLE_ROS command sent to %s\\n\", stream_id_to_string(sensor_id));\n}\n", "CodeBleu_score": 38.9743022933414}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\t// Check if the sensor is already activated\n\tif (sensor_id_to_token_map.find(sensor_id)!= sensor_id_to_token_map.end()) {\n\t\t// If the sensor is already activated, return the existing token\n\t\ttoken_type token = sensor_id_to_token_map[sensor_id];\n\t\tLOG(INFO) << \"Sensor \" << sensor_id << \" is already activated. Returning existing token \" << token;\n\t\treturn token;\n\t} else {\n\t\t// If the sensor is not activated, activate the sensor on a secondary server\n\t\tLOG(INFO) << \"Sensor \" << sensor_id << \" is not activated. Activating sensor on a secondary server.\";\n\t\tActivateSensor(sensor_id);\n\t\t// Retrieve a new token\n\t\ttoken_type token = GetNewToken();\n\t\t// Update the maps\n\t\tsensor_id_to_token_map[sensor_id] = token;\n\t\ttoken_to_sensor_id_map[token] = sensor_id;\n\t\t// Log the action\n\t\tLOG(INFO) << \"Sensor \" << sensor_id << \" is activated on a secondary server. Returning new token \" << token;\n\t\treturn token;\n\t}\n}\n", "CodeBleu_score": 44.57334409434598}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\t// Check if sensor is already activated\n\tif (sensor_id in activated_sensors) {\n\t\tLOG(INFO) << \"Sensor \" << sensor_id << \" is already activated. Returning existing token.\";\n\t\treturn activated_sensors[sensor_id];\n\t}\n\t// If not, enable sensor on secondary server\n\tLOG(INFO) << \"Sensor \" << sensor_id << \" is not activated. Enabling sensor on secondary server.\";\n\tPrimaryCommands::EnableSensor(sensor_id);\n\t// Retrieve token\n\ttoken_type token = secondary_server.GetSensorToken(sensor_id);\n\t// Update maps\n\tactivated_sensors[sensor_id] = token;\n\t// Log action\n\tLOG(INFO) << \"Sensor \" << sensor_id << \" is activated. Token: \" << token;\n\treturn token;\n}\n", "CodeBleu_score": 39.530704497702736}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\t// Check if the sensor is already activated\n\tif (activated_sensors.count(sensor_id) > 0) {\n\t\t// If the sensor is already activated, log the action\n\t\tLOG_INFO(\"Sensor %s is already activated\", sensor_id.c_str());\n\t\treturn activated_sensors.at(sensor_id);\n\t}\n\t// If the sensor is not activated, enable the sensor on a secondary server\n\telse {\n\t\t// Create a new message\n\t\tMessage msg;\n\t\t// Set the message type to enable\n\t\tmsg.set_type(Message::ENABLE);\n\t\t// Set the message data to the sensor_id\n\t\tmsg.set_data(sensor_id);\n\t\t// Send the message\n\t\tSendSecondaryMessage(msg);\n\t\t// Wait for the secondary server to send a reply\n\t\tMessage reply;\n\t\tReceiveSecondaryMessage(reply);\n\t\t// Check if the reply is an ACK\n\t\tif (reply.get_type() == Message::ACK) {\n\t\t\t// If the reply is an ACK, retrieve a new token\n\t\t\ttoken_type new_token = GenerateToken();\n\t\t\t// Update the maps\n\t\t\tactivated_sensors[sensor_id] = new_token;\n\t\t\tsensor_tokens[new_token] = sensor_id;\n\t\t\t// Log the action\n\t\t\tLOG_INFO(\"Sensor %s is activated\", sensor_id.c_str());\n\t\t\t// Return the new token\n\t\t\treturn new_token;\n\t\t}\n\t\t// If the reply is not an ACK, return an empty token\n\t\telse {\n\t\t\tLOG_ERROR(\"Error enabling sensor %s\", sensor_id.c_str());\n\t\t\treturn token_type();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.235515133643446}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file;\n\tfile.open(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(data);\n}\n", "CodeBleu_score": 61.55714080698241}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (file.is_open()) {\n\t\tstd::vector<char> data;\n\t\tfile.seekg(0, std::ios::end);\n\t\tdata.resize(file.tellg());\n\t\tfile.seekg(0, std::ios::beg);\n\t\tfile.read(data.data(), data.size());\n\t\tfile.close();\n\t\treturn Load(data);\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 48.35739180976662}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\tstd::cout << \"Could not open file \" << filename << std::endl;\n\t\treturn false;\n\t}\n\n\t// Read file into a vector\n\tstd::vector<unsigned char> file_data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\n\t// Parse file\n\treturn Load(file_data);\n}\n", "CodeBleu_score": 52.772471113971086}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)\t// Check if the system is ready\n\tif (!ready) {\n\t\treturn false;\n\t}\n\t// Check if the crowd object is not null\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\t// Search for the agent id in the walker and vehicle mappings\n\tauto walker = walkers.find(id);\n\tauto vehicle = vehicles.find(id);\n\t// If found, remove the agent from the crowd\n\tif (walker!= walkers.end()) {\n\t\t// Enter a critical section\n\t\tstd::lock_guard<std::mutex> lock(crowdMutex);\n\t\t// Remove the agent\n\t\tcrowd->removeAgent(walker->second);\n\t\t// Update the walker manager\n\t\twalkerManager.RemoveAgent(id);\n\t\t// Remove the id from the mappings\n\t\twalkers.erase(walker);\n\t}\n\telse if (vehicle!= vehicles.end()) {\n\t\t// Enter a critical section\n\t\tstd::lock_guard<std::mutex> lock(crowdMutex);\n\t\t// Remove the agent\n\t\tcrowd->removeAgent(vehicle->second);\n\t\t// Update the vehicle manager\n\t\tvehicleManager.RemoveAgent(id);\n\t\t// Remove the id from the mappings\n\t\tvehicles.erase(vehicle);\n\t}\n\telse {\n\t\t// The agent is not in the navigation system\n\t\treturn false;\n\t}\n\t// The agent is successfully removed\n\treturn true;\n}\n", "CodeBleu_score": 55.57354873826619}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!m_ready) {\n\t\treturn false;\n\t}\n\tif (m_crowd == nullptr) {\n\t\treturn false;\n\t}\n\tif (m_agent_map.find(id)!= m_agent_map.end()) {\n\t\tstd::lock_guard<std::mutex> lock(m_agent_map_mutex);\n\t\tauto agent = m_agent_map[id];\n\t\tm_crowd->removeAgent(agent);\n\t\tif (agent->m_type == AgentType::WALKER) {\n\t\t\tm_walker_manager->removeWalker(agent);\n\t\t}\n\t\telse {\n\t\t\tm_vehicle_manager->removeVehicle(agent);\n\t\t}\n\t\tm_agent_map.erase(id);\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 42.09618311504448}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tassert(m_ready);\n\tassert(m_crowd);\n\n\tbool success = false;\n\n\tstd::unique_lock<std::mutex> lock(m_mutex);\n\n\t// Search for the agent in the walker and vehicle mappings.\n\tauto walker = m_walkers.find(id);\n\tauto vehicle = m_vehicles.find(id);\n\n\tif (walker!= m_walkers.end()) {\n\t\t// Remove the agent from the crowd.\n\t\tm_crowd->removeAgent(walker->second);\n\n\t\t// Update the walker manager.\n\t\tm_walkerManager.removeAgent(walker->second);\n\n\t\t// Remove the agent from the mappings.\n\t\tm_walkers.erase(walker);\n\n\t\tsuccess = true;\n\t}\n\telse if (vehicle!= m_vehicles.end()) {\n\t\t// Remove the agent from the crowd.\n\t\tm_crowd->removeAgent(vehicle->second);\n\n\t\t// Update the vehicle manager.\n\t\tm_vehicleManager.removeAgent(vehicle->second);\n\n\t\t// Remove the agent from the mappings.\n\t\tm_vehicles.erase(vehicle);\n\n\t\tsuccess = true;\n\t}\n\n\treturn success;\n}\n", "CodeBleu_score": 46.60413899777935}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> current_vehicles = GetVehicleIDs();\n\tfor (auto& vehicle : vehicles) {\n\t\tif (vehicle.id == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (current_vehicles.find(vehicle.id) == current_vehicles.end()) {\n\t\t\tAddVehicle(vehicle.id, vehicle.bounding_box, vehicle.position, vehicle.velocity, vehicle.yaw, vehicle.is_ego);\n\t\t}\n\t\telse {\n\t\t\tUpdateVehicle(vehicle.id, vehicle.bounding_box, vehicle.position, vehicle.velocity, vehicle.yaw, vehicle.is_ego);\n\t\t}\n\t}\n\tfor (auto& vehicle_id : current_vehicles) {\n\t\tif (vehicle_id == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (std::find_if(vehicles.begin(), vehicles.end(), [vehicle_id](const VehicleCollisionInfo& vehicle) { return vehicle.id == vehicle_id; }) == vehicles.end()) {\n\t\t\tRemoveVehicle(vehicle_id);\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 48.66437817920987}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> vehicle_ids;\n\tfor (auto vehicle : vehicles) {\n\t\tvehicle_ids.insert(vehicle.id);\n\t}\n\tfor (auto vehicle : vehicles_) {\n\t\tif (vehicle_ids.find(vehicle.id) == vehicle_ids.end()) {\n\t\t\tvehicle.updated = false;\n\t\t}\n\t}\n\tfor (auto vehicle : vehicles) {\n\t\tauto it = vehicle_map_.find(vehicle.id);\n\t\tif (it == vehicle_map_.end()) {\n\t\t\tvehicle_map_[vehicle.id] = vehicle.id;\n\t\t\tvehicles_.push_back(vehicle);\n\t\t} else {\n\t\t\tvehicles_[it->second] = vehicle;\n\t\t}\n\t}\n\tvehicles_.erase(std::remove_if(vehicles_.begin(), vehicles_.end(), [](VehicleCollisionInfo vehicle) { return!vehicle.updated; }), vehicles_.end());\n\treturn true;\n}\n", "CodeBleu_score": 46.49856511793844}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> vehicle_ids;\n\tfor (auto vehicle : vehicles) {\n\t\tvehicle_ids.insert(vehicle.vehicle_id);\n\t}\n\n\tfor (auto vehicle : vehicles_) {\n\t\tif (vehicle_ids.count(vehicle.vehicle_id) > 0) {\n\t\t\tvehicle.updated = true;\n\t\t} else if (vehicle.updated) {\n\t\t\tvehicle.updated = false;\n\t\t\tvehicle.removed = true;\n\t\t}\n\t}\n\n\tfor (auto vehicle : vehicles) {\n\t\tif (vehicle.removed) {\n\t\t\tcontinue;\n\t\t}\n\t\tbool vehicle_found = false;\n\t\tfor (auto vehicle_ : vehicles_) {\n\t\t\tif (vehicle_.vehicle_id == vehicle.vehicle_id) {\n\t\t\t\tvehicle_.updated = true;\n\t\t\t\tvehicle_.removed = false;\n\t\t\t\tvehicle_.position = vehicle.position;\n\t\t\t\tvehicle_.velocity = vehicle.velocity;\n\t\t\t\tvehicle_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!vehicle_found) {\n\t\t\tVehicle vehicle_;\n\t\t\tvehicle_.vehicle_id = vehicle.vehicle_id;\n\t\t\tvehicle_.updated = true;\n\t\t\tvehicle_.removed = false;\n\t\t\tvehicle_.position = vehicle.position;\n\t\t\tvehicle_.velocity = vehicle.velocity;\n\t\t\tvehicles_.push_back(vehicle_);\n\t\t}\n\t}\n\n\tfor (auto it = vehicles_.begin(); it!= vehicles_.end();) {\n\t\tif ((*it).removed) {\n\t\t\tit = vehicles_.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 44.868374416161465}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)#if WITH_RECAST\n  std::lock_guard<std::mutex> lock(MapMutex);\n  if (id < 0) {\n    return false;\n  }\n  if (Walkers.find(id)!= Walkers.end()) {\n    return false;\n  }\n  if (Vehicles.find(id)!= Vehicles.end()) {\n    return false;\n  }\n  if (Crowd) {\n    carla::geom::Location location = GetActorLocation(id);\n    float sq_distance = location.DistanceSquared(direction);\n    return sq_distance <= distance * distance;\n  }", "CodeBleu_score": 48.289771686051495}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tauto *actor = FindActor(id);\n\tif (!actor) {\n\t\treturn false;\n\t}\n\tauto *walker = dynamic_cast<Walker *>(actor);\n\tauto *vehicle = dynamic_cast<Vehicle *>(actor);\n\tif (walker) {\n\t\tauto *w = FindWalker(walker);\n\t\tif (w) {\n\t\t\tauto *crowd = GetCrowd(w->crowd_id);\n\t\t\tif (crowd) {\n\t\t\t\tauto *crowd_agent = crowd->GetAgent(w->crowd_agent_id);\n\t\t\t\tif (crowd_agent) {\n\t\t\t\t\treturn crowd_agent->HasVehicleNear(distance * distance, direction);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (vehicle) {\n\t\tauto *v = FindVehicle(vehicle);\n\t\tif (v) {\n\t\t\tauto *crowd = GetCrowd(v->crowd_id);\n\t\t\tif (crowd) {\n\t\t\t\tauto *crowd_agent = crowd->GetAgent(v->crowd_agent_id);\n\t\t\t\tif (crowd_agent) {\n\t\t\t\t\treturn crowd_agent->HasVehicleNear(distance * distance, direction);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 39.59784931073111}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_crowd) {\n\t\tcarla::geom::Location actor_location = GetActorLocation(id);\n\t\tcarla::geom::Location vehicle_location;\n\t\tcarla::geom::Vector3D vehicle_velocity;\n\t\tfloat vehicle_distance;\n\t\tbool is_vehicle_near = false;\n\t\tfor (const auto &walker : m_walkers) {\n\t\t\tif (walker.id!= id) {\n\t\t\t\tvehicle_location = GetActorLocation(walker.id);\n\t\t\t\tvehicle_distance = actor_location.DistanceSquared(vehicle_location);\n\t\t\t\tif (vehicle_distance < distance * distance) {\n\t\t\t\t\tis_vehicle_near = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!is_vehicle_near) {\n\t\t\tfor (const auto &vehicle : m_vehicles) {\n\t\t\t\tif (vehicle.id!= id) {\n\t\t\t\t\tvehicle_location = GetActorLocation(vehicle.id);\n\t\t\t\t\tvehicle_velocity = GetActorVelocity(vehicle.id);\n\t\t\t\t\tvehicle_distance = actor_location.DistanceSquared(vehicle_location);\n\t\t\t\t\tif (vehicle_distance < distance * distance) {\n\t\t\t\t\t\tis_vehicle_near = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (is_vehicle_near) {\n\t\t\tcarla::geom::Vector3D direction_vector = vehicle_location - actor_location;\n\t\t\tfloat dot_product = direction_vector.Dot(direction);\n\t\t\tif (dot_product > 0.0f) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 42.38127749036272}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tEventResult result = EventResult::kSuccess;\n\n\tauto &walker = m_Walkers[id];\n\tauto &route = walker.m_Route;\n\tauto &routePoint = route[walker.m_CurrentRoutePoint];\n\n\tif (routePoint.m_Type == RoutePoint::Type::kWalk) {\n\t\tWalkerEventVisitor visitor(m_World, m_Physics, m_Audio, m_Graphics, info, delta);\n\t\tresult = boost::variant2::visit(visitor, routePoint.m_Event);\n\t} else if (routePoint.m_Type == RoutePoint::Type::kWait) {\n\t\twalker.m_WaitTimeRemaining -= delta;\n\t\tif (walker.m_WaitTimeRemaining <= 0.0) {\n\t\t\twalker.m_WaitTimeRemaining = 0.0;\n\t\t\twalker.m_CurrentRoutePoint++;\n\t\t}\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 43.76647548758859}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tauto route_point = info.route.GetRoutePoint(info.route_index);\n\tauto visitor = WalkerEventVisitor(id, info, delta);\n\treturn boost::variant2::visit(visitor, route_point);\n}\n", "CodeBleu_score": 56.168253248714564}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tEventResult result = EventResult::kNoResult;\n\tauto route = info.route;\n\tif (!route.empty()) {\n\t\tauto &routePoint = route.front();\n\t\tauto visitor = WalkerEventVisitor(id, info.context, delta);\n\t\tresult = boost::apply_visitor(visitor, routePoint);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 47.02717166355407}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\tpugi::xml_node roads = xml.child(\"OpenDRIVE\");\n\tpugi::xml_node road = roads.child(\"road\");\n\twhile (road) {\n\t\tstd::string id = road.attribute(\"id\").value();\n\t\tpugi::xml_node plan_view = road.child(\"planView\");\n\t\tpugi::xml_node geometry = plan_view.child(\"geometry\");\n\t\tpugi::xml_node line = geometry.child(\"line\");\n\t\tpugi::xml_node spiral = geometry.child(\"spiral\");\n\t\tpugi::xml_node arc = geometry.child(\"arc\");\n\t\tpugi::xml_node poly3 = geometry.child(\"poly3\");\n\t\tpugi::xml_node paramPoly3 = geometry.child(\"paramPoly3\");\n\t\tpugi::xml_node clothoid = geometry.child(\"clothoid\");\n\t\tpugi::xml_node clothoidList = geometry.child(\"clothoidList\");\n\t\tpugi::xml_node cubicPolynomial = geometry.child(\"cubicPolynomial\");\n\t\tpugi::xml_node roadList = plan_view.child(\"roadList\");\n\t\tpugi::xml_node junction = plan_view.child(\"junction\");\n\t\tpugi::xml_node predecessor = road.child(\"predecessor\");\n\t\tpugi::xml_node successor = road.child(\"successor\");\n\t\tpugi::xml_node left_lanes = road.child(\"leftLanes\");\n\t\tpugi::xml_node right_lanes = road.child(\"rightLanes\");\n\t\tpugi::xml_node lanes = road.child(\"lanes\");\n\t\tif (roadList) {\n\t\t\tstd::cout << \"Road list is not supported yet.\" << std::endl;\n\t\t\texit(1);\n\t\t}\n\t\tif (junction) {\n\t\t\tstd::cout << \"Junctions are not supported yet.\" << std::endl;\n\t\t\texit(1);\n\t\t}\n\t\tif (predecessor) {\n\t\t\tstd::cout << \"Predecessors are not supported yet.\" << std::endl;\n\t\t\texit(1);\n\t\t}\n\t\tif (successor) {\n\t\t\tstd::cout << \"Successors are not supported yet.\" << std::endl;", "CodeBleu_score": 43.20107922277493}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n// Iterate through each road node", "CodeBleu_score": 4.750000000110259}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n// Iterate through each road node in the XML document", "CodeBleu_score": 4.750002564577609}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)#ifndef NDEBUG\n  std::cout << \"on_publication_matched: \" << info.total_count_change << \" \" << info.current_count_change << std::endl;", "CodeBleu_score": 24.13557859064661}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (info.total_count == info.total_count_change) {\n\t\t// total count has not changed\n\t\treturn;\n\t}\n\tif (info.total_count_change > 0) {\n\t\t// total count increased\n\t\tif (matched_ == 0) {\n\t\t\tmatched_ = info.total_count_change;\n\t\t\twriter_ = writer;\n\t\t} else {\n\t\t\t// more than one match\n\t\t\tlog_error(\"More than one match for CarlaEgoVehicleControl\");\n\t\t}\n\t} else {\n\t\t// total count decreased\n\t\tmatched_ -= info.total_count_change;\n\t\tif (matched_ == 0) {\n\t\t\twriter_ = nullptr;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 39.617976112073585}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)#ifdef DEBUG_ROS\n  ROS_INFO_STREAM(\"New match found on topic \" << info.topic_name << \" with \" << info.current_count << \" current matches\");", "CodeBleu_score": 22.70538112554523}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (info.current_count_change == 1) {\n\t\t++matched_count;\n\t\tif (matched_count == 1) {\n\t\t\tfirst_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t--matched_count;\n\t\tif (matched_count == 0) {\n\t\t\tdestroy_subscriber();\n\t\t}\n\t} else {\n\t\tstd::cout << \"Subscription matched callback with invalid change count \" << info.current_count_change << std::endl;\n\t}\n}\n", "CodeBleu_score": 57.2427899659925}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\tif (info.current_count_change == 1) {\n\t\t++_matched_subscriptions;\n\t\tif (_matched_subscriptions == 1) {\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t--_matched_subscriptions;\n\t\tif (_matched_subscriptions == 0) {\n\t\t\treader->destroy();\n\t\t}\n\t} else {\n\t\tstd::cout << \"Unexpected current_count_change status: \" << info.current_count_change << std::endl;\n\t}\n}\n", "CodeBleu_score": 53.61649640062518}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)#if DEBUG_CARLA_SUBSCRIBER_LISTENER\n  std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched()\" << std::endl;", "CodeBleu_score": 7.522555896801668}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)#if defined(CARLA_NO_RPC)\n  (void)data;\n  (void)handle;\n  (void)force_md5;\n  return false;", "CodeBleu_score": 7.5793785875309}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)#if WITH_FASTCDR\n                bool key_present = false;\n                CarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n                const void *temp = p_type;\n                CdrStream cdr_stream;\n                cdr_stream.attach(reinterpret_cast<uint8_t*>(const_cast<void*>(temp)), 1024);\n                if (force_md5 || CarlaCollisionEvent::serializeKey(cdr_stream)) {\n                    cdr_stream.detach(handle, 16);\n                    key_present = true;\n                }\n                return key_present;", "CodeBleu_score": 28.742584750532714}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)#if defined(CARLA_NO_MD5)\n  (void)data;\n  (void)handle;\n  (void)force_md5;\n  return false;", "CodeBleu_score": 7.579393054724762}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)#ifndef NDEBUG\n  LOG4CXX_TRACE(logger_, \"CarlaEgoVehicleControlPubSubType::serialize()\");", "CodeBleu_score": 2.5697611675179726}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)#ifndef NDEBUG\n  LOG4CXX_DEBUG(logger_, \"CarlaEgoVehicleControlPubSubType::serialize() begin [\" << this << \"]\" );", "CodeBleu_score": 2.6152656435636814}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)#ifndef NDEBUG\n  printf(\"CarlaEgoVehicleControlPubSubType::serialize() [Entry]\\n\");", "CodeBleu_score": 2.5652223403438215}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\t// Check if target has been set\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Decode message\n\tmavlink_message_t msg_copy = msg;\n\tmavlink_msg_global_position_int_decode(&msg_copy, &mav_global_pos);\n\n\t// Check if target system ID is set\n\tif (mav_global_pos.target_system == 0) {\n\t\tmav_global_pos.target_system = mav_global_pos.lat;\n\t\tmav_global_pos.target_system = mav_global_pos.lon;\n\t\tmav_global_pos.target_system = mav_global_pos.alt;\n\n\t\t// Request data streams from target\n\t\tsend_mavlink_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, mav_global_pos.target_system, mav_global_pos.target_component, mavlink_pack_request_data_stream_t(1, 1, 1, 1, 1, 1, 1));\n\t}\n\n\t// Check if message type is one that should be tracked\n\tif (msg.msgid!= MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n\t\treturn;\n\t}\n\n\t// Set target set flag\n\ttarget_set = true;\n}\n", "CodeBleu_score": 36.80299826888008}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\t// Check if target has already been set\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Decode MAVLink message\n\tmavlink_message_t msg_copy = msg;\n\tmavlink_status_t status;\n\tmavlink_msg_heartbeat_decode(&msg_copy, &status);\n\n\t// Check if message type is one that should be tracked\n\tif (status.msg_id!= MAVLINK_MSG_ID_GLOBAL_POSITION_INT && status.msg_id!= MAVLINK_MSG_ID_SCALED_PRESSURE) {\n\t\treturn;\n\t}\n\n\t// Set target system ID if it is not set\n\tif (target_sysid == 0) {\n\t\ttarget_sysid = status.sysid;\n\t\ttarget_set = true;\n\t\tmavlink_request_data_stream_send(target_sysid, target_compid, MAVLINK_DATA_STREAM_POSITION, 1, 1);\n\t\tmavlink_request_data_stream_send(target_sysid, target_compid, MAVLINK_DATA_STREAM_PRESSURE, 1, 1);\n\t\treturn;\n\t}\n\n\t// Check if target system ID matches message system ID\n\tif (status.sysid!= target_sysid) {\n\t\treturn;\n\t}\n\n\t// Set target component ID if it is not set\n\tif (target_compid == 0) {\n\t\ttarget_compid = status.compid;\n\t\ttarget_set = true;\n\t\tmavlink_request_data_stream_send(target_sysid, target_compid, MAVLINK_DATA_STREAM_POSITION, 1, 1);\n\t\tmavlink_request_data_stream_send(target_sysid, target_compid, MAVLINK_DATA_STREAM_PRESSURE, 1, 1);\n\t\treturn;\n\t}\n\n\t// Check if target component ID matches message component ID\n\tif (status.compid!= target_compid) {\n\t\treturn;\n\t}\n\n\t// Set target set flag\n\ttarget_set = true;\n}\n", "CodeBleu_score": 35.82623907143593}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT: {\n\t\tmavlink_global_position_int_t pos;\n\t\tmavlink_msg_global_position_int_decode(&msg, &pos);\n\t\tif (pos.target_system == 0) {\n\t\t\tpos.target_system = pos.lat;\n\t\t}\n\t\tif (pos.target_system == 0) {\n\t\t\tpos.target_system = pos.lon;\n\t\t}\n\t\tif (pos.target_system == 0) {\n\t\t\tpos.target_system = pos.alt;\n\t\t}\n\t\tif (pos.target_system!= 0) {\n\t\t\tif (pos.target_system!= _target_sysid) {\n\t\t\t\t_target_sysid = pos.target_system;\n\t\t\t\tmavlink_msg_request_data_stream_send(_mavlink_fd, 0, _target_sysid, MAV_DATA_STREAM_POSITION | MAV_DATA_STREAM_PRESSURE, MAV_DATA_STREAM_ALL, 1);\n\t\t\t\t_target_set = true;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MAVLINK_MSG_ID_GPS_RAW_INT: {\n\t\tmavlink_gps_raw_int_t pos;\n\t\tmavlink_msg_gps_raw_int_decode(&msg, &pos);\n\t\tif (pos.target_system == 0) {\n\t\t\tpos.target_system = pos.lat;\n\t\t}\n\t\tif (pos.target_system == 0) {\n\t\t\tpos.target_system = pos.lon;\n\t\t}\n\t\tif (pos.target_system == 0) {\n\t\t\tpos.target_system = pos.alt;\n\t\t}\n\t\tif (pos.target_system!= 0) {\n\t\t\tif (pos.target_system!= _target_sysid) {\n\t\t\t\t_target_sysid = pos.target_system;\n\t\t\t\tmavlink_msg_request_data_stream_send(_mavlink_fd, 0, _target_sysid, MAV_DATA_STREAM_POSITION | MAV_DATA_STREAM_PRESSURE, MAV_DATA_STREAM", "CodeBleu_score": 38.395779866935975}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 52.01521276871457}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\tMAV_RESULT result = GCS_MAVLINK_Base::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_altitude_calibration = true;\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 64.2487712961915}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_altitude_calibration = true;\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 53.272874764280665}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n\tif (packet.param1 == 1.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tarm_motors();\n\t}\n\telse if (packet.param1 == 0.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tdisarm_motors();\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 50.146536438964795}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tif (packet.param1 == 1.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tarmServos();\n\t}\n\telse if (packet.param1 == 0.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tdisarmServos();\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 50.63321450377184}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tif (packet.param1 == 1.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tthis->arm_servos();\n\t}\n\telse if (packet.param1 == 0.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tthis->disarm_servos();\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 51.466049170273976}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\t// Check if the system and component ID is valid\n\tif (sysid >= NUM_SYSTEMS || compid >= NUM_COMPONENTS) {\n\t\treturn;\n\t}\n\n\t// Check if there is space available on the GCS channels\n\tfor (uint8_t i = 0; i < NUM_GCS_CHANNELS; i++) {\n\t\tif (gcs_channels[i].available_space() >= POSITION_DATA_LENGTH) {\n\t\t\t// Send a request to start the data stream\n\t\t\tgcs_channels[i].request_datastream_position(sysid, compid);\n\t\t\treturn;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.67307615696972}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\t// Iterate over all available channels\n\tfor (int i = 0; i < _gcs_channels.size(); i++) {\n\t\t// Check if the channel is available\n\t\tif (_gcs_channels[i].status == GCS_CHANNEL_AVAILABLE) {\n\t\t\t// Check if space is available in the payload buffer\n\t\t\tif (_gcs_channels[i].payload_size < _gcs_channels[i].max_payload_size) {\n\t\t\t\t// Send request to start position stream\n\t\t\t\tmavlink_message_t msg;\n\t\t\t\tmavlink_msg_request_data_stream_send(\n\t\t\t\t\t_mavlink_fd,\n\t\t\t\t\t&msg,\n\t\t\t\t\t_gcs_channels[i].sysid,\n\t\t\t\t\t_gcs_channels[i].compid,\n\t\t\t\t\tMAV_DATA_STREAM_TYPE_POSITION,\n\t\t\t\t\t1, 0, 0);\n\t\t\t\t// Update channel status\n\t\t\t\t_gcs_channels[i].status = GCS_CHANNEL_STREAMING_POSITION;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 1;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 1;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 2;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs_channels[i].payload_size += 4;\n\t\t\t\t// Update payload size\n\t\t\t\t_gcs", "CodeBleu_score": 40.91620626223316}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\tfor (int i = 0; i < GCS_CHANNEL_COUNT; i++) {\n\t\tif (gcs_channels[i].sysid == 0 && gcs_channels[i].compid == 0) {\n\t\t\tgcs_channels[i].sysid = sysid;\n\t\t\tgcs_channels[i].compid = compid;\n\t\t\tgcs_channels[i].request_datastream_position();\n\t\t\treturn;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.7595027322626}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\tif (ahrs.get_pitch_cosine() == 0.0f) {\n\t\treturn false;\n\t}\n\tef_pitch = asin(ahrs.get_pitch_cosine() * sin(pitch));\n\tef_yaw = yaw + ahrs.get_roll();\n\treturn true;\n}\n", "CodeBleu_score": 40.89720881418126}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\tif (ahrs.get_pitch_cosine() == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = -1 * atan(ahrs.get_pitch_cosine() * tan(pitch));\n\tef_yaw = yaw + ahrs.get_yaw_offset();\n\treturn true;\n}\n", "CodeBleu_score": 41.00368665623088}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\tfloat pitch_cos = cos(pitch);\n\tif (pitch_cos == 0.0) {\n\t\treturn false;\n\t}\n\tfloat pitch_sin = sin(pitch);\n\tfloat yaw_cos = cos(yaw);\n\tfloat yaw_sin = sin(yaw);\n\tef_pitch = atan2(pitch_sin, pitch_cos);\n\tef_yaw = atan2(yaw_sin * pitch_cos, yaw_cos - pitch_sin * pitch_sin);\n\treturn true;\n}\n", "CodeBleu_score": 36.105434147949325}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)\t// Calculate the yaw and pitch in centidegrees\n\tfloat yaw_cd = (float)yaw_angle * 100.0f;\n\tfloat pitch_cd = (float)pitch_angle * 100.0f;\n\n\t// Check if the direction is reversed\n\tif (yaw_cd > 18000.0f) {\n\t\tyaw_cd = 36000.0f - yaw_cd;\n\t}\n\n\t// Calculate the angle error\n\tfloat yaw_error = yaw_cd - target_yaw;\n\tfloat pitch_error = pitch_cd - target_pitch;\n\n\t// Convert the errors from earth frame to body frame\n\tfloat yaw_error_bf = yaw_error * cos(pitch_angle * 0.0174532925f) + pitch_error * sin(pitch_angle * 0.0174532925f);\n\tfloat pitch_error_bf = -yaw_error * sin(pitch_angle * 0.0174532925f) + pitch_error * cos(pitch_angle * 0.0174532925f);\n\n\t// Check if the target distance is valid or no minimum distance is set\n\tif (target_distance >= 0.0f || minimum_distance == 0.0f) {\n\t\t// Update the pitch and yaw servos\n\t\tyaw_servo.write_angle(yaw_error_bf * 0.02f);\n\t\tpitch_servo.write_angle(pitch_error_bf * 0.02f);\n\t}\n}\n", "CodeBleu_score": 33.66496897637936}, {"code": "void Mode::update_auto(void)\t// Update target yaw and pitch\n\tif (target_distance_valid) {\n\t\t// Calculate target yaw and pitch in centidegrees\n\t\ttarget_yaw_cd = (int32_t) (target_yaw * 100.0f);\n\t\ttarget_pitch_cd = (int32_t) (target_pitch * 100.0f);\n\n\t\t// Check if the direction is reversed\n\t\tif (target_yaw_cd < 0) {\n\t\t\ttarget_yaw_cd = -target_yaw_cd;\n\t\t\ttarget_yaw_cd = 36000 - target_yaw_cd;\n\t\t}\n\t\tif (target_pitch_cd < 0) {\n\t\t\ttarget_pitch_cd = -target_pitch_cd;\n\t\t\ttarget_pitch_cd = 36000 - target_pitch_cd;\n\t\t}\n\n\t\t// Compute the angle error\n\t\tangle_error_yaw_cd = target_yaw_cd - yaw_cd;\n\t\tangle_error_pitch_cd = target_pitch_cd - pitch_cd;\n\n\t\t// Check if the direction is reversed\n\t\tif (angle_error_yaw_cd > 18000) {\n\t\t\tangle_error_yaw_cd = 36000 - angle_error_yaw_cd;\n\t\t}\n\t\tif (angle_error_yaw_cd < -18000) {\n\t\t\tangle_error_yaw_cd = -36000 - angle_error_yaw_cd;\n\t\t}\n\t\tif (angle_error_pitch_cd > 18000) {\n\t\t\tangle_error_pitch_cd = 36000 - angle_error_pitch_cd;\n\t\t}\n\t\tif (angle_error_pitch_cd < -18000) {\n\t\t\tangle_error_pitch_cd = -36000 - angle_error_pitch_cd;\n\t\t}\n\n\t\t// Convert the errors from earth frame to body frame\n\t\tangle_error_yaw_cd = -angle_error_yaw_cd;\n\t\tangle_error_pitch_cd = -angle_error_pitch_cd;\n\n\t\t// Update the pitch and yaw servos\n\t\tif", "CodeBleu_score": 22.813816587253605}, {"code": "void Mode::update_auto(void)\t// Get the current yaw and pitch angles in centidegrees\n\tint16_t yaw_cd = get_yaw_cd();\n\tint16_t pitch_cd = get_pitch_cd();\n\n\t// Get the current yaw and pitch angles in radians\n\tfloat yaw = (float)yaw_cd * (float)M_PI / 1800.0;\n\tfloat pitch = (float)pitch_cd * (float)M_PI / 1800.0;\n\n\t// Check if the direction is reversed\n\tbool yaw_reversed = yaw < 0;\n\tbool pitch_reversed = pitch < 0;\n\n\t// Compute the angle error\n\tfloat yaw_error = yaw - target_yaw;\n\tfloat pitch_error = pitch - target_pitch;\n\n\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n\tif (target_distance > 0 || min_distance == 0) {\n\t\t// Convert the errors from earth frame to body frame\n\t\tif (yaw_reversed) yaw_error = -yaw_error;\n\t\tif (pitch_reversed) pitch_error = -pitch_error;\n\n\t\t// Compute the angle error in centidegrees\n\t\tint16_t yaw_error_cd = (int16_t)(yaw_error * 1800.0 / M_PI);\n\t\tint16_t pitch_error_cd = (int16_t)(pitch_error * 1800.0 / M_PI);\n\n\t\t// Compute the yaw and pitch servos' speeds\n\t\tint16_t yaw_speed = (int16_t)(yaw_kp * yaw_error_cd + yaw_kd * (yaw_error_cd - prev_yaw_error_cd));\n\t\tint16_t pitch_speed = (int16_t)(pitch_kp * pitch_error_cd + pitch_kd * (pitch_error_cd - prev_pitch_error_cd));\n\n\t\t// Update the previous yaw and pitch errors\n\t\tprev_yaw_error_cd = yaw_error_cd;\n\t\tprev_pitch_error_cd = pitch_error_cd;\n\n\t\t// Update the yaw and pitch servos\n\t\tset", "CodeBleu_score": 26.82884808354623}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)\t// Check if the GPS has a fix\n\tif (GPS.status() >= 3) {\n\t\t// Check if the last message time has changed\n\t\tif (last_message_time!= GPS.last_message_time()) {\n\t\t\t// Update the last message time\n\t\t\tlast_message_time = GPS.last_message_time();\n\n\t\t\t// Check if the home location has been set\n\t\t\tif (home_location_set) {\n\t\t\t\t// Check if the home location has been set\n\t\t\t\tif (home_location_set) {\n\t\t\t\t\t// Check if the ground start countdown has reached one\n\t\t\t\t\tif (ground_start_countdown == 1) {\n\t\t\t\t\t\t// Check if the current location is valid\n\t\t\t\t\t\tif (current_location_valid) {\n\t\t\t\t\t\t\t// Set the home location\n\t\t\t\t\t\t\thome_location = current_location;\n\t\t\t\t\t\t\thome_location_set = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Reset the ground start countdown\n\t\t\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Increment the ground start countdown\n\t\t\t\t\t\tground_start_countdown++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Check if the current location is valid\n\t\t\t\tif (current_location_valid) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\thome_location = current_location;\n\t\t\t\t\thome_location_set = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Reset the ground start countdown\n\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Reset the ground start countdown\n\t\tground_start_countdown = 0;\n\t}\n}\n", "CodeBleu_score": 47.92885016002531}, {"code": "void Tracker::update_GPS(void)\t// Update the GPS data\n\tGPS.update();\n\n\t// Check if the last message time has changed\n\tif (last_message_time!= GPS.last_message_time) {\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (GPS.status() >= 3) {\n\t\t\t// If the GPS is at least 3D fix, reset the countdown\n\t\t\tcountdown_ground_start = 0;\n\t\t} else {\n\t\t\t// If the GPS is not at least 3D fix, increment the countdown\n\t\t\tcountdown_ground_start++;\n\t\t}\n\n\t\t// Update the last message time\n\t\tlast_message_time = GPS.last_message_time;\n\t}\n\n\t// If the countdown reaches one, set the home location\n\tif (countdown_ground_start == 1) {\n\t\t// Check if the GPS is at least 3D fix\n\t\tif (GPS.status() >= 3) {\n\t\t\t// Set the home location\n\t\t\thome_location = GPS.location();\n\n\t\t\t// Reset the countdown\n\t\t\tcountdown_ground_start = 0;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.625554472741584}, {"code": "void Tracker::update_GPS(void)\tif (GPS.newNMEAreceived()) {\n\t\tGPS.parse(GPS.lastNMEA());\n\t\tif (GPS.fixType > 1) {\n\t\t\tgps_fix_count++;\n\t\t}\n\t\tif (gps_fix_count > 1) {\n\t\t\tgps_fix_count = 0;\n\t\t\tgps_fix_timeout = 0;\n\t\t\tif (home_valid == 0) {\n\t\t\t\thome_valid = 1;\n\t\t\t\thome_lat = GPS.latitude;\n\t\t\t\thome_lon = GPS.longitude;\n\t\t\t\thome_alt = GPS.altitude;\n\t\t\t\thome_fix_timeout = 0;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = 10;\n\t\t\t\thome_fix_count = 0;\n\t\t\t\thome_fix_timeout = ", "CodeBleu_score": 36.510773006952405}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch < 0.0) {\n\t\tif (pitch_onoff_servo_count > 0) {\n\t\t\tpitch_onoff_servo_count = 0;\n\t\t\tdigitalWrite(PITCH_ONOFF_SERVO_PIN, LOW);\n\t\t}\n\t}\n\telse {\n\t\tif (pitch_onoff_servo_count < 100) {\n\t\t\tpitch_onoff_servo_count++;\n\t\t}\n\t\telse {\n\t\t\tpitch_onoff_servo_count = 0;\n\t\t\tdigitalWrite(PITCH_ONOFF_SERVO_PIN, HIGH);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 18.814442228485273}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch < 0.0) {\n\t\t// Set servo to 0 degrees\n\t\tpwmWrite(SERVO_PIN, 0);\n\t}\n\telse if (pitch > 0.0) {\n\t\t// Set servo to 180 degrees\n\t\tpwmWrite(SERVO_PIN, 500);\n\t}\n\telse {\n\t\t// Set servo to center\n\t\tpwmWrite(SERVO_PIN, 250);\n\t}\n}\n", "CodeBleu_score": 17.686835493590483}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch > 0.0) {\n\t\tif (pitch > 180.0) {\n\t\t\tpitch = 180.0;\n\t\t}\n\t\tif (pitch < 0.0) {\n\t\t\tpitch = 0.0;\n\t\t}\n\t\tmavlink_message_t msg;\n\t\tmavlink_msg_command_long_pack(\n\t\t\t1, 0,\n\t\t\tmavlink_system.sysid,\n\t\t\tmavlink_system.compid,\n\t\t\t&msg,\n\t\t\t1,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\tpitch,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t", "CodeBleu_score": 18.215522615266178}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\tbool result = AP_Arming::barometer_checks(display_failure);\n\tif (result) {\n\t\tif (g.baro_fail_alt_max > 0) {\n\t\t\tif (fabsf(g.baro_alt_relative - g.baro_alt_relative_prev) > g.baro_fail_alt_max) {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\tgcs_send_text_fmt(MAV_SEVERITY_WARNING, \"BARO: Barometer altitude %f exceeds limit of %f\", g.baro_alt_relative, g.baro_fail_alt_max);\n\t\t\t\t}\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 31.751431862893043}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\t// call base class method\n\tbool ret = AP_Arming_Checks::barometer_checks(display_failure);\n\tif (!ret) {\n\t\treturn false;\n\t}\n\t// check barometer reference\n\tif (g.baro_source!= ORB_SOURCE_EXTERNAL) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"No barometer detected\");\n\t\t}\n\t\treturn false;\n\t}\n\t// check barometer altitude\n\tfloat baro_alt_diff = g.baro_alt_filtered - g.baro_alt_filtered_last;\n\tif (fabsf(baro_alt_diff) > 0.1f) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Barometer altitude too far from inertial navigation\");\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 41.46729292448508}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)bool result = AP_Arming_Checks::barometer_checks(display_failure);", "CodeBleu_score": 9.082441358918306}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (_terrain_source == RangeFinder) {\n\t\treturn false;\n\t}\n\tif (_terrain_source == TerrainDatabase && _rtl_alt_type == RTL_ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 49.03339942873411}, {"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (_vehicle->rangefinder->get_terrain_source() == Rangefinder::Rangefinder_Source_Rangefinder) {\n\t\treturn false;\n\t} else if (_vehicle->rangefinder->get_terrain_source() == Rangefinder::Rangefinder_Source_Terrain_Database && _RTL_alt_type == RTL_ALT_TYPE_TERRAIN) {\n\t\treturn true;\n\t} else {\n\t\treturn AP_Arming::terrain_database_required();\n\t}\n}\n", "CodeBleu_score": 55.33313386143179}, {"code": "bool AP_Arming_Copter::terrain_database_required() const#if AP_TERRAIN_AVAILABLE\n    if (_terrain_source == RangeFinder) {\n        return false;\n    } else if (_terrain_source == TerrainDatabase && _rtl_altitude_type == RTL_Altitude::Terrain) {\n        return true;\n    } else {\n        return AP_Arming::terrain_database_required();\n    }", "CodeBleu_score": 50.22421179458417}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()\t// get the time for the next loop\n\tuint32_t now = micros();\n\tuint32_t dt = constrain_float(now - _last_loop_time, 500, 10000);\n\t_last_loop_time = now;\n\n\t// set the loop time for the controllers\n\t_attitude_control.set_loop_time_us(dt);\n\t_position_control.set_loop_time_us(dt);\n\t_motor_control.set_loop_time_us(dt);\n\n\t// run the rate controllers\n\t_attitude_control.rate_controller_run();\n}\n", "CodeBleu_score": 50.26851036364091}, {"code": "void Copter::run_rate_controller()\t// set the loop time for the controllers\n\t_loop_time = _scheduler->last_interval;\n\n\t// run the attitude controller\n\t_attitude_control->rate_controller_run();\n}\n", "CodeBleu_score": 16.614285777285566}, {"code": "void Copter::run_rate_controller()\t// get the last loop time from the scheduler\n\tfloat dt = _scheduler->get_dt();\n\n\t// set the loop time for attitude, position, and motor controllers\n\t_attitude_control->set_dt(dt);\n\t_position_control->set_dt(dt);\n\t_motor_control->set_dt(dt);\n\n\t// run the low-level rate controllers\n\t_attitude_control->rate_controller_run();\n}\n", "CodeBleu_score": 54.564353434143406}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.alt_frame == MAV_FRAME_GLOBAL_RELATIVE_ALT) {\n\t\tif (old_loc.alt!= new_loc.alt) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (old_loc.lat!= new_loc.lat || old_loc.lng!= new_loc.lng) {\n\t\ttarget_loc = new_loc;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 40.96822648864485}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.alt_frame == MAV_FRAME_GLOBAL_RELATIVE_ALT) {\n\t\tif (old_loc.alt!= new_loc.alt) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (old_loc.lat!= new_loc.lat || old_loc.lng!= new_loc.lng) {\n\t\ttarget_location = new_loc;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 41.258236649646065}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.alt_frame == MAV_FRAME_GLOBAL_RELATIVE_ALT) {\n\t\tif (old_loc.alt!= new_loc.alt) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng) {\n\t\treturn false;\n\t}\n\n\ttarget_loc = new_loc;\n\treturn true;\n}\n", "CodeBleu_score": 40.465138349241215}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)#if MAVLINK_NEED_BYTE_SWAP ||!MAVLINK_ALIGNED_FIELDS\n    mavlink_rc_channels_override_t packet;\n    packet.ch1_raw = ch1_raw;\n    packet.ch2_raw = ch2_raw;\n    packet.ch3_raw = ch3_raw;\n    packet.ch4_raw = ch4_raw;\n    packet.ch5_raw = ch5_raw;\n    packet.ch6_raw = ch6_raw;\n    packet.ch7_raw = ch7_raw;\n    packet.ch8_raw = ch8_raw;\n    packet.ch9_raw = ch9_raw;\n    packet.ch10_raw = ch10_raw;\n    packet.ch11_raw = ch11_raw;\n    packet.ch12_raw = ch12_raw;\n    packet.ch13_raw = ch13_raw;\n    packet.ch14_raw = ch14_raw;\n    packet.ch15_raw = ch15_raw;\n    packet.ch16_raw = ch16_raw;\n    packet.ch17_raw = ch17_raw;\n    packet.ch18_raw = ch18_raw;\n    packet.ch1_scaled = ch1_scaled;\n    packet.ch2_scaled = ch2_scaled;\n    packet.ch3_scaled = ch3_scaled;\n    packet.ch4_scaled = ch4_scaled;\n    packet.ch5_scaled = ch5_scaled;\n    packet.ch6_scaled = ch6_scaled;\n    packet.ch7_scaled = ch7_scaled;\n    packet.ch8_scaled = ch8_scaled;\n    packet.ch9_scaled = ch9_scaled;\n    packet.ch10_scaled = ch10_scaled;\n    packet.ch11_scaled = ch11_scaled;\n    packet.ch12_scaled = ch12_scaled;\n    packet.ch13_scaled = ch13_scaled;\n    packet.ch14_scaled = ch14_scaled;\n    packet.ch15_scaled = ch15_scaled;\n    packet.ch16_scaled = ch16_scaled;\n    packet.", "CodeBleu_score": 20.26837731476917}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (aux_switch_pos == ch_flag) {\n\t\tif (mode == get_mode()) {\n\t\t\trc().reset_mode_switch();\n\t\t} else {\n\t\t\tset_mode(mode);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.26649720915101}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)#ifdef AUX_FUNCTION\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        if (set_mode(mode)) {\n            // The mode was set successfully, so reset the mode switch\n            rc().reset_mode_switch();\n        }\n    } else {\n        if (get_mode() == mode) {\n            // The mode is already set, so reset the mode switch\n            rc().reset_mode_switch();\n        }\n    }", "CodeBleu_score": 61.503215398381684}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()\tfloat roll_trim_rad = 0.0f;\n\tfloat pitch_trim_rad = 0.0f;\n\n\t/*\n\t * Calculate the trim values from the control inputs of the roll and pitch channels.\n\t * The APM uses a mixer to map the control inputs to the roll and pitch outputs.\n\t * The roll and pitch trim values are in the range [-1, 1] and are converted to radians.\n\t */\n\troll_trim_rad = _rc_channels.control[roll_channel] * roll_trim_max;\n\tpitch_trim_rad = _rc_channels.control[pitch_channel] * pitch_trim_max;\n\n\t/*\n\t * Add the trim values to the AHRS trim.\n\t */\n\t_ahrs.set_trim(roll_trim_rad, pitch_trim_rad);\n\n\t/*\n\t * Log the event.\n\t */\n\tevents.log(\"TRIM: roll = %.2f, pitch = %.2f\", (double)roll_trim_rad, (double)pitch_trim_rad);\n\n\t/*\n\t * Send a confirmation message with MAV_SEVERITY_INFO.\n\t */\n\tsend_statustext_info(\"TRIM: roll = %.2f, pitch = %.2f\", (double)roll_trim_rad, (double)pitch_trim_rad);\n}\n", "CodeBleu_score": 41.18006318389503}, {"code": "void Copter::save_trim()\t// calculate trim\n\tfloat roll_trim_rad = radians(roll_trim_CH);\n\tfloat pitch_trim_rad = radians(pitch_trim_CH);\n\n\t// add trim to AHRS\n\tahrs.set_trim(roll_trim_rad, pitch_trim_rad);\n\n\t// log the event\n\tlog_message(\"TRIM: Roll %u, Pitch %u\", roll_trim_CH, pitch_trim_CH);\n\n\t// send a message back to the user\n\tmavlink_log_entry_t msg = {};\n\tmsg.time_boot_ms = get_system_time_us() / 1000;\n\tmsg.severity = MAV_SEVERITY_INFO;\n\tmsg.message = \"TRIM: Roll %u, Pitch %u\";\n\tmsg.param1 = roll_trim_CH;\n\tmsg.param2 = pitch_trim_CH;\n\tmsg.param3 = 0.0f;\n\tmsg.param4 = 0.0f;\n\tmsg.param5 = 0.0f;\n\tmsg.param6 = 0.0f;\n\tmsg.param7 = 0.0f;\n\tmavlink_msg_log_entry_send_struct(_mavlink->get_channel(), &msg);\n}\n", "CodeBleu_score": 40.797888839658484}, {"code": "void Copter::save_trim()\n#if CLI_ENABLED == ENABLED\n    if (gcs_send_message(MAV_SEVERITY_INFO, \"Saving trim values\")) {", "CodeBleu_score": 5.848158901210131}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()\t// Retrieve the copter's velocity\n\tfloat vel_x = m_vehicle->velocity_x();\n\tfloat vel_y = m_vehicle->velocity_y();\n\tfloat vel_z = m_vehicle->velocity_z();\n\n\t// Calculate the speed squared\n\tfloat speed_sq = vel_x*vel_x + vel_y*vel_y + vel_z*vel_z;\n\n\t// Check if the copter's position is valid and the speed exceeds a minimum threshold\n\tif (m_vehicle->position_valid() && speed_sq > 0.1f) {\n\t\t// Calculate the look-ahead yaw angle\n\t\tfloat yaw_angle = atan2(vel_y, vel_x);\n\n\t\t// Update the look-ahead yaw angle\n\t\tm_look_ahead_yaw = yaw_angle;\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn m_look_ahead_yaw;\n}\n", "CodeBleu_score": 44.46685544638792}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\t// Get the current velocity vector\n\tVector3f vel = _vehicle->velocity();\n\n\t// Get the speed squared\n\tfloat speed_sq = vel.x * vel.x + vel.y * vel.y;\n\n\t// Check if the vehicle is airborne\n\tbool is_airborne = _vehicle->is_airborne();\n\n\t// Check if the vehicle is airborne and the speed is above the minimum threshold\n\tif (is_airborne && speed_sq > MIN_SPEED_SQ) {\n\t\t// Calculate the look-ahead yaw angle\n\t\tfloat yaw = atan2f(vel.y, vel.x);\n\n\t\t// Update the look-ahead yaw angle\n\t\t_look_ahead_yaw = yaw;\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}\n", "CodeBleu_score": 51.22636760718715}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\t// Get the current velocity.\n\tfloat vx = vehicle->velocity.x;\n\tfloat vy = vehicle->velocity.y;\n\tfloat vz = vehicle->velocity.z;\n\t// Calculate the speed squared.\n\tfloat speed_squared = vx * vx + vy * vy + vz * vz;\n\t// If the vehicle's position is valid and the speed is greater than the minimum threshold, compute the look-ahead yaw angle.\n\tif (vehicle->position_valid && speed_squared > MIN_SPEED_SQUARED) {\n\t\t// Compute the look-ahead yaw angle.\n\t\tfloat yaw = atan2f(vy, vx);\n\t\t// Return the look-ahead yaw angle.\n\t\treturn yaw;\n\t}\n\t// Otherwise, return the current yaw angle.\n\treturn vehicle->attitude.yaw;\n}\n", "CodeBleu_score": 42.74653303370405}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (method == AP_Arming::RUDDER && _rudder_disarmed) {\n\t\treturn false;\n\t}\n\tif (method == AP_Arming::THROTTLE && _throttle_zero) {\n\t\treturn false;\n\t}\n\tif (method == AP_Arming::WATCHDOG) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 34.77964901887607}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)#if defined(DISABLE_ARMING_CHECKS) || defined(DISABLE_WATCHDOG)\n    return true;", "CodeBleu_score": 4.4584170374088465}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // in SITL mode, always arm\n    return true;", "CodeBleu_score": 4.45752004377383}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\t// check if already armed\n\tif (armed) {\n\t\treturn true;\n\t}\n\n\t// check if we are arming in the disarmed state\n\tif (current_arming_state == AP_Arming::DISARMED) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the pre-arm state\n\tif (current_arming_state == AP_Arming::PRE_ARM) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the armed state\n\tif (current_arming_state == AP_Arming::ARMED) {\n\t\treturn true;\n\t}\n\n\t// check if we are arming in the armed_error state\n\tif (current_arming_state == AP_Arming::ARMED_ERROR) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the in_air state\n\tif (current_arming_state == AP_Arming::IN_AIR) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the in_air_error state\n\tif (current_arming_state == AP_Arming::IN_AIR_ERROR) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the in_air_landed state\n\tif (current_arming_state == AP_Arming::IN_AIR_LANDED) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the in_air_landed_error state\n\tif (current_arming_state == AP_Arming::IN_AIR_LANDED_ERROR) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the takeoff state\n\tif (current_arming_state == AP_Arming::TAKEOFF) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the takeoff_error state\n\tif (current_arming_state == AP_Arming::TAKEOFF_ERROR) {\n\t\treturn false;\n\t}\n\n\t// check if we are arming in the RTL state\n\tif (current_arming_state == AP_Ar", "CodeBleu_score": 21.597846627158102}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\t// check if we are already armed\n\tif (_armed) {\n\t\treturn true;\n\t}\n\t// check if arming checks are required\n\tif (do_arming_checks) {\n\t\t// check if we are in a mode that requires arming checks\n\t\tif (check_mode_requires_arming_checks()) {\n\t\t\t// check if we are in a mode that requires a valid home location\n\t\t\tif (check_mode_requires_valid_home_location()) {\n\t\t\t\t// check if we have a valid home location\n\t\t\t\tif (!check_valid_home_location()) {\n\t\t\t\t\t// home location is invalid\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check if we are in a mode that requires a valid home location\n\t\t\tif (check_mode_requires_valid_region_of_interest()) {\n\t\t\t\t// check if we have a valid region of interest\n\t\t\t\tif (!check_valid_region_of_interest()) {\n\t\t\t\t\t// region of interest is invalid\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// set the arming method\n\t_arming_method = method;\n\t// set the arming state\n\t_armed = true;\n\t// update the home location\n\tupdate_home_location();\n\t// set the home location in the AHRS system\n\tahrs.set_home_location(home_location);\n\t// update the current location\n\tupdate_current_location();\n\t// set the current location in the AHRS system\n\tahrs.set_current_location(current_location);\n\t// set the arming delay\n\t_arming_delay = millis() + AP_ARMING_DELAY_MS;\n\t// send a status message\n\tsend_status_text(MAV_SEVERITY_INFO, PSTR(\"Arming %s\"), AP_Arming::method_str(_arming_method));\n\t// return success\n\treturn true;\n}\n", "CodeBleu_score": 46.228039075198204}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)#if CONFIG_HAL_BOARD == HAL_BOARD_APM1\n    // check for valid method\n    if(method < 0 || method >= AP_Arming::NUM_METHODS) {\n        return false;\n    }", "CodeBleu_score": 15.078596754075468}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\tif (g.armed) {\n\t\treturn true;\n\t}\n\n\tif (g.rc_override.override!= AP_HAL::RC_OVERRIDE_DISARM) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Pre-arm checks failed: RC override is %d\", g.rc_override.override);\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 57.86313981490938}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\tif (g.armed) {\n\t\treturn true;\n\t}\n\tif (!g.disarm_pin.configured()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(MAV_SEVERITY_ERROR, PSTR(\"Disarming not available\"));\n\t\t}\n\t\treturn false;\n\t}\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 61.49044088049467}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\t// disarm button not configured, display failure message if requested and return\n\tif (!g.disarm_enabled) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_fmt(MAV_SEVERITY_CRITICAL, PSTR(\"Disarm button not configured\"));\n\t\t}\n\t\treturn false;\n\t}\n\t// perform standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 54.92665344520209}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat ne_x = cos(yaw) * x - sin(yaw) * y;\n\tfloat ne_y = sin(yaw) * x + cos(yaw) * y;\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 51.18080852379469}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat temp_x = x;\n\tfloat temp_y = y;\n\tx = temp_x * cos(yaw) - temp_y * sin(yaw);\n\ty = temp_x * sin(yaw) + temp_y * cos(yaw);\n}\n", "CodeBleu_score": 33.83685741209336}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat ne_x = x * cos(yaw) - y * sin(yaw);\n\tfloat ne_y = x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 52.14690752355977}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// Check if the yaw angle and param4 values are within acceptable ranges.\n\tif (packet.param4 < -PI || packet.param4 > PI) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\t// Set the yaw heading using the provided parameters.\n\tyaw_heading_ = packet.param1;\n\tyaw_mode_ = packet.param2;\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 47.177114438896176}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\tif(packet.param1 < 0.0 || packet.param1 > 360.0 || packet.param4 < -90.0 || packet.param4 > 90.0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\telse {\n\t\t// Set yaw using provided parameters\n\t\t_vehicle->set_yaw_heading(packet.param1, packet.param4);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n}\n", "CodeBleu_score": 42.1044077744689}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\tif (!is_condition_yaw_valid(packet.param1, packet.param2, packet.param3, packet.param4)) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tset_condition_yaw(packet.param1, packet.param2, packet.param3, packet.param4);\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 47.151432627460125}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\tif (control_mode == AUTO || control_mode == GUIDED) {\n\t\treturn (uint8_t) (waypoint_bearing / 2);\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 35.40851880327228}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn (uint8_t) (get_uint16_t_field(11) / 2);\n}\n", "CodeBleu_score": 6.122082202065965}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn _high_latency_tgt_heading;\n}\n", "CodeBleu_score": 5.801350011259761}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.timestamp = millis();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\twrite_log_packet(packet);\n\t}\n}\n", "CodeBleu_score": 36.24148286380685}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (log_enabled) {\n\t\tLogPacket packet = {\n\t\t\t.timestamp = millis(),\n\t\t\t.id = id,\n\t\t\t.data.int32 = value\n\t\t};\n\t\tlog_writer.write_critical_block(&packet, sizeof(packet));\n\t}\n}\n", "CodeBleu_score": 40.34367075261069}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (!Logging_Enabled) {\n\t\treturn;\n\t}\n\tLogPacket packet;\n\tpacket.time = HAL_GetTick();\n\tpacket.id = id;\n\tpacket.data.int32 = value;\n\tLogger::Write_Critical_Block(packet);\n}\n", "CodeBleu_score": 35.76080461958576}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()\tif (home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome_loc = get_position();\n\t\treturn;\n\t}\n\n\tVector3f ekf_loc = get_position_EKF();\n\tif (ekf_loc.get_length() > 0.0f) {\n\t\thome_is_set = true;\n\t\thome_loc = ekf_loc;\n\t\treturn;\n\t}\n}\n", "CodeBleu_score": 22.946136721019943}, {"code": "void Sub::update_home_from_EKF()\tif (home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors_armed) {\n\t\tset_home_position(get_EKF_position());\n\t} else {\n\t\tVector3f ekf_position = get_EKF_position();\n\t\tif (set_home_position(ekf_position)) {\n\t\t\thome_is_set = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 23.318165734164182}, {"code": "void Sub::update_home_from_EKF()\tif (_home_is_set) {\n\t\treturn;\n\t}\n\n\tif (_armed) {\n\t\t_home_is_set = _ekf.update_home();\n\n\t} else {\n\t\t_home_is_set = _ekf.get_position_error_integral() < _params.home_position_error_threshold;\n\t}\n}\n", "CodeBleu_score": 23.80275766046332}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()\t// If the motors are not armed, set the throttle to zero, adjust the spool state, and exit.\n\tif (!motorsArmed) {\n\t\tmotors.setThrottle(0);\n\t\tspool.adjust();\n\t\treturn;\n\t}\n\t// If the motors are armed, set the spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run the attitude controller with these rates.\n\tspool.set(Spool::State::UNLIMITED_THROTTLE);\n\tVector3D bodyRates;\n\tbodyRates.x = pilot.roll * ACRO_ROLL_RATE_GAIN;\n\tbodyRates.y = pilot.pitch * ACRO_PITCH_RATE_GAIN;\n\tbodyRates.z = pilot.throttle * ACRO_THROTTLE_RATE_GAIN;\n\tattitudeController.run(bodyRates);\n\t// Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\tmotors.setThrottle(pilot.throttle * ACRO_THROTTLE_GAIN);\n\tmotors.setMotor(Motors::Motor::LEFT, pilot.roll * ACRO_ROLL_GAIN);\n\tmotors.setMotor(Motors::Motor::RIGHT, -pilot.roll * ACRO_ROLL_GAIN);\n\tmotors.setMotor(Motors::Motor::FRONT, pilot.pitch * ACRO_PITCH_GAIN);\n\tmotors.setMotor(Motors::Motor::BACK, -pilot.pitch * ACRO_PITCH_GAIN);\n}\n", "CodeBleu_score": 46.17677754578149}, {"code": "void ModeAcro::run()\t// If the motors are not armed, stop the motors and exit.\n\tif (!motorsArmed) {\n\t\tthrottle = 0;\n\t\tspoolState = SPOOL_STATE_IDLE;\n\t\tattitudeController.relax();\n\t\treturn;\n\t}\n\n\t// If the spool state is not idle, run the spool controller.\n\tif (spoolState!= SPOOL_STATE_IDLE) {\n\t\tspoolController.run();\n\t}\n\n\t// Convert pilot inputs to desired body frame rates.\n\tdesiredRates.roll = pilotInput.roll;\n\tdesiredRates.pitch = pilotInput.pitch;\n\tdesiredRates.yaw = pilotInput.yaw;\n\tdesiredRates.thrust = pilotInput.throttle;\n\n\t// Run the attitude controller with the desired body frame rates.\n\tattitudeController.run(desiredRates);\n\n\t// Set the forward and lateral motor inputs based on pilot controls.\n\tmotors.setMotor1(-desiredRates.thrust + desiredRates.roll + desiredRates.pitch - desiredRates.yaw);\n\tmotors.setMotor2(-desiredRates.thrust - desiredRates.roll + desiredRates.pitch + desiredRates.yaw);\n\tmotors.setMotor3(-desiredRates.thrust - desiredRates.roll - desiredRates.pitch + desiredRates.yaw);\n\tmotors.setMotor4(-desiredRates.thrust + desiredRates.roll - desiredRates.pitch - desiredRates.yaw);\n}\n", "CodeBleu_score": 38.88167745584797}, {"code": "void ModeAcro::run()\t// If the motors are not armed, set throttle to zero, adjust spool state, and exit.\n\tif (!motorsArmed) {\n\t\tsetMotors(0.0f, 0.0f, 0.0f, 0.0f);\n\t\tspool.adjust();\n\t\treturn;\n\t}\n\n\t// If armed, set spool state to unlimited throttle and convert pilot inputs to desired body frame rates.\n\tspool.setThrottle(1.0f);\n\tfloat rollDesired = pilot.roll();\n\tfloat pitchDesired = pilot.pitch();\n\tfloat yawDesired = pilot.yaw();\n\tfloat rollRateDesired = pilot.rollRate();\n\tfloat pitchRateDesired = pilot.pitchRate();\n\tfloat yawRateDesired = pilot.yawRate();\n\n\t// Run the attitude controller with the desired body frame rates.\n\tfloat rollRate, pitchRate, yawRate;\n\tattitudeController.run(rollDesired, pitchDesired, yawDesired, rollRateDesired, pitchRateDesired, yawRateDesired, rollRate, pitchRate, yawRate);\n\n\t// Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\tfloat throttle = pilot.throttle();\n\tsetMotors(throttle, rollRate, pitchRate, yawRate);\n}\n", "CodeBleu_score": 38.75918798194026}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()\t// set mode\n\tmode = GUIDED_POS_CONTROL;\n\t// set waypoint controller\n\twaypoint_controller.set_destination(waypoint_controller.get_stopping_point());\n\t// set auto yaw mode\n\tauto_yaw_mode = DEFAULT_AUTO_YAW_MODE;\n}\n", "CodeBleu_score": 20.48119061993121}, {"code": "void ModeGuided::guided_pos_control_start()\t// Set mode to position control\n\tmode = MODE_POS_CONTROL;\n\n\t// Initialize waypoint controller\n\twaypoint_controller.init(pos_setpoint_global, pos_setpoint_local, vel_setpoint, yaw_setpoint);\n\n\t// Get the stopping point\n\tVector3f stopping_point = get_stopping_point();\n\n\t// Set the stopping point as the waypoint destination\n\twaypoint_controller.set_destination(stopping_point);\n\n\t// Initialize yaw using the default auto yaw mode\n\tauto_yaw_controller.init(pos_setpoint_global, pos_setpoint_local, vel_setpoint, yaw_setpoint);\n}\n", "CodeBleu_score": 31.83242519559505}, {"code": "void ModeGuided::guided_pos_control_start()\t// set position control mode\n\t_pos_control.set_mode(POSCTL);\n\t// set the position setpoint\n\t_pos_control.set_pos_setpoint(_guided_pos_sp);\n\t// initialize yaw setpoint to current yaw\n\t_pos_control.initialize_yaw_setpoint_from_current_position();\n\t// set yaw control mode\n\t_pos_control.set_yaw_control_mode(YAW_CONTROL_MODE_AUTO);\n\t// set yaw setpoint to current yaw\n\t_pos_control.update_yaw_setpoint_from_current_position();\n\t// set the yaw setpoint to the current yaw\n\t_pos_control.set_yaw_setpoint_deg(_pos_control.get_yaw_setpoint_deg());\n\t// set the yaw setpoint to the current yaw\n\t_pos_control.set_yaw_setpoint_rad(_pos_control.get_yaw_setpoint_rad());\n\t// set the yaw setpoint to the current yaw\n\t_pos_control.set_yaw_setpoint_body(_pos_control.get_yaw_setpoint_body());\n\t// set the yaw setpoint to the current yaw\n\t_pos_control.set_yaw_setpoint_rad_from_body(_pos_control.get_yaw_setpoint_rad_from_body());\n\t// set the yaw setpoint to the current yaw\n\t_pos_control.set_yaw_setpoint_body_from_rad(_pos_control.get_yaw_setpoint_body_from_rad());\n\t// set the yaw setpoint to the current yaw\n\t_pos_control.set_yaw_setpoint_deg_from_body(_pos_control.get_yaw_setpoint_deg_from_body());\n\t// set the yaw setpoint to the current yaw\n\t_pos_control.set_yaw_setpoint_body_from_deg(_pos_control.get_yaw_setpoint_body_from_deg());\n\t// set the yaw setpoint to the current yaw\n\t_pos_control.set_yaw_setpoint_rad_from_deg(_pos_control.get_yaw_setpoint_rad_from_deg());\n\t// set", "CodeBleu_score": 22.664635818015235}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()\t// Set the vertical maximum speeds and accelerations\n\t_vel_control.set_max_vertical_speed(param.get_param_float(ParamFloat::GuidedVelControlMaxVerticalSpeed));\n\t_vel_control.set_max_vertical_acceleration(param.get_param_float(ParamFloat::GuidedVelControlMaxVerticalAcceleration));\n\t_vel_control.set_max_horizontal_speed(param.get_param_float(ParamFloat::GuidedVelControlMaxHorizontalSpeed));\n\t_vel_control.set_max_horizontal_acceleration(param.get_param_float(ParamFloat::GuidedVelControlMaxHorizontalAcceleration));\n\n\t// Initialize the vertical and horizontal velocity controllers\n\t_vel_control.initialize_velocity_controllers();\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\t_vel_control.set_yaw_control_mode(VelocityControl::AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 37.29728917358632}, {"code": "void ModeGuided::guided_vel_control_start()\t// Set the vertical and horizontal velocity limits\n\t_vel_control.set_vel_limit(_vel_max_up, _vel_max_down, _vel_max_north, _vel_max_east, _vel_max_yaw);\n\n\t// Initialize the velocity controllers\n\t_vel_control.init_velocity_control();\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\t_control_mode.set_yaw_control_mode(AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 25.747788652140596}, {"code": "void ModeGuided::guided_vel_control_start()\t// Set pilot-defined maximum speeds and accelerations\n\t_max_h_vel = _pilot->get_max_h_speed();\n\t_max_v_vel = _pilot->get_max_v_speed();\n\t_max_h_accel = _pilot->get_max_h_accel();\n\t_max_v_accel = _pilot->get_max_v_accel();\n\t_max_yaw_rate = _pilot->get_max_yaw_rate();\n\n\t// Initialize the velocity controllers\n\t_vel_control.initialize(_max_h_vel, _max_v_vel, _max_h_accel, _max_v_accel, _max_yaw_rate);\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\t_control_mode = AUTO_YAW_HOLD;\n}\n", "CodeBleu_score": 40.817072490504394}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()\tif (time_since_last_heartbeat > 10000) {\n\t\treturn true;\n\t}\n\tif (current_position.alt < 10) {\n\t\treturn true;\n\t}\n\tif (current_position.alt > 300) {\n\t\treturn true;\n\t}\n\tif (distance_to_target > 1000) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 20.864689021109413}, {"code": "bool ModeGuided::guided_limit_check()\t// Check if the current altitude is below the minimum threshold\n\tif (current_altitude < minimum_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is above the maximum threshold\n\tif (current_altitude > maximum_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the limit\n\tif (horizontal_distance_moved > horizontal_distance_limit) {\n\t\treturn true;\n\t}\n\n\t// Check if the timeout has been exceeded\n\tif (time_since_last_update > timeout) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}\n", "CodeBleu_score": 19.25751367529821}, {"code": "bool ModeGuided::guided_limit_check()\t// Check if the timeout has been exceeded\n\tif (millis() - _start_time > _timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if the altitude is below the minimum\n\tif (fabs(_pos.alt) < _min_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if the altitude is above the maximum\n\tif (fabs(_pos.alt) > _max_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the limit\n\tif (fabs(_pos.distance_to(_target)) > _max_distance) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 29.351940021144333}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()\t// Check if the motor test has passed\n\tif (pass) {\n\t\t// Check if the motor test has timed out\n\t\tif (timeout) {\n\t\t\t// Send a timeout message\n\t\t\tsend_timeout_message();\n\t\t\t// Set the pass flag to false\n\t\t\tpass = false;\n\t\t\t// Disable the motor test\n\t\t\tdisable_motor_test();\n\t\t\t// Disarm the system\n\t\t\tdisarm_system();\n\t\t\t// Record the failure time\n\t\t\tfailure_time = current_time;\n\t\t\t// Return false\n\t\t\treturn false;\n\t\t}\n\t\t// Check if the test has passed\n\t\telse if (current_time - start_time >= 2.0) {\n\t\t\t// Return true\n\t\t\treturn true;\n\t\t}\n\t}\n\t// Return false\n\treturn false;\n}\n", "CodeBleu_score": 29.316226922539446}, {"code": "bool Sub::verify_motor_test()\t// Verify that the test has been enabled\n\tif (test_enabled) {\n\t\t// Verify that the test has been armed\n\t\tif (test_armed) {\n\t\t\t// Verify that the test has not timed out\n\t\t\tif (test_timeout == false) {\n\t\t\t\t// Verify that the test has been completed\n\t\t\t\tif (test_completed) {\n\t\t\t\t\t// Verify that the test passed\n\t\t\t\t\tif (test_pass) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Record the failure time\n\t\t\t\t\t\ttest_failure_time = millis();\n\t\t\t\t\t\t// Disarm the test\n\t\t\t\t\t\ttest_armed = false;\n\t\t\t\t\t\t// Disable the test\n\t\t\t\t\t\ttest_enabled = false;\n\t\t\t\t\t\t// Set the pass flag to false\n\t\t\t\t\t\ttest_pass = false;\n\t\t\t\t\t\t// Send a timeout message\n\t\t\t\t\t\tsend_timeout_message(TIMEOUT_MOTOR_TEST);\n\t\t\t\t\t\t// Return false\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Return false\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Record the failure time\n\t\t\t\ttest_failure_time = millis();\n\t\t\t\t// Disarm the test\n\t\t\t\ttest_armed = false;\n\t\t\t\t// Disable the test\n\t\t\t\ttest_enabled = false;\n\t\t\t\t// Set the pass flag to false\n\t\t\t\ttest_pass = false;\n\t\t\t\t// Send a timeout message\n\t\t\t\tsend_timeout_message(TIMEOUT_MOTOR_TEST);\n\t\t\t\t// Return false\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Return false\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\t// Return false\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 40.60237100933161}, {"code": "bool Sub::verify_motor_test()\tif(test_timeout_timer.Read() >= 1.0) {\n\t\tROS_ERROR(\"Motor test timed out\");\n\t\tsend_timeout_message();\n\t\tpass = false;\n\t\tdisable_motor_test();\n\t\tdisarm_system();\n\t\tfailure_time = time(NULL);\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 18.870809879828975}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target = get_param_float(Param_WPNAV_ROLL);\n\tfloat pitch_target = get_param_float(Param_WPNAV_PITCH);\n\n\t// constrain roll and pitch within specified range\n\troll_target = constrain_float(roll_target, -WPNAV_MAX_ANGLE_CD, WPNAV_MAX_ANGLE_CD);\n\tpitch_target = constrain_float(pitch_target, -WPNAV_MAX_ANGLE_CD, WPNAV_MAX_ANGLE_CD);\n\n\t// normalize roll and pitch targets\n\troll_target = (roll_target + WPNAV_MAX_ANGLE_CD) / (2 * WPNAV_MAX_ANGLE_CD);\n\tpitch_target = (pitch_target + WPNAV_MAX_ANGLE_CD) / (2 * WPNAV_MAX_ANGLE_CD);\n\n\t// assign normalized values to outputs\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}\n", "CodeBleu_score": 34.64588435333689}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\t// Get roll and pitch from wp_nav\n\tfloat roll_in = wp_nav.roll_cd;\n\tfloat pitch_in = wp_nav.pitch_cd;\n\n\t// Constrain roll and pitch within specified maximum angle range\n\tfloat roll_max = 2000.0f; // 20.0 degrees\n\tfloat pitch_max = 2000.0f; // 20.0 degrees\n\tfloat roll_min = -roll_max;\n\tfloat pitch_min = -pitch_max;\n\troll_in = constrain_float(roll_in, roll_min, roll_max);\n\tpitch_in = constrain_float(pitch_in, pitch_min, pitch_max);\n\n\t// Normalize roll and pitch\n\tfloat roll_norm = (roll_in - roll_min) / (roll_max - roll_min);\n\tfloat pitch_norm = (pitch_in - pitch_min) / (pitch_max - pitch_min);\n\n\t// Assign normalized roll and pitch to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}\n", "CodeBleu_score": 38.58260228553627}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\t// Retrieve roll and pitch targets from wp_nav in centidegrees.\n\tfloat roll_target_cd = wp_nav.roll_cd;\n\tfloat pitch_target_cd = wp_nav.pitch_cd;\n\n\t// Constrain roll and pitch targets within a specified maximum angle range.\n\tif (roll_target_cd > max_roll_cd) {\n\t\troll_target_cd = max_roll_cd;\n\t} else if (roll_target_cd < -max_roll_cd) {\n\t\troll_target_cd = -max_roll_cd;\n\t}\n\n\tif (pitch_target_cd > max_pitch_cd) {\n\t\tpitch_target_cd = max_pitch_cd;\n\t} else if (pitch_target_cd < -max_pitch_cd) {\n\t\tpitch_target_cd = -max_pitch_cd;\n\t}\n\n\t// Normalize roll and pitch targets.\n\tfloat roll_target = roll_target_cd / 100.0f;\n\tfloat pitch_target = pitch_target_cd / 100.0f;\n\n\t// Assign normalized values to lateral_out and forward_out.\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}\n", "CodeBleu_score": 36.64805727895696}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()\tif (this->barometer.calibrated) {\n\t\tthis->barometer.calibrated = false;\n\t\tthis->barometer.altitude_comp = 0;\n\t\tthis->barometer.altitude_comp_last = 0;\n\t\tthis->barometer.altitude_comp_sum = 0;\n\t\tthis->barometer.altitude_comp_sum_last = 0;\n\t\tthis->barometer.altitude_comp_sum_count = 0;\n\t\tthis->barometer.altitude_comp_sum_max = 0;\n\t\tthis->barometer.altitude_comp_sum_min = 0;\n\t\tthis->barometer.altitude_comp_sum_max_count = 0;\n\t\tthis->barometer.altitude_comp_sum_min_count = 0;\n\t\tthis->barometer.altitude_comp_sum_max_sum = 0;\n\t\tthis->barometer.altitude_comp_sum_min_sum = 0;\n\t\tthis->barometer.altitude_comp_sum_max_sum_count = 0;\n\t\tthis->barometer.altitude_comp_sum_min_sum_count = 0;\n\t\tthis->barometer.altitude_comp_sum_max_sum_sum = 0;\n\t\tthis->barometer.altitude_comp_sum_min_sum_sum = 0;\n\t\tthis->barometer.altitude_comp_sum_max_sum_sum_count = 0;\n\t\tthis->barometer.altitude_comp_sum_min_sum_sum_count = 0;\n\t\tthis->barometer.altitude_comp_sum_max_sum_sum_sum = 0;\n\t\tthis->barometer.altitude_comp_sum_min_sum_sum_sum = 0;\n\t\tthis->barometer.altitude_comp_sum_max_sum_sum_sum_count = 0;\n\t\tthis->barometer.altitude_comp_sum_min_sum_sum_sum_count = 0;\n\t\tthis->barometer.altitude_comp_sum_max_sum_sum_sum_sum = 0;\n\t\tthis->barometer.altitude_comp_sum_min_sum_sum_sum_sum = 0;", "CodeBleu_score": 5.24132728957571}, {"code": "void Sub::read_barometer()\tif (baro_data.altitude > 0.0f) {\n\t\tbaro_data.pressure_cal = baro_data.pressure / powf(1.0f - (baro_data.altitude / 44330.0f), 5.255f);\n\t}\n\n\tif (baro_sensor!= nullptr) {\n\t\tif (baro_data.health > 0) {\n\t\t\tbaro_sensor->set_health_status(baro_data.health);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.23504301316532}, {"code": "void Sub::read_barometer()\t// Update the barometer data\n\tbarometer.update();\n\n\t// Check if the altitude is above zero\n\tif (altitude > 0.0f) {\n\t\t// Update the barometer calibration\n\t\tbarometer_calibration.update(barometer.get_pressure(), barometer.get_temperature(), altitude);\n\t}\n\n\t// Update the sensor health status\n\tif (barometer.is_healthy()) {\n\t\tsensor_health.set_barometer_healthy();\n\t}\n}\n", "CodeBleu_score": 53.23750287202428}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()\tif (!inertial_nav_available) {\n\t\treturn false;\n\t}\n\tif (armed) {\n\t\tif (!position_ok()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (in_constant_position_mode()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 12.832876236930197}, {"code": "bool Sub::ekf_position_ok()\tif (!status.in_air) {\n\t\treturn true;\n\t}\n\tif (status.armed) {\n\t\tif (status.ekf_pos_ok) {\n\t\t\treturn true;\n\t\t}\n\t\tif (status.control_mode == MAV_MODE_GUIDED_ARMED || status.control_mode == MAV_MODE_AUTO_ARMED) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 43.52678163275521}, {"code": "bool Sub::ekf_position_ok()\tif (!inertial_nav_available) {\n\t\treturn false;\n\t}\n\tif (armed) {\n\t\tif (ekf_pos_ok) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 10.858819505690349}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tif (get_control_mode() == STABILIZE) {\n\t\treturn true;\n\t}\n\n\tif (!AP_Arming_Checks::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs.is_ready()) {\n\t\tif (display_failure) {\n\t\t\tprint_name();\n\t\t\tprintf(\"GPS: AHRS not ready\\n\");\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (ekf.using_gps()) {\n\t\tif (ekf.get_ekf_health()!= AP_InertialSensor::EKF_OK) {\n\t\t\tif (display_failure) {\n\t\t\t\tprint_name();\n\t\t\t\tprintf(\"GPS: EKF failsafe active\\n\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!ahrs.position_valid()) {\n\t\tif (display_failure) {\n\t\t\tprint_name();\n\t\t\tprintf(\"GPS: position estimate invalid\\n\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 48.08402367112164}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tif (Arming::gps_checks(display_failure) == false) {\n\t\treturn false;\n\t}\n\tif (ahrs.get_status()!= AP_AHRS::STATUS_OK) {\n\t\tif (display_failure) {\n\t\t\tArming::print_name();\n\t\t\tSerial.println_P(PSTR(\" AHRS not ready\"));\n\t\t}\n\t\treturn false;\n\t}\n\tif (ekf.check_failsafe() == false) {\n\t\tif (display_failure) {\n\t\t\tArming::print_name();\n\t\t\tSerial.println_P(PSTR(\" EKF failsafe active\"));\n\t\t}\n\t\treturn false;\n\t}\n\tif (ahrs.is_gps_good() == false) {\n\t\tif (display_failure) {\n\t\t\tArming::print_name();\n\t\t\tSerial.println_P(PSTR(\" GPS not locked\"));\n\t\t}\n\t\treturn false;\n\t}\n\tif (ahrs.get_ekf_ok() == false) {\n\t\tif (display_failure) {\n\t\t\tArming::print_name();\n\t\t\tSerial.println_P(PSTR(\" EKF not OK\"));\n\t\t}\n\t\treturn false;\n\t}\n\tif (ahrs.get_position_valid() == false) {\n\t\tif (display_failure) {\n\t\t\tArming::print_name();\n\t\t\tSerial.println_P(PSTR(\" Position estimate invalid\"));\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 49.281405401351094}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tif (!gps_ok()) {\n\t\tif (display_failure) {\n\t\t\tprint_no_gps();\n\t\t}\n\t\treturn false;\n\t}\n\tif (!ahrs.is_ready()) {\n\t\tif (display_failure) {\n\t\t\tprint_ahrs_fail();\n\t\t}\n\t\treturn false;\n\t}\n\tif (!ekf.using_gps()) {\n\t\tif (display_failure) {\n\t\t\tprint_no_gps();\n\t\t}\n\t\treturn false;\n\t}\n\tif (!ekf.in_position_mode()) {\n\t\tif (display_failure) {\n\t\t\tprint_no_gps();\n\t\t}\n\t\treturn false;\n\t}\n\tif (!ekf.is_gps_good()) {\n\t\tif (display_failure) {\n\t\t\tprint_no_gps();\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 31.783482005939057}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)#if CONFIG_HAL_BOARD == HAL_BOARD_PX4\n    if (do_arming_checks) {\n        // check that the rover is on the ground\n        if (!check_ground()) {\n            return false;\n        }\n    }", "CodeBleu_score": 18.103626807226405}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\t// if we are already armed, do nothing\n\tif (armed) {\n\t\treturn true;\n\t}\n\n\t// if we are already in the process of arming, do nothing\n\tif (arming) {\n\t\treturn true;\n\t}\n\n\t// set arming flag\n\tarming = true;\n\n\t// set arming method\n\tarming_method = method;\n\n\t// set arming_failed flag\n\tarming_failed = false;\n\n\t// arm the vehicle\n\tswitch (method) {\n\t\tcase AP_Arming::Method::ALWAYS:\n\t\t\tarm_always();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::RTL:\n\t\t\tarm_rtl();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::GUIDED:\n\t\t\tarm_guided();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::LOITER:\n\t\t\tarm_loiter();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::LAND:\n\t\t\tarm_land();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::RTL_LAND:\n\t\t\tarm_rtl_land();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::POSHOLD:\n\t\t\tarm_poshold();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::STABILIZE:\n\t\t\tarm_stabilize();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::AUTO:\n\t\t\tarm_auto();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::MANUAL:\n\t\t\tarm_manual();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::INITIAL_STABILIZE:\n\t\t\tarm_initial_stabilize();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::GPS_HOLD:\n\t\t\tarm_gps_hold();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::FAILSAFE:\n\t\t\tarm_failsafe();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::OF_LOITER:\n\t\t\tarm_of_loiter();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::OF_RTL:\n\t\t\tarm_of_rtl();\n\t\t\tbreak;\n\n\t\tcase AP_Arming::Method::OF_LAND:\n\t\t\tarm_of", "CodeBleu_score": 24.586097327985645}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\t// if armed, disarm first\n\tif (armed()) {\n\t\tdisarm();\n\t}\n\n\t// perform arming checks\n\tif (do_arming_checks) {\n\t\tif (!arming_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// arm\n\tswitch (method) {\n\t\tcase AP_Arming::DISARMED:\n\t\t\tset_armed(false);\n\t\t\tbreak;\n\n\t\tcase AP_Arming::ALWAYS:\n\t\t\tset_armed(true);\n\t\t\tbreak;\n\n\t\tcase AP_Arming::ALWAYS_FAIL:\n\t\t\tset_armed(false);\n\t\t\tset_arming_failed(true);\n\t\t\treturn false;\n\n\t\tcase AP_Arming::ALWAYS_OK:\n\t\t\tset_armed(true);\n\t\t\tbreak;\n\n\t\tcase AP_Arming::RC_LOST:\n\t\t\tif (rc_lost.get()) {\n\t\t\t\tset_armed(true);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::RC_OK:\n\t\t\tif (!rc_lost.get()) {\n\t\t\t\tset_armed(true);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::COMPASS_CALIBRATED:\n\t\t\tif (compass_calibrated.get()) {\n\t\t\t\tset_armed(true);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::COMPASS_NOT_CALIBRATED:\n\t\t\tif (!compass_calibrated.get()) {\n\t\t\t\tset_armed(true);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::GPS_OK:\n\t\t\tif (!gps_lost.get()) {\n\t\t\t\tset_armed(true);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::GPS_LOST:\n\t\t\tif (gps_lost.get()) {\n\t\t\t\tset_armed(true);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::HOME_OK:\n\t\t\tif (home_ok.get()) {\n\t\t\t\tset_armed(true);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AP_Arming::HOME_LOST:\n\t\t\tif (!home_ok.get()) {\n\t\t\t\tset_armed(true);\n\t\t\t}\n\t\t", "CodeBleu_score": 37.90808084525328}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (charging_state) {\n\t\t\tif (charging_allowed_time + CHARGING_ALLOWED_TIME < time(NULL)) {\n\t\t\t\tcharging_state = false;\n\t\t\t\tcharging_allowed_time = time(NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_allowed_time + CHARGING_ALLOWED_TIME < time(NULL)) {\n\t\t\t\tcharging_state = true;\n\t\t\t\tcharging_allowed_time = time(NULL);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_state) {\n\t\t\tcharging_state = false;\n\t\t\tcharging_allowed_time = time(NULL);\n\t\t}\n\t\tif (time(NULL) > charging_allowed_time + CHARGING_ALLOWED_RETRY_TIME) {\n\t\t\tcharging_allowed_time = time(NULL);\n\t\t\tif (battery_voltage > BATTERY_VOLTAGE_THRESHOLD) {\n\t\t\t\tcharging_allowed = true;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.48629947341394}, {"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (charging_active) {\n\t\t\tif (!charging_allowed) {\n\t\t\t\tcharging_active = false;\n\t\t\t\tcharging_disabled_time = get_time();\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_allowed) {\n\t\t\t\tcharging_active = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!charging_active) {\n\t\t\tif (charging_allowed) {\n\t\t\t\tcharging_active = true;\n\t\t\t} else {\n\t\t\t\tif (get_time() - charging_disabled_time > CHARGING_RETRY_DELAY) {\n\t\t\t\t\tcharging_allowed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.898201485766194}, {"code": "void updateChargingEnabled()\t// If charging is allowed but should not continue, disable charging and record the time.\n\tif (charging_allowed == true && charging_should_continue == false) {\n\t\t// Disable charging.\n\t\tdigitalWrite(CHARGING_PIN, LOW);\n\t\t// Record the time.\n\t\tcharging_disabled_time = millis();\n\t\t// Reset the flag.\n\t\tcharging_should_continue = true;\n\t}\n\t// If charging is not allowed, retry enabling charging after a specified delay, checking the conditions again to decide whether to enable or continue disabling charging.\n\telse if (charging_allowed == false) {\n\t\t// If charging is currently disabled, check if the delay has passed.\n\t\tif (charging_should_continue == true) {\n\t\t\t// If the delay has passed, check if charging is allowed again.\n\t\t\tif (millis() - charging_disabled_time > CHARGING_DELAY) {\n\t\t\t\t// Reset the flag.\n\t\t\t\tcharging_should_continue = false;\n\t\t\t\t// Check if charging is allowed again.\n\t\t\t\tif (charging_allowed == true) {\n\t\t\t\t\t// Enable charging.\n\t\t\t\t\tdigitalWrite(CHARGING_PIN, HIGH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 51.01096190491465}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = crc16(message, size);\n\t\tuint8_t crcBytes[2];\n\t\tcrcBytes[0] = crc >> 8;\n\t\tcrcBytes[1] = crc & 0xFF;\n\t\tpacketSerial.write(message, size);\n\t\tpacketSerial.write(crcBytes, 2);\n\t}\n}\n", "CodeBleu_score": 37.18277146890864}, {"code": "void sendMessage(void *message, size_t size)\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = crc16(message, size);\n\t\tuint8_t crcBytes[2];\n\t\tcrcBytes[0] = crc >> 8;\n\t\tcrcBytes[1] = crc & 0xFF;\n\t\tpacketSerial.write(message, size);\n\t\tpacketSerial.write(crcBytes, 2);\n\t}\n}\n", "CodeBleu_score": 37.18277146890864}, {"code": "void sendMessage(void *message, size_t size)\tif (rosRunning) {\n\t\tif (size >= 4) {\n\t\t\tuint16_t crc = calculateCRC(message, size);\n\t\t\tuint8_t crcBytes[2];\n\t\t\tcrcBytes[0] = crc >> 8;\n\t\t\tcrcBytes[1] = crc & 0xFF;\n\t\t\tpacketSerial.write(message, size);\n\t\t\tpacketSerial.write(crcBytes, 2);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.8619579488774}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()\tSerial.begin(9600);\n\tdelay(500);\n\tif (Serial.available() > 0) {\n\t\tSerial.flush();\n\t}\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x01);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tSerial.flush();\n\tif (Serial.available() > 0) {\n\t\tSerial.read();\n\t\tif (Serial.read() == 0x7E) {\n\t\t\tif (Serial.read() == 0xFF) {\n\t\t\t\tif (Serial.read() == 0x06) {\n\t\t\t\t\tif (Serial.read() == 0x02) {\n\t\t\t\t\t\tif (Serial.read() == 0x01) {\n\t\t\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0xEF) {\n\t\t\t\t\t\t\t\t\t\t\tSerial.flush();\n\t\t\t\t\t\t\t\t\t\t\tif (Serial.available() > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tSerial.read();\n\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x7E) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0xFF) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x06) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x03) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x01) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0xEF) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSerial.flush();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.available() > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSerial.read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0x7E) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Serial.read() == 0xFF", "CodeBleu_score": 33.25903438185907}, {"code": "bool MP3Sound::begin()\t_mp3_serial.begin(9600);\n\t_mp3_serial.flush();\n\t_mp3_serial.println(\"AT+FRESET\");\n\tdelay(500);\n\t_mp3_serial.println(\"AT+FINIT\");\n\tdelay(500);\n\t_mp3_serial.println(\"AT+FSD\");\n\tdelay(500);\n\t_mp3_serial.println(\"AT+FNUM\");\n\tdelay(500);\n\t_mp3_serial.flush();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_serial.read();\n\t_mp3_", "CodeBleu_score": 37.669482328117496}, {"code": "bool MP3Sound::begin()\t// Initialize serial port\n\tSerial.begin(9600);\n\t// Clear any existing data in the buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\t// Initialize sound module\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x01);\n\tSerial.write(0xEF);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.", "CodeBleu_score": 34.7138641480797}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()\tint i;\n\tint activeSounds = 0;\n\tfor (i = 0; i < MAX_SOUNDS; i++) {\n\t\tif (sounds[i].active) {\n\t\t\tactiveSounds++;\n\t\t}\n\t}\n\tif (activeSounds == 0) {\n\t\treturn 0;\n\t}\n\tif (!playing) {\n\t\tplaySound(sounds[activeSounds - 1].sound);\n\t\tsounds[activeSounds - 1].active = false;\n\t\treturn activeSounds - 1;\n\t}\n\treturn activeSounds;\n}\n", "CodeBleu_score": 33.941557302263625}, {"code": "int MP3Sound::processSounds()\tint numActiveSounds = 0;\n\tint i;\n\tfor (i = 0; i < NUM_SOUNDS; i++) {\n\t\tif (activeSounds[i].active) {\n\t\t\tnumActiveSounds++;\n\t\t}\n\t}\n\tif (numActiveSounds == 0 || playingMP3) {\n\t\treturn numActiveSounds;\n\t}\n\t// Play the last sound in the list.\n\tplayMP3(activeSounds[numActiveSounds - 1].filename);\n\t// Remove the last sound from the list.\n\tactiveSounds[numActiveSounds - 1].active = false;\n\treturn numActiveSounds - 1;\n}\n", "CodeBleu_score": 31.95033172391268}, {"code": "int MP3Sound::processSounds()\tif(activeSounds.size() == 0) {\n\t\treturn activeSounds.size();\n\t}\n\tif(playingSound == NULL) {\n\t\tplayingSound = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tplayingSound->play();\n\t}\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 39.30212658953587}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)AbstractCamera *ac = (AbstractCamera *) d;", "CodeBleu_score": 5.938830303507162}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)AbstractCamera *ac = (AbstractCamera *) d;\n", "CodeBleu_score": 5.938830303507162}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)\tassert(d);\n\tassert(r);\n\tbool handled = true;\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE: {\n\t\t\t// Clean up any existing memory-mapped file\n\t\t\tif (d->memory_mapped_file) {\n\t\t\t\twb_memory_mapped_file_delete(d->memory_mapped_file);\n\t\t\t\td->memory_mapped_file = NULL;\n\t\t\t}\n\t\t\t// Set up a new memory-mapped file\n\t\t\tconst char *filename = wb_request_get_string(r, 0);\n\t\t\tif (filename) {\n\t\t\t\td->memory_mapped_file = wb_memory_mapped_file_new(filename);\n\t\t\t\tif (!d->memory_mapped_file) {\n\t\t\t\t\tfprintf(stderr, \"Error: could not open memory-mapped file '%s'.\\n\", filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\thandled = false;\n\t\t\tbreak;\n\t}\n\treturn handled;\n}\n", "CodeBleu_score": 53.20177389388486}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)\tif (!d)\n\t\treturn -1;\n\tif (d->tag!= WB_NODE_TAG_ABSTRACT_CAMERA)\n\t\treturn -1;\n\treturn wb_camera_get_height(d);\n}\n", "CodeBleu_score": 32.97901463813033}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)\treturn wb_abstract_camera_get_width(d);\n}\n", "CodeBleu_score": 2.7590767270146794}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)\tint result = -1;\n\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tif (ac) {\n\t\tpthread_mutex_lock(&ac->mutex);\n\t\tif (ac->width >= 0 && ac->height >= 0)\n\t\t\tresult = ac->height;\n\t\tpthread_mutex_unlock(&ac->mutex);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 50.354251282616325}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tint sampling_period;\n\tWbDevice *accelerometer;\n\n\tif ((accelerometer = wb_robot_get_device(tag)) == NULL) {\n\t\tfprintf(stderr, \"Error: wb_robot_get_device failed.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (wb_accelerometer_get_sampling_period(accelerometer, &sampling_period) == WB_FAILED) {\n\t\tfprintf(stderr, \"Error: wb_accelerometer_get_sampling_period failed.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn sampling_period;\n}\n", "CodeBleu_score": 43.19198387581439}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tint sampling_period = -1;\n\tstruct Acceleration *accelerometer;\n\n\tif (tag < 0 || tag >= WB_MAX_DEVICES) {\n\t\tfprintf(stderr, \"Invalid device tag: %d\\n\", tag);\n\t\treturn -1;\n\t}\n\n\tpthread_mutex_lock(&mutex_devices);\n\taccelerometer = devices[tag].accelerometer;\n\tif (accelerometer!= NULL)\n\t\tsampling_period = accelerometer->sampling_period;\n\tpthread_mutex_unlock(&mutex_devices);\n\n\tif (sampling_period < 0)\n\t\tfprintf(stderr, \"Error: no accelerometer found with tag %d\\n\", tag);\n\n\treturn sampling_period;\n}\n", "CodeBleu_score": 46.58271888307235}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tint sampling_period;\n\tWbDevice *accelerometer;\n\tif ((accelerometer = wb_robot_get_device(tag, WB_NODE_ACCELEROMETER)) == NULL)\n\t\twb_log_error(\"The accelerometer device with tag %d does not exist.\", tag);\n\telse if (wb_accelerometer_get_sampling_period(accelerometer, &sampling_period) == WB_NO_ERROR)\n\t\treturn sampling_period;\n\treturn -1;\n}\n", "CodeBleu_score": 40.52945142380906}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}\n", "CodeBleu_score": 39.01462488971326}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dms);\n\twb_gps_free_degrees_minutes_seconds(dms);\n\treturn result;\n}\n", "CodeBleu_score": 39.71105819348251}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = dms;\n\twb_gps_free_degrees_minutes_seconds(dms);\n\treturn result;\n}\n", "CodeBleu_score": 43.44053731107996}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdAASSERT (g && plane);\n\tdGeomBox a = (dGeomBox) g;\n\tdVector3 p;\n\tdReal sign;\n\tdReal min_dist;\n\tdReal dist;\n\n\tp[0] = x - a->final_posr->pos[0];\n\tp[1] = y - a->final_posr->pos[1];\n\tp[2] = z - a->final_posr->pos[2];\n\n\t/*\n\t * For each of the three axes, find the point on the box that is\n\t * farthest in the direction of the axis.\n\t */\n\tmin_dist = REAL(0.0);\n\tsign = REAL(0.0);\n\tdist = REAL(0.0);\n\tif (dFabs(p[0]) > a->side[0]) {\n\t\tdist = p[0] - a->side[0];\n\t\tsign = REAL(-1.0);\n\t}\n\telse {\n\t\tdist = a->side[0] - p[0];\n\t}\n\tif (dist > min_dist) {\n\t\tmin_dist = dist;\n\t\tplane[0] = sign;\n\t\tplane[1] = REAL(0.0);\n\t\tplane[2] = REAL(0.0);\n\t\tplane[3] = -dist;\n\t}\n\tif (dFabs(p[1]) > a->side[1]) {\n\t\tdist = p[1] - a->side[1];\n\t\tsign = REAL(-1.0);\n\t}\n\telse {\n\t\tdist = a->side[1] - p[1];\n\t}\n\tif (dist > min_dist) {\n\t\tmin_dist = dist;\n\t\tplane[0] = REAL(0.0);\n\t\tplane[1] = sign;\n\t\tplane[2] = REAL(0.0);\n\t\tplane[3] = -dist;\n\t}\n\tif (dFabs(p[2]) > a->side[2]) {\n\t\tdist = p[2] - a->side[2];\n\t\tsign = REAL(-1.0);\n\t}\n\telse {\n\t\tdist = a->side[2]", "CodeBleu_score": 31.092933861339}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdVector3 p;\n\tdGeomBoxGetLengths(g,p);\n\tdReal a = dFabs(p[0]);\n\tdReal b = dFabs(p[1]);\n\tdReal c = dFabs(p[2]);\n\tdReal ax = dFabs(x);\n\tdReal ay = dFabs(y);\n\tdReal az = dFabs(z);\n\tdReal signx = (x >= 0)? REAL(1.0) : REAL(-1.0);\n\tdReal signy = (y >= 0)? REAL(1.0) : REAL(-1.0);\n\tdReal signz = (z >= 0)? REAL(1.0) : REAL(-1.0);\n\tdReal dmin = REAL(0.0);\n\tint minAxis = 0;\n\tif (ax < ay) {\n\t\tif (ax < az) {\n\t\t\tminAxis = 0;\n\t\t\tdmin = ax;\n\t\t}\n\t\telse {\n\t\t\tminAxis = 2;\n\t\t\tdmin = az;\n\t\t}\n\t}\n\telse {\n\t\tif (ay < az) {\n\t\t\tminAxis = 1;\n\t\t\tdmin = ay;\n\t\t}\n\t\telse {\n\t\t\tminAxis = 2;\n\t\t\tdmin = az;\n\t\t}\n\t}\n\tif (minAxis == 0) {\n\t\tplane[0] = signx;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t}\n\telse if (minAxis == 1) {\n\t\tplane[0] = 0;\n\t\tplane[1] = signy;\n\t\tplane[2] = 0;\n\t}\n\telse {\n\t\tplane[0] = 0;\n\t\tplane[1] = 0;\n\t\tplane[2] = signz;\n\t}\n\tplane[3] = -dmin * REAL(0.5);\n}\n", "CodeBleu_score": 34.22557864944407}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdVector3 p;\n\tdGeomBoxGetLengths(g, p);\n\tdReal l = p[0];\n\tdReal w = p[1];\n\tdReal h = p[2];\n\tdReal px = x - dGeomGetPosition(g)[0];\n\tdReal py = y - dGeomGetPosition(g)[1];\n\tdReal pz = z - dGeomGetPosition(g)[2];\n\tdReal d;\n\tif (px < -l + dReal(0.001)) {\n\t\tif (py < -w + dReal(0.001)) {\n\t\t\tif (pz < -h + dReal(0.001)) {\n\t\t\t\tplane[0] = 1;\n\t\t\t\tplane[1] = 0;\n\t\t\t\tplane[2] = 0;\n\t\t\t\tplane[3] = -l;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pz > h - dReal(0.001)) {\n\t\t\t\tplane[0] = 1;\n\t\t\t\tplane[1] = 0;\n\t\t\t\tplane[2] = 0;\n\t\t\t\tplane[3] = l;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tplane[0] = 0;\n\t\t\tplane[1] = 1;\n\t\t\tplane[2] = 0;\n\t\t\tplane[3] = -w;\n\t\t\treturn;\n\t\t}\n\t\tif (py > w - dReal(0.001)) {\n\t\t\tif (pz < -h + dReal(0.001)) {\n\t\t\t\tplane[0] = 1;\n\t\t\t\tplane[1] = 0;\n\t\t\t\tplane[2] = 0;\n\t\t\t\tplane[3] = -l;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pz > h - dReal(0.001)) {\n\t\t\t\tplane[0] = 1;\n\t\t\t\tplane[1] = 0;\n\t\t\t\tplane[2] = 0;\n\t\t\t\tplane[3] = l;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tplane[0] = 0;\n\t\t\tplane[1] = -1;\n\t\t\tplane[2] = 0;\n\t\t\tplane[3] = w;\n\t\t\treturn;\n\t", "CodeBleu_score": 30.142468423185097}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)#ifdef dSINGLE\n  dVector3 p0, p1, p2, p3;", "CodeBleu_score": 7.162481920911619}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tdAASSERT (box && immersion);\n\tdAASSERT (box->body && fluidPlane);\n\tdAASSERT (dImmerseBoxIsValid (box, fluidPlane, flags));\n\tdAASSERT (dImmerseBoxFlagsIsValid (flags));\n\tdAASSERT (dImmerseBoxImmersionIsValid (immersion));\n\n\tdImmerseBoxInitialize (box, fluidPlane, flags, immersion);\n\treturn dImmerseBoxPerform (box, fluidPlane, flags, immersion);\n}\n", "CodeBleu_score": 42.59554437689496}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tdIASSERT (box && box->body && immersion);\n\tdIASSERT (dImmerseBoxValidateParams (box, fluidPlane, flags, immersion));\n\tdImmerseBoxInitParams (box, fluidPlane, flags, immersion);\n\treturn dImmerseBoxCheck (box, immersion);\n}\n", "CodeBleu_score": 45.658703551191095}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdIASSERT(o1->type == dBoxClass);\n\tdIASSERT(o2->type == dCapsuleClass);\n\tdAASSERT(immersion);\n\n\t// Get the box and capsule data\n\tconst dReal *p1 = o1->final_posr->pos;\n\tconst dReal *R1 = o1->final_posr->R;\n\tconst dReal *p2 = o2->final_posr->pos;\n\tconst dReal *R2 = o2->final_posr->R;\n\tconst dReal *side = ((dBox*) o1)->side;\n\tconst dReal radius = ((dCapsule*) o2)->radius;\n\tconst dReal halfLength = ((dCapsule*) o2)->length * REAL(0.5);\n\n\t// Check for a collision\n\tdVector3 pa, pb, pa_local, pb_local;\n\tint n = dCollideBoxCapsule(p1, R1, side, p2, R2, radius, halfLength, pa, pb);\n\tif (n < 1) {\n\t\treturn 0;\n\t}\n\n\t// Compute the local-space collision points\n\tdMultiply0_331(pa_local, R1, pa);\n\tdMultiply0_331(pb_local, R1, pb);\n\n\t// Set the immersion parameters\n\timmersion->type = dImmersionGeomCapsule;\n\timmersion->o1 = o1;\n\timmersion->o2 = o2;\n\timmersion->flags = flags;\n\timmersion->side = 0;\n\timmersion->normal[0] = 0;\n\timmersion->normal[1] = 0;\n\timmersion->normal[2] = 1;\n\timmersion->depth = dCalcVectorDot3(pa_local, immersion->normal) - radius;\n\timmersion->depth += dCalcVectorDot3(pb_local, immersion->normal) - radius;\n\timmersion->depth *= REAL(0.5);\n\timmersion->offset = dCalcVectorDot3(pa_local, immersion->normal);\n\tdNormalize3(immersion->normal);\n\n\t// Compute the immersion", "CodeBleu_score": 41.56307662977377}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdAASSERT (o1 && o2 && immersion);\n\tdUASSERT (o1->type == dBoxClass, \"argument 1 is not a box\");\n\tdUASSERT (o2->type == dCapsuleClass, \"argument 2 is not a capsule\");\n\tconst dReal *p1 = o1->final_posr->pos;\n\tconst dReal *p2 = o2->final_posr->pos;\n\tconst dReal *R1 = o1->final_posr->R;\n\tconst dReal *R2 = o2->final_posr->R;\n\tconst dReal *side = o1->boxside;\n\tconst dReal *radius = o2->final_radius;\n\tdVector3 p;\n\tdReal r;\n\tint i;\n\tdVector3 tmp;\n\tdReal tmp_r;\n\tdVector3 normal;\n\tdReal depth;\n\tdReal rsq;\n\tdReal side_sq;\n\tdVector3 side_vec;\n\tdVector3 side_proj;\n\tdReal side_proj_sq;\n\tdReal side_proj_len;\n\tdReal side_proj_len_inv;\n\tdVector3 side_proj_norm;\n\tdVector3 side_proj_norm_inv;\n\tdReal side_proj_dot_norm;\n\tdVector3 side_proj_cross_norm;\n\tdVector3 side_proj_cross_norm_inv;\n\tdReal side_proj_cross_norm_dot_side_vec;\n\tdVector3 side_proj_cross_side_vec;\n\tdVector3 side_proj_cross_side_vec_inv;\n\tdVector3 side_proj_cross_side_vec_cross_norm;\n\tdVector3 side_proj_cross_side_vec_cross_norm_inv;\n\tdReal side_proj_cross_side_vec_cross_norm_dot_side_vec;\n\tdVector3 side_proj_cross_side_vec_cross_norm_cross_side_vec;\n\tdVector3 side_proj_cross_side_vec_cross_norm_cross_side_vec_inv;\n\t", "CodeBleu_score": 23.61217616650903}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdAASSERT (o1 && o2 && immersion);\n\t// Get the box and capsule.\n\tdGeomBox *box = (dGeomBox*) o1;\n\tdGeomCapsule *capsule = (dGeomCapsule*) o2;\n\t// Get the dimensions of the box.\n\tdVector3 box_side;\n\tdGeomBoxGetSides (box, box_side);\n\t// Get the dimensions of the capsule.\n\tdReal radius, half_height;\n\tdGeomCapsuleGetParams (capsule, &radius, &half_height);\n\t// Check for a collision.\n\tif (dBoxTouchesCapsule (box_side, radius, half_height, capsule)) {\n\t\t// Set the immersion parameters.\n\t\tdVector3 normal;\n\t\tdGeomCapsuleGetDirection (capsule, normal);\n\t\tdGeomCapsuleGetPosition (capsule, immersion->position);\n\t\tdGeomCapsuleGetRotation (capsule, immersion->rotation);\n\t\tdReal depth;\n\t\tdGeomBoxPointDepth (box, immersion->position, &depth);\n\t\timmersion->depth = depth + radius;\n\t\tdGeomPlaneSetParams (immersion->plane, normal, immersion->position);\n\t\t// Compute the immersion plane for the capsule.\n\t\tdVector3 capsule_side;\n\t\tdGeomCapsuleGetSides (capsule, capsule_side);\n\t\tdReal capsule_depth = dFabs (dGeomPlanePointDistance (immersion->plane, capsule_side));\n\t\tdVector3 capsule_center;\n\t\tdGeomCapsuleGetPosition (capsule, capsule_center);\n\t\tdReal capsule_radius = dSqrt (dDOT (capsule_side, capsule_side));\n\t\tdReal capsule_radius_sqr = capsule_radius * capsule_radius;\n\t\tdVector3 capsule_normal;\n\t\tdGeomPlaneGetParams (immersion->plane, capsule_normal);\n\t\tdReal capsule_dist = dFabs (dDOT (capsule_center, capsule_normal));\n\t\tdReal capsule_dist_sqr = capsule_dist * capsule_dist;\n\t\tdReal capsule_depth", "CodeBleu_score": 35.69020556958869}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\t// The volume of the hemisphere is given by the following integral:\n\t// \t\\int_0^1 dz (1 - z^2) (1 - (1 - z^2) tan^2 theta_0) (1 - (1 - z^2) sin^2 theta_1)\n\t// The first integral is analytic, and the second integral is given by Simpson's rule.\n\t// To handle potential singularities, we divide the integration into two parts:\n\t// \t- Part 1: from 0 to zIOverR\n\t// \t- Part 2: from zIOverR to 1\n\tdReal z2 = zIOverR * zIOverR;\n\tdReal z2_1 = 1 - z2;\n\tdReal z2_1_tan2 = z2_1 * z2_1 * tanTheta0 * tanTheta0;\n\tdReal z2_1_sin2 = z2_1 * z2_1 * sinTheta1 * sinTheta1;\n\tdReal z2_1_tan2_sin2 = z2_1_tan2 * sinTheta1 * sinTheta1;\n\tdReal z2_1_tan2_sin2_2 = z2_1_tan2_sin2 * 2;\n\tdReal z2_1_sin2_2 = z2_1_sin2 * 2;\n\tdReal z2_1_tan2_sin2_3 = z2_1_tan2_sin2 * 3;\n\tdReal z2_1_tan2_sin2_4 = z2_1_tan2_sin2 * 4;\n\tdReal z2_1_sin2_4 = z2_1_sin2 * 4;\n\tdReal z2_1_tan2_sin2_5 = z2_1_tan2_sin2 * 5;\n\tdReal z2_1_tan2_sin2_6 = z2_1_tan2_sin2 * 6;\n\tdReal z2_1_sin2_6 = z2_1_sin2 * 6;\n\tdReal z2_1_tan2_sin2_", "CodeBleu_score": 31.53331355964764}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal zI = zIOverR * m_radius;\n\tdReal cosTheta0 = 1.0;\n\tdReal cosTheta1 = sinTheta1;\n\tdReal sinTheta0 = 0.0;\n\tdReal sinTheta1 = 1.0;\n\tdReal theta0 = acos(cosTheta0);\n\tdReal theta1 = acos(cosTheta1);\n\tdReal theta = theta1 - theta0;\n\tdReal tanTheta = tan(theta);\n\tdReal r = m_radius;\n\tdReal z = zI;\n\tdReal zOverR = z / r;\n\tdReal zOverR2 = zOverR * zOverR;\n\tdReal zOverR3 = zOverR * zOverR2;\n\tdReal zOverR4 = zOverR * zOverR3;\n\tdReal zOverR5 = zOverR * zOverR4;\n\tdReal zOverR6 = zOverR * zOverR5;\n\tdReal zOverR7 = zOverR * zOverR6;\n\tdReal zOverR8 = zOverR * zOverR7;\n\tdReal zOverR9 = zOverR * zOverR8;\n\tdReal zOverR10 = zOverR * zOverR9;\n\tdReal zOverR11 = zOverR * zOverR10;\n\tdReal zOverR12 = zOverR * zOverR11;\n\tdReal zOverR13 = zOverR * zOverR12;\n\tdReal zOverR14 = zOverR * zOverR13;\n\tdReal zOverR15 = zOverR * zOverR14;\n\tdReal zOverR16 = zOverR * zOverR15;\n\tdReal zOverR17 = zOverR * zOverR16;\n\tdReal zOverR18 = zOverR * zOverR17;\n\tdReal zOverR19 = zOverR * zOverR18;\n\tdReal zOverR20 = zOverR * zOverR19;\n\t", "CodeBleu_score": 32.10462512947082}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal sinTheta0 = sqrt(1.0 - zIOverR * zIOverR);\n\tdReal cosTheta0 = zIOverR / sinTheta0;\n\tdReal sinTheta1Sq = sinTheta1 * sinTheta1;\n\tdReal sinTheta0Sq = sinTheta0 * sinTheta0;\n\tdReal cosTheta0Sq = cosTheta0 * cosTheta0;\n\tdReal sinTheta1CosTheta0 = sinTheta1 * cosTheta0;\n\tdReal sinTheta0CosTheta0 = sinTheta0 * cosTheta0;\n\tdReal sinTheta1CosTheta0Sq = sinTheta1CosTheta0 * sinTheta1CosTheta0;\n\tdReal sinTheta0CosTheta0Sq = sinTheta0CosTheta0 * sinTheta0CosTheta0;\n\tdReal cosTheta0CosTheta0 = cosTheta0 * cosTheta0;\n\tdReal sinTheta1CosTheta0CosTheta0 = sinTheta1CosTheta0 * cosTheta0;\n\tdReal sinTheta0CosTheta0CosTheta0 = sinTheta0CosTheta0 * cosTheta0;\n\tdReal sinTheta1CosTheta0CosTheta0Sq = sinTheta1CosTheta0CosTheta0 * sinTheta1CosTheta0CosTheta0;\n\tdReal sinTheta0CosTheta0CosTheta0Sq = sinTheta0CosTheta0CosTheta0 * sinTheta0CosTheta0CosTheta0;\n\tdReal cosTheta0CosTheta0CosTheta0 = cosTheta0CosTheta0 * cosTheta0CosTheta0;\n\tdReal sinTheta1CosTheta0CosTheta0CosTheta0 = sinTheta1CosTheta0CosTheta0 * cosTheta0CosTheta0;\n\tdReal sinTheta0CosTheta0CosTheta0CosTheta0 = sinTheta0CosTheta0CosTheta0 * cosTheta0CosTheta0;\n\tdReal sinTheta1CosTheta0CosTheta0CosTheta0Sq = sinTheta1CosTheta0CosTheta0CosTheta0 * sinTheta1CosTheta0CosTheta0CosTheta0;\n\tdReal sinTheta0CosTheta0CosTheta0CosTheta0Sq = sinTheta0CosTheta0CosTheta0CosTheta0 * sinTheta0CosTheta0CosTheta0CosTheta0;\n\tdReal cosTheta0Cos", "CodeBleu_score": 35.46868886052762}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\t// The volume of a hemisphere is 2*pi*r*r*h/3\n\tdReal volumeOfHemisphere = 2.0*M_PI*radius*radius*zIOverR/3.0;\n\tdReal volumeFraction = volume/volumeOfHemisphere;\n\tdReal volumeFractionSquared = volumeFraction*volumeFraction;\n\tdReal volumeFractionCubed = volumeFractionSquared*volumeFraction;\n\tdReal volumeFractionFourth = volumeFractionCubed*volumeFraction;\n\tdReal volumeFractionFifth = volumeFractionFourth*volumeFraction;\n\tdReal volumeFractionSixth = volumeFractionFifth*volumeFraction;\n\tdReal volumeFractionSeventh = volumeFractionSixth*volumeFraction;\n\tdReal volumeFractionEighth = volumeFractionSeventh*volumeFraction;\n\tdReal volumeFractionNinth = volumeFractionEighth*volumeFraction;\n\tdReal volumeFractionTenth = volumeFractionNinth*volumeFraction;\n\tdReal volumeFractionEleventh = volumeFractionTenth*volumeFraction;\n\tdReal volumeFractionTwelfth = volumeFractionEleventh*volumeFraction;\n\tdReal volumeFractionThirteenth = volumeFractionTwelfth*volumeFraction;\n\tdReal volumeFractionFourteenth = volumeFractionThirteenth*volumeFraction;\n\tdReal volumeFractionFifteenth = volumeFractionFourteenth*volumeFraction;\n\tdReal volumeFractionSixteenth = volumeFractionFifteenth*volumeFraction;\n\tdReal volumeFractionSeventeenth = volumeFractionSixteenth*volumeFraction;\n\tdReal volumeFractionEighteenth = volumeFractionSeventeenth*volumeFraction;\n\tdReal volumeFractionNineteenth = volumeFractionEighteenth*volumeFraction;\n\tdReal volumeFractionTwentieth = volumeFractionNineteenth*volumeFraction;\n\tdReal volumeFractionTwentyFirst = volumeFractionTwentieth*volumeFraction;\n\tdReal volumeFractionTwentySecond = volumeFractionTwentyFirst*volumeFraction;\n\tdReal volumeFractionTwentyThird = volumeFractionTwentySecond*volumeFraction;\n\tdReal volumeFractionTwentyFourth = volumeFractionTwentyThird*volumeFraction;\n\tdReal volumeFractionTwentyFifth = volumeFractionTw", "CodeBleu_score": 35.29183926503343}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal z0 = zIOverR * m_radius;\n\tdReal z1 = z0 + m_immersionDepthRatio * m_radius;\n\tdReal z2 = z1 + m_immersionDepthRatio * m_radius;\n\tdReal z3 = z2 + m_immersionDepthRatio * m_radius;\n\tdReal z4 = z3 + m_immersionDepthRatio * m_radius;\n\tdReal z5 = z4 + m_immersionDepthRatio * m_radius;\n\tdReal z6 = z5 + m_immersionDepthRatio * m_radius;\n\tdReal z7 = z6 + m_immersionDepthRatio * m_radius;\n\tdReal z8 = z7 + m_immersionDepthRatio * m_radius;\n\tdReal z9 = z8 + m_immersionDepthRatio * m_radius;\n\tdReal z10 = z9 + m_immersionDepthRatio * m_radius;\n\tdReal z11 = z10 + m_immersionDepthRatio * m_radius;\n\tdReal z12 = z11 + m_immersionDepthRatio * m_radius;\n\tdReal z13 = z12 + m_immersionDepthRatio * m_radius;\n\tdReal z14 = z13 + m_immersionDepthRatio * m_radius;\n\tdReal z15 = z14 + m_immersionDepthRatio * m_radius;\n\tdReal z16 = z15 + m_immersionDepthRatio * m_radius;\n\tdReal z17 = z16 + m_immersionDepthRatio * m_radius;\n\tdReal z18 = z17 + m_immersionDepthRatio * m_radius;\n\tdReal z19 = z18 + m_immersionDepthRatio * m_radius;\n\tdReal z20 = z19 + m_immersionDepthRatio * m_radius;\n\tdReal z21 = z20 + m_immersionDepthRatio * m_radius;\n\tdReal z22 = z21 + m_immersionDepthRatio * m_radius;\n\tdReal z23 = z2", "CodeBleu_score": 34.64805466013557}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal h = this->immersedHemisphereHeight(zIOverR, tanTheta0, sinTheta1);\n\tdReal hOverR = h / this->radius;\n\tdReal integral = 0.0;\n\tdReal z = 0.0;\n\tdReal dz = this->radius / 100.0;\n\tfor (int i = 0; i < 100; i++) {\n\t\tz += dz;\n\t\tdReal x = this->immersedHemisphereX(z, zIOverR, tanTheta0, sinTheta1);\n\t\tdReal y = this->immersedHemisphereY(z, zIOverR, tanTheta0, sinTheta1);\n\t\tdReal r = sqrt(x * x + y * y);\n\t\tintegral += (this->immersedHemisphereBuoyancy(z, zIOverR, tanTheta0, sinTheta1) * dz) / (r * r * r);\n\t}\n\tintegral *= 0.5 * dz;\n\treturn integral / hOverR / volume;\n}\n", "CodeBleu_score": 41.81617443588886}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdReal *p1 = dGeomGetPosition(o1);\n\tdReal *p2 = dGeomGetPosition(o2);\n\tdReal *R1 = dGeomGetRotation(o1);\n\tdReal *R2 = dGeomGetRotation(o2);\n\tdReal *v1 = dGeomGetPosition(immersion->v1);\n\tdReal *v2 = dGeomGetPosition(immersion->v2);\n\tdReal *v3 = dGeomGetPosition(immersion->v3);\n\tdReal *v4 = dGeomGetPosition(immersion->v4);\n\tdReal *v5 = dGeomGetPosition(immersion->v5);\n\tdReal *v6 = dGeomGetPosition(immersion->v6);\n\tdReal *v7 = dGeomGetPosition(immersion->v7);\n\tdReal *v8 = dGeomGetPosition(immersion->v8);\n\tdReal *v9 = dGeomGetPosition(immersion->v9);\n\tdReal *v10 = dGeomGetPosition(immersion->v10);\n\tdReal *v11 = dGeomGetPosition(immersion->v11);\n\tdReal *v12 = dGeomGetPosition(immersion->v12);\n\tdReal *v13 = dGeomGetPosition(immersion->v13);\n\tdReal *v14 = dGeomGetPosition(immersion->v14);\n\tdReal *v15 = dGeomGetPosition(immersion->v15);\n\tdReal *v16 = dGeomGetPosition(immersion->v16);\n\tdReal *v17 = dGeomGetPosition(immersion->v17);\n\tdReal *v18 = dGeomGetPosition(immersion->v18);\n\tdReal *v19 = dGeomGetPosition(immersion->v19);\n\tdReal *v20 = dGeomGetPosition(immersion->v20);\n\tdReal *v21 = dGeomGetPosition(immersion->v21);\n\tdReal *v22 = dGeomGetPosition(immersion->v22);\n\tdReal *", "CodeBleu_score": 28.097752272505836}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tconst dReal *v0, *v1, *v2;\n\tdVector3 dv;\n\tdReal r, h, d, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23, h24, h25, h26, h27, h28, h29, h30, h31, h32, h33, h34, h35, h36, h37, h38, h39, h40, h41, h42, h43, h44, h45, h46, h47, h48, h49, h50, h51, h52, h53, h54, h55, h56, h57, h58, h59, h60, h61, h62, h63, h64, h65, h66, h67, h68, h69, h70, h71, h72, h73, h74, h75, h76, h77, h78, h79, h80, h81, h82, h83, h84, h85, h86, h87, h88, h89, h90, h91, h92, h93, h94, h95, h96, h97, h98, h99, h100, h101, h102, h103, h104, h105, h106, h107, h108, h109, h110, h111, h112, h113, h114, h115, h116, h117, h118,", "CodeBleu_score": 5.778615373754113}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdReal depthRatio, tanInitialAngle, sinFinalAngle, volume, volumeRatio, radius;\n\tdReal x, y, z, r, theta, phi;\n\tdReal xCenter, yCenter, zCenter;\n\tdReal xBuoyancyCenter, yBuoyancyCenter, zBuoyancyCenter;\n\tdReal xBuoyancyCenterScaled, yBuoyancyCenterScaled, zBuoyancyCenterScaled;\n\tdReal xBuoyancyCenterScaledAdjusted, yBuoyancyCenterScaledAdjusted, zBuoyancyCenterScaledAdjusted;\n\tdReal volumeRatioBuoyancyCenterScaledAdjusted;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquared;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedCubed;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubed;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFour;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatio;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioSquared;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioCubed;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioSquaredCubed;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioSquaredCubedOverTwo;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioSquaredCubedOverTwoTimesVolumeRatio;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioSquaredCubedOverTwoTimesVolumeRatioSquared;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioSquaredCubedOverTwoTimesVolumeRatioCubed;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioSquaredCubedOverTwoTimesVolumeRatioSquaredCubed;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatioSquaredCubedOverTwoTimesVolumeRatioSquaredCubedOverThree;\n\tdReal volumeRatioBuoyancyCenterScaledAdjustedSquaredCubedOverFourTimesVolumeRatio", "CodeBleu_score": 7.151243353709978}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()\tROS_INFO(\"Starting SleepNode\");\n\n\t// Retrieve the sleep duration in milliseconds\n\tconst std_msgs::Duration::ConstPtr& sleep_duration_msg =\n\t\tthis->get_parameter(\"sleep_duration\").get_parameter_value().as_duration();\n\tconst int sleep_duration_ms = sleep_duration_msg->toSec() * 1000;\n\n\t// If the sleep duration is invalid, return SUCCESS\n\tif (sleep_duration_ms <= 0) {\n\t\tROS_INFO(\"Sleep duration is not positive, returning SUCCESS\");\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tthis->set_status(NodeStatus::RUNNING);\n\n\t// Start a timer\n\tthis->start_timer(sleep_duration_ms);\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\tthis->set_on_timer_end_callback([this]() {\n\t\tthis->set_output_msg();\n\t\tthis->set_status(NodeStatus::SUCCESS);\n\t});\n\n\treturn NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 36.498301976579135}, {"code": "NodeStatus SleepNode::onStart()\t// Get the sleep duration in milliseconds from the input.\n\tconst unsigned int sleep_duration = getInput<unsigned int>(\"sleep_duration\");\n\n\t// If the sleep duration is missing or non-positive, return SUCCESS.\n\tif (!sleep_duration) {\n\t\tROS_INFO(\"Sleep duration is missing or non-positive, returning SUCCESS\");\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING.\n\tROS_INFO(\"Setting node status to RUNNING\");\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer to emit a wake-up signal after the sleep duration.\n\tROS_INFO(\"Starting timer to emit wake-up signal after the sleep duration\");\n\tstartTimer(sleep_duration);\n\n\t// Set a callback to emit a wake-up signal when the timer expires.\n\tROS_INFO(\"Setting callback to emit a wake-up signal when the timer expires\");\n\tsetCallback(std::bind(&SleepNode::onTimer, this));\n\n\treturn NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 35.47560221728856}, {"code": "NodeStatus SleepNode::onStart()\t// Retrieve the sleep duration\n\tconst std::string sleep_duration = getInput(\"sleep_duration\");\n\t// If the duration is missing or non-positive, return SUCCESS\n\tif (sleep_duration.empty() || std::stod(sleep_duration) <= 0.0) {\n\t\tROS_INFO(\"The sleep duration is missing or non-positive, so returning SUCCESS\");\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// Otherwise, set the node status to RUNNING, start the timer, and set a callback to emit a wake-up signal when the timer expires\n\tROS_INFO(\"Setting the node status to RUNNING\");\n\tset_status(NodeStatus::RUNNING);\n\tROS_INFO(\"Starting the timer\");\n\ttimer_ = create_timer(std::stod(sleep_duration), std::bind(&SleepNode::onTimer, this));\n\tROS_INFO(\"Setting a callback to emit a wake-up signal when the timer expires\");\n\ttimer_.setCallback(std::bind(&SleepNode::onTimer, this));\n\t// Return RUNNING\n\treturn NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 42.22841639472614}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()\t// Retrieve the entry\n\tstd::shared_ptr<Blackboard> blackboard = this->getBlackboard();\n\tif (blackboard == nullptr) {\n\t\tROS_ERROR_STREAM(\"Failed to retrieve the blackboard\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tstd::string entry_name = this->getInput(\"entry_name\", std::string(\"\"));\n\tif (entry_name.empty()) {\n\t\tROS_ERROR_STREAM(\"Failed to retrieve the entry name\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tstd::shared_ptr<BlackboardEntry> entry = blackboard->getEntry(entry_name);\n\tif (entry == nullptr) {\n\t\tROS_ERROR_STREAM(\"Failed to retrieve the entry\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\t// Lock the entry's mutex\n\tif (!entry->lockMutexForReading()) {\n\t\tROS_ERROR_STREAM(\"Failed to lock the entry's mutex\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\t// Retrieve the sequence ID\n\tint64_t sequence_id = entry->getSequenceID();\n\t// Compare the sequence IDs\n\tint64_t prev_sequence_id = this->getPrevSequenceID(entry_name);\n\tif (prev_sequence_id!= sequence_id) {\n\t\t// Update the stored sequence ID\n\t\tthis->setPrevSequenceID(entry_name, sequence_id);\n\t\t// Unlock the entry's mutex\n\t\tif (!entry->unlockMutexForReading()) {\n\t\t\tROS_ERROR_STREAM(\"Failed to unlock the entry's mutex\");\n\t\t\treturn NodeStatus::FAILURE;\n\t\t}\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// Unlock the entry's mutex\n\tif (!entry->unlockMutexForReading()) {\n\t\tROS_ERROR_STREAM(\"Failed to unlock the entry's mutex\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\treturn NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 37.92708525284345}, {"code": "NodeStatus EntryUpdatedAction::tick()\t// Retrieve the entry from the blackboard\n\tEntry entry;\n\tif (!blackboard->get(entry_name, entry)) {\n\t\tROS_ERROR_STREAM(\"EntryUpdatedAction: Could not retrieve entry \" << entry_name << \" from blackboard\");\n\t\treturn FAILURE;\n\t}\n\n\t// Lock the entry's mutex\n\tif (!entry.mutex.try_lock()) {\n\t\tROS_DEBUG_STREAM(\"EntryUpdatedAction: Could not lock mutex of entry \" << entry_name);\n\t\treturn FAILURE;\n\t}\n\n\t// Compare the sequence IDs\n\tif (entry.sequence_id!= sequence_id) {\n\t\tsequence_id = entry.sequence_id;\n\t\tentry.mutex.unlock();\n\t\treturn SUCCESS;\n\t}\n\n\t// Unlock the mutex and return FAILURE\n\tentry.mutex.unlock();\n\treturn FAILURE;\n}\n", "CodeBleu_score": 33.66324176155216}, {"code": "NodeStatus EntryUpdatedAction::tick()\t// Get the entry\n\tBlackboard::Ptr& blackboard = this->blackboard_ptr_;\n\tstd::string entry_name = this->entry_name_;\n\tBlackboard::PtrEntry entry = blackboard->getEntry(entry_name);\n\n\t// Check if the entry exists\n\tif (entry) {\n\t\t// Lock the entry mutex\n\t\tboost::mutex::scoped_lock lock(*(entry->mutex));\n\n\t\t// Get the current sequence ID\n\t\tint current_sequence_id = entry->sequence_id;\n\n\t\t// Compare the current sequence ID with the stored sequence ID\n\t\tif (current_sequence_id!= this->previous_sequence_id_) {\n\t\t\t// Update the stored sequence ID\n\t\t\tthis->previous_sequence_id_ = current_sequence_id;\n\n\t\t\t// Return SUCCESS\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\n\t// Return FAILURE\n\treturn NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 37.341604670825845}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const\tif (success_threshold_ < 0) {\n\t\treturn (size_t)(success_threshold_ * children_.size());\n\t}\n\treturn (size_t)success_threshold_;\n}\n", "CodeBleu_score": 50.485848447740764}, {"code": "size_t ParallelNode::successThreshold() const\tif (successThreshold_ < 0) {\n\t\treturn std::max(1, (size_t)(successThreshold_ * (float)children_.size()));\n\t}\n\treturn successThreshold_;\n}\n", "CodeBleu_score": 50.292609629014905}, {"code": "size_t ParallelNode::successThreshold() const\tif (successThreshold_ < 0) {\n\t\t// If the success threshold is negative, it adjusts the value based on the number of child nodes, ensuring the result is non-negative.\n\t\treturn std::max(size_t(0), successThreshold_ + int(children_.size()));\n\t}\n\telse {\n\t\t// If the success threshold is non-negative, it returns it directly as a size_t.\n\t\treturn successThreshold_;\n\t}\n}\n", "CodeBleu_score": 57.18240280814923}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()\twhile(true) {\n\t\t// Check the current time\n\t\ttime_t currentTime = time(0);\n\t\t// If the current time is more than 10 milliseconds after the last heartbeat, disable all breakpoints\n\t\tif(difftime(currentTime, lastHeartbeat) > 0.01) {\n\t\t\t// Disable all breakpoints\n\t\t\tfor(int i = 0; i < MAX_NUM_BREAKPOINTS; i++) {\n\t\t\t\tbreakpoints[i].enabled = false;\n\t\t\t}\n\t\t}\n\t\t// Sleep for 10 milliseconds\n\t\tusleep(10000);\n\t}\n}\n", "CodeBleu_score": 16.71975757107924}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\tstd::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();\n\t\tstd::chrono::duration<double> elapsed = now - lastHeartbeat;\n\t\tif (elapsed.count() > 10) {\n\t\t\t// disable all breakpoints\n\t\t\tfor (auto &bp : breakpoints) {\n\t\t\t\tbp.second.enabled = false;\n\t\t\t}\n\t\t\t// enable all breakpoints that are set to be enabled\n\t\t\tfor (auto &bp : breakpoints) {\n\t\t\t\tif (bp.second.enabledWhenActive) {\n\t\t\t\t\tbp.second.enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t}\n}\n", "CodeBleu_score": 41.427301620151965}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (this->heartbeat_status!= this->last_heartbeat_status) {\n\t\t\tthis->last_heartbeat_status = this->heartbeat_status;\n\t\t\tthis->setBreakpoints();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 15.353018134005517}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> ret;\n\tstd::vector<std::string> bb_names;\n\tstd::stringstream ss(bb_list);\n\tstd::string bb_name;\n\twhile (std::getline(ss, bb_name, ',')) {\n\t\tbb_names.push_back(bb_name);\n\t}\n\n\tif (bb_names.size() == 0) {\n\t\treturn ret;\n\t}\n\n\tstd::map<std::string, Blackboard::Ptr> bb_map = getBBs();\n\tfor (std::string bb_name : bb_names) {\n\t\tif (bb_map.find(bb_name) == bb_map.end()) {\n\t\t\tROS_ERROR_STREAM(\"Blackboard \" << bb_name << \" not found.\");\n\t\t\tcontinue;\n\t\t}\n\t\tBlackboard::Ptr bb = bb_map[bb_name];\n\t\tif (!bb->isLocked()) {\n\t\t\tbb->lock(true);\n\t\t}\n\t\tif (!bb->isValid()) {\n\t\t\tROS_ERROR_STREAM(\"Blackboard \" << bb_name << \" is not valid.\");\n\t\t\tcontinue;\n\t\t}\n\t\tstd::string json_str = bb->exportToJson();\n\t\trapidjson::Document doc;\n\t\tdoc.Parse(json_str.c_str());\n\t\trapidjson::StringBuffer buffer;\n\t\trapidjson::Writer<rapidjson::StringBuffer> writer(buffer);\n\t\tdoc.Accept(writer);\n\t\tstd::string msgpack_str = buffer.GetString();\n\t\tstd::vector<uint8_t> msgpack_vec(msgpack_str.begin(), msgpack_str.end());\n\t\tret.insert(ret.end(), msgpack_vec.begin(), msgpack_vec.end());\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 40.05786051554852}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> bb_dump;\n\tstd::string bb_name;\n\tstd::string delimiter = \",\";\n\tsize_t pos = 0;\n\tsize_t prev_pos = 0;\n\tstd::vector<std::string> bb_names;\n\tbb_names = split(bb_list, delimiter);\n\tfor (size_t i = 0; i < bb_names.size(); i++) {\n\t\tbb_name = bb_names[i];\n\t\tpos = bb_name.find_last_of('.');\n\t\tif (pos!= std::string::npos) {\n\t\t\tbb_name = bb_name.substr(pos + 1);\n\t\t}\n\t\tif (bb_name.empty()) {\n\t\t\tbb_name = \"root\";\n\t\t}\n\t\tif (bb_name == \"root\") {\n\t\t\tbb_dump = generateBlackboardDump(blackboard_root);\n\t\t} else {\n\t\t\tblackboard_root.lockRead();\n\t\t\tblackboard_root.lockSubtree(bb_name);\n\t\t\tbb_dump = generateBlackboardDump(blackboard_root.getSubtree(bb_name));\n\t\t\tblackboard_root.unlockSubtree(bb_name);\n\t\t\tblackboard_root.unlockRead();\n\t\t}\n\t\tbb_dump.insert(bb_dump.begin(), bb_name.begin(), bb_name.end());\n\t\tbb_dump.push_back(0);\n\t\tif (i < bb_names.size() - 1) {\n\t\t\tbb_dump.insert(bb_dump.end(), delimiter.begin(), delimiter.end());\n\t\t}\n\t}\n\treturn bb_dump;\n}\n", "CodeBleu_score": 40.82287665233989}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> msgpack_dump;\n\tstd::vector<std::string> bb_names;\n\tstd::vector<std::string> tokens;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\tfor (auto bb_name : bb_names) {\n\t\tif (bb_name.size() > 0) {\n\t\t\tauto bb = blackboard_server.getBlackboard(bb_name);\n\t\t\tif (bb) {\n\t\t\t\tauto subtree = bb->getTree();\n\t\t\t\tif (subtree) {\n\t\t\t\t\tsubtree->lockReading();\n\t\t\t\t\tauto bb_dump = subtree->toMessagePack();\n\t\t\t\t\tsubtree->unlockReading();\n\t\t\t\t\tmsgpack_dump.insert(msgpack_dump.end(), bb_dump.begin(), bb_dump.end());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn msgpack_dump;\n}\n", "CodeBleu_score": 45.70425258301797}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Search for the node\n\tNode* node = getNode(node_uid);\n\tif (node == NULL) {\n\t\treturn false;\n\t}\n\n\t// Retrieve the associated hook\n\tHook* hook = node->getHook();\n\tif (hook == NULL) {\n\t\treturn false;\n\t}\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (hook->getStatus()!= NodeStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// Lock the hook's mutex\n\tstd::unique_lock<std::mutex> hook_lock(hook->getMutex());\n\n\t// Set the desired status and removal flag\n\thook->setStatus(result);\n\thook->setRemove(remove);\n\n\t// Mark the hook as ready\n\thook->setReady();\n\n\t// Notify all waiting threads\n\thook_lock.unlock();\n\thook->getCondition().notify_all();\n\n\treturn true;\n}\n", "CodeBleu_score": 39.79673869747198}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Find the hook\n\tauto it = hooks_.find(node_uid);\n\tif (it == hooks_.end()) {\n\t\tROS_ERROR_STREAM(\"Groot2Publisher::unlockBreakpoint - Unable to find node \" << node_uid);\n\t\treturn false;\n\t}\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (it->second.status_!= NodeStatus::BREAKPOINT) {\n\t\tROS_ERROR_STREAM(\"Groot2Publisher::unlockBreakpoint - Node \" << node_uid << \" is not in BREAKPOINT mode\");\n\t\treturn false;\n\t}\n\n\t// Lock the hook's mutex\n\tstd::unique_lock<std::mutex> lock(it->second.mutex_);\n\n\t// Set the desired status and removal flag, mark it as ready, and notify all waiting threads\n\tit->second.status_ = result;\n\tit->second.remove_ = remove;\n\tit->second.ready_ = true;\n\tlock.unlock();\n\tit->second.cond_.notify_all();\n\n\treturn true;\n}\n", "CodeBleu_score": 39.2415900691783}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Check if the node exists and is valid\n\tif (pos == POSITION_INVALID) {\n\t\treturn false;\n\t}\n\n\t// Retrieve the associated hook and lock its mutex\n\tGroot2Hook *hook = getHook(pos, node_uid);\n\tif (hook == nullptr) {\n\t\treturn false;\n\t}\n\tstd::unique_lock<std::mutex> lock(hook->mutex);\n\n\t// If the hook is in BREAKPOINT mode, set the desired status and removal flag, mark it as ready, and notify all waiting threads\n\tif (hook->status == STATUS_BREAKPOINT) {\n\t\thook->status = result;\n\t\thook->remove = remove;\n\t\thook->ready = true;\n\t\thook->cv.notify_all();\n\t\treturn true;\n\t}\n\n\t// Otherwise, return false\n\treturn false;\n}\n", "CodeBleu_score": 42.56483459726106}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread(&BT::ThreadedAction::tick_thread, this).detach();\n\t}\n\n\tif (exception_) {\n\t\tstd::rethrow_exception(exception_);\n\t}\n\n\treturn status_;\n}\n", "CodeBleu_score": 14.560227319586511}, {"code": "NodeStatus BT::ThreadedAction::executeTick()\t// If the node is currently running, return RUNNING\n\tif (status_ == NodeStatus::RUNNING) {\n\t\treturn status_;\n\t}\n\n\t// If the node is currently halted, return HALTED\n\tif (status_ == NodeStatus::HALTED) {\n\t\treturn status_;\n\t}\n\n\t// If an exception is currently being thrown, rethrow it\n\tif (exception_thrown_) {\n\t\tthrow exception_;\n\t}\n\n\t// Set the node status to RUNNING\n\tstatus_ = NodeStatus::RUNNING;\n\n\t// Reset halt_requested_\n\thalt_requested_ = false;\n\n\t// Start a new thread to run the tick function\n\tstd::thread(&BT::ThreadedAction::tick_thread, this).detach();\n\n\treturn status_;\n}\n", "CodeBleu_score": 17.405366498254583}, {"code": "NodeStatus BT::ThreadedAction::executeTick()\t// If the node is not running, start it\n\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\texecutor_thread_ = std::thread(&BT::ThreadedAction::tick_thread, this);\n\t}\n\t// If the node is running, wait for it to complete\n\telse if (status_ == NodeStatus::RUNNING) {\n\t\texecutor_thread_.join();\n\t}\n\n\t// Check for any exceptions that were thrown in the thread\n\tif (exception_) {\n\t\tstd::rethrow_exception(exception_);\n\t}\n\n\treturn status_;\n}\n", "CodeBleu_score": 24.07452580535303}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tconst TreeNode* node = root_node;\n\tint depth = 0;\n\tstd::function<void(const TreeNode*, int)> print_children = [&print_children, &stream, &depth](const TreeNode* node, int depth) {\n\t\tif (node->has_child()) {\n\t\t\tstream << std::string(depth * 4,'') << node->get_name() << std::endl;\n\t\t\tprint_children(node->get_child(), depth + 1);\n\t\t}\n\t\telse {\n\t\t\tstream << std::string(depth * 4,'') << node->get_name() << std::endl;\n\t\t}\n\t};\n\tstream << std::string(100, '-') << std::endl;\n\tprint_children(node, depth);\n\tstream << std::string(100, '-') << std::endl;\n}\n", "CodeBleu_score": 34.5402037349575}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tstream << std::endl;\n\tstream << \"----------------------------------------\" << std::endl;\n\tstream << \"Tree Structure\" << std::endl;\n\tstream << \"----------------------------------------\" << std::endl;\n\tstream << std::endl;\n\tstd::function<void(const TreeNode*, unsigned int)> print_tree_recursively = [&print_tree_recursively, &stream](const TreeNode* node, unsigned int depth) {\n\t\tstream << std::string(depth, '\\t') << node->name << std::endl;\n\t\tif (node->is_control_node()) {\n\t\t\tfor (const TreeNode* child : node->get_children()) {\n\t\t\t\tprint_tree_recursively(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprint_tree_recursively(node->get_child(), depth + 1);\n\t\t}\n\t};\n\tprint_tree_recursively(root_node, 0);\n\tstream << std::endl;\n\tstream << \"----------------------------------------\" << std::endl;\n\tstream << std::endl;\n}\n", "CodeBleu_score": 41.42468227208311}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\n\t// Define a lambda function to handle printing the children.\n\tauto print_children = [&stream, &print_children](const TreeNode* node, int depth) {\n\t\tfor (const TreeNode* child : node->children) {\n\t\t\tstream << std::string(depth * 4,'') << child->name << std::endl;\n\t\t\tprint_children(child, depth + 1);\n\t\t}\n\t};\n\n\t// Print the root node.\n\tstream << root_node->name << std::endl;\n\n\t// Print the children of the root node.\n\tprint_children(root_node, 1);\n}\n", "CodeBleu_score": 22.276981810600567}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"The node is null\");\n\t}\n\tvisitor(node);\n\tif (node->isControlNode()) {\n\t\tconst ControlNode* controlNode = dynamic_cast<const ControlNode*>(node);\n\t\tfor (const TreeNode* child : controlNode->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->isDecoratorNode()) {\n\t\tconst DecoratorNode* decoratorNode = dynamic_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decoratorNode->child, visitor);\n\t}\n}\n", "CodeBleu_score": 57.47986018414248}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"The given node is null\");\n\t}\n\tvisitor(node);\n\tif (node->isControlNode()) {\n\t\tconst ControlNode* controlNode = dynamic_cast<const ControlNode*>(node);\n\t\tfor (const TreeNode* child : controlNode->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->isDecoratorNode()) {\n\t\tconst DecoratorNode* decoratorNode = dynamic_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decoratorNode->child, visitor);\n\t}\n}\n", "CodeBleu_score": 57.39183032234456}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (!node) {\n\t\tthrow LogicError(\"The given node is null\");\n\t}\n\tvisitor(node);\n\tif (const auto controlNode = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const auto& child : controlNode->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (const auto decoratorNode = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decoratorNode->child, visitor);\n\t}\n}\n", "CodeBleu_score": 58.79458588222555}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tif (builders.find(manifest.registrationID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID \\\"\" + manifest.registrationID + \"\\\" is already registered.\");\n\t}\n\n\tbuilders[manifest.registrationID] = builder;\n\tmanifests[manifest.registrationID] = manifest;\n}\n", "CodeBleu_score": 43.905444978105976}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tif (builders.find(manifest.registration_ID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID \\\"\" + manifest.registration_ID + \"\\\" already exists.\");\n\t}\n\tbuilders[manifest.registration_ID] = builder;\n\tmanifests[manifest.registration_ID] = manifest;\n}\n", "CodeBleu_score": 44.00643880886891}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tif (builders.find(manifest.registration_id)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"A builder with the same ID has already been registered: \" + manifest.registration_id);\n\t}\n\tbuilders[manifest.registration_id] = builder;\n\tmanifests[manifest.registration_id] = manifest;\n}\n", "CodeBleu_score": 45.10193612300418}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\tNodeBuilder builder = [tick_functor](const std::string& name) {\n\t\treturn std::make_shared<SimpleActionNode>(name, tick_functor);\n\t};\n\tregisterBuilder(ID, builder, ports);\n}\n", "CodeBleu_score": 40.345781633585716}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\nNodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {", "CodeBleu_score": 18.828995033534053}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\tNodeBuilder builder = [tick_functor](const std::string& ID) {\n\t\treturn std::make_shared<SimpleActionNode>(ID, tick_functor);\n\t};\n\tregisterBuilder(ID, builder, ports);\n}\n", "CodeBleu_score": 38.14847645078615}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> blackboard_backups;\n\tblackboard_backups.reserve(tree.size());\n\tfor (auto& subtree : tree) {\n\t\tauto blackboard = std::make_shared<Blackboard>();\n\t\tblackboard->Clone(subtree->blackboard);\n\t\tblackboard_backups.push_back(blackboard);\n\t}\n\treturn blackboard_backups;\n}\n", "CodeBleu_score": 49.51438954578597}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> bb_backups;\n\tbb_backups.reserve(tree.GetNumSubTrees());\n\tfor (int i = 0; i < tree.GetNumSubTrees(); ++i) {\n\t\tBlackboard::Ptr bb_backup = std::make_shared<Blackboard>();\n\t\tbb_backup->CopyFrom(*(tree.GetSubTree(i).GetBlackboard()));\n\t\tbb_backups.push_back(bb_backup);\n\t}\n\treturn bb_backups;\n}\n", "CodeBleu_score": 46.99040005776991}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.Size());\n\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tauto backup = std::make_shared<Blackboard>();\n\t\tbackup->Clone(subtree->blackboard);\n\t\tbackups.push_back(backup);\n\t}\n\n\treturn backups;\n}\n", "CodeBleu_score": 53.40355525556576}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (!executor.has_value()) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value().Execute(env);\n}\n\n}  // namespace BT\n", "CodeBleu_score": 71.2196640199196}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tBT::Expected<BT::Executor> executor = ParseScript(script);\n\tif (executor.has_value()) {\n\t\treturn executor.value().Execute(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}\n\n} // namespace BT\n", "CodeBleu_score": 72.39540381811527}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor->Execute(env);\n}\n\n}\n", "CodeBleu_score": 67.68377063785177}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)\t// Acquire the lock\n\tstd::unique_lock<std::mutex> lock(mutex);\n\n\t// If a library is already loaded, throw a RuntimeError\n\tif (handle) {\n\t\tthrow std::runtime_error(\"A library is already loaded\");\n\t}\n\n\t// Attempt to load the library\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\t// If the load failed, retrieve the error message and throw a RuntimeError\n\tif (!handle) {\n\t\tstd::string error = dlerror();\n\t\tthrow std::runtime_error(error);\n\t}\n\n\t// Store the path of the loaded library\n\tthis->path = path;\n}\n", "CodeBleu_score": 56.14682303752431}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::lock_guard<std::mutex> lock(mutex);\n\n\tif (handle) {\n\t\tthrow RuntimeError(\"Library is already loaded\");\n\t}\n\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\tif (!handle) {\n\t\tconst char* error = dlerror();\n\t\tthrow RuntimeError(std::string(\"Failed to load library: \") + error);\n\t}\n\n\tpath_ = path;\n}\n", "CodeBleu_score": 57.5291841071258}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (handle) {\n\t\tthrow std::runtime_error(\"Library already loaded\");\n\t}\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tconst char* error = dlerror();\n\t\tif (error) {\n\t\t\tthrow std::runtime_error(error);\n\t\t}\n\t\tthrow std::runtime_error(\"Unknown error\");\n\t}\n\tthis->path = path;\n}\n", "CodeBleu_score": 59.4058133042618}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.trim();\n\n\tif (stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 23.800908251167062}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView trimmed = str.trim();\n\tif (trimmed.front()!= '{' || trimmed.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer!= nullptr) {\n\t\t*stripped_pointer = trimmed.substr(1, trimmed.size() - 2);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 22.564646368390637}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tstr = str.trim();\n\tif (str[0]!= '{' || str[str.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 22.01070250547426}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble cost = 0.0;\n\tint dx = x1 - x0;\n\tint dy = y1 - y0;\n\tint sx = 0;\n\tint sy = 0;\n\tif (dx < 0) {\n\t\tsx = -1;\n\t\tdx = -dx;\n\t} else {\n\t\tsx = 1;\n\t}\n\tif (dy < 0) {\n\t\tsy = -1;\n\t\tdy = -dy;\n\t} else {\n\t\tsy = 1;\n\t}\n\tint err = dx - dy;\n\tint e2;\n\tint i;\n\tfor (i = 0; i < dx; i++) {\n\t\te2 = 2 * err;\n\t\tif (e2 > -dy) {\n\t\t\terr = err - dy;\n\t\t\tx0 = x0 + sx;\n\t\t}\n\t\tif (e2 < dx) {\n\t\t\terr = err + dx;\n\t\t\ty0 = y0 + sy;\n\t\t}\n\t\tcost += getCost(x0, y0);\n\t}\n\treturn cost;\n}\n", "CodeBleu_score": 32.69718933631383}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble line_cost = 0.0;\n\n\t// Iterate through the line\n\tfor (LineIterator it(x0, y0, x1, y1); it!= it.end(); ++it) {\n\t\t// Get the point cost\n\t\tdouble point_cost = costmap_[it.getIndex()];\n\n\t\t// Update the line cost\n\t\tline_cost = std::max(line_cost, point_cost);\n\n\t\t// If the point cost is negative, return immediately\n\t\tif (point_cost < 0.0) {\n\t\t\treturn point_cost;\n\t\t}\n\t}\n\n\treturn line_cost;\n}\n", "CodeBleu_score": 55.18838057360483}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble cost = 0.0;\n\tint dx = x1 - x0;\n\tint dy = y1 - y0;\n\tint x, y;\n\tint incx, incy, p, delta;\n\n\tif (dx == 0) {\n\t\tif (dy == 0) {\n\t\t\treturn cost;\n\t\t}\n\t\telse if (dy > 0) {\n\t\t\ty = y0;\n\t\t\tinc = 1;\n\t\t}\n\t\telse {\n\t\t\ty = y1;\n\t\t\tinc = -1;\n\t\t}\n\n\t\tfor (x = x0; x <= x1; x++) {\n\t\t\tcost += costmap_[x][y];\n\t\t\ty += inc;\n\t\t}\n\t}\n\telse if (dx > 0) {\n\t\tif (dy == 0) {\n\t\t\tx = x0;\n\t\t\tinc = 1;\n\t\t}\n\t\telse if (dy > 0) {\n\t\t\tp = 2 * dy - dx;\n\t\t\tx = x0;\n\t\t\ty = y0;\n\t\t\tincx = 1;\n\t\t\tincy = 1;\n\t\t}\n\t\telse {\n\t\t\tp = 2 * dy + dx;\n\t\t\tx = x0;\n\t\t\ty = y1;\n\t\t\tincx = 1;\n\t\t\tincy = -1;\n\t\t}\n\n\t\tfor (x = x0; x <= x1; x++) {\n\t\t\tcost += costmap_[x][y];\n\t\t\tif (p < 0) {\n\t\t\t\tp += 2 * dy;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty += incy;\n\t\t\t\tp += 2 * dy - 2 * dx;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (dy == 0) {\n\t\t\tx = x0;\n\t\t\tinc = -1;\n\t\t}\n\t\telse if (dy > 0) {\n\t\t\tp = -2 * dy - dx;\n\t\t\tx = x0;\n\t\t\ty = y0;\n\t\t\tincx = -1;\n\t\t\tincy = 1;\n\t\t}\n\t\telse {\n\t\t\tp = -2 * dy + dx;\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tincx", "CodeBleu_score": 35.75509227514632}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.empty()) {\n\t\treturn;\n\t}\n\tnav_msgs::Path plan;\n\tplan.header.frame_id = path[0].header.frame_id;\n\tplan.header.stamp = path[0].header.stamp;\n\tplan.poses.reserve(path.size());\n\tfor (const auto& pose : path) {\n\t\tplan.poses.push_back(pose);\n\t}\n\tpub.publish(plan);\n}\n", "CodeBleu_score": 53.280145960426985}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.empty())  {\n\t\tROS_INFO(\"Plan is empty, not publishing\");\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Publishing plan\");\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path[0].header.frame_id;\n\tmsg.header.stamp = path[0].header.stamp;\n\tmsg.poses.reserve(path.size());\n\n\tfor (const auto& pose : path)  {\n\t\tmsg.poses.push_back(pose);\n\t}\n\n\tpub.publish(msg);\n}\n", "CodeBleu_score": 51.409619512028634}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.empty()) {\n\t\treturn;\n\t}\n\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path.front().header.frame_id;\n\tmsg.header.stamp = path.front().header.stamp;\n\n\tfor (const auto& pose : path) {\n\t\tmsg.poses.push_back(pose);\n\t}\n\n\tpub.publish(msg);\n}\n", "CodeBleu_score": 42.72610721747604}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) && (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}\n", "CodeBleu_score": 54.528666845813014}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\treturn (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}\n", "CodeBleu_score": 56.58080984271277}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\treturn (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}\n", "CodeBleu_score": 56.58080984271277}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tboost::mutex::scoped_lock lock(configuration_mutex);\n\tif (restore_defaults) {\n\t\tconfig = default_configuration;\n\t}\n\tif (!setup) {\n\t\tdefault_configuration = config;\n\t\tsetup = true;\n\t}\n\tcurrent_configuration = config;\n}\n", "CodeBleu_score": 55.706979008303094}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (restore_defaults) {\n\t\tconfig = default_limits;\n\t}\n\tif (!setup) {\n\t\tdefault_limits = config;\n\t\tsetup = true;\n\t}\n\tstd::lock_guard<std::mutex> lock(configuration_mutex);\n\tcurrent_limits = config;\n}\n", "CodeBleu_score": 49.26912558983057}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\tsetup_ = true;\n\t}\n\n\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tconfig_mutex_.lock();\n\tcurrent_limits_ = config;\n\tconfig_mutex_.unlock();\n}\n", "CodeBleu_score": 63.13339156197893}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)// \tROS_INFO(\"Updating cell\");\n  double new_target_distance = 0.0;\n  bool is_obstacle = false;\n\n  if (check_cell->isObstacle()) {\n    is_obstacle = true;\n    new_target_distance = costmap.getInflateCosts(check_cell->getCenterX(), check_cell->getCenterY());\n  } else {\n    new_target_distance = calculateTargetDistance(current_cell, check_cell, costmap);\n  }\n\n  if (is_obstacle || new_target_distance == costmap.getInflateCosts(check_cell->getCenterX(), check_cell->getCenterY())) {\n    current_cell->setTargetDistance(new_target_distance);\n    return false;\n  } else if (new_target_distance < current_cell->getTargetDistance()) {\n    current_cell->setTargetDistance(new_target_distance);\n    return true;\n  } else {\n    return false;\n  }\n}\n", "CodeBleu_score": 47.5122290031737}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\tdouble new_target_distance = std::numeric_limits<double>::infinity();\n\tif (check_cell->is_obstacle) {\n\t\tnew_target_distance = std::numeric_limits<double>::infinity();\n\t} else {\n\t\tnew_target_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\t}\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 48.16351975183289}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\t// Check if the cell is an obstacle or unknown.\n\tif (costmap.getCost(check_cell->getCenterX(), check_cell->getCenterY()) >= costmap.getObstacleThreshold()) {\n\t\t// If the cell is an obstacle or unknown, set the target distance to the maximum obstacle cost.\n\t\tcurrent_cell->setTargetDistance(std::numeric_limits<double>::max());\n\t\treturn false;\n\t}\n\n\t// Calculate the target distance of the cell.\n\tdouble target_distance = std::hypot(check_cell->getCenterX() - current_cell->getCenterX(),\n\t                                   check_cell->getCenterY() - current_cell->getCenterY());\n\n\t// Check if the new target distance is shorter.\n\tif (target_distance < current_cell->getTargetDistance()) {\n\t\t// If the new target distance is shorter, update the target distance of the cell.\n\t\tcurrent_cell->setTargetDistance(target_distance);\n\t\treturn true;\n\t}\n\n\t// Return false if the new target distance is not shorter.\n\treturn false;\n}\n", "CodeBleu_score": 40.23371573045183}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tdouble cost = 0.0;\n\tdouble scaling_factor = 0.0;\n\tdouble footprint_cost = 0.0;\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty. Cannot calculate cost.\");\n\t\treturn -9.0;\n\t}\n\tfor (int i = 0; i < traj.points.size(); ++i) {\n\t\tfootprint_cost = footprintCost(traj.points[i].pose);\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\tcost += footprint_cost;\n\t\tscaling_factor += scaling_factor_;\n\t}\n\tif (sum_scores_) {\n\t\treturn cost;\n\t} else {\n\t\treturn cost / scaling_factor;\n\t}\n}\n", "CodeBleu_score": 39.74156095858888}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\\t// Initialize the cost and scaling factor based on the trajectory and speed parameters.", "CodeBleu_score": 2.4907753812589584}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tif (footprint_spec_.footprint_points.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty.\");\n\t\treturn -9.0;\n\t}\n\t// Initialize the cost and scaling factor.\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\tif (traj.points.size() < 2) {\n\t\tROS_ERROR(\"Trajectory must have at least 2 points.\");\n\t\treturn -9.0;\n\t}\n\t// Calculate the footprint cost at each point.\n\tfor (int i = 0; i < traj.points.size() - 1; i++) {\n\t\tcost += scorePoint(traj.points[i], scaling_factor);\n\t}\n\t// If the sum_scores_ flag is set, return the sum of the costs.\n\tif (sum_scores_) {\n\t\treturn cost;\n\t}\n\t// Otherwise, return the maximum cost.\n\telse {\n\t\treturn std::max(cost, 0.0);\n\t}\n}\n", "CodeBleu_score": 32.815601317632044}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n//  ROS_INFO(\"footprintCost\");\n  //  ROS_INFO(\"x: %f, y: %f, th: %f, scale: %f\", x, y, th, scale);\n\n  //  ROS_INFO(\"footprint_spec.size(): %d\", footprint_spec.size());\n  double footprint_cost = 0.0;\n  double world_model_cost = 0.0;\n\n  //  ROS_INFO(\"footprint_spec[0].x: %f, footprint_spec[0].y: %f\", footprint_spec[0].x, footprint_spec[0].y);\n\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    //  ROS_INFO(\"footprint_spec[i].x: %f, footprint_spec[i].y: %f\", footprint_spec[i].x, footprint_spec[i].y);\n    footprint_spec[i].x *= scale;\n    footprint_spec[i].y *= scale;\n  }\n\n  if (!costmap->worldToMap(x, y, footprint_spec[0].x, footprint_spec[0].y)) {\n    //  ROS_INFO(\"off map\");\n    return -7.0;\n  }\n\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    double world_model_cost_at_point = world_model->footprintCost(footprint_spec[i].x, footprint_spec[i].y, th);\n    footprint_cost = std::max(footprint_cost, world_model_cost_at_point);\n  }\n\n  //  ROS_INFO(\"footprint_cost: %f\", footprint_cost);\n\n  return std::max(footprint_cost, costmap->getCost(footprint_spec[0].x, footprint_spec[0].y));\n}\n", "CodeBleu_score": 54.52446156728574}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n#if ROS_VERSION == 1\n  return footprintCost1(x, y, th, scale, footprint_spec, costmap, world_model);", "CodeBleu_score": 15.79104352042868}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n//  std::cout << \"footprint cost\" << std::endl;\n", "CodeBleu_score": 8.418410617595558}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic!= odom_topic_) {\n\t\tif (!odom_topic.empty()) {\n\t\t\tROS_INFO(\"Subscribing to odometry topic: %s\", odom_topic.c_str());\n\t\t\tsub_odom_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\tROS_INFO(\"Unsubscribing from odometry topic\");\n\t\t\tsub_odom_.shutdown();\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t}\n}\n", "CodeBleu_score": 37.76878499727285}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic!= odom_topic_) {\n\t\tif (!odom_topic.empty()) {\n\t\t\tsub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\tsub_.shutdown();\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t}\n}\n", "CodeBleu_score": 34.290777091159775}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic == odom_topic_) {\n\t\treturn;\n\t}\n\todom_topic_ = odom_topic;\n\tif (odom_topic_.empty()) {\n\t\todom_sub_.shutdown();\n\t} else {\n\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t}\n}\n", "CodeBleu_score": 39.56047945481197}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tconst float distSq = (pos - prev).squaredNorm();\n\tconst float angleDiff = (pos - prev).normalized().dot(getGoalDirection().normalized());\n\n\tif (distSq > 0.01) {\n\t\t// Reset oscillation flags\n\t\toscillationFlags_.reset();\n\t}\n\telse if (angleDiff > 0.95) {\n\t\t// Reset oscillation flags\n\t\toscillationFlags_.reset();\n\t}\n}\n", "CodeBleu_score": 29.516013636592263}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tconst float dist = (pos - prev).squaredNorm();\n\tconst float angle = angleDiff(pos, prev);\n\n\tif (dist > _squaredDistThreshold) {\n\t\t_oscillationFlags.reset();\n\t} else if (angle > _angleThreshold) {\n\t\t_oscillationFlags.reset();\n\t}\n}\n", "CodeBleu_score": 28.752138363100066}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tif (pos.squaredNorm() > 0.0f) {\n\t\tconst float squaredDistance = (pos - prev).squaredNorm();\n\t\tconst float angularDifference = (pos - prev).norm() * (pos.norm() + prev.norm()) - (pos.dot(prev));\n\t\tif (squaredDistance > squaredDistanceThreshold_ || angularDifference > angularDifferenceThreshold_) {\n\t\t\tresetOscillationFlags();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.269245179384875}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// Determine the grid coordinates of the point.\n\tint x = (int)floor((pt.x - min_x) / cell_size);\n\tint y = (int)floor((pt.y - min_y) / cell_size);\n\n\t// If the point is outside the grid bounds, return without inserting it.\n\tif (x < 0 || x >= num_cells_x || y < 0 || y >= num_cells_y) {\n\t\treturn;\n\t}\n\n\t// Determine the grid index of the point.\n\tint index = y * num_cells_x + x;\n\n\t// If the point is too close to its nearest neighbor, return without inserting it.\n\tif (points[index].size() > 0) {\n\t\tfloat min_dist = std::numeric_limits<float>::max();\n\t\tfor (int i = 0; i < points[index].size(); i++) {\n\t\t\tfloat dist = (pt.x - points[index][i].x) * (pt.x - points[index][i].x) + (pt.y - points[index][i].y) * (pt.y - points[index][i].y);\n\t\t\tif (dist < min_dist) {\n\t\t\t\tmin_dist = dist;\n\t\t\t}\n\t\t}\n\t\tif (min_dist < min_dist_squared) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Insert the point into the grid.\n\tpoints[index].push_back(pt);\n}\n", "CodeBleu_score": 38.11833968571071}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// Check if the point is too close to its nearest neighbor.\n\tif (nearestNeighborDist(pt) < min_dist) {\n\t\treturn;\n\t}\n\n\t// Get the grid coordinates of the point.\n\tint x = std::floor((pt.x - min_x) / resolution);\n\tint y = std::floor((pt.y - min_y) / resolution);\n\n\t// Check if the point is outside the grid bounds.\n\tif (x < 0 || x >= num_cells_x || y < 0 || y >= num_cells_y) {\n\t\treturn;\n\t}\n\n\t// Get the grid index.\n\tint index = y * num_cells_x + x;\n\n\t// Insert the point into the cell.\n\tgrid[index].push_back(pt);\n}\n", "CodeBleu_score": 44.36487487466357}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\tif (!initialized_) {\n\t\tinitialize(pt);\n\t}\n\n\t// Check if the point is too close to its nearest neighbor\n\tif (isTooClose(pt)) {\n\t\treturn;\n\t}\n\n\t// Get the grid coordinates of the point\n\tint x, y;\n\tgetGridCoordinates(pt, x, y);\n\n\t// Check if the point is inside the grid\n\tif (x < 0 || x >= num_cells_x_ || y < 0 || y >= num_cells_y_) {\n\t\treturn;\n\t}\n\n\t// Get the index of the cell\n\tint index = getIndex(x, y);\n\n\t// Insert the point into the cell\n\tcells_[index].insert(pt);\n}\n", "CodeBleu_score": 45.17938112999587}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else if (sample_target_vel[i] < vel[i]) {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 73.56349302760367}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel(i) > vel(i)) {\n\t\t\tnew_vel(i) = std::min(vel(i) + acclimits(i) * dt, sample_target_vel(i));\n\t\t}\n\t\telse if (sample_target_vel(i) < vel(i)) {\n\t\t\tnew_vel(i) = std::max(vel(i) - acclimits(i) * dt, sample_target_vel(i));\n\t\t}\n\t\telse {\n\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 54.68260029692065}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 68.89229133135004}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble goal_x, goal_y, diff, dist;\n\tint i;\n\tbool found = false;\n\n\tfor (i = (int) path_length - 1; i >= 0; i--) {\n\t\tgoal_x = path_x[i];\n\t\tgoal_y = path_y[i];\n\t\tdist = sqrt(pow(goal_x - x, 2) + pow(goal_y - y, 2));\n\t\tif (dist < clearance) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tgoal_x = path_x[i];\n\t\tgoal_y = path_y[i];\n\t\tdiff = atan2(goal_y - y, goal_x - x) - heading;\n\t\tif (diff > M_PI)\n\t\t\tdiff -= 2 * M_PI;\n\t\tif (diff < -M_PI)\n\t\t\tdiff += 2 * M_PI;\n\t\treturn abs(diff);\n\t}\n\telse {\n\t\treturn DBL_MAX;\n\t}\n}\n", "CodeBleu_score": 40.263899354957466}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble diff = DBL_MAX;\n\tdouble dist = 0.0;\n\tdouble x_world = 0.0;\n\tdouble y_world = 0.0;\n\tdouble heading_diff = 0.0;\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint last_i = 0;\n\tint last_j = 0;\n\tint last_k = 0;\n\tint last_cell_x = 0;\n\tint last_cell_y = 0;\n\tint last_cell_z = 0;\n\tint last_cell_i = 0;\n\tint last_cell_j = 0;\n\tint last_cell_k = 0;\n\tint last_cell_i_old = 0;\n\tint last_cell_j_old = 0;\n\tint last_cell_k_old = 0;\n\tint cell_i = 0;\n\tint cell_j = 0;\n\tint cell_k = 0;\n\tint cell_i_old = 0;\n\tint cell_j_old = 0;\n\tint cell_k_old = 0;\n\tint cell_x_old = 0;\n\tint cell_y_old = 0;\n\tint cell_z_old = 0;\n\tint cell_x_world = 0;\n\tint cell_y_world = 0;\n\tint cell_z_world = 0;\n\tint cell_x_world_old = 0;\n\tint cell_y_world_old = 0;\n\tint cell_z_world_old = 0;\n\tint cell_x_world_diff = 0;\n\tint cell_y_world_diff = 0;\n\tint cell_z_world_diff = 0;\n\tint cell_x_world_diff_old = 0;\n\tint cell_y_world_diff_old = 0;\n\tint cell_z_world_diff_old = 0;\n\tint cell_x_world_diff_sum = 0;\n\tint", "CodeBleu_score": 7.400694301720398}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble min_dist = DBL_MAX;\n\tint min_dist_index = -1;\n\tdouble dist_to_goal;\n\tdouble goal_theta;\n\tdouble current_theta;\n\tdouble delta_x, delta_y;\n\tdouble delta_theta;\n\tdouble dist_to_goal_x, dist_to_goal_y;\n\tdouble dist_to_goal_theta;\n\tdouble dist;\n\tdouble dist_to_goal_x_y;\n\tdouble dist_to_goal_x_y_theta;\n\tdouble dist_to_goal_x_theta;\n\tdouble dist_to_goal_y_theta;\n\tdouble dist_to_goal_x_y_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta_theta;\n\tdouble dist_to_goal_x_y_theta_theta_theta_theta_theta_", "CodeBleu_score": 6.1781703148103455}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost < 0) {\n\t\tROS_WARN_STREAM(\"Invalid trajectory: (\" << x << \", \" << y << \", \" << theta << \", \" << vx << \", \" << vy << \", \" << vtheta << \")\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 64.26147840047227}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\t// Check that the requested velocities are achievable.\n\tdouble max_vel_x = std::max(fabs(vx_samp), fabs(vx));\n\tdouble max_vel_y = std::max(fabs(vy_samp), fabs(vy));\n\tdouble max_vel_theta = std::max(fabs(vtheta_samp), fabs(vtheta));\n\tdouble max_vel = std::max(std::max(max_vel_x, max_vel_y), max_vel_theta);\n\tif (max_vel > MAX_PLANNER_VEL) {\n\t\tROS_WARN_STREAM(\"Planner: Exceeded max velocity \" << max_vel << \" > \" << MAX_PLANNER_VEL << \".\");\n\t\treturn false;\n\t}\n\n\t// Check that the requested velocities are achievable.\n\tdouble max_accel_x = fabs(vx_samp - vx) / DT;\n\tdouble max_accel_y = fabs(vy_samp - vy) / DT;\n\tdouble max_accel_theta = fabs(vtheta_samp - vtheta) / DT;\n\tdouble max_accel = std::max(std::max(max_accel_x, max_accel_y), max_accel_theta);\n\tif (max_accel > MAX_PLANNER_ACCEL) {\n\t\tROS_WARN_STREAM(\"Planner: Exceeded max acceleration \" << max_accel << \" > \" << MAX_PLANNER_ACCEL << \".\");\n\t\treturn false;\n\t}\n\n\t// Check that the requested velocities are achievable.\n\tdouble max_jerk_x = fabs(vx_samp - 2 * vx + vx_samp) / pow(DT, 3);\n\tdouble max_jerk_y = fabs(vy_samp - 2 * vy + vy_samp) / pow(DT, 3);\n\tdouble max_jerk_theta = fabs(vtheta_samp - 2 * vtheta + vtheta_samp) / pow(DT, 3);\n\tdouble max_jerk = std::max(std::max(max_jerk_x, max_jerk_y), max_jerk_theta);\n\tif (max_jerk > MAX_PLANNER_JERK", "CodeBleu_score": 38.193092273233674}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\t// Check that the requested velocities are less than the maximum velocities\n\tif (vx > max_vel_x || vy > max_vel_y || vtheta > max_vel_theta) {\n\t\tROS_WARN_STREAM(\"TrajectoryPlanner::checkTrajectory: (\" << x << \", \" << y << \", \" << theta << \", \" << vx << \", \" << vy << \", \" << vtheta << \") exceeds maximum velocity\");\n\t\treturn false;\n\t}\n\n\t// Check that the requested velocities are greater than the minimum velocities\n\tif (vx < min_vel_x || vy < min_vel_y || vtheta < min_vel_theta) {\n\t\tROS_WARN_STREAM(\"TrajectoryPlanner::checkTrajectory: (\" << x << \", \" << y << \", \" << theta << \", \" << vx << \", \" << vy << \", \" << vtheta << \") exceeds minimum velocity\");\n\t\treturn false;\n\t}\n\n\t// Check that the requested position is within the bounds of the world\n\tif (fabs(x) > world_x_max || fabs(y) > world_y_max) {\n\t\tROS_WARN_STREAM(\"TrajectoryPlanner::checkTrajectory: (\" << x << \", \" << y << \", \" << theta << \", \" << vx << \", \" << vy << \", \" << vtheta << \") exceeds world boundaries\");\n\t\treturn false;\n\t}\n\n\t// Check that the requested velocities are less than the maximum accelerations\n\tdouble vx_acc = (vx_samp - vx) / dt;\n\tdouble vy_acc = (vy_samp - vy) / dt;\n\tdouble vtheta_acc = (vtheta_samp - vtheta) / dt;\n\tif (vx_acc > max_accel_x || vy_acc > max_accel_y || vtheta_acc > max_accel_theta) {\n\t\tROS_WARN_STREAM(\"TrajectoryPlanner::checkTrajectory: (\" << x << \", \" << y << \", \" << theta << \", \" << vx << \", \" << vy << \", \" << vtheta << \") exceeds maximum acceleration\");\n\t\treturn false;\n\t}\n\n\t// Check that the requested velocities are greater than the minimum accelerations\n\tif (vx_acc < min_accel_x || vy_acc < min_accel_y || vtheta_", "CodeBleu_score": 37.12573455966763}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()\t// Check if the object is initialized\n\tif (!initialized_) {\n\t\tROS_ERROR(\"ClearCostmapRecovery has not been initialized, but runBehavior() as been called. Please call initialize() to use this recovery behavior.\");\n\t\treturn;\n\t}\n\n\t// Check if the costmap is NULL\n\tif (costmap_ros_->getCostmap() == NULL) {\n\t\tROS_ERROR(\"Costmap is NULL. Please check that the costmap topic is being published, and that the costmap is being properly received.\");\n\t\treturn;\n\t}\n\n\t// Check if the local costmap is NULL\n\tif (costmap_ros_->getCostmap()->getCharMap() == NULL) {\n\t\tROS_ERROR(\"Local costmap is NULL. Please check that the costmap topic is being published, and that the costmap is being properly received.\");\n\t\treturn;\n\t}\n\n\t// Check if the global costmap is NULL\n\tif (costmap_ros_->getGlobalCostmap() == NULL) {\n\t\tROS_ERROR(\"Global costmap is NULL. Please check that the costmap topic is being published, and that the costmap is being properly received.\");\n\t\treturn;\n\t}\n\n\t// Check if the local costmap is inflated\n\tif (!costmap_ros_->getCostmap()->isCostmapInflated()) {\n\t\tROS_WARN(\"Local costmap is not inflated. The costmap recovery behavior will still work, but clearing the costmap will not be optimal. Please call inflateCostmap() to fix this.\");\n\t}\n\n\t// Check if the global costmap is inflated\n\tif (!costmap_ros_->getGlobalCostmap()->isCostmapInflated()) {\n\t\tROS_WARN(\"Global costmap is not inflated. The costmap recovery behavior will still work, but clearing the costmap will not be optimal. Please call inflateCostmap() to fix this.\");\n\t}\n\n\t// Check if the robot is in an area to clear\n\tif (costmap_ros_->getRobotRadius() > 0.0) {\n\t\t// Get the robot's position\n\t\tgeometry_msgs::Point robot_position;\n\t\tif (!costmap_ros_->getRobotPose(robot_position)) {\n\t\t\tROS_ERROR(\"Unable to get robot position.\");\n\t\t\treturn;\n\t\t}\n\n\t\t", "CodeBleu_score": 26.747299884143906}, {"code": "void ClearCostmapRecovery::runBehavior()\tif (!initialized_) {\n\t\tROS_ERROR_STREAM(\"[\" << behavior_name_ << \"]: Behavior is not initialized, but started as active. Please check your code, as this is a bug.\");\n\t\treturn;\n\t}\n\tif (!costmap_ros_) {\n\t\tROS_ERROR_STREAM(\"[\" << behavior_name_ << \"]: Costmap is not set. Please set a costmap using setCostmap()\");\n\t\treturn;\n\t}\n\tif (!costmap_global_) {\n\t\tROS_ERROR_STREAM(\"[\" << behavior_name_ << \"]: Global costmap is not set. Please set a costmap using setCostmap()\");\n\t\treturn;\n\t}\n\tif (!costmap_local_) {\n\t\tROS_ERROR_STREAM(\"[\" << behavior_name_ << \"]: Local costmap is not set. Please set a costmap using setCostmap()\");\n\t\treturn;\n\t}\n\tif (!costmap_global_->isUsingExternalMemory()) {\n\t\tROS_ERROR_STREAM(\"[\" << behavior_name_ << \"]: Global costmap is not using external memory. Please set it to use external memory using setCostmap() or setUseExternalCostmapMemory(true).\");\n\t\treturn;\n\t}\n\tif (!costmap_local_->isUsingExternalMemory()) {\n\t\tROS_ERROR_STREAM(\"[\" << behavior_name_ << \"]: Local costmap is not using external memory. Please set it to use external memory using setCostmap() or setUseExternalCostmapMemory(true).\");\n\t\treturn;\n\t}\n\tif (!costmap_global_->isUpdateable()) {\n\t\tROS_ERROR_STREAM(\"[\" << behavior_name_ << \"]: Global costmap is not updateable. Please set it to updateable using setCostmap() or setUpdateable(true).\");\n\t\treturn;\n\t}\n\tif (!costmap_local_->isUpdateable()) {\n\t\tROS_ERROR_STREAM(\"[\" << behavior_name_ << \"]: Local costmap is not updateable. Please set it to updateable using setCostmap() or setUpdateable(true).\");\n\t\treturn;\n\t}\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN_STREAM(\"[\" << behavior_name_ << \"]: Clearing costmap inside area \"", "CodeBleu_score": 23.292886670266206}, {"code": "void ClearCostmapRecovery::runBehavior()\tif (!initialized_) {\n\t\tROS_ERROR_NAMED(\"clear_costmap_recovery\", \"ClearCostmapRecovery has not been initialized, can't run behavior\");\n\t\treturn;\n\t}\n\tif (!global_costmap_) {\n\t\tROS_ERROR_NAMED(\"clear_costmap_recovery\", \"ClearCostmapRecovery: global costmap is NULL, can't run behavior\");\n\t\treturn;\n\t}\n\tif (!local_costmap_) {\n\t\tROS_ERROR_NAMED(\"clear_costmap_recovery\", \"ClearCostmapRecovery: local costmap is NULL, can't run behavior\");\n\t\treturn;\n\t}\n\n\t// Check if we should be clearing the entire costmap or just a sub-region of it\n\tif (clear_entire_costmap_) {\n\t\t// Clear the entire costmap\n\t\tROS_WARN_NAMED(\"clear_costmap_recovery\", \"Clearing entire costmap\");\n\t\tclearEntireCostmap();\n\t} else {\n\t\t// Check if we should clear the entire local costmap or just a sub-region of it\n\t\tif (clear_local_costmap_) {\n\t\t\t// Clear the entire local costmap\n\t\t\tROS_WARN_NAMED(\"clear_costmap_recovery\", \"Clearing entire local costmap\");\n\t\t\tclearEntireLocalCostmap();\n\t\t} else {\n\t\t\t// Clear a sub-region of the local costmap\n\t\t\tROS_WARN_NAMED(\"clear_costmap_recovery\", \"Clearing local costmap in a %f x %f box\", clear_costmap_recovery.clear_costmap_recovery.clear_costmap_recovery.x_offset, clear_costmap_recovery.clear_costmap_recovery.clear_costmap_recovery.y_offset);\n\t\t\tclearLocalCostmapRegion();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 22.26268505243007}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tpolygon_cells.clear();\n\tpolygon_cells.reserve(polygon.size());\n\tpolygon_cells.push_back(polygon.front());\n\tfor (std::vector<MapLocation>::const_iterator it = polygon.begin() + 1; it!= polygon.end(); ++it) {\n\t\traytraceLine(polygon_cells.back(), *it, polygon_cells);\n\t}\n\traytraceLine(polygon_cells.back(), polygon.front(), polygon_cells);\n}\n", "CodeBleu_score": 32.07196298372474}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\tMapLocation current_point = polygon.back();\n\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation next_point = polygon[i];\n\n\t\tpolygon_cells.clear();\n\t\traytraceLine(current_point, next_point, polygon_cells);\n\n\t\tcurrent_point = next_point;\n\t}\n\n\tpolygon_cells.clear();\n\traytraceLine(current_point, polygon.front(), polygon_cells);\n}\n", "CodeBleu_score": 43.93562408986742}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tif (polygon.size() < 3) {\n\t\tROS_WARN(\"Costmap2D::polygonOutlineCells: polygon must have at least 3 vertices\");\n\t\treturn;\n\t}\n\tpolygon_cells.clear();\n\tMapLocation last_point = polygon[polygon.size() - 1];\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation current_point = polygon[i];\n\t\tif (current_point == last_point) {\n\t\t\tROS_WARN(\"Costmap2D::polygonOutlineCells: polygon cannot have consecutive duplicate vertices\");\n\t\t\treturn;\n\t\t}\n\t\traytraceLine(last_point, current_point, polygon_cells);\n\t\tlast_point = current_point;\n\t}\n\traytraceLine(polygon[polygon.size() - 1], polygon[0], polygon_cells);\n}\n", "CodeBleu_score": 47.479332562771745}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t// Prepare the grid data\n\tprepareGrid();\n\n\t// Publish the grid\n\tpublishGrid();\n}\n", "CodeBleu_score": 27.44532197697771}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\tROS_INFO(\"New subscriber to costmap_2d detected. Preparing costmap_2d grid data...\");\n\tprepareGrid();\n\tROS_INFO(\"Publishing costmap_2d grid data to new subscriber...\");\n\tpub.publish(grid_data_);\n\tROS_INFO(\"Done publishing costmap_2d grid data to new subscriber.\");\n}\n", "CodeBleu_score": 51.06531159987775}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\tprepareGrid();\n\tpub.publish(grid);\n}\n", "CodeBleu_score": 66.00860259586796}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()\tmutex_.lock();\n\tcostmap_ = costmap_ros_->getCostmap();\n\tcostmap_ros_->getCostmap()->lockRead();\n\tresolution_ = costmap_ros_->getCostmap()->getResolution();\n\twidth_ = costmap_ros_->getCostmap()->getSizeInCellsX();\n\theight_ = costmap_ros_->getCostmap()->getSizeInCellsY();\n\torigin_x_ = costmap_ros_->getCostmap()->getOriginX();\n\torigin_y_ = costmap_ros_->getCostmap()->getOriginY();\n\torigin_z_ = costmap_ros_->getCostmap()->getOriginZ();\n\torigin_orientation_ = costmap_ros_->getCostmap()->getOriginYaw();\n\tmap_width_ = costmap_ros_->getCostmap()->getSizeInMetersX();\n\tmap_height_ = costmap_ros_->getCostmap()->getSizeInMetersY();\n\n\t// Convert map coordinates to world coordinates\n\torigin_x_ = origin_x_ + map_width_ / 2.0;\n\torigin_y_ = origin_y_ + map_height_ / 2.0;\n\torigin_z_ = 0.0;\n\torigin_orientation_ = 0.0;\n\n\t// Resize grid data vector\n\tgrid_data_.resize(width_ * height_);\n\n\t// Populate grid data from costmap\n\tfor (int i = 0; i < height_; i++) {\n\t\tfor (int j = 0; j < width_; j++) {\n\t\t\tint index = i * width_ + j;\n\t\t\tint cost = costmap_ros_->getCostmap()->getCost(j, i);\n\t\t\tgrid_data_[index] = cost;\n\t\t}\n\t}\n\n\tcostmap_ros_->getCostmap()->unlockRead();\n\tmutex_.unlock();\n}\n", "CodeBleu_score": 34.748777871955106}, {"code": "void Costmap2DPublisher::prepareGrid()\t// Lock the costmap mutex\n\tmutex_.lock();\n\n\t// Get the costmap resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\n\t// Set the grid's resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tgeometry_msgs::PointStamped origin;\n\torigin.header.stamp = grid_.header.stamp;\n\torigin.header.frame_id = grid_.header.frame_id;\n\torigin.point.x = costmap_->getOriginX();\n\torigin.point.y = costmap_->getOriginY();\n\torigin.point.z = 0;\n\ttf_listener_.transformPoint(grid_.header.frame_id, origin, origin);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin.point.x;\n\tgrid_.info.origin.position.y = origin.point.y;\n\tgrid_.info.origin.position.z = 0;\n\ttf2::Quaternion quat;\n\tquat.setRPY(0, 0, costmap_->getOriginYaw());\n\tgrid_.info.origin.orientation.x = quat.x();\n\tgrid_.info.origin.orientation.y = quat.y();\n\tgrid_.info.origin.orientation.z = quat.z();\n\tgrid_.info.origin.orientation.w = quat.w();\n\n\t// Save the origin coordinates\n\torigin_x_ = origin.point.x;\n\torigin_y_ = origin.point.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < grid_.info.width; i++) {\n\t\tfor (unsigned int j = 0; j <", "CodeBleu_score": 57.19305143403252}, {"code": "void Costmap2DPublisher::prepareGrid()\tmutex_.lock();\n\tfloat resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = costmap_->getFrameId();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tint index = 0;\n\tfor (int i = 0; i < grid_.info.height; ++i) {\n\t\tfor (int j = 0; j < grid_.info.width; ++j) {\n\t\t\tgrid_.data[index] = costmap_->getCharMap()[i * grid_.info.width + j];\n\t\t\tindex++;\n\t\t}\n\t}\n\tmutex_.unlock();\n}\n", "CodeBleu_score": 54.12614053535132}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\\t// If the footprint and robot radius in the new and old configurations are the same, return immediately.\\n\\tif (new_config.robot_radius == old_config.robot_radius && new_config.footprint_model.footprint == old_config.footprint_model.footprint) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// If the new configuration contains a valid footprint string, convert the string to a footprint and set it.\\n\\tif (!new_config.footprint_model.footprint.empty()) {\\n\\t\\tstd::vector<geometry_msgs::Point> footprint;\\n\\t\\tstd::stringstream ss(new_config.footprint_model.footprint);\\n\\t\\tstd::string item;\\n\\t\\tgeometry_msgs::Point point;\\n\\t\\twhile (std::getline(ss, item, ';')) {\\n\\t\\t\\tstd::stringstream item_stream(item);\\n\\t\\t\\titem_stream >> point.x >> point.y;\\n\\t\\t\\tfootprint.push_back(point);\\n\\t\\t}\\n\\t\\tsetFootprint(footprint);\\n\\t} else {\\n\\t\\t// If the footprint string is invalid, log an error.\\n\\t\\tROS_ERROR(\\\"Invalid footprint provided. Using default footprint.\\\");\\n\\n\\t\\t// Set the footprint based on the robot radius.\\n\\t\\tdouble radius = new_config.robot_radius;\\n\\t\\tsetFootprintFromRadius(radius);\\n\\t}\\n}\\n\\n/*\\n * This function, Costmap2DROS::readTransformFromConfig, updates the transform based on the new configuration.\\nIf the transform and robot radius in the new and old configurations are the same, it returns immediately.\\nIf the new configuration contains a valid transform string, it converts the string to a transform and sets it.\\nIf the transform string is invalid, it logs an error.\\nIf no valid transform string is provided, it sets the transform based on the robot radius.\n */", "CodeBleu_score": 5.413274539522901}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\\t// Check if the footprint is the same", "CodeBleu_score": 4.687517889498513}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\\t// If the footprint and robot radius are the same, return immediately.", "CodeBleu_score": 4.699491218414551}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\tif (getRobotPose(new_pose)) {\n\t\tif (new_pose.header.frame_id!= robot_frame) {\n\t\t\tROS_WARN(\"Costmap2DROS: Robot pose frame does not match the costmap frame. Costmap will not be updated. Costmap frame: %s, Robot pose frame: %s\", costmap_frame.c_str(), new_pose.header.frame_id.c_str());\n\t\t\treturn;\n\t\t}\n\t}\n\telse {\n\t\tROS_WARN(\"Costmap2DROS: Failed to get robot pose. Costmap will not be updated.\");\n\t\treturn;\n\t}\n}\n", "CodeBleu_score": 43.5142271905559}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\\t\\ttry {", "CodeBleu_score": 9.368782296570703}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\tif (!initialized_) {\n\t\tROS_WARN(\"Costmap2DROS: Movement callback called before initialization, ignoring\");\n\t\treturn;\n\t}\n\n\tgeometry_msgs::PoseStamped current_pose;\n\ttry {\n\t\tcurrent_pose = tf_.lookupTransform(global_frame_, robot_base_frame_, ros::Time(0));\n\t} catch (tf::TransformException &ex) {\n\t\tROS_WARN(\"Costmap2DROS: Failed to get current pose: %s\", ex.what());\n\t\treturn;\n\t}\n\n\tnew_pose.x = current_pose.pose.position.x;\n\tnew_pose.y = current_pose.pose.position.y;\n\tnew_pose.theta = tf::getYaw(current_pose.pose.orientation);\n}\n", "CodeBleu_score": 41.15849507298666}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()\\t\\t// Retrieve list of plugins", "CodeBleu_score": 7.444064672242476}, {"code": "void Costmap2DROS::start()\tif (initialized_) {\n\t\tROS_INFO(\"Costmap2DROS::start() called on an already initialized costmap, doing nothing\");\n\t\treturn;\n\t}\n\tif (!ros::isStarted()) {\n\t\tROS_INFO(\"Costmap2DROS::start() called on an uninitialized costmap, but ROS is not yet initialized, waiting for initialization\");\n\t\twhile (!ros::isStarted()) {\n\t\t\tros::WallDuration(0.05).sleep();\n\t\t}\n\t\tROS_INFO(\"ROS is now initialized, resuming start()\");\n\t}\n\tif (stop_updates_) {\n\t\tROS_INFO(\"Costmap2DROS::start() called on a stopped costmap, restarting\");\n\t\tstop_updates_ = false;\n\t\t// get the list of plugins\n\t\tstd::vector<std::string> plugin_list;\n\t\tstd::string plugin_name;\n\t\tplugin_name = name_ + \"/plugins\";\n\t\tif (nh_.hasParam(plugin_name)) {\n\t\t\tnh_.getParam(plugin_name, plugin_list);\n\t\t}\n\t\t// re-subscribe to all topics\n\t\tfor (unsigned int i = 0; i < plugin_list.size(); i++) {\n\t\t\tROS_DEBUG(\"Costmap2DROS::start() activating plugin %s\", plugin_list[i].c_str());\n\t\t\tnh_.subscribe(plugin_list[i] + \"/inflated_costmap\", 1, &Costmap2DROS::inflated_costmap_callback, this);\n\t\t\tnh_.subscribe(plugin_list[i] + \"/obstacle_layer\", 1, &Costmap2DROS::obstacle_layer_callback, this);\n\t\t\tnh_.subscribe(plugin_list[i] + \"/raw_costmap\", 1, &Costmap2DROS::raw_costmap_callback, this);\n\t\t\tnh_.subscribe(plugin_list[i] + \"/voxel_layer\", 1, &Costmap2DROS::voxel_layer_callback, this);\n\t\t}\n\t}\n\t// wait for the map to be initialized\n\twhile (!initialized_) {\n\t\tros::WallDuration(0.05).sleep();\n\t}\n\t// wait for the map update thread to be active\n\twhile", "CodeBleu_score": 36.002310964698694}, {"code": "void Costmap2DROS::start()\t// Get list of plugins\n\tstd::vector<std::string> plugin_names;\n\tplugin_lib_.getAllPlugins(plugin_names);\n\n\t// Check if the costmap was stopped\n\tif (std::find(plugin_names.begin(), plugin_names.end(), \"obstacle_layer\")!= plugin_names.end() || std::find(plugin_names.begin(), plugin_names.end(), \"inflation_layer\")!= plugin_names.end()) {\n\t\tROS_INFO(\"Costmap2DROS::start(): costmap is stopped. Re-activating plugins.\");\n\n\t\t// Activate each plugin\n\t\tfor (unsigned int i = 0; i < plugin_names.size(); i++) {\n\t\t\tif (plugin_lib_.isClassAvailable(plugin_names[i])) {\n\t\t\t\tplugin_lib_.activatePlugin(plugin_names[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Set stopped flag to false\n\t\tstopped_ = false;\n\n\t\t// Set stop_updates_ to false\n\t\tstop_updates_ = false;\n\n\t\t// Wait until ROS is running and the costmap is initialized\n\t\twhile (!initialized_ ||!update_thread_.isRunning()) {\n\t\t\tros::WallDuration(0.01).sleep();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.72753483279275}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\t// Find the first valid observation\n\tauto it = observations_.begin();\n\tfor (; it!= observations_.end(); ++it) {\n\t\tif (it->second.is_valid()) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Remove all observations that are older than the keep time\n\tfor (; it!= observations_.end(); ++it) {\n\t\tif (it->second.timestamp_ < timestamp() - observation_keep_time_) {\n\t\t\tobservations_.erase(it);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.894597854321574}, {"code": "void ObservationBuffer::purgeStaleObservations()\t// If the keep time is 0, then we don't need to purge anything.\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\n\t// Iterate through the list of observations, removing any that are older than the keep time.\n\t// Stop if we find a valid observation.\n\tObservationList::iterator iter = observations_.begin();\n\twhile (iter!= observations_.end()) {\n\t\t// If the observation is valid, then stop.\n\t\tif (iter->second.isValid()) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// If the observation is too old, remove it.\n\t\tif (iter->second.getAge() > observation_keep_time_) {\n\t\t\tobservations_.erase(iter++);\n\t\t} else {\n\t\t\t++iter;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.52464790435983}, {"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\tfor (auto it = observations_.begin(); it!= observations_.end(); ++it) {\n\t\tif (it->second.timestamp_ > observation_keep_time_) {\n\t\t\tit = observations_.erase(it);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 29.143077394572874}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\t// Get the yaw angle of the start and end poses\n\tdouble start_yaw = tf::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end poses\n\tdouble yaw_diff = shortestAngularDistance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in angle for each pose in the path\n\tdouble yaw_incr = yaw_diff / (end_index - start_index);\n\n\t// Update the orientation of each pose in the path\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble yaw = start_yaw + yaw_incr * (i - start_index);\n\t\tpath[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n\t}\n}\n", "CodeBleu_score": 59.969281436077296}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\t// Check that the start and end indices are valid\n\tif (start_index < 0 || start_index >= (int)path.size() || end_index < 0 || end_index >= (int)path.size()) {\n\t\tROS_ERROR(\"Invalid start or end index in interpolate function\");\n\t\treturn;\n\t}\n\t// Get the yaw angles at the start and end indices\n\tdouble start_yaw = tf::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble yaw_dist = shortestAngularDistance(start_yaw, end_yaw);\n\t// Check if the path is not empty\n\tif (yaw_dist!= 0) {\n\t\t// Compute the incremental change in yaw angle for each pose\n\t\tdouble yaw_inc = (end_yaw - start_yaw) / (end_index - start_index);\n\t\t// Update the orientation of each pose in the specified range\n\t\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t\t// Get the current pose\n\t\t\tgeometry_msgs::PoseStamped& pose = path[i];\n\t\t\t// Get the current yaw angle\n\t\t\tdouble yaw = tf::getYaw(pose.pose.orientation);\n\t\t\t// Calculate the new yaw angle\n\t\t\tdouble new_yaw = yaw + yaw_inc;\n\t\t\t// Update the pose's orientation\n\t\t\tpose.pose.orientation = tf::createQuaternionMsgFromYaw(new_yaw);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 51.154051996821416}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\tdouble start_yaw = tf::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\tdouble yaw_diff = shortestAngularDistance(start_yaw, end_yaw);\n\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble yaw = tf::getYaw(path[i].pose.orientation);\n\t\tdouble yaw_incr = shortestAngularDistance(yaw, yaw_diff);\n\t\tpath[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw + yaw_incr);\n\t}\n}\n", "CodeBleu_score": 53.43403279387389}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tROS_INFO(\"Received a make_plan service request\");\n\tROS_INFO(\"The start pose is (%f, %f, %f)\", req.start.pose.position.x, req.start.pose.position.y, req.start.pose.position.z);\n\tROS_INFO(\"The goal pose is (%f, %f, %f)\", req.goal.pose.position.x, req.goal.pose.position.y, req.goal.pose.position.z);\n\n\t// Set the start and goal poses in the costmap\n\tcostmap_2d::Costmap2DROS* costmap_ros = costmap_ros_.get();\n\tgeometry_msgs::PoseStamped start_pose = req.start;\n\tstart_pose.header.frame_id = costmap_ros->getGlobalFrameID();\n\tgeometry_msgs::PoseStamped goal_pose = req.goal;\n\tgoal_pose.header.frame_id = costmap_ros->getGlobalFrameID();\n\tcostmap_ros->setStartPosition(start_pose.pose.position.x, start_pose.pose.position.y);\n\tcostmap_ros->setGoalPosition(goal_pose.pose.position.x, goal_pose.pose.position.y);\n\n\t// Make the plan\n\tnavfn::MakeNavPlan::Response plan;\n\tif (makePlan(plan)) {\n\t\tresp = plan;\n\t\treturn true;\n\t}\n\telse {\n\t\tROS_WARN(\"No path found.\");\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 40.03788051210692}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tROS_INFO(\"Received a new plan request\");\n\t// set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\t// call makePlan to generate a path\n\tnavfn::MakeNavPlan::Response plan = makePlan(req.start, req.goal);\n\t// check if a path was found\n\tif (plan.plan.poses.size() > 0) {\n\t\t// if a path was found, update the response\n\t\tresp.plan = plan.plan;\n\t\tresp.success = true;\n\t\tROS_INFO(\"Plan found\");\n\t\treturn true;\n\t} else {\n\t\tROS_WARN(\"No plan found\");\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 54.09640062057635}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tROS_INFO(\"Received a new plan request\");\n\tresp.plan_found = false;\n\tresp.plan.poses.clear();\n\n\t// Set the start and goal points\n\tstart.x = req.start.pose.position.x;\n\tstart.y = req.start.pose.position.y;\n\tstart.theta = tf::getYaw(req.start.pose.orientation);\n\n\tgoal.x = req.goal.pose.position.x;\n\tgoal.y = req.goal.pose.position.y;\n\tgoal.theta = tf::getYaw(req.goal.pose.orientation);\n\n\t// Set the frame_id to \"map\"\n\tstart.header.frame_id = \"map\";\n\tgoal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tmakePlan();\n\n\t// If a path was found, set the plan_found flag to true and copy the path to the response\n\tif (path.poses.size() > 0) {\n\t\tresp.plan_found = true;\n\t\tresp.plan = path;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 52.20554720872457}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\tros::NodeHandle n;\n\tmake_plan_service = n.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\n\tgoal_sub = n.subscribe(\"goal\", 10, &PlannerWithCostmap::goalCallback, this);\n}\n", "CodeBleu_score": 50.279108129611714}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()) *\n * @param name\n * @param cmap\n */", "CodeBleu_score": 24.588814824080515}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\tros::NodeHandle nh;\n\tros::Subscriber goal_sub = nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n\tmake_plan_service = nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n}\n", "CodeBleu_score": 52.66544798155878}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (wx < costmap_origin_x_ && wy < costmap_origin_y_) {\n\t\tmx = round((wx - costmap_origin_x_) / costmap_resolution_);\n\t\tmy = round((wy - costmap_origin_y_) / costmap_resolution_);\n\t\tif (mx < costmap_width_ && my < costmap_height_) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 37.86123192407393}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (wx < origin_x_ || wy < origin_y_ || wx > origin_x_ + map_width_ || wy > origin_y_ + map_height_) {\n\t\treturn false;\n\t}\n\n\tmx = (wx - origin_x_) / resolution_;\n\tmy = (wy - origin_y_) / resolution_;\n\n\treturn true;\n}\n", "CodeBleu_score": 35.362709410405955}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (wx < costmap_origin_x_ || wy < costmap_origin_y_ || wx > costmap_origin_x_ + costmap_width_ || wy > costmap_origin_y_ + costmap_height_) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_origin_x_) / costmap_resolution_;\n\tmy = (wy - costmap_origin_y_) / costmap_resolution_;\n\treturn true;\n}\n", "CodeBleu_score": 38.32882493429594}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif (!initialized_) {\n\t\tROS_ERROR(\"Global planner has not been initialized, cannot publish plan\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Publishing plan\");\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = global_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\tfor (const auto& pose : path) {\n\t\tgui_path.poses.push_back(pose);\n\t}\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 48.254997091157406}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tROS_INFO(\"Publishing Plan\");\n\tif (!initialized_) {\n\t\tROS_ERROR(\"Global planner has not been initialized, cannot publish plan\");\n\t\treturn;\n\t}\n\n\t// Create a message and populate it\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = global_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses.push_back(path[i]);\n\t}\n\n\t// Publish the plan\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 65.92475729304059}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tROS_INFO_STREAM(\"Publishing plan\");\n\tif (!initialized_) {\n\t\tROS_ERROR_STREAM(\"Global planner has not been initialized yet, cannot publish plan\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = \"world\";\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (const auto& pose : path) {\n\t\tgui_path.poses.push_back(pose);\n\t}\n\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 49.73691935772994}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG_STREAM(\"MoveBase::goalCB has been called\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 68.12322667323382}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG_STREAM(\"Received a new goal\");\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal = *goal;\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 58.551523261531614}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG_STREAM(\"Received a goal\");\n\tactionlib_msgs::GoalID goalID;\n\tgoalID.stamp = ros::Time::now();\n\tgoalID.id = \"move_base\";\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = goalID.stamp;\n\taction_goal.header.frame_id = \"odom\";\n\taction_goal.goal_id = goalID;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 64.27610849853151}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tdouble squaredLimit = limit * limit;\n\tdouble squaredDistance = distance * distance;\n\tif (squaredDistance > squaredLimit) {\n\t\tROS_INFO(\"Slowing down and clearing distance limit\");\n\t\tif (removeLimitThread!= NULL) {\n\t\t\tremoveLimitThread->join();\n\t\t\tdelete removeLimitThread;\n\t\t}\n\t\tremoveLimitThread = new std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistanceTimer.stop();\n\t}\n}\n", "CodeBleu_score": 46.522913410980415}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tdouble squaredLimit = pow(limit, 2);\n\tdouble squaredDistance = pow(distance, 2);\n\tif (squaredDistance > squaredLimit) {\n\t\tROS_INFO(\"The robot has moved %f meters, which is more than the limit of %f meters. The robot will now slow down.\", distance, limit);\n\t\tif (removeLimitThread.joinable()) {\n\t\t\tremoveLimitThread.join();\n\t\t}\n\t\tremoveLimitThread = std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\ttimer.stop();\n\t}\n}\n", "CodeBleu_score": 41.796839657133724}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tdouble currentDistance = sqrt(pow(robot_pose.pose.position.x, 2) + pow(robot_pose.pose.position.y, 2));\n\tdouble squaredLimit = pow(distanceLimit, 2);\n\tdouble squaredDistance = pow(currentDistance, 2);\n\tif (squaredDistance > squaredLimit) {\n\t\tROS_INFO(\"Robot has moved %f meters. Clearing speed limit.\", currentDistance);\n\t\tspeedLimitThread.join();\n\t\tspeedLimitThread = std::thread(&MoveSlowAndClear::clearSpeedLimit, this);\n\t\tdistanceCheckTimer.stop();\n\t}\n}\n", "CodeBleu_score": 48.22694921629797}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\tgeometry_msgs::PoseStamped pose = getRobotPose();\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tmakePlan(pose, goal->pose, path);\n\tif (path.size() > 0) {\n\t\tpublishPlan(path);\n\t}\n}\n", "CodeBleu_score": 49.90269392559515}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\t// Get the current pose of the robot\n\tgeometry_msgs::PoseStamped current_pose = getRobotPose();\n\t// Generate a path from the current pose to the goal pose\n\tmakePlan(current_pose, goal->pose, path);\n}\n", "CodeBleu_score": 38.092703779589264}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\t// Get the current robot pose.\n\tgeometry_msgs::PoseStamped robot_pose = getRobotPose();\n\n\t// Make a plan from the current pose to the goal pose.\n\tmakePlan(robot_pose, goal->pose, path);\n}\n", "CodeBleu_score": 38.12020791129706}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\t// Create a service request\n\tmavros_msgs::SetMode srv;\n\tsrv.request.base_mode = 0;\n\tsrv.request.custom_mode = \"OFFBOARD\";\n\t// Set the parameter ID and value\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.param_value = param_set.param_value;\n\t// Send the request\n\tparam_set_client_.call(srv);\n}\n", "CodeBleu_score": 56.29447027457526}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tROS_INFO(\"Gimbal param set server\");\n\tmavros_msgs::ParamSet param_srv;\n\tparam_srv.param_id = param_set.param_id;\n\tparam_srv.value = param_set.value;\n\tparam_set_client_.call(param_srv);\n}\n", "CodeBleu_score": 52.54361048272192}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\t// Create a service request\n\tmavros_msgs::ParamSetRequest request;\n\trequest.param_id = param_set.param_id;\n\trequest.value = param_set.value;\n\n\t// Send the request\n\tparam_set_client_.call(request);\n}\n", "CodeBleu_score": 54.59896463252394}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()\tROS_INFO(\"Server thread started\");\n\tros::NodeHandle n;\n\tros::Subscriber sub = n.subscribe(\"CommunicationBridge/pub\", 1000, &CommunicationBridge::serverCallback, this);\n\tros::spin();\n}\n", "CodeBleu_score": 8.291393607944636}, {"code": "void CommunicationBridge::serverFun()\tint serverSocket, newSocket, clientAddressLength;\n\tsockaddr_in clientAddress;\n\tchar buffer[1024];\n\tint receivedBytes;\n\tstring message;\n\n\tserverSocket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverSocket < 0) {\n\t\tROS_ERROR(\"Could not create socket.\\n\");\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Socket created.\\n\");\n\n\tserverAddress.sin_family = AF_INET;\n\tserverAddress.sin_port = htons(SERVER_PORT);\n\tserverAddress.sin_addr.s_addr = INADDR_ANY;\n\n\tif (bind(serverSocket, (sockaddr *) &serverAddress, sizeof(serverAddress)) < 0) {\n\t\tROS_ERROR(\"Could not bind socket.\\n\");\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Socket bound.\\n\");\n\n\tif (listen(serverSocket, 1) < 0) {\n\t\tROS_ERROR(\"Could not listen on socket.\\n\");\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Socket listening.\\n\");\n\n\tclientAddressLength = sizeof(clientAddress);\n\tnewSocket = accept(serverSocket, (sockaddr *) &clientAddress, (socklen_t *) &clientAddressLength);\n\n\tif (newSocket < 0) {\n\t\tROS_ERROR(\"Could not accept connection.\\n\");\n\t\treturn;\n\t}\n\n\tROS_INFO(\"Connection accepted.\\n\");\n\n\twhile (true) {\n\t\tmemset(buffer, 0, 1024);\n\t\treceivedBytes = recv(newSocket, buffer, 1024, 0);\n\t\tif (receivedBytes <= 0) {\n\t\t\tROS_ERROR(\"Could not receive data.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tROS_INFO(\"Data received.\\n\");\n\n\t\tmessage = buffer;\n\t\tif (message.length() <= 0) {\n\t\t\tROS_ERROR(\"Received message length is zero or less.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tROS_INFO(\"Message decoded.\\n\");\n\n\t\tpub.publish(message);\n\t}\n}\n", "CodeBleu_score": 39.970469581057905}, {"code": "void CommunicationBridge::serverFun()\tROS_INFO(\"Server thread started\");\n\t// Create a TCP/IP socket\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n\t\tROS_ERROR(\"ERROR opening socket\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Socket created\");\n\t// Bind the socket to the port\n\tstruct sockaddr_in serv_addr;\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(port);\n\tif (bind(sock, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tROS_ERROR(\"ERROR on binding\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Socket bound\");\n\t// Listen for incoming connections\n\tif (listen(sock, 5) < 0) {\n\t\tROS_ERROR(\"ERROR on listen\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Listening\");\n\twhile (ros::ok()) {\n\t\t// Wait for a connection\n\t\tROS_INFO(\"Waiting for a connection\");\n\t\tstruct sockaddr_in cli_addr;\n\t\tsocklen_t clilen = sizeof(cli_addr);\n\t\tint newsockfd = accept(sock, (struct sockaddr *) &cli_addr, &clilen);\n\t\tif (newsockfd < 0) {\n\t\t\tROS_ERROR(\"ERROR on accept\");\n\t\t\treturn;\n\t\t}\n\t\tROS_INFO(\"Connection accepted\");\n\t\t// Receive a message\n\t\tchar buffer[256];\n\t\tint n = recv(newsockfd, buffer, 256, 0);\n\t\tif (n <= 0) {\n\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\treturn;\n\t\t}\n\t\tROS_INFO(\"Received %d bytes\", n);\n\t\t// Decode the message\n\t\tstd_msgs::String msg;\n\t\tmsg.data = buffer;\n\t\t// Publish the message\n\t\tpub.publish(msg);\n\t\tROS_INFO(\"Published message\");\n\t\t// Close the socket\n\t\tclose(newsockfd);\n\t}\n\t// Close the socket\n\tclose(sock);\n}\n\n", "CodeBleu_score": 44.1215386363092}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (simulation_mode_ == false) {\n\t\tuav_basic_ uav_pub;\n\t\tuav_pub.publishCommand(uav_cmd);\n\t} else {\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].getID() == uav_cmd.id) {\n\t\t\t\tswarm_control_simulation_[i].publishCommand(uav_cmd);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.74301687280124}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (sim_mode_) {\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].uav_id_ == uav_cmd.uav_id_) {\n\t\t\t\tswarm_control_simulation_[i].uav_cmd_ = uav_cmd;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 36.892394684373066}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (simulation_mode) {\n\t\t// Find the UAV with the matching ID\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].id == uav_cmd.id) {\n\t\t\t\t// Publish the command to the UAV\n\t\t\t\tswarm_control_simulation_[i].uav_control_pub.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Publish the command to the UAV\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 36.283180397051794}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tstd::string command = \"reboot\";\n\t\tsystem(command.c_str());\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tstd::string command = \"shutdown now\";\n\t\tsystem(command.c_str());\n\t} else if (mode_selection.use_mode == CREATE_MODE) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == DELETE_MODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}\n", "CodeBleu_score": 61.30609351635573}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == REBOOTNX) {\n\t\t// TODO: add reboot command here\n\t\treturn;\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\t// TODO: add exit command here\n\t\treturn;\n\t} else if (mode_selection.use_mode == CREATE_MODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETE_MODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}\n", "CodeBleu_score": 42.500907409277325}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == REBOOTNX) {\n\t\t// Reboot the system\n\t\tsystem(\"reboot\");\n\t}\n\telse if (mode_selection.use_mode == EXITNX) {\n\t\t// Exit the program\n\t\texit(0);\n\t}\n\telse if (mode_selection.use_mode == CREATE_MODE) {\n\t\t// Create a mode\n\t\tcreateMode(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == DELETE_MODE) {\n\t\t// Delete a mode\n\t\tdeleteMode(mode_selection);\n\t}\n}\n", "CodeBleu_score": 54.01042048503704}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\t// If the vehicle is not a swarm vehicle, set the heartbeat_flag to true.\n\tif (vehicle_type!= swarm) {\n\t\theartbeat_flag = true;\n\t\treturn;\n\t}\n\n\t// If the vehicle is a swarm vehicle, check if the heartbeat_flag is true.\n\tif (heartbeat_flag) {\n\t\t// If the heartbeat_flag is true, increment the heartbeat_counter.\n\t\theartbeat_counter++;\n\t}\n\telse {\n\t\t// If the heartbeat_flag is false, set the heartbeat_counter to 0.\n\t\theartbeat_counter = 0;\n\t}\n\n\t// If the heartbeat_counter exceeds the maximum number of missed heartbeats, print an error message and trigger the appropriate actions based on the vehicle type.\n\tif (heartbeat_counter >= max_heartbeat_attempts) {\n\t\tROS_ERROR(\"Heartbeat counter exceeded maximum number of attempts. Vehicle is disconnected.\");\n\t\tif (vehicle_type == swarm) {\n\t\t\t// If the vehicle is a swarm vehicle, set the disconnect_flag to true.\n\t\t\tdisconnect_flag = true;\n\t\t\t// Set the heartbeat_flag to false.\n\t\t\theartbeat_flag = false;\n\t\t}\n\t\telse if (vehicle_type == uav) {\n\t\t\t// If the vehicle is an UAV vehicle, set the UAV_flag to false.\n\t\t\tUAV_flag = false;\n\t\t}\n\t\telse if (vehicle_type == ugv) {\n\t\t\t// If the vehicle is an UGV vehicle, set the UGV_flag to false.\n\t\t\tUGV_flag = false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.22990989123379}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\tif (heartbeat_count!= 0) {\n\t\theartbeat_count--;\n\t}\n\tif (heartbeat_count == 0) {\n\t\tif (vehicle_type == swarm_type) {\n\t\t\tROS_ERROR(\"Swarm heartbeat lost. Shutting down swarm.\");\n\t\t\tswarm_shutdown_flag = true;\n\t\t}\n\t\telse if (vehicle_type == uav_type) {\n\t\t\tROS_ERROR(\"UAV heartbeat lost. Shutting down UAV.\");\n\t\t\tuav_shutdown_flag = true;\n\t\t}\n\t\telse if (vehicle_type == ugv_type) {\n\t\t\tROS_ERROR(\"UGV heartbeat lost. Shutting down UGV.\");\n\t\t\tugv_shutdown_flag = true;\n\t\t}\n\t\telse {\n\t\t\tROS_ERROR(\"Vehicle type not recognized. Shutting down vehicle.\");\n\t\t\tvehicle_shutdown_flag = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.495920367604235}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\t// Check if the vehicle is a swarm vehicle\n\tif (swarm_flag) {\n\t\t// Check if the heartbeat count has changed\n\t\tif (heartbeat_count!= swarm_heartbeat_count) {\n\t\t\t// Reset the heartbeat count\n\t\t\tswarm_heartbeat_count = heartbeat_count;\n\n\t\t\t// Reset the missed heartbeat counter\n\t\t\tswarm_missed_heartbeat_count = 0;\n\t\t}\n\t\t// If the heartbeat count has not changed, increment the missed heartbeat counter\n\t\telse {\n\t\t\tswarm_missed_heartbeat_count++;\n\t\t}\n\n\t\t// Check if the heartbeat count has remained unchanged for the specified number of attempts\n\t\tif (swarm_missed_heartbeat_count >= swarm_heartbeat_attempts) {\n\t\t\t// Print an error message\n\t\t\tROS_ERROR(\"Swarm vehicle %s lost connection to the master.\", vehicle_name.c_str());\n\n\t\t\t// Set the disconnect flag\n\t\t\tswarm_disconnect_flag = true;\n\t\t}\n\t}\n\t// Check if the vehicle is a UAV vehicle\n\telse if (uav_flag) {\n\t\t// Check if the heartbeat count has changed\n\t\tif (heartbeat_count!= uav_heartbeat_count) {\n\t\t\t// Reset the heartbeat count\n\t\t\tuav_heartbeat_count = heartbeat_count;\n\n\t\t\t// Reset the missed heartbeat counter\n\t\t\tuav_missed_heartbeat_count = 0;\n\t\t}\n\t\t// If the heartbeat count has not changed, increment the missed heartbeat counter\n\t\telse {\n\t\t\tuav_missed_heartbeat_count++;\n\t\t}\n\n\t\t// Check if the heartbeat count has remained unchanged for the specified number of attempts\n\t\tif (uav_missed_heartbeat_count >= uav_heartbeat_attempts) {\n\t\t\t// Print an error message\n\t\t\tROS_ERROR(\"UAV vehicle %s lost connection to the master.\", vehicle_name.c_str());\n\n\t\t\t// Set the disconnect flag\n\t\t\tuav_disconnect_flag = true;\n\t\t}\n\t}\n\t// Check if the vehicle is a UGV vehicle\n\telse if (ugv_flag) {\n\t\t// Check if the heartbeat count has changed\n\t\tif (heartbeat_count!= ugv_heartbeat_count) {\n\t\t\t// Reset the heartbeat count\n\t\t\tugv_heartbeat_count = heartbeat_count;\n\n\t\t\t// Reset the", "CodeBleu_score": 36.500188044570024}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\t// Extract the drone ID from the header\n\tuint8_t drone_id = msg->header.frame_id;\n\t// Create a Bspline struct for each trajectory in the message\n\tfor (int i = 0; i < msg->num_bsplines; i++) {\n\t\t// Create a Bspline struct\n\t\tBspline bspline;\n\t\t// Set the Bspline struct's attributes\n\t\tbspline.id = msg->bsplines[i].id;\n\t\tbspline.duration = msg->bsplines[i].duration;\n\t\tbspline.num_segments = msg->bsplines[i].num_segments;\n\t\tbspline.num_knots = msg->bsplines[i].num_knots;\n\t\tbspline.num_points = msg->bsplines[i].num_points;\n\t\tbspline.order = msg->bsplines[i].order;\n\t\tbspline.type = msg->bsplines[i].type;\n\t\tbspline.knots = msg->bsplines[i].knots;\n\t\tbspline.points = msg->bsplines[i].points;\n\t\tbspline.yaw_points = msg->bsplines[i].yaw_points;\n\t\t// Populate the Bspline struct's knots, position points, and yaw points\n\t\tfor (int j = 0; j < bspline.num_knots; j++) {\n\t\t\tbspline.knots[j] = msg->bsplines[i].knots[j];\n\t\t}\n\t\tfor (int j = 0; j < bspline.num_points; j++) {\n\t\t\tbspline.points[j].x = msg->bsplines[i].points[j].x;\n\t\t\tbspline.points[j].y = msg->bsplines[i].points[j].y;\n\t\t\tbspline.points[j].z = msg->bsplines[i].points[j].z;\n\t\t}\n\t\tfor (int j = 0; j < bspline.num_points; j++) {\n\t\t\tbspline.yaw_points[j] = msg->bsplines[i].yaw_points[j];\n\t\t}\n\t\t// Encode the Bspline struct's data\n\t\tprometheus_msgs::Bspline bspline", "CodeBleu_score": 53.737262280123964}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\tROS_INFO(\"multitrajSubTcpCb: got a message\");\n\t// Extract the drone ID from the message header\n\tint drone_id = msg->header.stamp.sec;\n\t// Create a Bspline struct for each trajectory in the message\n\tfor (int i = 0; i < msg->num_bsplines; i++) {\n\t\tBspline bspline;\n\t\tbspline.drone_id = drone_id;\n\t\tbspline.duration = msg->bsplines[i].duration;\n\t\tbspline.num_segments = msg->bsplines[i].num_segments;\n\t\tbspline.num_knots = msg->bsplines[i].num_knots;\n\t\tbspline.num_pos = msg->bsplines[i].num_pos;\n\t\tbspline.num_yaw = msg->bsplines[i].num_yaw;\n\t\t// Populate the Bspline struct with the message data\n\t\tfor (int j = 0; j < msg->bsplines[i].num_knots; j++) {\n\t\t\tbspline.knots.push_back(msg->bsplines[i].knots[j]);\n\t\t}\n\t\tfor (int j = 0; j < msg->bsplines[i].num_pos; j++) {\n\t\t\tbspline.pos.push_back(msg->bsplines[i].pos[j]);\n\t\t}\n\t\tfor (int j = 0; j < msg->bsplines[i].num_yaw; j++) {\n\t\t\tbspline.yaw.push_back(msg->bsplines[i].yaw[j]);\n\t\t}\n\t\t// Encode the Bspline struct and send it via TCP\n\t\tstd::vector<uint8_t> encoded_data = encodeBspline(bspline);\n\t\ttcp_com.sendData(encoded_data);\n\t}\n}\n", "CodeBleu_score": 56.02548328472802}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\t// Extract the drone ID from the message\n\tint drone_id = msg->id;\n\t// Extract the trajectory data from the message\n\tprometheus_msgs::Bspline bspline_msg;\n\tfor (int i = 0; i < msg->num_bsplines; i++) {\n\t\tbspline_msg = msg->bsplines[i];\n\t\t// Initialize a Bspline struct\n\t\tBspline bspline;\n\t\t// Set its attributes\n\t\tbspline.id = bspline_msg.id;\n\t\tbspline.duration = bspline_msg.duration;\n\t\tbspline.num_segments = bspline_msg.num_segments;\n\t\tbspline.num_control_points = bspline_msg.num_control_points;\n\t\t// Populate its knots, position points, and yaw points\n\t\tfor (int j = 0; j < bspline_msg.num_control_points; j++) {\n\t\t\tbspline.knots.push_back(bspline_msg.knots[j]);\n\t\t\tgeometry_msgs::Point point;\n\t\t\tpoint.x = bspline_msg.position_points[j].x;\n\t\t\tpoint.y = bspline_msg.position_points[j].y;\n\t\t\tpoint.z = bspline_msg.position_points[j].z;\n\t\t\tbspline.position_points.push_back(point);\n\t\t\tbspline.yaw_points.push_back(bspline_msg.yaw_points[j]);\n\t\t}\n\t\t// Encode the Bspline struct\n\t\tprometheus_msgs::Bspline bspline_encoded;\n\t\tprometheus_msgs::Bspline bspline_encoded_msg;\n\t\tprometheus_msgs::MultiBsplines bsplines_encoded;\n\t\tprometheus_msgs::MultiBsplines bsplines_encoded_msg;\n\t\tencodeBspline(bspline, bspline_encoded);\n\t\tencodeBsplines(bspline, bsplines_encoded);\n\t\t// Send the encoded data via TCP\n\t\tif (drone_id == 1) {\n\t\t\ttcp_1_pub.publish(bspline_encoded_msg);\n\t\t}\n\t\telse if (drone_id == 2) {\n\t\t\ttcp_2_pub.publish(bspline_encoded_", "CodeBleu_score": 45.145926508095314}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Compress the point cloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.compress(*cloud, *compressed_cloud);\n\n\t// Create a new PointCloud2 message\n\tsensor_msgs::PointCloud2 output;\n\tpcl::toROSMsg(*compressed_cloud, output);\n\toutput.header.frame_id = msg.header.frame_id;\n\toutput.header.stamp = msg.header.stamp;\n\n\t// Return the new PointCloud2 message\n\treturn output;\n}\n", "CodeBleu_score": 31.86274222283496}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Compress the point cloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.compress(*cloud, *compressed_cloud);\n\n\t// Convert the compressed point cloud to a PointCloud2 message\n\tsensor_msgs::PointCloud2 output_msg;\n\tpcl::toROSMsg(*compressed_cloud, output_msg);\n\n\treturn output_msg;\n}\n", "CodeBleu_score": 29.74108425290578}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Convert the PointCloud2 message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Compress the point cloud\n\tpcl::PointCloud<pcl::PointXYZRGB> compressed_cloud = compress_cloud(cloud);\n\n\t// Convert the compressed point cloud to a PointCloud2 message\n\tsensor_msgs::PointCloud2 output;\n\tpcl::toROSMsg(compressed_cloud, output);\n\toutput.header = msg.header;\n\n\treturn output;\n}\n", "CodeBleu_score": 21.345084655159326}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor(int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif(multi_uav_state_.at(i).uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_.at(i) = uav_state;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.77818037092935}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 57.5763087166318}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].id == uav_state.id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.67737556156291}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\tMultiUGVState msg;\n\tmsg.ugv_count = m_multi_ugv_state.ugv_count;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tmsg.ugv_state[i].id = m_multi_ugv_state.ugv_state[i].id;\n\t\tmsg.ugv_state[i].battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tmsg.ugv_state[i].position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tmsg.ugv_state[i].position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tmsg.ugv_state[i].position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tmsg.ugv_state[i].velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tmsg.ugv_state[i].velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tmsg.ugv_state[i].velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tmsg.ugv_state[i].attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tmsg.ugv_state[i].attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tmsg.ugv_state[i].attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t}\n\tm_ugv_state_pub.publish(msg);\n}\n", "CodeBleu_score": 34.717589125486384}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\tMultiUGVState m_multi_ugv_state_msg;\n\tUGVState m_ugv_state_msg;\n\tint i;\n\tfor (i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tm_ugv_state_msg.ugv_id = m_multi_ugv_state.ugv_states[i].ugv_id;\n\t\tm_ugv_state_msg.battery = m_multi_ugv_state.ugv_states[i].battery;\n\t\tm_ugv_state_msg.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n\t\tm_ugv_state_msg.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n\t\tm_ugv_state_msg.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n\t\tm_ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n\t\tm_ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n\t\tm_ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n\t\tm_ugv_state_msg.attitude.roll = m_multi_ugv_state.ugv_states[i].attitude.roll;\n\t\tm_ugv_state_msg.attitude.pitch = m_multi_ugv_state.ugv_states[i].attitude.pitch;\n\t\tm_ugv_state_msg.attitude.yaw = m_multi_ugv_state.ugv_states[i].attitude.yaw;\n\t\tm_multi_ugv_state_msg.ugv_states.push_back(m_ugv_state_msg);\n\t}\n\tm_multi_ugv_state_msg.ugv_count = m_multi_ugv_state", "CodeBleu_score": 39.22658549913333}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\t/*\n\t * Initialize a MultiUGVState message\n\t */\n\tswarmie_msgs::MultiUGVState multi_ugv_state_msg;\n\tmulti_ugv_state_msg.header.stamp = ros::Time::now();\n\tmulti_ugv_state_msg.header.frame_id = \"swarmie_link0\";\n\n\t/*\n\t * Iterate through each UGV state in the provided MultiUGVState structure\n\t */\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t/*\n\t\t * Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\t */\n\t\tswarmie_msgs::UGVState ugv_state_msg;\n\t\tugv_state_msg.id = m_multi_ugv_state.ugv_states[i].id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_states[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n\t\tugv_state_msg.attitude.x = m_multi_ugv_state.ugv_states[i].attitude.x;\n\t\tugv_state_msg.attitude.y = m_multi_ugv_state.ugv_states[i].attitude.y;\n\t\tugv_state_msg.attitude.z = m", "CodeBleu_score": 43.07654500647307}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tdouble dist;\n\tdouble dist_grad;\n\tdouble dist_grad_q;\n\tdouble dist_grad_q_grad;\n\tdouble dist_grad_q_grad_q;\n\tdouble dist_grad_q_grad_q_grad;\n\tdouble dist_grad_q_grad_q_grad_q;\n\tdouble dist_grad_q_grad_q_grad_q_grad;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad;\n\tdouble dist_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_grad_q_", "CodeBleu_score": 6.328411498211134}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// Initialize cost and gradient\n\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(m_num_control_points, m_num_dims);\n\n\t// Iterate through control points\n\tfor (int i = 0; i < m_num_control_points; i++) {\n\t\t// Compute predicted position of moving object\n\t\tEigen::VectorXd q_predicted = calcMovingObjPos(q, i);\n\n\t\t// Compute distance error\n\t\tdouble dist_error = (q.col(i) - q_predicted).norm();\n\n\t\t// Update cost and gradient\n\t\tcost += dist_error * dist_error;\n\t\tgradient.col(i) = (q.col(i) - q_predicted) * 2.0;\n\t}\n}\n", "CodeBleu_score": 25.36893219031772}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// Initialize cost and gradient\n\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through all control points\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute the predicted position of the moving object\n\t\tEigen::Vector3d predPos = calcMovingObjPos(q.row(i));\n\n\t\t// Compute the distance between the control point and the moving object\n\t\tdouble dist = (predPos - q.row(i)).norm();\n\n\t\t// If the distance is less than the clearance, update the cost and gradient\n\t\tif (dist < clearance) {\n\t\t\t// Compute the cost and gradient\n\t\t\tdouble c = clearance - dist;\n\t\t\tEigen::Vector3d grad = (predPos - q.row(i)) / dist;\n\t\t\tcost += c;\n\t\t\tgradient.row(i) = grad;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 29.319106995246802}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tdouble a2 = 1.0;\n\tdouble b2 = 1.0;\n\n\tdouble x_ref, y_ref, x_cur, y_cur;\n\n\tint n_q = q.rows();\n\tint n_traj = q.cols();\n\n\tcost = 0.0;\n\tgradient.setZero(n_q, n_traj);\n\n\tfor (int i = 0; i < n_traj; i++) {\n\t\tfor (int j = 0; j < n_q; j++) {\n\t\t\tx_ref = ref_points(j, i);\n\t\t\ty_ref = ref_points(j + n_q, i);\n\n\t\t\tx_cur = q(j, i);\n\t\t\ty_cur = q(j + n_q, i);\n\n\t\t\tdouble x_diff = x_cur - x_ref;\n\t\t\tdouble y_diff = y_cur - y_ref;\n\n\t\t\tdouble x_dot = x_diff * x_diff;\n\t\t\tdouble y_dot = y_diff * y_diff;\n\n\t\t\tdouble x_cross = x_diff * y_diff;\n\t\t\tdouble y_cross = y_diff * x_diff;\n\n\t\t\tdouble x_norm = sqrt(x_dot + y_dot);\n\t\t\tdouble y_norm = sqrt(x_cross + y_cross);\n\n\t\t\tdouble x_cost = a2 * x_norm + b2 * y_norm;\n\t\t\tdouble y_cost = a2 * y_norm + b2 * x_norm;\n\n\t\t\tcost += x_cost + y_cost;\n\n\t\t\tdouble x_grad = 2.0 * a2 * x_diff / x_norm;\n\t\t\tdouble y_grad = 2.0 * a2 * y_diff / y_norm;\n\n\t\t\tgradient(j, i) = x_grad + y_grad;\n\t\t\tgradient(j + n_q, i) = -x_grad + y_grad;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.17734129226415}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tint n_cp = q.rows();\n\tint n_dim = q.cols();\n\n\tcost = 0.0;\n\tgradient.resize(n_cp, n_dim);\n\tgradient.setZero();\n\n\tEigen::MatrixXd r_pos(n_cp, n_dim);\n\tEigen::MatrixXd r_vel(n_cp, n_dim);\n\tEigen::MatrixXd r_acc(n_cp, n_dim);\n\n\tfor (int i = 0; i < n_cp; i++) {\n\t\tr_pos.row(i) = ref_pos.row(i) - q.row(i);\n\t\tr_vel.row(i) = ref_vel.row(i) - q.row(i);\n\t\tr_acc.row(i) = ref_acc.row(i) - q.row(i);\n\t}\n\n\tfor (int i = 0; i < n_cp; i++) {\n\t\tcost += a2 * (r_pos.row(i).transpose() * r_pos.row(i)).trace() + b2 * (r_vel.row(i).transpose() * r_vel.row(i)).trace() + c2 * (r_acc.row(i).transpose() * r_acc.row(i)).trace();\n\n\t\tgradient.row(i) += 2.0 * a2 * r_pos.row(i);\n\t\tgradient.row(i) += 2.0 * b2 * r_vel.row(i);\n\t\tgradient.row(i) += 2.0 * c2 * r_acc.row(i);\n\t}\n}\n", "CodeBleu_score": 28.469888081865363}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// Initialize the cost and gradient\n\tcost = 0.0;\n\tgradient.resize(q.rows(), q.cols());\n\tgradient.setZero();\n\n\t// Iterate through the control points\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute the error vector\n\t\tEigen::VectorXd error = referencePoints.col(i) - q.col(i);\n\n\t\t// Compute the velocity vector\n\t\tEigen::VectorXd velocity = (q.col(i + 1) - q.col(i)) / segmentLength;\n\n\t\t// Update the cost\n\t\tcost += a2 * error.transpose() * error + b2 * velocity.transpose() * velocity;\n\n\t\t// Update the gradient\n\t\tgradient.col(i) += 2 * a2 * error + 2 * b2 * velocity;\n\t\tgradient.col(i + 1) -= 2 * a2 * error + 2 * b2 * velocity;\n\t}\n}\n", "CodeBleu_score": 28.423380633052226}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()\t// The jerk trajectory is the third derivative of the spline.\n\tstd::vector<double> jerkTrajectory = getThirdDerivative();\n\t\n\t// Retrieve the knot times and control points of the jerk trajectory.\n\tstd::vector<double> knotTimes = jerkTrajectory.at(0);\n\tstd::vector<std::vector<double>> controlPoints = jerkTrajectory.at(1);\n\t\n\t// Initialize the jerk value.\n\tdouble jerkValue = 0;\n\t\n\t// Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times.\n\tfor (int i = 0; i < controlPoints.size(); i++) {\n\t\tfor (int j = 0; j < controlPoints.at(i).size(); j++) {\n\t\t\tjerkValue += pow(controlPoints.at(i).at(j), 2) * (knotTimes.at(i + 1) - knotTimes.at(i));\n\t\t}\n\t}\n\t\n\t// Return the total jerk value.\n\treturn jerkValue;\n}\n", "CodeBleu_score": 42.17734159597018}, {"code": "double UniformBspline::getJerk()\t// Get the knot times and control points of the jerk trajectory\n\tstd::vector<double> knots = getJerkKnots();\n\tstd::vector<std::vector<double>> control_points = getJerkControlPoints();\n\n\t// Initialize the jerk value\n\tdouble jerk = 0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < control_points.size(); i++) {\n\t\tfor (int j = 0; j < control_points[i].size(); j++) {\n\t\t\t// Sum the squared control point values multiplied by the differences in knot times\n\t\t\tjerk += pow(control_points[i][j], 3) * (knots[i + 1] - knots[i]);\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn jerk;\n}\n", "CodeBleu_score": 41.54714227631542}, {"code": "double UniformBspline::getJerk()\tdouble jerk = 0.0;\n\tfor (int i = 0; i < num_ctrl_pts; i++) {\n\t\tfor (int j = 0; j < dim; j++) {\n\t\t\tjerk += pow(ctrl_pts[i][j], 3) * (knot_times[i+1] - knot_times[i]);\n\t\t}\n\t}\n\treturn jerk;\n}\n", "CodeBleu_score": 29.648562304646564}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\tfloat z = depth;\n\treturn Eigen::Vector4d(x, y, z, 1.0);\n}\n", "CodeBleu_score": 50.21554315878461}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \treturn Eigen::Vector4d((u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1);\n}\n", "CodeBleu_score": 37.47755734702526}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\tfloat z = depth;\n\treturn Eigen::Vector4d(x, y, z, 1);\n}\n", "CodeBleu_score": 49.95247785909571}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\tint drone_id = stoi(odom.child_frame_id.substr(4));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t}\n\tcatch(const std::invalid_argument& e) {\n\t\tROS_WARN(\"DroneDetector: Could not extract drone ID from child_frame_id field of Odometry message. Exception: %s\", e.what());\n\t}\n}\n", "CodeBleu_score": 53.75427838706036}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\tstd::string drone_id;\n\ttry {\n\t\tdrone_id = odom.child_frame_id.substr(0, odom.child_frame_id.find('_'));\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector: Could not extract drone ID from child_frame_id field of odometry message.\\n%s\", e.what());\n\t\treturn;\n\t}\n\trcvDroneOdomCallbackBase(odom, drone_id);\n}\n", "CodeBleu_score": 46.68514105799954}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\tstd::string child_frame_id = odom.child_frame_id;\n\t\tint id = std::stoi(child_frame_id.substr(0, child_frame_id.find('_')));\n\t\trcvDroneOdomCallbackBase(odom, id);\n\t}\n\tcatch (const std::invalid_argument& e) {\n\t\tROS_ERROR(\"Invalid argument: %s\", e.what());\n\t}\n}\n", "CodeBleu_score": 51.44181844155153}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// Get the camera pose in the world frame.\n\tEigen::Vector3d camera_position = this->camera_pose.getOrigin();\n\tEigen::Quaterniond camera_orientation = this->camera_pose.getRotation();\n\n\t// Get the camera intrinsics.\n\tdouble fx = this->camera_info.K[0];\n\tdouble fy = this->camera_info.K[4];\n\tdouble cx = this->camera_info.K[2];\n\tdouble cy = this->camera_info.K[5];\n\n\t// Compute the pixel position in the camera frame.\n\tdouble x = true_pixel[0];\n\tdouble y = true_pixel[1];\n\tdouble z = 1;\n\tdouble x_c = (x - cx) * z / fx;\n\tdouble y_c = (y - cy) * z / fy;\n\tdouble z_c = z;\n\n\t// Transform the pixel position from the camera frame to the world frame.\n\tEigen::Vector3d true_position_c(x_c, y_c, z_c);\n\tEigen::Vector3d true_position_w = camera_orientation.inverse() * true_position_c + camera_position;\n\n\t// Check if the drone is in the image.\n\tbool found = true;\n\tfor (int i = 0; i < this->world_points.size(); i++) {\n\t\tif (this->world_points[i].x() == true_position_w.x() && this->world_points[i].y() == true_position_w.y() && this->world_points[i].z() == true_position_w.z()) {\n\t\t\tfound = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Compute the pose error.\n\tif (found) {\n\t\tEigen::Vector3d true_position_w_error = true_position_w - this->world_points[drone_id];\n\t\tdouble pose_error = true_position_w_error.norm();\n\n\t\t// Update the debug result.\n\t\tthis->debug_result.pose_error = pose_error;\n\t\tthis->debug_result.found = true;\n\n\t\t// Publish the pose error.\n\t\tthis->pose_error", "CodeBleu_score": 27.945605179140554}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// Check if the drone is already detected\n\tif (drone_id == -1) {\n\t\t// No drone detected, update debug result\n\t\tdebug_result_msg.detected = false;\n\t\tdebug_result_msg.id = -1;\n\t\tdebug_result_msg.position.x = 0;\n\t\tdebug_result_msg.position.y = 0;\n\t\tdebug_result_msg.position.z = 0;\n\t\tdebug_result_msg.velocity.x = 0;\n\t\tdebug_result_msg.velocity.y = 0;\n\t\tdebug_result_msg.velocity.z = 0;\n\t\tdebug_result_msg.acceleration.x = 0;\n\t\tdebug_result_msg.acceleration.y = 0;\n\t\tdebug_result_msg.acceleration.z = 0;\n\t\tdebug_result_msg.yaw = 0;\n\t\tdebug_result_msg.pitch = 0;\n\t\tdebug_result_msg.roll = 0;\n\t\tdebug_result_msg.confidence = 0;\n\t\tdebug_result_msg.timestamp = ros::Time::now();\n\t\tdebug_result_pub.publish(debug_result_msg);\n\t\treturn;\n\t}\n\n\t// Check if the drone is already in the map\n\tif (drone_id in drone_map) {\n\t\t// Drone is already in the map, check if the true pixel position has changed\n\t\tif (drone_map[drone_id].true_pixel.x() == true_pixel.x() && drone_map[drone_id].true_pixel.y() == true_pixel.y()) {\n\t\t\t// True pixel position has not changed, update debug result\n\t\t\tdebug_result_msg.detected = drone_map[drone_id].detected;\n\t\t\tdebug_result_msg.id = drone_map[drone_id].id;\n\t\t\tdebug_result_msg.position.x = drone_map[drone_id].position.x();\n\t\t\tdebug_result_msg.position.y = drone_map[drone_id].position.y();\n\t\t\tdebug_result_msg.position.z = drone_map[drone_id].position.z();\n\t\t\tdebug", "CodeBleu_score": 31.82611126301978}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// Check for valid ID\n\tif (drone_id < 0) {\n\t\tROS_ERROR_STREAM(\"Invalid drone ID: \" << drone_id);\n\t\treturn;\n\t}\n\n\t// Check for valid pixel\n\tif (true_pixel.x() < 0 || true_pixel.y() < 0 || true_pixel.x() >= image_width_ || true_pixel.y() >= image_height_) {\n\t\tROS_ERROR_STREAM(\"Invalid pixel: \" << true_pixel.transpose());\n\t\treturn;\n\t}\n\n\t// Check for valid detection\n\tif (!detections_.count(drone_id)) {\n\t\tROS_ERROR_STREAM(\"No detection for drone ID: \" << drone_id);\n\t\treturn;\n\t}\n\n\t// Get detection\n\tconst Detection &detection = detections_[drone_id];\n\n\t// Compute true pose in camera frame\n\tEigen::Vector2d true_position = detection.position;\n\ttrue_position.x() += true_pixel.x();\n\ttrue_position.y() += true_pixel.y();\n\tEigen::Vector2d true_position_pixels = true_position / detection.scale;\n\tEigen::Vector2d true_position_pixels_offset = true_position_pixels - detection.center;\n\tEigen::Vector2d true_position_meters = true_position_pixels_offset * detection.focal_length;\n\n\t// Compute true pose in world frame\n\tEigen::Vector3d true_position_meters_world = detection.position_world + true_position_meters.cast<double>();\n\n\t// Compute pose error\n\tEigen::Vector3d pose_error = true_position_meters_world - detection.position_world;\n\n\t// Update debug result\n\tdebug_result_.id = drone_id;\n\tdebug_result_.position = true_position_meters_world;\n\tdebug_result_.position_error = pose_error;\n\n\t// Publish pose error\n\tpose_error_pub_.publish(pose_error);\n}\n", "CodeBleu_score": 33.13356148479087}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current!= start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 67.99917692323582}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\n\twhile (current!= start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\n\treturn path;\n}\n", "CodeBleu_score": 67.99917692323582}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current!= startNode) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 68.17757893074219}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert start point to grid index\n\tstart_idx = Vector3i(start_pt.x / resolution, start_pt.y / resolution, start_pt.z / resolution);\n\tif (start_idx.x < 0 || start_idx.x >= grid_size.x || start_idx.y < 0 || start_idx.y >= grid_size.y || start_idx.z < 0 || start_idx.z >= grid_size.z) {\n\t\tROS_ERROR(\"Start point is out of bounds\");\n\t\treturn false;\n\t}\n\n\t// Convert end point to grid index\n\tend_idx = Vector3i(end_pt.x / resolution, end_pt.y / resolution, end_pt.z / resolution);\n\tif (end_idx.x < 0 || end_idx.x >= grid_size.x || end_idx.y < 0 || end_idx.y >= grid_size.y || end_idx.z < 0 || end_idx.z >= grid_size.z) {\n\t\tROS_ERROR(\"End point is out of bounds\");\n\t\treturn false;\n\t}\n\n\t// Check if start or end point is inside an obstacle\n\tif (grid_map.data[start_idx.x + start_idx.y * grid_size.x + start_idx.z * grid_size.x * grid_size.y] == 1 || grid_map.data[end_idx.x + end_idx.y * grid_size.x + end_idx.z * grid_size.x * grid_size.y] == 1) {\n\t\t// Iterate until start or end point is not inside an obstacle\n\t\tbool start_in_obstacle = true;\n\t\tbool end_in_obstacle = true;\n\t\twhile (start_in_obstacle || end_in_obstacle) {\n\t\t\t// Check if start point is inside an obstacle\n\t\t\tif (start_in_obstacle) {\n\t\t\t\t// Move start point away from end point until it is no longer in an obstacle\n\t\t\t\tif (grid_map.data[end_idx.x + end_idx.y * grid_size.x + end_idx.z * grid_size.x * grid", "CodeBleu_score": 31.835763991594284}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert start and end points to grid indices\n\tif (ConvertCoordinatesToIndex(start_pt, start_idx) && ConvertCoordinatesToIndex(end_pt, end_idx)) {\n\t\t// If the start or end point is inside an obstacle, adjust the point\n\t\tif (IsPointInObstacle(start_idx) || IsPointInObstacle(end_idx)) {\n\t\t\t// Adjust start point\n\t\t\tif (IsPointInObstacle(start_idx)) {\n\t\t\t\tif (!AdjustPoint(start_idx, end_idx)) {\n\t\t\t\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Failed to adjust start point.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Adjust end point\n\t\t\tif (IsPointInObstacle(end_idx)) {\n\t\t\t\tif (!AdjustPoint(end_idx, start_idx)) {\n\t\t\t\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Failed to adjust end point.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Failed to convert start and end points to grid indices.\");\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 39.03560728956151}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\tstart_idx = Vector3i::Zero();\n\tend_idx = Vector3i::Zero();\n\n\t// Convert start point to grid index\n\tif (!ConvertPointToIndex(start_pt, start_idx)) {\n\t\tROS_ERROR(\"Start point is outside of the grid map. Cannot find a path.\");\n\t\treturn false;\n\t}\n\n\t// Convert end point to grid index\n\tif (!ConvertPointToIndex(end_pt, end_idx)) {\n\t\tROS_ERROR(\"End point is outside of the grid map. Cannot find a path.\");\n\t\treturn false;\n\t}\n\n\t// Check if start and end points are in the same grid cell\n\tif (start_idx == end_idx) {\n\t\tROS_ERROR(\"Start and end points are in the same grid cell. Cannot find a path.\");\n\t\treturn false;\n\t}\n\n\t// Check if start point is inside an obstacle\n\tif (grid_map_.IsObstacle(start_idx)) {\n\t\tROS_INFO(\"Start point is inside an obstacle. Adjusting start point...\");\n\n\t\t// Adjust start point\n\t\tbool is_start_point_adjusted = false;\n\t\twhile (!is_start_point_adjusted) {\n\t\t\t// Adjust the x coordinate\n\t\t\tif (grid_map_.IsObstacle(start_idx + Vector3i(1, 0, 0))) {\n\t\t\t\tstart_idx[0] -= 1;\n\t\t\t}\n\t\t\telse if (grid_map_.IsObstacle(start_idx - Vector3i(1, 0, 0))) {\n\t\t\t\tstart_idx[0] += 1;\n\t\t\t}\n\n\t\t\t// Adjust the y coordinate\n\t\t\tif (grid_map_.IsObstacle(start_idx + Vector3i(0, 1, 0))) {\n\t\t\t\tstart_idx[1] -= 1;\n\t\t\t}\n\t\t\telse if (grid_map_.IsObstacle(start_idx - Vector3i(0, 1, 0))) {\n\t\t\t\tstart_idx[1] += 1;\n\t\t\t}\n\n\t\t\t// Adjust the z coordinate\n\t\t\tif (grid_map_.IsObstacle(start_idx + Vector3i(0, 0, 1))) {\n\t\t\t\tstart_idx[2] -= 1;\n\t\t\t}", "CodeBleu_score": 32.113326496908684}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\tint min_id_x = getIndex(min_pos.x(), min_pos.y(), min_pos.z());\n\tint min_id_y = getIndex(min_pos.x(), min_pos.y(), max_pos.z());\n\tint min_id_z = getIndex(min_pos.x(), max_pos.y(), min_pos.z());\n\tint min_id_z_plus_1 = getIndex(min_pos.x(), max_pos.y(), max_pos.z());\n\n\tint max_id_x = getIndex(max_pos.x(), min_pos.y(), min_pos.z());\n\tint max_id_y = getIndex(max_pos.x(), min_pos.y(), max_pos.z());\n\tint max_id_z = getIndex(max_pos.x(), max_pos.y(), min_pos.z());\n\tint max_id_z_plus_1 = getIndex(max_pos.x(), max_pos.y(), max_pos.z());\n\n\tint min_id = std::min(min_id_x, std::min(min_id_y, std::min(min_id_z, min_id_z_plus_1)));\n\tint max_id = std::max(max_id_x, std::max(max_id_y, std::max(max_id_z, max_id_z_plus_1)));\n\n\tfor (int i = min_id; i <= max_id; ++i) {\n\t\toccupancy_buffer_inflate_[i] = 0;\n\t}\n}\n", "CodeBleu_score": 32.444163405150974}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\tEigen::Vector3i min_id, max_id;\n\tEigen::Vector3d min_pos_local, max_pos_local;\n\n\t// Get the min and max ids\n\tif (!getIndexFromPosition(min_pos, min_id)) {\n\t\tROS_ERROR(\"GridMap::resetBuffer: Failed to get index from position (%f, %f, %f)\", min_pos.x(), min_pos.y(), min_pos.z());\n\t\treturn;\n\t}\n\n\tif (!getIndexFromPosition(max_pos, max_id)) {\n\t\tROS_ERROR(\"GridMap::resetBuffer: Failed to get index from position (%f, %f, %f)\", max_pos.x(), max_pos.y(), max_pos.z());\n\t\treturn;\n\t}\n\n\t// Get the min and max positions in the local frame\n\tmin_pos_local = getPositionFromIndex(min_id);\n\tmax_pos_local = getPositionFromIndex(max_id);\n\n\t// Iterate over the grid coordinates from min_id to max_id and set the corresponding elements in the occupancy_buffer_inflate_ to zero\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\tEigen::Vector3i grid_index(i, j, k);\n\t\t\t\tEigen::Vector3d grid_position = getPositionFromIndex(grid_index);\n\n\t\t\t\t// Check if the grid_position is within the region\n\t\t\t\tif (grid_position.x() >= min_pos_local.x() && grid_position.x() <= max_pos_local.x() && grid_position.y() >= min_pos_local.y() && grid_position.y() <= max_pos_local.y() && grid_position.z() >= min_pos_local.z() && grid_position.z() <= max_pos_local.z()) {\n\t\t\t\t\toccupancy_buffer_inflate_.at(grid_index.x(), grid_index.y(), grid_index.z()) = ", "CodeBleu_score": 36.60090905096795}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\tEigen::Vector3i min_id, max_id;\n\tif (getGridCoordinates(min_pos, min_id) && getGridCoordinates(max_pos, max_id)) {\n\t\tfor (int x = min_id(0); x <= max_id(0); ++x) {\n\t\t\tfor (int y = min_id(1); y <= max_id(1); ++y) {\n\t\t\t\tfor (int z = min_id(2); z <= max_id(2); ++z) {\n\t\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t\t\tdistance_buffer_inflate_(x, y, z) = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 66.9858797363669}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\n\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d diff_max = diff.cwiseAbs();\n\tEigen::Vector3d diff_min = diff.cwiseAbs();\n\tEigen::Vector3d result = pt;\n\tdouble max_coeff = 1.0;\n\tdouble min_coeff = 1.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff_max(i) > 0.0) {\n\t\t\tmax_coeff = std::min(max_coeff, map_size_[i] / diff_max(i));\n\t\t}\n\t\tif (diff_min(i) > 0.0) {\n\t\t\tmin_coeff = std::min(min_coeff, map_size_[i] / diff_min(i));\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff_max(i) > 0.0) {\n\t\t\tresult(i) = camera_pt(i) + max_coeff * diff(i);\n\t\t} else if (diff_min(i) > 0.0) {\n\t\t\tresult(i) = camera_pt(i) + min_coeff * diff(i);\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 47.23166910919371}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\n\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_trans = diff;\n\tEigen::Vector3d max_trans = diff;\n\tEigen::Vector3d trans_coeff = diff;\n\tdouble min_dist = 1000000;\n\tdouble max_dist = -1000000;\n\tdouble dist = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff[i] < 0) {\n\t\t\tmin_trans[i] = -1;\n\t\t\tmax_trans[i] = 0;\n\t\t} else if (diff[i] > 0) {\n\t\t\tmin_trans[i] = 0;\n\t\t\tmax_trans[i] = 1;\n\t\t}\n\t\tfor (int j = min_trans[i]; j <= max_trans[i]; j++) {\n\t\t\ttrans_coeff[i] = j;\n\t\t\tdist = (pt - (camera_pt + trans_coeff * diff)).norm();\n\t\t\tif (dist < min_dist) {\n\t\t\t\tmin_dist = dist;\n\t\t\t}\n\t\t\tif (dist > max_dist) {\n\t\t\t\tmax_dist = dist;\n\t\t\t}\n\t\t}\n\t}\n\tif (min_dist < max_dist) {\n\t\treturn camera_pt + min_trans * diff;\n\t} else {\n\t\treturn camera_pt + max_trans * diff;\n\t}\n}\n", "CodeBleu_score": 50.80405596510259}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\n\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt = Eigen::Vector3d::Zero();\n\tEigen::Vector3d max_pt = Eigen::Vector3d::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tmin_pt[i] = camera_pt[i] + std::min(0.0, diff[i]);\n\t\tmax_pt[i] = camera_pt[i] + std::max(0.0, diff[i]);\n\t}\n\tEigen::Vector3d pt_in_map = pt;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (pt_in_map[i] < min_pt[i]) {\n\t\t\tpt_in_map[i] = min_pt[i];\n\t\t} else if (pt_in_map[i] > max_pt[i]) {\n\t\t\tpt_in_map[i] = max_pt[i];\n\t\t}\n\t}\n\treturn pt_in_map;\n}\n", "CodeBleu_score": 46.058044202522744}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// Check if the last occupancy update is too recent\n\tif (ros::Time::now() - lastOccupancyUpdate < occupancyUpdateInterval) {\n\t\treturn;\n\t}\n\n\t// Check if the map is initialized\n\tif (!initialized) {\n\t\tROS_WARN(\"Grid map not initialized yet. Skipping occupancy update.\");\n\t\treturn;\n\t}\n\n\t// Check if the map is updated\n\tif (!updated) {\n\t\tROS_WARN(\"Grid map not updated yet. Skipping occupancy update.\");\n\t\treturn;\n\t}\n\n\t// Check if the local map is updated\n\tif (localMapUpdated) {\n\t\tROS_WARN(\"Local map not updated yet. Skipping occupancy update.\");\n\t\treturn;\n\t}\n\n\t// Check if the odometry is too old\n\tif (ros::Time::now() - lastOdometryUpdate > odometryTimeout) {\n\t\tROS_WARN(\"Odometry data is too old. Skipping occupancy update.\");\n\t\treturn;\n\t}\n\n\t// Check if the depth image is too old\n\tif (ros::Time::now() - lastDepthUpdate > depthTimeout) {\n\t\tROS_WARN(\"Depth data is too old. Skipping occupancy update.\");\n\t\treturn;\n\t}\n\n\t// Update the last occupancy update time\n\tlastOccupancyUpdate = ros::Time::now();\n\n\t// Get the depth image\n\tcv_bridge::CvImagePtr depth_image_ptr;\n\ttry {\n\t\tdepth_image_ptr = cv_bridge::toCvCopy(depth_image_msg, \"32FC1\");\n\t} catch (cv_bridge::Exception& e) {\n\t\tROS_ERROR(\"cv_bridge exception: %s\", e.what());\n\t\treturn;\n\t}\n\tconst cv::Mat& depth_image = depth_image_ptr->image;\n\n\t// Get the camera info\n\tsensor_msgs::CameraInfo camera_info_msg = depth_image_msg.camera_info;\n\tcv_bridge::CvCameraInfo camera_info_ptr;\n\ttry {\n\t\tcamera_info_ptr = cv_bridge::toCvCopy(camera_info_msg);\n\t} catch (cv_bridge::Exception& e) {\n\t\tROS_ERROR(\"cv_bridge exception:", "CodeBleu_score": 32.48716210510018}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\tif (last_update_time_ > 0) {\n\t\tdouble time_since_last_update = (ros::Time::now() - last_update_time_).toSec();\n\t\tif (time_since_last_update < update_interval_) {\n\t\t\treturn;\n\t\t}\n\t}\n\tlast_update_time_ = ros::Time::now();\n\n\t// Clear the local map\n\tif (local_map_updated_) {\n\t\tclearMap();\n\t\tlocal_map_updated_ = false;\n\t}\n\n\t// Project the depth image into points\n\tif (!projectDepthImageToPoints()) {\n\t\treturn;\n\t}\n\n\t// Process the points with raycasting\n\tif (!processPointsWithRaycasting()) {\n\t\treturn;\n\t}\n\n\t// Update the local map\n\tif (!updateLocalMap()) {\n\t\treturn;\n\t}\n\n\t// Publish the local map\n\tpublishLocalMap();\n}\n", "CodeBleu_score": 30.45043120116158}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\tif (this->lastOccupancyUpdateTime_ == 0) {\n\t\tthis->lastOccupancyUpdateTime_ = ros::Time::now().toSec();\n\t}\n\n\t// Check if the occupancy grid needs to be updated\n\tif (this->lastOccupancyUpdateTime_ + this->occupancyUpdateTimeout_ > ros::Time::now().toSec()) {\n\t\treturn;\n\t}\n\n\t// Check if the local map needs to be updated\n\tif (this->lastLocalMapUpdateTime_ + this->localMapUpdateTimeout_ > ros::Time::now().toSec()) {\n\t\treturn;\n\t}\n\n\t// Check if the depth image is valid\n\tif (this->depthImage_.width == 0 || this->depthImage_.height == 0) {\n\t\tROS_ERROR(\"Depth image is empty\");\n\t\treturn;\n\t}\n\n\t// Check if the odometry is valid\n\tif (this->odom_.header.stamp == 0) {\n\t\tROS_ERROR(\"Odometry is empty\");\n\t\treturn;\n\t}\n\n\t// Check if the local map is valid\n\tif (this->localMap_.info.width == 0 || this->localMap_.info.height == 0) {\n\t\tROS_ERROR(\"Local map is empty\");\n\t\treturn;\n\t}\n\n\t// Check if the local map is valid\n\tif (this->localMap_.data.size() == 0) {\n\t\tROS_ERROR(\"Local map is empty\");\n\t\treturn;\n\t}\n\n\t// Update the last occupancy update time\n\tthis->lastOccupancyUpdateTime_ = ros::Time::now().toSec();\n\n\t// Get the time difference between now and the last occupancy update\n\tdouble timeDifference = this->lastOccupancyUpdateTime_ - this->lastLocalMapUpdateTime_;\n\n\t// Check if the local map needs to be updated\n\tif (timeDifference > this->localMapUpdateTimeout_) {\n\t\tthis->updateLocalMap();\n\t}\n\n\t// Clear the occupancy grid\n\tthis->clearOccupancyGrid();\n\n\t// Project the depth image into points\n\tthis->projectDepthImageIntoPoints();\n\n\t// Process the points with raycasting\n\tthis->processPointsWithRaycasting();\n\n\t// Update the last local map update time\n\tthis->last", "CodeBleu_score": 33.400316054383744}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tint num_images = image_fns.size();\n\tint num_ellipses = 0;\n\tfloat f_measure_sum = 0.0;\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load the image\n\t\tMat image = imread(image_fns[i], 0);\n\t\tif (image.empty()) {\n\t\t\tcout << \"Could not read image \" << image_fns[i] << endl;\n\t\t\treturn 0.0;\n\t\t}\n\t\t// Load the ground truth ellipses\n\t\tvector<Ellipse> gt_ellipses = _load_ellipses(gt_fns[i], gt_angle_radians);\n\t\tnum_ellipses += gt_ellipses.size();\n\t\t// Load the detected ellipses\n\t\tvector<Ellipse> dt_ellipses = _load_ellipses(dt_fns[i], gt_angle_radians);\n\t\t// Evaluate the detection performance\n\t\tfloat f_measure = _ellipse_f_measure(gt_ellipses, dt_ellipses);\n\t\tf_measure_sum += f_measure;\n\t}\n\treturn f_measure_sum / (float)num_images;\n}\n", "CodeBleu_score": 51.13969375647247}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat f_measure = 0.0;\n\tint num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// load image and ground truth\n\t\tMat img = imread(image_fns[i], IMREAD_GRAYSCALE);\n\t\tvector<Ellipse2D> gt_ellipses = _load_ellipses(gt_fns[i]);\n\t\tvector<Ellipse2D> dt_ellipses = _load_ellipses(dt_fns[i]);\n\n\t\t// evaluate detection performance\n\t\tf_measure += _ellipse_evaluate_image(img, gt_ellipses, dt_ellipses, gt_angle_radians);\n\t}\n\treturn f_measure / (float)num_images;\n}\n", "CodeBleu_score": 53.62015403810821}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\t// Initialize variables\n\tint num_images = image_fns.size();\n\tfloat total_f_measure = 0.0;\n\n\t// Iterate through the images\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load the image and ground truth ellipses\n\t\tMat image = imread(image_fns[i]);\n\t\tvector<ellipse_t> gt_ellipses = ellipse_read(gt_fns[i]);\n\t\tvector<ellipse_t> dt_ellipses = ellipse_read(dt_fns[i]);\n\n\t\t// Evaluate the detection performance\n\t\tfloat f_measure = ellipse_f_measure(image, gt_ellipses, dt_ellipses, gt_angle_radians);\n\n\t\t// Accumulate the F-measure\n\t\ttotal_f_measure += f_measure;\n\t}\n\n\t// Return the average F-measure\n\treturn total_f_measure / num_images;\n}\n", "CodeBleu_score": 53.92836289653392}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat angle = atan2(y - b, x - a);\n\tfloat diff = angle - atan2(b - y, a - x);\n\tif (diff < -M_PI) {\n\t\tdiff += 2 * M_PI;\n\t} else if (diff > M_PI) {\n\t\tdiff -= 2 * M_PI;\n\t}\n\treturn diff;\n}\n", "CodeBleu_score": 31.466987221761944}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tif (foci == NULL) {\n\t\treturn 0.0;\n\t}\n\tfloat foci_angle = atan2(foci[1] - y, foci[0] - x);\n\tfloat point_angle = atan2(y, x);\n\tfloat angle = foci_angle - point_angle;\n\tif (angle > PI) {\n\t\tangle -= TWO_PI;\n\t} else if (angle < -PI) {\n\t\tangle += TWO_PI;\n\t}\n\treturn angle;\n}\n", "CodeBleu_score": 39.24664225274015}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tif (foci == NULL) {\n\t\treturn 0.0f;\n\t}\n\tfloat a = atan2(foci[1] - y, foci[0] - x);\n\tfloat b = atan2(foci[3] - y, foci[2] - x);\n\tfloat c = a - b;\n\tif (c > M_PI) {\n\t\tc -= 2 * M_PI;\n\t} else if (c < -M_PI) {\n\t\tc += 2 * M_PI;\n\t}\n\treturn c;\n}\n", "CodeBleu_score": 36.51120983924335}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tdouble m = (vp1[i].y - vp1[start].y) / (vp1[i].x - vp1[start].x);\n\t\tintegral_above += (vp1[i].x + vp1[start].x) * (vp1[i].x * vp1[i].x + vp1[i].x * vp1[start].x + vp1[start].x * vp1[start].x) / 3.0 * (vp1[i].y + vp1[start].y) / 2.0;\n\t\tintegral_below += (vp1[i].x + vp1[start].x) * (vp1[i].x * vp1[i].x + vp1[i].x * vp1[start].x + vp1[start].x * vp1[start].x) / 3.0 * (vp1[i].y - vp1[start].y) / 2.0;\n\t}\n\tif (integral_above < integral_below)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n", "CodeBleu_score": 33.395457216223726}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\t// calculate the minimum and maximum x and y coordinates of the points in the section\n\tdouble x_min = vp1.points[start].x;\n\tdouble x_max = vp1.points[start].x;\n\tdouble y_min = vp1.points[start].y;\n\tdouble y_max = vp1.points[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1.points[i].x < x_min)\n\t\t\tx_min = vp1.points[i].x;\n\t\tif (vp1.points[i].x > x_max)\n\t\t\tx_max = vp1.points[i].x;\n\t\tif (vp1.points[i].y < y_min)\n\t\t\ty_min = vp1.points[i].y;\n\t\tif (vp1.points[i].y > y_max)\n\t\t\ty_max = vp1.points[i].y;\n\t}\n\n\t// compute the integral above and below the polygon section\n\tdouble area_above = 0.0;\n\tdouble area_below = 0.0;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tarea_above += (vp1.points[i].x + vp1.points[i - 1].x) * (vp1.points[i].y - vp1.points[i - 1].y);\n\t\tarea_below += (vp1.points[i].x + vp1.points[i - 1].x) * (vp1.points[i - 1].y - vp1.points[i - 2].y);\n\t}\n\n\t// if the integral above is less than the integral below, the section is concave\n\tif (area_above < area_below)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n", "CodeBleu_score": 35.083980878112705}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\tdouble min_x = 1e10, max_x = -1e10, min_y = 1e10, max_y = -1e10;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\tdouble integral_above = 0, integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tdouble x = vp1[i].x, y = vp1[i].y;\n\t\tif (i == start) {\n\t\t\tintegral_above += (x - min_x) * (y + max_y);\n\t\t\tintegral_below += (x - min_x) * (y - min_y);\n\t\t} else if (i == end) {\n\t\t\tintegral_above += (max_x - x) * (y + max_y);\n\t\t\tintegral_below += (max_x - x) * (y - min_y);\n\t\t} else {\n\t\t\tintegral_above += (x - min_x) * (y + max_y) + (max_x - x) * (y + max_y);\n\t\t\tintegral_below += (x - min_x) * (y - min_y) + (max_x - x) * (y - min_y);\n\t\t}\n\t}\n\treturn integral_above < integral_below;\n}\n", "CodeBleu_score": 43.60784168574894}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tprometheus_msgs::DetectionInfo det_msg;\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tdet_msg = msg->detection_infos[i];\n\t\tif (det_msg.name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t\tif (num_lost >= VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain >= VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (is_detected) {\n\t\t\tsight_angle = det_msg.angle;\n\t\t} else {\n\t\t\tsight_angle = -1;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 56.91880342244584}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tfor(int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif(msg->detection_infos[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t}\n\t\telse {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\n\t\tif(num_lost > VISION_THRES)\n\t\t\tis_detected = false;\n\t\tif(num_regain > VISION_THRES)\n\t\t\tis_detected = true;\n\n\t\t//swap the sight_angle values\n\t\tfloat temp = ellipse_det.sight_angle;\n\t\tellipse_det.sight_angle = msg->detection_infos[i].sight_angle;\n\t\tmsg->detection_infos[i].sight_angle = temp;\n\t}\n}\n", "CodeBleu_score": 52.388319138499504}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tprometheus_msgs::DetectionInfo::ConstPtr target = msg->objects[0];\n\tif (target->name == \"T\") {\n\t\tnum_regain++;\n\t\tnum_lost = 0;\n\t}\n\telse {\n\t\tnum_lost++;\n\t\tnum_regain = 0;\n\t}\n\tif (num_lost > VISION_THRES) {\n\t\tis_detected = false;\n\t}\n\tif (num_regain > VISION_THRES) {\n\t\tis_detected = true;\n\t}\n\t//swap\n\tfloat temp = ellipse_det.sight_angle;\n\tellipse_det.sight_angle = ellipse_det.sight_angle_2;\n\tellipse_det.sight_angle_2 = temp;\n}\n", "CodeBleu_score": 56.97644082323522}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\treturn Occupy_map_ptr->check_collision(cur_pos, safe_distance);\n}\n", "CodeBleu_score": 37.247946481891816}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\tif(Occupy_map_ptr->is_occupied(cur_pos, safe_distance)) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 38.192974971865304}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\tdouble x_pos = cur_pos[0];\n\tdouble y_pos = cur_pos[1];\n\tdouble z_pos = cur_pos[2];\n\n\t// Check if the position is within the map boundaries\n\tif (x_pos < 0 || x_pos > map_width || y_pos < 0 || y_pos > map_height || z_pos < 0 || z_pos > map_depth) {\n\t\treturn false;\n\t}\n\n\t// Check if the position is within the safety distance of the obstacles\n\tif (Occupy_map_ptr->is_occupied(x_pos, y_pos, z_pos, safe_distance)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 41.93441170118846}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)\tpath_nodes_.clear();\n\tpath_nodes_.push_back(end_node);\n\tNodePtr parent_node = end_node->parent_node_;\n\twhile (parent_node!= nullptr) {\n\t\tpath_nodes_.push_back(parent_node);\n\t\tparent_node = parent_node->parent_node_;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 59.83347348144722}, {"code": "void Astar::retrievePath(NodePtr end_node)\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent_;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 57.057374493972965}, {"code": "void Astar::retrievePath(NodePtr end_node)\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 58.59658674221569}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].heading = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].vel = odom->twist.twist.linear.x;\n\tstate_nei[id].time = odom->header.stamp.toSec();\n\n\t// Check if the UGV is in the same position as the start position\n\tif (state_nei[id].x == start_pos.x && state_nei[id].y == start_pos.y) {\n\t\tget_nei_state = false;\n\t}\n\telse {\n\t\tget_nei_state = true;\n\t}\n}\n", "CodeBleu_score": 39.395604133950215}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].roll = odom->pose.pose.orientation.x;\n\tstate_nei[id].pitch = odom->pose.pose.orientation.y;\n\tstate_nei[id].yaw = odom->pose.pose.orientation.z;\n\tstate_nei[id].yaw = odom->pose.pose.orientation.w;\n\tstate_nei[id].vel_x = odom->twist.twist.linear.x;\n\tstate_nei[id].vel_y = odom->twist.twist.linear.y;\n\tstate_nei[id].vel_z = odom->twist.twist.linear.z;\n\tstate_nei[id].vel_roll = odom->twist.twist.angular.x;\n\tstate_nei[id].vel_pitch = odom->twist.twist.angular.y;\n\tstate_nei[id].vel_yaw = odom->twist.twist.angular.z;\n\tif (sim_mode == true) {\n\t\tdouble dist = sqrt(pow(state_nei[id].x - start_pos.x, 2) + pow(state_nei[id].y - start_pos.y, 2));\n\t\tif (dist > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n}\n", "CodeBleu_score": 52.46094698028391}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \t// Get the UGV's position and orientation from the odometry data\n\tstate_nei[id][0] = odom->pose.pose.position.x;\n\tstate_nei[id][1] = odom->pose.pose.position.y;\n\tstate_nei[id][2] = odom->pose.pose.position.z;\n\tstate_nei[id][3] = odom->pose.pose.orientation.x;\n\tstate_nei[id][4] = odom->pose.pose.orientation.y;\n\tstate_nei[id][5] = odom->pose.pose.orientation.z;\n\tstate_nei[id][6] = odom->pose.pose.orientation.w;\n\n\t// Check if the UGV has reached the goal position\n\tif (state_nei[id][0] == goal_x && state_nei[id][1] == goal_y) {\n\t\t// If the UGV has reached the goal position, set the get_nei_state flag to false\n\t\tget_nei_state[id] = false;\n\t}\n\n\t// If in simulation mode, check if the UGV is too far away from the start position\n\tif (sim_mode) {\n\t\t// Calculate the distance from the UGV to the start position\n\t\tdouble dist = sqrt(pow(state_nei[id][0] - start_x, 2) + pow(state_nei[id][1] - start_y, 2));\n\n\t\t// If the UGV is too far away from the start position, set the get_nei_state flag to false\n\t\tif (dist > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.905837989024654}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\t// Check if odometry is ready\n\tif (!odom_ready) {\n\t\treturn;\n\t}\n\t// Set sensor_ready flag to true\n\tsensor_ready = true;\n\t// Increment update counter\n\tupdate_counter++;\n\t// Every fifth update, update the Astar map\n\tif (update_counter % 5 == 0) {\n\t\t// Reset update counter\n\t\tupdate_counter = 0;\n\t\t// Update Astar map\n\t\tupdate_astar_map(msg);\n\t}\n}\n", "CodeBleu_score": 52.10908403248}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tpc_update_counter++;\n\t\tif (pc_update_counter == 5) {\n\t\t\tpc_update_counter = 0;\n\t\t\tpc_ready = true;\n\t\t\tpc_sub.shutdown();\n\t\t\tAstar_map.update_map(msg);\n\t\t\tAstar_map.reset_map();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.43401639898659}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (!odometry_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count % 5 == 0) {\n\t\tupdate_count = 0;\n\t\tpcl::fromROSMsg(*msg, cloud);\n\t\tmap.update_map(cloud);\n\t}\n}\n", "CodeBleu_score": 48.641210730281934}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\t// Check if the global map has been updated\n\tif (get_gpcl == false) {\n\t\t// Set the flag to true\n\t\tget_gpcl = true;\n\n\t\t// Convert the sensor message to a point cloud\n\t\tpcl::fromROSMsg(*global_point, global_pcl);\n\n\t\t// Store the point cloud\n\t\tpcl::io::savePCDFileASCII(\"global_pcl.pcd\", global_pcl);\n\n\t\t// Inflate the point cloud\n\t\tinflate_global_pcl();\n\t}\n}\n", "CodeBleu_score": 53.63504257737581}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tgpcl.is_dense = true;\n\t\tgpcl.width = gpcl.points.size();\n\t\tgpcl.height = 1;\n\t\tpcl::toROSMsg(gpcl, gpcl_ros);\n\t\tglobal_map_pub.publish(gpcl_ros);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tgpcl_ptr = gpcl.makeShared();\n\t\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\t\tsor.setInputCloud(gpcl_ptr);\n\t\tsor.setLeafSize(0.1, 0.1, 0.1);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_filtered_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tsor.filter(*gpcl_filtered_ptr);\n\t\tpcl::toROSMsg(*gpcl_filtered_ptr, gpcl_filtered_ros);\n\t\tglobal_map_pub_filtered.publish(gpcl_filtered_ros);\n\t\tstd::cout << \"Global map updated\" << std::endl;\n\t}\n}\n", "CodeBleu_score": 44.27730442740337}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *global_pc);\n\t\tglobal_pc_inflated.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_pc_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t*global_pc_ptr = global_pc;\n\t\tglobal_pc_inflated = global_pc_ptr;\n\t\tglobal_pc_inflated->is_dense = false;\n\t\tglobal_pc_inflated->width = 3;\n\t\tglobal_pc_inflated->height = global_pc_inflated->points.size();\n\t\tglobal_pc_inflated->points.resize(global_pc_inflated->width * global_pc_inflated->height);\n\t\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\t\tsor.setInputCloud(global_pc_inflated);\n\t\tsor.setLeafSize(0.2, 0.2, 0.2);\n\t\tsor.filter(*global_pc_inflated);\n\t\tROS_INFO(\"Global map updated\");\n\t}\n}\n", "CodeBleu_score": 48.382748673638076}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\tif (local_point->header.frame_id!= \"/base_link\") {\n\t\tROS_ERROR(\"Laser scan frame ID is not /base_link\");\n\t\treturn;\n\t}\n\n\tif (odom.header.frame_id!= \"/base_link\") {\n\t\tROS_ERROR(\"Odometry frame ID is not /base_link\");\n\t\treturn;\n\t}\n\n\tif (local_point->header.stamp.toSec() < last_laser_time) {\n\t\tROS_ERROR(\"Laser scan time is not newer than last laser scan time\");\n\t\treturn;\n\t}\n\n\tif (odom.header.stamp.toSec() < last_odom_time) {\n\t\tROS_ERROR(\"Odometry time is not newer than last odometry time\");\n\t\treturn;\n\t}\n\n\tif (local_point->header.stamp.toSec() - last_odom_time > 10) {\n\t\tROS_ERROR(\"Odometry is not newer than 10 seconds\");\n\t\treturn;\n\t}\n\n\tif (local_point->header.stamp.toSec() - last_laser_time > 10) {\n\t\tROS_ERROR(\"Laser scan is not newer than 10 seconds\");\n\t\treturn;\n\t}\n\n\tlast_laser_time = local_point->header.stamp.toSec();\n\tlast_odom_time = odom.header.stamp.toSec();\n\n\t// Transform laser scan to PointCloud2\n\tpcl::PointCloud<pcl::PointXYZ> scan;\n\tpcl::PointXYZ point;\n\tfor (int i = 0; i < local_point->ranges.size(); i++) {\n\t\tif (local_point->ranges[i] > 0) {\n\t\t\tpoint.x = local_point->ranges[i] * cos(local_point->angle_min + i * local_point->angle_increment);\n\t\t\tpoint.y = local_point->ranges[i] * sin(local_point->angle_min + i * local_point->angle_increment);\n\t\t\tpoint.z = 0;\n\t\t\tscan.points.push_back(point);\n\t\t}\n\t}\n\tsensor_msgs::PointCloud2 scan_msg;\n\tpcl", "CodeBleu_score": 38.8529182351764}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\t// Get the current time in milliseconds\n\tdouble current_time_millis = current_time.toNSec() / 1000000.0;\n\n\t// Check if the map is empty\n\tif (map_empty) {\n\t\t// If the map is empty, create the first point cloud\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t// Create a point cloud message\n\t\tpcl::toROSMsg(*local_cloud, local_map_msg);\n\t\t// Publish the local map\n\t\tlocal_map_pub.publish(local_map_msg);\n\t\t// Set the map to not empty\n\t\tmap_empty = false;\n\t}\n\n\t// Create a point cloud from the laser scan\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t// Create a point cloud message\n\tpcl::toROSMsg(*local_cloud, local_map_msg);\n\t// Publish the local map\n\tlocal_map_pub.publish(local_map_msg);\n\n\t// Check if the map is not empty\n\tif (!map_empty) {\n\t\t// If the map is not empty, merge the local map with the laser scan\n\t\t// Create a point cloud from the laser scan\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t// Convert the laser scan to a point cloud\n\t\tpcl::fromROSMsg(local_point->points, *local_cloud);\n\t\t// Merge the local map with the laser scan\n\t\tmerge_local_map(local_cloud, odom);\n\t}\n}\n", "CodeBleu_score": 44.014825684715824}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled_voxel(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled_voxel_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled_voxel_filtered_merged(new pcl::PointCloud<pcl::PointXYZ>);\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled_voxel_filtered_merged_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled_voxel_filtered_merged_downsampled_voxel(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled_voxel_filtered_merged_downsampled_voxel_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled_voxel_filtered_merged_downsampled_voxel_filtered_merged(new pcl::PointCloud<pcl::PointXYZ>);\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_projected_filtered_downsampled_voxel_filtered_merged_downsampled_voxel_filtered_merged_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\t", "CodeBleu_score": 10.224145520652183}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t//ROS_INFO(\"Publishing global point cloud\");\n\tpcl::toROSMsg(*global_map, global_pcl);\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl);\n\n\t//ROS_INFO(\"Publishing inflated point cloud\");\n\tpcl::toROSMsg(*inflate_map, inflate_pcl);\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(inflate_pcl);\n}\n", "CodeBleu_score": 50.881930261715105}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t// ROS_INFO(\"Publishing pcl\");\n\tpcl::toROSMsg(*global_map, global_pcl);\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl);\n\n\tpcl::toROSMsg(*inflate_map, inflate_pcl);\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(inflate_pcl);\n}\n", "CodeBleu_score": 49.90706976491637}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t// Convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic.\n\tpcl::toROSMsg(*global_map, global_pcl);\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl);\n\n\t// Convert the inflated point cloud to a ROS message and publish it with the frame ID \"world\" to the inflate_pcl_pub topic.\n\tpcl::toROSMsg(*inflate_map, inflate_pcl);\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(inflate_pcl);\n}\n", "CodeBleu_score": 55.87013431494905}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif(sensor_ready) {\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\t\tpcl::fromROSMsg(*msg, cloud);\n\t\tsensor_ready = false;\n\t\t//ROS_INFO(\"Received Lidar point cloud\");\n\t\tmap.updateMap(cloud, current_pose, current_twist);\n\t\tsensor_ready = true;\n\t}\n}\n", "CodeBleu_score": 44.81423654358315}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tsensor_ready = true;\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(*msg, cloud);\n\tif (cloud.size() == 0) {\n\t\tROS_INFO(\"Received empty point cloud\");\n\t\treturn;\n\t}\n\t//ROS_INFO(\"Received point cloud with %d points\", (int) cloud.size());\n\t//ROS_INFO(\"Current map size is %d\", (int) map.size());\n\tmap.clear();\n\tfor (size_t i = 0; i < cloud.points.size(); i++) {\n\t\tif (cloud.points[i].x == 0 && cloud.points[i].y == 0 && cloud.points[i].z == 0)\n\t\t\tcontinue;\n\t\tmap.push_back(Point(cloud.points[i].x, cloud.points[i].y, cloud.points[i].z));\n\t}\n\tROS_INFO(\"Map updated\");\n}\n", "CodeBleu_score": 45.14314006604858}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (!sensor_ready) {\n\t\tsensor_ready = true;\n\t\tROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready set to true\");\n\t}\n\n\t// Get current time\n\tros::Time current_time = msg->header.stamp;\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: current_time = %f\", current_time.toSec());\n\n\t// Get current UAV position\n\tdouble uav_x = current_pose.pose.position.x;\n\tdouble uav_y = current_pose.pose.position.y;\n\tdouble uav_z = current_pose.pose.position.z;\n\tdouble uav_roll = current_pose.pose.orientation.x;\n\tdouble uav_pitch = current_pose.pose.orientation.y;\n\tdouble uav_yaw = current_pose.pose.orientation.z;\n\tdouble uav_w = current_pose.pose.orientation.w;\n\ttf::Quaternion q(uav_roll, uav_pitch, uav_yaw, uav_w);\n\ttf::Matrix3x3 m(q);\n\tdouble roll, pitch, yaw;\n\tm.getRPY(roll, pitch, yaw);\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: uav_x = %f, uav_y = %f, uav_z = %f, uav_roll = %f, uav_pitch = %f, uav_yaw = %f\", uav_x, uav_y, uav_z, uav_roll, uav_pitch, uav_yaw);\n\n\t// Get current UAV velocity\n\tdouble uav_vx = current_velocity.twist.linear.x;\n\tdouble uav_vy = current_velocity.twist.linear.y;\n\tdouble uav_vz = current_velocity.twist.linear.z;\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: uav_vx = %f, uav_vy = %f, uav_vz = %f\", uav_vx, uav_vy, uav_vz);\n\n\t// Get current UAV acceleration\n\tdouble", "CodeBleu_score": 44.20442280627401}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)#ifdef DEBUG_PRINT\n  static int count = 0;\n  count++;\n  if (count % 100 == 0) {\n    std::cout << \"control loop\" << std::endl;\n  }", "CodeBleu_score": 14.588155350064552}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\n#ifdef DEBUG\n  std::cout << \"controlLoop_ called\" << std::endl;", "CodeBleu_score": 5.497353558494658}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get current time\n\tros::Time time_now = ros::Time::now();\n\t// Get current time in seconds\n\tdouble time_now_seconds = time_now.toSec();\n\t// Get the time elapsed since the last control loop\n\tdouble dt = time_now_seconds - last_time_seconds_;\n\t// Update last time\n\tlast_time_seconds_ = time_now_seconds;\n\n\t// Get current joint positions\n\tcurrent_joint_positions_ = joint_states_.position;\n\n\t// Get current joint velocities\n\tcurrent_joint_velocities_ = joint_states_.velocity;\n\n\t// Get current base velocity\n\tgeometry_msgs::Twist base_velocity = base_velocity_filter_.getVelocity();\n\n\t// Get base velocity in the world frame\n\tEigen::Vector3d base_velocity_world = base_velocity_filter_.getVelocityWorld();\n\n\t// Get base velocity in the world frame\n\tEigen::Vector3d base_velocity_world_filtered = base_velocity_filter_.getVelocityWorldFiltered();\n\n\t// Get base acceleration in the world frame\n\tEigen::Vector3d base_acceleration_world = base_velocity_filter_.getAccelerationWorld();\n\n\t// Get base acceleration in the world frame\n\tEigen::Vector3d base_acceleration_world_filtered = base_velocity_filter_.getAccelerationWorldFiltered();\n\n\t// Get base jerk in the world frame\n\tEigen::Vector3d base_jerk_world = base_velocity_filter_.getJerkWorld();\n\n\t// Get base jerk in the world frame\n\tEigen::Vector3d base_jerk_world_filtered = base_velocity_filter_.getJerkWorldFiltered();\n\n\t// Get base snap in the world frame\n\tEigen::Vector3d base_snap_world = base_velocity_filter_.getSnapWorld();\n\n\t// Get base snap in the world frame\n\tEigen::Vector3d base_snap_world_filtered = base_velocity_filter_.getSnapWorldFiltered();\n\n\t// Get base twist in the world frame\n\tEigen::Vector3d base_twist_world = base_velocity_filter_.getTwistWorld();\n\n\t// Get base twist in the world frame\n\tEigen::Vector3d base_twist_world_filtered", "CodeBleu_score": 32.25496793111523}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])#ifndef GAZEBO\n  // Create the message.\n  ContactsStamped foot_contacts_msg;\n  foot_contacts_msg.header.stamp = ros::Time::now();\n  foot_contacts_msg.header.frame_id = robot_model_.base_link_;\n\n  // Populate the message.\n  for (int leg_idx = 0; leg_idx < 4; leg_idx++) {\n    foot_contacts_msg.contacts.push_back(Contact());\n    foot_contacts_msg.contacts.back().position.z = -0.085;\n    foot_contacts_msg.contacts.back().normal.z = 1.0;\n    foot_contacts_msg.contacts.back().contact_positions.push_back(\n        robot_model_.foot_positions_[leg_idx]);\n    foot_contacts_msg.contacts.back().contact_normals.push_back(\n        robot_model_.foot_normals_[leg_idx]);\n    foot_contacts_msg.contacts.back().contact_positions.push_back(\n        robot_model_.foot_positions_[leg_idx] +\n        robot_model_.foot_normals_[leg_idx] * 0.02);\n    foot_contacts_msg.contacts.back().contact_normals.push_back(\n        robot_model_.foot_normals_[leg_idx]);\n    foot_contacts_msg.contacts.back().contact_positions.push_back(\n        robot_model_.foot_positions_[leg_idx] -\n        robot_model_.foot_normals_[leg_idx] * 0.02);\n    foot_contacts_msg.contacts.back().contact_normals.push_back(\n        robot_model_.foot_normals_[leg_idx]);\n    foot_contacts_msg.contacts.back().contact_positions.push_back(\n        robot_model_.foot_positions_[leg_idx] +\n        robot_model_.foot_normals_[leg_idx] * 0.01);\n    foot_contacts_msg.contacts.back().contact_normals.push_back(\n        robot_model_.foot_normals_[leg_idx]);\n    foot_contacts_msg.contacts.back().contact_positions.push_back(\n        robot_model_.foot_positions_[leg_idx] -\n        robot_model_.foot_normals_[leg_idx] *", "CodeBleu_score": 43.82109868494855}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])#ifndef GAZEBO\n  if (foot_contact_for_current_gait_phase_ &&!gazebo_) {\n    foot_contacts_msg_.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      foot_contacts_msg_.contacts[i].contact_positions[0] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_positions[1] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_positions[2] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_normals[0] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_normals[1] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_normals[2] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_positions_z[0] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_positions_z[1] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_positions_z[2] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_normals_z[0] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_normals_z[1] = 0.0;\n      foot_contacts_msg_.contacts[i].contact_normals_z[2] = 0.0;\n      foot_contacts_msg_.contacts[i].depths[0] = 0.0;\n      foot_contacts_msg_.contacts[i].depths[1] = 0.0;\n      foot_contacts_msg_.contacts[i].depths[2] = 0.0;\n      foot_contacts_msg_.contacts[i].positions_valid[0] = 0;\n      foot_contacts_msg_.contacts[i].positions_valid[1] = 0;\n      foot_contacts_msg_.contacts[i].positions_valid[2] = 0;\n      foot_contacts_msg_.contacts[i].normals_valid[0] = 0;\n      foot_contacts_msg_.contacts[i].normals_", "CodeBleu_score": 53.09387676485442}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])#ifndef GAZEBO\n  if (foot_contacts_publisher_.getTopic().empty()) {\n    return;\n  }\n\n  ContactsStamped contacts_stamped;\n  contacts_stamped.header.stamp = ros::Time::now();\n  contacts_stamped.header.frame_id = robot_description_ + \"/base_link\";\n  for (int i = 0; i < 4; ++i) {\n    contacts_stamped.contacts.push_back(Contact());\n    contacts_stamped.contacts.back().position.x = foot_positions_[i].x;\n    contacts_stamped.contacts.back().position.y = foot_positions_[i].y;\n    contacts_stamped.contacts.back().position.z = foot_positions_[i].z;\n    contacts_stamped.contacts.back().normal.x = 0.0;\n    contacts_stamped.contacts.back().normal.y = 0.0;\n    contacts_stamped.contacts.back().normal.z = 1.0;\n    contacts_stamped.contacts.back().depth = 0.0;\n    contacts_stamped.contacts.back().state = foot_contacts[i]? ContactState::STATE_IN_CONTACT : ContactState::STATE_AT_SURFACE;\n  }\n  foot_contacts_publisher_.publish(contacts_stamped);", "CodeBleu_score": 36.7913878968804}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)\t# Construct a minimal joints message\n\t# Note that the joint names must be in the same order as the joints in the URDF file\n\tjoints_msg = JointState()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_msg.name = ['shoulder_pan_joint','shoulder_lift_joint', 'elbow_joint', 'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']\n\tjoints_msg.position = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5]]\n\tjoints_msg.velocity = []\n\tjoints_msg.effort = []\n\n\t# Publish the joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t# Construct a joint trajectory message\n\t# Note that the joint names must be in the same order as the joints in the URDF file\n\ttraj_msg = JointTrajectory()\n\ttraj_msg.header.stamp = rospy.Time.now() + rospy.Duration(0.01)\n\ttraj_msg.joint_names = ['shoulder_pan_joint','shoulder_lift_joint', 'elbow_joint', 'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']\n\ttraj_msg.points.append(JointTrajectoryPoint())\n\ttraj_msg.points[0].positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5]]\n\ttraj_msg.points[0].velocities = []\n\ttraj_msg.points[0].accelerations = []\n\ttraj_msg.points[0].time_from_start = rospy.Duration(2.0)\n\n\t# Publish the joint trajectory message\n\tself.traj_pub.publish(traj_msg)\n}\n", "CodeBleu_score": 39.922819337566786}, {"code": "def joints_cmd_callback(self, joints)\t# Create a message that contains only the first 12 joint positions.\n\tmsg = JointState()\n\tmsg.position = joints.position[:12]\n\tmsg.name = self.joint_names[:12]\n\tmsg.header.stamp = rospy.Time.now()\n\tself.joints_pub.publish(msg)\n\t# Create a message that contains the first 12 joint positions and a specified duration.\n\ttraj_msg = JointTrajectory()\n\ttraj_msg.joint_names = self.joint_names[:12]\n\ttraj_msg.points.append(JointTrajectoryPoint())\n\ttraj_msg.points[0].positions = msg.position\n\ttraj_msg.points[0].time_from_start = rospy.Duration(self.duration)\n\tself.traj_pub.publish(traj_msg)\n}\n", "CodeBleu_score": 46.68474138062641}, {"code": "def joints_cmd_callback(self, joints)\tif (joints.positions.size()!= 12) {\n\t\tROS_ERROR(\"Invalid number of joint positions (%d) sent to joints_cmd_callback. Expected 12.\", joints.positions.size());\n\t\treturn;\n\t}\n\n\tstd_msgs::Float64MultiArray joint_positions;\n\tjoint_positions.data.resize(12);\n\tfor (int i = 0; i < 12; i++) {\n\t\tjoint_positions.data[i] = joints.positions[i];\n\t}\n\n\t// Publish the joint positions.\n\tself.pub_joint_positions.publish(joint_positions);\n\n\t// Construct the joint trajectory message.\n\tcontrol_msgs::FollowJointTrajectoryGoal goal;\n\tgoal.trajectory.joint_names.resize(12);\n\tfor (int i = 0; i < 12; i++) {\n\t\tgoal.trajectory.joint_names[i] = std::string(\"joint\") + std::to_string(i + 1);\n\t}\n\tgoal.trajectory.points.resize(1);\n\tgoal.trajectory.points[0].positions.resize(12);\n\tfor (int i = 0; i < 12; i++) {\n\t\tgoal.trajectory.points[0].positions[i] = joints.positions[i];\n\t}\n\tgoal.trajectory.points[0].velocities.resize(12);\n\tfor (int i = 0; i < 12; i++) {\n\t\tgoal.trajectory.points[0].velocities[i] = 0.0;\n\t}\n\tgoal.trajectory.points[0].accelerations.resize(12);\n\tfor (int i = 0; i < 12; i++) {\n\t\tgoal.trajectory.points[0].accelerations[i] = 0.0;\n\t}\n\tgoal.trajectory.points[0].time_from_start = ros::Duration(self.trajectory_duration);\n\n\t// Publish the joint trajectory message.\n\tself.pub_joint_trajectory.publish(goal);\n}\n", "CodeBleu_score": 37.22519951710537}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)\\t\\t\\tstd::string link_name;", "CodeBleu_score": 3.7123447945366608}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string link_name = _msg->contact(i).collision1().id();\n\t\tlink_name = link_name.substr(0, link_name.find(\"::\"));\n\t\tif (link_name == \"left_foot\" || link_name == \"right_foot\") {\n\t\t\tfoot_contact_[link_name] = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.58706483682161}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\\t// Get the number of contacts", "CodeBleu_score": 1.369901551799362}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Check input\n\tASSERT_LE(0.0, thrust_);\n\tASSERT_LE(0.0, angular_acceleration_);\n\n\t// Set all rotor velocities to zero if the controller is not active\n\tif (!active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Compute the desired acceleration and angular acceleration\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d desired_angular_acceleration;\n\tdesired_acceleration << 0.0, 0.0, thrust_;\n\tdesired_angular_acceleration << 0.0, 0.0, angular_acceleration_;\n\n\t// Project thrust onto the body z-axis\n\tEigen::Vector3d thrust_projected;\n\tthrust_projected << 0.0, 0.0, thrust_ * cos(desired_angular_acceleration(2));\n\n\t// Combine desired acceleration and angular acceleration into a single vector\n\tEigen::Vector3d desired_acceleration_and_angular_acceleration;\n\tdesired_acceleration_and_angular_acceleration << desired_acceleration(0) + thrust_projected(0), desired_acceleration(1) + thrust_projected(1), desired_acceleration(2) + thrust_projected(2);\n\n\t// Compute the rotor velocities\n\tEigen::Matrix3d rotor_matrix;\n\trotor_matrix << 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0;\n\tEigen::Vector3d rotor_velocities_temp;\n\trotor_velocities_temp << desired_acceleration_and_angular_acceleration(0) / sqrt(3.0), desired_acceleration_and_angular_acceleration(1) / sqrt(3.0), desired_acceleration_and_angular_acceleration(2) / sqrt(3.0);\n\trotor_velocities->noalias() = rotor_matrix * rotor_velocities_temp;\n\n\t// Ensure non-negative values\n\tfor (int i = 0; i < 3; i++) {\n\t\tif ((*rotor_velocities)(i) < 0.0) {\n\t\t\t(*", "CodeBleu_score": 43.370642979028986}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Ensure input is valid.\n\tassert(rotor_velocities!= nullptr);\n\n\t// If the controller is not active, set all rotor velocities to zero.\n\tif (!this->is_active_) {\n\t\trotor_velocities->setZero(this->num_rotors_);\n\t\treturn;\n\t}\n\n\t// Calculate the desired acceleration and angular acceleration.\n\tEigen::VectorXd desired_acceleration = this->desired_state_.segment(this->num_positions_, this->num_velocities_);\n\tEigen::VectorXd desired_angular_acceleration = this->desired_state_.segment(this->num_positions_ + this->num_velocities_, this->num_rotors_);\n\n\t// Project thrust onto the body z-axis.\n\tEigen::VectorXd thrust_projected = this->thrust_moment_.segment(0, this->num_rotors_);\n\tthrust_projected.normalize();\n\n\t// Combine angular acceleration and thrust into a single vector.\n\tEigen::VectorXd combined_desired_acceleration = thrust_projected + desired_angular_acceleration;\n\n\t// Compute the rotor velocities.\n\tEigen::VectorXd rotor_velocities_temp = this->rotor_matrix_ * combined_desired_acceleration;\n\trotor_velocities->setZero(this->num_rotors_);\n\tfor (int i = 0; i < this->num_rotors_; ++i) {\n\t\t(*rotor_velocities)[i] = sqrt(fmax(0.0, rotor_velocities_temp[i]));\n\t}\n}\n", "CodeBleu_score": 34.785215452027174}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\n}\n", "CodeBleu_score": 2.947191336884822}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// TODO: Fill this in.\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d velocity_world;\n\tEigen::Vector3d acceleration_world;\n\tEigen::Vector3d acceleration_body;\n\n\t// Get the position and velocity errors.\n\tposition_error = (trajectory_position_ - vehicle_state_.position);\n\tvelocity_error = (trajectory_velocity_ - vehicle_state_.velocity);\n\n\t// Transform the vehicle's velocity to the world frame.\n\tvelocity_world = vehicle_state_.rotation * vehicle_state_.velocity;\n\n\t// Compute the desired acceleration.\n\tacceleration_world = -position_gain_ * position_error - velocity_gain_ * velocity_error - gravity_;\n\tacceleration_body = vehicle_state_.rotation.transpose() * acceleration_world;\n\t*acceleration = acceleration_body;\n}\n", "CodeBleu_score": 46.16952474533508}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// Transform the vehicle's velocity to the world frame.\n\tEigen::Vector3d velocity_world = vehicle_state_.velocity_.rotation() * vehicle_state_.velocity_.translation();\n\n\t// Compute the position error.\n\tEigen::Vector3d position_error = vehicle_state_.position_.translation() - command_trajectory_.position_;\n\n\t// Compute the velocity error.\n\tEigen::Vector3d velocity_error = velocity_world - command_trajectory_.velocity_;\n\n\t// Compute the desired acceleration.\n\tEigen::Vector3d desired_acceleration = -k_position_ * position_error - k_velocity_ * velocity_error;\n\n\t// Adjust for vehicle mass and gravity.\n\tdesired_acceleration += vehicle_state_.mass_ * gravity_;\n\n\t// Limit the acceleration to the commanded acceleration.\n\tdesired_acceleration = desired_acceleration.cwiseMin(command_trajectory_.acceleration_);\n\tdesired_acceleration = desired_acceleration.cwiseMax(-command_trajectory_.acceleration_);\n\n\t// Store the acceleration.\n\tacceleration->setZero();\n\tacceleration->head(2) = desired_acceleration.head(2);\n}\n", "CodeBleu_score": 44.740442939661726}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// TODO: Fill this in.\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d velocity_world;\n\tEigen::Vector3d acceleration_world;\n\n\t// Position error.\n\tposition_error = (desired_trajectory_.back().position_ - vehicle_state_.position_);\n\n\t// Velocity error.\n\tvelocity_error = (desired_trajectory_.back().velocity_ - vehicle_state_.velocity_);\n\n\t// Transform the vehicle's velocity to the world frame.\n\tvelocity_world = vehicle_state_.rotation_matrix_.transpose() * vehicle_state_.velocity_;\n\n\t// Calculate the desired acceleration in the world frame.\n\tacceleration_world = (k_p_position_ * position_error) + (k_p_velocity_ * velocity_error) + (k_d_velocity_ * (velocity_world - desired_trajectory_.back().velocity_)) + (gravity_ * vehicle_state_.mass_);\n\n\t// Transform the acceleration back to the vehicle frame.\n\t*acceleration = vehicle_state_.rotation_matrix_ * acceleration_world;\n}\n", "CodeBleu_score": 46.60795961810399}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Ensure the rotor velocities vector is the correct size.\n\tif (rotor_velocities->rows()!= rotor_velocities_.rows()) {\n\t\trotor_velocities->resize(rotor_velocities_.rows());\n\t}\n\n\t// Ensure the input is valid.\n\tif (thrust_reference_ < 0) {\n\t\tthrust_reference_ = 0;\n\t}\n\n\t// Calculate the desired angular acceleration.\n\tEigen::Vector3d angular_acceleration = CalculateAngularAcceleration();\n\n\t// Calculate the rotor velocities.\n\tfor (int i = 0; i < rotor_velocities_.rows(); ++i) {\n\t\trotor_velocities->coeffRef(i) = sqrt(\n\t\t\t(thrust_reference_ + rotor_thrusts_.coeffRef(i)) /\n\t\t\t(rotor_mass_ * rotor_inertia_.coeffRef(i) + rotor_inertia_constant_ * angular_acceleration.coeffRef(i) * angular_acceleration.coeffRef(i)));\n\t}\n}\n", "CodeBleu_score": 38.701955141763925}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Ensure the input is valid\n\tassert(rotor_velocities!= nullptr);\n\n\t// Resize the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(rotor_velocities_matrix_.cols());\n\n\t// Calculate the desired angular acceleration\n\tEigen::VectorXd angular_acceleration = thrust_reference_ * thrust_to_attitude_matrix_.transpose();\n\n\t// Combine the desired angular acceleration with the thrust reference into a single vector\n\tEigen::VectorXd combined_vector = angular_acceleration + thrust_reference_;\n\n\t// Compute the rotor velocities\n\t*rotor_velocities = rotor_velocities_matrix_ * combined_vector;\n\n\t// Take the square root of each component\n\trotor_velocities->array() = rotor_velocities->array().sqrt();\n}\n", "CodeBleu_score": 38.05366494287512}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Check that the input is valid\n\tassert(rotor_velocities!= NULL);\n\tassert(rotor_velocities->size() == kNumRotors);\n\n\t// Resize the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(kNumRotors);\n\n\t// Calculate the desired angular acceleration\n\tEigen::VectorXd angular_acceleration = CalculateDesiredAngularAcceleration();\n\n\t// Combine the thrust reference and the desired angular acceleration into a single vector\n\tEigen::VectorXd combined_input = thrust_reference_ + angular_acceleration;\n\n\t// Calculate the rotor velocities by multiplying with a predefined matrix\n\tEigen::VectorXd rotor_velocities_pre_scaling = rotor_matrix_ * combined_input;\n\n\t// Ensure that the rotor velocities are at least one\n\trotor_velocities_pre_scaling = rotor_velocities_pre_scaling.cwiseMax(1.0);\n\n\t// Take the square root of each component\n\t*rotor_velocities = rotor_velocities_pre_scaling.cwiseSqrt();\n}\n", "CodeBleu_score": 42.06200661319853}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    # Find the corresponding indices for the start and end times\n    start_index = self.time.index(start_time)\n    end_index = self.time.index(end_time)\n    # Make a deep copy of the object\n    new_object = copy.deepcopy(self)\n    # Slice the attributes\n    new_object.time = self.time[start_index:end_index+1]\n    new_object.data = self.data[start_index:end_index+1]\n    new_object.units = self.units\n    new_object.name = self.name\n    new_object.description = self.description\n    new_object.metadata = self.metadata\n    new_object.data_type = self.data_type\n    new_object.data_format = self.data_format\n    new_object.data_structure = self.data_structure\n    new_object.data_repository = self.data_repository\n    new_object.data_owner = self.data_owner\n    new_object.data_location = self.data_location\n    new_object.data_query = self.data_query\n    new_object.data_access_url = self.data_access_url\n    new_object.data_access_format = self.data_access_format\n    new_object.data_access_method = self.data_access_method\n    new_object.data_access_email = self.data_access_email\n    new_object.data_access_phone = self.data_access_phone\n    new_object.data_access_address = self.data_access_address\n    new_object.data_access_code = self.data_access_code\n    new_object.data_access_notes = self.data_access_notes\n    new_object.data_access_url_notes = self.data_access_url_notes\n    new_object.data_access_format_notes = self.data_access_format_notes\n    new_object.data_access_method_notes = self.data_access_method_notes\n    new_object.data_access_email_notes = self.data_access_email_notes\n    new_object.data_access_phone_notes = self.data_access_phone_notes\n    new_object.data_access_address_", "CodeBleu_score": 25.076994200477777}, {"code": "def slice(self, start_time, end_time)\n    # Find the corresponding indices for the start and end times\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n    # Update each attribute of the copied object to contain only the sliced data\n    for attribute in self.attributes:\n        if attribute == 'time':\n            sliced_object.time = self.time[start_index:end_index]\n        else:\n            sliced_object.__dict__[attribute] = self.__dict__[attribute][start_index:end_index]\n    # Return the copied and sliced object\n    return sliced_object\n", "CodeBleu_score": 35.31746491067281}, {"code": "def slice(self, start_time, end_time)\n    # Create a copy of the object\n    new_obj = copy.deepcopy(self)\n\n    # Find the indices of the start and end times\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n\n    # Slice the data for each attribute\n    for attribute in self.attributes:\n        new_obj.data[attribute] = self.data[attribute][start_index:end_index]\n\n    # Return the copied and sliced object\n    return new_obj\n", "CodeBleu_score": 25.57981959996883}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert quaternion to euler angles\n    euler_angles = tf.transformations.euler_from_quaternion((rotation.x, rotation.y, rotation.z, rotation.w))\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if waypoint is different from last one\n    if self.last_point is None or self.last_point.position!= point or self.last_yaw!= euler_angles[2]:\n      # Append point, yaw, and time\n      self.points.append(point)\n      self.yaws.append(euler_angles[2])\n      self.times.append(msg_time.to_sec() - bag_time.to_sec())\n    # Update last point and yaw\n    self.last_point = point\n    self.last_yaw = euler_angles[2]\n", "CodeBleu_score": 23.942978358163145}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation\n    pos = waypoint_msg.pose.pose.position\n    rot = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    (roll, pitch, yaw) = euler_from_quaternion([rot.x, rot.y, rot.z, rot.w])\n\n    # Create Point object\n    point = Point()\n    point.x = pos.x\n    point.y = pos.y\n    point.z = pos.z\n\n    # Check if the current waypoint is different from the last one\n    if (point.x!= self.last_point.x) or (point.y!= self.last_point.y) or (point.z!= self.last_point.z) or (yaw!= self.last_yaw):\n        # Append point, yaw, and time to their respective arrays\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time.to_sec() - bag_time.to_sec())\n\n        # Update last point and yaw\n        self.last_point = point\n        self.last_yaw = yaw\n", "CodeBleu_score": 23.058145568004843}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert the rotation to Euler angles\n    (roll, pitch, yaw) = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object from the position\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if (self.last_point is None) or (self.last_point!= point) or (self.last_yaw!= yaw):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n\n        # Update the last point and yaw\n        self.last_point = point\n        self.last_yaw = yaw\n", "CodeBleu_score": 25.637950020016202}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    # Convert the message timestamp to seconds\n    msg_time = msg.header.stamp.secs + (msg.header.stamp.nsecs / 1000000000.0)\n    # If the topic matches, append the linear acceleration data to the corresponding x, y, and z attributes\n    if topic == self.accel_topic:\n      self.accel_x.append(msg.linear_acceleration.x)\n      self.accel_y.append(msg.linear_acceleration.y)\n      self.accel_z.append(msg.linear_acceleration.z)\n    # Append the message time and bag time to the time attributes\n    self.accel_time.append(msg_time)\n    self.accel_bag_time.append(bag_time)\n\n  def extract_gps_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract_gps_topics, appends GPS topic message content to latitude and longitude attributes.\\nIt converts the message timestamp to seconds.\\nFor each GPS topic, if the topic matches, it appends the latitude and longitude data to the corresponding attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n    # Convert the message timestamp to seconds\n    msg_time = msg.header.stamp.secs + (msg.header.stamp.nsecs / 1000000000.0)\n    # If the topic matches, append the latitude and longitude data to the corresponding attributes\n    if topic == self.gps_topic:\n      self.gps_lat.append(msg.latitude)\n      self.gps_lon.append(msg.longitude)\n    # Append the message time and bag time to the time attributes\n    self.gps_time.append(msg_time)\n    self.gps_bag_time.append(bag_time)\n\n  def extract_odom_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract_odom_topics, appends Odometry topic message content to x, y, and yaw attributes.\\nIt converts the message timestamp to seconds.\\nFor each Odometry topic, if the topic matches, it appends the x, y, and yaw data to the corresponding attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n    # Convert the message timestamp to seconds\n    msg_time", "CodeBleu_score": 30.055089430288184}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu/data\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.bag_time.append(bag_time)\n    elif topic == \"/imu/data_raw\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.bag_time.append(bag_time)\n    elif topic == \"/imu/mag\":\n        self.magnetic_x.append(msg.magnetic_field.x)\n        self.magnetic_y.append(msg.magnetic_field.y)\n        self.magnetic_z.append(msg.magnetic_field.z)\n        self.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.bag_time.append(bag_time)\n    elif topic == \"/imu/mag_raw\":\n        self.magnetic_x.append(msg.magnetic_field.x)\n        self.magnetic_y.append(msg.magnetic_field.y)\n        self.magnetic_z.append(msg.magnetic_field.z)\n        self.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.bag_time.append(bag_time)\n    elif topic == \"/imu/temperature\":\n        self.temperature.append(msg.temperature)\n        self.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.bag_time.append(bag_time)\n    elif topic == \"/imu/data_raw_mag\":\n        self.acceleration_x.append", "CodeBleu_score": 28.34796859110026}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu/data\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.acceleration_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.acceleration_bag_time.append(bag_time)\n    elif topic == \"/imu/data_raw\":\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.acceleration_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.acceleration_bag_time.append(bag_time)\n    elif topic == \"/imu/mag\":\n        self.magnetic_x.append(msg.magnetic_field.x)\n        self.magnetic_y.append(msg.magnetic_field.y)\n        self.magnetic_z.append(msg.magnetic_field.z)\n        self.magnetic_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.magnetic_bag_time.append(bag_time)\n    elif topic == \"/imu/mag_raw\":\n        self.magnetic_x.append(msg.magnetic_field.x)\n        self.magnetic_y.append(msg.magnetic_field.y)\n        self.magnetic_z.append(msg.magnetic_field.z)\n        self.magnetic_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.magnetic_bag_time.append(bag_time)\n    elif topic == \"/imu/temperature\":\n        self.temperature.append(msg.temperature)\n        self.temperature_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.temperature_bag_time.append(bag", "CodeBleu_score": 29.129950586404384}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n    # Create a figure with a title and a subplot for accelerations\n    fig, ax = plt.subplots(1, 1, figsize=(10, 6))\n    fig.suptitle('Accelerations')\n\n    # Plot the x, y, and z components over time with different colors and labels\n    for i, data in enumerate(self.accelerations):\n        ax.plot(data[:, 0], data[:, 1], label=f'x{i}', color='red')\n        ax.plot(data[:, 0], data[:, 2], label=f'y{i}', color='green')\n        ax.plot(data[:, 0], data[:, 3], label=f'z{i}', color='blue')\n\n    # Add labels for the x and y axes\n    ax.set(xlabel='Time (s)', ylabel='Acceleration (g)')\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        plot_filename = f'{self.plot_prefix}accelerations{plot_suffix}.png'\n        plt.savefig(plot_filename)\n\n    # Display the plot\n    plt.show()\n", "CodeBleu_score": 31.980850155823}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    # create figure\n    fig = plt.figure(figsize=(10, 10))\n    # create subplot for accelerations\n    ax = fig.add_subplot(111)\n    # add title\n    ax.set_title(\"Accelerations\")\n    # add labels for x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    # plot each acceleration dataset\n    for accel in self.accelerations:\n        # plot x component\n        ax.plot(accel.time, accel.x, label=accel.name + \" x\")\n        # plot y component\n        ax.plot(accel.time, accel.y, label=accel.name + \" y\")\n        # plot z component\n        ax.plot(accel.time, accel.z, label=accel.name + \" z\")\n    # add legend\n    ax.legend()\n    # save plot if saving plots is enabled\n    if self.save_plots:\n        # construct filename\n        filename = \"accelerations\"\n        # add suffix if it is provided\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        # add file extension\n        filename += \".png\"\n        # save plot\n        plt.savefig(filename)\n    # show plot if show plots is enabled\n    if self.show_plots:\n        plt.show()\n    # close plot\n    plt.close()\n", "CodeBleu_score": 36.54844905718717}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    if self.save_plots:\n      if plot_suffix == None:\n        plot_suffix = \"\"\n      else:\n        plot_suffix = \"_\" + plot_suffix\n    else:\n      plot_suffix = \"\"\n\n    fig, axs = plt.subplots(3, sharex=True, figsize=(10, 7))\n    fig.suptitle(\"Accelerations\")\n    fig.subplots_adjust(hspace=0.3)\n\n    for i in range(3):\n      axs[i].plot(self.accelerations[i], label=\"x\")\n      axs[i].plot(self.accelerations[i + 3], label=\"y\")\n      axs[i].plot(self.accelerations[i + 6], label=\"z\")\n      axs[i].legend()\n      axs[i].set_ylabel(\"Acceleration (m/s^2)\")\n\n    axs[2].set_xlabel(\"Time (s)\")\n    axs[2].set_xlim(0, self.time[-1])\n    fig.savefig(\"accelerations\" + plot_suffix + \".png\")\n    plt.close()\n\n  def plot_gyroscope_angles(self, plot_suffix=None):\n    \"\"\"This function, plot_gyroscope_angles, generates and saves a plot of gyroscope data.\\nIt creates a figure with a title and a subplot for gyroscope angles.\\nFor each gyroscope dataset, it plots the x, y, and z components over time with different colors and labels.\\nIt adds labels for the x and y axes and includes a legend.\\nIf saving plots is enabled, it constructs a filename based on a prefix and optional suffix and saves the plot as a PNG file.\"\"\"\n    if self.save_plots:\n      if plot_suffix == None:\n        plot_suffix = \"\"\n      else:\n        plot_suffix = \"_\" + plot_suffix\n    else:\n      plot_suffix = \"\"\n\n    fig, axs = plt.subplots(3, sharex=True, figsize=(10, 7))\n    fig.suptitle(\"Gyroscope Angles\")\n    fig.subplots_adjust(hspace=0.3)\n\n    for i in range(3):\n      axs[i].plot(self.gyroscope_angles[i], label=\"x\")\n      axs[i].plot(self.gyroscope_angles[i + 3], label=\"y\")\n      axs[i].", "CodeBleu_score": 29.72221551513718}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"Error: compare_positions requires at least two pose indices.\")\n        return\n    for i in range(len(pose_indeces)-1):\n        compare_two_xyz(self, pose_indeces[i], pose_indeces[i+1])\n", "CodeBleu_score": 31.756990443775663}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        raise ValueError(\"Please enter at least two pose indices.\")\n    for index in pose_indeces:\n        for compare_index in pose_indeces[pose_indeces.index(index)+1:]:\n            compare_two_xyz(self, index, compare_index)\n", "CodeBleu_score": 38.16473138002352}, {"code": "def compare_positions(self, pose_indeces)\n    # Check if there are at least two pose indices to compare\n    if len(pose_indeces) < 2:\n        print(\"Not enough pose indices to compare.\")\n        return\n    # Iterate through each pose index\n    for i in range(len(pose_indeces)):\n        # Iterate through each subsequent pose index\n        for j in range(i+1, len(pose_indeces)):\n            # Compare the positions of the two poses\n            compare_two_xyz(self, pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 36.505577832800796}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    if start_time == None:\n        start_time = 0\n    if end_time == None:\n        end_time = self.wrench.times[-1]\n    collision_times = []\n    for time in self.wrench.times:\n        if time >= start_time and time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 43.27804295194858}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n        if start_time is not None and end_time is not None:\n            if time >= start_time and time <= end_time:\n                collision_times.append(time)\n        elif start_time is not None and end_time is None:\n            if time >= start_time:\n                collision_times.append(time)\n        elif start_time is None and end_time is not None:\n            if time <= end_time:\n                collision_times.append(time)\n        else:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 37.20431347919945}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    if start_time == None:\n        start_time = self.start_time\n    if end_time == None:\n        end_time = self.end_time\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 41.78904223009632}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 29.32422071502378}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 31.476525987439373}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time,\n                                        x_range, plot_suffix, [-1.5, 1.5])\n", "CodeBleu_score": 32.71336842093475}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)if (data == nullptr) return;\n", "CodeBleu_score": 6.225230410272026}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)if (!data) {", "CodeBleu_score": 4.482368611123783}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)if (data == nullptr) {", "CodeBleu_score": 6.338866405257071}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\n//  ROS_INFO(\"Waypoint callback called\");\n\n  // Get current simulation time\n  gazebo::common::Time sim_time = this->parent->GetWorld()->GetSimTime();\n\n  // Convert to ROS time\n  ros::Time ros_time(sim_time.sec, sim_time.nsec);\n\n  // Write message to bag file\n  this->bag_.write(this->namespace_ + \"/\" + this->waypoint_topic_, ros_time,\n                   *trajectory_msg);\n}\n", "CodeBleu_score": 52.30903149710298}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)#if GAZEBO_MAJOR_VERSION >= 8\n  common::Time current_time = parent_model_->GetWorld()->SimTime();", "CodeBleu_score": 17.654905146659967}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)#if GAZEBO_MAJOR_VERSION >= 8\n  ros::Time timestamp = ros::Time::now();", "CodeBleu_score": 12.226913644580156}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\n#if GAZEBO_MAJOR_VERSION >= 8\n  double dt = (now - last_time).Double();", "CodeBleu_score": 6.821788508333344}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\tros::Time ros_time = ros::Time(now.sec, now.nsec);\n\t// Prepare message for actuator velocities\n\t// Note: The joint velocities are set to the slowed-down rotational velocities\n\t//       to avoid the joints from moving too fast.\n\tgazebo_msgs::JointCmd msg;\n\tmsg.header.stamp = ros_time;\n\tmsg.header.frame_id = \"world\";\n\tmsg.name.resize(motor_velocities_.size());\n\tmsg.velocity.resize(motor_velocities_.size());\n\tfor (unsigned int i = 0; i < motor_velocities_.size(); i++) {\n\t\tmsg.name[i] = motor_velocities_.keys()[i];\n\t\tmsg.velocity[i] = motor_velocities_[msg.name[i]];\n\t}\n\t// Write message to bag file\n\tbag_.write(namespace_ + \"/\" + motor_topic_, ros_time, msg);\n}\n", "CodeBleu_score": 51.37384446456764}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\\tfor (int i = 0; i < kNumMotors; i++) {", "CodeBleu_score": 7.117594393187186}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#ifdef DEBUG_PRINT\n  gzdbg << \"RollPitchYawrateThrustCallback called\\n\";", "CodeBleu_score": 2.8819009830884337}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#if GAZEBO_PLUGIN_DEBUG\n  gzmsg << \"RollPitchYawrateThrustCallback called\" << std::endl;", "CodeBleu_score": 3.366517074982642}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#if GAZEBO_FW_DYNAMICS_PLUGIN_DEBUG_PRINT == 1\n  gzdbg << \"RollPitchYawrateThrustCallback() called.\\n\";", "CodeBleu_score": 2.9388891327251403}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#if GAZEBO_MAJOR_VERSION >= 8\n  boost::posix_time::ptime t_start =\n      boost::posix_time::microsec_clock::local_time();", "CodeBleu_score": 2.403580372566438}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#if MAVLINK_COMM_NUM_BUFFERS > 0\n  fd_set rfds;\n  struct timeval tv;\n  int ret;\n\n  FD_ZERO(&rfds);\n  FD_SET(this->udp_fd, &rfds);\n\n  /* Convert timeout to timeval struct */\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  /* Poll file descriptors */\n  ret = select(this->udp_fd + 1, &rfds, NULL, NULL, &tv);\n  if (ret < 0) {\n    /* Error */\n    gzerr << \"Error polling file descriptors\" << std::endl;\n  } else if (ret > 0) {\n    /* Data available */\n    if (FD_ISSET(this->udp_fd, &rfds)) {\n      /* Receive data */\n      this->receiveMAVLinkMessage();\n    }\n  }", "CodeBleu_score": 36.22523631137811}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#if GAZEBO_MAJOR_VERSION >= 8\n  // Create a timeval structure to pass to select\n  struct timeval timeout;\n  timeout.tv_sec = static_cast<int>(_timeoutMs / 1000);\n  timeout.tv_usec = static_cast<int>(_timeoutMs % 1000) * 1000;\n\n  // Create a file descriptor set for select\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(this->serialConnection->GetFD(), &readfds);\n\n  // Poll for data on the serial connection\n  int selectResult = select(this->serialConnection->GetFD() + 1, &readfds, NULL, NULL, &timeout);\n\n  // If data is available, receive it\n  if (selectResult == 1) {\n    this->serialConnection->Read(this->receiveBuffer, sizeof(this->receiveBuffer));\n  }", "CodeBleu_score": 28.136320800349917}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() \tif (this->isOpen())  {\n\t\tthis->lock.lock();\n\t\tif (this->isOpen())  {\n\t\t\tthis->stopIO();\n\t\t\tthis->closeSerialDevice();\n\t\t\tthis->lock.unlock();\n\t\t\tif (this->ioThread.joinable())  {\n\t\t\t\tthis->ioThread.join();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 12.661453595025973}, {"code": "void GazeboMavlinkInterface::close() \\tstd::unique_lock<std::mutex> lock(mutex_);", "CodeBleu_score": 7.959239544001613}, {"code": "void GazeboMavlinkInterface::close() \tif (this->isOpen()) {\n\t\tthis->lock();\n\t\tthis->stopIoService();\n\t\tthis->closeSerialDevice();\n\t\tthis->unlock();\n\t}\n}\n", "CodeBleu_score": 11.136283128718848}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolationdouble x1, y1, z1, x2, y2, z2;", "CodeBleu_score": 4.393603374959194}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolationdouble x = 0.0;", "CodeBleu_score": 4.398894262659452}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolationdouble x1 = x1_ * scale_;", "CodeBleu_score": 4.409546643723533}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)\tif (_time == m_time) return;\n\tm_time = _time;\n\tif (m_loop) m_time = fmod(m_time, m_length);\n\telse m_time = clamp(m_time, 0.0, m_length);\n\tif (m_time == m_length && m_loop) m_time = 0.0;\n\tif (m_time < 0.0) m_time = 0.0;\n\tm_time = floor(m_time);\n\tif (m_time == m_length && m_loop) m_time = 0.0;\n\tif (m_time < 0.0) m_time = 0.0;\n\tm_time = fmod(m_time, m_length);\n\tif (m_time == m_length && m_loop) m_time = 0.0;\n\tif (m_time < 0.0) m_time = 0.0;\n\tm_time = floor(m_time);\n\tif (m_time == m_length && m_loop) m_time = 0.0;\n\tif (m_time < 0.0) m_time = 0.0;\n\tm_time = fmod(m_time, m_length);\n\tif (m_time == m_length && m_loop) m_time = 0.0;\n\tif (m_time < 0.0) m_time = 0.0;\n\tm_time = floor(m_time);\n\tif (m_time == m_length && m_loop) m_time = 0.0;\n\tif (m_time < 0.0) m_time = 0.0;\n\tm_time = fmod(m_time, m_length);\n\tif (m_time == m_length && m_loop) m_time = 0.0;\n\tif (m_time < 0.0) m_time = 0.0;\n\tm_time = floor(m_time);\n\tif (m_time == m_length && m_loop) m_time", "CodeBleu_score": 31.14614153823661}, {"code": "void Animation::SetTime(double _time)\tif (m_time == _time)\n\t\treturn;\n\n\tm_time = _time;\n\tif (m_time < 0.0) {\n\t\tif (m_looping)\n\t\t\tm_time += m_length;\n\t\telse\n\t\t\tm_time = 0.0;\n\t} else if (m_time > m_length) {\n\t\tif (m_looping)\n\t\t\tm_time -= m_length;\n\t\telse\n\t\t\tm_time = m_length;\n\t}\n\n\tif (m_time < m_length && m_time > 0.0) {\n\t\tm_time_changed = true;\n\t\tm_time_changed_callback(m_time);\n\t}\n}\n", "CodeBleu_score": 35.14311657603859}, {"code": "void Animation::SetTime(double _time)\tif (_time == time) return;\n\ttime = _time;\n\tif (loop) {\n\t\tif (time < 0) time = length + time;\n\t\tif (time >= length) time = time - length;\n\t} else {\n\t\ttime = Clamp(time, 0.0, length);\n\t}\n\tUpdate();\n}\n", "CodeBleu_score": 32.95505873572495}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n    self.vehicle.set_mav_frame(mavutil.mavlink.MAV_FRAME_BODY_NED)\n    self.vehicle.set_mav_command_long_send(self.vehicle.target_system, self.vehicle.target_component, mavutil.mavlink.MAV_CMD_NAV_TAKEOFF, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    print(\"Vehicle Type: {}\\nVehicle ID: {}\\nFlight Mode: {}\".format(self.vehicle.type, self.vehicle.id, self.vehicle.mode))\n", "CodeBleu_score": 19.942925721322837}, {"code": "def hover(self)\n    self.vehicle.set_frame(1)\n    self.vehicle.set_motion_type(0)\n    target_motion = self.vehicle.get_motion_command()\n    target_motion.x = self.vehicle.get_position()[0]\n    target_motion.y = self.vehicle.get_position()[1]\n    target_motion.z = self.vehicle.get_position()[2]\n    target_motion.yaw = self.vehicle.get_yaw()\n    self.vehicle.send_motion_command(target_motion)\n    print(\"Vehicle Type: {}\\nVehicle ID: {}\\nFlight Mode: {}\".format(self.vehicle.get_type(), self.vehicle.get_id(), self.vehicle.get_flight_mode()))\n", "CodeBleu_score": 19.72197920994695}, {"code": "def hover(self)\n    self.vehicle.message_factory.set_position_target_global_int_encode(\n        0,       # time_boot_ms (not used)\n        0, 0,    # target system, target component\n        mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT, # frame\n        0b0000111111000111, # type_mask (only speeds enabled)\n        0, # lat_int - X Position in WGS84 frame in 1e7 * meters\n        0, # lon_int - Y Position in WGS84 frame in 1e7 * meters\n        0, # alt - Altitude in meters in AMSL altitude(not WGS84 if absolute or relative)\n        self.vehicle.location.global_relative_frame.alt, # altitude above terrain if GLOBAL_TERRAIN_ALT_INT\n        0, # X velocity in NED frame in m/s\n        0, # Y velocity in NED frame in m/s\n        0, # Z velocity in NED frame in m/s\n        0, 0, 0, # afx, afy, afz acceleration (not supported yet, ignored in GCS_Mavlink)\n        0, 0)    # yaw, yaw_rate (not supported yet, ignored in GCS_Mavlink)\n\n    self.vehicle.message_factory.set_position_target_local_ned_encode(\n        0,       # time_boot_ms (not used)\n        0, 0,    # target system, target component\n        mavutil.mavlink.MAV_FRAME_LOCAL_NED, # frame\n        0b0000111111000111, # type_mask (only positions enabled)\n        0, 0, 0, # x, y, z positions (or North, East, Down in the MAV_FRAME_BODY_NED frame\n        0, 0, 0, # x, y, z velocity in m/s  (not used)\n        0, 0, 0, # x, y, z acceleration (not supported yet, ignored in GCS_Mavlink)\n        0, 0)    # yaw, yaw_rate (not supported yet,", "CodeBleu_score": 12.999290384569626}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      try:\n        self.flight_mode_service(self.flight_mode)\n        print(\"Flight mode switched to \" + self.flight_mode)\n        return True\n      except:\n        print(\"Failed to switch flight mode to \" + self.flight_mode)\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the hover flag to 1, and sets the target velocity to 0. It then calls the set_velocity method.\"\"\"\n    self.hover_flag = 1\n    self.target_velocity = 0\n    self.set_velocity()\n\n  def set_velocity(self):\n    \"\"\"This function, set_velocity, sets the velocity of the vehicle to the target velocity. If the hover flag is 1, it sets the velocity to 0. It then calls the set_velocity_service method.\"\"\"\n    if self.hover_flag == 1:\n      self.velocity = 0\n    else:\n      self.velocity = self.target_velocity\n    self.set_velocity_service(self.velocity)\n\n  def set_target_velocity(self, target_velocity):\n    \"\"\"This function, set_target_velocity, sets the target velocity to the target velocity parameter. It then calls the set_velocity method.\"\"\"\n    self.target_velocity = target_velocity\n    self.set_velocity()\n\n  def get_target_velocity(self):\n    \"\"\"This function, get_target_velocity, returns the target velocity.\"\"\"\n    return self.target_velocity\n\n  def get_velocity(self):\n    \"\"\"This function, get_velocity, returns the velocity.\"\"\"\n    return self.velocity\n\n  def get_flight_mode(self):\n    \"\"\"This function, get_flight_mode, returns the flight mode.\"\"\"\n    return self.flight_mode\n\n  def get_hover_flag(self):\n    \"\"\"This function, get_hover_flag, returns the hover flag.\"\"\"\n    return self.hover_flag\n\n  def get_battery_percentage(self):\n    \"\"\"This function, get_battery_percentage, returns the battery percentage.\"\"\"\n    return self.battery_percentage\n\n  def get_battery_voltage(self):\n    \"\"\"This function, get_battery_voltage, returns the battery voltage.\"\"\"\n    return self.battery_voltage\n\n  def get_battery_current(self):\n    \"\"\"This function,", "CodeBleu_score": 38.010864652138096}, {"code": "def flight_mode_switch(self)\n    mode = self.flight_mode\n    if mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      try:\n        self.flightModeService(mode)\n        print('Flight mode switched to'+ mode)\n        return True\n      except:\n        print('Failed to switch flight mode to'+ mode)\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the vehicle to hover mode.\\nIt does this by setting the hover flag to 1 and calling the set_throttle method with a throttle value of 0.\\nThe function returns True if the hover succeeds, and False if it fails.\"\"\"\n    try:\n      self.hover_flag = 1\n      self.set_throttle(0)\n      print('Vehicle set to hover')\n      return True\n    except:\n      print('Failed to set vehicle to hover')\n      return False\n\n  def set_throttle(self, throttle):\n    \"\"\"This function, set_throttle, sets the throttle of the vehicle.\\nIt does this by calling the set_throttle method of the vehicle_service.\\nThe function returns True if the throttle set succeeds, and False if it fails.\"\"\"\n    try:\n      self.vehicle_service(throttle)\n      print('Vehicle throttle set to'+ str(throttle))\n      return True\n    except:\n      print('Failed to set vehicle throttle to'+ str(throttle))\n      return False\n\n  def set_speed(self, speed):\n    \"\"\"This function, set_speed, sets the speed of the vehicle.\\nIt does this by calling the set_speed method of the vehicle_service.\\nThe function returns True if the speed set succeeds, and False if it fails.\"\"\"\n    try:\n      self.vehicle_service(speed)\n      print('Vehicle speed set to'+ str(speed))\n      return True\n    except:\n      print('Failed to set vehicle speed to'+ str(speed))\n      return False\n\n  def set_yaw(self, yaw):\n    \"\"\"This function, set_yaw, sets the yaw of the vehicle.\\nIt does this by calling the set_yaw method of the vehicle_service.\\nThe function returns True if the yaw set succeeds, and False if it fails.\"\"\"\n    try:\n      self.vehicle_service(yaw)\n      print('Vehicle yaw set to'+ str(yaw))\n      return True\n    except:\n      print('Failed to set vehicle yaw to'+ str(yaw))\n      return False\n\n  def", "CodeBleu_score": 31.794972381698848}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      try:\n        self.flight_mode_service(self.flight_mode)\n        print('Flight mode switched to'+ self.flight_mode)\n        return True\n      except:\n        print('Failed to switch flight mode')\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the hover flag to 1, and sets the vehicle to the 'HOVER' flight mode.\"\"\"\n    self.hover_flag = 1\n    self.flight_mode = 'HOVER'\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, sets the takeoff flag to 1, and sets the vehicle to the 'Takeoff' flight mode.\"\"\"\n    self.takeoff_flag = 1\n    self.flight_mode = 'Takeoff'\n\n  def land(self):\n    \"\"\"This function, land, sets the land flag to 1, and sets the vehicle to the 'Land' flight mode.\"\"\"\n    self.land_flag = 1\n    self.flight_mode = 'Land'\n\n  def set_velocity(self, velocity):\n    \"\"\"This function, set_velocity, sets the vehicle velocity to the input velocity.\"\"\"\n    self.velocity = velocity\n\n  def set_angular_velocity(self, angular_velocity):\n    \"\"\"This function, set_angular_velocity, sets the vehicle angular velocity to the input angular velocity.\"\"\"\n    self.angular_velocity = angular_velocity\n\n  def set_acceleration(self, acceleration):\n    \"\"\"This function, set_acceleration, sets the vehicle acceleration to the input acceleration.\"\"\"\n    self.acceleration = acceleration\n\n  def set_angular_acceleration(self, angular_acceleration):\n    \"\"\"This function, set_angular_acceleration, sets the vehicle angular acceleration to the input angular acceleration.\"\"\"\n    self.angular_acceleration = angular_acceleration\n\n  def set_height(self, height):\n    \"\"\"This function, set_height, sets the vehicle height to the input height.\"\"\"\n    self.height = height\n\n  def set_pitch(self, pitch):\n    \"\"\"This function, set_pitch, sets the vehicle pitch to the input pitch.\"\"\"\n    self.pitch = pitch\n\n  def set_roll(self, roll):\n    \"\"\"This function, set_roll, sets the vehicle roll to the input roll.\"\"\"\n    self.roll = roll\n\n  def set_yaw(self, yaw):\n    \"\"\"", "CodeBleu_score": 31.389876346004314}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag:\n      self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n      if not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z]\n", "CodeBleu_score": 43.49263720817376}, {"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag:\n      self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n      self.coordinate_frame = 1\n      self.motion_type = 1\n      self.target_motion = self.construct_target_motion(msg.linear.x, msg.angular.z)\n\n  def hover_state_transition(self, linear_x, angular_z):\n    \"\"\"This function, hover_state_transition, checks if the hover_flag should be set or cleared.\\nIf the hover_flag is not set and the linear_x and angular_z components are greater than the hover_threshold, the hover_flag is set.\\nIf the hover_flag is set and the linear_x and angular_z components are less than the hover_threshold, the hover_flag is cleared.\"\"\"\n    if not self.hover_flag and abs(linear_x) > self.hover_threshold and abs(angular_z) > self.hover_threshold:\n      self.hover_flag = True\n    elif self.hover_flag and abs(linear_x) < self.hover_threshold and abs(angular_z) < self.hover_threshold:\n      self.hover_flag = False\n\n  def hold_state_transition(self, linear_x, angular_z, frame):\n    \"\"\"This function, hold_state_transition, checks if the hold_flag should be set or cleared.\\nIf the hold_flag is not set and the linear_x and angular_z components are greater than the hold_threshold, the hold_flag is set.\\nIf the hold_flag is set and the linear_x and angular_z components are less than the hold_threshold, the hold_flag is cleared.\"\"\"\n    if not self.hold_flag and abs(linear_x) > self.hold_threshold and abs(angular_z) > self.hold_threshold:\n      self.hold_flag = True\n      self.hold_frame = frame\n    elif self.hold_flag and abs(linear_x) < self.hold_threshold and abs(angular_z) < self.hold_threshold:\n      self.hold_flag = False\n\n ", "CodeBleu_score": 37.045239236249905}, {"code": "def cmd_vel_enu_callback(self, msg)\n    if self.hover_flag == False and self.hold_flag == False:\n      self.coordinate_frame = 1\n      self.motion_type = 1\n      self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z]\n      self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    elif self.hover_flag == True and self.hold_flag == False:\n      self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    else:\n      pass\n\n  def hover_state_transition(self, linear_x, linear_y, linear_z, angular_x, angular_y, angular_z):\n    \"\"\"This function, hover_state_transition, transitions the state machine to hover mode.\\nIt sets the hover_flag to True, and sets the hold_flag to False.\"\"\"\n    self.hover_flag = True\n    self.hold_flag = False\n    self.hover_timer = rospy.get_time()\n    self.hover_duration = self.hover_timer - self.hover_timer_prev\n    self.hover_timer_prev = self.hover_timer\n    self.hover_timer_prev_prev = self.hover_timer_prev\n    self.hover_timer_prev_prev_prev = self.hover_timer_prev_prev\n    self.hover_timer_prev_prev_prev_prev = self.hover_timer_prev_prev_prev\n    self.hover_timer_prev_prev_prev_prev_prev = self.hover_timer_prev_prev_prev_prev\n    self.hover_timer_prev_prev_prev_prev_prev_prev = self.hover_timer_prev_prev_prev_prev_prev\n    self.hover_timer_prev_prev_prev_prev_prev_prev_prev = self.hover_timer_prev_prev_prev_prev_prev_prev\n    self.hover_timer_prev_prev_prev_prev_prev", "CodeBleu_score": 44.29317893746085}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n    if self.flight_mode!= \"HOVER\":\n      if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02) or (abs(w) > 0.005):\n        self.hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n        self.set_mode(\"OFFBOARD\")\n      elif self.hover_flag == 0 and (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02) and (abs(w) < 0.005):\n        self.hover_flag = 1\n        self.flight_mode = \"HOVER\"\n        self.set_mode(\"HOVER\")\n        self.hover()\n\n  def hover(self):\n    \"\"\"This function, hover, makes the drone hover in place.\"\"\"\n    self.hover_pub.publish(Empty())\n\n  def set_mode(self, mode):\n    \"\"\"This function, set_mode, sets the flight mode of the drone.\\nmode is a string that can be set to \"OFFBOARD\", \"HOVER\", \"AUTO.MISSION\", \"AUTO.LOITER\", \"AUTO.RTL\", \"AUTO.LAND\", \"AUTO.RTGS\", or \"AUTO.READY\".\"\"\"\n    if mode == \"OFFBOARD\":\n      self.offboard_pub.publish(Empty())\n    elif mode == \"HOVER\":\n      self.hover_pub.publish(Empty())\n    elif mode == \"AUTO.MISSION\":\n      self.auto_mission_pub.publish(Empty())\n    elif mode == \"AUTO.LOITER\":\n      self.auto_loiter_pub.publish(Empty())\n    elif mode == \"AUTO.RTL\":\n      self.auto_rtl_pub.publish(Empty())\n    elif mode == \"AUTO.LAND\":\n      self.auto_land_pub.publish(Empty())\n    elif mode == \"AUTO.RTGS\":\n      self.auto_rtgs_pub.publish(Empty())\n    elif mode == \"AUTO.READY\":\n      self.auto_ready_pub.publish(Empty())\n\n  def arm(self):\n    \"\"\"This function, arm, arms the drone.\"\"\"\n    self.arm_pub.publish(True)\n\n  def disarm(self):\n    \"\"\"", "CodeBleu_score": 51.127321026226035}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.hover_flag == 0:\n      if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n        self.set_mode(\"OFFBOARD\")\n        self.hover_flag = 1\n    elif self.hover_flag == 1:\n      if self.flight_mode!= \"HOVER\":\n        self.set_mode(\"HOVER\")\n        self.hover_flag = 2\n      if (abs(x) < 0.02) and (abs(y) < 0.02) and (abs(z) < 0.02) and (abs(w) < 0.005):\n        self.hover_flag = 0\n\n  def takeoff(self, z):\n    \"\"\"This function, takeoff, takes off the drone to the specified z height and hovers.\\nIt takes in the z value as an argument and sets the takeoff_flag to 1, changes the flight mode to 'AUTO.TAKEOFF', and initiates the takeoff action.\"\"\"\n    if self.takeoff_flag == 0:\n      self.set_mode(\"AUTO.TAKEOFF\")\n      self.takeoff_flag = 1\n    elif self.takeoff_flag == 1:\n      if self.flight_mode!= \"HOVER\":\n        self.set_mode(\"HOVER\")\n        self.takeoff_flag = 2\n      if (self.local_position.pose.position.z - z) < 0.1:\n        self.takeoff_flag = 0\n\n  def land(self):\n    \"\"\"This function, land, lands the drone.\\nIt sets the land_flag to 1, changes the flight mode to 'AUTO.LAND', and initiates the landing action.\"\"\"\n    if self.land_flag == 0:\n      self.set_mode(\"AUTO.LAND\")\n      self.land_flag = 1\n\n  def set_mode(self, mode):\n    \"\"\"This function, set_mode, sets the flight mode of the drone.\\nIt takes in the mode as an argument and calls the set_mode service with the specified mode.\"\"\"\n    rospy.wait_for_service('/mavros/", "CodeBleu_score": 37.89052147148995}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.hover_flag == 0:\n      if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n        print(\"Transitioning to OFFBOARD\")\n      else:\n        self.hover_flag = 1\n        self.flight_mode = \"HOVER\"\n        print(\"Transitioning to HOVER\")\n    else:\n      if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n        self.hover_flag = 1\n        self.flight_mode = \"HOVER\"\n        print(\"Transitioning to HOVER\")\n\n  def hover(self, x, y, z, w):\n    \"\"\"This function, hover, takes the drone's current position, velocity, and acceleration and uses them to determine the drone's desired position and velocity. It then sends the desired position and velocity to the drone. It also sets the drone's current position and velocity to the desired position and velocity.\"\"\"\n    self.hover_state_transition(x, y, z, w)\n    if self.flight_mode == \"HOVER\":\n      self.desired_position.x = x\n      self.desired_position.y = y\n      self.desired_position.z = z\n      self.desired_velocity.x = x\n      self.desired_velocity.y = y\n      self.desired_velocity.z = z\n      self.desired_acceleration.x = x\n      self.desired_acceleration.y = y\n      self.desired_acceleration.z = z\n      self.current_position.x = x\n      self.current_position.y = y\n      self.current_position.z = z\n      self.current_velocity.x = x\n      self.current_velocity.y = y\n      self.current_velocity.z = z\n      self.current_acceleration.x = x\n      self.current_acceleration.y = y\n      self.current_acceleration.z = z\n      self.pub.publish(self.desired_position)\n      self.pub_vel.publish(self.desired_velocity", "CodeBleu_score": 54.09957525520346}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n", "CodeBleu_score": 19.528210155997467}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n", "CodeBleu_score": 19.528210155997467}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    self.frame = \"body\"\n    self.motion_type = \"hover\"\n    self.target_motion = self.vehicle.simple_takeoff(self.target_altitude)\n    print(\"Vehicle type: {}\\nVehicle ID: {}\\nFlight mode: {}\".format(self.vehicle.type, self.vehicle.id, self.vehicle.mode.name))\n", "CodeBleu_score": 23.14988322696358}, {"code": "def hover(self)\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.simple_takeoff(self.h)\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"HOVER\")\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.flush()\n    print(\"Vehicle Type: \" + str(self.vehicle.type))\n    print(\"Vehicle ID: \" + str(self.vehicle.id))\n    print(\"Flight Mode: \" + str(self.vehicle.mode))\n    self.vehicle.flush()\n", "CodeBleu_score": 23.929893349611962}, {"code": "def hover(self)\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(self.target_altitude)\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot_version')\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    self.vehicle.wait_ready('autopilot", "CodeBleu_score": 17.36847326289318}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n      self.hover()\n      return True\n    else:\n      try:\n        self.flight_mode_service(self.flight_mode)\n        print(\"Flight mode switched to \" + self.flight_mode)\n        return True\n      except:\n        print(\"Failed to switch flight mode.\")\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the hover flag and calls the hover method of the vehicle.\"\"\"\n    self.hover_flag = True\n    self.vehicle.hover()\n\n  def arm_and_takeoff(self, aTargetAltitude):\n    \"\"\"This function, arm_and_takeoff, arms the vehicle and then takes off to the target altitude.\\nIt returns True if the vehicle takes off and False otherwise.\"\"\"\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    while self.vehicle.gps_0.fix_type < 2:\n      print(\"Waiting for GPS...\")\n      time.sleep(1)\n    print(\"Arming motors...\")\n    self.vehicle.armed = True\n    while not self.vehicle.armed:\n      print(\"Waiting for arming...\")\n      time.sleep(1)\n    print(\"Taking off!\")\n    self.vehicle.simple_takeoff(aTargetAltitude)\n    while True:\n      print(\"Altitude: \", self.vehicle.location.global_relative_frame.alt)\n      if self.vehicle.location.global_relative_frame.alt >= aTargetAltitude * 0.95:\n        print(\"Reached target altitude.\")\n        break\n      time.sleep(1)\n    return True\n\n  def disarm(self):\n    \"\"\"This function, disarm, disarms the vehicle.\"\"\"\n    self.vehicle.armed = False\n\n  def get_distance_metres(self, aLocation1, aLocation2):\n    \"\"\"This function, get_distance_metres, returns the distance between two LocationGlobal objects in metres.\"\"\"\n    dlat = aLocation2.lat - aLocation1.lat\n    dlong = aLocation2.lon - aLocation1.lon\n    return math.sqrt((dlat * dlat) + (dlong * dlong)) * 1.113195e5\n\n  def get_location_metres(self, original_location, dNorth, dEast):\n    \"\"\"This function, get_", "CodeBleu_score": 37.51542810702131}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover_flag = True\n      self.hover()\n      return True\n    else:\n      try:\n        self.flight_mode_service(self.flight_mode)\n        self.flight_mode = self.flight_mode_service.getMode().mode\n        print('Flight mode switched to'+ self.flight_mode)\n        return True\n      except:\n        print('Flight mode switch failed')\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the vehicle to hover mode and calls the takeoff method.\"\"\"\n    self.set_mode('HOVER')\n    self.takeoff()\n\n  def land(self):\n    \"\"\"This function, land, lands the vehicle and sets the hover flag to False.\"\"\"\n    self.set_mode('LAND')\n    self.hover_flag = False\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, takes off the vehicle and sets the hover flag to False.\"\"\"\n    self.set_mode('RTL')\n    self.hover_flag = False\n\n  def set_mode(self, mode):\n    \"\"\"This function, set_mode, sets the vehicle mode to the given mode.\\nIf successful, it prints the new flight mode and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    try:\n      self.flight_mode_service(mode)\n      self.flight_mode = self.flight_mode_service.getMode().mode\n      print('Flight mode set to'+ self.flight_mode)\n      return True\n    except:\n      print('Flight mode set failed')\n      return False\n\n  def set_arm(self, arm):\n    \"\"\"This function, set_arm, sets the vehicle arm state to the given arm state.\\nIf successful, it prints the new arm state and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    try:\n      self.arm_service(arm)\n      self.arm = self.arm_service.getArm()\n      print('Vehicle arm set to'+ self.arm)\n      return True\n    except:\n      print('Vehicle arm set failed')\n      return False\n\n  def set_home(self):\n    \"\"\"This function, set_home, sets the vehicle home position to the current position of the vehicle.\"\"\"\n    self.home_position = self.local_position\n    print('Vehicle home position set", "CodeBleu_score": 26.2769346155455}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover_flag = True\n      self.hover()\n      return True\n    else:\n      try:\n        self.flight_mode_service(self.flight_mode)\n        self.flight_mode = self.get_flight_mode()\n        print(\"Flight mode switched to \" + self.flight_mode)\n        return True\n      except:\n        print(\"Failed to switch flight mode.\")\n        return False\n", "CodeBleu_score": 55.707073491449755}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    if self.visualize:\n      self.visualize()\n    self.get_total_reward()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward by calling the get_reward method for each agent.\\nIt then adds the rewards to the total_reward attribute.\"\"\"\n    self.total_reward = 0\n    for agent in self.agents:\n      self.total_reward += agent.get_reward()\n\n  def visualize(self):\n    \"\"\"This function, visualize, calls the visualize method for each agent.\"\"\"\n    for agent in self.agents:\n      agent.visualize()\n", "CodeBleu_score": 58.406474549387674}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward for the current state of the game.\\nIt does this by adding up the rewards for each player, and then subtracting the rewards for each player from the total reward.\\nIt returns the total reward.\"\"\"\n    total_reward = 0\n    for player in self.players:\n      total_reward += player.reward\n    for player in self.players:\n      total_reward -= player.reward\n    return total_reward\n\n  def visualize(self):\n    \"\"\"This function, visualize, visualizes the current state of the game by calling the visualize method for each player.\"\"\"\n    for player in self.players:\n      player.visualize()\n", "CodeBleu_score": 53.37799782269619}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 51.10360294045804}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n    if msg.header.frame_id == self.uav_id:\n        self.local_pose = msg.pose\n        self.local_pose.position.x = msg.pose.position.x + self.bias_x\n        self.local_pose.position.y = msg.pose.position.y + self.bias_y\n        self.local_pose.position.z = msg.pose.position.z + self.bias_z\n        self.local_pose.orientation.x = msg.pose.orientation.x\n        self.local_pose.orientation.y = msg.pose.orientation.y\n        self.local_pose.orientation.z = msg.pose.orientation.z\n        self.local_pose.orientation.w = msg.pose.orientation.w\n        self.local_pose_pub.publish(self.local_pose)\n        self.local_pose_stamped = msg\n        self.local_pose_stamped.pose.position.x = msg.pose.position.x + self.bias_x\n        self.local_pose_stamped.pose.position.y = msg.pose.position.y + self.bias_y\n        self.local_pose_stamped.pose.position.z = msg.pose.position.z + self.bias_z\n        self.local_pose_stamped.pose.orientation.x = msg.pose.orientation.x\n        self.local_pose_stamped.pose.orientation.y = msg.pose.orientation.y\n        self.local_pose_stamped.pose.orientation.z = msg.pose.orientation.z\n        self.local_pose_stamped.pose.orientation.w = msg.pose.orientation.w\n        self.local_pose_stamped_pub.publish(self.local_pose_stamped)\n        self.global_pose = msg.pose\n        self.global_pose.position.x = msg.pose.position.x + self.bias_x\n        self.global_pose.position.y = msg.pose.position.y + self.bias_y\n        self.global_pose.position.z = msg.pose.position.z + self.bias_z\n        self.global_pose.orientation.x = msg.pose.orientation.x\n        self.global_pose.orientation.y =", "CodeBleu_score": 18.240506257286594}, {"code": "def local_pose_callback(self, msg, i)\n    if msg.id == self.id:\n      self.local_pose = msg.pose\n      self.global_pose = Pose()\n      self.global_pose.position.x = msg.pose.position.x + self.bias[i][0]\n      self.global_pose.position.y = msg.pose.position.y + self.bias[i][1]\n      self.global_pose.position.z = msg.pose.position.z + self.bias[i][2]\n      self.global_pose.orientation = msg.pose.orientation\n      self.local_pose_pub.publish(self.local_pose)\n      self.global_pose_pub.publish(self.global_pose)\n      if self.takeoff_target_pose.position.z == 0:\n        self.takeoff_target_pose.position.x = self.local_pose.position.x\n        self.takeoff_target_pose.position.y = self.local_pose.position.y\n        self.takeoff_target_pose.position.z = self.local_pose.position.z + self.takeoff_height\n        self.hover_target_pose.position.x = self.local_pose.position.x\n        self.hover_target_pose.position.y = self.local_pose.position.y\n        self.hover_target_pose.position.z = self.local_pose.position.z + self.hover_height\n        self.takeoff_target_pose_pub.publish(self.takeoff_target_pose)\n        self.hover_target_pose_pub.publish(self.hover_target_pose)\n      else:\n        self.takeoff_target_pose.position.x = self.local_pose.position.x\n        self.takeoff_target_pose.position.y = self.local_pose.position.y\n        self.takeoff_target_pose.position.z = self.local_pose.position.z + self.takeoff_height\n        self.hover_target_pose.position.x = self.local_pose.position.x\n        self.hover_target_pose.position.y = self.local_pose.position.y\n        self.hover_target_pose.position.z = self.local_pose.position", "CodeBleu_score": 19.59190414760036}, {"code": "def local_pose_callback(self, msg, i)\n    if msg.header.seq == i:\n        self.local_pose = msg\n        self.global_pose.pose.position.x = msg.pose.position.x + self.bias[0]\n        self.global_pose.pose.position.y = msg.pose.position.y + self.bias[1]\n        self.global_pose.pose.position.z = msg.pose.position.z + self.bias[2]\n        self.global_pose.pose.orientation = msg.pose.orientation\n        self.local_pose_pub.publish(self.local_pose)\n        self.global_pose_pub.publish(self.global_pose)\n        if self.takeoff_target_pose.header.seq == i:\n            self.takeoff_target_pose.pose.position.x = msg.pose.position.x + self.bias[0]\n            self.takeoff_target_pose.pose.position.y = msg.pose.position.y + self.bias[1]\n            self.takeoff_target_pose.pose.position.z = msg.pose.position.z + self.bias[2]\n            self.hover_target_pose.pose.position.x = msg.pose.position.x + self.bias[0]\n            self.hover_target_pose.pose.position.y = msg.pose.position.y + self.bias[1]\n            self.hover_target_pose.pose.position.z = msg.pose.position.z + self.bias[2]\n        if self.hover_target_pose.header.seq == i:\n            self.hover_target_pose.pose.position.x = msg.pose.position.x + self.bias[0]\n            self.hover_target_pose.pose.position.y = msg.pose.position.y + self.bias[1]\n            self.hover_target_pose.pose.position.z = msg.pose.position.z + self.bias[2]\n        if self.land_target_pose.header.seq == i:\n            self.land_target_pose.pose.position.x = msg.pose.position.x + self.bias[0]\n            self.land_target_pose.pose.position.y = msg.pose.position.", "CodeBleu_score": 20.22902816227806}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    if self.uav_state.pose.position.z > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n", "CodeBleu_score": 64.42799728905327}, {"code": "def takeoff_detection(self)\n    if self.arm_state == \"active\" and self.uav_alt > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 60.50820644625583}, {"code": "def takeoff_detection(self)\n    if self.arm_state == \"active\" and self.altitude > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 60.617887392028216}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    # Initialize distance matrix\n    dist_mat = np.zeros((len(orig_formation), len(change_formation)))\n    # Loop through rows\n    for i in range(len(orig_formation)):\n        # Loop through columns\n        for j in range(len(change_formation)):\n            # Calculate Euclidean distance\n            dist = np.linalg.norm(orig_formation[i] - change_formation[j])\n            # Subtract from 50 and convert to int\n            dist_mat[i][j] = int(50 - dist)\n    return dist_mat\n", "CodeBleu_score": 27.998776402753005}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # Build distance matrix for original formation\n    orig_dist_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            if i!= j:\n                orig_dist_matrix[i][j] = int(50 - np.linalg.norm(orig_formation[i] - orig_formation[j]))\n            else:\n                orig_dist_matrix[i][j] = 0\n    # Build distance matrix for changed formation\n    change_dist_matrix = np.zeros((len(change_formation), len(change_formation)))\n    for i in range(len(change_formation)):\n        for j in range(len(change_formation)):\n            if i!= j:\n                change_dist_matrix[i][j] = int(50 - np.linalg.norm(change_formation[i] - change_formation[j]))\n            else:\n                change_dist_matrix[i][j] = 0\n    return orig_dist_matrix, change_dist_matrix\n", "CodeBleu_score": 23.64990355753976}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # Create a distance matrix for the original formation.\n    dist_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            if i!= j:\n                dist_matrix[i, j] = np.linalg.norm(orig_formation[i] - orig_formation[j])\n\n    # Create a distance matrix for the changed formation.\n    dist_matrix_changed = np.zeros((len(change_formation), len(change_formation)))\n    for i in range(len(change_formation)):\n        for j in range(len(change_formation)):\n            if i!= j:\n                dist_matrix_changed[i, j] = np.linalg.norm(change_formation[i] - change_formation[j])\n\n    # Subtract the two distance matrices.\n    dist_matrix = dist_matrix - dist_matrix_changed\n\n    # Convert to integers.\n    dist_matrix = dist_matrix.astype(int)\n\n    return dist_matrix\n\n", "CodeBleu_score": 22.278630587453694}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    if self.left_visited[i] == True:\n        return False\n    self.left_visited[i] = True\n    for j in range(self.n):\n        if self.right_visited[j] == False and self.graph[i][j] == 1:\n            gap = self.left_labels[i] + self.right_labels[j] - self.match_weight\n            if gap == 0:\n                self.right_visited[j] = True\n                if self.find_path(j):\n                    return True\n                else:\n                    self.right_visited[j] = False\n            else:\n                self.right_slack[j] = min(self.right_slack[j], gap)\n    return False\n", "CodeBleu_score": 38.18474538777829}, {"code": "def find_path(self, i)\n    if self.left_visited[i] == False:\n        self.left_visited[i] = True\n        for j in range(self.n):\n            if self.right_visited[j] == False:\n                gap = self.left_label[i] - self.right_label[j]\n                if gap == 0:\n                    self.right_visited[j] = True\n                    if self.find_path(j) == True:\n                        return True\n                    else:\n                        self.right_visited[j] = False\n                else:\n                    if self.slack[j] < gap:\n                        self.slack[j] = gap\n        return False\n    else:\n        return True\n", "CodeBleu_score": 35.44274328020611}, {"code": "def find_path(self, i)\n    if self.left_visited[i]:\n      return False\n    self.left_visited[i] = True\n    for j in self.right_adj[i]:\n      if not self.right_visited[j]:\n        gap = self.left_label[i] + self.right_label[j] - self.weight[i][j]\n        if gap == 0:\n          if self.find_path(j):\n            return True\n        else:\n          self.slack[j] = min(self.slack[j], gap)\n    return False\n\n  def augment(self):\n    \"\"\"This function, augment, attempts to augment the matching by finding an augmenting path.\\nIf a path is found, it updates the match weight and returns True.\\nOtherwise, it returns False.\"\"\"\n    for i in range(self.n):\n      self.left_visited = [False] * self.n\n      self.right_visited = [False] * self.n\n      self.slack = [float('inf')] * self.n\n      if self.find_path(i):\n        for j in range(self.n):\n          if self.right_visited[j]:\n            self.left_label[j] += self.slack[j]\n            self.right_label[j] -= self.slack[j]\n            self.weight[j][i] += self.slack[j]\n        return True\n    return False\n", "CodeBleu_score": 31.1298547632607}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n    # Initialize the slack variables for each UAV\n    for uav in self.uavs:\n        uav.slack = 0\n    # Initialize the visit arrays for each UAV\n    for uav in self.uavs:\n        uav.visit = [False for i in range(len(self.uavs))]\n    # Initialize the match array for each UAV\n    for uav in self.uavs:\n        uav.match = -1\n    # Initialize the match results for each UAV\n    for uav in self.uavs:\n        uav.match_results = []\n    # Initialize the path array for each UAV\n    for uav in self.uavs:\n        uav.path = []\n    # Initialize the minimum slack value\n    min_slack = 0\n    # Initialize the iteration count\n    iteration_count = 0\n    # Iterate over UAVs\n    while True:\n        # Increment the iteration count\n        iteration_count += 1\n        # Iterate over UAVs\n        for uav in self.uavs:\n            # Reset the visit array for each UAV\n            for i in range(len(self.uavs)):\n                uav.visit[i] = False\n            # Reset the path array for each UAV\n            uav.path = []\n            # Initialize the slack value for each UAV\n            uav.slack = 0\n            # Iterate over UAVs\n            for i in range(len(self.uavs)):\n                # Skip if the UAV is the same as the current UAV\n                if uav is self.uavs[i]:\n                    continue\n                # Skip if the UAV is already matched\n                if uav.match is not -1:\n                    continue\n                # Skip if the UAV has already been visited\n                if uav.visit[i]:\n                    continue\n                # Skip if the UAV is already in the path\n                if i in uav.path:\n                    continue\n                # Skip if the UAV is not in the path\n                if i not in uav.path:\n                    # Initialize the minimum slack value\n                    min_slack = 0\n                    # Iterate over UAVs\n                    for j in range(len(self.uavs)):\n                        # Skip if the UAV is the same as the current UAV\n                        if uav is self.uavs[j]:\n                            continue\n                        # Skip if the UAV is already matched", "CodeBleu_score": 25.86011323211534}, {"code": "def KM(self)\n    #Initialize the slack and visit arrays for each UAV.\n    slack = np.zeros((self.nUAV,self.nUAV))\n    visited = np.zeros((self.nUAV,self.nUAV))\n    #Initialize the match array.\n    match = np.zeros(self.nUAV)\n    #Iterate over UAVs.\n    for i in range(self.nUAV):\n        #Reset the slack and visited arrays for each UAV.\n        slack[i,:] = 0\n        visited[i,:] = 0\n        #Iterate over UAVs.\n        for j in range(self.nUAV):\n            #Initialize the slack and visited arrays for each UAV.\n            if self.G[i,j] == 1:\n                slack[i,j] = self.w[i,j]\n                visited[i,j] = 0\n            else:\n                slack[i,j] = 0\n                visited[i,j] = 0\n        #Iterate over UAVs.\n        for j in range(self.nUAV):\n            #Initialize the slack and visited arrays for each UAV.\n            if self.G[i,j] == 1:\n                #Iterate over UAVs.\n                for k in range(self.nUAV):\n                    #Initialize the slack and visited arrays for each UAV.\n                    if self.G[j,k] == 1:\n                        #Initialize the slack and visited arrays for each UAV.\n                        if visited[j,k] == 0:\n                            #Initialize the slack and visited arrays for each UAV.\n                            if slack[j,k] > slack[i,j] + self.w[j,k]:\n                                #Initialize the slack and visited arrays for each UAV.\n                                slack[j,k] = slack[i,j] + self.w[j,k]\n                                visited[j,k] = 1\n            #Initialize the slack and visited arrays for each UAV.\n            if self.G[i,j] == 0:\n                #Iterate over UAVs.\n                for k in range(self.nUAV):\n                    #Initialize the slack and visited arrays for each UAV.\n                    if self.G[j,k] == 1:\n                        #Initialize the slack and visited arrays for each UAV.\n                        if slack[i,k", "CodeBleu_score": 24.293735328034142}, {"code": "def KM(self)\n    #Initialize the slack variables and visit arrays for each UAV.\n    for uav in self.uavs:\n        uav.slack = 0\n        uav.visited = False\n    #Iterate over UAVs, finding the maximum matching.\n    for uav in self.uavs:\n        #Initialize the visit array for the current UAV.\n        uav.visited = False\n        #Iterate over UAVs, finding the maximum matching.\n        for uav2 in self.uavs:\n            #If the current UAV has not been visited, check if it has a path to the current UAV.\n            if not uav.visited:\n                #If the current UAV has a path to the current UAV, update the slack variable.\n                if self.has_path(uav,uav2):\n                    uav.slack += 1\n            #If the current UAV has not been visited, check if it has a path to the current UAV.\n            if not uav2.visited:\n                #If the current UAV has a path to the current UAV, update the slack variable.\n                if self.has_path(uav2,uav):\n                    uav2.slack += 1\n        #Reset the visit array for the current UAV.\n        uav.visited = False\n    #Iterate over UAVs, finding the maximum matching.\n    while True:\n        #Initialize the visit array for the current UAV.\n        uav.visited = False\n        #Iterate over UAVs, finding the maximum matching.\n        for uav2 in self.uavs:\n            #If the current UAV has not been visited, check if it has a path to the current UAV.\n            if not uav.visited:\n                #If the current UAV has a path to the current UAV, update the slack variable.\n                if self.has_path(uav,uav2):\n                    uav.slack += 1\n            #If the current UAV has not been visited, check if it has a path to the current UAV.\n            if not uav2.visited:\n                #If the current UAV has a path to the current UAV, update the slack variable.\n                if self.has_path(uav2,uav):\n                    uav2.slack += 1\n        #Reset the visit array for the current UAV.\n        uav.", "CodeBleu_score": 24.937443994029206}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n    # Convert image to HSV color space and separate the V channel\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv = cv2.split(hsv)[2]\n    # Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, yellow_lower, yellow_upper)\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n", "CodeBleu_score": 21.270782765902137}, {"code": "def yellow_dectection(image)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20,100,100])\n    upper_yellow = np.array([40,255,255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 29.57179247381484}, {"code": "def yellow_dectection(image)\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([15, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 27.085328208956632}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription\n}\n", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription\tauto it = standalone_tag_descriptions_.find(tag_id);\n\tif (it!= standalone_tag_descriptions_.end()) {\n\t\tdescription_container = it->second;\n\t\treturn true;\n\t}\n\telse if (print_warning) {\n\t\tROS_WARN_STREAM(\"TagDetector::findStandaloneTagDescription: Could not find a standalone tag description for tag ID \" << tag_id);\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 35.34878438305036}, {"code": "bool TagDetector::findStandaloneTagDescriptionbool TagDetector::findStandaloneTagDescription(int tagID, std::string &descriptionContainer, bool printWarning) {\n    auto it = standalone_tag_descriptions_.find(tagID);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            std::string warningMessage = \"No description found for standalone tag ID \" + std::to_string(tagID);\n            ROS_WARN_STREAM(warningMessage);\n        }\n        return false;\n    }\n    descriptionContainer = it->second;\n    return true;\n}\n", "CodeBleu_score": 60.346905130260694}]}
