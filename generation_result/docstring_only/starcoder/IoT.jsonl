{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t i;\n\tuint8_t *p = (uint8_t *)desc;\n\n\tif (desc->bDescriptorType!= USB_DESC_TYPE_INTERFACE) {\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < desc->bNumEndpoints; i++) {\n\t\tp += desc->bLength;\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)p;\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n", "CodeBleu_score": 36.475009643641755}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t i;\n\tusb_iface_desc_t *iface_desc;\n\n\t/* Iterate over all interfaces in the configuration descriptor. */\n\tfor (i = 0; i < desc->bNumInterfaces; i++) {\n\t\tiface_desc = (usb_iface_desc_t *)desc;\n\n\t\t/* Iterate over all endpoints in the interface descriptor. */\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)iface_desc + iface_desc->bLength);\n\t\twhile (desc->bDescriptorType!= USB_DT_ENDPOINT) {\n\t\t\t/* Move to the next descriptor. */\n\t\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc + desc->bLength);\n\t\t\tif ((uint8_t *)desc > (uint8_t *)iface_desc + iface_desc->bLength) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* We have reached the end of the configuration descriptor. */\n\treturn NULL;\n}\n", "CodeBleu_score": 40.757090273774224}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\twhile (desc->bLength) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc + desc->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 28.01427548425672}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (g_usb_dev.cfg.cur_cfg == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= g_usb_dev.cfg.cur_cfg->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t *iface_desc = g_usb_dev.cfg.cur_cfg + g_usb_dev.cfg.cur_cfg->bLength;\n\tfor (uint8_t i = 0; i < g_usb_dev.cfg.cur_cfg->bNumInterfaces; i++) {\n\t\tif (iface_desc[1] == iface_num) {\n\t\t\tfor (uint8_t j = 0; j < iface_desc[2]; j++) {\n\t\t\t\tif (iface_desc[3 + j * 2 + 1] == setting_num) {\n\t\t\t\t\tg_usb_dev.cfg.cur_iface = iface_desc;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tiface_desc += iface_desc[0];\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 37.41825151787262}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (iface_num >= g_usb_cfg.config_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\tuint8_t *iface_desc_ptr = (uint8_t *)(&g_usb_cfg.config_desc);\n\tuint8_t *iface_desc_end = (uint8_t *)(&g_usb_cfg.config_desc) + g_usb_cfg.config_desc.wTotalLength;\n\twhile (iface_desc_ptr < iface_desc_end) {\n\t\tif (iface_desc_ptr[1]!= USB_DESC_TYPE_INTERFACE) {\n\t\t\tiface_desc_ptr += iface_desc_ptr[0];\n\t\t\tcontinue;\n\t\t}\n\t\tif (iface_desc_ptr[2]!= iface_num) {\n\t\t\tiface_desc_ptr += iface_desc_ptr[0];\n\t\t\tcontinue;\n\t\t}\n\t\tif (iface_desc_ptr[3]!= setting_num) {\n\t\t\tiface_desc_ptr += iface_desc_ptr[0];\n\t\t\tcontinue;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 33.14261286586041}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tuint8_t *desc_ptr;\n\tuint8_t desc_type;\n\tuint8_t desc_len;\n\tuint8_t desc_num_alt_setting;\n\tuint8_t desc_iface_num;\n\tuint8_t desc_iface_setting;\n\tuint8_t desc_iface_class;\n\tuint8_t desc_iface_subclass;\n\tuint8_t desc_iface_protocol;\n\tuint8_t desc_iface_index;\n\n\tif (!udc_is_cfg_valid()) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_cfg_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tdesc_ptr = (uint8_t *)&udc_cfg_desc;\n\tdesc_len = udc_cfg_desc.wTotalLength;\n\n\twhile (desc_len > 0) {\n\t\tdesc_type = desc_ptr[1];\n\t\tdesc_len = desc_ptr[0];\n\n\t\tif (desc_type == USB_DESC_TYPE_INTERFACE) {\n\t\t\tdesc_num_alt_setting = desc_ptr[2];\n\t\t\tdesc_iface_num = desc_ptr[4];\n\t\t\tdesc_iface_setting = desc_ptr[5];\n\t\t\tdesc_iface_class = desc_ptr[6];\n\t\t\tdesc_iface_subclass = desc_ptr[7];\n\t\t\tdesc_iface_protocol = desc_ptr[8];\n\t\t\tdesc_iface_index = desc_ptr[9];\n\n\t\t\tif (desc_iface_num == iface_num && desc_iface_setting == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tdesc_ptr += desc_len;\n\t\tdesc_len -= desc_len;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 41.754367576329074}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void)\tuint8_t ep_num;\n\tuint8_t ep_status;\n\n\tep_num = udc_req_get_wValue() & 0x0F;\n\tif (udc_req_get_wLength()!= sizeof(ep_status)) {\n\t\tudc_req_stall();\n\t\treturn false;\n\t}\n\n\tif (ep_num >= udc_get_num_ep()) {\n\t\tudc_req_stall();\n\t\treturn false;\n\t}\n\n\tif (udc_endpoint_halted(ep_num)) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tudc_req_set_payload_buf(&ep_status, sizeof(ep_status));\n\treturn true;\n}\n", "CodeBleu_score": 33.775113730513695}, {"code": "static bool udc_req_std_ep_get_status(void)\tuint8_t ep_num;\n\tuint8_t ep_status;\n\tuint8_t ep_size;\n\tuint8_t ep_type;\n\tuint8_t ep_dir;\n\n\tep_num = udc_req_get_wValue() & 0x0F;\n\tep_status = 0;\n\n\tif (ep_num == 0) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_size = udc_ep_get_size(ep_num);\n\t\tep_type = udc_ep_get_type(ep_num);\n\t\tep_dir = udc_ep_get_dir(ep_num);\n\n\t\tif (ep_size > 0) {\n\t\t\tif (ep_type == UDC_EP_TYPE_CTRL) {\n\t\t\t\tif (ep_dir == UDC_EP_DIR_IN) {\n\t\t\t\t\tep_status = udc_ep_is_halted(ep_num);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ep_dir == UDC_EP_DIR_OUT) {\n\t\t\t\t\tep_status = udc_ep_is_halted(ep_num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tudc_req_set_payload(ep_status);\n\treturn true;\n}\n", "CodeBleu_score": 37.40162376678472}, {"code": "static bool udc_req_std_ep_get_status(void)\tif (g_ep_status_len!= sizeof(uint8_t)) {\n\t\treturn false;\n\t}\n\n\tuint8_t ep_num = g_ep_status_buf[0];\n\n\tif (ep_num >= USB_NUM_ENDPOINTS) {\n\t\treturn false;\n\t}\n\n\tif (USB_ENDPOINTS[ep_num].halted) {\n\t\tg_ep_status_buf[0] = 1;\n\t} else {\n\t\tg_ep_status_buf[0] = 0;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 24.294870314529064}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void)\tuint8_t if_num = udc_setup.wIndex & 0xff;\n\tif (udc_setup.bmRequestType.Type!= USB_SETUP_TYPE_STANDARD) {\n\t\treturn false;\n\t}\n\tif (udc_setup.bmRequestType.Recipient!= USB_SETUP_RECIPIENT_INTERFACE) {\n\t\treturn false;\n\t}\n\tif (udc_setup.bRequest == USB_REQ_GET_INTERFACE) {\n\t\tudc_ep_write_packet(0, &if_num, 1);\n\t\treturn true;\n\t}\n\tif (udc_setup.bRequest == USB_REQ_SET_INTERFACE) {\n\t\tif (udc_setup.wLength) {\n\t\t\treturn false;\n\t\t}\n\t\tif (if_num >= udc_config.num_interfaces) {\n\t\t\treturn false;\n\t\t}\n\t\tif (udc_setup.wValue!= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tudc_set_interface(if_num);\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 48.90701940321376}, {"code": "static bool udc_req_iface(void)\tbool ret = false;\n\tuint8_t iface_num = udc_ctrl_req.bInterfaceNumber;\n\tuint8_t alt_setting = udc_ctrl_req.bAlternateSetting;\n\tuint8_t iface_index = udc_find_iface(iface_num);\n\tuint8_t iface_num_alt_setting = udc_get_iface_num_alt_setting(iface_index, alt_setting);\n\n\tif (iface_index < USB_NUM_INTERFACES) {\n\t\tif (udc_is_configured()) {\n\t\t\tif (iface_num_alt_setting < USB_NUM_INTERFACES) {\n\t\t\t\tudc_set_interface(iface_num, alt_setting);\n\t\t\t\tudc_ctrl_req.wIndex = iface_num_alt_setting;\n\t\t\t\tudc_ctrl_req.wValue = 0;\n\t\t\t\tudc_ctrl_req.wLength = 0;\n\t\t\t\tudc_ctrl_req.type = UDC_REQ_TYPE_STANDARD;\n\t\t\t\tudc_ctrl_req.recipient = UDC_REQ_RECIPIENT_INTERFACE;\n\t\t\t\tudc_ctrl_req.request = UDC_REQ_GET_STATUS;\n\t\t\t\tudc_ctrl_req.value = 0;\n\t\t\t\tudc_ctrl_req.length = 2;\n\t\t\t\tudc_ctrl_req.data = udc_ctrl_req_data;\n\t\t\t\tudc_ctrl_req.status = 0;\n\t\t\t\tudc_ctrl_req.actual = 0;\n\t\t\t\tudc_ctrl_req.callback = NULL;\n\t\t\t\tudc_ctrl_req.context = NULL;\n\t\t\t\tudc_ctrl_req.timeout = 0;\n\t\t\t\tudc_ctrl_req.setup = true;\n\t\t\t\tudc_ctrl_req.interface = iface_index;\n\t\t\t\tudc_ctrl_req.alt_setting = alt_setting;\n\t\t\t\tudc_ctrl_req.setup_packet_length = 8;\n\t\t\t\tudc_ctrl_req.data_packet_length = 0;\n\t\t\t\tudc_ctrl_req.data_packet_count = 0;\n\t\t\t\tudc_ctrl_req.status_stage = UDC_CTRL_REQ_STATUS_STAGE_WAIT;\n\t\t\t\tudc_ctrl_req.data_", "CodeBleu_score": 34.52570407406682}, {"code": "static bool udc_req_iface(void)\tbool success = true;\n\tuint8_t iface_num = udc_setup.wIndex & 0x0f;\n\tuint8_t alt_num = udc_setup.wValue & 0x0f;\n\n\tif (udc_device.state!= CONFIGURED) {\n\t\tudc_send_stall_handshake();\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_device.num_interfaces) {\n\t\tudc_send_stall_handshake();\n\t\treturn false;\n\t}\n\n\tudc_device.configuration.interfaces[iface_num].alt_setting = udc_device.configuration.interfaces[iface_num].alt_settings[alt_num];\n\n\tif (!udc_device.configuration.interfaces[iface_num].alt_setting.handler->setup(udc_setup.wValue, udc_setup.wIndex, udc_setup.wLength)) {\n\t\tudc_send_stall_handshake();\n\t\tsuccess = false;\n\t}\n\n\treturn success;\n}\n", "CodeBleu_score": 45.3208478520915}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void)\t// Initialize the LUN list\n\tudi_msc_lun_list = NULL;\n\t// Initialize the current LUN\n\tudi_msc_current_lun = 0;\n\t// Initialize the number of LUNs\n\tudi_msc_lun_nb = 0;\n\t// Initialize the current LUN state\n\tudi_msc_lun_state = 0;\n\t// Initialize the current LUN capacity\n\tudi_msc_lun_capacity = 0;\n\t// Initialize the current LUN block size\n\tudi_msc_lun_block_size = 0;\n\t// Initialize the current LUN block count\n\tudi_msc_lun_block_count = 0;\n\t// Initialize the current LUN block address\n\tudi_msc_lun_block_address = 0;\n\t// Initialize the current LUN block length\n\tudi_msc_lun_block_length = 0;\n\t// Initialize the current LUN block data\n\tudi_msc_lun_block_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;\n\t// Initialize the current LUN block remaining data\n\tudi_msc_lun_block_remaining_data = 0;", "CodeBleu_score": 13.828431727694909}, {"code": "bool udi_msc_enable(void)\tuint8_t i;\n\tuint8_t lun;\n\tuint8_t lun_nb;\n\tuint8_t sense_key;\n\tuint8_t sense_asc;\n\tuint8_t sense_ascq;\n\tuint8_t inquiry_data[36];\n\tuint8_t inquiry_data_len;\n\tuint8_t inquiry_page_code;\n\tuint8_t inquiry_page_len;\n\tuint8_t inquiry_page_data[255];\n\tuint8_t inquiry_page_data_len;\n\tuint8_t inquiry_page_data_pos;\n\tuint8_t inquiry_page_data_sense_key;\n\tuint8_t inquiry_page_data_sense_asc;\n\tuint8_t inquiry_page_data_sense_ascq;\n\tuint8_t inquiry_page_data_lun;\n\tuint8_t inquiry_page_data_nb_lun;\n\tuint8_t inquiry_page_data_nb_lun_supported;\n\tuint8_t inquiry_page_data_nb_lun_allocated;\n\tuint8_t inquiry_page_data_nb_lun_reserved;\n\tuint8_t inquiry_page_data_nb_lun_failed;\n\tuint8_t inquiry_page_data_nb_lun_supported_max;\n\tuint8_t inquiry_page_data_nb_lun_allocated_max;\n\tuint8_t inquiry_page_data_nb_lun_reserved_max;\n\tuint8_t inquiry_page_data_nb_lun_failed_max;\n\tuint8_t inquiry_page_data_nb_lun_supported_min;\n\tuint8_t inquiry_page_data_nb_lun_allocated_min;\n\tuint8_t inquiry_page_data_nb_lun_reserved_min;\n\tuint8_t inquiry_page_data_nb_lun_failed_min;\n\tuint8_t inquiry_page_data_nb_lun_supported_cur;\n\tuint8_", "CodeBleu_score": 13.2675969167875}, {"code": "bool udi_msc_enable(void)\tbool ret = false;\n\n\t// Initialize the MSC interface\n\tudi_msc_init();\n\n\t// Get the number of LUNs\n\tif (udi_msc_get_lun() > 0) {\n\t\t// Check if there are LUNs available\n\t\tif (udi_msc_is_ready()) {\n\t\t\t// Unload the medium on each LUN\n\t\t\tudi_msc_unload();\n\n\t\t\t// Start the MSC process\n\t\t\tret = udi_msc_start();\n\t\t}\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 15.15669445075688}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\t// Check the status of the transfer.\n\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t// Update the amount of data sent.\n\t\tudi_msc_cbw_t* cbw = &udi_msc_cbw;\n\t\tcbw->data_residue -= nb_sent;\n\n\t\t// If the data residue is 0, the transfer is complete.\n\t\tif (cbw->data_residue == 0) {\n\t\t\t// Update the sense data.\n\t\t\tudi_msc_sense_data_update(0x00, 0x00, 0x00);\n\n\t\t\t// Process the updated CSW.\n\t\t\tudi_msc_process_csw();\n\t\t}\n\t} else {\n\t\t// The transfer is not complete.\n\t\t// Wait for a MSC setup reset.\n\t\twhile (!udi_msc_setup_received) {\n\t\t\t// Process the next USB event.\n\t\t\tudd_g_ctrl_cb(udd_g_ep_0);\n\t\t}\n\n\t\t// Process the updated CSW.\n\t\tudi_msc_process_csw();\n\t}\n}\n", "CodeBleu_score": 50.35260488509354}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t// The transfer failed, update the sense data\n\t\tudi_msc_update_sense_data(kUSBMSC_SENSE_KEY_ILLEGAL_REQUEST,\n\t\t\tkUSBMSC_SENSE_KEY_NO_SENSE, 0x00);\n\t\t// Wait for a MSC setup reset to restart CBW reception\n\t\treturn;\n\t}\n\t// Decrease the data residue in the CSW\n\tudi_msc_cbw_t* cbw = (udi_msc_cbw_t*) UDC_GET_CBW_PTR();\n\tcbw->dDataResidue -= nb_sent;\n\t// Process the updated CSW\n\tudi_msc_process_csw();\n}\n", "CodeBleu_score": 51.4155490608136}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t/*\n\t\t * Update the sense data, and decrease the data residue in the CSW.\n\t\t */\n\t\tudi_msc_sense_update(0, 0);\n\t\tudi_msc_csw_update(nb_sent);\n\t\t/*\n\t\t * Process the updated CSW.\n\t\t */\n\t\tudi_msc_process_csw();\n\t} else if (status == UDD_EP_TRANSFER_ABORTED) {\n\t\t/*\n\t\t * The transfer has been aborted, let's wait for a MSC setup reset.\n\t\t */\n\t\tudi_msc_state = UDI_MSC_WAIT_SETUP;\n\t} else if (status == UDD_EP_TRANSFER_STALL) {\n\t\t/*\n\t\t * The transfer has been stalled, let's wait for a MSC setup reset.\n\t\t */\n\t\tudi_msc_state = UDI_MSC_WAIT_SETUP;\n\t} else {\n\t\t/*\n\t\t * The transfer has failed, let's wait for a MSC setup reset.\n\t\t */\n\t\tudi_msc_state = UDI_MSC_WAIT_SETUP;\n\t}\n}\n", "CodeBleu_score": 46.39033620628633}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void)\tuint8_t csw_tag;\n\tuint32_t csw_data_residue;\n\tuint8_t csw_status;\n\tuint8_t csw_signature[4];\n\tuint8_t csw_tag_residue;\n\tuint8_t csw_tag_residue_tmp;\n\tuint8_t csw_tag_residue_tmp2;\n\tuint8_t csw_tag_residue_tmp3;\n\tuint8_t csw_tag_residue_tmp4;\n\tuint8_t csw_tag_residue_tmp5;\n\tuint8_t csw_tag_residue_tmp6;\n\tuint8_t csw_tag_residue_tmp7;\n\tuint8_t csw_tag_residue_tmp8;\n\tuint8_t csw_tag_residue_tmp9;\n\tuint8_t csw_tag_residue_tmp10;\n\tuint8_t csw_tag_residue_tmp11;\n\tuint8_t csw_tag_residue_tmp12;\n\tuint8_t csw_tag_residue_tmp13;\n\tuint8_t csw_tag_residue_tmp14;\n\tuint8_t csw_tag_residue_tmp15;\n\tuint8_t csw_tag_residue_tmp16;\n\tuint8_t csw_tag_residue_tmp17;\n\tuint8_t csw_tag_residue_tmp18;\n\tuint8_t csw_tag_residue_tmp19;\n\tuint8_t csw_tag_residue_tmp20;\n\tuint8_t csw_tag_residue_tmp21;\n\tuint8_t csw_tag_residue_tmp22;\n\tuint8_t csw_tag_residue_tmp23;\n\tuint8_t csw_tag_residue_tmp24;\n\tuint8_t csw_tag_residue_tmp25;\n\tuint8_t csw_", "CodeBleu_score": 3.1751478546353344}, {"code": "static void udi_msc_csw_process(void)\tif (udi_msc_cbw_tag == 0) {\n\t\tudi_msc_cbw_tag = udi_msc_cbw_tag_next;\n\t}\n\tudi_msc_csw_data_residue = udi_msc_cbw_data_len - udi_msc_cbw_data_processed;\n\tudi_msc_csw_data_residue = SWAP_WORD(udi_msc_csw_data_residue);\n\tudi_msc_csw_send(0);\n\tudi_msc_cbw_data_processed = 0;\n\tudi_msc_cbw_tag = 0;\n\tudi_msc_cbw_signature = 0;\n}\n", "CodeBleu_score": 35.07269990537119}, {"code": "static void udi_msc_csw_process(void)\t// If the data residue is non-zero, stall the next request on the appropriate endpoint\n\tif (udi_msc_cbw.bCBWDataResidue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & CBW_DIR_IN) {\n\t\t\tusb_ack_in();\n\t\t} else {\n\t\t\tusb_ack_out();\n\t\t}\n\t}\n\t// Prepare the CSW\n\tudi_msc_csw.dCSWSignature = CSW_SIGNATURE;\n\tudi_msc_csw.bCSWStatus = CSW_STATUS_PASSED;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.bCBWDataResidue;\n\t// Convert the data residue to little-endian format\n\tudi_msc_csw.dCSWDataResidue = SWAP_WORD(udi_msc_csw.dCSWDataResidue);\n\t// Send the CSW\n\tudi_msc_send_csw();\n}\n", "CodeBleu_score": 49.359722419517865}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tuint8_t i;\n\tuint8_t b_dtr_rate_1200 = false;\n\tuint32_t dw_reset_delay = 0;\n\n\tif (port >= USB_CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\tdw_reset_delay = 0;\n\n\t\t/* Check if the DTR rate is 1200. */\n\t\tfor (i = 0; i < USB_CDC_PORT_COUNT; i++) {\n\t\t\tif (usb_cdc_line_coding[i].dwDTERate == 1200) {\n\t\t\t\tb_dtr_rate_1200 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* If the DTR rate is 1200, disable the DTR signal. */\n\t\tif (b_dtr_rate_1200) {\n\t\t\tusb_cdc_line_coding[port].bDTR = false;\n\t\t\tusb_cdc_line_coding[port].bRTS = true;\n\t\t}\n\n\t\t/* If the DTR rate is 1200 and the DTR signal is disabled, schedule a delayed system reset. */\n\t\tif (b_dtr_rate_1200 &&!usb_cdc_line_coding[port].bDTR) {\n\t\t\tdw_reset_delay = 1000;\n\t\t}\n\t} else {\n\t\t/* Enable the DTR signal. */\n\t\tusb_cdc_line_coding[port].bDTR = true;\n\t\tusb_cdc_line_coding[port].bRTS = true;\n\n\t\t/* Cancel any scheduled system reset. */\n\t\tcancelReset();\n\t}\n\n\t/* Update the DTR status. */\n\tusb_cdc_line_coding[port].bDTR = b_enable;\n\n\t/* If a delayed system reset is scheduled, schedule it now. */\n\tif (dw_reset_delay) {\n\t\tscheduleReset(dw_reset_delay);\n\t}\n}\n", "CodeBleu_score": 30.82199445097204}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (port >= USB_CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\tif (g_usb_cdc_ports[port].dtr_rate_1200) {\n\t\t\tif (!g_usb_cdc_ports[port].dtr) {\n\t\t\t\tg_usb_cdc_ports[port].dtr = true;\n\t\t\t\tif (g_usb_cdc_ports[port].reset_scheduled) {\n\t\t\t\t\tcancelReset(port);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (g_usb_cdc_ports[port].dtr) {\n\t\t\tg_usb_cdc_ports[port].dtr = false;\n\t\t\tif (g_usb_cdc_ports[port].dtr_rate_1200) {\n\t\t\t\tif (!g_usb_cdc_ports[port].reset_scheduled) {\n\t\t\t\t\tg_usb_cdc_ports[port].reset_scheduled = true;\n\t\t\t\t\tscheduleReset(port, 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.495741137929656}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (port >= USB_CDC_PORT_MAX) {\n\t\treturn;\n\t}\n\tusb_cdc_port_t* port_ptr = &g_usb_cdc_port[port];\n\tport_ptr->b_dtr = b_enable;\n\tif (port_ptr->b_dtr) {\n\t\tif (port_ptr->dtr_rate == USB_CDC_DTR_RATE_1200) {\n\t\t\tif (port_ptr->b_dtr_enabled) {\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (port_ptr->dtr_rate == USB_CDC_DTR_RATE_1200) {\n\t\t\tif (port_ptr->b_dtr_enabled) {\n\t\t\t\tport_ptr->b_dtr_enabled = false;\n\t\t\t\tport_ptr->b_dtr_enabled_pending = true;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.03587950640187}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)\tswitch (usb_control_request.bRequest) {\n\t\tcase 0x04: {\n\t\t\t// Microsoft-compatible device descriptor\n\t\t\tusb_control_request.wValue = 0x0000;\n\t\t\tusb_control_request.wIndex = 0x0000;\n\t\t\tusb_control_request.wLength = sizeof(usb_microsoft_compatible_device_descriptor);\n\t\t\tusb_control_request.payload = (uint8_t *) usb_microsoft_compatible_device_descriptor;\n\t\t\treturn true;\n\t\t}\n\t\tcase 0x05: {\n\t\t\t// Microsoft-compatible configuration descriptor\n\t\t\tusb_control_request.wValue = 0x0000;\n\t\t\tusb_control_request.wIndex = 0x0000;\n\t\t\tusb_control_request.wLength = sizeof(usb_microsoft_compatible_configuration_descriptor);\n\t\t\tusb_control_request.payload = (uint8_t *) usb_microsoft_compatible_configuration_descriptor;\n\t\t\treturn true;\n\t\t}\n\t\tcase 0x06: {\n\t\t\t// Microsoft-compatible string descriptor\n\t\t\tusb_control_request.wValue = usb_control_request.wIndex;\n\t\t\tusb_control_request.wIndex = 0x0409;\n\t\t\tusb_control_request.wLength = 255;\n\t\t\tusb_control_request.payload = (uint8_t *) usb_microsoft_compatible_string_descriptor;\n\t\t\treturn true;\n\t\t}\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 25.30509685820726}, {"code": "bool usb_task_other_requests(void)\tuint8_t request_type = usb_control_request.bmRequestType;\n\tuint8_t request = usb_control_request.bRequest;\n\tuint16_t value = usb_control_request.wValue;\n\tuint16_t index = usb_control_request.wIndex;\n\tuint16_t length = usb_control_request.wLength;\n\tbool handled = false;\n\n\tif ((request_type & USB_REQUEST_TYPE_TYPE_MASK) == USB_REQUEST_TYPE_TYPE_VENDOR) {\n\t\tif (request == USB_REQUEST_GET_DESCRIPTOR) {\n\t\t\tif (value == USB_DESCRIPTOR_TYPE_STRING) {\n\t\t\t\tif (index == 0) {\n\t\t\t\t\t// Microsoft OS String Descriptor\n\t\t\t\t\tusb_control_request.payload[0] = 48; // wTotalLength\n\t\t\t\t\tusb_control_request.payload[1] = 3; // bNumInterfaces\n\t\t\t\t\tusb_control_request.payload[2] = 0x04; // bConfigurationValue\n\t\t\t\t\tusb_control_request.payload[3] = 0x09; // iConfiguration\n\t\t\t\t\tusb_control_request.payload[4] = 0x04; // bmAttributes\n\t\t\t\t\tusb_control_request.payload[5] = 0x09; // MaxPower\n\t\t\t\t\tusb_control_request.payload[6] = 0x04; // bNumInterfaces\n\t\t\t\t\tusb_control_request.payload[7] = 0x00; // bInterfaceNumber\n\t\t\t\t\tusb_control_request.payload[8] = 0x00; // bAlternateSetting\n\t\t\t\t\tusb_control_request.payload[9] = 0x02; // bNumEndpoints\n\t\t\t\t\tusb_control_request.payload[10] = 0x02; // bInterfaceClass\n\t\t\t\t\tusb_control_request.payload[11] = 0x02; // bInterfaceSubClass\n\t\t\t\t\tusb_control_request.payload[12] = 0x01; // bInterfaceProtocol\n\t\t\t\t\tusb_control_request.payload[13] = 0x00; // iInterface\n\t\t\t\t\tusb_control_request.payload[14] = 0x00; //", "CodeBleu_score": 20.75856443133605}, {"code": "bool usb_task_other_requests(void)\tswitch (usb_setup.bRequest) {\n\t\tcase 0x04: {\n\t\t\tusb_setup.wValue = 0x0001;\n\t\t\tusb_setup.wLength = 0x0002;\n\t\t\tusb_setup.data[0] = 0x00;\n\t\t\tusb_setup.data[1] = 0x00;\n\t\t\treturn true;\n\t\t}\n\t\tcase 0x05: {\n\t\t\tusb_setup.wValue = 0x0001;\n\t\t\tusb_setup.wLength = 0x0002;\n\t\t\tusb_setup.data[0] = 0x00;\n\t\t\tusb_setup.data[1] = 0x00;\n\t\t\treturn true;\n\t\t}\n\t\tdefault: {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 10.393324397348408}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tuint8_t i;\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\n\tbuf[i] = spiRec();\n}\n", "CodeBleu_score": 43.474075410683675}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0) return;\n\tuint8_t *p = buf;\n\twhile (--nbyte) {\n\t\t*p++ = spiRec();\n\t}\n\t*p = spiRec();\n}\n", "CodeBleu_score": 29.886940864687205}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tuint8_t i;\n\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[i] = spiRec();\n}\n", "CodeBleu_score": 43.474075410683675}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler;\n\tuint32_t *relocated_isr_table;\n\n\t// Get the address of the relocated ISR vector table\n\trelocated_isr_table = (uint32_t *) *((uint32_t *) 0xE000ED08);\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Get the current handler for the specified IRQ\n\toldHandler = (pfnISR_Handler) relocated_isr_table[irq];\n\n\t// Replace the current handler with the new handler\n\trelocated_isr_table[irq] = (uint32_t) newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}\n", "CodeBleu_score": 48.515770710719444}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler;\n\n\t// retrieve the address of the relocated interrupt vector table\n\tuint32_t *pVectorTable = (uint32_t *)SCB->VTOR;\n\n\t// disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// retrieve the current handler for the specified IRQ\n\toldHandler = (pfnISR_Handler)pVectorTable[irq];\n\n\t// replace the current handler with the new handler\n\tpVectorTable[irq] = (uint32_t)newHandler;\n\n\t// re-enable global interrupts\n\t__enable_irq();\n\n\t// return the original ISR handler\n\treturn oldHandler;\n}\n", "CodeBleu_score": 49.62291560998814}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler = NULL;\n\tuint32_t *pTable;\n\tuint32_t *pHandler;\n\tuint32_t handler;\n\n\t/* Get the address of the relocated interrupt vector table */\n\tpTable = (uint32_t *)SCB->VTOR;\n\n\t/* Disable global interrupts */\n\t__disable_irq();\n\n\t/* Get the current handler for the specified IRQ */\n\tpHandler = &pTable[irq];\n\thandler = *pHandler;\n\n\t/* Replace the current handler with the new handler */\n\t*pHandler = (uint32_t)newHandler;\n\n\t/* Re-enable global interrupts */\n\t__enable_irq();\n\n\t/* Return the original handler */\n\toldHandler = (pfnISR_Handler)handler;\n\treturn oldHandler;\n}\n", "CodeBleu_score": 44.754774476130535}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek()\tif (enabled() && configured()) {\n\t\twhile (SerialUSB.available()) {\n\t\t\tint c = SerialUSB.read();\n\t\t\tif (c == 0x1B) {\n\t\t\t\tif (emergency_parser.enabled) {\n\t\t\t\t\tc = emergency_parser.process(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}\n", "CodeBleu_score": 25.294449510702187}, {"code": "int MarlinSerialUSB::peek()#if ENABLED(SERIAL_STATS_DROPPED_BYTES)\n  static uint32_t last_dropped = 0;", "CodeBleu_score": 2.7307476780149913}, {"code": "int MarlinSerialUSB::peek()#if ENABLED(SERIAL_USB)\n  if (serial_ && serial_->peek()) {\n    int c = serial_->read();\n    if (ENABLED(EMERGENCY_PARSER) && c == EMERGENCY_PARSER_MESSAGE) {\n      emergency_parser.parse();\n    }\n    return c;\n  }\n  return -1;", "CodeBleu_score": 23.767120623815305}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read()#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available()) return emergency_parser.read();", "CodeBleu_score": 16.697161374759656}, {"code": "int MarlinSerialUSB::read()#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available()) {\n    return emergency_parser.read();\n  }", "CodeBleu_score": 17.33414535491025}, {"code": "int MarlinSerialUSB::read()\t// Check if there is a pending character\n\tif (m_rx_buffer.available()) {\n\t\treturn m_rx_buffer.read_byte();\n\t}\n\t// If not, check if the USB CDC is enabled and configured\n\tif (!m_usb_cdc_enabled) {\n\t\treturn -1;\n\t}\n\t// Check if there are any bytes available to read from the PC\n\tif (!m_usb_cdc_serial.available()) {\n\t\treturn -1;\n\t}\n\t// If a byte is available, read the byte\n\tuint8_t byte = m_usb_cdc_serial.read();\n\t// Update the emergency parser if enabled\n\tif (m_emergency_parser) {\n\t\tm_emergency_parser->update(byte);\n\t}\n\t// Return the read character\n\treturn byte;\n}\n", "CodeBleu_score": 34.18369366410892}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available()\tif (count) return count;\n\treturn usb_cdc_enabled && usb_cdc_connected && usb_cdc_rx_buffer_head!= usb_cdc_rx_buffer_tail;\n}\n", "CodeBleu_score": 30.627880407135944}, {"code": "int MarlinSerialUSB::available()#if ENABLED(USE_USB_SERIAL)\n  if (Serial && Serial.available()) return Serial.available();", "CodeBleu_score": 33.25890614671157}, {"code": "int MarlinSerialUSB::available()#if ENABLED(USE_USB_SERIAL)\n  if (usb_cdc_enabled) {\n    return usb_cdc.available();\n  }", "CodeBleu_score": 27.584976202202643}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tif (pos < 0 || pos >= _size) {\n\t\treturn false;\n\t}\n\n\tuint16_t crc_tmp = *crc;\n\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (pos >= _size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvalue[i] = _data[pos];\n\t\tcrc_tmp = crc16_update(crc_tmp, value[i]);\n\t\tif (writing) {\n\t\t\t_data[pos] = value[i];\n\t\t}\n\t\tpos++;\n\t}\n\n\t*crc = crc_tmp;\n\n\treturn true;\n}\n", "CodeBleu_score": 44.9811485516597}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tif (pos >= _size) {\n\t\treturn false;\n\t}\n\n\tint bytes_read = 0;\n\twhile (bytes_read < size && pos < _size) {\n\t\tif (!writing) {\n\t\t\tvalue[bytes_read] = _data[pos];\n\t\t}\n\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, _data[pos]);\n\t\t}\n\n\t\tpos++;\n\t\tbytes_read++;\n\t}\n\n\treturn bytes_read == size;\n}\n", "CodeBleu_score": 42.64069997342676}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tif (pos >= _size) {\n\t\treturn false;\n\t}\n\n\tsize_t i = 0;\n\twhile (i < size) {\n\t\tif (pos >= _size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (writing) {\n\t\t\tvalue[i] = _data[pos];\n\t\t}\n\n\t\tif (crc) {\n\t\t\t*crc = crc16_add(*crc, _data[pos]);\n\t\t}\n\n\t\tpos++;\n\t\ti++;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 43.556552941553775}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\tif (pin >= NUM_DIGITAL_PINS) return;\n\n\tif (PWM_PINS[pin] == 0) {\n\t\tif (PWM_COUNT == 0) {\n\t\t\t// Start the timer\n\t\t\tledcSetup(PWM_TIMER, freq, res);\n\t\t}\n\n\t\t// Allocate a new slot\n\t\tPWM_PINS[pin] = PWM_COUNT;\n\t\tPWM_COUNT++;\n\t}\n\n\t// Set the PWM value\n\tledcWrite(PWM_TIMER, PWM_PINS[pin], value);\n}\n", "CodeBleu_score": 28.93895772070537}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)#ifdef ESP32\n    ledcWrite(pin, value, freq, res);", "CodeBleu_score": 9.395042588963099}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\tif(value > 0) {\n\t\tif(freq > 0) {\n\t\t\tif(res > 0) {\n\t\t\t\tif(res < 16) {\n\t\t\t\t\t// Hardware PWM\n\t\t\t\t\tledcWrite(pin, res, value);\n\t\t\t\t} else {\n\t\t\t\t\t// Software PWM\n\t\t\t\t\tif(PWM_PINS[pin] == 0) {\n\t\t\t\t\t\t// No existing software PWM state found, so start the timer\n\t\t\t\t\t\tif(PWM_TIMER == 0) {\n\t\t\t\t\t\t\t// No timer running yet, so start it\n\t\t\t\t\t\t\tif(freq > 0) {\n\t\t\t\t\t\t\t\t// Set the timer frequency\n\t\t\t\t\t\t\t\tif(freq < 1000000) {\n\t\t\t\t\t\t\t\t\t// Set the prescaler to 80MHz / (freq * 2) - 1\n\t\t\t\t\t\t\t\t\tuint32_t prescaler = (80000000 / (freq * 2)) - 1;\n\t\t\t\t\t\t\t\t\t// Set the timer frequency\n\t\t\t\t\t\t\t\t\ttimer_config_t config = {\n\t\t\t\t\t\t\t\t\t\t.divider = prescaler,\n\t\t\t\t\t\t\t\t\t\t.counter_dir = TIMER_COUNT_UP,\n\t\t\t\t\t\t\t\t\t\t.counter_en = TIMER_PAUSE,\n\t\t\t\t\t\t\t\t\t\t.alarm_en = TIMER_ALARM_DIS,\n\t\t\t\t\t\t\t\t\t\t.intr_type = TIMER_INTR_LEVEL,\n\t\t\t\t\t\t\t\t\t\t.auto_reload = TIMER_AUTORELOAD_DIS\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\ttimer_init(PWM_TIMER, config);\n\t\t\t\t\t\t\t\t\ttimer_set_counter_value(PWM_TIMER, 0);\n\t\t\t\t\t\t\t\t\ttimer_set_alarm_value(PWM_TIMER, 0);\n\t\t\t\t\t\t\t\t\ttimer_enable_intr(PWM_TIMER);\n\t\t\t\t\t\t\t\t\ttimer_isr_register(PWM_TIMER, &PWM_timer_isr, NULL, ESP_INTR_FLAG_IRAM, NULL);\n\t\t\t\t\t\t\t\t\ttimer_start(PWM_TIMER);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Timer frequency too high\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Increment the used PWM count\n\t\t\t\t\t\tPWM_PINS[pin]++;\n\t\t\t\t\t}\n\t\t\t\t\t// Set the PWM value, converting it to a 7-bit internal representation\n\t\t\t\t\tuint16_t duty = (value * 1023) / res;\n\t\t\t\t\tif(duty > 1023) {\n\t\t\t\t\t\tduty = 1023;\n\t\t\t\t\t}\n\t\t\t\t\tPWM_", "CodeBleu_score": 35.72497066152781}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value)#if SERVO_DELAY_ARRAY_LENGTH!= 0\n    static_assert(SERVO_DELAY_ARRAY_LENGTH >= SERVO_CHANNELS, \"The servo delay array length must be greater than or equal to the number of servo channels.\");", "CodeBleu_score": 22.713356561470345}, {"code": "void Servo::move(const int value)\tstatic_assert(SERVO_DELAY_LENGTH >= SERVO_CHANNEL_COUNT, \"SERVO_DELAY_LENGTH must be greater than or equal to SERVO_CHANNEL_COUNT\");\n\n\t// Check if the servo attaches successfully\n\tif (attach()) {\n\t\t// Write the desired value to move the servo\n\t\twrite(value);\n\n\t\t// Wait for a predefined delay specific to the servo channel\n\t\tdelay(SERVO_DELAY[SERVO_CHANNEL]);\n\n\t\t// Optionally, detach the servo\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tdetach();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.96792727381375}, {"code": "void Servo::move(const int value)#if defined(DEACTIVATE_SERVOS_AFTER_MOVE) && (DEACTIVATE_SERVOS_AFTER_MOVE == 1)\n  detach();", "CodeBleu_score": 17.44690137475565}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample()\tuint32_t i;\n\tuint32_t j;\n\tuint32_t k;\n\tuint32_t duty_cycle;\n\tuint32_t pin_state;\n\tuint32_t pin_mask;\n\tuint32_t port_data;\n\tuint32_t port_mask;\n\tuint32_t port_shift;\n\tuint32_t port_index;\n\tuint32_t port_offset;\n\tuint32_t port_count;\n\tuint32_t port_mask_index;\n\tuint32_t port_mask_offset;\n\tuint32_t port_mask_count;\n\tuint32_t port_mask_shift;\n\tuint32_t port_mask_data;\n\tuint32_t port_mask_data_mask;\n\tuint32_t port_mask_data_shift;\n\tuint32_t port_mask_data_index;\n\tuint32_t port_mask_data_offset;\n\tuint32_t port_mask_data_count;\n\tuint32_t port_mask_data_mask_index;\n\tuint32_t port_mask_data_mask_offset;\n\tuint32_t port_mask_data_mask_count;\n\tuint32_t port_mask_data_mask_shift;\n\tuint32_t port_mask_data_mask_data;\n\tuint32_t port_mask_data_mask_data_mask;\n\tuint32_t port_mask_data_mask_data_shift;\n\tuint32_t port_mask_data_mask_data_index;\n\tuint32_t port_mask_data_mask_data_offset;\n\tuint32_t port_mask_data_mask_data_count;\n\tuint32_t port_mask_data_mask_data_mask_index;\n\tuint32_t port_mask_data_mask_data_mask_offset;\n\tuint32_t port_mask_data_mask_data_mask_count;\n\tuint", "CodeBleu_score": 3.036790279640848}, {"code": "void i2s_push_sample()\t// Update the PWM states for each pin\n\tfor (uint8_t pin = 0; pin < NUM_PINS; pin++) {\n\t\t// Check if the pin has active PWM\n\t\tif (pwm_states[pin].duty_cycle > 0) {\n\t\t\t// If the PWM tick count reaches zero, toggle the pin state and set the tick count for the next transition\n\t\t\tif (pwm_states[pin].tick_count == 0) {\n\t\t\t\tpwm_states[pin].tick_count = pwm_states[pin].duty_cycle;\n\t\t\t\tpwm_states[pin].state =!pwm_states[pin].state;\n\t\t\t}\n\t\t\t// Store the updated pin state into the current position of the DMA buffer\n\t\t\tif (pwm_states[pin].state) {\n\t\t\t\ti2s_buf[i2s_buf_pos] |= (1 << pin);\n\t\t\t} else {\n\t\t\t\ti2s_buf[i2s_buf_pos] &= ~(1 << pin);\n\t\t\t}\n\t\t\t// Increment the buffer position\n\t\t\ti2s_buf_pos++;\n\t\t\t// If the buffer position reaches the buffer size, reset it to zero\n\t\t\tif (i2s_buf_pos == I2S_BUF_SIZE) {\n\t\t\t\ti2s_buf_pos = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.76057923591025}, {"code": "void i2s_push_sample()\t// Iterate through each pin\n\tfor (uint8_t pin = 0; pin < NUM_PINS; pin++) {\n\t\t// Check if the pin has active PWM\n\t\tif (pin_pwm_duty_cycle[pin]!= 0) {\n\t\t\t// Check if the pin state needs to be updated\n\t\t\tif (pin_state[pin]!= pin_pwm_duty_cycle[pin] > 0) {\n\t\t\t\t// Update the pin state\n\t\t\t\tpin_state[pin] = pin_pwm_duty_cycle[pin] > 0;\n\n\t\t\t\t// Toggle the pin\n\t\t\t\tif (pin_state[pin]) {\n\t\t\t\t\tdigitalWrite(pin, HIGH);\n\t\t\t\t} else {\n\t\t\t\t\tdigitalWrite(pin, LOW);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Decrement the PWM tick count\n\t\t\tpin_pwm_duty_cycle[pin]--;\n\t\t}\n\t}\n\n\t// Update the DMA buffer\n\tuint32_t *buffer = (uint32_t *)audio_dma_buffer;\n\tbuffer[audio_dma_buffer_pos] = 0;\n\tfor (uint8_t pin = 0; pin < NUM_PINS; pin++) {\n\t\tif (pin_state[pin]) {\n\t\t\tbuffer[audio_dma_buffer_pos] |= (1 << pin);\n\t\t}\n\t}\n\n\t// Increment the DMA buffer position\n\taudio_dma_buffer_pos++;\n\tif (audio_dma_buffer_pos >= AUDIO_DMA_BUFFER_SIZE) {\n\t\taudio_dma_buffer_pos = 0;\n\t}\n}\n", "CodeBleu_score": 34.561948412547935}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\tif (timer_num < TIMER_NUM) {\n\t\treturn HAL_timer_get_count_by_timer_num(timer_num);\n\t} else {\n\t\treturn HAL_TIMER_INVALID_TIMER;\n\t}\n}\n", "CodeBleu_score": 20.413397013636754}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\tif (timer_num >= HAL_TIMER_NUM) {\n\t\treturn 0;\n\t}\n\n\treturn HAL_TIMER_ARRAY[timer_num].counter;\n}\n", "CodeBleu_score": 19.303206846419403}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\tuint32_t timer_val;\n\n\t// Check the timer number\n\tif (timer_num >= TIMER_NUM) {\n\t\treturn 0;\n\t}\n\n\t// Check the timer state\n\tif (timer_state[timer_num]!= TIMER_STATE_RUN) {\n\t\treturn 0;\n\t}\n\n\t// Get the timer value\n\ttimer_val = TIMER_GetCounter(timer_num);\n\n\t// Return the timer value\n\treturn (hal_timer_t)timer_val;\n}\n", "CodeBleu_score": 34.92202258546312}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (writing) {\n\t\t\tvalue[i] = EEPROM.read(pos + i);\n\t\t}\n\t\tif (crc) {\n\t\t\t*crc = crc16_update(*crc, value[i]);\n\t\t}\n\t}\n\tpos += size;\n\treturn true;\n}\n", "CodeBleu_score": 60.38299635525921}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tif (!value) return false;\n\tif (size == 0) return false;\n\tif (pos + size > EEPROM_SIZE) return false;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (writing) {\n\t\t\tvalue[i] = EEPROM.read(pos);\n\t\t}\n\t\tpos++;\n\t\tif (crc) {\n\t\t\t*crc = update_crc16(*crc, value[i]);\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 54.68419263345822}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tif (writing) {\n\t\tfor (size_t i = 0; i < size; ++i) {\n\t\t\tvalue[i] = EEPROM.read(pos);\n\t\t\tif (crc!= NULL) {\n\t\t\t\t*crc = crc16_update(*crc, value[i]);\n\t\t\t}\n\t\t\t++pos;\n\t\t}\n\t} else {\n\t\tpos += size;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 56.381684918362474}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (sdio_handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\tuint8_t retry = 0;\n\tdo {\n\t\tretry++;\n\t\tif (sdmmc_write_blocks(sdio_handle, src, block, 1) == 0) {\n\t\t\treturn true;\n\t\t}\n\t} while (retry < SD_MAX_RETRIES);\n\tprintf(\"SD write failed after %d retries\\n\", retry);\n\treturn false;\n}\n", "CodeBleu_score": 30.963579525898723}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (!SDHC_SD_SDIO) {\n\t\treturn false;\n\t}\n\tif (!src) {\n\t\treturn false;\n\t}\n\tuint8_t count = 0;\n\twhile (SDHC_GetWriteErrorFlag()) {\n\t\tcount++;\n\t\tif (count > 10) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tSDHC_WriteBlock(block, src);\n\tcount = 0;\n\twhile (SDHC_GetWriteErrorFlag()) {\n\t\tcount++;\n\t\tif (count > 10) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 25.43184562603201}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (SDIO == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\t// Wait for the card to be ready for a write operation.\n\tif (SDIO_WaitReady()!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Set the block size.\n\tif (SDIO_SetBlockSize(512)!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Set the write address.\n\tif (SDIO_SetWriteAddress(block)!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Set the data transfer direction.\n\tif (SDIO_SetTransferDirection(SDIO_TRANSFER_DIRECTION_TO_CARD)!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Set the data transfer mode.\n\tif (SDIO_SetTransferMode(SDIO_TRANSFER_MODE_BLOCK)!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Set the data transfer configuration.\n\tif (SDIO_SetTransferConfiguration(SDIO_TRANSFER_CONFIGURATION_SINGLE)!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Set the data transfer size.\n\tif (SDIO_SetTransferSize(512)!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Set the data transfer interrupt configuration.\n\tif (SDIO_SetTransferInterrupt(SDIO_TRANSFER_INTERRUPT_ENABLED)!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Enable the SDIO peripheral.\n\tif (SDIO_Enable()!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Wait for the transfer to complete.\n\tif (SDIO_WaitTransferComplete()!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Send the data block.\n\tif (SDIO_WriteData(src)!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Wait for the transfer to complete.\n\tif (SDIO_WaitTransferComplete()!= SDIO_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// Disable the SDIO peripheral.\n\tif (SDIO_Disable()!= S", "CodeBleu_score": 23.92938068479459}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\t// Check if the timer channel is valid\n\tASSERT(timer_num == TIMER_CHANNEL_TEMP_SENSOR || timer_num == TIMER_CHANNEL_STEPPER);\n\n\t// Set the timer frequency\n\tHAL_timer_set_frequency(timer_num, frequency);\n\n\t// Start the timer\n\tif (timer_num == TIMER_CHANNEL_TEMP_SENSOR) {\n\t\tHAL_timer_start_temp_sensor();\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\tHAL_timer_start_stepper();\n\t}\n}\n", "CodeBleu_score": 36.411063547182586}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\\tassert(timer_num < TIMER_CHANNEL_COUNT);", "CodeBleu_score": 6.971226666976568}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)#if defined(HAL_TIMER_MODULE_ENABLED)\n    assert(timer_num < TIMER_CHANNEL_NUM);\n    assert(frequency > 0);\n\n    uint32_t prescaler;\n    uint32_t period;\n\n    if (timer_num == TIMER_CHANNEL_TEMP) {\n        prescaler = TEMP_TIMER_PRESCALER;\n        period = HAL_TIMER_FREQ_HZ / frequency;\n    } else if (timer_num == TIMER_CHANNEL_STEP) {\n        prescaler = STEP_TIMER_PRESCALER;\n        period = HAL_TIMER_FREQ_HZ / frequency;\n    } else {\n        assert(0);\n    }\n\n    TIM_TimeBaseInitTypeDef timer_init_struct = {0};\n    timer_init_struct.TIM_Prescaler = prescaler;\n    timer_init_struct.TIM_Period = period - 1;\n    timer_init_struct.TIM_ClockDivision = TIM_CKD_DIV1;\n    timer_init_struct.TIM_CounterMode = TIM_COUNTERMODE_UP;\n    timer_init_struct.TIM_RepetitionCounter = 0;\n\n    if (HAL_TIM_Base_Init(&timer_handles[timer_num])!= HAL_OK) {\n        assert(0);\n    }\n\n    if (HAL_TIM_Base_Init(&timer_handles[timer_num])!= HAL_OK) {\n        assert(0);\n    }\n\n    if (HAL_TIM_Base_Init(&timer_handles[timer_num])!= HAL_OK) {\n        assert(0);\n    }\n\n    if (HAL_TIM_Base_Init(&timer_handles[timer_num])!= HAL_OK) {\n        assert(0);\n    }\n\n    if (HAL_TIM_Base_Init(&timer_handles[timer_num])!= HAL_OK) {\n        assert(0);\n    }\n\n    if (HAL_TIM_Base_Init(&timer_handles[timer_num])!= HAL_OK) {\n        assert(0);\n    }\n\n    if (HAL_TIM_Base_Init(&timer_handles[timer_num])!= HAL_OK) {\n        assert(0);\n    }\n\n    if (HAL_TIM_Base_Init(&timer_handles[timer_num])!= HAL_OK) {\n        assert(0);\n    }\n\n    if (HAL_TIM_Base_Init(&timer_", "CodeBleu_score": 39.96144408020385}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start()\t// Open file for reading and writing.\n\tif (this->file.open(this->filename, FILE_READ | FILE_WRITE)) {\n\t\t// Get file size.\n\t\tthis->file.seek(0, SeekMode::end);\n\t\tthis->file_size = this->file.position();\n\t\tthis->file.seek(0);\n\n\t\t// Check file size.\n\t\tif (this->file_size < EEPROM_SIZE) {\n\t\t\t// Fill remainder of buffer with default erase value.\n\t\t\tfor (uint32_t i = this->file_size; i < EEPROM_SIZE; i++) {\n\t\t\t\tthis->buffer[i] = EEPROM_ERASE_VALUE;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Read file into buffer.\n\t\t\tthis->file.read(this->buffer, EEPROM_SIZE);\n\t\t}\n\n\t\t// Close file.\n\t\tthis->file.close();\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 21.15878582497359}, {"code": "bool PersistentStore::access_start()\tif (this->file_size < EEPROM_SIZE) {\n\t\tthis->access_buffer = new uint8_t[EEPROM_SIZE];\n\t\tfor (int i = 0; i < EEPROM_SIZE; i++) {\n\t\t\tthis->access_buffer[i] = EEPROM_ERASE_VALUE;\n\t\t}\n\t} else {\n\t\tthis->access_buffer = new uint8_t[EEPROM_SIZE];\n\t}\n\tthis->access_file = fopen(this->filename, \"r+b\");\n\tif (this->access_file == NULL) {\n\t\treturn false;\n\t}\n\tfread(this->access_buffer, 1, EEPROM_SIZE, this->access_file);\n\tif (this->file_size < EEPROM_SIZE) {\n\t\tfor (int i = this->file_size; i < EEPROM_SIZE; i++) {\n\t\t\tthis->access_buffer[i] = EEPROM_ERASE_VALUE;\n\t\t}\n\t\tthis->file_size = EEPROM_SIZE;\n\t}\n\tfclose(this->access_file);\n\treturn true;\n}\n", "CodeBleu_score": 26.74597309335185}, {"code": "bool PersistentStore::access_start()\tif (this->file_open()) {\n\t\tthis->file_size = this->file.size();\n\t\tif (this->file_size < PersistentStore::EEPROM_SIZE) {\n\t\t\tthis->file.write(this->buffer, PersistentStore::EEPROM_SIZE - this->file_size);\n\t\t}\n\t\tthis->file.read(this->buffer, PersistentStore::EEPROM_SIZE);\n\t\tthis->file.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 11.508062532967253}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i;\n\tuint8_t r = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tr <<= 1;\n\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, b & 0x80);\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_RESET);\n\t\tif (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\tr |= 0x01;\n\t\t}\n\t\tb <<= 1;\n\t}\n\n\tHAL_Delay(1);\n\treturn r;\n}\n", "CodeBleu_score": 39.66162001372323}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\tuint8_t l;\n\tuint8_t m;\n\tuint8_t n;\n\tuint8_t o;\n\tuint8_t p;\n\tuint8_t q;\n\tuint8_t r;\n\tuint8_t s;\n\tuint8_t t;\n\tuint8_t u;\n\tuint8_t v;\n\tuint8_t w;\n\tuint8_t x;\n\tuint8_t y;\n\tuint8_t z;\n\tuint8_t a;\n\tuint8_t b;\n\tuint8_t c;\n\tuint8_t d;\n\tuint8_t e;\n\tuint8_t f;\n\tuint8_t g;\n\tuint8_t h;\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\tuint8_t l;\n\tuint8_t m;\n\tuint8_t n;\n\tuint8_t o;\n\tuint8_t p;\n\tuint8_t q;\n\tuint8_t r;\n\tuint8_t s;\n\tuint8_t t;\n\tuint8_t u;\n\tuint8_t v;\n\tuint8_t w;\n\tuint8_t x;\n\tuint8_t y;\n\tuint8_t z;\n\tuint8_t a;\n\tuint8_t b;\n\tuint8_t c;\n\tuint8_t d;\n\tuint8_t e;\n\tuint8_t f;\n\tuint8_t g;\n\tuint8_t h;\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\tuint8_t l;\n\tuint8_t m;\n\tuint8_t n;\n\tuint8_t o;\n\tuint8_t p;\n\tuint8_t q;\n\tuint8_t r;\n\tuint8_t s;\n\tuint8_t t;\n", "CodeBleu_score": 24.177023213544736}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t r = 0;\n\tuint8_t i = 0;\n\tuint8_t j = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tHAL_GPIO_WritePin(SPIx_MOSI_GPIO_Port, SPIx_MOSI_Pin, (b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\t\tb <<= 1;\n\t\t\tHAL_GPIO_WritePin(SPIx_SCK_GPIO_Port, SPIx_SCK_Pin, GPIO_PIN_SET);\n\t\t\tHAL_GPIO_WritePin(SPIx_SCK_GPIO_Port, SPIx_SCK_Pin, GPIO_PIN_RESET);\n\t\t\tif (HAL_GPIO_ReadPin(SPIx_MISO_GPIO_Port, SPIx_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\t\tr |= (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\tHAL_Delay(1);\n\treturn r;\n}\n", "CodeBleu_score": 38.41476368987913}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_CLK(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\t/* Enable the AHB clock */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the AHB clock */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 72.18121718134593}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\tif (RCC_AHBPeriph!= 0x00000000) {\n\t\t/* Check the parameters */\n\t\tassert_param(IS_RCC_AHB_CLK_DIV(RCC_AHBPeriph));\n\t\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\t\tif (NewState!= DISABLE) {\n\t\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t\t} else {\n\t\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 69.93468008723902}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 75.26335500508152}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)\t// Read the received byte\n\tuint8_t data = obj->uart->read();\n\n\t// Check for a parity error\n\tif (obj->uart->is_rx_parity_error()) {\n\t\t// If enabled, store the error in the emergency parser\n\t\tif (obj->emergency_parser) {\n\t\t\tobj->emergency_parser->store_error(data);\n\t\t}\n\t}\n\telse {\n\t\t// If there is space in the receive buffer, store the received byte\n\t\tif (obj->rx_head!= obj->rx_tail) {\n\t\t\tobj->rx_buffer[obj->rx_head] = data;\n\t\t\tobj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\t}\n\t\telse {\n\t\t\t// If the receive buffer is full, store the received byte in the emergency parser\n\t\t\tif (obj->emergency_parser) {\n\t\t\t\tobj->emergency_parser->store_error(data);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.61340922532498}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)\tif (obj->rx_buffer.head!= obj->rx_buffer.tail) {\n\t\tif (obj->rx_buffer.head + 1 == RX_BUFFER_SIZE) {\n\t\t\tobj->rx_buffer.head = 0;\n\t\t} else {\n\t\t\tobj->rx_buffer.head++;\n\t\t}\n\t}\n\tobj->rx_buffer.buffer[obj->rx_buffer.head] = obj->rx_buffer.buffer[obj->rx_buffer.tail];\n\tif (obj->rx_buffer.tail + 1 == RX_BUFFER_SIZE) {\n\t\tobj->rx_buffer.tail = 0;\n\t} else {\n\t\tobj->rx_buffer.tail++;\n\t}\n\tif (obj->parser) obj->parser->rx_complete_irq(obj);\n}\n", "CodeBleu_score": 29.68402532121182}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)\tuint8_t c = obj->getc();\n\tif (c!= PARITY_ERROR) {\n\t\tif (obj->rx_head!= obj->rx_tail) {\n\t\t\tobj->rx_buffer[obj->rx_head] = c;\n\t\t\tobj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\t}\n\t}\n\tif (obj->emergency_parser) {\n\t\tobj->emergency_parser->received_byte(c);\n\t}\n}\n", "CodeBleu_score": 42.97481177704119}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (step_timer_initialized &&!step_timer_interrupt_attached) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t\tstep_timer_interrupt_attached = 1;\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (temp_timer_initialized &&!temp_timer_interrupt_attached) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t\ttemp_timer_interrupt_attached = 1;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.00966392752108}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\t// Check if the timer is initialized and lacks an interrupt\n\tif (timer_num < MF_TIMER_NUM && timer_num >= 0 && timer_interrupts[timer_num] == 0) {\n\t\t// Attach the appropriate interrupt handler\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\tHAL_timer_attach_interrupt_handler(Step_Handler);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\tHAL_timer_attach_interrupt_handler(Temp_Handler);\n\t\t}\n\t\t// Enable the interrupt\n\t\ttimer_interrupts[timer_num] = 1;\n\t}\n}\n", "CodeBleu_score": 46.73956371941918}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tif (timer_num < NUM_TIMERS) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.764092935975114}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\t// Check for zero-length slice\n\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\n\t// Calculate the hash of the substring\n\th := hashRabinKarp(sep)\n\n\t// Calculate the hash of the main string\n\tn := len(s) - len(sep)\n\thMain := hashRabinKarp(s[n:])\n\n\t// Check if the hash of the substring is equal to the hash of the main string\n\tif h == hMain {\n\t\t// Check if the substring matches\n\t\tif s[n:] == sep {\n\t\t\treturn n\n\t\t}\n\t}\n\n\t// Calculate the hash of the substring shifted one character to the right\n\thMain = roll(hMain, s[n])\n\n\t// Check if the hash of the substring is equal to the hash of the main string shifted one character to the right\n\tif h == hMain {\n\t\t// Check if the substring matches\n\t\tif s[n+1:] == sep {\n\t\t\treturn n + 1\n\t\t}\n\t}\n\n\t// Calculate the hash of the substring shifted two characters to the right\n\thMain = roll(hMain, s[n])\n\n\t// Check if the hash of the substring is equal to the hash of the main string shifted two characters to the right\n\tif h == hMain {\n\t\t// Check if the substring matches\n\t\tif s[n+2:] == sep {\n\t\t\treturn n + 2\n\t\t}\n\t}\n\n\t// Check for each character in the main string\n\tfor i := n - 1; i >= 0; i-- {\n\t\t// Calculate the hash of the main string shifted one character to the right\n\t\thMain = roll(hMain, s[i])\n\n\t\t// Check if the hash of the substring is equal to the hash of the main string shifted one character to the right\n\t\tif h == hMain {\n\t\t\t// Check if the substring matches\n\t\t\tif s[i+1:i+len(sep)+1] == sep {\n\t\t\t\treturn i + 1\n\t\t\t}\n\t\t}\n\t}\n\n\t// No match found\n\treturn -1\n}\n", "CodeBleu_score": 43.34537253432419}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\treturn len(s) - len(sep) - IndexRabinKarp(s[len(s)-len(sep):], sep)\n}\n", "CodeBleu_score": 6.753887043313156}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\t// Calculate the hash of the substring (sep)\n\th := hashRabinKarp(sep)\n\t// Calculate the hash of the substring (sep)\n\t// with a \"rolling\" or \"moving window\" approach\n\t// and compare it against the hash of the main string\n\t// with a \"rolling\" or \"moving window\" approach\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif h == hashRabinKarp(s[i:i+len(sep)]) && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 29.254509148339082}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush()\t// Disable interrupts\n\tusbcdc.usb.SetInterruptMask(0)\n\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\t// Send it to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\n\t// Set \"waitTxc\" to false\n\tusbcdc.waitTxc = false\n\n\t// Restore the interrupt mask\n\tusbcdc.usb.SetInterruptMask(usbcdc.interruptMask)\n}\n", "CodeBleu_score": 32.683167701290884}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.lock.Lock()\n\tdefer usbcdc.lock.Unlock()\n\tusbcdc.waitTxc = false\n\tif len(usbcdc.txBuf) > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tusbcdc.lock.Unlock()\n}\n", "CodeBleu_score": 27.425597440329913}, {"code": "func (usbcdc *USBCDC) Flush()\t// Disable interrupts\n\tusbcdc.usb.SetInterruptMask(false)\n\t// Check if there is data in the transmit buffer\n\tif len(usbcdc.txBuf) > 0 {\n\t\t// Send it to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\t// Set \"waitTxc\" to false\n\tusbcdc.waitTxc = false\n\t// Restore the interrupt mask\n\tusbcdc.usb.SetInterruptMask(true)\n}\n", "CodeBleu_score": 31.734731385467814}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool)\tif write {\n\t\ti2c.cr.setBits(i2c.cr.write)\n\t} else {\n\t\ti2c.cr.setBits(i2c.cr.read)\n\t}\n\ti2c.cr.setBits(i2c.cr.start)\n\ti2c.sr.setBits(i2c.sr.clear)\n\ti2c.dr.set(address << 1)\n}\n", "CodeBleu_score": 31.233500178412825}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.control = 0\n\tif write {\n\t\ti2c.control = 1 << 7\n\t}\n\ti2c.control |= 1 << 6\n\ti2c.control |= (address << 1)\n\ti2c.bus.SetControl(i2c.control)\n\tfor i := 0; i < 1000; i++ {\n\t\tif i2c.bus.GetStatus()&0x100!= 0 {\n\t\t\treturn\n\t\t}\n\t}\n\tpanic(\"I2C: start condition failed\")\n}\n", "CodeBleu_score": 34.72215693448002}, {"code": "func (i2c *I2C) start(address uint8, write bool)\t// Clear interrupt flag\n\ti2c.cr.StoreBits(cr.I2CEN, 0)\n\t// Set start condition\n\ti2c.cr.StoreBits(cr.START, 1)\n\t// Wait for start condition\n\tfor!i2c.sr.HasBits(sr.START) {\n\t}\n\t// Send address\n\ti2c.dr.Store(address << 1)\n\tif write {\n\t\ti2c.dr.StoreBits(dr.RD_WRN, 0)\n\t} else {\n\t\ti2c.dr.StoreBits(dr.RD_WRN, 1)\n\t}\n\t// Enable I2C\n\ti2c.cr.StoreBits(cr.I2CEN, 1)\n}\n", "CodeBleu_score": 33.406672963947024}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\t// Check that the start address is aligned with the block size\n\tif start%f.blockSize!= 0 {\n\t\treturn fmt.Errorf(\"start address must be aligned with the block size\")\n\t}\n\n\t// Check that the length is a multiple of the block size\n\tif len%f.blockSize!= 0 {\n\t\treturn fmt.Errorf(\"length must be a multiple of the block size\")\n\t}\n\n\t// Configure the flash for erasing\n\tif err := f.configureFlashForErase(); err!= nil {\n\t\treturn err\n\t}\n\n\t// Erase each block\n\tfor block := start; block < start+len; block += f.blockSize {\n\t\t// Wait for any ongoing flash operations to complete\n\t\tif err := f.waitFlashReady(); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Erase the block\n\t\tif err := f.eraseBlock(block); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Configure the flash for reading\n\tif err := f.configureFlashForRead(); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 34.37519572655868}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tif f.erase == nil {\n\t\treturn errors.New(\"flash device does not support erasing\")\n\t}\n\tif len <= 0 {\n\t\treturn errors.New(\"invalid erase length\")\n\t}\n\tif start < 0 {\n\t\treturn errors.New(\"invalid erase start address\")\n\t}\n\tif start%f.eraseSize!= 0 {\n\t\treturn errors.New(\"start address is not aligned with erase size\")\n\t}\n\tif start/f.eraseSize+len > f.numBlocks {\n\t\treturn errors.New(\"erase exceeds flash size\")\n\t}\n\tf.lock.RLock()\n\tdefer f.lock.RUnlock()\n\tf.erase(start/f.eraseSize, len)\n\treturn nil\n}\n", "CodeBleu_score": 23.479367148105798}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"invalid arguments\")\n\t}\n\taddr := start * f.blockSize\n\tfor i := int64(0); i < len; i++ {\n\t\tif err := f.EraseBlock(addr); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\taddr += f.blockSize\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 32.9077386753861}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 {\n\t\treturn 0, errors.New(\"invalid offset\")\n\t}\n\tif off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, errors.New(\"write exceeds device size\")\n\t}\n\tstart := off\n\tend := off + int64(len(p))\n\tfor start < end {\n\t\tn = int(end - start)\n\t\tif n > f.writeBlockSize {\n\t\t\tn = f.writeBlockSize\n\t\t}\n\t\t// pad p to fit the write block size\n\t\tpad := make([]byte, n)\n\t\tcopy(pad, p)\n\t\tp = pad\n\t\t// enable write mode\n\t\tf.writeMode()\n\t\t// write the data in blocks\n\t\tfor i := 0; i < n; i += f.writeBlockSize {\n\t\t\tf.writeBlock(p[i : i+f.writeBlockSize])\n\t\t}\n\t\t// wait for the flash memory to be ready\n\t\tf.waitReady()\n\t\t// update the start address\n\t\tstart += int64(n)\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 32.20260684158253}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 {\n\t\treturn 0, errors.New(\"invalid offset\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, errors.New(\"write exceeds block device size\")\n\t}\n\tstartAddr := uint32(off) / uint32(f.writeBlockSize)\n\tremaining := len(p)\n\tfor startAddr*uint32(f.writeBlockSize) < uint32(off) {\n\t\tstartAddr++\n\t\tremaining -= int(f.writeBlockSize)\n\t}\n\tfor remaining > 0 {\n\t\tif err := f.enableWrite(); err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif err := f.writeBlock(startAddr, p[:remaining]); err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tstartAddr++\n\t\tp = p[remaining:]\n\t\tremaining -= int(f.writeBlockSize)\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 31.507280157941903}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\t// Check if the write operation exceeds the flash memory bounds.\n\tif off < 0 || off+int64(len(p)) > f.size {\n\t\treturn 0, errors.New(\"write out of bounds\")\n\t}\n\n\t// Calculate the start address for writing and pad the byte slice to fit the write block size.\n\taddr := f.addr + uint32(off)\n\tp = pad(p, f.writeBlock)\n\n\t// Enable write mode on the flash memory controller.\n\tf.writeMode()\n\n\t// Write the data in blocks.\n\tfor len(p) > 0 {\n\t\t// Calculate the number of bytes to write.\n\t\tn = len(p)\n\t\tif n > f.writeBlock {\n\t\t\tn = f.writeBlock\n\t\t}\n\n\t\t// Write the data.\n\t\terr = f.write(addr, p[:n])\n\t\tif err!= nil {\n\t\t\treturn\n\t\t}\n\n\t\t// Wait for the flash memory to be ready after each write operation.\n\t\terr = f.waitReady()\n\t\tif err!= nil {\n\t\t\treturn\n\t\t}\n\n\t\t// Update the byte slice and the address.\n\t\tp = p[n:]\n\t\taddr += uint32(n)\n\t}\n\n\treturn len(p), nil\n}\n", "CodeBleu_score": 29.412313019980484}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tdupFd, err := syscall.Dup(fd)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(dupFd)\n\n\tdirPtr, err := syscall.Fdopendir(dupFd)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\treturn dirPtr, \"\", nil\n}\n", "CodeBleu_score": 48.16545896749128}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor and check for errors.\n\tfdDup, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(fdDup)\n\tif err = syscall.CloseOnExec(fdDup); err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tif err = checkFd(fdDup); err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Repeatedly attempt to open the directory until it either succeeds or encounters an error other than \"syscall.EINTR\".\n\tvar dir uintptr\n\tvar errStr string\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fdDup)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\terrStr = err.Error()\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If an error occurs, close the duplicated file descriptor and return the error message; otherwise, return the directory pointer with no error.\n\tif err!= nil {\n\t\tsyscall.Close(fdDup)\n\t\treturn 0, errStr, err\n\t}\n\treturn dir, \"\", nil\n}\n", "CodeBleu_score": 60.95679098735831}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor so we can close it later without affecting the caller.\n\tfdDup, err := syscall.Dup(fd)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(fdDup)\n\n\t// Check for errors.\n\terr = checkFd(fdDup)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory file descriptor.\n\tdirp, err := syscall.Fdopendir(fdDup)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\treturn dirp, \"\", nil\n}\n", "CodeBleu_score": 53.64152368923945}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response)\tesp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, NULL);\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (response) {\n\t\treturn partition->size - partition->offset - SPIFFS_SIZE;\n\t} else {\n\t\treturn partition->size - SPIFFS_SIZE;\n\t}\n}\n", "CodeBleu_score": 33.96232452753389}, {"code": "static uint32_t sketchSize(sketchSize_t response)\tuint32_t size = 0;\n\tesp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, \"factory\");\n\tif (partition!= NULL) {\n\t\tesp_partition_t *partition = esp_partition_get(partition);\n\t\tif (response) {\n\t\t\tsize = partition->size - partition->offset - partition->encrypted_size;\n\t\t} else {\n\t\t\tsize = partition->size;\n\t\t}\n\t}\n\treturn size;\n}\n", "CodeBleu_score": 34.35804582381944}, {"code": "static uint32_t sketchSize(sketchSize_t response)\tuint32_t size;\n\tesp_partition_t *partition;\n\tconst esp_partition_t *running = esp_ota_get_running_partition();\n\tif (running == NULL) {\n\t\treturn 0;\n\t}\n\tpartition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, running->label);\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\tif (response) {\n\t\tsize = partition->size - running->address;\n\t} else {\n\t\tsize = partition->size;\n\t}\n\treturn size;\n}\n", "CodeBleu_score": 53.78022777236116}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\tuint32_t sectors_per_cluster;\n\tuint32_t sectors_per_fat;\n\tuint32_t sectors_per_fat_with_padding;\n\tuint32_t sectors_per_root_directory;\n\tuint32_t sectors_per_data_region;\n\tuint32_t sectors_per_disk;\n\tuint32_t bytes_per_sector;\n\tuint32_t bytes_per_cluster;\n\tuint32_t bytes_per_fat;\n\tuint32_t bytes_per_fat_with_padding;\n\tuint32_t bytes_per_root_directory;\n\tuint32_t bytes_per_data_region;\n\tuint32_t bytes_per_disk;\n\tuint32_t root_directory_sector;\n\tuint32_t data_region_sector;\n\tuint32_t fat_sector;\n\tuint32_t fat_sector_with_padding;\n\tuint32_t i;\n\tuint8_t *sector_buffer;\n\tuint8_t *sector_buffer_2;\n\tuint8_t *sector_buffer_3;\n\tuint8_t *sector_buffer_4;\n\tuint8_t *sector_buffer_5;\n\tuint8_t *sector_buffer_6;\n\tuint8_t *sector_buffer_7;\n\tuint8_t *sector_buffer_8;\n\tuint8_t *sector_buffer_9;\n\tuint8_t *sector_buffer_10;\n\tuint8_t *sector_buffer_11;\n\tuint8_t *sector_buffer_12;\n\tuint8_t *sector_buffer_13;\n\tuint8_t *sector_buffer_14;\n\tuint8_t *sector_buffer_15;\n\tuint8_t *sector_buffer_16;\n\tuint8_t *sector_buffer_17;\n\tuint8_t *sector_buffer_18;\n\tuint8_t *sector_buffer_19;\n\tuint8_t", "CodeBleu_score": 7.493617572338676}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\t// Initialize the RAM disk.\n\tif (!disk_initialize()) {\n\t\treturn false;\n\t}\n\n\t// Get the disk size in 512-byte sectors.\n\tuint32_t disk_size = disk_get_sectors();\n\n\t// Allocate memory for the RAM disk.\n\tuint8_t *ram_disk = malloc(disk_size * 512);\n\tif (!ram_disk) {\n\t\treturn false;\n\t}\n\n\t// Create the FAT filesystem.\n\tuint8_t *fat_filesystem = fat_create(ram_disk, disk_size);\n\tif (!fat_filesystem) {\n\t\tfree(ram_disk);\n\t\treturn false;\n\t}\n\n\t// Create the boot sector.\n\tuint8_t *boot_sector = fat_create_boot_sector(fat_filesystem, volume_label, serial_number);\n\tif (!boot_sector) {\n\t\tfat_destroy(fat_filesystem);\n\t\tfree(ram_disk);\n\t\treturn false;\n\t}\n\n\t// Write the boot sector to the RAM disk.\n\tdisk_write(0, boot_sector, 1);\n\n\t// Write the FAT filesystem to the RAM disk.\n\tdisk_write(1, fat_filesystem, disk_size);\n\n\t// Add a root directory entry for the firmware file.\n\tif (partition_running()) {\n\t\tif (!fat_add_file(fat_filesystem, \"firmware.bin\", 0, 0x200)) {\n\t\t\tfat_destroy(fat_filesystem);\n\t\t\tfree(ram_disk);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Free the memory used by the boot sector and FAT filesystem.\n\tfree(boot_sector);\n\tfree(fat_filesystem);\n\n\treturn true;\n}\n", "CodeBleu_score": 39.61191497236551}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\tuint32_t i;\n\tuint32_t sector_count;\n\tuint32_t root_dir_sectors;\n\tuint32_t data_sectors;\n\tuint32_t fat_sectors;\n\tuint32_t data_size;\n\tuint32_t root_dir_size;\n\tuint32_t fat_size;\n\tuint32_t data_start_sector;\n\tuint32_t root_dir_start_sector;\n\tuint32_t fat_start_sector;\n\tuint32_t root_dir_entry_size;\n\tuint32_t root_dir_entry_count;\n\tuint32_t root_dir_cluster_count;\n\tuint32_t root_dir_cluster_size;\n\tuint32_t root_dir_cluster_start_sector;\n\tuint32_t root_dir_cluster_end_sector;\n\tuint32_t root_dir_cluster_end_cluster;\n\tuint32_t root_dir_cluster_end_cluster_size;\n\tuint32_t root_dir_cluster_end_cluster_start_sector;\n\tuint32_t root_dir_cluster_end_cluster_end_sector;\n\tuint32_t root_dir_cluster_end_cluster_end_cluster;\n\tuint32_t root_dir_cluster_end_cluster_end_cluster_size;\n\tuint32_t root_dir_cluster_end_cluster_end_cluster_start_sector;\n\tuint32_t root_dir_cluster_end_cluster_end_cluster_end_sector;\n\tuint32_t root_dir_cluster_end_cluster_end_cluster_end_cluster;\n\tuint32_t root_dir_cluster_end_cluster_end_cluster_end_cluster_size;\n\tuint32_t root_dir_cluster_end_cluster_end_cluster_end_cluster_start_sector;\n\tuint32_t root_dir_cluster_end_cluster_end_cluster_end_cluster_end_sector;\n\tuint", "CodeBleu_score": 7.301702421408912}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tesp_err_t err;\n\tif (offset % partition->sector_size!= 0) {\n\t\tprintf(\"Offset 0x%x is not aligned with flash sector size 0x%x\\n\", offset, partition->sector_size);\n\t\treturn ESP_FAIL;\n\t}\n\tif ((err = msc_erase_sector(partition, offset))!= ESP_OK) {\n\t\tprintf(\"Erase sector failed with error 0x%x\\n\", err);\n\t\treturn err;\n\t}\n\treturn msc_write(partition, offset, data, size);\n}\n", "CodeBleu_score": 43.16309985296648}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tif (offset % partition->sector_size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not sector aligned\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\n\tif (esp_partition_erase_range(partition, offset, partition->sector_size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector at offset 0x%x\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\n\tif (esp_partition_write(partition, offset, data, size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write data at offset 0x%x\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\n\treturn ESP_OK;\n}\n", "CodeBleu_score": 42.54580842915714}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)\tif (offset % partition->sector_size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not aligned with the sector size 0x%x\", offset, partition->sector_size);\n\t\treturn ESP_FAIL;\n\t}\n\tif (esp_partition_erase_range(partition, offset, partition->sector_size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Erase failed at offset 0x%x\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}\n", "CodeBleu_score": 46.15305567032024}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i = 0;\n\tunsigned char c;\n\twhile (i < maxlen && (c = hex2byte(in))!= 0xff) {\n\t\tout[i] = c;\n\t\tin += 2;\n\t\ti++;\n\t}\n\treturn i;\n}\n", "CodeBleu_score": 25.925461713872615}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i = 0;\n\tsize_t j = 0;\n\tunsigned char c;\n\twhile (i < maxlen && in[i]!= 0) {\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tc = in[i] - '0';\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tc = in[i] - 'A' + 10;\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tc = in[i] - 'a' + 10;\n\t\t} else {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i + 1 < maxlen && in[i + 1] >= '0' && in[i + 1] <= '9') {\n\t\t\tc = (c << 4) + (in[i + 1] - '0');\n\t\t} else if (i + 1 < maxlen && in[i + 1] >= 'A' && in[i + 1] <= 'F') {\n\t\t\tc = (c << 4) + (in[i + 1] - 'A' + 10);\n\t\t} else if (i + 1 < maxlen && in[i + 1] >= 'a' && in[i + 1] <= 'f') {\n\t\t\tc = (c << 4) + (in[i + 1] - 'a' + 10);\n\t\t} else {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tout[j] = c;\n\t\ti += 2;\n\t\tj++;\n\t}\n\treturn j;\n}\n", "CodeBleu_score": 42.070743495815954}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i = 0;\n\tsize_t j = 0;\n\tunsigned char c;\n\n\twhile (i < maxlen && *in) {\n\t\tif (*in >= '0' && *in <= '9') {\n\t\t\tc = *in - '0';\n\t\t} else if (*in >= 'a' && *in <= 'f') {\n\t\t\tc = *in - 'a' + 10;\n\t\t} else if (*in >= 'A' && *in <= 'F') {\n\t\t\tc = *in - 'A' + 10;\n\t\t} else {\n\t\t\tin++;\n\t\t\tcontinue;\n\t\t}\n\t\tin++;\n\t\tif (*in >= '0' && *in <= '9') {\n\t\t\tc = (c << 4) | (*in - '0');\n\t\t} else if (*in >= 'a' && *in <= 'f') {\n\t\t\tc = (c << 4) | (*in - 'a' + 10);\n\t\t} else if (*in >= 'A' && *in <= 'F') {\n\t\t\tc = (c << 4) | (*in - 'A' + 10);\n\t\t} else {\n\t\t\tin++;\n\t\t\tcontinue;\n\t\t}\n\t\tin++;\n\t\tout[j] = c;\n\t\tj++;\n\t\ti++;\n\t}\n\treturn j;\n}\n", "CodeBleu_score": 34.06383889758325}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void)\tif (!initialized) {\n\t\treturn 0;\n\t}\n\tif (!xSemaphoreTake(txLock, 1000)) {\n\t\treturn 0;\n\t}\n\tint freeSize = txSize - txHead - txTail;\n\txSemaphoreGive(txLock);\n\treturn freeSize;\n}\n", "CodeBleu_score": 39.632228243061284}, {"code": "int HWCDC::availableForWrite(void)\tint size = 0;\n\n\tif (txBuffer == NULL) {\n\t\treturn 0;\n\t}\n\tif (txLock == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (txLock->take(txTimeout)) {\n\t\tsize = txBuffer->getFreeSize();\n\t\ttxLock->give();\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 49.572747049343924}, {"code": "int HWCDC::availableForWrite(void)\tif (!m_txLock) return 0;\n\tif (xSemaphoreTake(m_txLock, 100)!= pdTRUE) return 0;\n\tint ret = m_txFree;\n\txSemaphoreGive(m_txLock);\n\treturn ret;\n}\n", "CodeBleu_score": 30.967142534436032}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\t// Lock the serial mutex\n\t_mutex.lock();\n\n\t// Assign the callback function\n\t_onReceiveCB = function;\n\n\t// Set the receive timeout behavior\n\t_onlyOnTimeout = onlyOnTimeout;\n\t_rxTimeout = onlyOnTimeout? _rxTimeout : 0;\n\n\t// If the callback is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n\tif (function) {\n\t\t_rxThreshold = SERIAL_RX_BUFFER_SIZE - 1;\n\t\tif (!_eventTask) {\n\t\t\t_eventTask = createTask(eventTask, this, SERIAL_EVENT_TASK_PRIORITY, SERIAL_EVENT_TASK_STACK_SIZE);\n\t\t}\n\t}\n\n\t// Unlock the serial mutex\n\t_mutex.unlock();\n}\n", "CodeBleu_score": 41.40030551216596}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\t// Lock the serial mutex\n\t_mutex.lock();\n\t// Assign the callback function\n\t_onReceiveCB = function;\n\t// Configure the receive timeout behavior\n\t_rxTimeout = onlyOnTimeout;\n\tif (_onReceiveCB) {\n\t\t// Set the FIFO full threshold\n\t\t_rxThreshold = RX_BUFFER_SIZE;\n\t\t// Create an event task if it does not already exist\n\t\tif (_eventTask == NULL) {\n\t\t\t_eventTask = new EventTask(this);\n\t\t}\n\t}\n\t// Unlock the serial mutex\n\t_mutex.unlock();\n}\n", "CodeBleu_score": 42.722291611547874}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)\t// Lock the serial mutex\n\t_mutex.lock();\n\n\t// Assign the callback function\n\t_onReceiveCB = function;\n\n\t// If the callback is not NULL, configure the receive timeout behavior\n\tif (_onReceiveCB!= NULL) {\n\t\t// If the \"onlyOnTimeout\" flag is set, set the receive timeout\n\t\tif (onlyOnTimeout) {\n\t\t\t_serial.setTimeout(_rxTimeout);\n\t\t}\n\t\t// Otherwise, set the receive timeout to the maximum value\n\t\telse {\n\t\t\t_serial.setTimeout(SERIAL_MAX_TIMEOUT);\n\t\t}\n\n\t\t// If the receive FIFO is empty, set the FIFO full threshold\n\t\tif (_serial.available() == 0) {\n\t\t\t_serial.setRxBufferSize(_rxBufferSize);\n\t\t}\n\n\t\t// If the event task does not already exist, create it\n\t\tif (_eventTask == NULL) {\n\t\t\t_eventTask = createTask(eventTask, this);\n\t\t}\n\t}\n\n\t// Unlock the serial mutex\n\t_mutex.unlock();\n}\n", "CodeBleu_score": 47.72081324761916}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tsize_t i = 0;\n\twhile (i < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[i++] = (char)c;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n", "CodeBleu_score": 56.81584064944754}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = (char)c;\n\t\tindex++;\n\t}\n\treturn index;\n}\n", "CodeBleu_score": 65.52187280596047}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = (char)c;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\treturn index;\n}\n", "CodeBleu_score": 64.60762736499248}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\t//log the pin, frequency, and duration\n\tSerial.print(\"tone pin \");\n\tSerial.print(pin);\n\tSerial.print(\" frequency \");\n\tSerial.print(frequency);\n\tSerial.print(\" duration \");\n\tSerial.println(duration);\n\n\t//check if the pin is available\n\tif (digitalPinToBitMask(pin) & ~digital_pin_used) {\n\t\t//initialize the tone\n\t\tpinMode(pin, OUTPUT);\n\t\tanalogWrite(pin, 0);\n\t\ttone_pin_used |= digitalPinToBitMask(pin);\n\t\ttone_pin_queue.enqueue(tone_command(pin, frequency, duration));\n\t} else {\n\t\t//log an error message instructing to stop the current tone on the pin first\n\t\tSerial.print(\"tone pin \");\n\t\tSerial.print(pin);\n\t\tSerial.println(\" is already in use\");\n\t}\n}\n", "CodeBleu_score": 37.12149926319663}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\t// Check if the pin is available\n\tif (digitalPinToBitMask(pin)!= NULL) {\n\t\t// Check if the pin is already in use\n\t\tif (digitalPinToInterrupt(pin) == NOT_AN_INTERRUPT) {\n\t\t\t// Initialize the tone\n\t\t\t// Set the pin as OUTPUT\n\t\t\tpinMode(pin, OUTPUT);\n\t\t\t// Set the pin to HIGH\n\t\t\tdigitalWrite(pin, HIGH);\n\t\t\t// Set the pin to PWM\n\t\t\tpinMode(pin, PWM);\n\t\t\t// Set the PWM frequency\n\t\t\tanalogWriteFreq(pin, frequency);\n\t\t\t// Set the PWM duty cycle\n\t\t\tanalogWrite(pin, 255);\n\t\t\t// Log the pin, frequency, and duration\n\t\t\tSerial.print(\"tone: pin=\");\n\t\t\tSerial.print(pin);\n\t\t\tSerial.print(\", frequency=\");\n\t\t\tSerial.print(frequency);\n\t\t\tSerial.print(\", duration=\");\n\t\t\tSerial.println(duration);\n\t\t\t// Send the start command to the queue\n\t\t\ttoneQueue.enqueue(toneStart(pin, frequency, duration));\n\t\t} else {\n\t\t\t// Log an error message\n\t\t\tSerial.print(\"tone: pin=\");\n\t\t\tSerial.print(pin);\n\t\t\tSerial.println(\" is already in use\");\n\t\t}\n\t} else {\n\t\t// Log an error message\n\t\tSerial.print(\"tone: pin=\");\n\t\tSerial.print(pin);\n\t\tSerial.println(\" is not available\");\n\t}\n}\n", "CodeBleu_score": 34.42794529408039}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)\t// Log the pin, frequency, and duration\n\tSerial.print(\"Tone on pin \");\n\tSerial.print(pin);\n\tSerial.print(\" at frequency \");\n\tSerial.print(frequency);\n\tSerial.print(\" for \");\n\tSerial.print(duration);\n\tSerial.println(\" ms.\");\n\n\t// Check if the pin is available or already in use\n\tif (pin_in_use[pin] == false) {\n\t\t// Set the pin to output mode\n\t\tpinMode(pin, OUTPUT);\n\n\t\t// Initialize the tone and send a start command with the pin, frequency, and duration to a queue\n\t\ttone_init(pin, frequency, duration);\n\t\ttone_queue.enqueue(tone_init(pin, frequency, duration));\n\n\t\t// Set the pin to in use\n\t\tpin_in_use[pin] = true;\n\t} else {\n\t\t// Log an error message instructing to stop the current tone on the pin first\n\t\tSerial.print(\"ERROR: Tone on pin \");\n\t\tSerial.print(pin);\n\t\tSerial.println(\" cannot be started because it is already in use.\");\n\t}\n}\n", "CodeBleu_score": 40.232339028562194}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled)\tif (USB.getUSB() == NULL) {\n\t\tif (enabled) {\n\t\t\tif (USB.getVersion() >= 0x0210) {\n\t\t\t\tUSB.setWebUSB(true);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tUSB.setWebUSB(false);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tUSB.setWebUSB(false);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (enabled) {\n\t\t\tif (USB.getVersion() >= 0x0210) {\n\t\t\t\tUSB.setWebUSB(true);\n\t\t\t} else {\n\t\t\t\tUSB.setWebUSB(false);\n\t\t\t}\n\t\t} else {\n\t\t\tUSB.setWebUSB(false);\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 28.040910124845325}, {"code": "bool ESPUSB::webUSB(bool enabled)\tif (!usb_started) {\n\t\twebUSB_enabled = enabled;\n\t\tif (enabled && usb_version < 0x0210) {\n\t\t\tusb_version = 0x0210;\n\t\t}\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (!webUSB_enabled) {\n\t\t\tif (usb_version < 0x0210) {\n\t\t\t\tusb_version = 0x0210;\n\t\t\t}\n\t\t\tsend_webUSB_descriptor();\n\t\t\tsend_webUSB_url();\n\t\t}\n\t} else {\n\t\tif (webUSB_enabled) {\n\t\t\tsend_webUSB_descriptor(false);\n\t\t\tsend_webUSB_url(false);\n\t\t}\n\t}\n\twebUSB_enabled = enabled;\n\treturn false;\n}\n", "CodeBleu_score": 65.91711708275474}, {"code": "bool ESPUSB::webUSB(bool enabled)\tif (!USB.hasStarted()) {\n\t\twebUSB_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tif (USB.getVersion() < 0x0210) {\n\t\t\t\tUSB.setVersion(0x0210);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 38.63036877767579}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX()\tuint8_t data;\n\tuint32_t len;\n\n\t// Read data from the USB endpoint\n\tlen = USB.read(EP_CDC_RX, &data, sizeof(data));\n\n\t// If data was read\n\tif (len) {\n\t\t// If the receive queue is full\n\t\tif (!receiveQueue.enqueue(data)) {\n\t\t\t// Log an error\n\t\t\terror(\"RX overflow\");\n\n\t\t\t// Post an overflow event with the number of dropped bytes\n\t\t\tevents.post(CDC_EVENT_RX_OVERFLOW, len);\n\t\t} else {\n\t\t\t// Post a receive event with the length of the received data\n\t\t\tevents.post(CDC_EVENT_RX, len);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 15.148867831148383}, {"code": "void USBCDC::_onRX()\t// Read data from the USB CDC\n\tuint8_t data = USB.read();\n\t// If the queue is full, log an error\n\tif (rxQueue.full()) {\n\t\t// Log an error\n\t\tlog_error(\"RX Queue Overflow\");\n\t\t// Post an overflow event with the number of dropped bytes\n\t\tpostOverflowEvent(1);\n\t}\n\t// If data was read, post a receive event with the length of the received data\n\telse if (data!= 0) {\n\t\t// Post a receive event with the length of the received data\n\t\tpostReceiveEvent(1);\n\t}\n}\n", "CodeBleu_score": 5.992306458945784}, {"code": "void USBCDC::_onRX()\tint32_t len = 0;\n\tint32_t n = 0;\n\tuint8_t buf[1];\n\n\t// Read data from the USB CDC interface\n\tn = USBCDC::read(buf, sizeof(buf));\n\tif (n > 0) {\n\t\t// Add the data to the receive queue\n\t\tlen = _rxq.write(buf, n);\n\t\tif (len < n) {\n\t\t\t// The queue is full\n\t\t\tUSBDevice.postError(ERROR_OVERFLOW);\n\t\t\t_rxq.clear();\n\t\t\tUSBDevice.logf(\"[%s] Overflow: dropped %d bytes\\n\", USBDevice.productName(), n - len);\n\t\t} else {\n\t\t\t// Post a receive event\n\t\t\tUSBDevice.postEvent(EVENT_CDC_RX, len);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 21.846329072548}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the name of the robot from the request\n\tname := mux.Vars(req)[\"name\"]\n\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(name)\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\t// Gather all the devices associated with the robot\n\tdevices, err := a.db.GetDevices(robot.ID)\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// Create the JSON response\n\tresponse := make(map[string]interface{})\n\tresponse[\"devices\"] = devices\n\n\t// Write the response to the HTTP response writer\n\ta.writeJSON(res, http.StatusOK, response)\n}\n", "CodeBleu_score": 37.33531291748594}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the name of the robot from the URL parameters\n\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Check if a robot with the specified name exists\n\trobot, err := a.db.GetRobot(name)\n\tif err!= nil {\n\t\t// If no robot was found, return an error message\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\t// Gather the devices associated with the robot\n\tdevices := robot.Devices()\n\n\t// Create a JSON response containing the devices\n\ta.writeJSON(res, http.StatusOK, map[string][]string{\"devices\": devices})\n}\n", "CodeBleu_score": 32.14567171887525}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the name of the robot from the request parameters.\n\tname := req.URL.Query().Get(\"name\")\n\n\t// If the name is empty, return an error.\n\tif name == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check if a robot with the given name exists.\n\trobot, err := a.db.GetRobot(name)\n\tif err!= nil {\n\t\t// If the robot does not exist, return an error.\n\t\tif err == ErrRobotNotFound {\n\t\t\tres.WriteHeader(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\t// If an unexpected error occurred, return an error.\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Create a new response object.\n\tresp := struct {\n\t\tRobots []struct {\n\t\t\tName string `json:\"name\"`\n\t\t} `json:\"robots\"`\n\t}{}\n\n\t// Iterate over all robots and add the name of each robot to the response.\n\tfor _, robot := range a.db.robots {\n\t\tresp.Robots = append(resp.Robots, struct {\n\t\t\tName string `json:\"name\"`\n\t\t}{Name: robot.Name})\n\t}\n\n\t// Write the response to the HTTP response writer.\n\terr = json.NewEncoder(res).Encode(resp)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 39.69578433352419}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the request URL\n\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Check if the robot exists\n\trobot, err := a.robots.Get(name)\n\tif err!= nil {\n\t\t// The robot was not found, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"Robot not found\"))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections, convert them to JSON format, and write them to the HTTP response\n\tconnections := make([]map[string]interface{}, len(robot.Connections))\n\tfor i, connection := range robot.Connections {\n\t\tconnections[i] = connection.ToJSON()\n\t}\n\tres.Write(robotConnectionsResponse(connections))\n}\n", "CodeBleu_score": 39.94206502811237}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the request URL.\n\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Check if the robot exists.\n\trobot, err := a.robots.Get(name)\n\tif err!= nil {\n\t\t// If the robot does not exist, return an error message.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, `{\"error\": \"robot not found\"}`)\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format.\n\tconnections := make([]map[string]string, len(robot.connections))\n\tfor i, connection := range robot.connections {\n\t\tconnections[i] = map[string]string{\n\t\t\t\"name\": connection.name,\n\t\t\t\"ip\":   connection.ip,\n\t\t}\n\t}\n\n\t// Write the connections to the HTTP response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 43.807967483348854}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Get the name of the robot from the URL\n\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Check if the robot exists\n\tif _, ok := a.robots[name];!ok {\n\t\t// If the robot does not exist, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with the specified name was found.\"))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format\n\tconnections := make([]map[string]string, len(a.robots[name].connections))\n\ti := 0\n\tfor connection := range a.robots[name].connections {\n\t\tconnections[i] = make(map[string]string)\n\t\tconnections[i][\"name\"] = connection\n\t\tconnections[i][\"direction\"] = a.robots[name].connections[connection]\n\t\ti++\n\t}\n\n\t// Write the connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(json.Marshal(connections))\n}\n", "CodeBleu_score": 41.20725437517919}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the URL query parameters.\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Get the device name from the URL query parameters.\n\tdeviceName := vars[\"device\"]\n\n\t// Check if the robot exists.\n\trobot, err := a.robots.Get(robotName)\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tdevice, err := robot.Devices.Get(deviceName)\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\terr = device.Command(req.URL.Query().Get(\"command\"))\n\tif err!= nil {\n\t\ta.writeError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\t// Write a JSON response.\n\ta.writeJSON(res, http.StatusOK, map[string]string{\"result\": \"ok\"})\n}\n", "CodeBleu_score": 47.597906095448884}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Retrieve the robot and device names from the URL query parameters.\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\tdeviceName := vars[\"deviceName\"]\n\n\t// Retrieve the robot with the specified name from the robots map.\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\t// The robot with the specified name was not found.\n\t\t// Write an error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, \"{\\\"error\\\":\\\"robot not found\\\"}\")\n\t\treturn\n\t}\n\n\t// Retrieve the device with the specified name from the robot's devices map.\n\tdevice, ok := robot.devices[deviceName]\n\tif!ok {\n\t\t// The device with the specified name was not found.\n\t\t// Write an error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, \"{\\\"error\\\":\\\"device not found\\\"}\")\n\t\treturn\n\t}\n\n\t// Retrieve the command name from the request body.\n\tvar commandName string\n\tif err := json.NewDecoder(req.Body).Decode(&commandName); err!= nil {\n\t\t// An error occurred while retrieving the command name from the request body.\n\t\t// Write an error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(res, \"{\\\"error\\\":\\\"invalid request\\\"}\")\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\tif err := device.Command(commandName); err!= nil {\n\t\t// An error occurred while executing the command on the device.\n\t\t// Write an error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(res, \"{\\\"error\\\":\\\"invalid command\\\"}\")\n\t\treturn\n\t}\n\n\t// Write a success message as a JSON response.\n\tres.Header().Set(\"Content-Type\", \"application", "CodeBleu_score": 33.907148719892575}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Retrieve the robot and device names from the URL query parameters\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\tdeviceName := vars[\"deviceName\"]\n\n\t// Check if the device exists\n\tdevice, err := a.robotManager.GetDevice(robotName, deviceName)\n\tif err!= nil {\n\t\t// If an error occurs while retrieving the device, write the error message as a JSON response\n\t\ta.writeJSONError(res, err)\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device\n\terr = device.Command(req.FormValue(\"command\"))\n\tif err!= nil {\n\t\t// If an error occurs while executing the command, write the error message as a JSON response\n\t\ta.writeJSONError(res, err)\n\t\treturn\n\t}\n\n\t// Write a JSON response indicating that the command was executed successfully\n\ta.writeJSON(res, map[string]interface{}{\n\t\t\"success\": true,\n\t})\n}\n", "CodeBleu_score": 44.287443500288546}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Retrieve the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\t// If the \"Authorization\" header is empty, return a \"401 Unauthorized\" response.\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Verify that the \"Authorization\" header is valid by checking it against the expected value.\n\t\texpected := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tif auth!= expected {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the \"Authorization\" header is valid, call the next handler.\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 55.586365749856434}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\t// If the \"Authorization\" header is empty, return an error.\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the \"Authorization\" header value into two parts: the type and the credentials.\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\t// If the \"Authorization\" header does not have two parts, return an error.\n\t\tif!(len(parts) == 2 && parts[0] == \"Basic\") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Decode the credentials and verify that they match the username and password.\n\t\tb, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err!= nil || string(b)!= username+\":\"+password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the credentials are valid, call the next handler.\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 49.22917693804882}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\t// If the header is empty, return an error.\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"authorization failed: missing authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Otherwise, attempt to split the header into 2 parts: the \"Basic\" prefix and the encoded credentials.\n\t\t// If the header is not formatted correctly, return an error.\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\tif len(parts)!= 2 || parts[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"authorization failed: invalid authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Decode the base64-encoded credentials.\n\t\t// If the credentials are not formatted correctly, return an error.\n\t\tdecoded, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"authorization failed: invalid authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the decoded credentials into 2 parts: the username and password.\n\t\t// If the credentials are not formatted correctly, return an error.\n\t\tparts = strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(parts)!= 2 || parts[0]!= username || parts[1]!= password {\n\t\t\thttp.Error(w, \"authorization failed: invalid authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the credentials are valid, call the next handler.\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 45.0967022439187}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif!a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0.0, fmt.Errorf(\"This connection does not support analog read.\")\n\t}\n\n\traw, err := a.connection.AnalogRead()\n\tif err!= nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"Could not read analog value: %s\", err)\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scaleRawValue(raw)\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 41.660418857305245}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the sensor for reading.\n\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\t// Check if the sensor supports analog reading.\n\tif!a.analogSupported {\n\t\treturn 0, 0.0, errors.New(\"the sensor does not support analog reading\")\n\t}\n\n\t// Read the sensor's value.\n\traw, err := a.sensor.Read()\n\n\t// Check for errors.\n\tif err!= nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\t// Scale the raw value.\n\tscaled := a.scaleRawValue(raw)\n\n\t// Update the last read values.\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\t// Return the raw and scaled values.\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 37.83381777076957}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif a.sensor == nil {\n\t\treturn 0, 0, errors.New(\"no sensor\")\n\t}\n\n\tif!a.supportsAnalog() {\n\t\treturn 0, 0, errors.New(\"sensor does not support analog\")\n\t}\n\n\traw, err := a.sensor.Read()\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.raw = raw\n\ta.scaled = a.scale(raw)\n\n\treturn raw, a.scaled, nil\n}\n", "CodeBleu_score": 45.87638381749586}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDrivervar name string\n\tif len(opts) > 0 {\n\t\tname = opts[0].(string)\n\t} else {\n\t\tname = \"GroveSoundSensorDriver\"\n\t}\n\tgsd := &GroveSoundSensorDriver{\n\t\tname:         name,\n\t\tanalogReader: a,\n\t\tpin:          pin,\n\t\tsoundLevel:   0,\n\t\tsoundLevelThreshold: 100,\n\t\tsoundLevelChan: make(chan int),\n\t\tsoundLevelThresholdChan: make(chan int),\n\t\tisOn:         false,\n\t\tisOnChan:     make(chan bool),\n\t}\n\tgo gsd.analogReader.Read(gsd.pin, gsd.soundLevelChan)\n\tgo gsd.analogReader.Read(gsd.pin, gsd.soundLevelThresholdChan)\n\treturn gsd\n}\n", "CodeBleu_score": 26.247598045133458}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDrivergsd := &GroveSoundSensorDriver{\n\t\tname:         \"GroveSoundSensorDriver\",\n\t\tanalogReader: a,\n\t\tpin:          pin,\n\t\tthreshold:    100,\n\t}\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase WithName:\n\t\t\tgsd.name = string(o)\n\t\tcase WithThreshold:\n\t\t\tgsd.threshold = o.Threshold\n\t\t}\n\t}\n\treturn gsd\n}\n", "CodeBleu_score": 33.795407843206235}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDrivergsd := &GroveSoundSensorDriver{\n\t\tname:       GSD_DEFAULT_NAME,\n\t\tanalog:     a,\n\t\tpin:        pin,\n\t\tsampleRate: GSD_DEFAULT_SAMPLE_RATE,\n\t\tthreshold:  GSD_DEFAULT_THRESHOLD,\n\t\thistory:    make([]float64, GSD_DEFAULT_HISTORY_LENGTH),\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase WithName:\n\t\t\tgsd.name = o.Name()\n\t\tcase WithHistoryLength:\n\t\t\tgsd.history = make([]float64, o.HistoryLength())\n\t\tcase WithSampleRate:\n\t\t\tgsd.sampleRate = o.SampleRate()\n\t\tcase WithThreshold:\n\t\t\tgsd.threshold = o.Threshold()\n\t\t}\n\t}\n\n\tgsd.analogSensor = NewAnalogSensorDriver(a, pin, WithSampleRate(gsd.sampleRate))\n\n\treturn gsd\n}\n", "CodeBleu_score": 30.083083651129993}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error\t// Write soft reset command\n\td.writeCommand(PCD_COMMAND_SOFT_RESET)\n\n\t// Wait for the reset to complete\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Check to see if the PCD has resumed communication\n\tif d.readStatus()&0x08 == 0x00 {\n\t\treturn errors.New(\"Soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 24.479668244285836}, {"code": "func (d *MFRC522Common) softReset() error\t// Write the command for soft reset.\n\tif err := d.WriteRegister(PCD_COMMAND, PCD_COMMAND_SOFT_RESET); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the reset to complete.\n\ttime.Sleep(time.Second)\n\n\t// Check to see if the reset succeeded.\n\tif status, err := d.ReadRegister(PCD_COMMAND); err!= nil {\n\t\treturn err\n\t} else if status&0x0800!= 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 56.04657061632009}, {"code": "func (d *MFRC522Common) softReset() error\t// Write soft reset command to the command register.\n\td.writeRegister(CommandReg, PCD_RESETPHASE)\n\t// Wait for the reset to complete.\n\ttime.Sleep(time.Millisecond * 10)\n\t// Check the reset has been properly done.\n\tif d.readRegister(CommandReg)!= 0x00 {\n\t\treturn errors.New(\"PCD soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 22.28651547765552}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tif len(backData)!= d.GetFIFOCount() {\n\t\treturn 0, errors.New(\"The length of the provided byte slice does not match the number of bytes in the FIFO buffer.\")\n\t}\n\n\tfor i := range backData {\n\t\tbackData[i] = d.ReadRegister(FIFODataReg)\n\t}\n\n\treturn d.ReadRegister(ControlReg), nil\n}\n", "CodeBleu_score": 19.24256247020439}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Wait for at least 1 byte in the FIFO\n\tlength, err := d.getFifoLength()\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif length == 0 {\n\t\treturn 0, ErrNoTag\n\t}\n\n\t// Check length\n\tif uint(len(backData))!= length {\n\t\treturn 0, ErrNotEnoughSpace\n\t}\n\n\t// Read data\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByte()\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read status\n\tlastBits, err := d.readRegister(regCommIrqReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}\n", "CodeBleu_score": 44.666784948422354}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tif len(backData)!= d.GetFIFOSize() {\n\t\treturn 0, errors.New(\"readFifo: The length of the byte slice provided does not match the FIFO size\")\n\t}\n\t// Check how many bytes are in the FIFO\n\tlength, err := d.ReadRegister(FIFOLevelReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\t// If the FIFO is empty, return an error\n\tif length == 0 {\n\t\treturn 0, errors.New(\"readFifo: The FIFO is empty\")\n\t}\n\t// If the FIFO is not empty, continue\n\t// Read the FIFO data into the provided byte slice\n\terr = d.ReadBytes(FIFODataReg, backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\t// Read the last bits received\n\tlastBits, err := d.ReadRegister(ControlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\t// Return the last bits received and any errors encountered\n\treturn lastBits, nil\n}\n", "CodeBleu_score": 43.01386594993279}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error\tif d.debug {\n\t\tlog.Printf(\"Halting PICC.\")\n\t}\n\n\tcommand := []byte{PICC_CMD_HALT}\n\tcrc := crc24.Checksum(command[:], 0x00)\n\tcommand = append(command, byte(crc>>16), byte(crc>>8), byte(crc))\n\n\tif err := d.PCD_Transceive(command, nil); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 33.47977156674406}, {"code": "func (d *MFRC522Common) piccHalt() error\tif debug {\n\t\tlog.Printf(\"halting PICC\")\n\t}\n\tcmd := []byte{0x50, 0x00}\n\tcrc := crc24(cmd)\n\tcmd = append(cmd, crc[:]...)\n\terr := d.PCD_Transceive(cmd, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 30.194017743208846}, {"code": "func (d *MFRC522Common) piccHalt() error\tif d.debug {\n\t\tlog.Printf(\"halting PICC\")\n\t}\n\n\t// Build command for PICC halt.\n\tcmd := []byte{piccCommand.HALT}\n\n\t// Calculate CRC for the command.\n\tcrc := crc24(cmd)\n\n\t// Append CRC to command.\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\tcmd = append(cmd, crc[2])\n\n\t// Send the command.\n\tif err := d.PCD_Transceive(cmd); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 34.09886405360288}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tif block > 0x0F {\n\t\treturn nil, ErrPICCError\n\t}\n\n\tdata := []byte{PICC_READ, block}\n\tdata = append(data, crc16(data))\n\n\terr := d.PCD_Communicate(data)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn d.PCD_Communicate(data)\n}\n", "CodeBleu_score": 34.675075720831416}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tvar result []byte\n\tvar status uint16\n\tvar backData []byte\n\tvar backLen uint16\n\tvar err error\n\n\t// Build command for PICC_READ.\n\tcmd := []byte{PICC_READ, byte(block)}\n\n\t// Calculate CRC for command.\n\ttmp := crc16.Checksum(cmd, crc16.MakeTable(crc16.CRC16_CCITT))\n\tcmd = append(cmd, byte(tmp&0xFF))\n\tcmd = append(cmd, byte(tmp>>8))\n\n\t// Transmit the command.\n\td.Write(cmd)\n\n\t// Wait for the response.\n\tif status = d.waitReady(); status!= MI_OK {\n\t\treturn nil, errors.New(\"read failed\")\n\t}\n\n\t// Read the response.\n\tif backLen, err = d.Read(backData); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the CRC.\n\tif status = d.piccCrc(backData[:backLen-2]); status!= MI_OK {\n\t\treturn nil, errors.New(\"read failed\")\n\t}\n\n\t// Return the data.\n\treturn backData[:backLen-2], nil\n}\n", "CodeBleu_score": 40.43308186690644}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\t// Create and send the request\n\trequest := []byte{piccCommandRead, block}\n\tif d.debug {\n\t\tfmt.Printf(\"PCD_Read: % X\\n\", request)\n\t}\n\tif err := d.PCD_Write(request); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the response\n\tresponse := make([]byte, 18)\n\tif err := d.PCD_Read(response); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the CRC\n\tif d.debug {\n\t\tfmt.Printf(\"PCD_Read: % X\\n\", response)\n\t}\n\tif!d.checkCRC(response[:len(response)-2]) {\n\t\treturn nil, ErrCRC\n\t}\n\n\t// Return the data\n\treturn response[1:len(response)-2], nil\n}\n", "CodeBleu_score": 47.74225718739903}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn ErrBufferTooSmall\n\t}\n\t// Clear the collision register\n\td.clearBitMask(mfrc522CrcCollisionPosition, 0x03)\n\t// Set the bits for the request command\n\td.writeBits(mfrc522CommandReg, reqMode, 0x07, 0)\n\t// Start the request by setting the FIFO level to 8\n\td.setFIFOLevel(0x08)\n\t// Wait for the request to be performed\n\tif err := d.waitToIdle(); err!= nil {\n\t\treturn err\n\t}\n\t// Read the first 8 bytes of the response\n\tif err := d.read(mfrc522FIFODataReg, answer[:8]); err!= nil {\n\t\treturn err\n\t}\n\t// Check if there was a collision\n\tif d.readBits(mfrc522CollReg, 0x03)!= 0x00 {\n\t\treturn ErrCollision\n\t}\n\t// Check if the request was not acknowledged\n\tif (answer[0] & 0x0F)!= 0x0A {\n\t\treturn ErrNoTag\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 49.35787338016648}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn ErrWrongSize\n\t}\n\n\td.clearBitMask(0x04, 0x08)\n\tif reqMode!= piccREQIDL {\n\t\td.setBitMask(0x08, 0x80)\n\t}\n\n\terr := d.PCD_TransceiveData(reqMode, 0, 0, answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif (answer[0] & 0x1B)!= 0x00 {\n\t\treturn ErrPCD\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 44.6473324004641}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn ErrBufferTooSmall\n\t}\n\t// Clear the bits in TxControl register\n\td.writeRegister(TxControlReg, 0x00)\n\n\t// Set mode\n\td.writeRegister(TxControlReg, reqMode|0x80)\n\n\t// Wait for the command to be sent.\n\t// Each iteration of the following loop takes 17.5ms.\n\t// Therefore, the maximum waiting time is 409.5ms.\n\tfor i := 0; i < MaxRetries; i++ {\n\t\t// Section 8.1.2.3 of the ISO/IEC 14443-3:2009 (E)\n\t\t// says that we need to wait at least 7.8ms before the first byte.\n\t\t// But MFRC522.py waits 10ms before the first byte.\n\t\t// So I use 13ms to be safe.\n\t\ttime.Sleep(13 * time.Millisecond)\n\t\t// Check if a card is in range\n\t\tstatus := d.readRegister(DivIrqReg)\n\t\tif status&0x04 == 0x04 {\n\t\t\t// A card is in range\n\t\t\tbreak\n\t\t}\n\t}\n\tif i == MaxRetries {\n\t\treturn ErrNoTag\n\t}\n\n\t// Check if an error occurred\n\tstatus = d.readRegister(ErrorReg)\n\tif status&0x1B!= 0x00 {\n\t\treturn ErrError\n\t}\n\n\t// Check if there is no card in the field\n\tif status&0x08 == 0x08 {\n\t\treturn ErrNoTag\n\t}\n\n\t// Wait for the request to be performed.\n\t// This amounts to 25% of the time needed to send the request.\n\t// Each iteration of the following loop takes 17.5ms.\n\t// Therefore, the maximum waiting time is 409.5ms.\n\tfor i := 0; i < MaxRetries; i++ {\n\t\t// Section 8.1.2.3 of the ISO/IEC 14443-3:2009 (E)\n\t\t// says that", "CodeBleu_score": 38.489890651408885}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Perform the step\n\tif d.direction == 0 {\n\t\td.stepNumber -= 1\n\t} else {\n\t\td.stepNumber += 1\n\t}\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Return the error encountered during the digital write operations\n\treturn nil\n}\n", "CodeBleu_score": 52.43154679443391}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low\n\tif err := d.pinStep.Write(gpio.Low); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait the delay\n\ttime.Sleep(d.delay)\n\n\t// Set the step pin high\n\tif err := d.pinStep.Write(gpio.High); err!= nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction == gpio.Low {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 60.75249724356212}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 66.92554307493069}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitor!= nil {\n\t\treturn errors.New(\"Distance monitor already running\")\n\t}\n\td.distanceMonitor = make(chan struct{})\n\td.stopDistanceMonitor = make(chan struct{})\n\td.wgDistanceMonitor = &sync.WaitGroup{}\n\td.wgDistanceMonitor.Add(1)\n\tgo func() {\n\t\tdefer d.wgDistanceMonitor.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitor:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\td.distance = d.ReadDistance()\n\t\t\t\tif d.distance == 0 {\n\t\t\t\t\tlog.Printf(\"Error reading distance from HCSR04 sensor\")\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(d.distanceMonitorInterval)\n\t\t}\n\t}()\n\treturn nil\n}\n", "CodeBleu_score": 47.50880285794455}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stopChannel!= nil {\n\t\treturn errors.New(\"distance monitor is already running\")\n\t}\n\n\td.stopChannel = make(chan bool)\n\td.waitGroup = &sync.WaitGroup{}\n\td.waitGroup.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}\n", "CodeBleu_score": 27.45055721721749}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.distanceMonitorMutex.Lock()\n\tdefer d.distanceMonitorMutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChannel = make(chan bool)\n\td.distanceMonitorWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorWaitGroup.Add(1)\n\td.distanceMonitorRunning = true\n\tgo d.distanceMonitor()\n\n\treturn nil\n}\n", "CodeBleu_score": 29.622964296160653}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\treturn func(pin int, duration time.Duration, channel string, timestamp uint32, value uint32) {\n\t\tif pin == d.triggerPin {\n\t\t\td.triggerTimestamp = timestamp\n\t\t} else if pin == d.echoPin {\n\t\t\td.echoTimestamp = timestamp\n\t\t\td.echoDuration = duration\n\t\t\td.sendEchoDuration(channel, duration)\n\t\t\td.triggerTimestamp = 0\n\t\t\td.echoTimestamp = 0\n\t\t\td.echoDuration = 0\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.06736376257468}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\treturn func(pin int, duration time.Duration, channel string, eventID uint32, eventValue uint32) {\n\t\tif pin == d.triggerPin {\n\t\t\td.start = time.Now()\n\t\t} else if pin == d.echoPin {\n\t\t\td.stop = time.Now()\n\t\t\td.duration = d.stop.Sub(d.start)\n\t\t\td.sendToChannel(channel, eventID, eventValue, d.duration)\n\t\t\td.start = time.Time{}\n\t\t\td.stop = time.Time{}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.04461882598732}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\treturn func(pin int, pulse time.Duration, channel string, eventID uint32, eventTime uint32) {\n\t\tif channel == d.Channel {\n\t\t\tif eventID == d.EventID {\n\t\t\t\td.EventTime = eventTime\n\t\t\t\td.Duration = pulse\n\t\t\t\td.Start = time.Now()\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.54324579424651}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error\td.distanceMutex.Lock()\n\tdefer d.distanceMutex.Unlock()\n\n\terr := d.triggerSensor()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase <-d.distanceComplete:\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn errors.New(\"timeout\")\n\t}\n}\n", "CodeBleu_score": 40.87593805456658}, {"code": "func (d *HCSR04Driver) measureDistance() error\t// Lock the measurement mutex to ensure exclusive access\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.hcsr04.Trigger()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.hcsr04.Ready():\n\tcase <-time.After(d.timeout):\n\t\treturn errors.New(\"timeout while waiting for the measurement to complete\")\n\t}\n\n\t// Get the measurement\n\td.distance = d.hcsr04.Microseconds()\n\treturn nil\n}\n", "CodeBleu_score": 51.5835907831939}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.distanceMutex.Lock()\n\tdefer d.distanceMutex.Unlock()\n\terr := d.hcsr04.TriggerMeasurement()\n\tif err!= nil {\n\t\treturn err\n\t}\n\terr = d.hcsr04.WaitForMeasurement()\n\tif err!= nil {\n\t\treturn err\n\t}\n\td.distance = d.hcsr04.GetMeasurementTime()\n\treturn nil\n}\n", "CodeBleu_score": 46.21339427842204}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n    if self.access_token is None:\n      if self.refresh_token is None:\n        raise AccountNotAuthorized(\"The application is not authorized. Please authorize the application using the 'authorize' method.\")\n      else:\n        self.access_token = self.fetch_access_token(self.refresh_token)\n        self.access_token_expiration_time = datetime.now() + timedelta(seconds=self.access_token_expires_in)\n        return self.access_token\n    elif self.access_token_expiration_time < datetime.now():\n      if self.refresh_token is None:\n        raise AccountNotAuthorized(\"The application is not authorized. Please authorize the application using the 'authorize' method.\")\n      else:\n        self.access_token = self.fetch_access_token(self.refresh_token)\n        self.access_token_expiration_time = datetime.now() + timedelta(seconds=self.access_token_expires_in)\n        return self.access_token\n    else:\n      return self.access_token\n\n  def fetch_access_token(self, refresh_token):\n    \"\"\"The function \"fetch_access_token\" retrieves an access token using the refresh token.\\nIt first checks if the refresh token is available in the environment variables.\\nIf not, it checks the local state for a valid refresh token and its expiration time.\\nIf the refresh token is expired but a client ID and secret are available, it attempts to fetch a new refresh token using the client ID and secret.\\nIf successful, it updates the local state with the new authentication data and returns the new access token.\\nIf all methods fail, it raises an \"AccountNotAuthorized\" exception.\"\"\"\n    if self.client_id is None or self.client_secret is None:\n      raise AccountNotAuthorized(\"The application is not authorized. Please authorize the application using the 'authorize' method.\")\n    elif self.refresh_token is None:\n      raise AccountNotAuthorized(\"The application is not authorized. Please authorize the application using the 'authorize' method.\")\n    elif self.refresh_token_expiration_time < datetime.now():\n      if self.client_id is None or self.client_secret is None:\n        raise AccountNotAuthorized(\"The application is not authorized. Please authorize the application using the 'authorize' method.\")\n      else:\n        self.refresh_token = self.fetch_refresh_token(self.client", "CodeBleu_score": 32.162645834844525}, {"code": "def fetch_authentication_token(self)\n    # Check if the access token is available in the environment variables.\n    if \"access_token\" in os.environ and \"access_token_expires\" in os.environ:\n        access_token = os.environ[\"access_token\"]\n        access_token_expires = os.environ[\"access_token_expires\"]\n    # If not, check the local state for a valid access token and its expiration time.\n    else:\n        if \"access_token\" in self.state:\n            access_token = self.state[\"access_token\"]\n            access_token_expires = self.state[\"access_token_expires\"]\n        else:\n            access_token = None\n            access_token_expires = None\n    # If the access token is expired but a refresh token is available, attempt to fetch a new access token using the refresh token.\n    if access_token_expires is not None and datetime.datetime.now() > datetime.datetime.fromtimestamp(float(access_token_expires)):\n        if \"refresh_token\" in self.state:\n            refresh_token = self.state[\"refresh_token\"]\n            try:\n                access_token, access_token_expires = self._fetch_access_token_with_refresh_token(refresh_token)\n                self.state[\"access_token\"] = access_token\n                self.state[\"access_token_expires\"] = access_token_expires\n                self.save_state()\n            except Exception as e:\n                raise AccountNotAuthorized(e)\n        else:\n            raise AccountNotAuthorized(\"No refresh token available\")\n    # If all methods fail, raise an \"AccountNotAuthorized\" exception.\n    else:\n        raise AccountNotAuthorized(\"No access token available\")\n    # Return the access token.\n    return access_token\n", "CodeBleu_score": 33.186344692997324}, {"code": "def fetch_authentication_token(self)\n    if 'AUTH_TOKEN' in os.environ:\n      return os.environ['AUTH_TOKEN']\n    else:\n      if 'access_token' in self.state:\n        if 'expires_at' in self.state:\n          if self.state['expires_at'] > time.time():\n            return self.state['access_token']\n          elif'refresh_token' in self.state:\n            return self.fetch_access_token_with_refresh_token()\n          else:\n            raise AccountNotAuthorized(\"The access token is expired and no refresh token is available.\")\n        else:\n          raise AccountNotAuthorized(\"The access token is expired but no expiration time is available.\")\n      else:\n        raise AccountNotAuthorized(\"No access token is available.\")\n\n  def fetch_access_token_with_refresh_token(self):\n    \"\"\"The function \"fetch_access_token_with_refresh_token\" uses the refresh token to obtain a new access token.\\nIf successful, it updates the local state with the new authentication data and returns the new access token.\\nIf the refresh token is invalid or expired, it raises an \"AccountNotAuthorized\" exception.\"\"\"\n    if'refresh_token' in self.state:\n      if'refresh_token_expires_at' in self.state:\n        if self.state['refresh_token_expires_at'] > time.time():\n          payload = {\n            'grant_type':'refresh_token',\n            'client_id': self.client_id,\n            'client_secret': self.client_secret,\n           'refresh_token': self.state['refresh_token']\n          }\n          headers = {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          }\n          response = requests.post(self.token_url, data=payload, headers=headers)\n          if response.status_code == 200:\n            response_json = response.json()\n            self.state['access_token'] = response_json['access_token']\n            self.state['expires_at'] = time.time() + response_json['expires_in']\n            if'refresh_token' in response_json:\n              self.state['refresh_token'] = response_json['refresh_token']\n              self.state['refresh_token_expires_at'] = time.time() + response_json['refresh_token_expires_", "CodeBleu_score": 38.5103531497619}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n    try:\n      refresh_token = self.session.get(\"refresh_token\")\n      if refresh_token is not None:\n        self.session.delete()\n        self.session.post(\"/v1/logout\", json={\"refresh_token\": refresh_token})\n        return True\n      else:\n        return False\n    except AccountError:\n      return False\n\n  def get_session(self):\n    \"\"\"The function \"get_session\" returns the local session.\"\"\"\n    return self.session\n\n  def set_session(self, session):\n    \"\"\"The function \"set_session\" sets the local session.\"\"\"\n    self.session = session\n\n  def get_access_token(self):\n    \"\"\"The function \"get_access_token\" returns the access token.\"\"\"\n    return self.session.get(\"access_token\")\n\n  def set_access_token(self, access_token):\n    \"\"\"The function \"set_access_token\" sets the access token.\"\"\"\n    self.session.set(\"access_token\", access_token)\n\n  def get_refresh_token(self):\n    \"\"\"The function \"get_refresh_token\" returns the refresh token.\"\"\"\n    return self.session.get(\"refresh_token\")\n\n  def set_refresh_token(self, refresh_token):\n    \"\"\"The function \"set_refresh_token\" sets the refresh token.\"\"\"\n    self.session.set(\"refresh_token\", refresh_token)\n\n  def get_account_id(self):\n    \"\"\"The function \"get_account_id\" returns the account ID.\"\"\"\n    return self.session.get(\"account_id\")\n\n  def set_account_id(self, account_id):\n    \"\"\"The function \"set_account_id\" sets the account ID.\"\"\"\n    self.session.set(\"account_id\", account_id)\n\n  def get_account_type(self):\n    \"\"\"The function \"get_account_type\" returns the account type.\"\"\"\n    return self.session.get(\"account_type\")\n\n  def set_account_type(self, account_type):\n    \"\"\"The function \"set_account_type\" sets the account type.\"\"\"\n    self.session.set(\"account_type\", account_type)\n\n  def get_account_status(self):\n    \"\"\"The function \"get_account_status\" returns the account status.\"\"\"\n    return self.session.get(\"account_status\")\n\n  def set_account_status(self, account_", "CodeBleu_score": 39.76363284112108}, {"code": "def logout(self)\n    refresh_token = self.get_refresh_token()\n    self.delete_session()\n    try:\n      r = requests.post(self.base_url + \"/v1/logout\", data={\"refresh_token\": refresh_token})\n      if r.status_code!= 200:\n        raise AccountError(\"An error occurred while attempting to log out. Please try again later.\")\n    except:\n      pass\n    return True\n\n  def get_refresh_token(self):\n    \"\"\"The function \"get_refresh_token\" returns the refresh token associated with the current session. If the session does not exist, it returns \"None\".\"\"\"\n    if self.session_exists():\n      return self.session[\"refresh_token\"]\n    else:\n      return None\n\n  def get_access_token(self):\n    \"\"\"The function \"get_access_token\" returns the access token associated with the current session. If the session does not exist, it returns \"None\".\"\"\"\n    if self.session_exists():\n      return self.session[\"access_token\"]\n    else:\n      return None\n\n  def get_session_id(self):\n    \"\"\"The function \"get_session_id\" returns the session ID associated with the current session. If the session does not exist, it returns \"None\".\"\"\"\n    if self.session_exists():\n      return self.session[\"session_id\"]\n    else:\n      return None\n\n  def get_user_id(self):\n    \"\"\"The function \"get_user_id\" returns the user ID associated with the current session. If the session does not exist, it returns \"None\".\"\"\"\n    if self.session_exists():\n      return self.session[\"user_id\"]\n    else:\n      return None\n\n  def get_user_name(self):\n    \"\"\"The function \"get_user_name\" returns the user name associated with the current session. If the session does not exist, it returns \"None\".\"\"\"\n    if self.session_exists():\n      return self.session[\"user_name\"]\n    else:\n      return None\n\n  def get_user_email(self):\n    \"\"\"The function \"get_user_email\" returns the user email associated with the current session. If the session does not exist, it returns \"None\".\"\"\"\n    if self.session_exists():\n      return self.session[\"user_email\"]\n    else:\n      return None\n\n  def get_user_phone(self):\n    \"\"\"", "CodeBleu_score": 41.2266022455967}, {"code": "def logout(self)\n    refresh_token = self.get_refresh_token()\n    if refresh_token is not None:\n      self.delete_local_session()\n      try:\n        self.post(\"/v1/logout\", {\n          \"refresh_token\": refresh_token\n        })\n      except AccountError:\n        pass\n    return True\n\n  def get_refresh_token(self):\n    \"\"\"The function \"get_refresh_token\" returns the refresh token for the user. If the refresh token is not found, the function returns \"None\".\"\"\"\n    return self.get_local_session().get(\"refresh_token\")\n\n  def get_local_session(self):\n    \"\"\"The function \"get_local_session\" returns the local session for the user. If the local session is not found, the function returns \"None\".\"\"\"\n    if self.local_session is None:\n      try:\n        with open(self.local_session_path, \"r\") as f:\n          self.local_session = json.load(f)\n      except:\n        self.local_session = {}\n    return self.local_session\n\n  def delete_local_session(self):\n    \"\"\"The function \"delete_local_session\" deletes the local session for the user.\"\"\"\n    self.local_session = None\n    if os.path.exists(self.local_session_path):\n      os.remove(self.local_session_path)\n\n  def get_account_info(self):\n    \"\"\"The function \"get_account_info\" returns a dictionary containing the following information about the user's account:\\n\"username\": The user's username.\\n\"email\": The user's email address.\\n\"phone_number\": The user's phone number.\"\"\"\n    return self.get(\"/v1/account\")\n\n  def get_account_id(self):\n    \"\"\"The function \"get_account_id\" returns the user's account ID.\"\"\"\n    return self.get_account_info().get(\"id\")\n\n  def get_account_username(self):\n    \"\"\"The function \"get_account_username\" returns the user's username.\"\"\"\n    return self.get_account_info().get(\"username\")\n\n  def get_account_email(self):\n    \"\"\"The function \"get_account_email\" returns the user's email address.\"\"\"\n    return self.get_account_info().get(\"email\")\n\n  def get_account_phone_number(self):\n   ", "CodeBleu_score": 47.82473763817464}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n      if not package.optional:\n        package_info = {}\n        package_info['name'] = package.name\n        package_info['version'] = package.version\n        if package.external:\n          package_info['external'] = True\n          package_info['source_url'] = package.source_url\n        packages.append(package_info)\n    return packages\n\n  def dump_used_packages_to_file(self, filename):\n    \"\"\"The function \"dump_used_packages_to_file\" writes the list of non-optional packages with their names and versions to a file.\\nIt iterates through the packages, skips optional ones, and collects metadata for the others.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it writes the list of packages with their respective information to the file.\"\"\"\n    packages = self.dump_used_packages()\n    with open(filename, 'w') as outfile:\n      json.dump(packages, outfile, indent=2)\n\n  def dump_all_packages(self):\n    \"\"\"The function \"dump_all_packages\" returns a list of all packages with their names and versions.\\nIt iterates through the packages, collects metadata for each one, and returns the list of packages with their respective information.\"\"\"\n    packages = []\n    for package in self.packages:\n      package_info = {}\n      package_info['name'] = package.name\n      package_info['version'] = package.version\n      if package.external:\n        package_info['external'] = True\n        package_info['source_url'] = package.source_url\n      packages.append(package_info)\n    return packages\n\n  def dump_all_packages_to_file(self, filename):\n    \"\"\"The function \"dump_all_packages_to_file\" writes the list of all packages with their names and versions to a file.\\nIt iterates through the packages, collects metadata for each one, and writes the list of packages with their respective information to the file.\"\"\"\n    packages = self.dump_all_packages()\n    with open(filename, 'w') as outfile:\n      json.dump(packages, outfile, indent=2)\n", "CodeBleu_score": 26.35064728457558}, {"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n      if package.is_optional:\n        continue\n      if package.is_external:\n        packages.append(f\"{package.name}@{package.version} (external: {package.source})\")\n      else:\n        packages.append(f\"{package.name}@{package.version}\")\n    return packages\n", "CodeBleu_score": 17.772349873874617}, {"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n      if not package.optional:\n        package_metadata = self.get_package_metadata(package)\n        if package_metadata.external:\n          package_metadata.source = package.url\n        packages.append(package_metadata)\n    return packages\n\n  def dump_unused_packages(self):\n    \"\"\"The function \"dump_unused_packages\" returns a list of optional packages with their names and versions.\\nIt iterates through the packages, skips non-optional ones, and collects metadata for the others.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.\"\"\"\n    packages = []\n    for package in self.packages:\n      if package.optional:\n        package_metadata = self.get_package_metadata(package)\n        if package_metadata.external:\n          package_metadata.source = package.url\n        packages.append(package_metadata)\n    return packages\n\n  def dump_all_packages(self):\n    \"\"\"The function \"dump_all_packages\" returns a list of all packages with their names and versions.\\nIt iterates through the packages and collects metadata for each of them.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.\"\"\"\n    packages = []\n    for package in self.packages:\n      package_metadata = self.get_package_metadata(package)\n      if package_metadata.external:\n        package_metadata.source = package.url\n      packages.append(package_metadata)\n    return packages\n\n  def dump_package_metadata(self, package):\n    \"\"\"The function \"dump_package_metadata\" returns a dictionary with metadata for the specified package.\\nIt iterates through the packages, skips non-matching ones, and collects metadata for the matching one.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the package's metadata as a dictionary.\"\"\"\n    for p in self.packages:\n      if p.name == package:\n        package_metadata = self.get_package_metadata(p)\n        if package_metadata.external:\n          package_metadata.source = p.url\n        return package_metadata\n    return None\n\n  def dump_package_dependencies(", "CodeBleu_score": 21.097972730151007}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    env_platform = env_platforms.get(env)\n    if env_platform is None:\n        raise UndefinedEnvPlatformError(f\"The environment platform is not defined for the environment {env}.\")\n    return cls(env_platform, autoinstall=autoinstall).set_env(env, targets)\n\n", "CodeBleu_score": 23.577581040855414}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if not targets:\n        targets = []\n    platform = env_platform(env)\n    if not platform:\n        raise UndefinedEnvPlatformError(env)\n    return cls(platform, autoinstall=autoinstall).set_env(env, targets)\n\n", "CodeBleu_score": 29.171866174815197}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if not targets:\n        targets = []\n    if not env:\n        raise UndefinedEnvPlatformError(\n            \"The environment name is not defined in the project configuration file.\"\n        )\n    platform = cls.get_platform(env)\n    if not platform:\n        raise UndefinedEnvPlatformError(\n            \"The environment platform is not defined in the project configuration file.\"\n        )\n    return cls(platform, autoinstall=autoinstall).set_env(env, targets)\n\n", "CodeBleu_score": 30.46539719979601}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tWire.beginTransmission(AXP192_SLAVE_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_SLAVE_ADDRESS, Size);\n\tuint8_t i = 0;\n\twhile (Wire.available()) {\n\t\tBuff[i++] = Wire.read();\n\t}\n}\n", "CodeBleu_score": 48.1360374117994}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tuint8_t i = 0;\n\twhile (Wire.available()) {\n\t\tBuff[i++] = Wire.read();\n\t}\n}\n", "CodeBleu_score": 51.252370822019444}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tuint8_t i = 0;\n\twhile (Wire.available()) {\n\t\tBuff[i] = Wire.read();\n\t\ti++;\n\t}\n}\n", "CodeBleu_score": 52.91347192965409}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us)\tSetSleep();\n\tif (time_in_us > 0) {\n\t\taxp192_set_timer(axp192, time_in_us);\n\t\taxp192_enable_timer(axp192, 1);\n\t} else {\n\t\taxp192_enable_timer(axp192, 0);\n\t}\n\taxp192_enable_exten(axp192, 0);\n\taxp192_enable_adc(axp192, 0);\n\taxp192_enable_power(axp192, 0);\n\taxp192_deep_sleep(axp192);\n}\n", "CodeBleu_score": 48.19332581889159}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)\tSetSleep(true);\n\tif (time_in_us > 0) {\n\t\taxp192_set_timer_sleep(time_in_us);\n\t} else {\n\t\taxp192_set_timer_sleep(0);\n\t}\n\taxp192_deep_sleep();\n}\n", "CodeBleu_score": 46.711022852390805}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)\tSetSleep(true);\n\tif (time_in_us > 0) {\n\t\t_axp192->WriteReg(AXP192_TIMER_CTL, AXP192_TIMER_START | AXP192_TIMER_MODE_SLEEP | AXP192_TIMER_WAKE_ENABLE | AXP192_TIMER_TIME_LONG(time_in_us));\n\t} else {\n\t\t_axp192->WriteReg(AXP192_TIMER_CTL, 0);\n\t}\n\t_axp192->WriteReg(AXP192_OFF_CTL, AXP192_OFF_OFF_DCDC2 | AXP192_OFF_OFF_DCDC3 | AXP192_OFF_OFF_LDO2 | AXP192_OFF_OFF_LDO3 | AXP192_OFF_OFF_DCDC1 | AXP192_OFF_OFF_LDO1);\n\t_axp192->WriteReg(AXP192_OFF_CTL, AXP192_OFF_OFF_EXTEN | AXP192_OFF_OFF_SLP_SHUTDOWN | AXP192_OFF_OFF_SHUTDOWN);\n}\n", "CodeBleu_score": 36.02443337732186}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)\t// Save the current y-coordinate.\n\tint y = this->y;\n\t// Fill the new line with the specified color.\n\tthis->fill_rectangle(0, y, this->width, this->line_height, color);\n\t// Increment the y-coordinate by the height of a text line.\n\ty += this->line_height;\n\t// If the y-coordinate exceeds the display boundaries minus the bottom fixed area, wrap around.\n\tif (y > this->height - this->fixed_bottom_height) {\n\t\ty = this->fixed_top_height;\n\t}\n\t// Update the scroll address.\n\tthis->scroll_address = y;\n\t// Return the previous y-coordinate.\n\treturn y;\n}\n", "CodeBleu_score": 7.237277829592897}, {"code": "int Display::scroll_line(uint32_t color)\tint32_t y = scroll_address_y;\n\tscroll_address_y = (scroll_address_y + text_line_height) & 0x3ff;\n\tif (scroll_address_y == 0) scroll_address_y = text_line_height;\n\tif (y < tteBar) {\n\t\tif (y + text_line_height > tteBar) {\n\t\t\ttft.fillRect(0, tteBar, tft.width(), y + text_line_height - tteBar, color);\n\t\t} else {\n\t\t\ttft.fillRect(0, y, tft.width(), text_line_height, color);\n\t\t}\n\t} else {\n\t\tif (y < tft.height() - tteBar) {\n\t\t\ttft.fillRect(0, y, tft.width(), text_line_height, color);\n\t\t} else {\n\t\t\ttft.fillRect(0, tft.height() - text_line_height, tft.width(), text_line_height, color);\n\t\t}\n\t}\n\treturn y;\n}\n", "CodeBleu_score": 25.24113130004405}, {"code": "int Display::scroll_line(uint32_t color)\t// Save the current y-coordinate\n\tint y_save = y;\n\t// Scroll the display\n\tscroll(1);\n\t// Fill the new line with the specified color\n\tfillRect(0, y, tteWidth, tteHeight, color);\n\t// Increment the y-coordinate by the height of a text line\n\ty += tteHeight;\n\t// Wrap around if the y-coordinate exceeds the display boundaries minus the bottom fixed area\n\tif (y > (tteHeight - tteBar)) {\n\t\ty = 0;\n\t}\n\t// If the top fixed area is active, use alternative top fixed area coordinates\n\tif (tteBar) {\n\t\ty += tteBar;\n\t}\n\t// Update the scroll address\n\tupdateScroll();\n\t// Return the previous y-coordinate\n\treturn y_save;\n}\n", "CodeBleu_score": 18.91614022132082}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\tif (!setAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\tif (!setSSIDs(ssids)) {\n\t\treturn false;\n\t}\n\tif (!setupContent()) {\n\t\treturn false;\n\t}\n\tif (!startPortal()) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 52.41142747726231}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\t// Initialize the access points\n\tif (!initAccessPoints(ssids, access_points)) {\n\t\treturn false;\n\t}\n\t// Initialize the HTML content\n\tif (!initHTML()) {\n\t\treturn false;\n\t}\n\t// Start the portal\n\tstartPortal();\n\treturn true;\n}\n", "CodeBleu_score": 61.754916944221264}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\tif (!setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\tif (!setupHTML(ssids)) {\n\t\treturn false;\n\t}\n\tstartPortal();\n\treturn true;\n}\n", "CodeBleu_score": 60.88876536726522}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue()\tif (!queue_enabled_flag) {\n\t\tqueue_enabled_flag = true;\n\t\tflush_queue();\n\t\ttext = new char[TEXT_SIZE];\n\t\ttext_in = new char[TEXT_SIZE];\n\t}\n}\n", "CodeBleu_score": 6.76118598076938}, {"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\t// Queue is already enabled, so initialize the text and text_in variables.\n\t\tif (text_in == NULL) {\n\t\t\ttext_in = new char[text_size];\n\t\t}\n\t\tif (text == NULL) {\n\t\t\ttext = new char[text_size];\n\t\t}\n\t} else {\n\t\t// Queue is not enabled, so flush the existing queue and set the queue_enabled_flag to true.\n\t\tflush_queue();\n\t\tqueue_enabled_flag = true;\n\t}\n}\n", "CodeBleu_score": 11.120702609534689}, {"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\tif (text_in.size() == 0) {\n\t\t\ttext_in = text;\n\t\t\ttext.clear();\n\t\t}\n\t} else {\n\t\tflush_queue();\n\t\tqueue_enabled_flag = true;\n\t}\n}\n", "CodeBleu_score": 9.559470965321307}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea()\tif (nmea_queue!= NULL) {\n\t\tdelete nmea_queue;\n\t\tnmea_queue = new Queue<String>(100);\n\t}\n\telse {\n\t\tnmea_queue = new Queue<String>(100);\n\t}\n}\n", "CodeBleu_score": 38.285034788766886}, {"code": "void GpsInterface::flush_queue_nmea()\tif (nmea_queue!= NULL) {\n\t\tdelete nmea_queue;\n\t\tnmea_queue = NULL;\n\t}\n\tnmea_queue = new Queue<char*>(10);\n}\n", "CodeBleu_score": 34.05658903841168}, {"code": "void GpsInterface::flush_queue_nmea()\tif (queue_nmea_!= NULL) {\n\t\tdelete queue_nmea_;\n\t\tqueue_nmea_ = NULL;\n\t}\n\tqueue_nmea_ = new QueueNmea();\n}\n", "CodeBleu_score": 33.684241935851425}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) *   uint32_t w = (area->x2 - area->x1 + 1);\n *   uint32_t h = (area->y2 - area->y1 + 1);\n *   uint32_t x = area->x1;\n *   uint32_t y = area->y1;\n *   uint32_t size = w * h;\n *   uint32_t bytes = size * sizeof(lv_color_t);\n *\n *   // In the case of monochrome displays, LVGL handles the bytes parameter\n *   // automatically. However, for color displays, it needs to be set manually.\n *   // In this case, the size of each color is LV_COLOR_SIZE / 8.\n *   // For example: For LV_COLOR_SIZE = 16, the size of each color is 2 bytes.\n *   // In this case, the bytes parameter should be set to 2 * size.\n *   // In LVGL, the color data is sent in 32-bit words.\n *   // If the size of each color is 2 bytes, then 32-bit word = 4 bytes.\n *   // So, the bytes parameter should be set to 4 * size.\n *   // If the size of each color is 4 bytes, then 32-bit word = 4 bytes.\n *   // So, the bytes parameter should be set to size.\n *   // In the case of color displays, the bytes parameter must be set manually.\n *   disp_spi_send_colors(color_p, bytes);\n *\n *   disp_spi_send_colors(0, 0); // The last parameter must be 0\n *\n *   // IMPORTANT!\n *   // Inform the graphics library that you are ready with the flushing\n *   // If you don't call lv_disp_flush_ready(), the library won't know\n *   // that you are ready and won't refresh the screen.\n *   lv_disp_flush_ready(disp);\n * }\n *\n *\n * @param color_p A pointer to an array of colors.\n * @param size    The size of the color array in bytes.\n */", "CodeBleu_score": 36.49055972623824}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n", "CodeBleu_score": 3.2297475512290195}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)#if LV_USE_GPU\n    if (lv_disp_get_gpu_enabled(disp)) {\n        /* Use the GPU to draw the screen */\n        lv_disp_flush_ready(disp);\n        return;\n    }", "CodeBleu_score": 6.8631775362840335}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tfor (int i = 0; i < menu->getNumberOfItems(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \"\\t\";\n\t\t}\n\t\tcout << menu->getItem(i)->getName() << endl;\n\t}\n\tcout << endl;\n}\n", "CodeBleu_score": 47.21701840638077}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tfor (int i = 0; i < menu->getSize(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tstd::cout << \"  \";\n\t\t}\n\t\tstd::cout << menu->getNode(i).getName() << std::endl;\n\t}\n\tstd::cout << std::endl;\n}\n", "CodeBleu_score": 49.10467591181957}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tif (menu == NULL) {\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < menu->size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tstd::cout << \"\\t\";\n\t\t}\n\n\t\tstd::cout << menu->get(i).getName() << std::endl;\n\t}\n\n\tstd::cout << std::endl;\n}\n", "CodeBleu_score": 48.73733551734969}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count)\tint i;\n\tchar randomSSID[6];\n\tint randomChannel;\n\tchar randomMAC[6];\n\tfor(i = 0; i < count; i++) {\n\t\t//Generate random SSID\n\t\trandomSSID[0] = (rand() % 26) + 97;\n\t\trandomSSID[1] = (rand() % 26) + 97;\n\t\trandomSSID[2] = (rand() % 26) + 97;\n\t\trandomSSID[3] = (rand() % 26) + 97;\n\t\trandomSSID[4] = (rand() % 26) + 97;\n\t\trandomSSID[5] = 0;\n\t\t//Generate random channel\n\t\trandomChannel = (rand() % 10) + 1;\n\t\t//Generate random MAC address\n\t\trandomMAC[0] = (rand() % 256);\n\t\trandomMAC[1] = (rand() % 256);\n\t\trandomMAC[2] = (rand() % 256);\n\t\trandomMAC[3] = (rand() % 256);\n\t\trandomMAC[4] = (rand() % 256);\n\t\trandomMAC[5] = 0;\n\t\t//Add SSID to list\n\t\taddSSID(randomSSID, randomChannel, randomMAC);\n\t\t//Print SSID to serial output\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.print(randomSSID);\n\t\tSerial.print(\", Channel: \");\n\t\tSerial.print(randomChannel);\n\t\tSerial.print(\", MAC: \");\n\t\tSerial.println(randomMAC);\n\t}\n\treturn i;\n}\n", "CodeBleu_score": 35.17836807310566}, {"code": "int WiFiScan::generateSSIDs(int count)\tint i = 0;\n\twhile (i < count) {\n\t\t// Generate a random SSID\n\t\tchar ssid[7];\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid[j] = random(0x61, 0x7A);\n\t\t}\n\t\tssid[6] = 0;\n\n\t\t// Generate a random channel\n\t\tint channel = random(1, 14);\n\n\t\t// Generate a random MAC address\n\t\tbyte mac[6];\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac[j] = random(0, 256);\n\t\t}\n\n\t\t// Add the SSID to the list\n\t\taddSSID(ssid, channel, mac);\n\n\t\t// Print the SSID to the serial output\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.println(ssid);\n\n\t\ti++;\n\t}\n\n\treturn i;\n}\n", "CodeBleu_score": 36.723247610430995}, {"code": "int WiFiScan::generateSSIDs(int count)\tint i = 0;\n\tfor (i = 0; i < count; i++) {\n\t\t// Generate random SSID\n\t\tchar ssid[7] = {0};\n\t\tint j = 0;\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tssid[j] = (char)('A' + (rand() % 26));\n\t\t}\n\t\t// Generate random channel\n\t\tint channel = (rand() % 14) + 1;\n\t\t// Generate random MAC address\n\t\tbyte mac[6] = {0};\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tmac[j] = (byte)(rand() % 256);\n\t\t}\n\t\t// Add SSID to list\n\t\taddSSID(ssid, channel, mac);\n\t\t// Print SSID to serial output\n\t\tSerial.print(ssid);\n\t\tSerial.print(\" - \");\n\t\tSerial.println(channel);\n\t}\n\treturn i;\n}\n", "CodeBleu_score": 39.397482066513604}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\n    # Initialize a Publisher client.\n    publisher = pubsub_v1.PublisherClient()\n\n    # Create a fully qualified identifier in the form of\n    # `projects/{project_id}/topics/{topic_name}`\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic.\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Created topic: {topic}\")\n\n", "CodeBleu_score": 47.30410687693764}, {"code": "def create_topic(project_id, topic_name)\n    # Initialize a Publisher client.\n    publisher = pubsub_v1.PublisherClient()\n    # Create a fully qualified identifier in the form of `projects/{project_id}/topics/{topic_name}`\n    topic_path = publisher.topic_path(project_id, topic_name)\n    # Create the topic.\n    topic = publisher.create_topic(topic_path)\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 47.407721850208304}, {"code": "def create_topic(project_id, topic_name)\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 47.407721850208304}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    token = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 72.75104479961406}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 56.64796094364441}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 56.64796094364441}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n    payload = message.payload.decode(\"utf-8\")\n    topic = message.topic\n    qos = message.qos\n    print(\"Received message '\" + str(payload) + \"' on topic '\" + str(topic) + \"' with QoS \" + str(qos))\n    if payload == \"on\":\n        capture_image()\n        upload_image()\n        publish_image()\n    else:\n        print(\"off\")\n", "CodeBleu_score": 24.073712744002396}, {"code": "def on_message(unused_client, unused_userdata, message)\n    payload = str(message.payload.decode(\"utf-8\"))\n    topic = message.topic\n    qos = str(message.qos)\n    print(\"Received message '\" + str(payload) + \"' on topic '\" + topic + \"' with QoS \" + qos)\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        image = capture_preview()\n        print(\"Uploading image to Google Cloud Storage bucket...\")\n        upload_image(image)\n        print(\"Publishing image URL to MQTT event topic...\")\n        publish_image_url()\n    else:\n        print(\"Turning off camera...\")\n        publish_off()\n", "CodeBleu_score": 28.179107525936708}, {"code": "def on_message(unused_client, unused_userdata, message)\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '\" + payload + \"' on topic '\"\n          + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        # Capture a preview image\n        camera.capture(os.path.join(os.path.dirname(__file__), 'images/image.jpg'))\n        # Upload the file to a specified bucket\n        s3.upload_file(os.path.join(os.path.dirname(__file__), 'images/image.jpg'), BUCKET_NAME, 'image.jpg')\n        # Publish the file's URL to an MQTT event topic\n        client.publish(TOPIC, s3.generate_presigned_url('get_object', Params={'Bucket': BUCKET_NAME, 'Key': 'image.jpg'}, ExpiresIn=300))\n    else:\n        print(\"off\")\n", "CodeBleu_score": 31.86453280260862}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name.\")\n    parser.add_argument(\n        \"--registry_id\",\n        required=True,\n        help=\"Cloud IoT Core registry id\")\n    parser.add_argument(\n        \"--device_id\",\n        required=True,\n        help=\"Cloud IoT Core device id\")\n    parser.add_argument(\n        \"--private_key_file\",\n        required=True,\n        help=\"Path to private key file.\")\n    parser.add_argument(\n        \"--algorithm\",\n        choices=enums.CryptoKeyVersionAlgorithm.__members__.values(),\n        default=enums.CryptoKeyVersionAlgorithm.RSA_PKCS1_2048_SHA256,\n        help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\n        \"--ca_certs\",\n        default=os.path.join(\n            os.path.dirname(__file__),\n            \"roots.pem\"),\n        help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\")\n    parser.add_argument(\n        \"--message_type\",\n        choices=[\"event\", \"state\"],\n        default=\"event\",\n        help=\"Type of message to publish.\")\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\")\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        choices=[8883, 443],\n        default=8883,\n        type=int,\n        help=\"MQTT bridge port.\")\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=20,\n        type=int,\n        help=\"Expiration time, in minutes, for JWT tokens.\")\n    parser.add_argument(\n        \"--mqtt_topic\",\n        default=\"/devices/{}/events\".format(\n            os.environ.get(\"GOOGLE_CLOUD_PROJECT\")),\n        help=\"MQTT", "CodeBleu_score": 42.01611754899049}, {"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT device connection example.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name.\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        required=True,\n        help=\"Cloud IoT Core registry id.\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        required=True,\n        help=\"Cloud IoT Core device id.\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        required=True,\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Type of message to publish. Either 'event' or'state'.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", default=8883, type=int, help=\"MQTT bridge port.\"\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=20,\n        type=int,\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n    )\n    parser.add_argument(\n        \"--mqtt_topic\", default=\"events\", help=\"MQTT topic name.\"\n    )\n    parser.add_argument(\n        \"--message_data\", default=\"Hello there!\", help=\"Message to publish.\"\n    )\n    parser.add_argument", "CodeBleu_score": 36.67028767945357}, {"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description='Example Google Cloud IoT MQTT device connection code.')\n    parser.add_argument('project_id', help='GCP cloud project name.')\n    parser.add_argument('subscription_name', help='Cloud Pub/Sub subscription name to listen for configuration messages.')\n    parser.add_argument('--registry_id', default=os.environ.get('GOOGLE_CLOUD_IOT_CORE_REGISTRY'), help='Cloud IoT Core registry id.')\n    parser.add_argument('--device_id', default=os.environ.get('GOOGLE_CLOUD_IOT_CORE_DEVICE_ID'), help='Cloud IoT Core device id.')\n    parser.add_argument('--private_key_file', default=os.environ.get('GOOGLE_CLOUD_IOT_CORE_PRIVATE_KEY_FILE'), help='Path to private key file.')\n    parser.add_argument('--algorithm', default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region.')\n    parser.add_argument('--ca_certs', default=os.environ.get('GOOGLE_CLOUD_IOT_CORE_CA_CERTS'), help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--num_messages', default=100, type=int, help='Number of messages to publish.')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--mqtt_topic', default='/devices/{}/{}'.format(os.environ.get('GOOGLE_CLOUD_IOT_CORE_DEVICE_ID'), 'events'), help='MQTT topic to publish device events.')\n    parser.add_argument('--message_type', default='event', help='Type of message to publish. Must be \"event\" or \"state\".')\n    parser.add_argument('--log_level', default='INFO', help='Logging level to use. Must be", "CodeBleu_score": 46.85734868933088}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n    # The following lines are modified from the original example:\n    # https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master/iot/api-client/mqtt_example/cloudiot_mqtt_example.py\n    # The original example is licensed under the Apache 2.0 License.\n    # https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master/LICENSE\n\n    # Define the required scopes for the Cloud IoT Core service\n    CLOUD_IOT_CORE_SCOPE = 'https://www.googleapis.com/auth/cloud-platform'\n    # The discovery URL for the Cloud IoT Core service\n    CLOUD_IOT_CORE_DISCOVERY_URL = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n\n    # Use the gcloud tool to get the project ID and location ID\n    project_id = subprocess.check_output(['gcloud', 'config', 'get-value', 'project']).strip()\n    cloud_region = subprocess.check_output(['gcloud', 'config', 'get-value', 'compute/region']).strip()\n\n    # Build and return the client for the Cloud IoT Core service\n    return googleapiclient.discovery.build(\n        'cloudiot', 'v1',\n        cache_discovery=False,\n        credentials=google.oauth2.service_account.Credentials.from_service_account_file(service_account_json),\n        discoveryServiceUrl=CLOUD_IOT_CORE_DISCOVERY_URL,\n        # The following lines are modified from the original example:\n        # https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master/iot/api-client/mqtt_example/cloudiot_mqtt_example.py\n        # The original example is licensed under the Apache 2.0 License.\n        # https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master/LICENSE\n        # The following line is modified from the original example:\n        # https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master/iot/api-client/mqtt_example/cloudiot_mqtt_example.py#L69\n        # The original example is licensed under the Apache 2.0 License.\n        # https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master", "CodeBleu_score": 30.785030989736306}, {"code": "def get_client(service_account_json)\n    # Create a Cloud IoT Core client for the given service account\n    # and the region of the given project.\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    return googleapiclient.discovery.build(\n        \"cloudiot\", \"v1\", credentials=google.oauth2.service_account.Credentials.from_service_account_file(service_account_json), discoveryServiceUrl=googleapiclient.discovery.V1_DISCOVERY_URI)\n\n", "CodeBleu_score": 22.727904249486862}, {"code": "def get_client(service_account_json)\n    # Create the Cloud IoT Core client\n    with open(service_account_json) as f:\n        private_key = f.read()\n    client = iot_v1.DeviceManagerClient()\n    return client\n", "CodeBleu_score": 8.28869099704687}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n    hash_method_asn1 = get_hash_method_asn1(hash_method)\n    if hash_method_asn1 == None:\n        raise ValueError(\"The hash method is invalid.\")\n    else:\n        hash_asn1 = hash_method_asn1 + hash_value\n        padded_hash = pad_for_signing(hash_asn1)\n        signature = priv_key.sign(padded_hash, padding.PSS(mgf=padding.MGF1(hash_method_asn1), salt_length=padding.PSS.MAX_LENGTH), hash_method_asn1)\n        return signature\n", "CodeBleu_score": 36.053191341441014}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    hash_method_asn1 = get_hash_method_asn1(hash_method)\n    if hash_method_asn1 is None:\n        raise Exception(\"Invalid hash method\")\n    signature = b\"\"\n    signature += hash_method_asn1\n    signature += hash_value\n    signature += b\"\\x00\" * (128 - len(hash_value) - len(hash_method_asn1))\n    signature = priv_key.sign(signature, hash_method)\n    return signature\n", "CodeBleu_score": 28.318380665341902}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    if hash_method not in HASH_METHODS:\n        raise ValueError(\"Invalid hash method specified.\")\n    hash_method_code = HASH_METHODS[hash_method]\n    hash_value_code = bytes([len(hash_value)]) + hash_value\n    signature_data = hash_method_code + hash_value_code\n    signature_data = pad_for_signing(signature_data)\n    signature = priv_key.sign(signature_data, ec.ECDSA(hashes.SHA256()))\n    return signature\n\n", "CodeBleu_score": 40.960223859428154}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n    if isinstance(pub_key, str):\n        pub_key = pub_key.encode()\n    if isinstance(message, str):\n        message = message.encode()\n    if isinstance(signature, str):\n        signature = signature.encode()\n    if isinstance(pub_key, bytes):\n        pub_key = RSA.importKey(pub_key)\n    if isinstance(message, bytes):\n        message = message.decode()\n    if isinstance(signature, bytes):\n        signature = signature.decode()\n    try:\n        signature = int(signature)\n    except ValueError:\n        raise ValueError(\"Signature must be an integer.\")\n    if signature < 0:\n        raise ValueError(\"Signature must be a positive integer.\")\n    if len(pub_key.exportKey()) > 1000:\n        raise ValueError(\"Key size too large.\")\n    if len(message) > 1000:\n        raise ValueError(\"Message size too large.\")\n    if pub_key.n < signature:\n        raise ValueError(\"Signature too large.\")\n    try:\n        signature = pow(signature, pub_key.e, pub_key.n)\n    except ValueError:\n        raise ValueError(\"Signature must be less than the modulus.\")\n    if signature == 0:\n        raise ValueError(\"Signature must not be zero.\")\n    if signature == 1:\n        raise ValueError(\"Signature must not be one.\")\n    try:\n        signature = RSA.importKey(signature)\n    except ValueError:\n        raise ValueError(\"Signature must be a valid RSA key.\")\n    if signature.n!= pub_key.n:\n        raise ValueError(\"Signature must be valid for the given modulus.\")\n    if signature.e!= pub_key.e:\n        raise ValueError(\"Signature must be valid for the given exponent.\")\n    if signature.d!= pub_key.d:\n        raise ValueError(\"Signature must be valid for the given private exponent.\")\n    if signature.p!= pub_key.p:\n        raise ValueError(\"Signature must be valid for the given first prime factor.\")\n    if signature.q!= pub_key.q:\n        raise ValueError(\"Signature must be valid for the given second prime factor.\")\n    if signature.u!= pub_key.u:\n        raise ValueError(\"Signature must be valid for the given CRT coefficient.\")\n    if signature.n < 2:\n        raise ValueError(\"Signature must be valid for a modulus greater than 1.\")\n    if signature.e < 2:\n        raise ValueError", "CodeBleu_score": 32.19855922838751}, {"code": "def verify(message, signature, pub_key)\n    clear_signature = decrypt(signature, pub_key)\n    hash_method = clear_signature[0]\n    if hash_method == 0:\n        hash_method = \"SHA-1\"\n    elif hash_method == 1:\n        hash_method = \"SHA-256\"\n    elif hash_method == 2:\n        hash_method = \"SHA-384\"\n    elif hash_method == 3:\n        hash_method = \"SHA-512\"\n    else:\n        raise VerificationError(\"The hash method is not supported.\")\n    hashed_message = hash_message(hash_method, message)\n    expected_padded_hash = clear_signature[1:]\n    if expected_padded_hash!= hashed_message:\n        raise VerificationError(\"The signature is invalid.\")\n    return hash_method\n\n", "CodeBleu_score": 25.648264041571565}, {"code": "def verify(message, signature, pub_key)\n    signature = int(signature)\n    decrypted_signature = rsa.decrypt(signature, pub_key)\n    hash_method = decrypted_signature[-1]\n    decrypted_signature = decrypted_signature[:-1]\n    if hash_method == 'H':\n        expected_hash = sha1(message)\n    elif hash_method == 'h':\n        expected_hash = sha256(message)\n    elif hash_method =='m':\n        expected_hash = md5(message)\n    else:\n        raise VerificationError('Invalid hash method')\n    if expected_hash!= decrypted_signature:\n        raise VerificationError('Invalid signature')\n    return hash_method\n", "CodeBleu_score": 24.09495560335187}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT()\t// Retrieve the current time and check if it is valid\n\ttime_t now = time(NULL);\n\tif (now == (time_t)-1) {\n\t\t// Failed to retrieve the current time\n\t\treturn;\n\t}\n\t// Update the JWT using the current UNIX time format\n\tupdateJWT(now);\n\t// Connect to the MQTT client\n\tif (mqtt_client.connect(mqtt_client_id, mqtt_username, mqtt_password, mqtt_topic, 0, 1, \"false\", 0)) {\n\t\t// Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n\t\tmqtt_subscribe_flag = true;\n\t\t// Print a debug message indicating the MQTT connection attempt\n\t\tprintf(\"INFO: MQTT connection attempt successful\\n\");\n\t} else {\n\t\t// Print a debug message indicating the MQTT connection attempt\n\t\tprintf(\"ERROR: MQTT connection attempt failed\\n\");\n\t}\n}\n", "CodeBleu_score": 40.70929056877054}, {"code": "static void connectMQTT()\t// Retrieve the current time.\n\tstruct tm timeinfo;\n\tif (!getLocalTime(&timeinfo)) {\n\t\t// The current time is not valid.\n\t\treturn;\n\t}\n\n\t// Update the JWT.\n\tupdateJWT(timeinfo.tm_year, timeinfo.tm_mon, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);\n\n\t// Connect to the MQTT client.\n\tif (!connectToClient()) {\n\t\t// The connection failed.\n\t\treturn;\n\t}\n\n\t// Set a flag to send an MQTT SUBSCRIBE packet after the connection is established.\n\tsendSubscribe = true;\n\n\t// Print a debug message.\n\tSerial.println(F(\"MQTT connection established\"));\n}\n", "CodeBleu_score": 42.83364770028207}, {"code": "static void connectMQTT()\t// Retrieve the current time and check if it is valid.\n\t// If it is valid, update the JWT using the current UNIX time format.\n\tif (getTime()) {\n\t\tupdateJWT();\n\t}\n\n\t// Connect to the MQTT client.\n\tif (connectToMQTTClient()) {\n\t\t// Set a flag to send an MQTT SUBSCRIBE packet after the connection is established.\n\t\tsendSub = true;\n\n\t\t// Print a debug message indicating the MQTT connection attempt.\n\t\tSerial.println(\"MQTT connection attempt successful.\");\n\t}\n}\n", "CodeBleu_score": 18.512615190007693}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t result = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t c = *str++;\n\t\tif (!isdigit(c)) {\n\t\t\treturn str - 1;\n\t\t}\n\t\tresult = result * 10 + c - '0';\n\t}\n\t*num = result;\n\treturn str;\n}\n", "CodeBleu_score": 18.20918721314328}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t value = 0;\n\twhile (width-- > 0) {\n\t\tuint8_t c = *str++;\n\t\tif (!isdigit(c)) {\n\t\t\treturn str - 1;\n\t\t}\n\t\tvalue = value * 10 + c - '0';\n\t\tif (value > UINT32_MAX) {\n\t\t\treturn str - 1;\n\t\t}\n\t}\n\t*num = value;\n\treturn str;\n}\n", "CodeBleu_score": 18.189164537947878}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\t*num = 0;\n\twhile (width > 0) {\n\t\tif (str[0] < '0' || str[0] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\t*num = (*num * 10) + (str[0] - '0');\n\t\tstr++;\n\t\twidth--;\n\t}\n\treturn str;\n}\n", "CodeBleu_score": 20.01941212928585}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\\treturn atcacert_date_dec_rfc5280_utc(build_state->cert_template + build_state->template_offset, &build_state->cert_template[build_state->cert_template_size - build_state->cert_template_max_size], &build_state->cert_template[build_state->cert_template_size - build_state->cert_template_max_size + build_state->cert_template_max_size - build_state->cert_template_min_size]);\n}\n", "CodeBleu_score": 13.387606769753061}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = 0;\n\tuint8_t* cert_ptr = NULL;\n\tuint8_t* cert_end = NULL;\n\tuint8_t* cert_start = NULL;\n\tuint8_t* tbs_start = NULL;\n\tuint8_t* tbs_end = NULL;\n\tuint8_t* tbs_ptr = NULL;\n\tuint8_t* tbs_ext_start = NULL;\n\tuint8_t* tbs_ext_end = NULL;\n\tuint8_t* tbs_ext_ptr = NULL;\n\tuint8_t* cert_ext_start = NULL;\n\tuint8_t* cert_ext_end = NULL;\n\tuint8_t* cert_ext_ptr = NULL;\n\tuint8_t* cert_ext_id = NULL;\n\tuint8_t* cert_ext_value = NULL;\n\tuint8_t* cert_ext_value_start = NULL;\n\tuint8_t* cert_ext_value_end = NULL;\n\tuint8_t* cert_ext_value_ptr = NULL;\n\tuint8_t* cert_ext_value_size = NULL;\n\tuint8_t* cert_ext_value_size_ptr = NULL;\n\tuint8_t cert_ext_value_size_len = 0;\n\tuint8_t cert_ext_value_size_len_max = 0;\n\tuint8_t cert_ext_value_size_len_min = 0;\n\tuint8_t cert_ext_value_size_len_min_max = 0;\n\tuint8_t cert_ext_value_size_len_min_max_max = 0;\n\tuint8_t cert_ext_value_size_len_min_max_max_max = 0;\n\tuint8_t cert_ext_value_size_len_max_max_max_max = 0;\n\tuint8_t cert_ext_value_size_len_min_max_max_max_max = 0;\n\tuint8_t cert_ext_value_size_len_min_max_max_", "CodeBleu_score": 9.696889801712139}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = 0;\n\tuint8_t* cert_ptr = NULL;\n\tsize_t cert_size = 0;\n\tuint8_t* cert_end = NULL;\n\tuint8_t* cert_start = NULL;\n\tuint32_t cert_sn_size = 0;\n\tuint32_t cert_sn_offset = 0;\n\tuint32_t cert_sn_bytes = 0;\n\tuint32_t cert_sn_start = 0;\n\tuint32_t cert_sn_end = 0;\n\tuint32_t cert_sn = 0;\n\tuint32_t cert_issue_date_size = 0;\n\tuint32_t cert_issue_date_offset = 0;\n\tuint32_t cert_issue_date_bytes = 0;\n\tuint32_t cert_issue_date_start = 0;\n\tuint32_t cert_issue_date_end = 0;\n\tuint32_t cert_expire_date_size = 0;\n\tuint32_t cert_expire_date_offset = 0;\n\tuint32_t cert_expire_date_bytes = 0;\n\tuint32_t cert_expire_date_start = 0;\n\tuint32_t cert_expire_date_end = 0;\n\tuint32_t cert_expire_years = 0;\n\tuint32_t cert_expire_days = 0;\n\tuint32_t cert_expire_seconds = 0;\n\tuint32_t cert_expire_seconds_start = 0;\n\tuint32_t cert_expire_seconds_end = 0;\n\tuint32_t cert_expire_seconds_leap_adjust = 0;\n\tuint32_t cert_expire_seconds_leap_adjust_start = 0;\n\tuint32_t cert_expire_seconds_leap_adjust_end = 0;\n\tuint32_t cert_expire_seconds_leap_adjust_days = 0;\n\tuint32_", "CodeBleu_score": 13.261191355964993}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])#if defined(ATECC608A)\n    uint8_t digest[32];\n    uint8_t signature[64];\n    uint8_t public_key[64];\n    uint8_t verify_response[64];\n\n    if (!cert_def) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (!cert) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (!ca_public_key) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Retrieve the digest of the certificate's to-be-signed (TBS) portion.\n    if (atcacert_get_tbs_digest(cert_def, cert, cert_size, digest)!= ATCACERT_E_SUCCESS) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Retrieve the certificate's signature.\n    if (atcacert_get_signature(cert_def, cert, cert_size, signature)!= ATCACERT_E_SUCCESS) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Retrieve the public key from the certificate.\n    if (atcacert_get_subj_public_key(cert_def, cert, cert_size, public_key)!= ATCACERT_E_SUCCESS) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Verify the TBS digest against the signature using the CA public key.\n    if (atcab_verify_extern_stored_mac(digest, signature, public_key, verify_response)!= ATCA_SUCCESS) {\n        return ATCACERT_E_VERIFY_FAILED;\n    }\n\n    // Check the verify response to see if the signature verified correctly.\n    if (atcab_is_verified(verify_response)!= 1) {\n        return ATCACERT_E_VERIFY_FAILED;\n    }\n\n    return ATCACERT_E_SUCCESS;", "CodeBleu_score": 42.647459345940284}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])#ifdef ATCA_HAL_I2C\n    if (atcab_init(g_atca_i2c_default_cfg)!= ATCA_SUCCESS) {\n        return ATCACERT_E_BAD_PARAMS;\n    }", "CodeBleu_score": 14.716195766438373}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])\"\"\"\n", "CodeBleu_score": 5.384615384615385}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{bool found = false;", "CodeBleu_score": 5.345808773355879}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\tbool ret = false;\n\ttimerStruct_t *current;\n\ttimerStruct_t *previous;\n\ttimerStruct_t *tmp;\n\tcurrent = *list;\n\tprevious = NULL;\n\twhile (current!= NULL) {\n\t\tif (current == timer) {\n\t\t\tif (previous == NULL) {\n\t\t\t\t*list = current->next;\n\t\t\t} else {\n\t\t\t\tprevious->next = current->next;\n\t\t\t}\n\t\t\tfree(current);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 39.994158414703016}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\tif (list == NULL) {\n\t\treturn false;\n\t}\n\tif (timer == NULL) {\n\t\treturn false;\n\t}\n\tif (*list == NULL) {\n\t\treturn false;\n\t}\n\tif (timer!= *list) {\n\t\treturn false;\n\t}\n\tif (timer->next == NULL) {\n\t\treturn false;\n\t}\n\tif (timer->prev == NULL) {\n\t\treturn false;\n\t}\n\tif (timer->next->prev!= timer) {\n\t\treturn false;\n\t}\n\tif (timer->prev->next!= timer) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n}\n", "CodeBleu_score": 26.87356312605371}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket)\tint status;\n\tstruct socket_info *socket_info;\n\n\t/*\n\t * Check if the given socket is valid.\n\t */\n\tif (socket < 0 || socket >= MAX_NUM_SOCKETS) {\n\t\treturn BSD_INVALID_SOCKET;\n\t}\n\n\t/*\n\t * Retrieve the socket information.\n\t */\n\tsocket_info = get_socket_info(socket);\n\n\t/*\n\t * Check if the socket is valid.\n\t */\n\tif (socket_info == NULL || socket_info->state == NOT_A_SOCKET) {\n\t\treturn BSD_INVALID_SOCKET;\n\t}\n\n\t/*\n\t * Close the socket.\n\t */\n\tstatus = close(socket);\n\n\t/*\n\t * Check if an error occurred.\n\t */\n\tif (status < 0) {\n\t\t/*\n\t\t * Check the error type.\n\t\t */\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_INVALID_SOCKET;\n\t\t\tcase EINTR:\n\t\t\t\treturn BSD_INTERRUPTED_SYSTEM_CALL;\n\t\t\tcase EIO:\n\t\t\t\treturn BSD_IO_ERROR;\n\t\t\tcase EISDIR:\n\t\t\t\treturn BSD_IS_A_DIRECTORY;\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_INVALID_SOCKET;\n\t\t\tcase EFAULT:\n\t\t\t\treturn BSD_FAULT_RETURNED_FROM_SYSTEM_CALL;\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_INVALID_SOCKET;\n\t\t\tcase EINTR:\n\t\t\t\treturn BSD_INTERRUPTED_SYSTEM_CALL;\n\t\t\tcase EIO:\n\t\t\t\treturn BSD_IO_ERROR;\n\t\t\tcase EISDIR:\n\t\t\t\treturn BSD_IS_A_DIRECTORY;\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_INVALID_SOCKET;\n\t\t\tcase EFAULT:\n\t\t\t\treturn BSD_FAULT_RETURNED_FROM_SYSTEM_CALL;\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_INVALID_SOCKET;\n\t\t\tcase EINTR:\n\t\t\t\treturn BSD_INTERRUPTED_SYSTEM_CALL;\n\t\t\tcase EIO:\n\t\t\t\treturn BSD_IO_ERROR;\n\t\t\tcase EISDIR:\n\t\t\t\treturn BSD_IS_A_DIRECTORY;\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_INVALID_SOCKET;\n\t\t\tcase EFAULT:\n\t\t\t\treturn BSD_FAULT_RETURNED_FROM_SYSTEM_CALL;", "CodeBleu_score": 38.33303454900635}, {"code": "int BSD_close(int socket)\tstruct socket_info *socket_info = NULL;\n\tint error_number = 0;\n\n\t/*\n\t * Retrieve the socket information and set its state to \"NOT_A_SOCKET\" if it exists.\n\t */\n\tif (socket >= 0 && socket < MAX_SOCKETS) {\n\t\tsocket_info = &socket_table[socket];\n\t\tif (socket_info->state!= NOT_A_SOCKET) {\n\t\t\tsocket_info->state = NOT_A_SOCKET;\n\t\t}\n\t}\n\n\t/*\n\t * Call the close function and check the return value for errors.\n\t */\n\tif (close(socket) < 0) {\n\t\terror_number = errno;\n\t\tif (error_number == EBADF) {\n\t\t\terror_number = ENOTSOCK;\n\t\t}\n\t}\n\n\t/*\n\t * If an error occurs, set the appropriate error number based on the error type and return \"BSD_ERROR\".\n\t * If no error occurs, return \"BSD_SUCCESS\".\n\t */\n\tif (error_number!= 0) {\n\t\terrno = error_number;\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}\n", "CodeBleu_score": 46.40111822410373}, {"code": "int BSD_close(int socket)\tint status = BSD_SUCCESS;\n\tstruct BSD_socket_information *socket_info = NULL;\n\n\t/*\n\t * Check if the given socket is a valid socket.\n\t */\n\tif (socket < 0 || socket >= BSD_SOCKET_COUNT) {\n\t\tstatus = BSD_INVALID_SOCKET;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Retrieve the socket information.\n\t */\n\tsocket_info = &BSD_socket_info[socket];\n\n\t/*\n\t * Check if the socket is a valid socket.\n\t */\n\tif (socket_info->state!= BSD_SOCKET_OPEN) {\n\t\tstatus = BSD_SOCKET_NOT_OPEN;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Close the socket.\n\t */\n\tif (close(socket_info->socket_fd) < 0) {\n\t\tstatus = BSD_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Set the socket state to \"NOT_A_SOCKET\".\n\t */\n\tsocket_info->state = BSD_SOCKET_NOT_A_SOCKET;\n", "CodeBleu_score": 35.47675141104478}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog)\tint response;\n\n\tresponse = listen(socket, backlog);\n\tif (response == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_EBADF;\n\t\t\tcase ENOTSOCK:\n\t\t\t\treturn BSD_ENOTSOCK;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\treturn BSD_EOPNOTSUPP;\n\t\t\tcase EINVAL:\n\t\t\t\treturn BSD_EINVAL;\n\t\t\tdefault:\n\t\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\telse {\n\t\treturn BSD_SUCCESS;\n\t}\n}\n", "CodeBleu_score": 39.37734409292541}, {"code": "int BSD_listen(int socket, int backlog)\tint ret = listen(socket, backlog);\n\tif (ret == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_EBADF;\n\t\t\tcase ENOTSOCK:\n\t\t\t\treturn BSD_ENOTSOCK;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\treturn BSD_EOPNOTSUPP;\n\t\t\tcase EINVAL:\n\t\t\t\treturn BSD_EINVAL;\n\t\t\tcase EMFILE:\n\t\t\t\treturn BSD_EMFILE;\n\t\t\tcase ENFILE:\n\t\t\t\treturn BSD_ENFILE;\n\t\t\tcase ENOBUFS:\n\t\t\t\treturn BSD_ENOBUFS;\n\t\t\tcase ENOMEM:\n\t\t\t\treturn BSD_ENOMEM;\n\t\t\tdefault:\n\t\t\t\treturn BSD_UNKNOWN_ERROR;\n\t\t}\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 34.33710437537041}, {"code": "int BSD_listen(int socket, int backlog)\tint ret;\n\tif ((ret = listen(socket, backlog)) < 0) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\treturn BSD_EBADF;\n\t\t\tcase ENOTSOCK:\n\t\t\t\treturn BSD_ENOTSOCK;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\treturn BSD_EOPNOTSUPP;\n\t\t\tcase EINVAL:\n\t\t\t\treturn BSD_EINVAL;\n\t\t\tcase EACCES:\n\t\t\t\treturn BSD_EACCES;\n\t\t\tcase EMFILE:\n\t\t\t\treturn BSD_EMFILE;\n\t\t\tcase ENFILE:\n\t\t\t\treturn BSD_ENFILE;\n\t\t\tcase ENOBUFS:\n\t\t\t\treturn BSD_ENOBUFS;\n\t\t\tcase ENOMEM:\n\t\t\t\treturn BSD_ENOMEM;\n\t\t\tdefault:\n\t\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 35.260330944734335}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret;\n\tint family;\n\tint type;\n\tint protocol;\n\tstruct sockaddr * sa;\n\tsocklen_t salen;\n\n\tif (socket < 0 || socket >= MAX_SOCKETS || sockets[socket].state == SOCKET_UNUSED) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tif (sockets[socket].state == SOCKET_CLOSED) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tif (sockets[socket].state == SOCKET_BOUND) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (addr == NULL || addrlen == NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tfamily = sockets[socket].family;\n\ttype = sockets[socket].type;\n\tprotocol = sockets[socket].protocol;\n\n\tif (family == AF_INET) {\n\t\tif (type!= SOCK_STREAM) {\n\t\t\terrno = EOPNOTSUPP;\n\t\t\treturn -1;\n\t\t}\n\n\t\tsa = (struct sockaddr *) &addr->in;\n\t\tsalen = sizeof(struct sockaddr_in);\n\t} else if (family == AF_INET6) {\n\t\tif (type!= SOCK_STREAM) {\n\t\t\terrno = EOPNOTSUPP;\n\t\t\treturn -1;\n\t\t}\n\n\t\tsa = (struct sockaddr *) &addr->in6;\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t} else {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\n\tret = accept(sockets[socket].fd, sa, &salen);\n\tif (ret < 0) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = EINVAL;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tsockets[ret].state = SOCKET_CONNECTED;\n\tsockets[ret].family = family;\n\tsockets[ret].type = type;\n\tsockets[ret].protocol = protocol;\n\tsockets[ret].bound = 0;\n\n\tif (family == AF_INET) {\n\t\taddr->in.sin_family = AF_INET;\n\t\taddr->in.sin_port = sockets[ret].", "CodeBleu_score": 39.71207648541639}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret = -1;\n\tint error = 0;\n\tstruct sockaddr_storage local_addr;\n\tsocklen_t local_addrlen = sizeof(local_addr);\n\tstruct sockaddr * local_addr_ptr = NULL;\n\n\tif (socket < 0 || socket >= BSD_SOCKET_TABLE_SIZE || addr == NULL || addrlen == NULL) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tif (BSD_SOCKET_TABLE[socket].bsd_socket_state == BSD_SOCKET_STATE_CLOSED) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tif (BSD_SOCKET_TABLE[socket].bsd_socket_state == BSD_SOCKET_STATE_LISTENING) {\n\t\tif (BSD_SOCKET_TABLE[socket].bsd_socket_domain == AF_INET) {\n\t\t\tif (BSD_SOCKET_TABLE[socket].bsd_socket_type == BSD_SOCK_STREAM) {\n\t\t\t\tif (BSD_SOCKET_TABLE[socket].bsd_socket_protocol == IPPROTO_TCP) {\n\t\t\t\t\tret = accept(BSD_SOCKET_TABLE[socket].bsd_socket_fd, (struct sockaddr *) &local_addr, &local_addrlen);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\terror = errno;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocal_addr_ptr = (struct sockaddr *) &local_addr;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrno = EPROTOTYPE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terrno = EPROTOTYPE;\n\t\t\t}\n\t\t} else if (BSD_SOCKET_TABLE[socket].bsd_socket_domain == AF_INET6) {\n\t\t\tif (BSD_SOCKET_TABLE[socket].bsd_socket_type == BSD_SOCK_STREAM) {\n\t\t\t\tif (BSD_SOCKET_TABLE[socket].bsd_socket_protocol == IPPROTO_TCP) {\n\t\t\t\t\tret = accept(BSD_SOCKET_TABLE[socket].bsd_socket_fd, (struct sockaddr *) &local_addr, &local_addrlen);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\terror = errno;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocal_addr_ptr = (struct sockaddr *) &local_addr;\n\t\t\t\t\t}\n\t\t\t\t} else {", "CodeBleu_score": 37.10014463236397}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret;\n\tstruct sockaddr_storage client_addr;\n\tsocklen_t client_addrlen = sizeof(client_addr);\n\tstruct sockaddr_storage server_addr;\n\tsocklen_t server_addrlen = sizeof(server_addr);\n\n\tif (socket < 0) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tif (addr == NULL || addrlen == NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (socket_table[socket].domain == PF_INET) {\n\t\tif (addrlen < sizeof(struct bsd_sockaddr_in)) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = accept(socket, (struct sockaddr *) &client_addr, &client_addrlen);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (client_addrlen > sizeof(struct bsd_sockaddr_in)) {\n\t\t\terrno = EINVAL;\n\t\t\tclose(ret);\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(addr, &client_addr, client_addrlen);\n\t\t*addrlen = client_addrlen;\n\t} else if (socket_table[socket].domain == PF_INET6) {\n\t\tif (addrlen < sizeof(struct bsd_sockaddr_in6)) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = accept(socket, (struct sockaddr *) &client_addr, &client_addrlen);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (client_addrlen > sizeof(struct bsd_sockaddr_in6)) {\n\t\t\terrno = EINVAL;\n\t\t\tclose(ret);\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(addr, &client_addr, client_addrlen);\n\t\t*addrlen = client_addrlen;\n\t} else {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 41.74322873967608}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT()\t// Get current time in UNIX format\n\ttime_t now = time(NULL);\n\t// Check if time is valid\n\tif (now == (time_t)-1) {\n\t\t// If not, print error message\n\t\tprintf(\"Error: Could not get current time in UNIX format.\\n\");\n\t\treturn;\n\t}\n\t// Update JWT with current time offset\n\tupdateJWT(now);\n\t// Connect to MQTT broker\n\tif (MQTTClient_connect(client, &connect_opts)!= MQTT_SUCCESS) {\n\t\t// If connection failed, print error message\n\t\tprintf(\"Error: Could not connect to MQTT broker.\\n\");\n\t\treturn;\n\t}\n\t// Set flag to send MQTT SUBSCRIBE packet\n\tsubscribe_flag = 1;\n\t// Print debug message\n\tprintf(\"MQTT connection established.\\n\");\n}\n", "CodeBleu_score": 38.571495595857975}, {"code": "static void connectMQTT()\t// Retrieve current time in UNIX format\n\ttime_t now = time(NULL);\n\n\t// Check if the current time is valid\n\tif (now < 1609459200) {\n\t\t// Update the JWT with the current time offset\n\t\tupdateJWT(now);\n\t}\n\n\t// Initialize the MQTT connection\n\tif (esp_mqtt_client_init(&mqtt_client) == ESP_OK) {\n\t\t// Print a debug message to indicate the connection attempt\n\t\tprintf(\"MQTT connection attempt\\n\");\n\n\t\t// Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n\t\tsubscribe_flag = true;\n\t}\n}\n", "CodeBleu_score": 45.083268404776405}, {"code": "static void connectMQTT()\t// Get current time in UNIX format\n\ttime_t now = time(NULL);\n\n\t// Check if time is valid\n\tif (now == (time_t)-1) {\n\t\t// If time is invalid, print error message and return\n\t\tprintf(\"Error: Could not get current time\\n\");\n\t\treturn;\n\t}\n\n\t// Get current time in UTC\n\tstruct tm *utcTime = gmtime(&now);\n\n\t// Calculate time offset\n\tint timeOffset = (int)difftime(now, mktime(utcTime));\n\n\t// Update JWT with time offset\n\tupdateJWT(timeOffset);\n\n\t// Connect to MQTT broker\n\tif (mqttClient.connect(mqtt_id)) {\n\t\t// Set flag to send MQTT SUBSCRIBE packet\n\t\tmqttSubscribe = 1;\n\n\t\t// Print debug message\n\t\tprintf(\"Connected to MQTT broker\\n\");\n\t} else {\n\t\t// Print error message\n\t\tprintf(\"Error: Could not connect to MQTT broker\\n\");\n\t}\n}\n", "CodeBleu_score": 37.796259738799684}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void)\tif (CLOUD_mqttClient.state == eMQTT_Connected) {\n\t\tCLOUD_mqttClient.disconnect(&CLOUD_mqttClient);\n\t}\n\tCLOUD_log_debug(\"Disconnecting from the cloud service...\");\n}\n", "CodeBleu_score": 41.78651207128858}, {"code": "void CLOUD_disconnect(void)\tif (mqttClient.state == MQTT_CONNECTED) {\n\t\tMQTT_Client_disconnect(&mqttClient);\n\t}\n\tLog_Debug(\"Disconnected from MQTT broker\");\n}\n", "CodeBleu_score": 42.24319034733261}, {"code": "void CLOUD_disconnect(void)\t// Disconnect the MQTT client if it is connected\n\tif (mqttClient.state() == MQTT_CONNECTED) {\n\t\t// Log the disconnection\n\t\tLog.info(\"Disconnecting from the cloud service\");\n\t\t// Retrieve the client connection information\n\t\tIPAddress ip;\n\t\tuint16_t port;\n\t\tmqttClient.remoteIP().toString().toCharArray(ipString, 16);\n\t\tip = IPAddress(ipString);\n\t\tport = mqttClient.remotePort();\n\t\t// Disconnect the MQTT client\n\t\tmqttClient.disconnect();\n\t\t// Log the disconnection\n\t\tLog.info(\"Disconnected from the cloud service\");\n\t}\n}\n", "CodeBleu_score": 42.628971813670155}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\tif (passed_wifi_creds) {\n\t\t// Attempt to connect using the specified SSID, authentication type, and password\n\t\tif (wifi_connectToApWithNewCreds(ssid, authType, password)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Connection failed, log an error message, update the networking error status, and return false\n\t\t\tprintf(\"Failed to connect to the specified SSID, authentication type, and password\\n\");\n\t\t\tnetworkingError = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// Attempt to connect using the default Wi-Fi settings\n\t\tif (wifi_connectToApWithNewCreds(DEFAULT_SSID, DEFAULT_AUTH_TYPE, DEFAULT_PASSWORD)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Connection failed, log an error message, update the networking error status, and return false\n\t\t\tprintf(\"Failed to connect to the default SSID, authentication type, and password\\n\");\n\t\t\tnetworkingError = true;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.782435563512436}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\tbool wifi_connected = false;\n\tif (passed_wifi_creds == 0) {\n\t\twifi_connected = wifi_connectToAp_default();\n\t} else {\n\t\twifi_connected = wifi_connectToAp_newCreds();\n\t}\n\tif (wifi_connected == false) {\n\t\tlog_error(\"wifi_connectToAp failed\");\n\t\tnetworking_error = true;\n\t}\n\treturn wifi_connected;\n}\n", "CodeBleu_score": 22.117687519246655}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\tif (passed_wifi_creds == 1) {\n\t\t// Connect to the access point using the specified credentials\n\t\tSerial.print(\"Attempting to connect to SSID: \");\n\t\tSerial.println(ssid);\n\t\tSerial.print(\"Using password: \");\n\t\tSerial.println(password);\n\t\tWiFi.begin(ssid, password);\n\t} else {\n\t\t// Connect to the access point using the default credentials\n\t\tSerial.print(\"Attempting to connect to SSID: \");\n\t\tSerial.println(DEFAULT_WIFI_SSID);\n\t\tSerial.print(\"Using password: \");\n\t\tSerial.println(DEFAULT_WIFI_PASSWORD);\n\t\tWiFi.begin(DEFAULT_WIFI_SSID, DEFAULT_WIFI_PASSWORD);\n\t}\n\t// Wait for the Wi-Fi to connect\n\tSerial.print(\"Waiting for Wi-Fi to connect to \");\n\tSerial.print(ssid);\n\twhile (WiFi.status()!= WL_CONNECTED) {\n\t\tSerial.print(\".\");\n\t\tdelay(500);\n\t}\n\tSerial.println();\n\tSerial.print(\"Wi-Fi connected to \");\n\tSerial.println(ssid);\n\tSerial.print(\"Wi-Fi IP address: \");\n\tSerial.println(WiFi.localIP());\n\treturn true;\n}\n", "CodeBleu_score": 33.20478394290157}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map)\t// Create a client and send a request to the GraphQL API.\n\tconst client = new ApolloClient({\n\t\turi: \"https://api.digitransit.fi/routing/v1/routers/hsl/index/graphql\"\n\t});\n\tconst { data } = await client.query({\n\t\tquery: gql`\n\t\t\tquery {\n\t\t\t\tsensors {\n\t\t\t\t\tid\n\t\t\t\t\tname\n\t\t\t\t\tlatitude\n\t\t\t\t\tlongitude\n\t\t\t\t}\n\t\t\t}\n\t\t`\n\t});\n\n\t// Log the response from the API.\n\tconsole.log(data);\n\n\t// If the response contains data, create a marker for each sensor.\n\tif (data.sensors) {\n\t\tconsole.log(\"Retrieved sensors:\");\n\t\tfor (const sensor of data.sensors) {\n\t\t\tconsole.log(sensor);\n\t\t\tconst marker = new H.map.Marker({\n\t\t\t\tlat: sensor.latitude,\n\t\t\t\tlng: sensor.longitude\n\t\t\t});\n\t\t\tmap.addObject(marker);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.88828124810495}, {"code": "async function DisplaySensors(map)// Create a client and set the endpoint to the GraphQL API.", "CodeBleu_score": 0.7405118079468137}, {"code": "async function DisplaySensors(map)\tconst client = new ApolloClient({\n\t\turi: 'https://api.graph.cool/simple/v1/cixos23120m0n0178veiiwrjr'\n\t});\n\n\tconst { data } = await client.query({\n\t\tquery: gql`\n\t\tquery Sensors {\n\t\t\tallSensors {\n\t\t\t\tid\n\t\t\t\tname\n\t\t\t\tgeo {\n\t\t\t\t\tlat\n\t\t\t\t\tlon\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`\n\t});\n\n\tconsole.log(data);\n\n\tif (data.allSensors) {\n\t\tconsole.log('Retrieved sensors');\n\t\tfor (sensor of data.allSensors) {\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: {\n\t\t\t\t\tlat: sensor.geo.lat,\n\t\t\t\t\tlng: sensor.geo.lon\n\t\t\t\t},\n\t\t\t\tmap: map,\n\t\t\t\ttitle: sensor.name\n\t\t\t});\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.44736412788745}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>\t// Create a new marker element with the sensor's unique ID as its id\n\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\n\t// Assign the marker a specific class name\n\tmarker.className ='sensor-marker';\n\n\t// Style the marker with a default color and border\n\tmarker.style.backgroundColor = '#1a1a1a';\n\tmarker.style.border = '2px solid #1a1a1a';\n\n\t// Return the created marker\n\treturn marker;\n};\n", "CodeBleu_score": 34.81371473805508}, {"code": "const CreateSensorMarker = (sensor) =>\t// Create the marker element\n\tconst marker = document.createElement('div');\n\t// Set the marker's id to the sensor's unique ID\n\tmarker.id = sensor.id;\n\t// Assign the marker a specific class name\n\tmarker.className ='sensor-marker';\n\t// Set the marker's style\n\tmarker.style.backgroundColor = '#333';\n\tmarker.style.border = '2px solid #333';\n\tmarker.style.borderRadius = '50%';\n\tmarker.style.width = '10px';\n\tmarker.style.height = '10px';\n\tmarker.style.margin = '-5px 0 0 -5px';\n\tmarker.style.position = 'absolute';\n\tmarker.style.zIndex = '999';\n\t// Return the created marker element\n\treturn marker;\n};\n", "CodeBleu_score": 31.018168048423828}, {"code": "const CreateSensorMarker = (sensor) =>\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"#000000\";\n\tmarker.style.border = \"2px solid #000000\";\n\treturn marker;\n};\n", "CodeBleu_score": 32.33943443227297}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    mfa_module_path = f\"{MFA_MODULE_PATH}.{module_name}\"\n    try:\n        mfa_module = importlib.import_module(mfa_module_path)\n    except ImportError as error:\n        _LOGGER.error(\"Unable to load MFA module %s: %s\", module_name, error)\n        raise\n\n    if not hasattr(mfa_module, \"MfaModule\"):\n        _LOGGER.error(\n            \"MFA module %s does not contain a class named MfaModule\", module_name\n        )\n        raise ImportError\n\n    mfa_module_class = getattr(mfa_module, \"MfaModule\")\n    if not issubclass(mfa_module_class, MfaModule):\n        _LOGGER.error(\n            \"MFA module %s does not contain a subclass of MfaModule\", module_name\n        )\n        raise ImportError\n\n    return mfa_module\n\n", "CodeBleu_score": 40.52761619670606}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\n    # Construct the module path\n    module_path = f\"{MFA_MODULES_PATH}.{module_name}\"\n\n    # Attempt to import the module\n    try:\n        module = await hass.async_add_executor_job(importlib.import_module, module_path)\n\n    # Log and raise an error if the module could not be imported\n    except ImportError as error:\n        _LOGGER.error(\"Failed to import multi-factor authentication module %s: %s\", module_name, error)\n        raise\n\n    # Return the module\n    return module\n\n", "CodeBleu_score": 25.461926316850647}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"custom_components.mfa.{module_name}\"\n    try:\n        module = await hass.async_add_executor_job(\n            importlib.import_module, module_path\n        )\n    except ImportError:\n        _LOGGER.error(\n            \"Failed to import multi-factor authentication module %s\", module_path\n        )\n        raise\n\n    if not hasattr(module, \"DOMAIN\"):\n        _LOGGER.error(\n            \"Multi-factor authentication module %s has no attribute DOMAIN\",\n            module_path,\n        )\n        raise ImportError\n\n    if not hasattr(module, \"async_setup\"):\n        _LOGGER.error(\n            \"Multi-factor authentication module %s has no attribute async_setup\",\n            module_path,\n        )\n        raise ImportError\n\n    if not hasattr(module, \"async_setup_entry\"):\n        _LOGGER.error(\n            \"Multi-factor authentication module %s has no attribute async_setup_entry\",\n            module_path,\n        )\n        raise ImportError\n\n    if not hasattr(module, \"async_unload_entry\"):\n        _LOGGER.error(\n            \"Multi-factor authentication module %s has no attribute async_unload_entry\",\n            module_path,\n        )\n        raise ImportError\n\n    if not hasattr(module, \"async_get_options_flow\"):\n        _LOGGER.error(\n            \"Multi-factor authentication module %s has no attribute async_get_options_flow\",\n            module_path,\n        )\n        raise ImportError\n\n    if not hasattr(module, \"async_get_auth_implementation\"):\n        _LOGGER.error(\n            \"Multi-factor authentication module %s has no attribute async_get_auth_implementation\",\n            module_path,\n        )\n        raise ImportError\n\n    if not hasattr(module, \"async_get_auth_flow\"):\n        _LOGGER.error(\n            \"Multi-factor authentication module %s has no attribute async_get_auth_flow\",\n            module_path,\n        )\n        raise ImportError\n\n    return module\n\n", "CodeBleu_score": 26.664814508619383}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = None\n    for entry in self.data:\n        if entry[\"user_id\"] == user_id:\n            pin = entry[\"pin\"]\n            break\n    if pin is None:\n        pin = setup_data[\"pin\"]\n        self.data.append({\"user_id\": user_id, \"pin\": pin})\n    else:\n        self.data[self.data.index({\"user_id\": user_id, \"pin\": pin})][\"pin\"] = setup_data[\"pin\"]\n    return pin\n\n", "CodeBleu_score": 47.60263740380288}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise ValueError(\"No PIN provided\")\n    if self.data_list.get(user_id):\n        self.data_list[user_id][\"pin\"] = pin\n    else:\n        self.data_list[user_id] = {\"pin\": pin}\n    return True\n\n", "CodeBleu_score": 35.95259374237678}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    if not self.data.get(user_id):\n        self.data[user_id] = setup_data\n        return True\n    else:\n        self.data[user_id] = setup_data\n        return True\n\n", "CodeBleu_score": 27.337541203485273}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n    if not self._init_lock.locked():\n      async with self._init_lock:\n        if not self._loaded:\n          try:\n            data = await self._user_store.async_load()\n            if not data:\n              data = {}\n            self._user_settings = {\n              user_id: NotifySetting(user_id, data.get(user_id, {}))\n              for user_id in self._user_store.users\n            }\n            self._loaded = True\n          except Exception as e:\n            _LOGGER.error(f\"Unable to load user settings: {e}\")\n            self._user_settings = {\n              user_id: NotifySetting(user_id) for user_id in self._user_store.users\n            }\n            self._loaded = True\n\n  async def async_save(self) -> None:\n    \"\"\"The function \"async_save\" asynchronously saves user data to the user store.\"\"\"\n    if self._loaded:\n      try:\n        await self._user_store.async_save(\n          {user_id: setting.to_dict() for user_id, setting in self._user_settings.items()}\n        )\n      except Exception as e:\n        _LOGGER.error(f\"Unable to save user settings: {e}\")\n\n  def get(self, user_id: str) -> NotifySetting:\n    \"\"\"The function \"get\" retrieves the user settings for the given user id.\\nIf the settings are not loaded yet, it attempts to load the settings.\\nIf the settings are still not loaded, it returns an empty dictionary for the user settings.\"\"\"\n    if not self._loaded:\n      asyncio.create_task(self._async_load())\n    return self._user_settings.get(user_id, NotifySetting(user_id))\n\n  def set(self, user_id: str, settings: dict) -> None:\n    \"\"\"The function \"set\" sets the given user settings for the given user id.\\nIf the settings are not loaded yet, it attempts to load the settings.\\nIf the settings are still not loaded, it returns an empty dictionary for the user settings.\"\"\"\n    if not self._loaded:\n      asyncio.create_task(self._async_load())\n    self._user_settings[user_id] = NotifySetting(user_id, settings)\n", "CodeBleu_score": 37.00502657474151}, {"code": "async def _async_load(self) -> None\n    async with self.init_lock:\n      if self.loaded:\n        return\n      if self.user_store.is_empty():\n        self.settings = {}\n      else:\n        self.settings = json.loads(await self.user_store.read())\n      self.loaded = True\n      for user_id, user_settings in self.settings.items():\n        self.settings[user_id] = NotifySetting(user_id, user_settings)\n\n  async def _async_save(self) -> None:\n    \"\"\"The function \"_async_save\" asynchronously saves user data to the user store.\\nIt acquires an initialization lock to ensure thread safety and then saves the data to the user store.\"\"\"\n    async with self.init_lock:\n      await self.user_store.write(json.dumps(self.settings))\n\n  async def get(self, user_id: int) -> NotifySetting:\n    \"\"\"The function \"get\" gets the NotifySetting object for a given user.\\nIt first loads the user data if it hasn't already been loaded.\\nIt then returns the NotifySetting object for the user.\"\"\"\n    await self._async_load()\n    return self.settings[user_id]\n\n  async def set(self, user_id: int, notify_setting: NotifySetting) -> None:\n    \"\"\"The function \"set\" sets the NotifySetting object for a given user.\\nIt first loads the user data if it hasn't already been loaded.\\nIt then sets the NotifySetting object for the user and saves the data to the user store.\"\"\"\n    await self._async_load()\n    self.settings[user_id] = notify_setting\n    await self._async_save()\n", "CodeBleu_score": 33.68883497009697}, {"code": "async def _async_load(self) -> None\n    async with self._initialization_lock:\n      if self._loaded:\n        return\n      if not await self._async_load_user_data():\n        self._user_settings = {}\n      for user_id, user_settings in self._user_settings.items():\n        self._user_settings[user_id] = NotifySetting(user_id, user_settings)\n      self._loaded = True\n\n  async def _async_load_user_data(self) -> bool:\n    \"\"\"The function \"_async_load_user_data\" asynchronously loads user data from the user store.\\nIt returns True if data was successfully loaded, otherwise False.\"\"\"\n    try:\n      data = await self._user_store.async_load()\n      if not data:\n        return False\n      self._user_settings = data\n      return True\n    except Exception as e:\n      raise RuntimeError(f\"Failed to load user settings from store: {e}\")\n\n  async def _async_save(self) -> None:\n    \"\"\"The function \"_async_save\" asynchronously saves the user settings to the user store.\"\"\"\n    try:\n      await self._user_store.async_save(self._user_settings)\n    except Exception as e:\n      raise RuntimeError(f\"Failed to save user settings to store: {e}\")\n", "CodeBleu_score": 26.394715109579902}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self._load_user_settings(user_id)\n    if self.user_settings:\n        return await self._validate_otp(user_id, user_input)\n    return False\n\n", "CodeBleu_score": 27.822880549647927}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self.async_load_user_settings(user_id)\n    if self.settings.get(user_id) is None:\n      return False\n    return await self.hass.async_add_executor_job(\n      self.validate,\n      user_id,\n      user_input\n    )\n\n  def validate(self, user_id: str, user_input: dict[str, Any]) -> bool:\n    \"\"\"The function \"validate\" validates user input for a given user ID.\\nIt ensures user settings are loaded, then retrieves the notification settings for the specified user.\\nIf no settings are found for the user, it returns False.\\nOtherwise, it validates the user input by verifying the OTP using the pyotp library and returns True if the validation passes.\"\"\"\n    self.async_load_user_settings(user_id)\n    if self.settings.get(user_id) is None:\n      return False\n    return pyotp.TOTP(self.settings[user_id][\"secret\"]).verify(user_input[\"otp\"])\n\n  async def async_get_user_settings(self, user_id: str) -> dict[str, Any]:\n    \"\"\"The function \"async_get_user_settings\" asynchronously retrieves the notification settings for a specified user.\\nIt ensures user settings are loaded, then retrieves the notification settings for the specified user.\\nIf no settings are found for the user, it returns None.\"\"\"\n    await self.async_load_user_settings(user_id)\n    return self.settings.get(user_id)\n\n  def get_user_settings(self, user_id: str) -> dict[str, Any]:\n    \"\"\"The function \"get_user_settings\" retrieves the notification settings for a specified user.\\nIt ensures user settings are loaded, then retrieves the notification settings for the specified user.\\nIf no settings are found for the user, it returns None.\"\"\"\n    self.async_load_user_settings(user_id)\n    return self.settings.get(user_id)\n\n  async def async_get_user_id(self, user_input: dict[str, Any]) -> str:\n    \"\"\"The function \"async_get_user_id\" asynchronously retrieves the user ID for a specified user input.\\nIt ensures user settings are loaded, then retrieves the user ID for the specified user input.\\nIf no user ID is found", "CodeBleu_score": 51.417992203615285}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self._load_user_settings(user_id)\n    settings = self._user_settings.get(user_id, None)\n    if settings is None:\n        return False\n    return await self._async_validate_settings(settings, user_input)\n\n", "CodeBleu_score": 39.959382403915036}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if not device_entry or not device_entry.area_id:\n        return None\n    area_id = device_entry.area_id\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 51.143880777558735}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 63.011160283136356}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    return area_dict[area_id]\n\n", "CodeBleu_score": 52.33412043797374}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    policy_dict: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category in policy.keys():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                policy_dict[category] = policy[category]\n            else:\n                policy_dict[category] = merge_categories(\n                    policy_dict[category], policy[category]\n                )\n    return policy_dict\n\n", "CodeBleu_score": 50.29699462573708}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen_categories:\n                merged_policy[category] = value\n                seen_categories.add(category)\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 46.893284817485885}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for p in policies:\n        for category, permissions in p.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                policy[category] = permissions\n            else:\n                policy[category] |= permissions\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 46.917929908942526}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(f\".{provider}\", __name__)\n    except ImportError as err:\n        raise HomeAssistantError(f\"Error loading {provider} auth provider\") from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed_requirements = set()\n\n    for requirement in module.REQUIREMENTS:\n        if requirement in processed_requirements:\n            continue\n\n        processed_requirements.add(requirement)\n\n        try:\n            await async_process_requirements(hass, requirement)\n        except HomeAssistantError as err:\n            _LOGGER.error(\n                \"Error processing requirement %s for %s auth provider: %s\",\n                requirement,\n                provider,\n                err,\n            )\n\n    return module\n\n", "CodeBleu_score": 43.53255264471404}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = await hass.async_add_executor_job(\n            importlib.import_module, f\"homeassistant.auth_providers.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error loading %s auth provider.\\n%s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError(\n            f\"Error loading {provider} auth provider: {err}\"\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed_requirements = set()\n\n    for requirement in module.REQUIREMENTS:\n        if requirement in processed_requirements:\n            continue\n\n        processed_requirements.add(requirement)\n\n        try:\n            await hass.async_add_executor_job(\n                importlib.import_module, requirement\n            )\n        except ImportError as err:\n            _LOGGER.error(\n                \"Error importing requirement %s for %s auth provider.\\n%s\",\n                requirement,\n                provider,\n                err,\n            )\n            raise HomeAssistantError(\n                f\"Error importing requirement {requirement} for {provider} auth provider: {err}\"\n            ) from err\n\n    return module\n\n", "CodeBleu_score": 44.3265787902641}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = await hass.async_add_executor_job(\n            importlib.import_module, f\"homeassistant.auth_providers.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error loading %s auth provider. %s\", provider, _format_error(err)\n        )\n        raise HomeAssistantError(\n            f\"Error loading {provider} auth provider: {err}\"\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    # Process requirements\n    processed_requirements = set()\n    for req in module.REQUIREMENTS:\n        if req in processed_requirements:\n            continue\n\n        processed_requirements.add(req)\n        if req.startswith(\"http\"):\n            # HTTP(S) requirement\n            try:\n                await hass.async_add_executor_job(\n                    importlib.import_module,\n                    f\"homeassistant.components.http.requirements.{req}\",\n                )\n            except ImportError as err:\n                _LOGGER.error(\n                    \"Error loading %s auth provider requirement. %s\",\n                    provider,\n                    _format_error(err),\n                )\n                raise HomeAssistantError(\n                    f\"Error loading {provider} auth provider requirement: {err}\"\n                ) from err\n        else:\n            # Local requirement\n            try:\n                await hass.async_add_executor_job(\n                    importlib.import_module, f\"homeassistant.components.{req}\"\n                )\n            except ImportError as err:\n                _LOGGER.error(\n                    \"Error loading %s auth provider requirement. %s\",\n                    provider,\n                    _format_error(err),\n                )\n                raise HomeAssistantError(\n                    f\"Error loading {provider} auth provider requirement: {err}\"\n                ) from err\n\n    return module\n\n", "CodeBleu_score": 42.146361759506945}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n    try:\n        self.users = await self.store.async_load()\n    except HomeAssistantError:\n        self.users = []\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"]!= normalize_username(user[\"username\"]):\n            _LOGGER.warning(\n                \"Found username that is not normalized: %s. \"\n                \"Please change the username in your configuration file to: %s\",\n                user[\"username\"],\n                normalize_username(user[\"username\"]),\n            )\n            user[\"username\"] = normalize_username(user[\"username\"])\n\n    # Check for duplicates\n    usernames = [user[\"username\"] for user in self.users]\n    if len(usernames)!= len(set(usernames)):\n        for username in set(usernames):\n            if usernames.count(username) > 1:\n                _LOGGER.warning(\n                    \"Found duplicate username: %s. \"\n                    \"Please change the username in your configuration file to: %s\",\n                    username,\n                    normalize_username(username),\n                )\n\n", "CodeBleu_score": 21.158433023896066}, {"code": "async def async_load(self) -> None\n    try:\n      self.users = await self.store.async_load()\n    except:\n      self.users = []\n\n    self.users = [user for user in self.users if user.get('username')]\n    self.users = [User(user) for user in self.users]\n\n  async def async_save(self) -> None:\n    \"\"\"The function \"async_save\" asynchronously saves user data to the store.\"\"\"\n    await self.store.async_save(self.users)\n\n  def add_user(self, username: str, password: str, email: str) -> None:\n    \"\"\"The function \"add_user\" adds a new user to the list of users.\\nIf the user already exists, it will not be added.\\nThe function returns True if the user was added, and False if the user already exists.\"\"\"\n    if not self.get_user(username):\n      self.users.append(User({\n        'username': username,\n        'password': password,\n        'email': email\n      }))\n      return True\n    return False\n\n  def get_user(self, username: str) -> User:\n    \"\"\"The function \"get_user\" returns a user object from the list of users based on the username.\\nIf the user does not exist, it returns None.\"\"\"\n    for user in self.users:\n      if user.username == username:\n        return user\n    return None\n\n  def update_user(self, username: str, password: str, email: str) -> None:\n    \"\"\"The function \"update_user\" updates a user object from the list of users based on the username.\\nIf the user does not exist, it will not be updated.\"\"\"\n    user = self.get_user(username)\n    if user:\n      user.password = password\n      user.email = email\n\n  def delete_user(self, username: str) -> None:\n    \"\"\"The function \"delete_user\" deletes a user object from the list of users based on the username.\\nIf the user does not exist, it will not be deleted.\"\"\"\n    user = self.get_user(username)\n    if user:\n      self.users.remove(user)\n", "CodeBleu_score": 27.56731700477174}, {"code": "async def async_load(self) -> None\n    try:\n      with open(self.path, \"r\") as f:\n        self.users = json.load(f)\n        if self.users == {}:\n          self.users = []\n    except FileNotFoundError:\n      self.users = []\n    except json.JSONDecodeError:\n      self.users = []\n    for user in self.users:\n      if not isinstance(user, str):\n        self.users.remove(user)\n\n  async def async_save(self) -> None:\n    \"\"\"The function \"async_save\" asynchronously saves user data to the store.\"\"\"\n    with open(self.path, \"w\") as f:\n      json.dump(self.users, f, indent=2)\n", "CodeBleu_score": 25.765446346081948}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = user[\"password_hash\"].encode(\"utf-8\")\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    if bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth(\"Invalid username\")\n    else:\n        raise InvalidAuth(\"Invalid username and password\")\n\n", "CodeBleu_score": 38.07447555596401}, {"code": "def validate_login(self, username: str, password: str) -> None\n    normalized_username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"<PASSWORD>\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == normalized_username:\n            stored_hash = user[\"password\"]\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    else:\n        if bcrypt.checkpw(password.encode(), dummy_hash):\n            raise InvalidAuth(\"Invalid username\")\n        else:\n            raise InvalidAuth(\"Invalid username and password\")\n\n", "CodeBleu_score": 35.52497291462278}, {"code": "def validate_login(self, username: str, password: str) -> None\n    # Normalize the username\n    username = username.lower()\n    # Initialize a dummy hash\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt(12))\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        # If a matching username is found, decode the stored password hash and compare the provided password with the stored hash\n        if user[\"username\"] == username:\n            password_hash = user[\"password_hash\"]\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    # If no matching user is found, perform a dummy hash check and raise an \"InvalidAuth\" exception\n    if bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth(\"Invalid username\")\n    # If a matching user is found, raise an \"InvalidAuth\" exception\n    else:\n        raise InvalidAuth(\"Invalid username\")\n", "CodeBleu_score": 36.079859043387266}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n    username = username.lower()\n    if username not in self.users:\n        raise InvalidUser(f\"User '{username}' not found\")\n    self.users.remove(username)\n    await self.save_users()\n", "CodeBleu_score": 21.952130925004248}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = username.lower()\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    self.users.remove(username)\n    self.save_users()\n\n", "CodeBleu_score": 22.147030695156246}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = username.lower()\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    self.users.remove(username)\n\n", "CodeBleu_score": 20.314026198076558}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if self.data is None:\n      await self.async_initialize()\n    try:\n      await self.hass.async_add_executor_job(self.data.remove_credentials, credentials.data)\n      await self.async_save()\n    except Exception:\n      pass\n", "CodeBleu_score": 55.992507622221645}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if self.data is None:\n      self.data = {}\n    try:\n      del self.data[credentials.data[\"username\"]]\n      await self.async_save(self.data)\n    except KeyError:\n      pass\n", "CodeBleu_score": 40.90613004879488}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self._data:\n      await self.async_get_data()\n\n    if credentials.data[CONF_USERNAME] in self._data:\n      self._data.pop(credentials.data[CONF_USERNAME])\n      await self.async_set_data(self._data)\n", "CodeBleu_score": 48.69075802580327}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    if not threads:\n        return set()\n    start = time.time()\n    joined = set()\n    while threads:\n        current = set()\n        for thread in threads:\n            if thread.is_alive():\n                current.add(thread)\n            elif thread.ident is not None:\n                joined.add(thread)\n        if current:\n            for thread in current:\n                thread.join(max(0, start + timeout - time.time()))\n        else:\n            break\n        if log:\n            for thread in current:\n                if thread.is_alive():\n                    logger.warning(f\"Thread {thread.name} is still running\")\n        threads = current\n    for thread in threads:\n        if thread.ident is not None:\n            joined.add(thread)\n        else:\n            thread.raise_exception()\n    return joined\n\n", "CodeBleu_score": 45.71827507473258}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined: set[Thread] = set()\n    for thread in threads:\n        thread_timeout = timeout\n        if thread.is_alive():\n            if thread.ident is not None:\n                thread_timeout = timeout - (time.time() - thread.start_time)\n            if thread_timeout > 0:\n                thread.join(thread_timeout)\n            if thread.is_alive():\n                if log:\n                    logger.debug(f\"Thread {thread.name} still alive\")\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    for thread in joined:\n        if thread.ident is None:\n            joined.remove(thread)\n    if len(joined) > 0:\n        logger.debug(f\"Interrupting {len(joined)} threads\")\n        for thread in joined:\n            thread.raise_exception()\n    return joined\n\n", "CodeBleu_score": 42.579493916508184}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread.join(timeout=timeout)\n        if thread.is_alive():\n            if log:\n                logger.warning(f\"Thread {thread.name} is still alive.\")\n            joined.add(thread)\n        elif thread.ident is None:\n            joined.add(thread)\n    for thread in joined:\n        thread.join()\n    for thread in threads:\n        if thread.is_alive():\n            thread.raise_exception()\n    return joined\n\n", "CodeBleu_score": 45.066029759630865}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n    # pylint: disable=protected-access\n    # pylint: disable=consider-using-enumerate\n    # pylint: disable=consider-using-sys-exit\n    # pylint: disable=consider-using-ternary\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-arguments\n    # pylint: disable=too-many-return-statements\n    # pylint: disable=too-many-boolean-expressions\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint", "CodeBleu_score": 0.5}, {"code": "def deadlock_safe_shutdown() -> None\n    # Get a list of all non-main, non-daemon, alive threads\n    non_main_threads = [t for t in threading.enumerate() if t is not threading.main_thread() and t.is_alive() and not t.daemon]\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = int(SHUTDOWN_TIMEOUT / len(non_main_threads))\n    # Attempt to join each thread within the calculated timeout\n    for thread in non_main_threads:\n        thread.join(timeout=timeout)\n        # Log a warning if joining a thread fails\n        if thread.is_alive():\n            logger.warning(f\"Failed to join thread {thread.name} within {timeout} seconds\")\n    # Log a warning if joining the main thread fails\n    if threading.main_thread().is_alive():\n        logger.warning(f\"Failed to join thread {threading.main_thread().name} within {timeout} seconds\")\n\n", "CodeBleu_score": 31.900996001944588}, {"code": "def deadlock_safe_shutdown() -> None\n    # Get the total shutdown timeout\n    total_shutdown_timeout = get_shutdown_timeout()\n\n    # Get the current time\n    current_time = time.time()\n\n    # Get all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if thread.name!= \"MainThread\" and not thread.daemon and thread.is_alive()]\n\n    # Get the number of remaining threads\n    remaining_threads = len(threads)\n\n    # If there are remaining threads\n    if remaining_threads > 0:\n\n        # Calculate the timeout for each thread\n        thread_timeouts = [total_shutdown_timeout / remaining_threads for _ in range(remaining_threads)]\n\n        # If the total shutdown timeout is less than the timeout for any thread\n        if total_shutdown_timeout < min(thread_timeouts):\n\n            # Log a warning\n            log_warning(\"The total shutdown timeout is less than the timeout for any thread. The total shutdown timeout will be used for all threads.\")\n\n            # Set all thread timeouts to the total shutdown timeout\n            thread_timeouts = [total_shutdown_timeout for _ in range(remaining_threads)]\n\n        # For each thread\n        for thread, thread_timeout in zip(threads, thread_timeouts):\n\n            # Get the current time\n            current_time = time.time()\n\n            # Calculate the timeout\n            timeout = thread_timeout - (current_time - start_time)\n\n            # If the timeout is negative\n            if timeout < 0:\n\n                # Set the timeout to 0\n                timeout = 0\n\n            # Try to join the thread within the timeout\n            try:\n\n                # Join the thread within the timeout\n                thread.join(timeout=timeout)\n\n            # If the thread fails to join\n            except RuntimeError:\n\n                # Log a warning\n                log_warning(f\"The thread \\\"{thread.name}\\\" failed to join within the timeout of {timeout:.2f} seconds. The thread will be killed.\")\n\n                # Kill the thread\n                thread.kill()\n\n    # Log a message\n    log_message(\"The server is shutting down.\")\n", "CodeBleu_score": 31.182655037206025}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if self._remaining_with_setup_started!= {} or remaining_with_setup_started!= {}:\n      self._remaining_with_setup_started = remaining_with_setup_started\n      self._dispatch_signal(self._internal_dispatcher_signal, remaining_with_setup_started)\n    self._has_remaining_with_setup_started = remaining_with_setup_started!= {}\n\n  def _dispatch_signal(self, signal: Signal, *args: Any) -> None:\n    \"\"\"The function \"_dispatch_signal\" dispatches a signal with the given arguments.\\nIf the signal is not connected, it raises a \"SignalNotConnectedError\".\"\"\"\n    if signal.is_connected:\n      signal.dispatch(*args)\n    else:\n      raise SignalNotConnectedError(f\"Signal {signal} is not connected.\")\n\n  def _async_dispatch_signal(self, signal: Signal, *args: Any) -> None:\n    \"\"\"The function \"_async_dispatch_signal\" dispatches a signal with the given arguments.\\nIf the signal is not connected, it raises a \"SignalNotConnectedError\".\"\"\"\n    if signal.is_connected:\n      signal.dispatch_async(*args)\n    else:\n      raise SignalNotConnectedError(f\"Signal {signal} is not connected.\")\n\n  def _setup_dispatcher_signal(self) -> None:\n    \"\"\"The function \"_setup_dispatcher_signal\" sets up the internal dispatcher signal.\"\"\"\n    self._internal_dispatcher_signal = Signal(self, \"internal_dispatcher_signal\")\n\n  def _setup_setup_signal(self) -> None:\n    \"\"\"The function \"_setup_setup_signal\" sets up the setup signal.\"\"\"\n    self._setup_signal = Signal(self, \"setup_signal\")\n\n  def _setup_teardown_signal(self) -> None:\n    \"\"\"The function \"_setup_teardown_signal\" sets up the teardown signal.\"\"\"\n    self._teardown_signal = Signal(self, \"teardown_signal\")\n\n  def _setup_setup_started_signal(self) -> None:\n    \"\"\"The function \"_setup_setup_started_signal\" sets up the setup started signal.\"\"\"\n    self._setup_started_signal = Signal(self, \"setup_started_signal\")\n\n  def _setup_setup_finished_signal(self) -> None:\n    \"\"\"The function \"_setup_setup_finished_signal\" sets up the setup", "CodeBleu_score": 38.97049336211455}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n      self.async_dispatcher_send(self.SIGNAL_DISPATCHER, remaining_with_setup_started)\n    else:\n      self.async_dispatcher_send(self.SIGNAL_DISPATCHER, None)\n    self._remaining_with_setup_started = remaining_with_setup_started!= {}\n\n  async def _async_run_setup(self, setup: Setup, setup_id: str, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_run_setup\" runs the setup and updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    try:\n      await setup.async_run_setup()\n    except Exception as exception:\n      self.async_send_signal(self.SIGNAL_ERROR, exception)\n    else:\n      self.async_send_signal(self.SIGNAL_SETUP_DONE, setup_id)\n    finally:\n      remaining_with_setup_started.pop(setup_id)\n      self._async_dispatch(remaining_with_setup_started)\n\n  async def _async_run_setups(self, setups: dict[str, Setup]) -> None:\n    \"\"\"The function \"_async_run_setups\" runs the setups and updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    remaining_with_setup_started: dict[str, float] = {}\n    for setup_id, setup in setups.items():\n      remaining_with_setup_started[setup_id] = time.time()\n      self._async_dispatch(remaining_with_setup_started)\n      await self._async_run_setup(setup, setup_id, remaining_with_setup_started)\n\n  def _run_setup(self, setup: Setup, setup_id: str, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_run_setup\" runs the setup and updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    try:\n      setup.run_setup()\n    except Exception as exception:\n      self.send_signal(self.SIGNAL_ERROR, exception)\n    else:\n      self.send_signal(self.SIGNAL_SETUP_DONE, setup_id)\n    finally:\n      remaining_with_setup_started.pop(setup_id)\n      self", "CodeBleu_score": 43.58215290566566}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n      self._dispatch_with_setups(remaining_with_setup_started)\n    elif self._remaining_with_setup_started:\n      self._dispatch_with_setups(self._remaining_with_setup_started)\n      self._remaining_with_setup_started = {}\n    else:\n      self._dispatch_without_setups()\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n  def _dispatch_without_setups(self) -> None:\n    \"\"\"The function \"_dispatch_without_setups\" dispatches a signal based on the state of remaining setups.\"\"\"\n    if self._remaining_without_setup_started:\n      self._dispatch_without_setups_with_remaining_setups()\n    else:\n      self._dispatch_without_setups_without_remaining_setups()\n\n  def _dispatch_without_setups_with_remaining_setups(self) -> None:\n    \"\"\"The function \"_dispatch_without_setups_with_remaining_setups\" dispatches a signal based on the state of remaining setups.\"\"\"\n    self._dispatch_without_setups_without_remaining_setups()\n    self._dispatch_with_setups(self._remaining_without_setup_started)\n    self._remaining_without_setup_started = {}\n\n  def _dispatch_without_setups_without_remaining_setups(self) -> None:\n    \"\"\"The function \"_dispatch_without_setups_without_remaining_setups\" dispatches a signal based on the state of remaining setups.\"\"\"\n    if self._remaining_with_setup_started:\n      self._dispatch_with_setups(self._remaining_with_setup_started)\n      self._remaining_with_setup_started = {}\n\n  def _dispatch_with_setups(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_dispatch_with_setups\" dispatches a signal based on the state of remaining setups.\"\"\"\n    if self._is_setup_running:\n      self._dispatch_with_setups_and_running_setup(remaining_with_setup_started)\n    else:\n      self._dispatch_with_setups_and_no_running_setup(remaining_with_setup_started)\n\n  def", "CodeBleu_score": 43.28584415637514}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # Generate the bluetooth.py content\n    content = generate(integrations, config)\n\n    # Read the current bluetooth.py content\n    try:\n        with open(config.root / \"bluetooth.py\", \"r\") as file:\n            current = file.read()\n    except FileNotFoundError:\n        current = \"\"\n\n    # Compare the current and generated bluetooth.py contents\n    if content!= current:\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            \"Run the following command to fix:\\n\\n\"\n            f\"To automatically fix, run:\\n\"\n            f\"  python3 -m homeassistant --script fix_bluetooth\\n\\n\"\n            \"To update manually, replace the content of:\\n\"\n            f\"  {config.root / 'bluetooth.py'}\\n\"\n            f\"with:\\n\\n\"\n            f\"{content}\",\n            fixable=True,\n        )\n    else:\n        config.add_job(\"bluetooth.py is up to date\", \"success\")\n\n", "CodeBleu_score": 37.56042542091102}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # Read the current content of bluetooth.py.\n    current_content: str | None = None\n    if os.path.isfile(config.path.current_file):\n        with open(config.path.current_file, \"r\") as f:\n            current_content = f.read()\n\n    # Generate the content of bluetooth.py based on the provided integrations.\n    new_content: str = generate(integrations)\n\n    # If the new content is the same as the current content, there is nothing to do.\n    if new_content == current_content:\n        return\n\n    # If the new content is different from the current content, there is a problem.\n    # Add an error to the configuration indicating that bluetooth.py is not up to date and providing a fixable suggestion.\n    config.add_error(\n        \"The content of bluetooth.py is not up to date.\",\n        \"Run the Bluetooth config flow again to update the file.\",\n        \"Update the content of bluetooth.py.\",\n        \"Update the content of bluetooth.py.\",\n    )\n\n", "CodeBleu_score": 40.37289465682853}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\n    # If no integrations are being validated, read the current content of bluetooth.py and compare it with the generated content.\n    if not integrations:\n        try:\n            with open(config.root / \"bluetooth.py\", \"r\") as f:\n                content = f.read()\n        except FileNotFoundError:\n            content = \"\"\n\n        # If the contents differ, add an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.\n        if content!= generate_content(integrations, config):\n            config.add_error(\n                \"bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n                \"bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            )\n\n    # Generate and validate the Bluetooth content based on provided integrations and store it in the configuration cache.\n    config.cache[\"bluetooth\"] = generate_content(integrations, config)\n\n", "CodeBleu_score": 46.376734800643185}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error\t// Create a request to the Dropbox OAuth2 token endpoint.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(fmt.Sprintf(\"refresh_token=%s&grant_type=refresh_token&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret)))\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers.\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request and check the response.\n\tresp, err := http.DefaultClient.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"Error refreshing access token: %s\", resp.Status)\n\t}\n\n\t// Decode the response and check for any errors.\n\tvar r struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\tif err := json.NewDecoder(resp.Body).Decode(&r); err!= nil {\n\t\treturn err\n\t}\n\tif r.AccessToken == \"\" {\n\t\treturn fmt.Errorf(\"Error refreshing access token: missing access token\")\n\t}\n\tif r.ExpiresIn == 0 {\n\t\treturn fmt.Errorf(\"Error refreshing access token: missing expires_in\")\n\t}\n\n\t// Update the access token and expiration time.\n\td.AccessToken = r.AccessToken\n\td.ExpiresAt = time.Now().Add(time.Duration(r.ExpiresIn) * time.Second)\n\n\treturn nil\n}\n", "CodeBleu_score": 46.73374043791435}, {"code": "func (d *Dropbox) refreshToken() error\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(fmt.Sprintf(\"refresh_token=%s&grant_type=refresh_token&client_id=%s&client_secret=%s\", d.refreshToken, d.appKey, d.appSecret)))\n\tif err!= nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tresp, err := http.DefaultClient.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"Dropbox returned %s: %s\", resp.Status, resp.Body)\n\t}\n\tvar r struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tif err := json.NewDecoder(resp.Body).Decode(&r); err!= nil {\n\t\treturn err\n\t}\n\td.accessToken = r.AccessToken\n\treturn nil\n}\n", "CodeBleu_score": 48.54329006404853}, {"code": "func (d *Dropbox) refreshToken() error\t// Create a request to the Dropbox OAuth2 token endpoint\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(url.Values{\"grant_type\": {\"refresh_token\"}, \"refresh_token\": {d.refreshToken}}).Encode())\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the authorization header\n\treq.Header.Add(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.appKey+\":\"+d.appSecret)))\n\n\t// Make the request\n\tresp, err := d.client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the response code\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"Dropbox API error: %s\", resp.Status)\n\t}\n\n\t// Decode the response body\n\tvar token struct {\n\t\tAccessToken  string `json:\"access_token\"`\n\t\tExpiresIn    int64  `json:\"expires_in\"`\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t\tTokenType    string `json:\"token_type\"`\n\t}\n\tif err := json.NewDecoder(resp.Body).Decode(&token); err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.accessToken = token.AccessToken\n\td.expiresAt = time.Now().Unix() + token.ExpiresIn\n\td.refreshToken = token.RefreshToken\n\n\treturn nil\n}\n", "CodeBleu_score": 46.81563840835105}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\t// Create a new HTTP request.\n\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Add the authorization header.\n\treq.Header.Add(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\t// Add the parameters for supporting all drives.\n\treq.Header.Add(\"X-Upload-Content-Type\", \"application/json\")\n\treq.Header.Add(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Add(\"X-Upload-Content-Transfer-Encoding\", \"binary\")\n\n\t// Make the request.\n\tvar response *http.Response\n\tif callback == nil {\n\t\tresponse, err = d.Client.Do(req)\n\t} else {\n\t\tresponse, err = callback(req)\n\t}\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\n\t// If a response structure is provided, set the response body.\n\tif resp!= nil {\n\t\tbody, err := ioutil.ReadAll(response.Body)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresp.(base.Response).SetBody(body)\n\t}\n\n\t// If the response status code is 401, refresh the token and try again.\n\tif response.StatusCode == http.StatusUnauthorized {\n\t\terr = d.Refresh()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\t\tif callback == nil {\n\t\t\tresponse, err = d.Client.Do(req)\n\t\t} else {\n\t\t\tresponse, err = callback(req)\n\t\t}\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer response.Body.Close()\n\t}\n\n\t// If the response status code is not 200, return an error.\n\tif response.StatusCode!= http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed: %s\", response.Status)\n\t}\n\n\t// Return the response body.\n\treturn ioutil.ReadAll(response.Body)\n}\n", "CodeBleu_score": 47.22154947908667}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\t// Create a request object.\n\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Set the authorization header.\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\t// Set the required parameters.\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/json\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\t// Set the callback function if one is provided.\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\t// Send the request.\n\tresp, err = d.Client.Do(req)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Close the response body.\n\tdefer resp.Body.Close()\n\t// Handle errors.\n\tif resp.StatusCode == 401 {\n\t\t// Refresh the token.\n\t\terr = d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Send the request again.\n\t\treturn d.request(url, method, callback, resp)\n\t} else if resp.StatusCode >= 300 {\n\t\treturn nil, errors.New(resp.Status)\n\t}\n\t// Read the response body.\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Set the response structure if one is provided.\n\tif resp!= nil {\n\t\terr = json.Unmarshal(body, resp)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// Return the response body.\n\treturn body, nil\n}\n", "CodeBleu_score": 58.20079403098827}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.AccessToken))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/json\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Transfer-Encoding\", \"binary\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/json\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Transfer-Encoding\", \"binary\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/json\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Transfer-Encoding\", \"binary\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/json\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Transfer-Encoding\", \"binary\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/json\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Transfer-Encoding\", \"binary\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/json\")\n\treq.Header.", "CodeBleu_score": 25.485687320863125}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Get the file size\n\tsize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Create a new HTTP client\n\tclient := http.Client{\n\t\tTransport: &http.Transport{\n\t\t\t// Set a 10 minute timeout for each request\n\t\t\tResponseHeaderTimeout: 10 * time.Minute,\n\t\t},\n\t}\n\n\t// Get the chunk size\n\tchunkSize, err := d.getChunkSize(ctx, size)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Upload the file in chunks\n\tfor i := 0; i < int(math.Ceil(float64(size)/float64(chunkSize))); i++ {\n\t\t// Create the request\n\t\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, nil)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the headers\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", i*chunkSize, (i*chunkSize)+chunkSize-1, size))\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\n\t\t// Send the request\n\t\tresp, err := client.Do(req)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check for context cancellation\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Check for HTTP errors\n\t\tif resp.StatusCode!= http.StatusCreated && resp.StatusCode!= http.StatusAccepted {\n\t\t\treturn fmt.Errorf(\"upload failed: %s\", resp.Status)\n\t\t}\n\t}\n\n\t// Return nil\n\treturn nil\n}\n", "CodeBleu_score": 40.34803476832876}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Get the file size\n\tsize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Get the chunk size\n\tchunkSize, err := d.getChunkSize(size)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Create the upload session\n\tuploadSession, err := d.createUploadSession(ctx, url, size)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Upload the file in chunks\n\tfor offset := int64(0); offset < size; offset += chunkSize {\n\t\t// Check if the context has been cancelled\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Get the chunk data\n\t\tchunk, err := stream.Read(offset, chunkSize)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Upload the chunk\n\t\tif err := d.uploadChunk(ctx, uploadSession, offset, chunk); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Complete the upload session\n\tif err := d.completeUploadSession(ctx, uploadSession); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 40.16393524513008}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Get the file size\n\tsize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set up the upload\n\treq, err := http.NewRequest(\"POST\", url, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the content type\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\n\t// Set the content range\n\treq.Header.Set(\"Content-Range\", \"bytes 0-\"+strconv.FormatInt(size-1, 10)+\"/*\")\n\n\t// Set the content length\n\treq.Header.Set(\"Content-Length\", strconv.FormatInt(size, 10))\n\n\t// Set the upload type\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\n\t// Set the upload length\n\treq.Header.Set(\"X-Upload-Content-Length\", strconv.FormatInt(size, 10))\n\n\t// Send the request\n\tresp, err := http.DefaultClient.Do(req.WithContext(ctx))\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the status code\n\tif resp.StatusCode!= http.StatusCreated {\n\t\treturn fmt.Errorf(\"invalid status code: %d\", resp.StatusCode)\n\t}\n\n\t// Get the upload URL\n\tlocation := resp.Header.Get(\"Location\")\n\tif location == \"\" {\n\t\treturn fmt.Errorf(\"missing location header\")\n\t}\n\n\t// Upload the chunks\n\tvar uploaded int64\n\tfor uploaded < size {\n\t\t// Check for context cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Get the chunk size\n\t\tchunkSize := int64(math.Min(float64(chunkSize), float64(size-uploaded)))\n\n\t\t// Read the chunk\n\t\tchunk, err := stream.Read(chunkSize)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create the request\n\t\treq, err := http.NewRequest(\"PUT\", location, bytes.NewReader(chunk))\n\t\tif err!= nil {\n\t\t\treturn", "CodeBleu_score": 44.1338650344693}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error\tmountPoint := ctx.FormValue(\"mount_point\")\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"missing mount point\"})\n\t}\n\tif err := unmountStorage(mountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\tif err := deleteStorageConfig(mountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"success\": \"storage unmounted\"})\n}\n", "CodeBleu_score": 33.85449395764889}, {"code": "func UmountStorage(ctx echo.Context) error\t// Bind the JSON data from the request context.\n\tvar jsonData map[string]string\n\tif err := ctx.Bind(&jsonData); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid request payload\")\n\t}\n\n\t// Retrieve the \"mount_point\" value from the JSON data.\n\tmountPoint := jsonData[\"mount_point\"]\n\tif mountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid request payload\")\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := storage.Unmount(mountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to unmount storage\")\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err := storage.DeleteConfig(mountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete storage configuration\")\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"status\": \"success\",\n\t})\n}\n", "CodeBleu_score": 39.413262887216085}, {"code": "func UmountStorage(ctx echo.Context) error\t// Bind the JSON data from the request context to a struct.\n\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Check if the mount point is empty.\n\tif req.MountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"mount_point cannot be empty\")\n\t}\n\n\t// Unmount the storage.\n\tif err := storage.Umount(req.MountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the storage configuration.\n\tif err := config.Delete(req.MountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusNoContent)\n}\n", "CodeBleu_score": 35.76167642525077}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error\t// Extract the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\t// If the path is missing, return an error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"missing path\"})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// If the file does not exist, return an error message.\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"file not found\"})\n\t}\n\n\t// If the file exists, return the file to the client.\n\treturn ctx.File(filePath)\n}\n", "CodeBleu_score": 35.99465042619306}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Extract the path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"path is missing\"})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"file does not exist\"})\n\t}\n\n\t// Open the file.\n\tfile, err := os.Open(path)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"could not open file\"})\n\t}\n\tdefer file.Close()\n\n\t// Create a response writer.\n\twriter := ctx.Response()\n\n\t// Copy the file to the response writer.\n\t_, err = io.Copy(writer, file)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"could not copy file\"})\n\t}\n\n\t// Set the content type.\n\twriter.Header().Set(echo.HeaderContentType, echo.MIMEOctetStream)\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"success\": \"file downloaded successfully\"})\n}\n", "CodeBleu_score": 37.254536596220206}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"path query parameter is missing\",\n\t\t})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"file not found\",\n\t\t})\n\t}\n\n\t// Open the file and send it to the client.\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": \"failed to open file\",\n\t\t})\n\t}\n\tdefer file.Close()\n\n\treturn ctx.Stream(http.StatusOK, mime.TypeByExtension(path.Ext(filePath)), file)\n}\n", "CodeBleu_score": 36.98447040263571}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\tif err := Notify(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"status\": \"ok\",\n\t})\n}\n", "CodeBleu_score": 49.42209875919698}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tvar msg map[string]interface{}\n\tif err := ctx.Bind(&msg); err!= nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\terr := notify.Post(name, msg)\n\tif err!= nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\treturn ctx.NoContent(http.StatusOK)\n}\n", "CodeBleu_score": 43.64371961313879}, {"code": "func PostNotifyMessage(ctx echo.Context) error\t// Bind the request body to a message map.\n\tvar msg map[string]interface{}\n\tif err := ctx.Bind(&msg); err!= nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Get the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Send the notification.\n\terr := notify.Send(ctx.Request().Context(), name, msg)\n\tif err!= nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusOK)\n}\n", "CodeBleu_score": 44.50133790459417}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP connection to a WebSocket connection.\n\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Register the new WebSocket connection with the message sending service.\n\tconnections = append(connections, ws)\n\tgo messageSender()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"Received message type %d and message %s\\n\", messageType, message)\n\t}\n}\n", "CodeBleu_score": 40.98970950357326}, {"code": "func NotifyWS(ctx echo.Context) error\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// add the new connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// start the message sending service\n\tgo sendMessages()\n\n\t// start reading messages from the WebSocket connection\n\tfor {\n\t\t// read a message from the WebSocket connection\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tlog.Println(err)\n\t\t\treturn err\n\t\t}\n\n\t\t// print the message type, message, and any errors\n\t\tlog.Printf(\"Received %s message: %s\", mt, message)\n\t\tif err!= nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.42351249249472}, {"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP GET request to a WebSocket connection.\n\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running.\n\tgo sendMessages()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\t// Check if the error is due to the WebSocket connection being closed.\n\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t// The WebSocket connection is closed.\n\t\t\t\tfmt.Println(\"Connection closed by client.\")\n\t\t\t} else {\n\t\t\t\t// The WebSocket connection is not closed.\n\t\t\t\tfmt.Println(\"Error reading from WebSocket connection:\", err)\n\t\t\t}\n\t\t\t// Remove the WebSocket connection from the list of connections.\n\t\t\tconnections = removeConnection(connections, ws)\n\t\t\t// Exit the loop.\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Printf(\"Message type: %d\\nMessage: %s\\nError: %s\\n\", messageType, message, err)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 43.52292646361423}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get the request body\n\treq := ctx.Request()\n\tvar request GetSystemHardwareInfoRequest\n\tif err := json.NewDecoder(req.Body).Decode(&request); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Error parsing request body: %s\", err))\n\t}\n\t// Check if the request body is empty\n\tif reflect.DeepEqual(request, GetSystemHardwareInfoRequest{}) {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Empty request body\"))\n\t}\n\t// Call the function \"GetSystemHardwareInfo\"\n\tresponse, err := GetSystemHardwareInfoFunc(request)\n\tif err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Error processing request: %s\", err))\n\t}\n\t// Return the response\n\treturn ctx.JSON(http.StatusOK, response)\n}\n", "CodeBleu_score": 19.372241518004934}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get the input data from the request body.\n\tvar jsonData map[string]interface{}\n\tif err := json.NewDecoder(ctx.Request().Body).Decode(&jsonData); err!= nil {\n\t\treturn ctx.String(http.StatusBadRequest, \"Invalid JSON input.\")\n\t}\n\n\t// Create a new SystemHardwareInfo object.\n\tsystemHardwareInfo := models.SystemHardwareInfo{}\n\n\t// Get the drive model and architecture.\n\tdriveModel, driveArchitecture, err := systemHardwareInfo.GetDriveModelAndArchitecture()\n\tif err!= nil {\n\t\treturn ctx.String(http.StatusInternalServerError, \"Failed to get drive model and architecture: \"+err.Error())\n\t}\n\n\t// Get the CPU information.\n\tcpuInfo, err := systemHardwareInfo.GetCPUInfo()\n\tif err!= nil {\n\t\treturn ctx.String(http.StatusInternalServerError, \"Failed to get CPU info: \"+err.Error())\n\t}\n\n\t// Create a map to store the data.\n\tdata := map[string]interface{}{\n\t\t\"driveModel\":      driveModel,\n\t\t\"driveArchitecture\": driveArchitecture,\n\t\t\"cpuInfo\":         cpuInfo,\n\t}\n\n\t// Return the data.\n\treturn ctx.JSON(http.StatusOK, data)\n}\n", "CodeBleu_score": 20.82306755394907}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get the hardware information from the system.\n\thardwareInfo := hardware.GetHardwareInfo()\n\n\t// Return the response as a JSON object.\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}\n", "CodeBleu_score": 8.160235834568583}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}\n", "CodeBleu_score": 68.76355944771844}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}\n", "CodeBleu_score": 73.83480124756016}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif strings.Contains(service, \"running\") {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}\n", "CodeBleu_score": 60.073615186028185}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message to JSON: %v\", err)\n\t\treturn\n\t}\n\n\tresponse, err := i.client.Publish(context.Background(), name, jsonMessage)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to publish message: %v\", err)\n\t\treturn\n\t}\n\n\tif response.StatusCode!= http.StatusOK {\n\t\tlog.Printf(\"Failed to publish message: %s\", response.Status)\n\t}\n}\n", "CodeBleu_score": 33.948796571588026}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\t// Serialize the message values to JSON strings.\n\tserializedMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message: %s\", err)\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse, err := i.publisher.Publish(name, serializedMessage)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to publish message: %s\", err)\n\t\treturn\n\t}\n\n\t// Check the response status code.\n\tif response.StatusCode!= http.StatusOK {\n\t\tlog.Printf(\"Failed to publish message: %s\", response.Status)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 33.21897824109826}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tif i.client == nil {\n\t\treturn\n\t}\n\tbody, err := json.Marshal(message)\n\tif err!= nil {\n\t\ti.logger.Error(\"failed to serialize message: %s\", err)\n\t\treturn\n\t}\n\ttopic := fmt.Sprintf(\"%s.%s\", i.topicPrefix, name)\n\ti.logger.Debug(\"publishing to topic %s: %s\", topic, string(body))\n\terr = i.client.Publish(topic, body)\n\tif err!= nil {\n\t\ti.logger.Error(\"failed to publish event: %s\", err)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 31.354897680709616}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(c.server)\n\treturn client\n}\n", "CodeBleu_score": 9.66024384070573}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\treturn message_bus.NewClientWithResponses(c.server)\n}\n", "CodeBleu_score": 7.081268823626069}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\treturn message_bus.NewClientWithResponses(c.server)\n}\n", "CodeBleu_score": 7.081268823626069}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \",\")[0]\n\tip = strings.TrimSpace(ip)\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" || ip == \"127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 68.05638987488545}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif len(ip) == 0 {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \",\")[0]\n\tip = strings.TrimSpace(ip)\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" || ip == \"127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 67.08957726420243}, {"code": "func GetIP(request *http.Request) string\tif xff := request.Header.Get(\"x-forwarded-for\"); xff!= \"\" {\n\t\tip := strings.Split(xff, \", \")[0]\n\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\treturn \"127.0.0.1\"\n\t\t}\n\t\treturn ip\n\t}\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\treturn ip\n}\n", "CodeBleu_score": 46.68221621287627}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\tvar entry []byte\n\tvar err error\n\tvar entryFiles []string\n\tvar moduleDir string\n\n\t// Get the modules directory path\n\tmoduleDir = c.GetModulesDirectory()\n\n\t// Get the entry files\n\tentryFiles = c.GetEntryFiles(moduleDir)\n\n\t// Concatenate the entries\n\tfor _, entryFile := range entryFiles {\n\t\tentry, err = c.ReadEntryFile(entryFile)\n\t\tif err!= nil {\n\t\t\tc.Log.Error(err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tentry = append(entry, []byte(\",\")...)\n\t\tentry = append(entry, []byte(\"\\n\")...)\n\t}\n\tentry = entry[:len(entry)-2]\n\n\t// Write the entry\n\terr = c.WriteEntryFile(entry)\n\tif err!= nil {\n\t\tc.Log.Error(err.Error())\n\t}\n}\n", "CodeBleu_score": 17.40501538617108}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Get the list of module directories\n\tmodulesDir := c.GetModulesDir()\n\tmoduleDirs, err := ioutil.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tc.logger.Error(\"Unable to read modules directory\", zap.String(\"path\", modulesDir), zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create the entry file\n\tentryFilePath := filepath.Join(modulesDir, \"entry.json\")\n\tentryFile, err := os.Create(entryFilePath)\n\tif err!= nil {\n\t\tc.logger.Error(\"Unable to create entry file\", zap.String(\"path\", entryFilePath), zap.Error(err))\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\t// Create the entry file writer\n\tentryFileWriter := bufio.NewWriter(entryFile)\n\tdefer entryFileWriter.Flush()\n\n\t// Create the entry file JSON encoder\n\tentryFileEncoder := json.NewEncoder(entryFileWriter)\n\n\t// Create the entry file JSON array\n\tentryFileArray := make([]interface{}, 0)\n\n\t// Iterate over each module directory\n\tfor _, moduleDir := range moduleDirs {\n\t\t// Skip non-directory entries\n\t\tif!moduleDir.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the module directory path\n\t\tmoduleDirPath := filepath.Join(modulesDir, moduleDir.Name())\n\n\t\t// Get the module entry file path\n\t\tmoduleEntryFilePath := filepath.Join(moduleDirPath, \"entry.json\")\n\n\t\t// Read the module entry file\n\t\tmoduleEntryFile, err := os.Open(moduleEntryFilePath)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Unable to read module entry file\", zap.String(\"path\", moduleEntryFilePath), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer moduleEntryFile.Close()\n\n\t\t// Create the module entry file reader\n\t\tmoduleEntryFileReader := bufio.NewReader(moduleEntryFile)\n\n\t\t// Create the module entry file decoder\n\t\tmoduleEntryFileDecoder := json.NewDecoder(moduleEntryFileReader)\n\n\t\t// Decode the module entry file\n\t\tmoduleEntryFileData := make([]interface{}, 0)\n\t\terr = moduleEntryFileDecoder.Decode(&moduleEntryFileData)\n\t\tif err!= nil {\n\t\t\tc.", "CodeBleu_score": 38.662199281306954}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Get the module directory path.\n\tmoduleDirectory := c.GetModuleDirectoryPath()\n\n\t// Get the entry file path.\n\tentryFilePath := c.GetEntryFilePath()\n\n\t// Create the entry file if it does not exist.\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tfile, err := os.Create(entryFilePath)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Failed to create entry file: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\t}\n\n\t// Get all the module directories.\n\tmoduleDirectories, err := ioutil.ReadDir(moduleDirectory)\n\tif err!= nil {\n\t\tc.logger.Error(\"Failed to read module directory: %s\", err)\n\t\treturn\n\t}\n\n\t// Create a slice of module entries.\n\tmoduleEntries := []moduleEntry{}\n\n\t// Loop through each module directory.\n\tfor _, moduleDirectory := range moduleDirectories {\n\t\t// Get the module directory name.\n\t\tmoduleDirectoryName := moduleDirectory.Name()\n\n\t\t// Get the module directory path.\n\t\tmoduleDirectoryPath := path.Join(moduleDirectory.Name())\n\n\t\t// Get the module entry file path.\n\t\tmoduleEntryFilePath := path.Join(moduleDirectoryPath, \"entry.json\")\n\n\t\t// Check if the module entry file exists.\n\t\tif _, err := os.Stat(moduleEntryFilePath); os.IsNotExist(err) {\n\t\t\tc.logger.Warn(\"Module directory %s does not contain an entry file\", moduleDirectoryPath)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Read the module entry file.\n\t\tmoduleEntryFile, err := ioutil.ReadFile(moduleEntryFilePath)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Failed to read module entry file: %s\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Unmarshal the module entry file.\n\t\tvar moduleEntry moduleEntry\n\t\terr = json.Unmarshal(moduleEntryFile, &moduleEntry)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Failed to unmarshal module entry file: %s\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the module entry to the slice of module entries.\n\t\tmoduleEntries = append(moduleEntries, moduleEntry)\n\t}\n\n\t// Create a", "CodeBleu_score": 40.54392807090124}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) \tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tif iface.Name == \"eth0\" {\n\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching interface found.\")\n}\n", "CodeBleu_score": 50.803109054467946}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\tif i.Name == \"eth0\" {\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no eth0 interface found\")\n}\n", "CodeBleu_score": 53.074189346017555}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tif iface.Name == \"eth0\" {\n\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching interface found\")\n}\n", "CodeBleu_score": 50.80261378974799}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t status = 0;\n\tuint32_t index = 0;\n\tSRequestObj *pRequestList = NULL;\n\tSRequestSummary *pRequestSummary = NULL;\n\tSTscObj *pTscList = NULL;\n\tSTscObj *pTmpTsc = NULL;\n\tSApplicationObj *pApplication = NULL;\n\tSApplicationObj *pTmpApplication = NULL;\n\tuint32_t requestCount = 0;\n\tuint32_t totalRequestCount = 0;\n\n\t/*\n\t * Check parameters\n\t */\n\tif (pRequest == NULL) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (pTscObj == NULL) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Add the request to the list of requests for the TSC object.\n\t */\n\tpRequestList = pTscObj->pRequestList;\n\tif (pRequestList == NULL) {\n\t\tpRequestList = pRequest;\n\t\tpTscObj->pRequestList = pRequestList;\n\t} else {\n\t\twhile (pRequestList->pNext!= NULL) {\n\t\t\tpRequestList = pRequestList->pNext;\n\t\t}\n\t\tpRequestList->pNext = pRequest;\n\t}\n\tpTscObj->requestCount++;\n\n\t/*\n\t * Update the request summary for the TSC object.\n\t */\n\tpRequestSummary = &pTscObj->requestSummary;\n\tpRequestSummary->totalRequestCount++;\n\tpRequestSummary->currentRequestCount++;\n\n\t/*\n\t * Update the application's request summary if it has application information.\n\t */\n\tpApplication = pTscObj->pApplication;\n\tif (pApplication!= NULL) {\n\t\tpTmpApplication = pApplication;\n\t\twhile (pTmpApplication!= NULL) {\n\t\t\tpRequestSummary = &pTmpApplication->requestSummary;\n\t\t\tpRequestSummary->totalRequestCount++;\n\t\t\tpRequestSummary->currentRequestCount++;\n\t\t\tpTmpApplication = pTmpApplication->pNext;\n\t\t}\n\t}\n\n\t/*\n\t * Update the request summary for the TSC list.\n\t */\n\tpTscList = g_pTscList;\n\twhile (pTscList!= NULL)", "CodeBleu_score": 33.92219731371311}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t ret = 0;\n\tint32_t i;\n\n\tif (pRequest == NULL) {\n\t\tret = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\tret = -1;\n\t\tgoto cleanup;\n\t}\n\n\t/* Increment the request count for the TSC object */\n\tpTscObj->requestCount++;\n\n\t/* Update the application's request summary */\n\tif (pTscObj->appInfo!= NULL) {\n\t\t/* Increment the total request count */\n\t\tpTscObj->appInfo->totalRequestCount++;\n\n\t\t/* Increment the current request count */\n\t\tfor (i = 0; i < TSC_NUM_REQUEST_TYPES; i++) {\n\t\t\tif (pRequest->type == i) {\n\t\t\t\tpTscObj->appInfo->currentRequestCount[i]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n", "CodeBleu_score": 29.652832755851527}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t status = 0;\n\tint32_t i = 0;\n\tint32_t found = 0;\n\n\t/*\n\t * Check parameters\n\t */\n\tif ((NULL == pRequest) || (NULL == pTscObj)) {\n\t\tstatus = -1;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Add a reference to the request object\n\t */\n\tstatus = addRequestRef(pRequest, pTscObj);\n\tif (0!= status) {\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Increment the request count for the associated TSC object\n\t */\n\tstatus = pthread_mutex_lock(&pTscObj->lock);\n\tif (0!= status) {\n\t\tgoto cleanup;\n\t}\n\n\tpTscObj->requestCount++;\n\n\tstatus = pthread_mutex_unlock(&pTscObj->lock);\n\tif (0!= status) {\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts\n\t */\n\tif (NULL!= pTscObj->pAppObj) {\n\t\tstatus = pthread_mutex_lock(&pTscObj->pAppObj->lock);\n\t\tif (0!= status) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/*\n\t\t * Search for the application in the list of applications\n\t\t */\n\t\tfor (i = 0; i < pTscObj->pAppObj->appCount; i++) {\n\t\t\tif (pTscObj->pAppObj->pAppList[i] == pTscObj->pAppObj) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the application is not found, add it to the list\n\t\t */\n\t\tif (0 == found) {\n\t\t\tpTscObj->pAppObj->pAppList[pTscObj->pAppObj->appCount] = pTscObj->pAppObj;\n\t\t\tpTscObj->pAppObj->appCount++;\n\t\t}\n\n\t\t/*\n\t\t * Update the application's request summary\n\t\t */\n\t\tpTscObj->pAppObj->requestCount++;\n\t\tpTscObj->pAppObj->currentRequestCount++;\n\n\t\tstatus = pthread_", "CodeBleu_score": 37.1631478793752}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tchar *db = pRequest->primaryDb;\n\tchar *p;\n\tif (db == NULL) {\n\t\treturn false;\n\t}\n\tp = strchr(db, '.');\n\tif (p!= NULL) {\n\t\tdb = p + 1;\n\t}\n\tif (strcmp(exceptDb, db) == 0) {\n\t\treturn false;\n\t}\n\twhile (pRequest!= NULL) {\n\t\tdb = pRequest->primaryDb;\n\t\tp = strchr(db, '.');\n\t\tif (p!= NULL) {\n\t\t\tdb = p + 1;\n\t\t}\n\t\tif (strcmp(exceptDb, db) == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tpRequest = pRequest->next;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 50.973478123271306}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tchar *requestDb = pRequest->database;\n\tif (requestDb == NULL) {\n\t\treturn true;\n\t}\n\tif (strcmp(requestDb, exceptDb)!= 0) {\n\t\tint i;\n\t\tfor (i = 0; i < pRequest->numDbs; i++) {\n\t\t\tif (strncmp(pRequest->dbList[i], exceptDb, strlen(exceptDb)) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 40.866155214009495}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tchar* primaryDb = pRequest->primaryDb;\n\tif (strcmp(primaryDb, exceptDb)!= 0) {\n\t\tchar* dbName = pRequest->dbName;\n\t\tif (dbName!= NULL) {\n\t\t\twhile (dbName[0] == '`' || dbName[0] == '\\\\') {\n\t\t\t\tdbName++;\n\t\t\t}\n\t\t\twhile (dbName[0]!= '\\0' && (dbName[0]!= '`' && dbName[0]!= '\\\\')) {\n\t\t\t\tdbName++;\n\t\t\t}\n\t\t\tif (dbName[0] == '\\0') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tdbName--;\n\t\t\twhile (dbName[0] == '`' || dbName[0] == '\\\\') {\n\t\t\t\tdbName--;\n\t\t\t}\n\t\t\tdbName++;\n\t\t\tif (strcmp(dbName, exceptDb) == 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 31.412052903946346}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tswitch(code) {\n\t\tcase RPC_ERROR_AUTH_FAILED:\n\t\tcase RPC_ERROR_NOT_AUTHORIZED:\n\t\tcase RPC_ERROR_NOT_ALLOWED:\n\t\tcase RPC_ERROR_NOT_FOUND:\n\t\tcase RPC_ERROR_NO_RESOURCES:\n\t\tcase RPC_ERROR_ALREADY_EXISTS:\n\t\tcase RPC_ERROR_TOO_LARGE:\n\t\tcase RPC_ERROR_INVALID_ARGS:\n\t\tcase RPC_ERROR_INVALID_RPC:\n\t\tcase RPC_ERROR_SERVER_ERROR:\n\t\tcase RPC_ERROR_TIMEOUT:\n\t\tcase RPC_ERROR_BUSY:\n\t\tcase RPC_ERROR_UNSUPPORTED:\n\t\tcase RPC_ERROR_UNAVAILABLE:\n\t\tcase RPC_ERROR_INTERNAL:\n\t\tcase RPC_ERROR_UNKNOWN:\n\t\t\treturn true;\n\t\tcase RPC_ERROR_NONE:\n\t\t\tswitch(msgType) {\n\t\t\t\tcase TMSG_OPEN_SESSION_REQ:\n\t\t\t\tcase TMSG_CLOSE_SESSION_REQ:\n\t\t\t\tcase TMSG_SESSION_HEARTBEAT_REQ:\n\t\t\t\tcase TMSG_SESSION_HEARTBEAT_RESP:\n\t\t\t\tcase TMSG_RPC_CALL_REQ:\n\t\t\t\tcase TMSG_RPC_CALL_RESP:\n\t\t\t\tcase TMSG_RPC_CANCEL_REQ:\n\t\t\t\tcase TMSG_RPC_RESULT_REQ:\n\t\t\t\tcase TMSG_RPC_RESULT_RESP:\n\t\t\t\tcase TMSG_RPC_ERROR_RESP:\n\t\t\t\tcase TMSG_RPC_STREAM_REQ:\n\t\t\t\tcase TMSG_RPC_STREAM_RESP:\n\t\t\t\tcase TMSG_RPC_STREAM_DATA:\n\t\t\t\tcase TMSG_RPC_STREAM_CLOSE:\n\t\t\t\tcase TMSG_RPC_PING_REQ:\n\t\t\t\tcase TMSG_RPC_PING_RESP:\n\t\t\t\t\treturn true;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 27.990590076024112}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tif (code == -1) {\n\t\treturn true;\n\t} else if (code == -2) {\n\t\treturn true;\n\t} else if (code == -3) {\n\t\treturn true;\n\t} else if (code == -4) {\n\t\treturn true;\n\t} else if (code == -5) {\n\t\treturn true;\n\t} else if (code == -6) {\n\t\treturn true;\n\t} else if (code == -7) {\n\t\treturn true;\n\t} else if (code == -8) {\n\t\treturn true;\n\t} else if (code == -9) {\n\t\treturn true;\n\t} else if (code == -10) {\n\t\treturn true;\n\t} else if (code == -11) {\n\t\treturn true;\n\t} else if (code == -12) {\n\t\treturn true;\n\t} else if (code == -13) {\n\t\treturn true;\n\t} else if (code == -14) {\n\t\treturn true;\n\t} else if (code == -15) {\n\t\treturn true;\n\t} else if (code == -16) {\n\t\treturn true;\n\t} else if (code == -17) {\n\t\treturn true;\n\t} else if (code == -18) {\n\t\treturn true;\n\t} else if (code == -19) {\n\t\treturn true;\n\t} else if (code == -20) {\n\t\treturn true;\n\t} else if (code == -21) {\n\t\treturn true;\n\t} else if (code == -22) {\n\t\treturn true;\n\t} else if (code == -23) {\n\t\treturn true;\n\t} else if (code == -24) {\n\t\treturn true;\n\t} else if (code == -25) {\n\t\treturn true;\n\t} else if (code == -26) {\n\t\treturn true;\n\t} else if (code == -27) {\n\t\treturn true;\n\t} else if (code == -28) {\n\t\treturn true;\n\t} else if (code == -29) {\n\t\treturn true;\n\t", "CodeBleu_score": 32.775916148740514}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tswitch(code) {\n\t\tcase -EPERM:\n\t\tcase -EACCES:\n\t\tcase -EFAULT:\n\t\tcase -EINTR:\n\t\tcase -EBUSY:\n\t\tcase -EAGAIN:\n\t\tcase -ENODEV:\n\t\tcase -EEXIST:\n\t\tcase -EIO:\n\t\tcase -EPIPE:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC:\n\t\tcase -EFBIG:\n\t\tcase -ENOSPC", "CodeBleu_score": 29.941008296449972}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests)\tif(pRequests == NULL) {\n\t\treturn;\n\t}\n\n\t// Iterate through the hash table\n\tSHashIter iter;\n\tSHashObj *pRequest;\n\tfor(pRequest = SHashIter_init(&iter, pRequests); pRequest!= NULL; pRequest = SHashIter_next(&iter)) {\n\t\t// Get the request ID\n\t\tint64_t requestID = (int64_t)SHashObj_getInt64(pRequest, \"requestID\");\n\n\t\t// Stop the query associated with the request if it is valid\n\t\tif(requestID >= 0) {\n\t\t\t// Stop the query\n\t\t\tstopRequest(requestID);\n\n\t\t\t// Release the request\n\t\t\treleaseRequest(requestID);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.60077641790381}, {"code": "void stopAllRequests(SHashObj *pRequests)\tif (pRequests == NULL) return;\n\tSHashIter *pIter = NULL;\n\tSRequest *pRequest = NULL;\n\tSQuery *pQuery = NULL;\n\tpIter = s_hash_iter_new(pRequests);\n\twhile ((pRequest = (SRequest *)s_hash_iter_next(pIter))!= NULL) {\n\t\tif (pRequest->status == REQUEST_STATUS_RUNNING) {\n\t\t\tpQuery = pRequest->pQuery;\n\t\t\tif (pQuery!= NULL) {\n\t\t\t\ts_query_stop(pQuery);\n\t\t\t\ts_query_release(pQuery);\n\t\t\t}\n\t\t}\n\t\ts_request_release(pRequest);\n\t}\n\ts_hash_iter_free(pIter);\n}\n", "CodeBleu_score": 40.49914699845313}, {"code": "void stopAllRequests(SHashObj *pRequests)\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\t// Iterate through the hash table\n\tSHashIter *pIter = hash_iter_new(pRequests);\n\twhile (hash_iter_hasnext(pIter)) {\n\t\t// Get the next request\n\t\tRequest *pRequest = (Request *) hash_iter_next_value(pIter);\n\n\t\t// If the request is valid, stop the query\n\t\tif (pRequest!= NULL) {\n\t\t\t// Stop the query\n\t\t\tstopQuery(pRequest->pQuery);\n\n\t\t\t// Release the request\n\t\t\treleaseRequest(pRequest);\n\t\t}\n\t}\n\thash_iter_delete(pIter);\n}\n", "CodeBleu_score": 41.93582780441933}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport()\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tif (__sync_bool_compare_and_swap(&clientStop, 0, 1)) {\n\t\twhile (clientStop!= 0) {\n\t\t\tusleep(10000);\n\t\t}\n\t} else {\n\t\ttscLog(\"Crash report thread already stopped\\n\");\n\t}\n}\n", "CodeBleu_score": 45.81899341074658}, {"code": "void tscStopCrashReport()\t// Check if crash reporting is enabled.\n\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\n\t// Attempt to set the clientStop flag to 1 using an atomic compare-and-exchange operation.\n\tif (0 == atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n\t\t// The operation failed.\n\t\ttscLogMessage(TSC_LOG_TYPE_ERROR, \"Crash report thread already stopped.\");\n\t\treturn;\n\t}\n\n\t// Wait in a loop until the clientStop flag becomes 0, indicating the thread has stopped.\n\twhile (clientStop) {\n\t\ttscSleep(1);\n\t}\n}\n", "CodeBleu_score": 53.70646715396654}, {"code": "void tscStopCrashReport()\tif (tscCrashReportingEnabled) {\n\t\tint32_t oldVal = 0;\n\t\tint32_t newVal = 1;\n\t\tif (tscAtomicCompareAndExchangeInt32(&tscClientStop, &oldVal, newVal)) {\n\t\t\twhile (tscClientStop) {\n\t\t\t\ttscSleep(1000);\n\t\t\t}\n\t\t} else {\n\t\t\ttscLogMessage(\"Crash report thread already stopped.\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.431179512440885}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\n\tstruct HB_ViewInfoResponse *pViewInfoRsp;\n\tint32_t rc;\n\tint32_t i;\n\tint32_t j;\n\tint32_t numViews;\n\tint32_t numCols;\n\tint32_t numRows;\n\tint32_t numBytes;\n\tint32_t numColsInView;\n\tint32_t numBytesInView;\n\tint32_t numRowsInView;\n\tint32_t numBytesInViewRow;\n\tint32_t numBytesInViewCol;\n\tint32_t numBytesInViewRowCol;\n\tint32_t numBytesInViewRowColValue;\n\tint32_t numBytesInViewRowColValueSize;\n\tint32_t numBytesInViewRowColValueData;\n\tint32_t numBytesInViewRowColValueDataLen;\n\tint32_t numBytesInViewRowColValueDataOffset;\n\tint32_t numBytesInViewRowColValueDataOffsetLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffset;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetDataLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetDataOffsetLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetDataOffsetDataLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetDataOffsetDataOffsetLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetDataOffsetDataOffsetDataLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetDataOffsetDataOffsetDataOffsetLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetDataOffsetDataOffsetDataOffsetDataLen;\n\tint32_t numBytesInViewRowColValueDataOffsetDataOffsetDataOffsetDataOffsetDataOffsetDataOffsetLen;\n", "CodeBleu_score": 4.878898396216548}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\n\tint32_t rc = 0;\n\tstruct SDescriptorArray *pDescriptorArray = NULL;\n\tstruct SDescriptor *pDescriptor = NULL;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t numDescriptors = 0;\n\tint32_t numColumns = 0;\n\tint32_t numRows = 0;\n\tint32_t numColumnsInView = 0;\n\tstruct SDescriptorArray *pViewDescriptorArray = NULL;\n\tstruct SDescriptor *pViewDescriptor = NULL;\n\tint32_t numViewDescriptors = 0;\n\tstruct SColumnArray *pColumnArray = NULL;\n\tstruct SColumn *pColumn = NULL;\n\tstruct SColumn *pViewColumn = NULL;\n\tint32_t numColumnsInViewIndex = 0;\n\tint32_t numColumnsInViewIndex2 = 0;\n\tint32_t numColumnsInViewIndex3 = 0;\n\tint32_t numColumnsInViewIndex4 = 0;\n\tint32_t numColumnsInViewIndex5 = 0;\n\tint32_t numColumnsInViewIndex6 = 0;\n\tint32_t numColumnsInViewIndex7 = 0;\n\tint32_t numColumnsInViewIndex8 = 0;\n\tint32_t numColumnsInViewIndex9 = 0;\n\tint32_t numColumnsInViewIndex10 = 0;\n\tint32_t numColumnsInViewIndex11 = 0;\n\tint32_t numColumnsInViewIndex12 = 0;\n\tint32_t numColumnsInViewIndex13 = 0;\n\tint32_t numColumnsInViewIndex14 = 0;\n\tint32_t numColumnsInViewIndex15 = 0;\n\tint32_t numColumnsInViewIndex16 = 0;\n\tint32_t numColumnsInViewIndex17 = 0;\n\tint32_t numColumnsInViewIndex18 = 0;\n\tint32_t num", "CodeBleu_score": 7.1217223276918356}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\n\tint32_t rc = 0;\n\tstruct SViewInfo *pViewInfo = NULL;\n\tstruct SViewInfo *pViewInfoTmp = NULL;\n\tstruct SColumnInfo *pColumnInfo = NULL;\n\tstruct SColumnInfo *pColumnInfoTmp = NULL;\n\tstruct SColumnInfo *pColumnInfoPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoNext = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmp = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmp = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpNext = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpNext = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpPrevPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpPrevPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpNextNext = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpNextNext = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpNextPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpNextPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpPrevNext = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpPrevNext = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpPrevPrevNext = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpPrevPrevNext = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpPrevPrevPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpPrevPrevPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpNextPrevNext = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpNextPrevNext = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpPrevNextNext = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpPrevNextNext = NULL;\n\tstruct SColumnInfo *pColumnInfoPrevTmpNextPrevPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoNextTmpNextPrevPrev = NULL;\n\tstruct SColumnInfo *p", "CodeBleu_score": 3.8937534153335305}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tif (properties->contentLength > 0) {\n\t\t((PutObjectData *) callbackData)->contentLength = properties->contentLength;\n\t} else {\n\t\t((PutObjectData *) callbackData)->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}\n", "CodeBleu_score": 65.94917242925835}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tstruct callbackData *data = (struct callbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\n\treturn S3StatusOK;\n}\n", "CodeBleu_score": 75.48991665100854}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)\tS3Status status = S3StatusOK;\n\tstruct S3PutObjectContext *context = (struct S3PutObjectContext *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tcontext->contentLength = properties->contentLength;\n\t} else {\n\t\tcontext->contentLength = 0;\n\t}\n\n\treturn status;\n}\n", "CodeBleu_score": 70.41978108810721}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync()\tint ret;\n\tchar *cmd;\n\n\t// Create checkpoint backup directory\n\tret = mkdir(checkpointBackupDir, 0700);\n\tif (ret < 0) {\n\t\tperror(\"Error creating checkpoint backup directory\");\n\t\treturn;\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDirs();\n\n\t// Generate Rsync configuration file\n\tif (!generateRsyncConfigFile()) {\n\t\treturn;\n\t}\n\n\t// Construct and execute command to start Rsync daemon\n\tcmd = (char *) malloc(sizeof(char) * 1000);\n\tsprintf(cmd, \"rsync --daemon --port=%d --config=%s\", rsyncPort, rsyncConfigFile);\n\tret = system(cmd);\n\tfree(cmd);\n\n\t// Log success or failure\n\tif (ret == 0) {\n\t\tprintf(\"Rsync server started successfully\\n\");\n\t} else {\n\t\tperror(\"Error starting Rsync server\");\n\t}\n}\n", "CodeBleu_score": 29.860229031135344}, {"code": "void startRsync()\tchar *checkpointDir = \" + checkpointDir + \";\n\tchar *rsyncConf = \" + rsyncConf + \";\n\tchar *rsyncCommand = \" + rsyncCommand + \";\n\tchar *rsyncPort = \" + rsyncPort + \";\n\tchar *rsyncUser = \" + rsyncUser + \";\n\tchar *rsyncPassword = \" + rsyncPassword + \";\n\n\t// Create the checkpoint backup directory\n\tif (mkdir(checkpointDir, 0700) == -1) {\n\t\tperror(\" + perrorMsg1 + \");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDirs(checkpointDir);\n\n\t// Generate the Rsync configuration file\n\tif (generateRsyncConf(checkpointDir, rsyncConf, rsyncUser, rsyncPassword) == -1) {\n\t\tperror(\" + perrorMsg2 + \");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Construct the Rsync command\n\tchar command[1024];\n\tsprintf(command, rsyncCommand, rsyncPort, rsyncConf);\n\n\t// Execute the Rsync command\n\tif (system(command) == -1) {\n\t\tperror(\" + perrorMsg3 + \");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n", "CodeBleu_score": 33.0742159830948}, {"code": "void startRsync()\t// Create the checkpoint backup directory if it does not exist\n\tif (mkdir(RSYNC_DIR, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == -1) {\n\t\tperror(\"Failed to create the checkpoint backup directory\");\n\t\treturn;\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDirs(RSYNC_DIR);\n\n\t// Generate the Rsync configuration file\n\tFILE *rsyncConfigFile = fopen(RSYNC_CONFIG_FILE, \"w\");\n\tif (rsyncConfigFile == NULL) {\n\t\tperror(\"Failed to open the Rsync configuration file\");\n\t\treturn;\n\t}\n\tfprintf(rsyncConfigFile, \"use chroot = false\\n\");\n\tfprintf(rsyncConfigFile, \"log file = %s\\n\", RSYNC_LOG_FILE);\n\tfprintf(rsyncConfigFile, \"log format = %%t %%o %%b %%f %%l %%m %%n %%s %%e %%c\\n\");\n\tfprintf(rsyncConfigFile, \"read only = true\\n\");\n\tfprintf(rsyncConfigFile, \"list = true\\n\");\n\tfprintf(rsyncConfigFile, \"uid = %d\\n\", geteuid());\n\tfprintf(rsyncConfigFile, \"gid = %d\\n\", getegid());\n\tfprintf(rsyncConfigFile, \"port = %d\\n\", RSYNC_PORT);\n\tfprintf(rsyncConfigFile, \"timeout = 60\\n\");\n\tfprintf(rsyncConfigFile, \"contimeout = 60\\n\");\n\tfprintf(rsyncConfigFile, \"ignore errors = true\\n\");\n\tfprintf(rsyncConfigFile, \"ignore non-readable = true\\n\");\n\tfprintf(rsyncConfigFile, \"ignore missing args = true\\n\");\n\tfprintf(rsyncConfigFile, \"delete = true\\n\");\n\tfprintf(rsyncConfigFile, \"delete-before = true\\n\");\n\tfprintf(rsyncConfigFile, \"delay-updates = true\\n\");\n\tfprintf(rsyncConfigFile, \"exclude = %s\\n\", RSYNC_EXCLUDE_FILE);\n\tfprintf(rsyncConfigFile, \"include = %s\\n\", RSYNC_INCLUDE_FILE);\n\tfprintf(rsyncConfigFile, \"filter = %", "CodeBleu_score": 20.753106428517192}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId)\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n\t}\n}\n", "CodeBleu_score": 47.825074256611344}, {"code": "public void destroyDispatcher(String dispatcherId)\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n\t}\n}\n", "CodeBleu_score": 46.600142860144175}, {"code": "public void destroyDispatcher(String dispatcherId)\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n\tdispatcher.shutdown();\n\tdispatchers.remove(dispatcherId);\n}\n", "CodeBleu_score": 58.88858680783508}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority) TbActorId[] children = childrenMap.get(parent);\n if (children!= null) {\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n if (actorSystem.isActorRegistered(child)) {\n actorSystem.send(child, msg, highPriority);\n } else {\n log.warn(\"[{}] Child {} is not registered\", parent, child);\n }\n }\n }\n }\n }\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *", "CodeBleu_score": 39.385999515309145}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)\tif (children.containsKey(parent)) {\n\t\tfor (TbActorId child : children.get(parent)) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\tTbActor actor = actorMap.get(child);\n\t\t\t\tif (actor!= null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (highPriority) {\n\t\t\t\t\t\t\tactor.tell(msg, ActorRef.noSender());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tactor.tell(msg, ActorRef.noSender());\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tlog.warn(\"Failed to send msg [{}] to actor [{}]\", msg, child);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlog.warn(\"Failed to send msg [{}] to actor [{}], actor not found\", msg, child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.24715507969275}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority) List<TbActorId> children = childActors.get(parent);\n if (children!= null) {\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n if (actors.containsKey(child)) {\n if (highPriority) {\n actorSystem.tell(new TbActorMsgEnvelope(child, msg), ActorRef.noSender());\n } else {\n actorSystem.tell(new TbActorMsgEnvelope(child, msg), actorContext);\n }\n } else {\n log.warn(\"[{}] Child actor [{}] is not registered!\", parent.getActorId(), child.getActorId());\n }\n }\n }\n }\n }\n */\n", "CodeBleu_score": 41.7763954446654}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (destroyed) {\n\t\tif (msg.getMsgType() == RULE_NODE_UPDATED_MSG && highPriority) {\n\t\t\tif (actor.init()) {\n\t\t\t\tlog.info(\"[{}] Actor reinitialized!\", actor.getActorId());\n\t\t\t\tactor.onReconnect();\n\t\t\t} else {\n\t\t\t\tlog.warn(\"[{}] Actor reinitialization failed!\", actor.getActorId());\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.onTbActorStopped(actor);\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t}\n}\n", "CodeBleu_score": 48.676038931221676}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (destroying) {\n\t\tif (highPriority && msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n\t\t\tif (initFailed) {\n\t\t\t\tinitFailed = false;\n\t\t\t\tinit();\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.onTbActorStopped(actorId);\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t}\n}\n", "CodeBleu_score": 48.862805824745344}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)\tif (!isDestructing()) {\n\t\tif (highPriority) {\n\t\t\tif (msg instanceof RuleNodeUpdateMsg) {\n\t\t\t\tif (isFailed()) {\n\t\t\t\t\treinitialize();\n\t\t\t\t}\n\t\t\t}\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t} else {\n\t\tif (highPriority && msg instanceof RuleNodeUpdateMsg) {\n\t\t\tnotifyFailed();\n\t\t} else {\n\t\t\tmsg.onTbActorStopped(this);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.74599769350002}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox()\tif (mailbox.isEmpty()) {\n\t\tstatus = Status.FREE;\n\t\tschedule(new QueueProcessingAttempt());\n\t} else {\n\t\ttry {\n\t\t\tprocessMessages();\n\t\t} catch (InitializationFailure e) {\n\t\t\tstopReason = e;\n\t\t\tdestroy();\n\t\t} catch (Exception e) {\n\t\t\tlogger.log(Level.WARNING, \"Exception while processing messages\", e);\n\t\t\tif (processFailureStrategy == ProcessFailureStrategy.STOP) {\n\t\t\t\tstopReason = e;\n\t\t\t\tdestroy();\n\t\t\t} else if (processFailureStrategy == ProcessFailureStrategy.RETRY) {\n\t\t\t\tschedule(new QueueProcessingAttempt());\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 13.092542173688178}, {"code": "private void processMailbox()\tif (mailbox.isEmpty()) {\n\t\tstatus = ActorStatus.FREE;\n\t\tif (mailbox.getQueue().getQueueType() == QueueType.HIGH_PRIORITY) {\n\t\t\tmailbox.getQueue().scheduleProcessing();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tif (status == ActorStatus.INITIALIZING) {\n\t\t\t\tprocessMessage(mailbox.poll());\n\t\t\t} else {\n\t\t\t\tprocessMessage(mailbox.get());\n\t\t\t}\n\t\t} catch (ActorInitializationException e) {\n\t\t\tstopReason = e;\n\t\t\tstatus = ActorStatus.STOPPED;\n\t\t\tdestroy();\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"An unexpected error occurred while processing a message.\", e);\n\t\t\tif (processFailureStrategy == ProcessFailureStrategy.STOP) {\n\t\t\t\tstopReason = e;\n\t\t\t\tstatus = ActorStatus.STOPPED;\n\t\t\t\tdestroy();\n\t\t\t} else if (processFailureStrategy == ProcessFailureStrategy.RETRY) {\n\t\t\t\tmailbox.scheduleProcessing();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 19.10245267866076}, {"code": "private void processMailbox()\tboolean processed = false;\n\twhile (!processed) {\n\t\tprocessed = true;\n\t\tif (status!= ActorStatus.ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t\tif (queueHigh.size() > 0) {\n\t\t\ttry {\n\t\t\t\tprocessMessage(queueHigh.poll());\n\t\t\t} catch (Exception e) {\n\t\t\t\tif (status == ActorStatus.ACTIVE) {\n\t\t\t\t\tlogger.error(\"Exception while processing high priority message\", e);\n\t\t\t\t\tprocessFailure(e);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (queueNormal.size() > 0) {\n\t\t\ttry {\n\t\t\t\tprocessMessage(queueNormal.poll());\n\t\t\t} catch (Exception e) {\n\t\t\t\tif (status == ActorStatus.ACTIVE) {\n\t\t\t\t\tlogger.error(\"Exception while processing normal priority message\", e);\n\t\t\t\t\tprocessFailure(e);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (queueLow.size() > 0) {\n\t\t\ttry {\n\t\t\t\tprocessMessage(queueLow.poll());\n\t\t\t} catch (Exception e) {\n\t\t\t\tif (status == ActorStatus.ACTIVE) {\n\t\t\t\t\tlogger.error(\"Exception while processing low priority message\", e);\n\t\t\t\t\tprocessFailure(e);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (queueInternal.size() > 0) {\n\t\t\ttry {\n\t\t\t\tprocessMessage(queueInternal.poll());\n\t\t\t} catch (Exception e) {\n\t\t\t\tif (status == ActorStatus.ACTIVE) {\n\t\t\t\t\tlogger.error(\"Exception while processing internal message\", e);\n\t\t\t\t\tprocessFailure(e);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (status == ActorStatus.ACTIVE) {\n\t\t\t\tstatus = ActorStatus.FREE;\n\t\t\t\tscheduleQueueProcessing();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 25.89348520154835}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause)\tif (destroyed) {\n\t\treturn;\n\t}\n\tdestroyed = true;\n\tif (stopReason == null) {\n\t\tstopReason = new ActorStopReason(ActorStopReason.DESTROYED, cause);\n\t}\n\texecutor.execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tdestroy0(cause);\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.warn(\"Exception while destroying actor \" + Actor.this, e);\n\t\t\t}\n\t\t}\n\t});\n}\n", "CodeBleu_score": 31.55027034550544}, {"code": "public void destroy(Throwable cause)\tif (destroyed) {\n\t\treturn;\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = new StopReason(StopReason.DESTROYED);\n\t}\n\tdestroyed = true;\n\texecutor.execute(() -> {\n\t\ttry {\n\t\t\tif (destroyed) {\n\t\t\t\tdestroyed = false;\n\t\t\t\ttry {\n\t\t\t\t\tdestroy(stopReason, cause);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlogger.warn(\"Failed to destroy actor {}\", this, t);\n\t\t\t\t}\n\t\t\t\tfor (Message message : messages) {\n\t\t\t\t\tmessage.fail(stopReason, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tready.set(false);\n\t\t}\n\t});\n}\n", "CodeBleu_score": 36.35838717319324}, {"code": "public void destroy(Throwable cause)\tif (destroyed) {\n\t\treturn;\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = new ActorStopReason(ActorStopReason.DESTROYED, cause);\n\t}\n\tdestroyed = true;\n\tdispatcher.execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tif (destroyed) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdestroy();\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlogger.warn(\"Exception while destroying actor {}\", Actor.this, e);\n\t\t\t\t\t}\n\t\t\t\t\tnotifyMessages();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tready = false;\n\t\t\t}\n\t\t}\n\t});\n}\n", "CodeBleu_score": 32.429372672607926}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tTenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n\t\tif (tenantProfile == null && ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tif (tenantProfile == null) {\n\t\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t\t}\n\t\tRateLimit rateLimit = tenantProfile.getRateLimit();\n\t\tif (rateLimit == null) {\n\t\t\treturn true;\n\t\t}\n\t\tRateLimitLevel rateLimitLevel = rateLimit.getLevel(level);\n\t\tif (rateLimitLevel == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (rateLimitLevel.getLimit() == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tRate rate = rateLimitLevel.getRate();\n\t\tif (rate == null) {\n\t\t\treturn true;\n\t\t}\n\t\tRatePeriod period = rate.getPeriod();\n\t\tif (period == null) {\n\t\t\treturn true;\n\t\t}\n\t\tlong time = System.currentTimeMillis();\n\t\tlong start = time - period.getDuration().toMillis();\n\t\tlong count = rateLimitRepository.count(tenantId, api, level, start, time);\n\t\tif (count >= rateLimitLevel.getLimit()) {\n\t\t\trateLimitNotificationService.processRateLimitNotification(tenantId, api, level, rateLimitLevel, count, start, time);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t} catch (Exception e) {\n\t\tlog.error(\"Failed to check rate limit [{}] [{}] [{}]\", api, tenantId, level, e);\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 44.54742969751974}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tTenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n\t\tRateLimit rateLimit = getRateLimit(tenantProfile, level);\n\t\tif (rateLimit!= null && rateLimit.check(api)) {\n\t\t\trateLimitNotification(tenantProfile, rateLimit);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 31.06951153215049}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\tif (tenantId.equals(SystemTenantId.SYS_TENANT_ID)) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tTenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n\t\tRateLimit rateLimit = tenantProfile.getRateLimit(api, level);\n\t\tif (rateLimit.check(api)) {\n\t\t\treturn true;\n\t\t}\n\t\trateLimitNotification(api, tenantId, rateLimit);\n\t\treturn false;\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.0369242648554}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions()\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tIterator<Map.Entry<String, DtlsSession>> it = dtlsSessions.entrySet().iterator();\n\twhile (it.hasNext()) {\n\t\tMap.Entry<String, DtlsSession> entry = it.next();\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlogger.info(\"DTLS session \" + entry.getKey() + \" has been inactive for \" + inactivityTimeout + \" milliseconds, removing it\");\n\t\t\tit.remove();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.108782652405104}, {"code": "public void evictTimeoutSessions()\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tSet<Map.Entry<Long, DtlsSession>> entries = sessions.entrySet();\n\tfor (Map.Entry<Long, DtlsSession> entry : entries) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(entry.getKey());\n\t\t\tlogger.info(\"Removed expired DTLS session\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.548368184773786}, {"code": "public void evictTimeoutSessions()\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tSet<Entry<String, DtlsSession>> entries = sessions.entrySet();\n\tfor (Entry<String, DtlsSession> entry : entries) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tString peerId = entry.getKey();\n\t\t\tDtlsSession session = entry.getValue();\n\t\t\tsessions.remove(peerId);\n\t\t\tlogger.fine(\"Session with peer id \" + peerId + \" expired\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 39.06645817756782}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tif (timeseries == null || timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t} else {\n\t\tList<TsKvEntry> result = new ArrayList<>();\n\t\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\t\tfor (JsonNode node : entry.getValue()) {\n\t\t\t\tresult.add(new BasicTsKvEntry(new BasicTimeseries(entry.getKey()), node.get(\"value\").asText(), node.get(\"ts\").asLong()));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n", "CodeBleu_score": 39.53530301550916}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tList<TsKvEntry> result = new ArrayList<>();\n\tif (timeseries == null || timeseries.isEmpty()) {\n\t\treturn result;\n\t}\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tfor (JsonNode value : values) {\n\t\t\tTsKvEntry tsKvEntry = new BasicTsKvEntry(new Long(value.get(\"ts\").asText()), value.get(\"value\"));\n\t\t\tresult.add(tsKvEntry);\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 40.34259008416177}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)\tif (timeseries == null || timetimeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tfor (JsonNode value : entry.getValue()) {\n\t\t\tTsKvEntry tsKvEntry = new BasicTsKvEntry(new Long(value.get(\"ts\").asText()), value.get(\"value\"));\n\t\t\tresult.add(tsKvEntry);\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 42.16051771265473}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken()\t// Create a request map with the refresh token\n\tMap<String, String> requestMap = new HashMap<String, String>();\n\trequestMap.put(\"refresh_token\", refreshToken);\n\n\t// Send a POST request to the authentication endpoint\n\tString response = sendRequest(authenticationEndpoint, requestMap, \"POST\");\n\n\t// Update the token information\n\tupdateTokenInfo(response);\n}\n", "CodeBleu_score": 30.383176135467227}, {"code": "public void refreshToken()\tMap<String, String> requestMap = new HashMap<String, String>();\n\trequestMap.put(\"refresh_token\", this.refreshToken);\n\trequestMap.put(\"grant_type\", \"refresh_token\");\n\trequestMap.put(\"client_id\", this.clientId);\n\trequestMap.put(\"client_secret\", this.clientSecret);\n\tString response = HttpHelper.sendPostRequest(this.authEndpoint, requestMap);\n\tJSONObject responseJson = new JSONObject(response);\n\tthis.accessToken = responseJson.getString(\"access_token\");\n\tthis.refreshToken = responseJson.getString(\"refresh_token\");\n\tthis.expiresAt = System.currentTimeMillis() + responseJson.getInt(\"expires_in\") * 1000;\n}\n", "CodeBleu_score": 33.83105098596626}, {"code": "public void refreshToken()\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", refreshToken);\n\trequestMap.put(\"grant_type\", \"refresh_token\");\n\trequestMap.put(\"client_id\", clientId);\n\trequestMap.put(\"client_secret\", clientSecret);\n\n\ttry {\n\t\tHttpResponse<String> response = Unirest.post(refreshEndpoint)\n\t\t\t.header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\t\t.body(requestMap)\n\t\t\t.asString();\n\n\t\tif (response.getStatus() == 200) {\n\t\t\tJsonObject json = new JsonParser().parse(response.getBody()).getAsJsonObject();\n\t\t\taccessToken = json.get(\"access_token\").getAsString();\n\t\t\trefreshToken = json.get(\"refresh_token\").getAsString();\n\t\t\ttokenExpiration = System.currentTimeMillis() + json.get(\"expires_in\").getAsInt() * 1000;\n\t\t} else {\n\t\t\tSystem.out.println(\"Error refreshing token: \" + response.getStatus() + \" \" + response.getBody());\n\t\t}\n\t} catch (UnirestException e) {\n\t\tSystem.out.println(\"Error refreshing token: \" + e.getMessage());\n\t}\n}\n", "CodeBleu_score": 44.057508107283674}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin()\t// Create a login request map\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username.getText());\n\tloginRequest.put(\"password\", password.getText());\n\n\t// Send the request to the authentication endpoint\n\tHttpResponse<String> response = Unirest.post(\"http://localhost:8080/api/auth/login\")\n\t\t.header(\"Content-Type\", \"application/json\")\n\t\t.body(loginRequest)\n\t\t.asString();\n\n\t// Update the token information\n\ttoken = response.getBody();\n\ttokenTimestamp = System.currentTimeMillis();\n }\n", "CodeBleu_score": 50.48122368024293}, {"code": " private void doLogin()\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", usernameField.getText());\n\tloginRequest.put(\"password\", passwordField.getText());\n\n\t// Send the login request\n\tString response = sendPostRequest(\"/api/auth/login\", loginRequest);\n\n\t// Parse the response and update the token information\n\ttry {\n\t\tJSONObject responseJson = new JSONObject(response);\n\t\ttoken = responseJson.getString(\"token\");\n\t\ttokenExpiration = System.currentTimeMillis() + (responseJson.getInt(\"expiresIn\") * 1000);\n\t\tloginStatusLabel.setText(\"Logged in as \" + usernameField.getText());\n\t} catch (JSONException e) {\n\t\tloginStatusLabel.setText(\"Invalid login credentials\");\n\t}\n}\n", "CodeBleu_score": 44.596211744302}, {"code": " private void doLogin()\t// Create a map of the login request\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username.getText());\n\tloginRequest.put(\"password\", <PASSWORD>());\n\n\t// Send the request to the authentication endpoint\n\tHttpResponse<String> response = Unirest.post(\"http://localhost:8080/api/auth/login\")\n\t\t.header(\"Content-Type\", \"application/json\")\n\t\t.body(loginRequest)\n\t\t.asString();\n\n\t// Check if the response was successful\n\tif (response.getStatus() == 200) {\n\t\t// Get the response data\n\t\tJSONObject responseData = new JSONObject(response.getBody());\n\n\t\t// Update the token information\n\t\ttoken.setText(responseData.getString(\"token\"));\n\t\ttokenExpiry.setText(responseData.getString(\"expiry\"));\n\t} else {\n\t\t// Display an error message\n\t\tloginError.setText(\"Login failed\");\n\t}\n}\n", "CodeBleu_score": 45.07601823396708}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\ttry {\n\t\tResponse response = client.target(baseUrl + \"/api/device/\" + deviceId.toString()).request().get();\n\t\tif (response.getStatus() == 200) {\n\t\t\treturn Optional.of(response.readEntity(Device.class));\n\t\t} else if (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(response.toString());\n\t\t}\n\t} catch (RuntimeException e) {\n\t\tthrow e;\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n", "CodeBleu_score": 52.59886416911821}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\ttry {\n\t\tHttpResponse<String> response = Unirest.get(\"{baseUrl}/api/device/{deviceId}\")\n\t\t\t.routeParam(\"baseUrl\", baseUrl)\n\t\t\t.routeParam(\"deviceId\", deviceId.toString())\n\t\t\t.asString();\n\t\tif (response.getStatus() == 200) {\n\t\t\treturn Optional.of(new Device(response.getBody()));\n\t\t} else if (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"HTTP error: \" + response.getStatus() + \" - \" + response.getBody());\n\t\t}\n\t} catch (UnirestException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n", "CodeBleu_score": 50.79109142842787}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)\ttry {\n\t\tHttpResponse<String> response = Unirest.get(String.format(\"http://localhost:8080/api/device/%s\", deviceId.toString()))\n\t\t\t\t.asString();\n\t\tif (response.getStatus() == 200) {\n\t\t\treturn Optional.of(new ObjectMapper().readValue(response.getBody(), Device.class));\n\t\t} else if (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(response.getStatusText());\n\t\t}\n\t} catch (UnirestException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n", "CodeBleu_score": 50.63689747848012}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\ttry {\n\t\tRequest request = new Request.Builder()\n\t\t\t.url(BASE_URL + \"/api/device-with-credentials\")\n\t\t\t.post(RequestBody.create(MediaType.parse(\"application/json\"), device.toJSONObject().put(\"credentials\", credentials.toJSONObject()).toString()))\n\t\t\t.build();\n\t\tResponse response = client.newCall(request).execute();\n\t\tif (response.code() == 201) {\n\t\t\treturn Optional.of(new Device(new JSONObject(response.body().string())));\n\t\t} else if (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new IOException(\"Unexpected response code: \" + response.code());\n\t\t}\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n", "CodeBleu_score": 45.86119420457947}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\ttry {\n\t\tRequest request = Request.Post(url + \"/api/device-with-credentials\")\n\t\t\t.addHeader(\"Content-Type\", \"application/json\")\n\t\t\t.addHeader(\"Authorization\", \"Bearer \" + accessToken)\n\t\t\t.bodyString(device.toJson(), ContentType.APPLICATION_JSON);\n\n\t\tHttpResponse response = httpClient.execute(request);\n\n\t\tif (response.getStatusLine().getStatusCode() == 201) {\n\t\t\treturn Optional.of(Device.fromJson(EntityUtils.toString(response.getEntity())));\n\t\t} else if (response.getStatusLine().getStatusCode() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Unexpected response status code: \" + response.getStatusLine().getStatusCode());\n\t\t}\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n", "CodeBleu_score": 46.15757649656815}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)\ttry {\n\t\tRequest request = new Request.Builder()\n\t\t\t.url(BASE_URL + \"/api/device-with-credentials\")\n\t\t\t.post(RequestBody.create(JSON, device.toJson() + credentials.toJson()))\n\t\t\t.build();\n\t\tResponse response = client.newCall(request).execute();\n\t\tif (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else if (response.code() == 200) {\n\t\t\treturn Optional.of(Device.fromJson(response.body().string()));\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Unexpected response code: \" + response.code());\n\t\t}\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n", "CodeBleu_score": 46.12573379547162}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val)\tif (typeof val === 'undefined') {\n\t\tval = addr;\n\t\tfor (var i = 0; i < this.leds.length; i++) {\n\t\t\tthis.leds[i].brightness(val);\n\t\t}\n\t} else {\n\t\tthis.leds[this.addrToIndex(addr)].brightness(val);\n\t}\n\treturn this;\n}\n", "CodeBleu_score": 43.30869173530913}, {"code": "brightness(addr, val)\tif (typeof addr === 'number') {\n\t\tif (typeof val === 'undefined') {\n\t\t\tthis.brightness = addr;\n\t\t} else {\n\t\t\tthis.brightness[addr] = val;\n\t\t}\n\t} else {\n\t\tthis.brightness = addr;\n\t}\n\treturn this;\n}\n", "CodeBleu_score": 33.95659525767951}, {"code": "brightness(addr, val)\tif (typeof addr === 'number') {\n\t\tif (typeof val === 'number') {\n\t\t\tthis.brightness[addr] = val;\n\t\t} else {\n\t\t\tthis.brightness[addr] = val? 1 : 0;\n\t\t}\n\t} else {\n\t\tif (typeof val === 'number') {\n\t\t\tfor (let i = 0; i < this.brightness.length; i++) {\n\t\t\t\tthis.brightness[i] = val;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < this.brightness.length; i++) {\n\t\t\t\tthis.brightness[i] = val? 1 : 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn this;\n}\n", "CodeBleu_score": 41.14328457681596}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr)\tconst obj = {};\n\tfor (const key in this) {\n\t\tif (this.hasOwnProperty(key) && typeof this[key] === 'function') {\n\t\t\tobj[key] = this[key].bind(this, addr);\n\t\t}\n\t}\n\tfor (const key in LedControl.prototype) {\n\t\tif (LedControl.prototype.hasOwnProperty(key) && typeof LedControl.prototype[key] === 'function') {\n\t\t\tobj[key] = LedControl.prototype[key].bind(this, addr);\n\t\t}\n\t}\n\treturn obj;\n}\n", "CodeBleu_score": 52.04514884558329}, {"code": "device(addr)\tconst proto = LedControl.prototype;\n\tconst obj = this;\n\tfor (const key in proto) {\n\t\tif (typeof proto[key] === \"function\") {\n\t\t\tobj[key] = proto[key].bind(this, addr);\n\t\t}\n\t}\n\tfor (const key in this) {\n\t\tif (typeof this[key] === \"function\") {\n\t\t\tobj[key] = this[key].bind(this, addr);\n\t\t}\n\t}\n\treturn obj;\n}\n", "CodeBleu_score": 43.94356240267025}, {"code": "device(addr)\tlet proto = LedControl.prototype;\n\tlet obj = this;\n\tfor (let key in proto) {\n\t\tif (typeof proto[key] === 'function') {\n\t\t\tobj[key] = proto[key].bind(this, addr);\n\t\t}\n\t}\n\tfor (let key in this) {\n\t\tif (typeof this[key] === 'function') {\n\t\t\tobj[key] = this[key].bind(this, addr);\n\t\t}\n\t}\n\treturn obj;\n}\n", "CodeBleu_score": 41.40286589478931}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => \tmethods.forEach(method => {\n\t\tif (typeof target[method]!== 'function') {\n\t\t\tthrow new Error('The method \"' + method + '\" is not a function');\n\t\t}\n\t\tconst originalMethod = target[method];\n\t\ttarget[method] = function (...args) {\n\t\t\tconst callback = args[args.length - 1];\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('The last argument must be a callback function');\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\targs[args.length - 1] = (...args) => {\n\t\t\t\tpromises.push(Promise.resolve(...args));\n\t\t\t};\n\t\t\tconst results = originalMethod.apply(this, args);\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback(results);\n\t\t\t});\n\t\t\treturn results;\n\t\t};\n\t});\n};\n", "CodeBleu_score": 34.73449851860077}, {"code": "Collection.installCallbackReconciliation = (target, methods) => \tmethods.forEach(method => {\n\t\ttarget[method] = (collection, duration, callback) => {\n\t\t\tif (typeof callback!== \"function\") {\n\t\t\t\tcallback = () => {};\n\t\t\t}\n\t\t\tlet promises = [];\n\t\t\tcollection.forEach(element => {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresolve(element[method]());\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, duration || 1000);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t}).catch(error => {\n\t\t\t\tconsole.error(error);\n\t\t\t});\n\t\t};\n\t});\n};\n", "CodeBleu_score": 33.209266192769746}, {"code": "Collection.installCallbackReconciliation = (target, methods) => \tmethods.forEach((method) => {\n\t\ttarget[method] = (collection, duration, callback) => {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tcallback = () => {};\n\t\t\t}\n\t\t\tlet promises = [];\n\t\t\tcollection.forEach((element) => {\n\t\t\t\tpromises.push(new Promise((resolve) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(element[method]());\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n};\n", "CodeBleu_score": 28.924888359939438}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen()\tvar inputString = \"\";\n\tvar inputChar = \"\";\n\tvar sentenceEnd = \"\";\n\tvar sentence = \"\";\n\tvar checksum = \"\";\n\tvar checksumChar = \"\";\n\tvar checksumIndex = 0;\n\tvar data = \"\";\n\tvar dataChar = \"\";\n\tvar dataIndex = 0;\n\tvar sentenceType = \"\";\n\tvar sentenceData = \"\";\n\tvar sentenceChecksum = \"\";\n\tvar sentenceChecksumChar = \"\";\n\tvar sentenceChecksumIndex = 0;\n\tvar sentenceChecksumValue = 0;\n\tvar sentenceChecksumValueComputed = 0;\n\tvar sentenceLength = 0;\n\tvar sentenceLengthChar = \"\";\n\tvar sentenceLengthIndex = 0;\n\tvar sentenceLengthValue = 0;\n\tvar sentenceLengthValueComputed = 0;\n\tvar sentenceIndex = 0;\n\tvar sentenceCount = 0;\n\tvar sentenceCountChar = \"\";\n\tvar sentenceCountIndex = 0;\n\tvar sentenceCountValue = 0;\n\tvar sentenceCountValueComputed = 0;\n\tvar sentenceCountValid = 0;\n\tvar sentenceCountValidChar = \"\";\n\tvar sentenceCountValidIndex = 0;\n\tvar sentenceCountValidValue = 0;\n\tvar sentenceCountValidValueComputed = 0;\n\tvar sentenceCountValidValid = 0;\n\tvar sentenceCountValidValidChar = \"\";\n\tvar sentenceCountValidValidIndex = 0;\n\tvar sentenceCountValidValidValue = 0;\n\tvar sentenceCountValidValidValueComputed = 0;\n\tvar sentenceCountValidValidValid = 0;\n\tvar sentenceCountValidValidValidChar = \"\";\n\tvar sentenceCountValidValidValidIndex = 0;\n\tvar sentenceCountValidValidValidValue = 0;\n\tvar sentenceCountValidValidValidValueComputed = 0;\n\tvar sentenceCountValidValidValidValid = 0;\n\tvar sentenceCountValidValidValidValidChar = \"\";\n\tvar sentenceCountValidValidValidValidIndex = 0;\n\tvar sentenceCountValidValidValidValidValue = 0;\n\tvar sentenceCountValidValidValidValidValueComputed = 0;\n\tvar sentenceCountValidValidValidValidValid = 0;\n\tvar sentenceCountValidValidValidValidValidChar = \"\";\n\tvar sentenceCountValidValidValid", "CodeBleu_score": 7.032098225687346}, {"code": "listen()\tvar inputString = \"\";\n\tvar inputChar = \"\";\n\tvar inputLen = 0;\n\tvar sentence = \"\";\n\tvar sentenceLen = 0;\n\tvar sentenceStart = 0;\n\tvar sentenceEnd = 0;\n\tvar sentenceIndex = 0;\n\tvar sentenceCount = 0;\n\tvar sentenceType = \"\";\n\tvar sentenceChecksum = \"\";\n\tvar sentenceChecksumActual = \"\";\n\tvar sentenceChecksumExpected = \"\";\n\tvar sentenceChecksumPassed = false;\n\tvar sentenceChecksumFailed = false;\n\n\t// Read data from the serial port\n\twhile (inputChar!= -1) {\n\t\tinputChar = serial.read();\n\n\t\t// If the input character is a carriage return, check if the previous character was a line feed. If so, process the input string as a sentence.\n\t\tif (inputChar == 13) {\n\t\t\tif (inputString[inputLen - 1] == 10) {\n\t\t\t\tsentence = inputString.substring(sentenceStart, inputLen - 1);\n\t\t\t\tsentenceLen = sentence.length;\n\t\t\t\tsentenceCount = sentenceCount + 1;\n\n\t\t\t\t// Check if the sentence is a valid NMEA sentence\n\t\t\t\tif (sentence.charAt(0) == \"$\" && sentence.charAt(sentenceLen - 3) == \"*\" && sentence.charAt(sentenceLen - 2) == \" \" && sentence.charAt(sentenceLen - 1) == \" \") {\n\t\t\t\t\tsentenceType = sentence.substring(1, 6);\n\t\t\t\t\tsentenceChecksum = sentence.substring(sentenceLen - 2, sentenceLen);\n\t\t\t\t\tsentenceChecksumActual = checksum(sentence.substring(1, sentenceLen - 3));\n\t\t\t\t\tsentenceChecksumExpected = sentenceChecksum.substring(0, 2);\n\n\t\t\t\t\t// If the checksum matches the expected checksum, process the sentence\n\t\t\t\t\tif (sentenceChecksumActual == sentenceChecksumExpected) {\n\t\t\t\t\t\tsentenceChecksumPassed = true;\n\t\t\t\t\t\tsentenceChecksumFailed = false;\n\n\t\t\t\t\t\t// Process the sentence\n\t\t\t\t\t\tparseNmeaSentence(sentenceType, sentence);\n\t\t\t\t\t}\n\t\t\t\t\t// If the checksum doesn't match the expected checksum, discard the sentence\n\t\t\t\t\telse {\n\t\t\t\t\t\tsentenceChecksumPassed = false;\n\t\t\t\t\t\tsentenceChecksumFailed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Reset the input string and start the next sentence\n\t\t\t\tinput", "CodeBleu_score": 11.824095823608191}, {"code": "listen()\tvar nmeaSentence = \"\";\n\tvar nmeaChecksum = \"\";\n\tvar nmeaChecksumIndex = 0;\n\tvar nmeaSentenceIndex = 0;\n\tvar nmeaSentenceEndIndex = 0;\n\tvar nmeaSentenceStartIndex = 0;\n\tvar nmeaSentenceLength = 0;\n\tvar nmeaSentenceType = \"\";\n\tvar nmeaSentenceTypeIndex = 0;\n\tvar nmeaSentenceChecksum = \"\";\n\tvar nmeaSentenceChecksumIndex = 0;\n\tvar nmeaSentenceChecksumLength = 0;\n\tvar nmeaSentenceChecksumCalculated = 0;\n\tvar nmeaSentenceChecksumPassed = false;\n\n\t// Read data from the serial port and process NMEA sentences\n\twhile (true) {\n\t\t// Read data from the serial port\n\t\tvar data = serial.read(1);\n\n\t\t// If data is available\n\t\tif (data.length > 0) {\n\t\t\t// If the data is a carriage return\n\t\t\tif (data == \"\\r\") {\n\t\t\t\t// If the data is a carriage return followed by a line feed\n\t\t\t\tif (serial.peek() == \"\\n\") {\n\t\t\t\t\t// Read the line feed\n\t\t\t\t\tserial.read(1);\n\t\t\t\t}\n\n\t\t\t\t// If the input string contains a valid NMEA sentence\n\t\t\t\tif (nmeaSentence.length > 0) {\n\t\t\t\t\t// Process the NMEA sentence\n\t\t\t\t\tparseNmeaSentence(nmeaSentence);\n\t\t\t\t}\n\n\t\t\t\t// Clear the input string\n\t\t\t\tnmeaSentence = \"\";\n\t\t\t}\n\t\t\t// Else if the data is a line feed\n\t\t\telse if (data == \"\\n\") {\n\t\t\t\t// If the input string contains a valid NMEA sentence\n\t\t\t\tif (nmeaSentence.length > 0) {\n\t\t\t\t\t// Process the NMEA sentence\n\t\t\t\t\tparseNmeaSentence(nmeaSentence);\n\t\t\t\t}\n\n\t\t\t\t// Clear the input string\n\t\t\t\tnmeaSentence = \"\";\n\t\t\t}\n\t\t\t// Else if the data is a dollar sign\n\t\t\telse if (data == \"$\") {\n\t\t\t\t// If the input string contains a valid NMEA sentence\n\t\t\t\tif (nmeaSentence.length > 0) {\n\t\t\t\t\t// Process the", "CodeBleu_score": 20.420415179618395}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint8_t sample_size = 0;\n\tuint8_t buffer_size = 0;\n\n\t/*\n\t * Determine the number of active channels and the size of each data sample.\n\t */\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t\tsample_size = sizeof(uint16_t);\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the buffer size.\n\t */\n\tbuffer_size = active_channels * sample_size * sequence->resolution;\n\n\tif (buffer_size > config->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 41.170571807308384}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tu8_t active_channels = 0;\n\tu8_t buffer_size = 0;\n\tu8_t channel;\n\n\tfor (channel = 0; channel < sequence->channels; channel++) {\n\t\tif (sequence->channels & BIT(channel)) {\n\t\t\tactive_channels++;\n\t\t\tbuffer_size += sizeof(u16_t);\n\t\t}\n\t}\n\n\tif (active_channels > config->num_channels) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 39.15588257980637}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tu32_t channel_mask = 0U;\n\tsize_t size_per_sample = 0U;\n\tu32_t buffer_size = 0U;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tfor (u32_t i = 0U; i < sequence->channels; i++) {\n\t\tchannel_mask |= BIT(sequence->channels[i].channel);\n\t}\n\n\tsize_per_sample = sizeof(u16_t);\n\n\tbuffer_size = size_per_sample * sequence->resolution;\n\n\tif (channel_mask & ~config->channel_mask) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 45.9830761813409}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channel_mask = 0;\n\tuint8_t channel_count = 0;\n\tuint8_t channel_index = 0;\n\tuint8_t channel_bits = 0;\n\tuint8_t channel_bits_max = 0;\n\tuint8_t channel_bits_min = 0;\n\tuint8_t channel_bits_expected = 0;\n\tuint8_t channel_bits_actual = 0;\n\tuint8_t channel_bits_mask = 0;\n\tuint8_t channel_bits_mask_expected = 0;\n\tuint8_t channel_bits_mask_actual = 0;\n\tuint8_t channel_bits_mask_shift = 0;\n\tuint8_t channel_bits_mask_shift_expected = 0;\n\tuint8_t channel_bits_mask_shift_actual = 0;\n\tuint8_t channel_bits_mask_shift_bits = 0;\n\tuint8_t channel_bits_mask_shift_bits_expected = 0;\n\tuint8_t channel_bits_mask_shift_bits_actual = 0;\n\tuint8_t channel_bits_mask_shift_bits_max = 0;\n\tuint8_t channel_bits_mask_shift_bits_min = 0;\n\tuint8_t channel_bits_mask_shift_bits_actual = 0;\n\tuint8_t channel_bits_mask_shift_bits_max = 0;\n\tuint8_t channel_bits_mask_shift_bits_min = 0;\n\tuint8_t channel_bits_mask_shift_bits_actual = 0;\n\tuint8_t channel_bits_mask_shift_bits_max = 0;\n\tuint8_t channel_bits_mask_shift_bits_min = 0;\n\tuint8_t channel_bits_mask_shift_bits_actual = 0;\n\tuint8_t channel_", "CodeBleu_score": 12.420542590336114}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tu16_t *buffer = sequence->buffer;\n\tu16_t channel_mask = 0;\n\tu8_t channel_index = 0;\n\tu8_t resolution = 0;\n\tint err_code;\n\n\t/* Check if the ADC sequence resolution matches the expected resolution. */\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"ADC resolution does not match expected resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid. */\n\tfor (channel_index = 0; channel_index < sequence->channels; channel_index++) {\n\t\tif (sequence->channels[channel_index].channel >= config->channels) {\n\t\t\tLOG_ERR(\"Invalid channel specified\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchannel_mask |= BIT(sequence->channels[channel_index].channel);\n\t}\n\n\t/* Validate the buffer size for the ADC read. */\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set the buffer and channel mask. */\n\tdata->buffer = buffer;\n\tdata->channel_mask = channel_mask;\n\n\t/* Set the ADC resolution. */\n\tresolution = (sequence->resolution + 7) / 8;\n\terr_code = ad559x_set_resolution(config->dev, resolution);\n\tif (err_code) {\n\t\treturn err_code;\n\t}\n\n\t/* Start the ADC read context. */\n\tk_sem_take(&data->read_sync, K_FOREVER);\n\terr_code = ad559x_start_read(config->dev, sequence->channels, sequence->channels, buffer);\n\tif (err_code) {\n\t\treturn err_code;\n\t}\n\n\t/* Wait for the read operation to complete. */\n\tk_sem_take(&data->read_sync, K_FOREVER);\n\n\treturn 0;\n}\n", "CodeBleu_score": 45.15369460684478}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tconst struct adc_ad559x_dev_config *dev_config = DEV_CFG(dev);\n\tstruct adc_ad559x_dev_data *dev_data = DEV_DATA(dev);\n\tint err_code;\n\n\tif (dev_data->resolution!= sequence->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (size_t i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i] >= dev_config->channel_count) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_data->buffer = sequence->buffer;\n\tdev_data->buffer_size = sequence->buffer_size;\n\tdev_data->buffer_remaining = sequence->buffer_size;\n\tdev_data->buffer_index = 0;\n\n\terr_code = adc_ad559x_start_read_context(dev, sequence);\n\tif (err_code!= 0) {\n\t\treturn err_code;\n\t}\n\n\tadc_ad559x_read_context_wait_for_completion(dev);\n\n\treturn 0;\n}\n", "CodeBleu_score": 45.03846867720184}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tint ret;\n\n\t/* Make sure the buffer is large enough for the ADC sample. */\n\tif (ctx->sample_buffer_len < ctx->sample_buffer_size) {\n\t\tprintf(\"adc_context_start_sampling: Error: sample buffer is too small (%d/%d)\\n\",\n\t\t       ctx->sample_buffer_len, ctx->sample_buffer_size);\n\t\treturn;\n\t}\n\n\t/* Make sure the ADC input has been configured. */\n\tif (!ctx->channel_config) {\n\t\tprintf(\"adc_context_start_sampling: Error: channel_config not set\\n\");\n\t\treturn;\n\t}\n\n\t/* Set the sampling time. */\n\tret = adc_set_sampling_time(ctx->dev, ctx->channel_config);\n\tif (ret < 0) {\n\t\tprintf(\"adc_context_start_sampling: Error: Could not set sampling time.\\n\");\n\t\treturn;\n\t}\n\n\t/* Set the buffer for the samples. */\n\tret = adc_set_buffer(ctx->dev, ctx->sample_buffer, ctx->sample_buffer_len);\n\tif (ret < 0) {\n\t\tprintf(\"adc_context_start_sampling: Error: Could not set buffer.\\n\");\n\t\treturn;\n\t}\n\n\t/* Kick off the sampling. */\n\tret = adc_read(ctx->dev, ctx->channel_config);\n\tif (ret < 0) {\n\t\tprintf(\"adc_context_start_sampling: Error: Could not read samples.\\n\");\n\t\treturn;\n\t}\n\n\t/* Mark the ADC context as active. */\n\tctx->sampling = true;\n}\n", "CodeBleu_score": 29.098174396223953}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tint status;\n\n\t/* Increment the reference count to ensure that the context is not\n\t * deleted while the interrupt handler is executing.\n\t */\n\tadc_context_ref(ctx);\n\n\t/* Enable the interrupt in the ADC controller. */\n\tadc_enable_interrupt(ctx->adc_dev, ctx->channel_mask);\n\n\t/* Enable the ADC block. */\n\tadc_enable(ctx->adc_dev);\n\n\t/* Start sampling on the enabled channels. */\n\tstatus = adc_read(ctx->adc_dev, &ctx->buffer, ctx->channel_mask);\n\tif (status) {\n\t\tprintk(\"adc_read failed with status %d\\n\", status);\n\t\tadc_context_release(ctx, NULL);\n\t\treturn;\n\t}\n\n\t/* Wait for the ADC interrupt to signal that the buffer is full. */\n\tk_sem_take(&ctx->completion_sem, K_FOREVER);\n\n\t/* At this point, the ADC interrupt has already fired and the\n\t * completion_sem has been given, so it is safe to release the\n\t * reference that was taken above.\n\t */\n\tadc_context_release(ctx, NULL);\n}\n", "CodeBleu_score": 41.018139828936675}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tint i;\n\tint err;\n\n\t/* make sure no sampling is active */\n\tif (ctx->state!= ADC_STATE_IDLE) {\n\t\treturn;\n\t}\n\n\t/* reset sampling state */\n\tadc_context_reset_sampling(ctx);\n\n\t/* set channels */\n\terr = adc_read_channel_mask(ctx, ctx->raw_chan_mask);\n\tif (err) {\n\t\tadc_context_enable_sampling(ctx, 0);\n\t\treturn;\n\t}\n\n\t/* set sampling frequency */\n\terr = adc_set_frequency(ctx, ctx->frequency);\n\tif (err) {\n\t\tadc_context_enable_sampling(ctx, 0);\n\t\treturn;\n\t}\n\n\t/* set buffer */\n\terr = adc_read_buffer(ctx, ctx->buffer, ctx->buffer_size);\n\tif (err) {\n\t\tadc_context_enable_sampling(ctx, 0);\n\t\treturn;\n\t}\n\n\t/* set repeat count */\n\terr = adc_set_repeat(ctx, ctx->repeat);\n\tif (err) {\n\t\tadc_context_enable_sampling(ctx, 0);\n\t\treturn;\n\t}\n\n\t/* enable hardware trigger */\n\tadc_enable_trigger(ctx, 1);\n\n\t/* enable DMA */\n\tadc_enable_dma(ctx, 1);\n\n\t/* enable conversions */\n\tadc_context_enable_sampling(ctx, 1);\n\n\t/* all done */\n\treturn;\n}\n", "CodeBleu_score": 29.996310506382628}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->buffer_repeat;\n\t} else {\n\t\tctx->buffer = ctx->buffer_raw;\n\t}\n}\n", "CodeBleu_score": 48.65636498468496}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->buf_ptr = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buf_ptr = ctx->buffer;\n\t}\n}\n", "CodeBleu_score": 49.47638830790781}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\t/* Update buffer pointer to point to the beginning of the repeat buffer instead of the data buffer. */\n\t\tctx->buffer = ctx->buffer_repeat;\n\t}\n}\n", "CodeBleu_score": 45.210153971261946}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tstruct adc_context *ctx = &data->ctx;\n\tconst struct device *dev = data->dev;\n\tuint8_t active_channels = data->active_channels;\n\tuint16_t *buffer = data->buffer;\n\tuint8_t channel;\n\tuint16_t raw_value;\n\tint rc;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < NUM_CHANNELS; channel++) {\n\t\t\tif (active_channels & BIT(channel)) {\n\t\t\t\trc = ad559x_read_channel(dev, channel, &raw_value);\n\t\t\t\tif (rc) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel);\n\t\t\t\t\tctx->status = rc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuffer[channel] = raw_value;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->status == 0) {\n\t\t\tctx->callback(dev, buffer, NULL, ctx);\n\t\t}\n\n\t\tk_sem_give(&data->sem);\n\t}\n}\n", "CodeBleu_score": 43.249593802774825}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\twhile (true) {\n\t\tk_sem_take(&data->acquisition_done_sem, K_FOREVER);\n\n\t\tfor (size_t i = 0; i < data->num_channels; i++) {\n\t\t\tconst struct adc_channel_cfg *channel = &data->channels[i];\n\t\t\tint err;\n\t\t\tu16_t sample;\n\n\t\t\terr = adc_read(data->dev, channel, &sample);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"ADC read failed with code %d\", err);\n\t\t\t\tdata->acquisition_complete = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata->buffer[i] = sample;\n\t\t}\n\n\t\tdata->acquisition_complete = true;\n\t}\n}\n", "CodeBleu_score": 35.9802728916719}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tstruct device *dev = data->dev;\n\tstruct adc_context *ctx = dev->driver_api;\n\tstruct adc_sequence *sequence = &data->sequence;\n\tconst struct adc_channel_cfg *channel;\n\tint err;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tif (data->sampling) {\n\t\t\tLOG_ERR(\"sampling already in progress\");\n\t\t\tadc_context_sampling_done(ctx, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata->sampling = true;\n\n\t\tsequence->channels = 0;\n\t\tfor (channel = sequence->channels_config; channel < sequence->channels_config + sequence->num_channels; channel++) {\n\t\t\tif (channel->channel_id < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = adc_read(dev, sequence, channel);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"ADC read failed with code %d\", err);\n\t\t\t\tadc_context_sampling_done(ctx, NULL);\n\t\t\t\tdata->sampling = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsequence->channels++;\n\t\t}\n\n\t\tif (sequence->channels) {\n\t\t\terr = adc_read(dev, sequence, NULL);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"ADC read failed with code %d\", err);\n\t\t\t\tadc_context_sampling_done(ctx, NULL);\n\t\t\t\tdata->sampling = false;\n\t\t\t}\n\t\t} else {\n\t\t\tadc_context_sampling_done(ctx, NULL);\n\t\t\tdata->sampling = false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.662138630816024}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev)\tint err = 0;\n\tuint8_t config_reg = 0;\n\tstruct ads1112_data *drv_data = dev->data;\n\n\tk_sleep(K_MSEC(drv_data->ready_time));\n\n\terr = ads1112_read_config_reg(dev, &config_reg);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!(config_reg & ADS1112_CONFIG_OS)) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 26.19679885503028}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)\tuint8_t config;\n\tint ret;\n\n\t/* Wait for the device to be ready. */\n\tk_sleep(K_MSEC(CONFIG_ADS1112_POLL_PERIOD));\n\n\t/* Check the status. */\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* Check if the device is ready. */\n\tif (!(config & ADS1112_CONFIG_OS)) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 29.21570112059133}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)\tint ret;\n\tuint8_t config;\n\n\t/* Wait for the device to be ready for data reading. */\n\tk_sleep(K_MSEC(CONFIG_ADS1112_READ_DELAY_MS));\n\n\t/* Read the configuration register to check the status. */\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\t/* If the device is not ready, it repeatedly sleeps for 100 microseconds and checks the status again until the device is ready. */\n\twhile ((config & ADS1112_CONFIG_OS_MASK) == ADS1112_CONFIG_OS_NOT_READY) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret!= 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* If an error occurs during register reading, it returns the error code; otherwise, it returns 0 when the device is ready. */\n\tif ((config & ADS1112_CONFIG_OS_MASK) == ADS1112_CONFIG_OS_ERROR) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 57.179308768475366}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tsize_t required_buffer_size;\n\tint error_code;\n\tconst struct ads1112_config *config = sequence->chan_list.channels[0]->dev->config_info;\n\tconst struct ads1112_chan_config *chan_config = &config->channels[sequence->chan_list.channels[0]->channel_id];\n\trequired_buffer_size = sequence->options.extra_samplings + 1;\n\tif (sequence->options.extra_samplings > 0) {\n\t\trequired_buffer_size += sequence->options.extra_samplings - 1;\n\t}\n\tif (required_buffer_size > sequence->options.buffer_size) {\n\t\tLOG_ERR(\"Buffer size %d is too small for %d samplings\", sequence->options.buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\terror_code = ads1112_set_data_rate(config, chan_config, sequence->rate);\n\tif (error_code!= 0) {\n\t\treturn error_code;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 40.9890403408005}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tuint32_t num_samples = 0;\n\tuint32_t num_extra_samples = 0;\n\tuint32_t buffer_size = 0;\n\tint error_code = 0;\n\tint i;\n\n\t/*\n\t * Check if the number of samples in the ADC sequence is valid.\n\t */\n\tif (sequence->num_channels > 16) {\n\t\tLOG_ERR(\"The number of channels in the ADC sequence is too large\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the number of extra samples in the ADC sequence is valid.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->options.extra_samplings[i].channel_index == i) {\n\t\t\tnum_extra_samples++;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the number of samples in the ADC sequence.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tnum_samples += sequence->channels[i].count;\n\t}\n\n\t/*\n\t * Calculate the required buffer size.\n\t */\n\tbuffer_size = num_samples + num_extra_samples;\n\n\t/*\n\t * Check if the buffer size is sufficient.\n\t */\n\tif (buffer_size > sequence->options.buffer_size) {\n\t\tLOG_ERR(\"The buffer size in the ADC sequence is too small\");\n\t\terror_code = -ENOMEM;\n\t}\n\n\treturn error_code;\n}\n", "CodeBleu_score": 38.269268473094776}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tint ret = 0;\n\tint buffer_size = 0;\n\tint num_samplings = 0;\n\tint num_extra_samplings = 0;\n\tint num_channels = 0;\n\tint num_conversions = 0;\n\tint num_conversions_per_channel = 0;\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint num_extra_samplings_per_channel = 0;\n\tint num_extra_samplings_per_conversion = 0;\n\tint num_extra_samplings_per_channel_per_conversion = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence_per_channel = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence_per_channel_per_sampling = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence_per_channel_per_sampling_per_channel = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence_per_channel_per_sampling_per_channel_per_sampling = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence_per_channel_per_sampling_per_channel_per_sampling_per_channel = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence_per_channel_per_sampling_per_channel_per_sampling_per_channel_per_sampling = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence_per_channel_per_sampling_per_channel_per_sampling_per_channel_per_sampling_per_channel = 0;\n\tint num_extra_samplings_per_channel_per_conversion_per_sequence_per_channel_per_sampling_per_channel_per_sampling_per_channel_per_sampling_", "CodeBleu_score": 5.771814960233175}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tint rc;\n\tstruct ads1112_data *drv_data = dev->data;\n\tconst struct ads1112_config *drv_config = dev->config;\n\tuint16_t *buf = drv_data->buffer;\n\tuint16_t *buf_end = buf + drv_data->buffer_size;\n\tuint16_t *buf_ptr;\n\tuint16_t *seq_buf;\n\tuint16_t seq_buf_size;\n\tuint16_t seq_buf_idx;\n\tuint8_t seq_buf_cnt;\n\tuint8_t seq_buf_cnt_max;\n\tuint8_t seq_buf_cnt_min;\n\tuint8_t seq_buf_cnt_max_cnt;\n\tuint8_t seq_buf_cnt_min_cnt;\n\tuint8_t seq_buf_cnt_max_idx;\n\tuint8_t seq_buf_cnt_min_idx;\n\tuint8_t seq_buf_cnt_max_val;\n\tuint8_t seq_buf_cnt_min_val;\n\tuint8_t seq_buf_cnt_max_cnt_max;\n\tuint8_t seq_buf_cnt_min_cnt_min;\n\tuint8_t seq_buf_cnt_max_cnt_min;\n\tuint8_t seq_buf_cnt_min_cnt_max;\n\tuint8_t seq_buf_cnt_max_cnt_max_idx;\n\tuint8_t seq_buf_cnt_min_cnt_min_idx;\n\tuint8_t seq_buf_cnt_max_cnt_max_val;\n\tuint8_t seq_buf_cnt_min_cnt_min_val;\n\tuint8_t seq_buf_cnt_max_cnt_min_cnt_min;\n\tuint8_t seq_buf_cnt_min_cnt_max_cnt_min;\n\tuint8_t seq_buf_cnt_max_cnt_min_cnt_max;\n\tuint8_t seq_buf_cnt_min_cnt_max_cnt_max;\n\tuint", "CodeBleu_score": 25.089891399181454}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *drv_data = dev->data;\n\tuint16_t *buffer = drv_data->buffer;\n\tuint8_t *seq_buffer = drv_data->seq_buffer;\n\tuint16_t seq_buffer_size = drv_data->seq_buffer_size;\n\tuint8_t seq_buffer_len = drv_data->seq_buffer_len;\n\tint ret;\n\n\tLOG_DBG(\"ads1112_adc_start_read: %p %p %d\", dev, sequence, wait);\n\n\tif (sequence->options) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels > 4) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution!= 12) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < sequence->channels) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\tif (sequence->channels == 2) {\n\t\t\tif (sequence->channels!= 2) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (sequence->channels!= 2) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (sequence->channels!= 2) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sequence->channels!= 3) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (sequence->channels!= 3) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (sequence->channels!= 3) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sequence->channels > 1) {\n\t\tif (sequence->channels == 2) {\n\t\t\tif (sequence->channels!= 2) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (sequence->channels!= 2) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (sequence->channels!= 2) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sequence->channels!= 3) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (sequence->channels!= 3)", "CodeBleu_score": 32.822206546438395}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint rc = 0;\n\n\t/* validate the sequence */\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t/* assign the sequence buffer to the device data */\n\tdata->buffer = sequence->buffer;\n\n\t/* start the ADC read context */\n\trc = ads1112_adc_read_context_start(dev, sequence->resolution);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t/* wait for the read operation to complete */\n\tif (wait) {\n\t\trc = ads1112_adc_read_context_wait(dev, sequence->resolution);\n\t}\n\n\treturn rc;\n}\n", "CodeBleu_score": 69.65236429516511}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tstruct device *dev;\n\tstruct codec_config config = {0};\n\tchar *codec_name = NULL;\n\tchar *codec_dev_name = NULL;\n\tchar *codec_dev_id = NULL;\n\tchar *codec_dev_type = NULL;\n\tchar *codec_dev_subtype = NULL;\n\tchar *codec_dev_bus = NULL;\n\tchar *codec_dev_addr = NULL;\n\tchar *codec_dev_label = NULL;\n\tchar *codec_dev_node = NULL;\n\tchar *codec_dev_path = NULL;\n\tchar *codec_dev_instance = NULL;\n\tchar *codec_dev_vendor = NULL;\n\tchar *codec_dev_version = NULL;\n\tchar *codec_dev_serial = NULL;\n\tchar *codec_dev_power_state = NULL;\n\tchar *codec_dev_power_state_str = NULL;\n\tchar *codec_dev_active_state = NULL;\n\tchar *codec_dev_active_state_str = NULL;\n\tchar *codec_dev_plug_state = NULL;\n\tchar *codec_dev_plug_state_str = NULL;\n\tchar *codec_dev_mute_state = NULL;\n\tchar *codec_dev_mute_state_str = NULL;\n\tchar *codec_dev_jack_type = NULL;\n\tchar *codec_dev_jack_type_str = NULL;\n\tchar *codec_dev_jack_connection = NULL;\n\tchar *codec_dev_jack_connection_str = NULL;\n\tchar *codec_dev_jack_icon = NULL;\n\tchar *codec_dev_jack_icon_str = NULL;\n\tchar *codec_dev_jack_status = NULL;\n\tchar *codec_dev_jack_status_str = NULL;\n\tchar *codec_dev_jack_microphone = NULL;\n\tchar *codec_dev_jack_microphone_str = NULL;\n\tchar *codec_dev_jack_headphone = NULL;\n\tchar *codec_dev_jack_headphone_str = NULL;\n\tchar *codec_dev_jack_speaker = NULL;\n\tchar *codec_", "CodeBleu_score": 36.07962927993532}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret = 0;\n\tstruct device *dev = NULL;\n\tstruct audio_codec_cfg_data *cfg = NULL;\n\tuint32_t dev_id = 0;\n\tuint32_t i = 0;\n\tuint32_t num_of_devs = 0;\n\tuint32_t num_of_props = 0;\n\tuint32_t *prop_ids = NULL;\n\tuint32_t *prop_vals = NULL;\n\tint32_t *prop_vals_str = NULL;\n\tuint32_t *prop_vals_str_len = NULL;\n\tuint32_t *prop_vals_str_max_len = NULL;\n\tint32_t *prop_vals_str_len_ret = NULL;\n\tuint32_t *prop_vals_str_max_len_ret = NULL;\n\tuint32_t *prop_vals_str_max_len_ret_str = NULL;\n\tint32_t *prop_vals_str_max_len_ret_str_len = NULL;\n\tint32_t *prop_vals_str_max_len_ret_str_len_ret = NULL;\n\tuint32_t *prop_vals_str_max_len_ret_str_ret = NULL;\n\tuint32_t *prop_vals_str_max_len_ret_str_ret_len = NULL;\n\tint32_t *prop_vals_str_max_len_ret_str_ret_len_ret = NULL;\n\tuint32_t *prop_vals_str_ret = NULL;\n\tuint32_t *prop_vals_str_len_ret = NULL;\n\tuint32_t *prop_vals_str_max_len_ret = NULL;\n\tint32_t *prop_vals_str_max_len_ret_str = NULL;\n\tint32_t *prop_vals_str_max_len_ret_str_len = NULL;\n\tint32_t *prop_vals_str_max_len_ret_str_len_ret = NULL", "CodeBleu_score": 10.788723953956112}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tint i;\n\tstruct device *dev = NULL;\n\tchar *dev_name = NULL;\n\tstruct audio_codec_cfg_data cfg_data;\n\tstruct audio_codec_dev_config *config = NULL;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Please specify the codec device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_name = argv[1];\n\n\tfor (i = 0; i < ARRAY_SIZE(audio_codec_dev); i++) {\n\t\tif (strcmp(audio_codec_dev[i].dev_name, dev_name) == 0) {\n\t\t\tdev = device_get_binding(audio_codec_dev[i].dev_name);\n\t\t\tif (dev == NULL) {\n\t\t\t\tshell_error(sh, \"Cannot find %s device!\", dev_name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tconfig = &audio_codec_dev[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (config == NULL) {\n\t\tshell_error(sh, \"Cannot find %s device!\", dev_name);\n\t\treturn -EINVAL;\n\t}\n\n\tcfg_data.dev_name = dev_name;\n\tcfg_data.codec_dai_name = config->codec_dai_name;\n\tcfg_data.bit_width = config->bit_width;\n\tcfg_data.ch_num = config->ch_num;\n\tcfg_data.fs = config->fs;\n\tcfg_data.bitrate = config->bitrate;\n\tcfg_data.frame_fmt = config->frame_fmt;\n\tcfg_data.mono_or_stereo = config->mono_or_stereo;\n\tcfg_data.i2s_id = config->i2s_id;\n\tcfg_data.i2s_mode = config->i2s_mode;\n\tcfg_data.i2s_wlen = config->i2s_wlen;\n\tcfg_data.i2s_fs = config->i2s_fs;\n\tcfg_data.i2s_fmt = config->i2s_fmt;\n\tcfg_data.", "CodeBleu_score": 45.11756535378231}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret;\n\n\t/* Check the device state */\n\tswitch (data->state) {\n\t\tcase STATE_CONFIGURED:\n\t\t\t/* Set the I2S command */\n\t\t\tdata->i2s_cmd = cmd;\n\n\t\t\t/* Set the state to active */\n\t\t\tdata->state = STATE_ACTIVE;\n\n\t\t\t/* Send the I2S command */\n\t\t\tret = mpxxdtyy_i2s_command(dev);\n\t\t\tif (ret!= 0) {\n\t\t\t\tLOG_ERR(\"Failed to send I2S command (%d)\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase STATE_ACTIVE:\n\t\t\t/* Check the I2S command */\n\t\t\tif (data->i2s_cmd!= cmd) {\n\t\t\t\tLOG_ERR(\"I2S command mismatch\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\t/* Check the command */\n\t\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\t\t/* Set the state to configured */\n\t\t\t\tdata->state = STATE_CONFIGURED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tLOG_ERR(\"Invalid device state (%d)\", data->state);\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 50.54986263293018}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_dev_data *dd = dev->data;\n\tint ret = 0;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (dd->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_start(dd);\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is not configured\");\n\t\t\tret = -EIO;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (dd->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_stop(dd);\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is not active\");\n\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Unknown trigger command: %d\", cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 27.02642409533699}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\tu8_t i2s_cmd = 0;\n\n\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tLOG_ERR(\"Device already active\");\n\t\t\treturn -EALREADY;\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\ti2s_cmd = MPXXDTYY_I2S_CMD_STOP;\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid trigger command\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\ti2s_cmd = MPXXDTYY_I2S_CMD_START;\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tLOG_ERR(\"Device already stopped\");\n\t\t\treturn -EALREADY;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid trigger command\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Invalid device state\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (i2s_cmd) {\n\t\tret = mpxxdtyy_i2s_cmd(dev, i2s_cmd);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"I2S command failed\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 41.615384606375535}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct auxdisplay_hd44780_data *data = dev->data;\n\n\t/* Get the current configuration */\n\tuint8_t config = auxdisplay_hd44780_get_config(dev);\n\n\t/* Get the current cursor and blink settings */\n\tuint8_t cursor_blink = auxdisplay_hd44780_get_cursor_blink(dev);\n\n\t/* Set the display mode bit */\n\tif (enabled) {\n\t\tconfig |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t} else {\n\t\tconfig &= ~AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\t/* Set the cursor bit */\n\tif (cursor_blink & AUXDISPLAY_HD44780_CURSOR_ON) {\n\t\tconfig |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t} else {\n\t\tconfig &= ~AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\t/* Set the blink bit */\n\tif (cursor_blink & AUXDISPLAY_HD44780_BLINK_ON) {\n\t\tconfig |= AUXDISPLAY_HD44780_BLINK_ON;\n\t} else {\n\t\tconfig &= ~AUXDISPLAY_HD44780_BLINK_ON;\n\t}\n\n\t/* Save the configuration */\n\tdata->config = config;\n\n\t/* Set the display mode command */\n\tdata->cmd[0] = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\tdata->cmd[1] = config;\n\n\t/* Send the command to the device */\n\tauxdisplay_hd44780_write_cmd(dev, data->cmd, sizeof(data->cmd));\n}\n", "CodeBleu_score": 56.83863780719669}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd[2];\n\n\tif (enabled) {\n\t\tcmd[0] = config->cmd_display_on;\n\t\tcmd[1] = config->cmd_display_mode | config->cmd_cursor_blink;\n\t} else {\n\t\tcmd[0] = config->cmd_display_off;\n\t\tcmd[1] = config->cmd_display_mode;\n\t}\n\n\tif (config->flags & AUXDISPLAY_HD44780_FLAG_CURSOR_BLINK) {\n\t\tif (enabled) {\n\t\t\tcmd[1] |= config->cmd_cursor_blink;\n\t\t} else {\n\t\t\tcmd[1] &= ~config->cmd_cursor_blink;\n\t\t}\n\t}\n\n\tif (config->flags & AUXDISPLAY_HD44780_FLAG_CURSOR_ON) {\n\t\tif (enabled) {\n\t\t\tcmd[1] |= config->cmd_cursor_on;\n\t\t} else {\n\t\t\tcmd[1] &= ~config->cmd_cursor_on;\n\t\t}\n\t}\n\n\tif (config->flags & AUXDISPLAY_HD44780_FLAG_DISPLAY_ON) {\n\t\tif (enabled) {\n\t\t\tcmd[1] |= config->cmd_display_on;\n\t\t} else {\n\t\t\tcmd[1] &= ~config->cmd_display_on;\n\t\t}\n\t}\n\n\tif (enabled) {\n\t\tconfig->flags |= AUXDISPLAY_HD44780_FLAG_DISPLAY_ON;\n\t} else {\n\t\tconfig->flags &= ~AUXDISPLAY_HD44780_FLAG_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_write_cmd(dev, cmd, sizeof(cmd));\n}\n", "CodeBleu_score": 48.22472708566807}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t display_mode = 0;\n\n\tif (enabled) {\n\t\tif (data->cursor_blink) {\n\t\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t\t}\n\n\t\tif (data->cursor_reverse) {\n\t\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_REVERSE;\n\t\t}\n\n\t\tif (data->cursor_on) {\n\t\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t\t}\n\n\t\tif (data->display_on) {\n\t\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t\t}\n\t}\n\n\tdata->display_mode_command[0] = AUXDISPLAY_HD44780_DISPLAY_MODE_COMMAND;\n\tdata->display_mode_command[1] = display_mode;\n\tdata->display_mode_command[2] = AUXDISPLAY_HD44780_DISPLAY_MODE_COMMAND_END;\n\n\tif (enabled) {\n\t\tdata->display_mode_enabled = true;\n\t}\n\n\tif (config->i2c_addr == AUXDISPLAY_HD44780_I2C_ADDR_ALT) {\n\t\tdata->display_mode_command[0] |= AUXDISPLAY_HD44780_DISPLAY_MODE_COMMAND_ALT_ADDR;\n\t}\n\n\ti2c_write(dev, data->display_mode_command, sizeof(data->display_mode_command));\n}\n", "CodeBleu_score": 59.76795522853081}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tuint32_t port = config->busy_gpio_port;\n\tuint32_t pin = config->busy_gpio_pin;\n\tint ret;\n\n\tif (port == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_read(port, pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 60.756542483793694}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = DEV_CFG(dev);\n\n\tif (config->busy_gpio == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get(config->busy_gpio);\n}\n", "CodeBleu_score": 63.745463965337066}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tint busy;\n\n\tif (config->busy_gpio == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_read(config->busy_gpio, &busy);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\treturn busy;\n}\n", "CodeBleu_score": 67.47426391783353}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\tint rc;\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\trc = i2c_write(dev, buf, sizeof(buf), config->i2c_addr);\n\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn rc;\n}\n", "CodeBleu_score": 65.79125568441528}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\treturn i2c_write(dev, &buffer[0], 2, config->i2c_slave_address);\n}\n", "CodeBleu_score": 56.23312448585393}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tuint8_t buffer[2];\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\treturn i2c_write(dev, buffer, sizeof(buffer), AUXDISPLAY_SERLCD_I2C_ADDRESS);\n}\n", "CodeBleu_score": 43.03058766750476}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_config *config = dev->config;\n\tconst struct bbram_emul_data *data_dev = dev->data;\n\n\tif (size > config->size - offset) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &data_dev->mem[offset], size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 56.79092888882528}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_dev_cfg *cfg = dev->config;\n\tuint8_t *mem = cfg->mem;\n\tint ret = 0;\n\n\tif (size > BBRAM_EMUL_MAX_READ_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif ((offset + size) > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (size_t i = 0; i < size; i++) {\n\t\tdata[i] = mem[offset + i];\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 40.83183024927642}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_config *config = dev->config;\n\tconst struct bbram_emul_data *data_dev = dev->data;\n\n\t/* Check if the requested size is valid */\n\tif (size == 0 || size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not exceed the memory bounds */\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not involve invalid memory */\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tmemcpy(data, data_dev->mem + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 60.95168604114905}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_dev = dev->data;\n\tuint32_t *memory_bbram = data_dev->memory_bbram;\n\tuint32_t *memory_bbram_shadow = data_dev->memory_bbram_shadow;\n\tuint32_t *memory_bbram_backup = data_dev->memory_bbram_backup;\n\tuint32_t *memory_bbram_backup_shadow = data_dev->memory_bbram_backup_shadow;\n\tuint32_t *memory_bbram_invalid_state = data_dev->memory_bbram_invalid_state;\n\tuint32_t *memory_bbram_invalid_state_shadow = data_dev->memory_bbram_invalid_state_shadow;\n\tuint32_t *memory_bbram_invalid_state_backup = data_dev->memory_bbram_invalid_state_backup;\n\tuint32_t *memory_bbram_invalid_state_backup_shadow = data_dev->memory_bbram_invalid_state_backup_shadow;\n\tint32_t *memory_bbram_invalid_state_counter = data_dev->memory_bbram_invalid_state_counter;\n\tint32_t *memory_bbram_invalid_state_counter_shadow = data_dev->memory_bbram_invalid_state_counter_shadow;\n\tint32_t *memory_bbram_invalid_state_counter_backup = data_dev->memory_bbram_invalid_state_counter_backup;\n\tint32_t *memory_bbram_invalid_state_counter_backup_shadow = data_dev->memory_bbram_invalid_state_counter_backup_shadow;\n\tint32_t *memory_bbram_invalid_state_counter_max = data_dev->memory_bbram_invalid_state_counter_max;\n\tint32_t *memory_bbram_invalid_state_", "CodeBleu_score": 20.83553220605357}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_dev_data *const data_dev = BBRAM_DEV_DATA(dev);\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_dev->state == BBRAM_EMUL_STATE_INVALID) {\n\t\treturn -EIO;\n\t}\n\n\tif (data_dev->state == BBRAM_EMUL_STATE_WRITING) {\n\t\treturn -EBUSY;\n\t}\n\n\tif (data_dev->state == BBRAM_EMUL_STATE_WRITTEN) {\n\t\treturn -EIO;\n\t}\n\n\tif (data_dev->state == BBRAM_EMUL_STATE_WRITING_ZERO) {\n\t\treturn -EBUSY;\n\t}\n\n\tif (data_dev->state == BBRAM_EMUL_STATE_WRITTEN_ZERO) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_dev->memory + offset, data, size);\n\n\tif (data_dev->state == BBRAM_EMUL_STATE_ERASED) {\n\t\tdata_dev->state = BBRAM_EMUL_STATE_WRITING;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 46.170192816414215}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *data_dev = dev->data;\n\n\t/* Check if the write size is valid. */\n\tif (size == 0 || size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM. */\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state. */\n\tif (data_dev->state == BBRAM_EMUL_STATE_INVALID) {\n\t\treturn -EFAULT;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory. */\n\tmemcpy(data_dev->memory + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 56.01912675079884}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\n\tint err;\n\n\tif (argc == 1) {\n\t\tshell_error(sh, \"No device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Could not get BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 77.51530406140628}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev) ", "CodeBleu_score": 8.854166666666668}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\n\tif (argc == 1) {\n\t\tshell_error(sh, \"No BBRAM device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Could not get BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 78.8128262694148}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev)\tint32_t num_bytes_read;\n\n\tnum_bytes_read = uart_fifo_read(dev, (uint8_t *)h4_hdr_buf, h4_hdr_buf_len);\n\n\tif (num_bytes_read < 0) {\n\t\tLOG_ERR(\"UART read failed\");\n\t} else {\n\t\th4_hdr_buf_len -= num_bytes_read;\n\t}\n}\n", "CodeBleu_score": 20.346069766602163}, {"code": "static void h4_read_hdr(const struct device *dev)\tuint8_t hdr_len;\n\tint ret;\n\n\thdr_len = h4_hdr_len(dev);\n\tif (hdr_len > 0) {\n\t\tret = uart_fifo_read(dev, h4_hdr_buf + h4_hdr_len(dev), hdr_len);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read %d bytes from UART device\", hdr_len);\n\t\t} else {\n\t\t\th4_hdr_len_set(dev, h4_hdr_len(dev) + ret);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.978554024680776}, {"code": "static void h4_read_hdr(const struct device *dev)\tuint8_t hdr_bytes_read;\n\tuint8_t hdr_bytes_remaining;\n\n\thdr_bytes_read = H4_HDR_SIZE - H4_HDR_SIZE_FIELD_SIZE;\n\thdr_bytes_remaining = H4_HDR_SIZE - hdr_bytes_read;\n\n\t/*\n\t * Read the remaining bytes from the UART FIFO into the header buffer.\n\t */\n\twhile (hdr_bytes_remaining) {\n\t\tint bytes_read;\n\n\t\tbytes_read = uart_fifo_read(dev, &h4_hdr_buf[hdr_bytes_read], hdr_bytes_remaining);\n\n\t\tif (bytes_read < 0) {\n\t\t\tLOG_ERR(\"Failed to read header data\");\n\t\t\treturn;\n\t\t}\n\n\t\thdr_bytes_read += bytes_read;\n\t\thdr_bytes_remaining -= bytes_read;\n\t}\n\n\t/*\n\t * Update the remaining byte count based on the number of bytes successfully read.\n\t */\n\th4_hdr.bytes_remaining = h4_hdr_buf[H4_HDR_SIZE_FIELD_SIZE];\n}\n", "CodeBleu_score": 38.83841170289129}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t bytes_read = 0;\n\twhile (len > 0) {\n\t\tsize_t bytes_to_read = min(len, sizeof(buf));\n\t\tint ret = uart_fifo_read(uart, buf, bytes_to_read);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART device %s\", uart->name);\n\t\t\treturn bytes_read;\n\t\t} else if (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbytes_read += ret;\n\t\tlen -= ret;\n\t}\n\treturn bytes_read;\n}\n", "CodeBleu_score": 35.911087088894526}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tchar buf[33];\n\tsize_t n = 0;\n\twhile (len) {\n\t\tsize_t m = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\t\tif (m == 0) {\n\t\t\tLOG_ERR(\"Failed to read %d bytes from %s\", len, uart->name);\n\t\t\treturn n;\n\t\t}\n\t\tlen -= m;\n\t\tn += m;\n\t}\n\treturn n;\n}\n", "CodeBleu_score": 41.87363905682394}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t n = 0;\n\twhile (len > 0) {\n\t\tsize_t m = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\t\tif (m == 0) {\n\t\t\tLOG_ERR(\"Failed to read from %s\", uart->name);\n\t\t\treturn n;\n\t\t}\n\t\tn += m;\n\t\tlen -= m;\n\t}\n\treturn n;\n}\n", "CodeBleu_score": 43.51842379739583}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tstruct zbus_observer *o;\n\tint hop = ZBUS_OBSERVER_PRIORITY_MIN;\n\n\tzbus_channel_lock(chan);\n\tHASH_ITER(hh, chan->observers, o, tmp) {\n\t\tif (o->priority < hop && o->enabled)\n\t\t\thop = o->priority;\n\t}\n\tchan->hop = hop;\n\tzbus_channel_unlock(chan);\n}\n", "CodeBleu_score": 15.39984148759112}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tint i;\n\tint hop = 0;\n\tzbus_mutex_lock(chan->data_lock);\n\tfor (i = 0; i < chan->observer_count; i++) {\n\t\tconst struct zbus_observer *o = &chan->observers[i];\n\t\tif (o->priority < hop && o->enabled) {\n\t\t\thop = o->priority;\n\t\t}\n\t}\n\tchan->hop = hop;\n\tzbus_mutex_unlock(chan->data_lock);\n}\n", "CodeBleu_score": 20.41266048926027}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tstruct zbus_observer *obs;\n\tuint8_t hop = ZBUS_HOP_MAX;\n\n\t/* Lock channel */\n\tzbus_mutex_lock(chan->lock);\n\n\t/* Iterate through observers */\n\tfor (obs = chan->observers; obs!= NULL; obs = obs->next) {\n\t\t/* Check if observer is enabled */\n\t\tif (obs->enabled == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check if observer priority is lower than current highest */\n\t\tif (obs->priority < hop) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\t/* Set highest observer priority */\n\tchan->hop = hop;\n\n\t/* Unlock channel */\n\tzbus_mutex_unlock(chan->lock);\n}\n", "CodeBleu_score": 25.147612304467472}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tstruct zbus_observer *cur_obs = obs;\n\twhile (cur_obs) {\n\t\tupdate_channel_hop(cur_obs);\n\t\tcur_obs = cur_obs->next;\n\t}\n}\n", "CodeBleu_score": 16.64954422035823}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tstruct zbus_channel_observer *o = NULL;\n\tstruct zbus_channel *ch = NULL;\n\n\tif (!obs)\n\t\treturn;\n\n\tHASH_ITER(hh, channel_observers, o, tmp) {\n\t\tif (obs->type == ZBUS_OBSERVER_TYPE_CHANNEL && obs->id == o->id) {\n\t\t\tch = zbus_channel_get(o->id);\n\t\t\tif (ch) {\n\t\t\t\tzbus_channel_update(ch, obs->data);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 17.780832714895055}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tstruct channel_hop *ch;\n\n\tfor (ch = channel_hops; ch; ch = ch->next) {\n\t\tif (ch->obs == obs) {\n\t\t\tupdate_channel_hop(ch);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 17.360676542712405}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tassert(obs!= NULL);\n\tassert(zbus_obs_is_locked(obs));\n\tassert(zbus_obs_is_attached(obs));\n\tassert(!in_interrupt());\n\tint rc = 0;\n\tif (obs->thread == NULL) {\n\t\trc = -1;\n\t} else {\n\t\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\t\tobs->thread = NULL;\n\t\tzbus_channel_update_priority(obs->channels);\n\t\tk_spin_unlock(&obs->lock, key);\n\t}\n\treturn rc;\n}\n", "CodeBleu_score": 40.18053983096409}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tint rc = 0;\n\tassert(obs!= NULL);\n\tassert(obs->zbus_obs_thread!= NULL);\n\tif (zbus_obs_is_in_isr(obs)) {\n\t\treturn -1;\n\t}\n\tspin_lock_irqsave(&obs->zbus_obs_lock);\n\tobs->zbus_obs_thread->zbus_thread_priority = ZBUS_THREAD_PRIORITY_MIN;\n\tfor (int i = 0; i < ZBUS_MAX_CHANNELS; i++) {\n\t\tif (obs->zbus_obs_channels[i]!= NULL) {\n\t\t\tzbus_channel_update(obs->zbus_obs_channels[i]);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&obs->zbus_obs_lock);\n\treturn rc;\n}\n", "CodeBleu_score": 41.76628405478364}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tint rc = 0;\n\tif (obs == NULL) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (zbus_is_in_isr()) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tspin_lock_bh(&obs->lock);\n\tobs->priority = ZBUS_THREAD_PRIORITY_MIN;\n\tzbus_channel_update_observer(obs);\n\tspin_unlock_bh(&obs->lock);\n", "CodeBleu_score": 44.608354943251314}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint rc = 0;\n\tstruct zbus_channel_state *state;\n\tstruct zbus_channel_state *new_state;\n\tk_timeout_t end_time;\n\tk_timeout_t now;\n\tk_timeout_t remaining;\n\tk_timeout_t notify_time;\n\tk_timeout_t notify_remaining;\n\tk_timeout_t notify_timeout;\n\tk_timeout_t notify_timeout_remaining;\n\tk_timeout_t notify_timeout_orig;\n\tk_timeout_t notify_timeout_orig_remaining;\n\tk_timeout_t notify_timeout_orig_remaining_adjusted;\n\tk_timeout_t notify_timeout_orig_adjusted;\n\tk_timeout_t notify_timeout_adjusted;\n\tk_timeout_t notify_timeout_adjusted_remaining;\n\tk_timeout_t notify_timeout_adjusted_remaining_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted_adjusted_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted_adjusted;\n\tk_timeout_t notify_timeout_adjusted_adjusted_remaining_adjusted_adjusted_adjusted_adjusted", "CodeBleu_score": 4.547052376016736}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint rc = 0;\n\tstruct zbus_context *ctx;\n\tstruct zbus_chan_notify_context *notify_ctx;\n\tk_timeout_t end_time;\n\tint notify_prio;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\t/*\n\t\t * If in ISR, adjust timeout to be minimum of 1ms and\n\t\t * the remaining time in the ISR.\n\t\t */\n\t\tk_timeout_t isr_timeout = k_is_in_isr()? k_isrs_remaining() : K_FOREVER;\n\t\ttimeout = K_MIN(K_MSEC(1), K_MIN(timeout, isr_timeout));\n\t}\n\n\tend_time = k_uptime_get() + timeout;\n\tnotify_ctx = zbus_chan_notify_context_get(chan);\n\tif (notify_ctx == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tctx = zbus_chan_context_get(chan);\n\tif (ctx == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tnotify_prio = ctx->priority + 1;\n\tif (notify_prio > CONFIG_ZBUS_MAX_PRIORITY) {\n\t\tnotify_prio = CONFIG_ZBUS_MAX_PRIORITY;\n\t}\n\n\tnotify_ctx->priority = notify_prio;\n\tnotify_ctx->end_time = end_time;\n\n\tzbus_chan_lock(chan);\n\trc = zbus_chan_notify_locked(chan, notify_ctx);\n\tzbus_chan_unlock(chan);\n\n\treturn rc;\n}\n", "CodeBleu_score": 41.48883095620883}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint rc = 0;\n\tstruct zbus_context *ctx = NULL;\n\tstruct zbus_chan_state *state = NULL;\n\tstruct zbus_chan_notify_context *notify_ctx = NULL;\n\tstruct zbus_chan_notify_context notify_ctx_stack;\n\tstruct k_thread *thread = NULL;\n\tk_timeout_t end_time = 0;\n\tk_timeout_t notify_timeout = 0;\n\tk_timeout_t notify_max_timeout = 0;\n\tk_timeout_t notify_min_timeout = 0;\n\tk_timeout_t notify_delta_timeout = 0;\n\tk_timeout_t notify_start_time = 0;\n\tk_timeout_t notify_end_time = 0;\n\tk_timeout_t notify_timeout_min = 0;\n\tk_timeout_t notify_timeout_max = 0;\n\tk_timeout_t notify_timeout_delta = 0;\n\tk_timeout_t notify_timeout_start = 0;\n\tk_timeout_t notify_timeout_end = 0;\n\tk_timeout_t notify_timeout_min_delta = 0;\n\tk_timeout_t notify_timeout_max_delta = 0;\n\tk_timeout_t notify_timeout_min_start = 0;\n\tk_timeout_t notify_timeout_min_end = 0;\n\tk_timeout_t notify_timeout_max_start = 0;\n\tk_timeout_t notify_timeout_max_end = 0;\n\tk_timeout_t notify_timeout_delta_start = 0;\n\tk_timeout_t notify_timeout_delta_end = 0;\n\tk_timeout_t notify_timeout_delta_min = 0;\n\tk_timeout_t notify_timeout_delta_max = 0;\n\tk_timeout_t notify_timeout_delta_min_start = 0;\n\tk_timeout_t notify_timeout_delta_min_end = 0;\n\tk_timeout_t notify_timeout_delta_max_start = 0;\n\tk_timeout", "CodeBleu_score": 9.780040662180129}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tif (Int == ETH_INT_TX) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_TXEIEN;\n\t\t} else {\n\t\t\tETH->INTEN &= ~ETH_INTEN_TXEIEN;\n\t\t}\n\t} else if (Int == ETH_INT_RX) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXEIEN;\n\t\t} else {\n\t\t\tETH->INTEN &= ~ETH_INTEN_RXEIEN;\n\t\t}\n\t} else if (Int == ETH_INT_LPI) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_LPIEN;\n\t\t} else {\n\t\t\tETH->INTEN &= ~ETH_INTEN_LPIEN;\n\t\t}\n\t} else if (Int == ETH_INT_TXC) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_TXCEN;\n\t\t} else {\n\t\t\tETH->INTEN &= ~ETH_INTEN_TXCEN;\n\t\t}\n\t} else if (Int == ETH_INT_RXC) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXCEN;\n\t\t} else {\n\t\t\tETH->INTEN &= ~ETH_INTEN_RXCEN;\n\t\t}\n\t} else if (Int == ETH_INT_WAKEUP) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_WAKEUPIEN;\n\t\t} else {\n\t\t\tETH->INTEN &= ~ETH_INTEN_WAKEUPIEN;\n\t\t}\n\t} else if (Int == ETH_INT_MMC) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_MMCIEN;\n\t\t} else {\n\t\t\tETH->INTEN &= ~ETH_INTEN_MMCIEN;\n\t\t}\n\t} else if (Int == ETH_INT_PMT) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_PMTIEN;\n\t\t} else {\n\t\t\tETH->INTEN &= ~ETH_INTEN_PMTIEN;\n\t\t}\n\t} else if (Int == ETH_INT_ALL) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_TXEIEN |", "CodeBleu_score": 36.07757324081413}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tif(Int > ETH_INT_LPIORX) {\n\t\treturn;\n\t}\n\n\tif(enable) {\n\t\tif(Int < ETH_INT_RX) {\n\t\t\tETH->INTEN |= (1 << Int);\n\t\t} else {\n\t\t\tETH->INTEN |= (1 << (Int - 4));\n\t\t}\n\t} else {\n\t\tif(Int < ETH_INT_RX) {\n\t\t\tETH->INTEN &= ~(1 << Int);\n\t\t} else {\n\t\t\tETH->INTEN &= ~(1 << (Int - 4));\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.062369570751315}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_FUNCTIONAL_STATE(enable));\n\n\tif (enable!= DISABLE) {\n\t\t/* Check if interrupt is abnormal */\n\t\tif (Int & ETH_INT_NIS) {\n\t\t\t/* Enable abnormal interrupt */\n\t\t\tETH->IER |= ETH_INT_NIS;\n\t\t} else {\n\t\t\t/* Enable normal interrupt */\n\t\t\tETH->IER |= Int;\n\t\t}\n\t} else {\n\t\t/* Disable interrupt */\n\t\tETH->IER &= ~Int;\n\n\t\t/* Check if there is no more enabled interrupt */\n\t\tif ((ETH->IER & ETH_INT_NIS) == 0) {\n\t\t\t/* Disable abnormal interrupt */\n\t\t\tETH->IER &= ~ETH_INT_NIS;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.34667306886593}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pTxDesc = &g_sTxDesc[0];\n\tunsigned int uiIndex;\n\n\tfor(uiIndex = 0; uiIndex < TX_DESCRIPTORS; uiIndex++, pTxDesc++) {\n\t\tif(pTxDesc->uiStatus == TX_DESC_FREE) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 22.64868962588418}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pTxDesc = &TxDesc[0];\n\tunsigned int i = 0;\n\tunsigned int iStop = 0;\n\tunsigned int iStart = 0;\n\tunsigned int iLoop = 0;\n\tunsigned int iTemp = 0;\n\n\tiStart = pTxDesc->iNextTxDescToFill;\n\tiStop = pTxDesc->iNextTxDescToFill;\n\tiLoop = 0;\n\twhile (iLoop < 1000000) {\n\t\tiTemp = pTxDesc->iNextTxDescToFill;\n\t\tif (iTemp == iStop) {\n\t\t\treturn 0;\n\t\t}\n\t\tiStop = iTemp;\n\t\tiTemp = iTemp + 1;\n\t\tif (iTemp >= MAX_TX_DESC_CNT) {\n\t\t\tiTemp = 0;\n\t\t}\n\t\tif (iTemp == iStart) {\n\t\t\tbreak;\n\t\t}\n\t\tpTxDesc = &TxDesc[iTemp];\n\t\tiLoop++;\n\t}\n\tpTxDesc = &TxDesc[iTemp];\n\ti = iTemp;\n\twhile (iLoop < 1000000) {\n\t\tif (pTxDesc->iNextTxDescToFill == i) {\n\t\t\tif (pTxDesc->ucOwnedByDMA == 0) {\n\t\t\t\tpTxDesc->ucOwnedByDMA = 1;\n\t\t\t\treturn pTxDesc;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i >= MAX_TX_DESC_CNT) {\n\t\t\ti = 0;\n\t\t}\n\t\tif (i == iTemp) {\n\t\t\tbreak;\n\t\t}\n\t\tpTxDesc = &TxDesc[i];\n\t\tiLoop++;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 33.15265630208062}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pTxDesc;\n\tuint32_t cur_desc_addr;\n\tuint32_t cur_desc_status;\n\tuint32_t cur_desc_length;\n\tuint32_t cur_desc_buf_length;\n\tuint32_t cur_desc_buf_addr;\n\tuint32_t cur_desc_buf_addr_aligned;\n\tuint32_t cur_desc_buf_addr_aligned_end;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end_aligned;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end_aligned_end;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end_aligned_end_aligned;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end_aligned;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end_aligned;\n\tuint32_t cur_desc_buf_addr_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end_aligned_end;\n\tuint32_t cur_desc_buf", "CodeBleu_score": 2.715569003912194}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\trt_err_t result = RT_EOK;\n\tif (device == NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: device is NULL\\n\");\n\t\tresult = -RT_ERROR;\n\t} else if (value == NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: value is NULL\\n\");\n\t\tresult = -RT_ERROR;\n\t} else {\n\t\tCy_CSD_Type *base = device->parent.parent.user_data;\n\t\tCy_CSD_IDAC_Channel_Type *dac_channel = &base->idac[channel];\n\t\tCy_CSD_IDAC_Enable(dac_channel);\n\t\tCy_CSD_IDAC_SetValue(dac_channel, *value);\n\t\tCy_CSD_IDAC_StartConvert(dac_channel);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 35.568277730457446}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\tif (device == RT_NULL) {\n\t\tCY_LOG_E(\"device is NULL\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (channel >= device->info.channel_num) {\n\t\tCY_LOG_E(\"channel:%d is out of range\", channel);\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (device->info.dev_class == RT_DEVICE_CLASS_DAC) {\n\t\tCy_CSD_Enable(device->info.base, device->info.context);\n\t}\n\n\tif (Cy_CSD_IsReady(device->info.base, device->info.context) == 0) {\n\t\tCY_LOG_E(\"CSD is not ready\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tCy_CSD_SetDacRef(device->info.base, device->info.context, CY_CSD_DAC_REF_INT_1_024VREF);\n\n\tif (Cy_CSD_SetDacTrim(device->info.base, device->info.context, CY_CSD_DAC_TRIM_DEFAULT)!= CY_CSD_SUCCESS) {\n\t\tCY_LOG_E(\"Set DAC trim failed\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (Cy_CSD_SetDacVdda(device->info.base, device->info.context, CY_CSD_DAC_VDDA_AUTO)!= CY_CSD_SUCCESS) {\n\t\tCY_LOG_E(\"Set DAC VDDA failed\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (Cy_CSD_SetDacVref(device->info.base, device->info.context, CY_CSD_DAC_VREF_AUTO)!= CY_CSD_SUCCESS) {\n\t\tCY_LOG_E(\"Set DAC Vref failed\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (Cy_CSD_SetDacVrefBuffer(device->info.base, device->info.context, CY_CSD_DAC_VREF_BUFFER_AUTO)!= CY_CSD_SUCCESS) {\n\t\tCY_LOG_E(\"Set DAC Vref buffer failed\");\n\t\treturn -RT_ERROR;\n\t}", "CodeBleu_score": 37.32790594370379}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\tcy_stc_csd_config_t config;\n\tcy_stc_csd_context_t context;\n\tcy_stc_csd_idac_config_t idacConfig;\n\tcy_stc_csd_idac_context_t idacContext;\n\tcy_en_csd_status_t status;\n\n\tif (device == NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: device is NULL\\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Configure the CSD HW block. */\n\tconfig.skipStandby = CY_CSD_SKIP_STANDBY_FOR_ADC;\n\tconfig.skipStandbyMode = CY_CSD_SKIP_STANDBY_FOR_ADC;\n\tconfig.skipStandbyCallback = NULL;\n\tconfig.skipStandbyCallbackParam = NULL;\n\tstatus = Cy_CSD_Init(device, &config, &context);\n\tif (status!= CY_CSD_SUCCESS) {\n\t\trt_kprintf(\"cyp_adc_convert: Cy_CSD_Init failed with %d\\n\", status);\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Configure the IDAC HW block. */\n\tidacConfig.referenceExt = CY_CSD_IDAC_REF_EXT_VREF;\n\tidacConfig.outputMode = CY_CSD_IDAC_OUTPUT_MODE_SW_AND_HW_CONTROLLED;\n\tidacConfig.swCtrlBypass = CY_CSD_SW_CTRL_BYPASS_OFF;\n\tidacConfig.swCtrlBypassInit = CY_CSD_SW_CTRL_BYPASS_OFF;\n\tidacConfig.swCascade = CY_CSD_SW_CTRL_CASCADE_OFF;\n\tidacConfig.swCascadeInit = CY_CSD_SW_CTRL_CASCADE_OFF;\n\tidacConfig.swShield = CY_CSD_SW_SHIELD_OFF;\n\tidacConfig.swShieldInit = CY_CSD_SW_SHIELD_OFF;\n\tidacConfig.swCmp = CY_CSD_SW_CMP_OFF;\n\tidacConfig.swCmpInit = CY_CSD_SW_CMP", "CodeBleu_score": 45.5290702540833}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\tint ret = 0;\n\trt_uint32_t end_addr = addr + size;\n\trt_uint32_t page_addr = 0;\n\trt_uint32_t page_size = 0;\n\trt_uint32_t page_offset = 0;\n\trt_uint32_t page_remaining = 0;\n\n\tif (end_addr > IFX_FLASH_END_ADDR) {\n\t\trt_kprintf(\"Error: Read operation would exceed flash memory's end address\\n\");\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\twhile (addr < end_addr) {\n\t\tpage_addr = addr & ~(IFX_FLASH_PAGE_SIZE - 1);\n\t\tpage_size = IFX_FLASH_PAGE_SIZE - (addr & (IFX_FLASH_PAGE_SIZE - 1));\n\t\tpage_offset = addr - page_addr;\n\t\tpage_remaining = size - (addr - addr);\n\n\t\tif (page_size > page_remaining) {\n\t\t\tpage_size = page_remaining;\n\t\t}\n\n\t\tret = ifx_flash_read_page(page_addr, buf, page_size);\n\t\tif (ret < 0) {\n\t\t\tgoto end;\n\t\t}\n\n\t\taddr += page_size;\n\t\tbuf += page_size;\n\t}\n", "CodeBleu_score": 29.784685455769388}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\trt_uint32_t i;\n\trt_uint32_t end_addr;\n\trt_uint32_t read_size;\n\n\t/* Check if the read operation would exceed the flash memory's end address */\n\tend_addr = ifx_flash_get_end_addr();\n\tif ((addr + size) > end_addr) {\n\t\trt_kprintf(\"The read operation would exceed the flash memory's end address\\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* Read the specified size of data from the flash memory address into the buffer, byte by byte */\n\tfor (i = 0; i < size; i++) {\n\t\tread_size = ifx_flash_read(addr + i, buf + i, 1);\n\t\tif (read_size == 0) {\n\t\t\trt_kprintf(\"The read operation failed\\n\");\n\t\t\treturn -RT_ERROR;\n\t\t}\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 50.374387239418596}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\trt_uint32_t end_addr;\n\tint ret;\n\n\t/* Check if the read operation would exceed the flash memory's end address */\n\tend_addr = ifx_flash_get_end_addr();\n\tif (addr + size > end_addr) {\n\t\trt_kprintf(\"ifx_flash_read_32k: Read operation would exceed flash memory's end address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read the data from the flash memory address into the buffer, byte by byte */\n\twhile (size > 0) {\n\t\tret = ifx_flash_read_byte(addr, buf);\n\t\tif (ret!= 1) {\n\t\t\trt_kprintf(\"ifx_flash_read_32k: Failed to read byte from flash memory\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\taddr++;\n\t\tbuf++;\n\t\tsize--;\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 33.91220656393352}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\tstruct rt_hwtimer_device *timer_device = (struct rt_hwtimer_device *)timer->parent.user_data;\n\tif (timer_device == NULL) {\n\t\treturn 0;\n\t}\n\treturn cyhal_timer_read(timer_device->hal_timer);\n}\n", "CodeBleu_score": 18.872089885175725}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\trt_uint32_t count = cyhal_timer_read(timer_obj);\n\treturn count;\n}\n", "CodeBleu_score": 52.19423213168225}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\tstruct rt_hwtimer_device *timer_dev;\n\tcyhal_timer_t *timer_obj;\n\trt_uint32_t counter;\n\n\ttimer_dev = (struct rt_hwtimer_device *)timer->parent.user_data;\n\ttimer_obj = (cyhal_timer_t *)timer_dev->parent.user_data;\n\n\tcounter = cyhal_timer_read(timer_obj);\n\n\treturn counter;\n}\n", "CodeBleu_score": 53.55603132672695}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void)\twhile (1) {\n\t\tif (mutex_trylock(&fs_mutex) == 0) {\n\t\t\treturn;\n\t\t}\n\t\t// TODO: sleep\n\t}\n}\n", "CodeBleu_score": 7.010126558902041}, {"code": "void dfs_lock(void)\tint i;\n\tfor (i = 0; i < 100000; i++) {\n\t\tif (mutex_lock(lock) == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert(i!= 100000);\n}\n", "CodeBleu_score": 18.46259818015053}, {"code": "void dfs_lock(void)\t/* TODO: Your code here */\n\tmutex_lock(mutex);\n}\n", "CodeBleu_score": 2.845087782329663}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint fd;\n\tfor (fd = startfd; fd < fdt->maxfds; fd++) {\n\t\tif (!fdt->fd_array[fd].fd_ptr) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* No empty slot found. Expand the table. */\n\treturn fdtable_expand(fdt, startfd);\n}\n", "CodeBleu_score": 28.243371344753044}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint fd;\n\tint i;\n\tint nr;\n\tint maxfd;\n\tint nfds;\n\tint ret;\n\n\tmaxfd = fdt->maxfd;\n\tnfds = fdt->nfds;\n\tnr = fdt->nr;\n\tfor (i = startfd; i < maxfd; i++) {\n\t\tif (fdt->fd[i].fd == -1) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (maxfd >= nfds) {\n\t\tif (nfds == 0) {\n\t\t\tnfds = FDTABLE_ALLOC_STEP;\n\t\t} else {\n\t\t\tnfds += FDTABLE_ALLOC_STEP;\n\t\t}\n\n\t\tret = fd_table_expand(fdt, nfds);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = maxfd; i < nfds; i++) {\n\t\tif (fdt->fd[i].fd == -1) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "CodeBleu_score": 45.52018836428161}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint fd;\n\tint i;\n\tint empty = -1;\n\n\t/* Try the specified slot first */\n\tfd = startfd;\n\tif (fd < 0) {\n\t\tfd = 0;\n\t}\n\n\tif (fd < fdt->maxfds) {\n\t\tif (fdt->fd_array[fd] == NULL) {\n\t\t\treturn fd;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Then the rest */\n\tfor (i = fd; i < fdt->maxfds; i++) {\n\t\tif (fdt->fd_array[i] == NULL) {\n\t\t\tempty = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (empty >= 0) {\n\t\treturn empty;\n\t}\n\n\treturn fdtable_expand(fdt, startfd);\n}\n", "CodeBleu_score": 38.32986370489931}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error)\tif (error < 0)\n\t\terror = -error;\n\n\tfor (int i = 0; i < sizeof(rt_err_str) / sizeof(rt_err_str[0]); i++)\n\t\tif (error == rt_err_str[i].code)\n\t\t\treturn rt_err_str[i].str;\n\n\treturn \"EUNKNOW\";\n}\n", "CodeBleu_score": 45.31091440879294}, {"code": "const char *rt_strerror(rt_err_t error)\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < sizeof(rt_err_str) / sizeof(rt_err_str[0]); i++) {\n\t\tif (rt_err_str[i].err == error) {\n\t\t\treturn rt_err_str[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}\n", "CodeBleu_score": 59.30020049284419}, {"code": "const char *rt_strerror(rt_err_t error)\tif (error < 0)\n\t\terror = -error;\n\tswitch (error) {\n\tcase RT_EOK:\n\t\treturn \"OK\";\n\tcase RT_EUNKNOWN:\n\t\treturn \"Unknown Error\";\n\tcase RT_ENOMEM:\n\t\treturn \"Out of memory\";\n\tcase RT_ETIMEOUT:\n\t\treturn \"Time out\";\n\tcase RT_EFULL:\n\t\treturn \"The resource is full\";\n\tcase RT_EEMPTY:\n\t\treturn \"The resource is empty\";\n\tcase RT_EBUSY:\n\t\treturn \"The resource is busy\";\n\tcase RT_EINVAL:\n\t\treturn \"Invalid argument\";\n\tcase RT_ENOSYS:\n\t\treturn \"Function not implemented\";\n\tcase RT_EIO:\n\t\treturn \"I/O Error\";\n\tcase RT_EINTR:\n\t\treturn \"Interrupted\";\n\tcase RT_EAGAIN:\n\t\treturn \"No more data\";\n\tcase RT_EPERM:\n\t\treturn \"No permission\";\n\tcase RT_EPIPE:\n\t\treturn \"Broken pipe\";\n\tcase RT_EVERR:\n\t\treturn \"Verification failed\";\n\tcase RT_EADDRINUSE:\n\t\treturn \"Address in use\";\n\tcase RT_ECONNABORTED:\n\t\treturn \"Connection aborted\";\n\tcase RT_ECONNRESET:\n\t\treturn \"Connection reset\";\n\tcase RT_ENOTCONN:\n\t\treturn \"The socket is not connected\";\n\tcase RT_EISCONN:\n\t\treturn \"The socket is already connected\";\n\tcase RT_ECONNREFUSED:\n\t\treturn \"Connection refused\";\n\tcase RT_EHOSTUNREACH:\n\t\treturn \"No route to host\";\n\tcase RT_EALREADY:\n\t\treturn \"Connection already in progress\";\n\tcase RT_EINPROGRESS:\n\t\treturn \"Operation in progress\";\n\tcase RT_EILSEQ:\n\t\treturn \"Illegal byte sequence\";\n\tcase RT_ENETDOWN:\n\t\treturn \"Network is down\";\n\tcase RT_EADDRNOTAVAIL:\n\t\treturn \"Address is not available\";\n\tcase RT_EAFNOSUPPORT:\n\t\treturn \"Address family not supported\";\n\tcase RT_ENETUNREACH:\n\t\treturn \"Network is unreachable\";\n", "CodeBleu_score": 29.14201906371805}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_base_t level;\n\trt_thread_idle_hook_t *hook_ptr;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (idle_hook_list.next == RT_NULL) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn -RT_EFULL;\n\t}\n\n\thook_ptr = (rt_thread_idle_hook_t *)idle_hook_list.next;\n\tidle_hook_list.next = hook_ptr->next;\n\trt_hw_interrupt_enable(level);\n\n\thook_ptr->next = RT_NULL;\n\thook_ptr->hook = hook;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (idle_hook_tail == RT_NULL) {\n\t\tidle_hook_head = hook_ptr;\n\t} else {\n\t\tidle_hook_tail->next = hook_ptr;\n\t}\n\tidle_hook_tail = hook_ptr;\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 32.77817985022987}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_err_t result;\n\trt_base_t level;\n\tstruct rt_thread *thread;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (idle_hook_list.next!= RT_NULL) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn -RT_EFULL;\n\t}\n\n\tthread = rt_thread_self();\n\tif (thread == RT_NULL) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn -RT_ERROR;\n\t}\n\n\tidle_hook_list.next = thread;\n\tidle_hook_list.data = hook;\n\trt_hw_interrupt_enable(level);\n\n\tresult = rt_thread_resume(idle_thread);\n\tif (result == RT_EOK) {\n\t\treturn RT_EOK;\n\t} else {\n\t\treturn -RT_ERROR;\n\t}\n}\n", "CodeBleu_score": 29.50149234719248}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_err_t result;\n\trt_base_t level;\n\trt_thread_idle_hook_t *idle_hook;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* lock */\n\tif (rt_thread_idle_hook_lock) {\n\t\t/* release interrupt */\n\t\trt_hw_interrupt_enable(level);\n\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* find an empty slot */\n\tidle_hook = &rt_thread_idle_hook_list[0];\n\twhile (idle_hook->func!= RT_NULL) {\n\t\tidle_hook ++;\n\t}\n\n\t/* set the hook */\n\tidle_hook->func = hook;\n\n\t/* release interrupt */\n\trt_hw_interrupt_enable(level);\n\n\t/* release lock */\n\trt_thread_idle_hook_lock = 0;\n\n\tresult = RT_EOK;\n\n\treturn result;\n}\n", "CodeBleu_score": 29.70610086426059}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_err_t ret = RT_EOK;\n\trt_uint8_t index;\n\trt_base_t level;\n\tstruct rt_thread *tid;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (hook == RT_NULL) {\n\t\tret = RT_ERROR;\n\t\tgoto __exit;\n\t}\n\n\tfor (index = 0; index < RT_IDLE_HOOK_LIST_SIZE; index++) {\n\t\tif (idle_hook_list[index] == hook) {\n\t\t\tidle_hook_list[index] = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index == RT_IDLE_HOOK_LIST_SIZE) {\n\t\tret = RT_ERROR;\n\t\tgoto __exit;\n\t}\n\n\t/* check whether the hook is in the thread idle hook list */\n\tfor (tid = idle_thread_list; tid!= RT_NULL; tid = tid->idle_thread.next) {\n\t\tif (tid->idle_thread.hook == hook) {\n\t\t\ttid->idle_thread.hook = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n", "CodeBleu_score": 42.28863036765795}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_err_t result = RT_EOK;\n\trt_bool_t found = RT_FALSE;\n\trt_base_t level;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* find the hook */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_NUM; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tfound = RT_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\t/* check result */\n\tif (found) {\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_ENOSYS;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 57.705255012076776}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_err_t result = RT_EOK;\n\trt_uint32_t index;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\tfor (index = 0; index < IDLE_HOOK_LIST_SIZE; index++) {\n\t\tif (idle_hook_list[index] == hook) {\n\t\t\tidle_hook_list[index] = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 57.04888352793218}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\trt_thread_t thread;\n\trt_err_t result;\n\n\t/* resume all threads in the list */\n\twhile (rt_list_isempty(susp_list) == 0) {\n\t\t/* get the thread from the list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, suspended_list);\n\n\t\t/* resume the thread */\n\t\tresult = rt_thread_resume(thread, thread_error);\n\t\tif (result!= RT_EOK) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 43.596588147035185}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\trt_thread_t thread;\n\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check parameter */\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\t/* resume all threads in the list */\n\tlevel = rt_hw_interrupt_disable();\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, suspended);\n\t\trt_list_remove(&(thread->suspended));\n\t\trt_hw_interrupt_enable(level);\n\n\t\t/* resume thread */\n\t\tresult = rt_thread_resume(thread, thread_error);\n\n\t\t/* disable interrupt */\n\t\tlevel = rt_hw_interrupt_disable();\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 41.292759741801646}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\trt_err_t result = RT_EOK;\n\trt_thread_t thread;\n\trt_base_t level;\n\n\t/* check parameter */\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\t/* resume all threads in the suspension list */\n\tlevel = rt_hw_interrupt_disable();\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\t/* get thread from suspension list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n\t\t/* resume thread */\n\t\tresult = rt_thread_resume(thread, thread_error);\n\t\tif (result!= RT_EOK) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 36.723137049442265}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t old_console = RT_NULL;\n\trt_device_t new_console = RT_NULL;\n\n\told_console = rt_console_get_device();\n\n\tif (old_console!= RT_NULL) {\n\t\tif (rt_device_find(name) == RT_NULL) {\n\t\t\trt_device_close(old_console);\n\t\t\told_console = RT_NULL;\n\t\t}\n\t}\n\n\tif (old_console == RT_NULL) {\n\t\tnew_console = rt_device_find(name);\n\t\tif (new_console!= RT_NULL) {\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\trt_console_set_device(new_console);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old_console;\n}\n", "CodeBleu_score": 54.53377321721706}, {"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t device, old_device;\n\n\t/* save current console device */\n\told_device = rt_console_get_device();\n\n\t/* find new console device */\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\t/* check if new console device is different and valid */\n\tif (device == old_device) {\n\t\treturn old_device;\n\t}\n\n\t/* close old console device */\n\tif (old_device!= RT_NULL) {\n\t\trt_device_close(old_device);\n\t}\n\n\t/* open new console device */\n\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)) {\n\t\treturn old_device;\n\t}\n\n\t/* set new console device */\n\treturn rt_console_set_device(device);\n}\n", "CodeBleu_score": 47.2155659685937}, {"code": "rt_device_t rt_console_set_device(const char *name)\trt_device_t console;\n\trt_device_t old_console;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* disable interrupt */\n\trt_enter_critical();\n\n\t/* save the old console device */\n\told_console = rt_console_get_device();\n\n\t/* find the new console device */\n\tconsole = rt_device_find(name);\n\tif (console == RT_NULL) {\n\t\t/* enable interrupt */\n\t\trt_exit_critical();\n\n\t\treturn old_console;\n\t}\n\n\t/* check if the new console device is the same as the old console device */\n\tif (console == old_console) {\n\t\t/* enable interrupt */\n\t\trt_exit_critical();\n\n\t\treturn old_console;\n\t}\n\n\t/* close the old console device */\n\tif (old_console!= RT_NULL) {\n\t\trt_device_close(old_console);\n\t}\n\n\t/* open the new console device */\n\tif (rt_device_open(console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)) {\n\t\t/* enable interrupt */\n\t\trt_exit_critical();\n\n\t\treturn old_console;\n\t}\n\n\t/* set the new console device */\n\trt_console_set_device(console);\n\n\t/* enable interrupt */\n\trt_exit_critical();\n\n\treturn old_console;\n}\n", "CodeBleu_score": 49.86132801331333}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type)\trt_uint32_t i;\n\trt_object_information_t *information;\n\trt_object_information_t *information_table;\n\trt_object_information_t *information_table_end;\n\trt_uint32_t object_count = 0;\n\trt_uint8_t object_table_lock;\n\n\t/* Get the object information table */\n\tinformation_table = rt_object_get_information_table(type);\n\tinformation_table_end = information_table + sizeof(information_table) / sizeof(information_table[0]);\n\n\t/* Lock the object table */\n\tobject_table_lock = rt_enter_critical();\n\n\t/* Iterate through the object table */\n\tfor (information = information_table; information < information_table_end; information++) {\n\t\t/* Check if the object is in use */\n\t\tif (information->object_list!= RT_NULL) {\n\t\t\t/* Increment the object count */\n\t\t\tobject_count += information->object_list->count;\n\t\t}\n\t}\n\n\t/* Unlock the object table */\n\trt_exit_critical(object_table_lock);\n\n\t/* Return the object count */\n\treturn object_count;\n}\n", "CodeBleu_score": 30.305005432269304}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tint count = 0;\n\tstruct rt_object_information *information;\n\tstruct rt_object_information *information_next;\n\n\trt_enter_critical();\n\n\t/* Get the object information */\n\tinformation = rt_object_get_information(type);\n\n\tif (information == RT_NULL) {\n\t\trt_exit_critical();\n\t\treturn 0;\n\t}\n\n\t/* Get the number of objects */\n\tcount = information->number;\n\n\t/* Get the next object information */\n\tinformation_next = information->next;\n\n\t/* Release the object information */\n\trt_object_information_release(information);\n\n\t/* Get the next object information */\n\twhile (information_next!= RT_NULL) {\n\t\t/* Get the number of objects */\n\t\tcount += information_next->number;\n\n\t\t/* Get the next object information */\n\t\tinformation_next = information_next->next;\n\t}\n\n\trt_exit_critical();\n\n\treturn count;\n}\n", "CodeBleu_score": 46.95680514167101}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tint count = 0;\n\trt_object_information_t *information;\n\trt_object_information_t *information_end;\n\trt_list_t *list;\n\trt_list_t *list_end;\n\trt_list_t *list_temp;\n\trt_list_t *list_temp_end;\n\trt_list_t *list_temp_temp;\n\trt_list_t *list_temp_temp_end;\n\trt_list_t *list_temp_temp_temp;\n\trt_list_t *list_temp_temp_temp_end;\n\trt_list_t *list_temp_temp_temp_temp;\n\trt_list_t *list_temp_temp_temp_temp_end;\n\trt_list_t *list_temp_temp_temp_temp_temp;\n\trt_list_t *list_temp_temp_temp_temp_temp_end;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_end;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_temp;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_temp_end;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_temp_temp;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_temp_temp_end;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_temp_temp_temp_end;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\trt_list_t *list_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_end;\n\trt_list_t *list_temp_temp_temp_temp", "CodeBleu_score": 7.722067105276811}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object)\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\tif (object->type!= RT_Object_Class_Unknown) {\n\t\trt_object_deinit(object);\n\n\t\trt_object_detach_hook(object);\n\n\t\trt_list_remove(&object->parent.list);\n\t\trt_spin_lock(&object->parent.lock);\n\t\tobject->type = RT_Object_Class_Unknown;\n\t\trt_spin_unlock(&object->parent.lock);\n\t}\n}\n", "CodeBleu_score": 33.0321375270079}, {"code": "void rt_object_detach(rt_object_t object)\tRT_ASSERT(object!= RT_NULL);\n\n\t/* detach object */\n\tobject->type = RT_Object_Class_Unknown;\n\trt_list_remove(&(object->list));\n\trt_spin_unlock(&(object->lock));\n}\n", "CodeBleu_score": 18.829663275676612}, {"code": "void rt_object_detach(rt_object_t object)\trt_object_information_t info;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_DEBUG_LOG(RT_DEBUG_OBJECT, (\"detach object: %s\", object->name));\n\n\tRT_DEBUG_ASSERT(object!= RT_NULL);\n\n\tinfo = object->information;\n\n\tRT_DEBUG_ASSERT(info!= RT_NULL);\n\n\t/* call hook function */\n\tif (info->deinit!= RT_NULL) {\n\t\tinfo->deinit(object);\n\t}\n\n\t/* remove object from list */\n\trt_list_remove(&info->object_list, &object->list);\n\n\t/* unlock object */\n\trt_hw_spin_unlock(info->lock);\n\n\t/* set object type to RT_Object_Class_Unknown */\n\tobject->type = RT_Object_Class_Unknown;\n}\n", "CodeBleu_score": 44.17237506043775}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_err_t result;\n\trt_custom_object_t custom_object;\n\n\t/* check if the object is valid */\n\tif (rt_object_get_type(obj)!= RT_Object_Class_Custom) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check if the object is a custom object */\n\tcustom_object = (rt_custom_object_t)obj;\n\tif (custom_object->parent.type!= RT_Object_Class_Custom) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check if the object has a destroy function */\n\tif (custom_object->parent.object_destroy!= RT_NULL) {\n\t\t/* call the destroy function */\n\t\tresult = custom_object->parent.object_destroy(obj);\n\t\tif (result!= RT_EOK) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/* delete the object */\n\trt_free(custom_object);\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 40.52963887336672}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n\trt_custom_object_t custom_object = (rt_custom_object_t)obj;\n\trt_err_t result = RT_EOK;\n\n\tif (custom_object->parent.parent.destroy!= RT_NULL) {\n\t\tresult = custom_object->parent.parent.destroy(custom_object);\n\t}\n\n\trt_object_delete(obj);\n\n\treturn result;\n}\n", "CodeBleu_score": 30.80423193955102}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_custom_object_t custom_object;\n\trt_err_t result;\n\n\tRT_ASSERT(obj!= RT_NULL);\n\n\tcustom_object = (rt_custom_object_t)obj;\n\tRT_ASSERT(custom_object->type == RT_Object_Class_Custom);\n\n\t/* check if the object has a destroy function */\n\tif (custom_object->parent.parent.destroy!= RT_NULL) {\n\t\t/* call the object's destroy function */\n\t\tresult = custom_object->parent.parent.destroy(obj);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\t/* delete the object */\n\trt_object_delete(obj);\n\n\treturn result;\n}\n", "CodeBleu_score": 43.69725072625807}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void)\tstruct thread *thread = _current_thread();\n\tif (thread) {\n\t\t_enter_critical_section();\n\t\t_close_thread(thread);\n\t\t_add_defunct_thread(thread);\n\t\t_exit_critical_section();\n\t\t_scheduler();\n\t}\n}\n", "CodeBleu_score": 51.865224726932915}, {"code": "static void _thread_exit(void)\tstruct thread_struct *t = current;\n\n\tt->state = THREAD_STATE_DEFUNCT;\n\n\t_critical_enter();\n\tlist_add_tail(&t->node, &defunct_threads);\n\t_critical_exit();\n\n\t_scheduler_trigger();\n}\n", "CodeBleu_score": 40.36291545736958}, {"code": "static void _thread_exit(void)\tstruct thread *thread;\n\tunsigned int old;\n\n\t/* Get the current thread */\n\tthread = _current_thread();\n\n\t/* Enter critical section */\n\told = _interrupt_disable();\n\n\t/* Close the thread */\n\tthread->state = THREAD_STATE_DEFUNCT;\n\tthread->next = NULL;\n\n\t/* Exit critical section */\n\t_interrupt_enable(old);\n\n\t/* Trigger a context switch */\n\t_scheduler();\n}\n", "CodeBleu_score": 52.55281938465619}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter)\tif (parameter == NULL) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 1) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 2) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 3) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 4) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 5) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 6) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 7) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 8) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 9) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 10) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 11) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 12) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 13) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 14) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 15) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 16) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 17) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 18) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 19) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 20) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 21) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 22) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 23) {\n\t\treturn;\n\t}\n\n\tif (parameter == (void *) 24) {\n\t\treturn;\n\t}\n\n\t", "CodeBleu_score": 26.070405166212495}, {"code": "static void _thread_timeout(void *parameter)\t_thread_t *thread = (_thread_t *)parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\tif (thread->state!= THREAD_STATE_SUSPENDED) {\n\t\treturn;\n\t}\n\tif (thread->priority > SCHED_PRIO_MAX) {\n\t\treturn;\n\t}\n\tif (thread->priority < SCHED_PRIO_MIN) {\n\t\treturn;\n\t}\n\tif (thread->stack_size > SCHED_STACK_SIZE_MAX) {\n\t\treturn;\n\t}\n\tif (thread->stack_size < SCHED_STACK_SIZE_MIN) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer == NULL) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer < thread->stack) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer > (thread->stack + thread->stack_size)) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer > (thread->stack + thread->stack_size - sizeof(_thread_stack_t))) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer < thread->stack) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer > (thread->stack + thread->stack_size)) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer > (thread->stack + thread->stack_size - sizeof(_thread_stack_t))) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer < thread->stack) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer > (thread->stack + thread->stack_size)) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer > (thread->stack + thread->stack_size - sizeof(_thread_stack_t))) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer < thread->stack) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer > (thread->stack + thread->stack_size)) {\n\t\treturn;\n\t}\n\tif (thread->stack_pointer > (thread->stack + thread", "CodeBleu_score": 31.226854151387535}, {"code": "static void _thread_timeout(void *parameter)\tstruct thread *thread = (struct thread *) parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tif (thread->state!= THREAD_STATE_SUSPENDED) {\n\t\treturn;\n\t}\n\n\tthread->error = THREAD_ERROR_TIMEOUT;\n\tthread_list_lock();\n\tthread_list_remove(thread);\n\tthread_list_insert(thread);\n\tthread_list_unlock();\n}\n", "CodeBleu_score": 35.375094645889696}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_base_t level;\n\trt_mutex_t mutex;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (thread->current_mutex!= RT_NULL) {\n\t\tmutex = thread->current_mutex;\n\t\tif (mutex->owner == thread) {\n\t\t\tmutex->owner = RT_NULL;\n\t\t\tif (mutex->object_type == RT_Object_Class_Semaphore) {\n\t\t\t\trt_sem_release(mutex);\n\t\t\t} else {\n\t\t\t\trt_mutex_release(mutex);\n\t\t\t}\n\t\t} else {\n\t\t\trt_list_remove(&(thread->thread_entry));\n\t\t}\n\t\tthread->current_mutex = RT_NULL;\n\t}\n\trt_hw_interrupt_enable(level);\n}\n", "CodeBleu_score": 38.19399211468946}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_base_t level;\n\trt_thread_mutex_t *mutex;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (thread->object_type == RT_Object_Class_Mutex) {\n\t\tmutex = (rt_thread_mutex_t *)thread;\n\t\tif (mutex->owner == thread) {\n\t\t\tmutex->owner = RT_NULL;\n\t\t}\n\t}\n\telse if (thread->object_type == RT_Object_Class_Event) {\n\t\trt_thread_event_t *event = (rt_thread_event_t *)thread;\n\t\trt_thread_t thread_from_event;\n\n\t\tif (event->set_event_info.event_type == RT_Event_Class_Thread) {\n\t\t\tthread_from_event = event->set_event_info.value.t;\n\t\t\tif (thread_from_event == thread) {\n\t\t\t\tevent->set_event_info.event_type = RT_Event_Class_None;\n\t\t\t}\n\t\t}\n\t}\n\telse if (thread->object_type == RT_Object_Class_MailBox) {\n\t\trt_thread_mbox_t *mbox = (rt_thread_mbox_t *)thread;\n\t\tif (mbox->owner == thread) {\n\t\t\tmbox->owner = RT_NULL;\n\t\t}\n\t}\n\telse if (thread->object_type == RT_Object_Class_MessageQueue) {\n\t\trt_thread_msg_t *msg = (rt_thread_msg_t *)thread;\n\t\tif (msg->send_list.next!= RT_NULL) {\n\t\t\trt_list_del(&(msg->send_list));\n\t\t}\n\t}\n\telse if (thread->object_type == RT_Object_Class_Semaphore) {\n\t\trt_thread_sem_t *sem = (rt_thread_sem_t *)thread;\n\t\tif (sem->owner == thread) {\n\t\t\tsem->owner = RT_NULL;\n\t\t}\n\t}\n\telse if (thread->object_type == RT_Object_Class_Timer) {\n\t\trt_timer_t *timer = (rt_timer_t *)thread;\n\t\tif (timer->parent.owner == thread) {", "CodeBleu_score": 38.348219080708745}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_base_t level;\n\trt_thread_mutex_t *mutex;\n\trt_thread_t owner;\n\trt_thread_t *wait_list;\n\trt_size_t wait_list_size;\n\trt_size_t i;\n\tlevel = rt_hw_interrupt_disable();\n\tmutex = thread->mutex_pending;\n\towner = thread->owner_thread;\n\twait_list = thread->wait_list;\n\twait_list_size = thread->wait_list_size;\n\tthread->mutex_pending = RT_NULL;\n\tthread->owner_thread = RT_NULL;\n\tthread->wait_list = RT_NULL;\n\tthread->wait_list_size = 0;\n\trt_hw_interrupt_enable(level);\n\tif (mutex!= RT_NULL) {\n\t\tfor (i = 0; i < wait_list_size; i++) {\n\t\t\tif (wait_list[i] == owner) {\n\t\t\t\twait_list[i] = RT_NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trt_mutex_release(mutex);\n\t}\n\tif (owner!= RT_NULL) {\n\t\trt_thread_resume(owner);\n\t}\n}\n", "CodeBleu_score": 37.52051404338811}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tif (thread == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (thread->stat!= RT_THREAD_INIT) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (thread->type!= RT_ThreadType_Main) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* set thread's name */\n\trt_thread_set_name(thread, thread->name);\n\n\t/* set thread's priority */\n\trt_thread_set_priority(thread, thread->init_priority);\n\n\t/* reset thread's state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger a scheduler */\n\trt_schedule();\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 44.00221351111837}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread startup: %s\\n\", thread->name));\n\n\tRT_DEBUG_ASSERT(thread!= RT_NULL);\n\tRT_DEBUG_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_DEBUG_ASSERT(thread->type == RT_ThreadType);\n\n\t/* set the thread's priority */\n\tif (rt_thread_set_priority(thread, thread->init_priority)!= RT_EOK) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* reset the thread's stack */\n\trt_hw_stack_init(thread->stack_addr, thread->stack_size, thread->entry, thread->parameter);\n\n\t/* reset the thread's error number */\n\tthread->error = RT_EOK;\n\n\t/* reset thread's statistic */\n\trt_thread_reset_statistic(thread);\n\n\t/* reset thread's stack_size and stack_addr */\n\tthread->stack_size = 0;\n\tthread->stack_addr = RT_NULL;\n\n\t/* set thread's stat as RT_THREAD_READY */\n\tlevel = rt_hw_interrupt_disable();\n\tthread->stat = RT_THREAD_READY;\n\trt_hw_interrupt_enable(level);\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* check whether there is a thread waiting for initialization */\n\tif (rt_thread_self() == RT_NULL && rt_thread_find_waiting_init()!= RT_NULL) {\n\t\t/* there is a thread waiting for initialization */\n\t\trt_schedule();\n\t}\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 44.74334334193587}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\trt_base_t level;\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tRT_DEBUG_LOG(RT_DEBUG_THREAD, (\"start thread:%s, stack:0x%08x, entry:0x%08x, parameter:0x%08x, stack_size:%d, priority:%d\\n\", thread->name, thread->stack_addr, thread->entry, thread->parameter, thread->stack_size, thread->current_priority));\n\t/* check parameter */\n\tRT_DEBUG_NULL_POINTER(thread);\n\tif (thread->stat!= RT_THREAD_INIT) {\n\t\tRT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread %s is not in init state\\n\", thread->name));\n\t\treturn -RT_ERROR;\n\t}\n\tif (thread->type!= RT_ThreadType_Normal) {\n\t\tRT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread %s is not a normal thread\\n\", thread->name));\n\t\treturn -RT_ERROR;\n\t}\n\t/* log thread's name and priority */\n\trt_enter_critical();\n\tthread->init_priority = thread->current_priority;\n\tthread->remaining_tick = thread->init_tick;\n\tthread->stat = RT_THREAD_READY;\n\trt_exit_critical();\n\t/* calculate thread's priority attributes */\n\tlevel = rt_hw_interrupt_disable();\n\trt_list_insert_after(&rt_thread_priority_table[thread->current_priority], &(thread->list));\n\trt_hw_interrupt_enable(level);\n\t/* reset thread's stack */\n\trt_memset(thread->stack_addr, 0x00, thread->stack_size);\n\tthread->stack_point = thread->stack_addr + thread->stack_size;\n\t/* reset thread's error code */\n\tthread->error = RT_EOK;\n\t/* resume thread */\n\trt_schedule();\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 39.20420566757365}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\trt_list_t *timer_list_head;\n\trt_list_t *timer_list_node;\n\trt_timer_t timer;\n\trt_tick_t tick;\n\trt_uint8_t level;\n\n\ttimer_list_head = &timer_list[0];\n\ttimer_list_node = timer_list_head->next;\n\n\t/* Check if the highest level of the timer skip list is not empty. */\n\tfor (level = RT_TIMER_SKIP_LIST_LEVELS - 1; level > 0; level--) {\n\t\tif (timer_list_head->next!= &timer_list[level]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (level == 0) {\n\t\t/* The highest level of the timer skip list is empty. */\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\ttimer = rt_list_entry(timer_list_node, struct rt_timer, list);\n\ttick = timer->timeout_tick;\n\n\tif (tick < *timeout_tick) {\n\t\t*timeout_tick = tick;\n\t}\n\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 35.25063450079501}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\trt_list_t *list;\n\trt_timer_t timer;\n\trt_uint8_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tif (rt_list_isempty(&timer_list[0])) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\tlist = &timer_list[0];\n\tlevel = 0;\n\n\twhile (1) {\n\t\tif (!rt_list_isempty(list)) {\n\t\t\ttimer = rt_list_entry(list->next, struct rt_timer, list);\n\t\t\tif (timer->list.next!= &timer_list[level]) {\n\t\t\t\t*timeout_tick = timer->timeout_tick;\n\t\t\t\treturn RT_EOK;\n\t\t\t}\n\n\t\t\tlist = timer->list.next;\n\t\t} else {\n\t\t\tlevel ++;\n\t\t\tif (level >= RT_TIMER_SKIPLIST_LEVELS) {\n\t\t\t\treturn -RT_ETIMEOUT;\n\t\t\t}\n\n\t\t\tlist = &timer_list[level];\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.464689078537745}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\trt_err_t result = RT_EOK;\n\trt_list_t *list_head = &timer_list[0];\n\trt_list_t *list_node;\n\trt_list_t *list_next;\n\trt_list_t *list_prev;\n\trt_uint32_t level;\n\trt_timer_t *timer;\n\n\t/* Get the highest level of the timer skip list. */\n\tlevel = _timer_list_get_level(list_head);\n\n\t/* Check if the highest level of the timer skip list is empty. */\n\tif (level == 0) {\n\t\tresult = -RT_ETIMEOUT;\n\t} else {\n\t\t/* Get the first timer entry of the highest level. */\n\t\tlist_node = list_head->next;\n\n\t\t/* Get the next timer entry. */\n\t\tlist_next = list_node->next;\n\n\t\t/* Get the previous timer entry. */\n\t\tlist_prev = list_node->prev;\n\n\t\t/* Get the timer object. */\n\t\ttimer = rt_list_entry(list_node, struct rt_timer, list);\n\n\t\t/* Check if the next timer entry is the end of the level. */\n\t\tif (list_next == list_head) {\n\t\t\t/* Set the timeout tick to the timer's timeout value. */\n\t\t\t*timeout_tick = timer->timeout_tick;\n\t\t} else {\n\t\t\t/* Set the timeout tick to the difference between the timer's timeout value and the next timer's timeout value. */\n\t\t\t*timeout_tick = timer->timeout_tick - ((struct rt_timer *)list_next)->timeout_tick;\n\t\t}\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 41.34721032442561}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\trt_timer_t timer;\n\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_DEBUG_LOG(RT_DEBUG_TIMER, (\"timer create\"));\n\n\tif (name == RT_NULL) {\n\t\tname = \"timer\";\n\t}\n\n\tif (timeout == RT_NULL) {\n\t\tRT_DEBUG_LOG(RT_DEBUG_TIMER, (\"timer create failed, timeout function is NULL\"));\n\t\treturn RT_NULL;\n\t}\n\n\tif (time == 0) {\n\t\tRT_DEBUG_LOG(RT_DEBUG_TIMER, (\"timer create failed, time is 0\"));\n\t\treturn RT_NULL;\n\t}\n\n\tif (time > RT_TICK_MAX / 2) {\n\t\tRT_DEBUG_LOG(RT_DEBUG_TIMER, (\"timer create failed, time is too large\"));\n\t\treturn RT_NULL;\n\t}\n\n\ttimer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL) {\n\t\tRT_DEBUG_LOG(RT_DEBUG_TIMER, (\"timer create failed, no memory\"));\n\t\treturn RT_NULL;\n\t}\n\n\tlevel = rt_hw_interrupt_disable();\n\trt_list_insert_after(&rt_timer_list, &timer->parent.list);\n\trt_hw_interrupt_enable(level);\n\n\ttimer->parent.flag = flag;\n\ttimer->timeout_func = timeout;\n\ttimer->parameter    = parameter;\n\ttimer->init_tick    = time;\n\ttimer->remaining_tick = time;\n\n\treturn timer;\n}\n", "CodeBleu_score": 47.281886654130666}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\trt_timer_t timer;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tif (name == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\tif (timeout == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\tif (time > RT_TICK_MAX / 2) {\n\t\treturn RT_NULL;\n\t}\n\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\ttimer->parent.flag = flag;\n\ttimer->timeout_func = timeout;\n\ttimer->parameter    = parameter;\n\ttimer->init_tick    = time;\n\ttimer->parent.type  = RT_Object_Class_Timer;\n\n\trt_timer_init(timer, time);\n\n\treturn timer;\n}\n", "CodeBleu_score": 56.4299079820207}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)#ifdef RT_USING_HEAP\n    rt_timer_t timer;", "CodeBleu_score": 8.995604685701418}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\tif a.Router == nil {\n\t\tpanic(\"API.Router must not be nil\")\n\t}\n\tif a.Middleware == nil {\n\t\tpanic(\"API.Middleware must not be nil\")\n\t}\n\tif a.Handler == nil {\n\t\tpanic(\"API.Handler must not be nil\")\n\t}\n\tif a.NotFoundHandler == nil {\n\t\tpanic(\"API.NotFoundHandler must not be nil\")\n\t}\n\tif a.UnauthorizedHandler == nil {\n\t\tpanic(\"API.UnauthorizedHandler must not be nil\")\n\t}\n\tif a.ErrorEncoder == nil {\n\t\tpanic(\"API.ErrorEncoder must not be nil\")\n\t}\n\n\t// Wrap the response writer so that we can capture its headers\n\trecorder := &httptest.ResponseRecorder{\n\t\tCode:        200,\n\t\tHeaderMap:   http.Header{},\n\t\tBody:        &bytes.Buffer{},\n\t\tFlushed:     true,\n\t\tResult:      nil,\n\t\tSize:        0,\n\t\tBodyAllowed: true,\n\t}\n\trecorder.HeaderMap = res.Header()\n\trecorder.Result = res\n\n\t// Wrap the request so that we can capture the request body\n\trequestBody := &bytes.Buffer{}\n\tif req.Body!= nil {\n\t\tif _, err := io.Copy(requestBody, req.Body); err!= nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treq.Body = ioutil.NopCloser(requestBody)\n\n\t// Wrap the request so that we can capture the request URI\n\trequestURI := req.RequestURI\n\treq.RequestURI = \"\"\n\n\t// Create a context with the request and response\n\tctx := context.Background()\n\tctx = context.WithValue(ctx, \"request\", req)\n\tctx = context.WithValue(ctx, \"response\", recorder)\n\n\t// Run the middleware\n\tif err := a.Middleware(ctx, req, recorder); err!= nil {\n\t\tif err == ErrUnauthorized {\n\t\t\ta.UnauthorizedHandler(ctx, req, recorder)\n\t\t} else {\n\t\t\ta.ErrorEncoder(ctx, req, recorder, err)\n\t\t}\n\t\treturn\n\t}\n\n\t// Run the router\n\tif err := a.Router(ctx, req, recorder); err!=", "CodeBleu_score": 29.944034542695864}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Create a new recorder for the response.\n\trec := httptest.NewRecorder()\n\n\t// Call the router, passing the recorder as the response writer.\n\ta.Router.ServeHTTP(rec, req)\n\n\t// Copy the headers from the recorder to the original response.\n\tfor k, v := range rec.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Write the recorder's status code and body to the original response.\n\tres.WriteHeader(rec.Code)\n\t_, _ = res.Write(rec.Body.Bytes())\n}\n", "CodeBleu_score": 41.1287545344959}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\ta.router.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 4.471227356666232}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// Get the path of the requested asset.\n\tpath := req.URL.Path[len(\"/robeaux/\"):]\n\t// Check if the path is empty.\n\tif path == \"\" {\n\t\t// If the path is empty, return a 404 error.\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Split the path into a file name and an extension.\n\tfile, ext := path[:len(path)-len(filepath.Ext(path))], path[len(path)-len(filepath.Ext(path)):]\n\t// Check if the file name is empty.\n\tif file == \"\" {\n\t\t// If the file name is empty, return a 404 error.\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Check if the file name is a directory.\n\tif file[len(file)-1] == '/' {\n\t\t// If the file name is a directory, return a 404 error.\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Check if the file name is a directory.\n\tif file[len(file)-1] == '/' {\n\t\t// If the file name is a directory, return a 404 error.\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Check if the file name is a directory.\n\tif file[len(file)-1] == '/' {\n\t\t// If the file name is a directory, return a 404 error.\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Check if the file name is a directory.\n\tif file[len(file)-1] == '/' {\n\t\t// If the file name is a directory, return a 404 error.\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Check if the file name is a directory.\n\tif file[len(file)-1] == '/' {\n\t\t// If the file name is a directory, return a 404 error.\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Check if the file name is a directory.\n\tif file[len(file)-1] == '/' {\n\t\t", "CodeBleu_score": 41.40558675659846}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tvar err error\n\tvar contentType string\n\tvar content []byte\n\tvar assetName string\n\n\tassetName = strings.TrimPrefix(req.URL.Path, \"/robeaux/\")\n\n\tif assetName == \"\" {\n\t\terr = errors.New(\"asset name is empty\")\n\t\ta.respondErr(res, req, http.StatusNotFound, err)\n\t\treturn\n\t}\n\n\tif strings.HasSuffix(assetName, \".js\") {\n\t\tcontentType = \"application/javascript\"\n\t} else if strings.HasSuffix(assetName, \".css\") {\n\t\tcontentType = \"text/css\"\n\t} else if strings.HasSuffix(assetName, \".html\") {\n\t\tcontentType = \"text/html\"\n\t} else {\n\t\terr = errors.New(\"unknown asset type\")\n\t\ta.respondErr(res, req, http.StatusNotFound, err)\n\t\treturn\n\t}\n\n\tcontent, err = a.asset(assetName)\n\tif err!= nil {\n\t\ta.respondErr(res, req, http.StatusNotFound, err)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Write(content)\n}\n", "CodeBleu_score": 32.862125471504086}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\text := path[strings.LastIndex(path, \".\"):]\n\tif ext == \".html\" {\n\t\text = \".css\"\n\t}\n\tcontent, err := a.assets.Asset(path)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\tif ext == \".css\" {\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t}\n\tif ext == \".js\" {\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t}\n\tres.Write(content)\n}\n", "CodeBleu_score": 40.88560888161737}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the request URL.\n\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Get the robot from the master instance.\n\trobot := a.master.GetRobot(name)\n\n\t// If the robot was found, create a JSON response containing the robot's connections.\n\tif robot!= nil {\n\t\tconnections := make([]Connection, len(robot.connections))\n\t\ti := 0\n\t\tfor connection := range robot.connections {\n\t\t\tconnections[i] = Connection{\n\t\t\t\tName: connection.name,\n\t\t\t\tType: connection.type,\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\t// Write the response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(json.Marshal(connections))\n\t\treturn\n\t}\n\n\t// Otherwise, write an error response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusNotFound)\n\tres.Write(json.Marshal(ErrorMessage{\n\t\tError: \"No robot found with the specified name.\",\n\t}))\n}\n", "CodeBleu_score": 41.5324483656217}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Find the robot\n\trobot, err := a.master.GetRobot(name)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the specified name\"})\n\t\treturn\n\t}\n\n\t// Gather the robot's connections\n\tconnections := robot.GetConnections()\n\n\t// Convert the connections to JSON\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// If there was an error converting the connections to JSON, write a JSON error message\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"There was an error converting the connections to JSON\"})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(jsonConnections)\n}\n", "CodeBleu_score": 35.4097144076208}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tname := mux.Vars(req)[\"name\"]\n\trobot := a.master.FindRobot(name)\n\tif robot == nil {\n\t\ta.writeError(res, http.StatusNotFound, fmt.Sprintf(\"no robot with name %s\", name))\n\t\treturn\n\t}\n\tconnections := robot.GetConnections()\n\ta.writeJSON(res, connections)\n}\n", "CodeBleu_score": 24.290620670614906}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if the request contains a \"Authorization\" header.\n\t\t// If it doesn't, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response.\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Extract the username and password from the \"Authorization\" header.\n\t\t// If the username and password don't match, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response.\n\t\t// If the username and password match, return a nil error.\n\t\tusername, password, ok := r.BasicAuth()\n\t\tif!ok || username!= \"admin\" || password!= \"<PASSWORD>\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 54.45062694886855}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\t// If the header is empty, return a \"Not Authorized\" response.\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the header into two parts: \"Basic\" and the base64-encoded username and password.\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\t// If the header is not formatted correctly, return a \"Not Authorized\" response.\n\t\tif!(len(parts) == 2 && parts[0] == \"Basic\") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Decode the base64-encoded username and password.\n\t\tb, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the decoded string into two parts: the username and password.\n\t\tparts = strings.SplitN(string(b), \":\", 2)\n\t\t// If the decoded string is not formatted correctly, return a \"Not Authorized\" response.\n\t\tif!(len(parts) == 2 && parts[0] == username && parts[1] == password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the username and password match, call the next handler.\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 48.03976444454654}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\t// If the header is empty, return a \"Not Authorized\" response.\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the header by a space.\n\t\tparts := strings.SplitN(authHeader, \" \", 2)\n\t\t// If the header is not formatted correctly, return a \"Not Authorized\" response.\n\t\tif!(len(parts) == 2 && parts[0] == \"Basic\") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Decode the base64-encoded username and password.\n\t\tdecoded, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the decoded username and password by a colon.\n\t\tcreds := strings.SplitN(string(decoded), \":\", 2)\n\t\t// If the decoded username and password are not formatted correctly, return a \"Not Authorized\" response.\n\t\tif!(len(creds) == 2 && creds[0] == username && creds[1] == password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the comparison succeeds, execute the handler.\n\t\th.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 47.53183025880306}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tif fromMin == fromMax {\n\t\treturn func(input float64) (value int) {\n\t\t\treturn int(toMin)\n\t\t}\n\t}\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn value\n\t}\n}\n", "CodeBleu_score": 61.344611379771806}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) int {\n\t\tvalue := int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn value\n\t}\n}\n", "CodeBleu_score": 63.63462784411858}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Min(math.Max(slope*input+intercept, toMin), toMax))\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 49.204325723502876}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.connected {\n\t\treturn 0, 0, fmt.Errorf(\"Sensor is not connected\")\n\t}\n\tif a.analogRead == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Sensor does not support analog reading\")\n\t}\n\n\traw, err := a.analogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 49.98003504725089}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection not initialized\")\n\t}\n\n\tif!a.connection.SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scaleRaw(raw)\n\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 50.67138183296468}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"Connection not open\")\n\t}\n\n\tif a.connection.AnalogInputPins == nil {\n\t\treturn 0, 0, errors.New(\"Connection does not support analog reading\")\n\t}\n\n\tif a.pin == nil {\n\t\treturn 0, 0, errors.New(\"Pin not set\")\n\t}\n\n\traw, err := a.connection.AnalogInputPins[a.pin].Read()\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 48.248779856318166}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - (m * fromMin)\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}\n", "CodeBleu_score": 39.50905429278115}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}\n", "CodeBleu_score": 39.192902878870065}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}\n", "CodeBleu_score": 39.192902878870065}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDrivername := DefaultName\n\tfor _, opt := range opts {\n\t\tswitch v := opt.(type) {\n\t\tcase string:\n\t\t\tname = v\n\t\t}\n\t}\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:    name,\n\t\tpin:     pin,\n\t\taReader: a,\n\t}\n\td.init()\n\treturn d\n}\n", "CodeBleu_score": 24.16034440336437}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriverd := NewGrovePiezoVibrationSensorDriverWithDefaults(a, pin)\n\tif err := d.SetupEvents(opts...); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}\n", "CodeBleu_score": 20.411822078358437}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriverif a == nil {\n\t\tpanic(\"NewGrovePiezoVibrationSensorDriver: AnalogReader is nil\")\n\t}\n\tname := \"\"\n\tif len(opts) > 0 {\n\t\tname = opts[0].(string)\n\t}\n\tif name == \"\" {\n\t\tname = \"GrovePiezoVibrationSensor\"\n\t}\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: name,\n\t\ta:    a,\n\t\tpin:  pin,\n\t\tdata: make(chan *Data),\n\t}\n\td.AddEventListener(d.handleDataEvent)\n\treturn d\n}\n", "CodeBleu_score": 39.06674162981959}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif hz < 0 {\n\t\treturn errors.New(\"frequency must be greater than 0\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"duration must be greater than 0\")\n\t}\n\tperiod := 1.0 / hz\n\tdelay := period / d.bpm\n\tfor i := 0; i < int(duration*d.bpm); i++ {\n\t\terr := d.On()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay * time.Second)\n\t\terr = d.Off()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay * time.Second)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 42.31072577819383}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif hz < 0 {\n\t\treturn errors.New(\"frequency must be greater than 0\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"duration must be greater than 0\")\n\t}\n\n\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := 60 / d.bpm * 1000 / hz\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < int(duration*1000/tonePeriod); i++ {\n\t\terr := d.Toggle()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 46.3100900243033}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif d.err!= nil {\n\t\treturn d.err\n\t}\n\tif hz <= 0 || duration <= 0 {\n\t\treturn errors.New(\"invalid frequency or duration\")\n\t}\n\tperiod := 1.0 / hz\n\tdelay := period / 2\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(delay * time.Second):\n\t\t\tif err := d.On(); err!= nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttime.Sleep(delay * time.Second)\n\t\t\tif err := d.Off(); err!= nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdelay = period\n\t\tcase <-time.After(duration * time.Second):\n\t\t\treturn nil\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.593759121659076}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn ErrNoSleepPin\n\t}\n\tif d.sleepPin.Get() == 0 {\n\t\treturn ErrSleepPinNotSet\n\t}\n\td.sleepPin.Set(0)\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 34.92965819017354}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\tif err := d.sleepPin.WaitForEdge(time.Second); err!= nil {\n\t\treturn err\n\t}\n\td.sleepPin.Out(gpio.Low)\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 41.84217491885105}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == 0 {\n\t\treturn errors.New(\"Sleep pin not set\")\n\t}\n\n\t// Stop any ongoing operations\n\td.stop()\n\n\t// Set the sleep pin to low\n\td.sleepPin.Low()\n\n\t// Mark the driver as sleeping\n\td.sleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 27.945934666390976}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pin map not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := gobot.NewAnalogSensor(path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 49.12229830471525}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.pinPath(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := gobot.NewAnalogSensor(path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 47.495985873740736}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pin map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpinPath, err := a.analogPinPath(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin, err := gobot.AnalogPin(pinPath, a.i2c.GetBus())\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 48.68956468868068}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}\n", "CodeBleu_score": 59.95976156540217}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}\n", "CodeBleu_score": 58.698050898586686}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}\n", "CodeBleu_score": 59.95976156540217}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if a.digitalPins == nil {\n\t\ta.digitalPins = make(map[string]gobot.DigitalPin)\n\t}\n\n\tif _, ok := a.digitalPins[id];!ok {\n\t\tpin, err := a.connectDigitalPin(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.digitalPins[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(a.digitalPins[id])\n\t}\n\n\treturn a.digitalPins[id], nil\n}\n", "CodeBleu_score": 33.64614667815376}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if a.connect() == nil {\n\t\treturn nil, fmt.Errorf(\"digitalPin: adaptor not connected\")\n\t}\n\n\tif len(id)!= 3 {\n\t\treturn nil, fmt.Errorf(\"digitalPin: invalid pin id: %s\", id)\n\t}\n\n\tif _, ok := a.digitalPins[id];!ok {\n\t\tchip := a.chip(id[0:2])\n\t\tif chip == nil {\n\t\t\treturn nil, fmt.Errorf(\"digitalPin: invalid chip id: %s\", id[0:2])\n\t\t}\n\n\t\tline := chip.line(id[2:])\n\t\tif line == nil {\n\t\t\treturn nil, fmt.Errorf(\"digitalPin: invalid line id: %s\", id[2:])\n\t\t}\n\n\t\tpin := chip.newDigitalPin(line)\n\t\tif pin == nil {\n\t\t\treturn nil, fmt.Errorf(\"digitalPin: failed to create pin: %s\", id)\n\t\t}\n\n\t\tif err := pin.init(); err!= nil {\n\t\t\treturn nil, fmt.Errorf(\"digitalPin: failed to init pin: %s\", err)\n\t\t}\n\n\t\ta.digitalPins[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(a.digitalPins[id])\n\t}\n\n\treturn a.digitalPins[id], nil\n}\n", "CodeBleu_score": 39.23550661254806}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)if a.connect() {\n\t\tpin, err := a.Adaptor.DigitalPin(id, opts...)\n\t\tif err == nil {\n\t\t\ta.pins[id] = pin\n\t\t}\n\t\treturn pin, err\n\t}\n\treturn nil, errors.New(\"digitalPin: Adaptor not connected\")\n}\n", "CodeBleu_score": 21.481268890761974}]}
