{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> requiredFiles;\n    std::vector<std::string> files;\n    std::vector<std::string> folders;\n    std::string path = folder;\n    std::string file;\n    std::stringstream ss;\n    std::stringstream ss2;\n    std::stringstream ss3;\n    std::stringstream ss4;\n    std::stringstream ss5;\n    std::stringstream ss6;\n    std::stringstream ss7;\n    std::stringstream ss8;\n    std::stringstream ss9;\n    std::stringstream ss10;\n    std::stringstream ss11;\n    std::stringstream ss12;\n    std::stringstream ss13;\n    std::stringstream ss14;\n    std::stringstream ss15;\n    std::stringstream ss16;\n    std::stringstream ss17;\n    std::stringstream ss18;\n    std::stringstream ss19;\n    std::stringstream ss20;\n    std::stringstream ss21;\n    std::stringstream ss22;\n    std::stringstream ss23;\n    std::stringstream ss24;\n    std::stringstream ss25;\n    std::stringstream ss26;\n    std::stringstream ss27;\n    std::stringstream ss28;\n    std::stringstream ss29;\n    std::stringstream ss30;\n    std::stringstream ss31;\n    std::stringstream ss32;\n    std::stringstream ss33;\n    std::stringstream ss34;\n    std::stringstream ss35;\n    std::stringstream ss36;\n    std::stringstream ss37;\n    std::stringstream ss38;\n    std::stringstream ss39;\n    std::stringstream ss40;\n    std::stringstream ss41;\n    std::stringstream ss42;\n    std::stringstream ss43;\n    std::stringstream ss44;\n    std::stringstream ss45;\n    std::stringstream ss46;\n    std::stringstream ss47;", "CodeBleu_score": 14.88761100569115}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = GetFiles(folder);\n\tfor (auto file : files) {\n\t\tif (download) {\n\t\t\tif (CheckFileExists(file)) {\n\t\t\t\tstd::cout << \"File \" << file << \" found in cache.\" << std::endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << \"File \" << file << \" not found in cache. Downloading file.\" << std::endl;\n\t\t\t\tDownloadFile(file);\n\t\t\t}\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\treturn requiredFiles;\n}\n", "CodeBleu_score": 47.95803277129098}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> required_files;\n    std::vector<std::string> files = GetFiles(folder);\n    for (auto &file : files) {\n        std::string full_path = folder + file;\n        if (download) {\n            if (CheckFile(full_path)) {\n                Log(full_path + \" found in cache.\");\n            } else {\n                Log(\"Downloading \" + full_path);\n                DownloadFile(full_path);\n            }\n        } else {\n            if (CheckFile(full_path)) {\n                required_files.push_back(full_path);\n            }\n        }\n    }\n    return required_files;\n}\n", "CodeBleu_score": 47.4042276690415}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  // Check if the parent is valid\n  if (parent != 0) {\n    // Check if the parent is valid\n    if (!IsValid(parent)) {\n      throw Exception(\n          \"Client::SpawnActorWithParent - Actor with id \" + parent.ToString() +\n          \" is not valid.\");\n    }\n  }\n\n  // Check if the socket name is valid\n  if (socket_name.empty()) {\n    throw Exception(\n        \"Client::SpawnActorWithParent - Socket name is empty.\");\n  }\n\n  // Check if the attachment type is valid\n  if (attachment_type != rpc::AttachmentType::SpringArm &&\n      attachment_type != rpc::AttachmentType::SpringArmGhost) {\n    throw Exception(\n        \"Client::SpawnActorWithParent - Attachment type is invalid.\");\n  }\n\n  // Check if the attachment type is SpringArm\n  if (attachment_type == rpc::AttachmentType::SpringArm) {\n    // Check if the transformation is valid\n    if (transform.location.z != 0.f) {\n      std::cerr << \"Client::SpawnActorWithParent - Warning: Transformation \"\n                << \"contains a non-zero translation in the 'z' axis. \"\n                << \"This may cause ill-formed transformations when the \"\n                << \"translation is only in the 'z' axis.\" << std::endl;\n    }\n  }\n\n  // Complete the actor spawning process\n  return SpawnActorInternal(description, transform, parent, attachment_type, socket_name);\n}\n", "CodeBleu_score": 46.56881933394252}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  if (parent == rpc::ActorId::kNull) {\n    throw std::runtime_error(\n        \"Tried to spawn an actor with a null parent ID\");\n  }\n\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0 &&\n        transform.location.y == 0.0 &&\n        transform.location.z != 0.0) {\n      LogWarning(\n          \"SpawnActorWithParent: Transform for SpringArm/SpringArmGhost has \"\n          \"only a z component, this may cause undesired behaviour\");\n    }\n  }\n\n  auto parent_actor = GetActor(parent);\n  if (parent_actor == nullptr) {\n    throw std::runtime_error(\n        \"Tried to spawn an actor with a parent ID that doesn't exist\");\n  }\n\n  auto description_ptr = std::make_shared<rpc::ActorDescription>(description);\n  auto transform_ptr = std::make_shared<geom::Transform>(transform);\n  auto parent_ptr = std::make_shared<rpc::ActorId>(parent);\n  auto attachment_type_ptr = std::make_shared<rpc::AttachmentType>(attachment_type);\n  auto socket_name_ptr = std::make_shared<std::string>(socket_name);\n\n  auto response = client->call(\n      \"spawn_actor_with_parent\",\n      description_ptr,\n      transform_ptr,\n      parent_ptr,\n      attachment_type_ptr,\n      socket_name_ptr);\n\n  return response.get<rpc::Actor>();\n}\n", "CodeBleu_score": 50.89273351754987}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  auto response = client_->call(\"spawn_actor_with_parent\",\n                                description,\n                                transform,\n                                parent,\n                                attachment_type,\n                                socket_name);\n  return response.get<rpc::Actor>();\n}\n", "CodeBleu_score": 31.291115555192807}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\n  // Get the token for the G-buffer.\n  std::string token;\n  std::string error;\n  rpc::TokenRequest req;\n  req.set_actorid(ActorId);\n  req.set_gbufferid(GBufferId);\n  rpc::TokenResponse res;\n  ClientContext context;\n  Status status = stub_->GetToken(&context, req, &res);\n  if (status.ok()) {\n    token = res.token();\n  } else {\n    std::cout << \"Error: \" << status.error_code() << \": \" << status.error_message() << std::endl;\n    return;\n  }\n\n  // Copy the token data.\n  std::string token_data = token.substr(0, 4);\n  std::string token_length = token.substr(4, 4);\n  uint32_t token_length_int = std::stoi(token_length, nullptr, 16);\n  token_data += token.substr(8, token_length_int * 2);\n\n  // Subscribe to the streaming client using the callback function.\n  std::string gbuffer_name = \"gbuffer_\" + std::to_string(GBufferId);\n  Subscribe(gbuffer_name, token_data, callback);\n}\n", "CodeBleu_score": 43.27231935636272}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)  auto token_data = GetTokenData(ActorId, GBufferId);\n  if (token_data.empty()) {\n    return;\n  }\n  auto token = std::make_shared<std::string>(token_data);\n  auto callback_wrapper = [this, callback](Buffer buffer) {\n    if (callback) {\n      callback(buffer);\n    }\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (--num_subscriptions_ == 0) {\n      if (client_->IsConnected()) {\n        client_->Disconnect();\n      }\n    }\n  };\n  client_->SubscribeToStream(token, callback_wrapper);\n}\n", "CodeBleu_score": 42.73658223544934}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\n    // Get the token for the G-buffer\n    rpc::Token token;\n    token.set_actorid(ActorId);\n    token.set_gbufferid(GBufferId);\n    token.set_type(rpc::Token::GBUFFER);\n    token.set_timestamp(0);\n    token.set_seq(0);\n\n    // Copy the token data to a string\n    std::string token_data;\n    token.SerializeToString(&token_data);\n\n    // Subscribe to the streaming client using the provided callback function\n    Subscribe(token_data, callback);\n}\n", "CodeBleu_score": 41.382347804835874}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(this);\n\t\tnavigation->SetEpisode(this);\n\t\tnavigation->SetWalker(walker);\n\t\tnavigation->SetWalkerNavigation(navigation);\n\t\tnavigation->SetWalkerNavigation(navigation);\n\t}\n\treturn navigation;\n}\n", "CodeBleu_score": 39.98742634003186}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>(this);\n        SetNavigation(navigation);\n    }\n    return navigation;\n}\n", "CodeBleu_score": 31.856893945973646}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>(*this);\n        navigation->SetNavigation(navigation);\n        navigation->SetWalker(this);\n        navigation->SetWalkerNavigation(navigation);\n    }\n    return navigation;\n}\n", "CodeBleu_score": 42.55150787403812}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  auto start = std::chrono::system_clock::now();\n  while (episode.GetFrameCount() < frame) {\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start) > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n\n  episode.GetTrafficManager().Tick();\n  return true;\n}\n", "CodeBleu_score": 47.251876766652366}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  const auto start = std::chrono::system_clock::now();\n  while (episode.GetFrameCount() < frame) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    if (std::chrono::system_clock::now() - start > timeout) {\n      return false;\n    }\n  }\n  episode.GetTrafficManager().Tick();\n  return true;\n}\n", "CodeBleu_score": 42.22726450276291}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  const auto start_time = std::chrono::system_clock::now();\n  const auto end_time = start_time + timeout;\n  while (episode.GetFrameCount() < frame) {\n    if (std::chrono::system_clock::now() > end_time) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetActorManager().Tick();\n  return true;\n}\n", "CodeBleu_score": 43.09308964573677}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  rpc::MapLayer layer = map_layers;\n  rpc::MapLayerSet map_layer_set;\n  map_layer_set.set_val(layer);\n  rpc::EpisodeSettings episode_settings;\n  episode_settings.set_synchronous_mode(reset_settings);\n  rpc::EpisodeId episode_id;\n  rpc::MapName map_name_msg;\n  map_name_msg.set_val(map_name);\n  rpc::EpisodeSettings episode_settings_msg;\n  episode_settings_msg.CopyFrom(episode_settings);\n  rpc::MapName map_name_msg_2;\n  map_name_msg_2.set_val(map_name);\n  rpc::MapLayerSet map_layer_set_msg;\n  map_layer_set_msg.CopyFrom(map_layer_set);\n  rpc::EpisodeSettings episode_settings_msg_2;\n  episode_settings_msg_2.CopyFrom(episode_settings_msg);\n  rpc::MapName map_name_msg_3;\n  map_name_msg_3.set_val(map_name);\n  rpc::MapLayerSet map_layer_set_msg_2;\n  map_layer_set_msg_2.CopyFrom(map_layer_set_msg);\n  rpc::EpisodeSettings episode_settings_msg_3;\n  episode_settings_msg_3.CopyFrom(episode_settings_msg_2);\n  rpc::EpisodeSettings episode_settings_msg_4;\n  episode_settings_msg_4.CopyFrom(episode_settings_msg_3);\n  rpc::MapName map_name_msg_4;\n  map_name_msg_4.set_val(map_name);\n  rpc::MapLayerSet map_layer_set_msg_3;\n  map_layer_set_msg_3.CopyFrom(map_layer_set_msg_2);\n  rpc::EpisodeSettings episode_settings_msg_5;\n  episode_settings_msg_5.CopyFrom(episode_settings_msg_4", "CodeBleu_score": 31.48470941577931}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  // The episode ID is the key to the map of episodes.\n  // The map of episodes is used to keep track of all the episodes that are currently loaded.\n  std::string episode_id = \"\";\n  // The episode object is the object that is returned to the user.\n  EpisodeProxy episode_proxy;\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  std::string episode_id_str = \"\";\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  std::string episode_id_str_new = \"\";\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  std::string episode_id_str_old = \"\";\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  int episode_id_int = 0;\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  int episode_id_int_new = 0;\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  int episode_id_int_old = 0;\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  std::string episode_id_str_new_old = \"\";\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  std::string episode_id_str_old_new = \"\";\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that is returned to the user.\n  std::string episode_id_str_new_new = \"\";\n  // The episode object is the object that is returned to the user.\n  // The episode object is the object that", "CodeBleu_score": 9.434025694686968}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  // TODO: Check if the episode is already loaded\n  // TODO: Check if the map name is valid\n\n  // Send the request\n  auto request = rpc::LoadEpisode(map_name, reset_settings, map_layers);\n  auto response = client.call(request);\n\n  // Check for errors\n  if (response.has_error()) {\n    throw std::runtime_error(response.error().message());\n  }\n\n  // Check if the episode is loaded\n  if (response.has_episode()) {\n    // TODO: Check if the episode is already loaded\n    return EpisodeProxy(response.episode());\n  }\n\n  // TODO: Check if the episode is loaded\n  throw std::runtime_error(\"Failed to load episode\");\n}\n", "CodeBleu_score": 35.86554254312042}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)    // Retrieve the walker associated with the controller\n    const Walker *walker = GetWalker(controller.GetId());\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Simulator::RegisterAIController: Could not find walker with ID \" + std::to_string(controller.GetId()));\n    }\n\n    // Assert that the episode is not null\n    if (episode == nullptr) {\n        throw std::runtime_error(\"Simulator::RegisterAIController: Episode is null\");\n    }\n\n    // Create navigation if it is missing\n    if (episode->navigation == nullptr) {\n        episode->navigation = std::make_unique<Navigation>(episode->map);\n    }\n\n    // Register the walker with the controller's ID\n    episode->navigation->RegisterWalker(controller.GetId(), walker->GetId());\n}\n", "CodeBleu_score": 52.10980111199913}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tauto walker = GetWalker(controller.GetWalkerId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker with ID \" + std::to_string(controller.GetWalkerId()) + \" not found\");\n\t}\n\tif (walker->GetEpisode() == nullptr) {\n\t\tthrow std::runtime_error(\"Walker with ID \" + std::to_string(controller.GetWalkerId()) + \" not in an episode\");\n\t}\n\tif (walker->GetEpisode()->GetNavigation() == nullptr) {\n\t\twalker->GetEpisode()->SetNavigation(Navigation::CreateNavigation(GetCurrentMapName()));\n\t}\n\twalker->GetEpisode()->GetNavigation()->RegisterWalker(controller.GetWalkerId(), controller.GetControllerId());\n}\n", "CodeBleu_score": 53.89777124041623}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tauto walker = GetWalker(controller.GetID());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found.\");\n\t}\n\tif (walker->GetEpisode() == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is null.\");\n\t}\n\tif (walker->GetEpisode()->GetNavigation() == nullptr) {\n\t\twalker->GetEpisode()->SetNavigation(std::make_shared<Navigation>(*walker->GetEpisode()));\n\t}\n\twalker->GetEpisode()->GetNavigation()->RegisterWalker(controller);\n}\n", "CodeBleu_score": 48.26544863259624}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  // TODO: Check if the blueprint is valid.\n  // TODO: Check if the transform is valid.\n  // TODO: Check if the parent is valid.\n  // TODO: Check if the socket_name is valid.\n\n  // Create the actor.\n  SharedPtr<Actor> actor = blueprint.Spawn(transform);\n  if (!actor) {\n    throw std::runtime_error(\"Simulator::SpawnActor: Failed to spawn actor.\");\n  }\n\n  // Attach the actor to the parent if provided.\n  if (parent) {\n    Attach(actor, parent, attachment_type, socket_name);\n  }\n\n  // Register the actor in the current episode.\n  RegisterActor(actor, gc);\n\n  // Log the actor creation.\n  LogActorCreation(actor);\n\n  return actor;\n}\n", "CodeBleu_score": 29.766278522748703}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  SharedPtr<Actor> actor = blueprint.Spawn(transform, parent, attachment_type, socket_name);\n  if (actor != nullptr) {\n    if (gc == GarbageCollectionPolicy::LIVE_ON_RESET) {\n      actor->SetActorGarbageCollectionSettings(true, true);\n    } else if (gc == GarbageCollectionPolicy::LIVE_ON_REPLAY) {\n      actor->SetActorGarbageCollectionSettings(false, true);\n    }\n    actor->SetActorApplyPhysicsAfterSpawning(true);\n    // Add actor to current episode\n    AddActor(actor);\n    // Log actor creation\n    LogActorCreation(actor);\n  }\n  return actor;\n}\n", "CodeBleu_score": 33.8097848902411}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  // TODO(mingxu): support parent actor\n  auto actor = blueprint.SpawnActor(transform);\n  if (actor == nullptr) {\n    throw std::runtime_error(\"Failed to spawn actor \" + blueprint.GetActorDescription().id);\n  }\n\n  // apply garbage collection policy\n  if (gc == GarbageCollectionPolicy::Enabled) {\n    actors_.push_back(actor);\n  }\n\n  // log actor creation\n  LogActorCreation(actor, blueprint.GetActorDescription().id);\n\n  // register actor\n  RegisterActor(actor, gc);\n\n  return actor;\n}\n", "CodeBleu_score": 35.05642097085937}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (!IsEpisodeReady()) {\n    throw std::logic_error(\"Call Simulator::BeginEpisode() before attempting to subscribe to a sensor\");\n  }\n  if (callback == nullptr) {\n    throw std::invalid_argument(\"The callback function is null\");\n  }\n  if (!sensor.IsValid()) {\n    throw std::invalid_argument(\"The sensor is invalid\");\n  }\n  if (sensor.GetType() == SensorType::Lidar) {\n    throw std::logic_error(\"Subscribing to a lidar sensor is not supported\");\n  }\n  if (sensor.GetType() == SensorType::Camera) {\n    // TODO(mingxu): Implement camera sensor\n    throw std::logic_error(\"Subscribing to a camera sensor is not supported\");\n  }\n  if (sensor.GetType() == SensorType::SemanticSegmentationCamera) {\n    // TODO(mingxu): Implement semantic segmentation camera sensor\n    throw std::logic_error(\"Subscribing to a semantic segmentation camera sensor is not supported\");\n  }\n\n  // Subscribe to the sensor's data stream\n  client_->SubscribeToStream(sensor.GetStream(),\n      [this, sensor, callback](SharedPtr<sensor::SensorData> data) {\n        // Deserialize the sensor data\n        sensor::SensorData sensor_data = sensor::SensorData::GetFromShared(data);\n        // Associate the data with the current episode\n        sensor_data.SetEpisode(episode_);\n        // Invoke the callback\n        callback(data);\n      });\n}\n", "CodeBleu_score": 37.69785643108322}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (!ValidateEpisode()) {\n    return;\n  }\n  // Subscribe to the sensor's data stream.\n  client_->SubscribeToStream(sensor.GetStream(),\n      [=](const std::string &message) {\n        // Deserialize the incoming message.\n        SharedPtr<sensor::SensorData> data = sensor::SensorDataFactory::Get(\n            sensor.GetType(), message);\n        // Associate the sensor data with the current episode.\n        data->SetEpisode(episode_);\n        // Invoke the provided callback.\n        callback(data);\n      });\n}\n", "CodeBleu_score": 38.41733581920062}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)\n    if (!IsEpisodeReady()) {\n      throw std::runtime_error(\"Episode is not ready!\");\n    }\n\n    // Subscribe to the sensor's stream\n    client->SubscribeToStream(sensor.id, sensor.type, [this, callback](\n        const std::string &stream_id, const std::string &stream_type,\n        const std::vector<uint8_t> &data) {\n\n      // Deserialize the sensor data\n      SharedPtr<sensor::SensorData> sensor_data;\n      if (stream_type == sensor::sensor_data::GetSensorDataType<sensor::LidarMeasurement>()) {\n        sensor_data = sensor::sensor_data::CreateSensorData<sensor::LidarMeasurement>(data);\n      } else if (stream_type == sensor::sensor_data::GetSensorDataType<sensor::RadarMeasurement>()) {\n        sensor_data = sensor::sensor_data::CreateSensorData<sensor::RadarMeasurement>(data);\n      } else if (stream_type == sensor::sensor_data::GetSensorDataType<sensor::CameraImage>()) {\n        sensor_data = sensor::sensor_data::CreateSensorData<sensor::CameraImage>(data);\n      } else if (stream_type == sensor::sensor_data::GetSensorDataType<sensor::Log>()) {\n        sensor_data = sensor::sensor_data::CreateSensorData<sensor::Log>(data);\n      } else if (stream_type == sensor::sensor_data::GetSensorDataType<sensor::CollisionEvent>()) {\n        sensor_data = sensor::sensor_data::CreateSensorData<sensor::CollisionEvent>(data);\n      } else if (stream_type == sensor::sensor_data::GetSensorDataType<sensor::GnssMeasurement>()) {\n        sensor_data = sensor::sensor_data::CreateSensorData<sensor::GnssMeasurement>(data);\n      } else if (stream_type == sensor::sensor_data::GetSensorDataType<sensor", "CodeBleu_score": 36.10939810518515}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    if (episode->GetWalkers().empty()) {\n        return;\n    }\n\n    auto walkers = episode->GetWalkers();\n    auto state = episode->GetState();\n\n    // Remove any walkers that no longer exist\n    for (auto it = walkers.begin(); it != walkers.end();) {\n        if (!it->second->IsAlive()) {\n            it = walkers.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    // Update the vehicles in the crowd and the crowd itself in the navigation module\n    if (!walkers.empty()) {\n        auto walker = walkers.begin()->second;\n        auto vehicle = walker->GetVehicle();\n        auto crowd = walker->GetCrowd();\n        auto crowd_sim = crowd->GetCrowdSimulation();\n\n        // Get the transform and speed of each walker\n        std::vector<carla::geom::Transform> transforms;\n        std::vector<carla::geom::Vector3D> speeds;\n        for (auto &walker : walkers) {\n            transforms.push_back(walker.second->GetTransform());\n            speeds.push_back(walker.second->GetSpeed());\n        }\n\n        // Apply these states in a batch to the simulator\n        crowd_sim->ApplyWalkerState(transforms, speeds);\n    }\n\n    // Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead\n    for (auto &walker : walkers) {\n        if (walker.second->IsDead()) {\n            walker.second->GetCrowd()->RemoveWalker(walker.second);\n            walker.second->Destroy();\n        }\n    }\n}\n", "CodeBleu_score": 41.9842536222657}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)  // Get the list of walkers from the episode\n  auto walkers = episode->GetWalkers();\n  // Check if the list is empty\n  if (walkers.empty())\n    return;\n  // Get the current state of the episode\n  auto state = episode->GetState();\n  // Remove any walkers that no longer exist\n  for (auto it = walkers.begin(); it != walkers.end();) {\n    if (!state.Walkers.count(*it)) {\n      // Remove the walker from the crowd\n      crowd->RemoveAgent(*it);\n      // Destroy the controller\n      (*it)->GetController().Destroy();\n      // Remove the walker from the list\n      it = walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n  // Update the vehicles in the crowd and the crowd itself\n  crowd->Update(state.TimeSeconds);\n  crowd->ApplyAction(state.TimeSeconds);\n  // For each walker\n  for (auto& walker : walkers) {\n    // Get its transform and speed\n    auto transform = walker->GetTransform();\n    auto speed = walker->GetSpeed();\n    // Apply these states in a batch to the simulator\n    simulator->ApplyWalkerState(transform, speed, walker->GetId());\n  }\n  // Check if any walker has been killed\n  for (auto it = walkers.begin(); it != walkers.end();) {\n    // If the walker has been killed\n    if (state.Walkers.count(*it) == 0) {\n      // Remove the walker from the crowd\n      crowd->RemoveAgent(*it);\n      // Destroy the controller\n      (*it)->GetController().Destroy();\n      // Remove the walker from the list\n      it = walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n}\n", "CodeBleu_score": 41.55289362693292}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    // Get the current state of the episode.\n    auto state = episode->CurrentState();\n    // If the crowd is empty, return.\n    if (state.crowd.empty()) {\n        return;\n    }\n    // Get the current walkers.\n    auto walkers = state.crowd;\n    // Remove any walkers that no longer exist.\n    for (auto it = walkers.begin(); it != walkers.end();) {\n        if (it->second.walker == nullptr) {\n            it = walkers.erase(it);\n        } else {\n            ++it;\n        }\n    }\n    // Update the vehicles in the crowd and the crowd itself.\n    for (auto &walker : walkers) {\n        // Get the transform and speed of the walker.\n        auto transform = walker.second.walker->GetActor()->GetTransform();\n        auto speed = walker.second.walker->GetActor()->GetVelocity();\n        // Apply the states in a batch to the simulator.\n        episode->ApplyStateBatch({\n            {Actor::Id(walker.second.walker->GetActor()->GetId()), {\n                {Actor::Attribute::Transform, transform},\n                {Actor::Attribute::Velocity, speed}\n            }}\n        });\n    }\n    // Check if any walker has been killed.\n    for (auto &walker : walkers) {\n        // If the walker is dead, handle their removal from the crowd and destroy their controller.\n        if (walker.second.walker->GetActor()->GetHealth() <= 0.0f) {\n            episode->RemoveActor(walker.second.walker->GetActor()->GetId());\n            walker.second.walker->Destroy();\n        }\n    }\n}\n", "CodeBleu_score": 35.42894746730161}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.id = actor_id_;\n  description.parent_id = parent_actor_id_;\n  description.parent_name = parent_name_;\n  description.transform = transform_;\n  description.bounding_box = bounding_box_;\n  description.attributes = attributes_;\n  description.parent_hash = parent_hash_;\n  description.parent_id = parent_actor_id_;\n  description.parent_name = parent_name_;\n  description.parent_type = parent_type_;\n  description.parent_transform = parent_transform_;\n  description.parent_bounding_box = parent_bounding_box_;\n  description.parent_attributes = parent_attributes_;\n  description.parent_hash = parent_hash_;\n  description.parent_id = parent_actor_id_;\n  description.parent_name = parent_name_;\n  description.parent_type = parent_type_;\n  description.parent_transform = parent_transform_;\n  description.parent_bounding_box = parent_bounding_box_;\n  description.parent_attributes = parent_attributes_;\n  description.parent_hash = parent_hash_;\n  description.parent_id = parent_actor_id_;\n  description.parent_name = parent_name_;\n  description.parent_type = parent_type_;\n  description.parent_transform = parent_transform_;\n  description.parent_bounding_box = parent_bounding_box_;\n  description.parent_attributes = parent_attributes_;\n  description.parent_hash = parent_hash_;\n  description.parent_id = parent_actor_id_;\n  description.parent_name = parent_name_;\n  description.parent_type = parent_type_;\n  description.parent_transform = parent_transform_;\n  description.parent_bounding_box = parent_bounding_box_;\n  description.parent_attributes = parent_attributes_;\n  description.parent_hash = parent_hash_;\n  description.parent_id = parent_actor_id_;\n  description.parent_name = parent_name_;\n  description.parent_type = parent_type_;\n  description.parent_transform = parent_transform_;\n  description.parent_bound", "CodeBleu_score": 39.825071061513526}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.id = id;\n  description.parent_id = parent_id;\n  description.parent_name = parent_name;\n  description.parent_type = parent_type;\n  description.transform = transform;\n  description.bounding_box = bounding_box;\n  description.attributes = attributes;\n  description.parent_hash = parent_hash;\n  description.parent_hash_index = parent_hash_index;\n  description.parent_hash_value = parent_hash_value;\n  description.parent_hash_type = parent_hash_type;\n  description.parent_hash_value_index = parent_hash_value_index;\n  description.parent_hash_value_type = parent_hash_value_type;\n  description.parent_hash_value_index_type = parent_hash_value_index_type;\n  description.parent_hash_value_index_value = parent_hash_value_index_value;\n  description.parent_hash_value_index_type_value = parent_hash_value_index_type_value;\n  description.parent_hash_value_type_value = parent_hash_value_type_value;\n  description.parent_hash_value_type_value_index = parent_hash_value_type_value_index;\n  description.parent_hash_value_type_value_index_type = parent_hash_value_type_value_index_type;\n  description.parent_hash_value_type_value_index_value = parent_hash_value_type_value_index_value;\n  description.parent_hash_value_type_value_index_type_value = parent_hash_value_type_value_index_type_value;\n  description.parent_hash_value_type_value_index_type_value_index = parent_hash_value_type_value_index_type_value_index;\n  description.parent_hash_value_type_value_index_type_value_index_type = parent_hash_value_type_value_index_type_value_index_type;\n  description.parent_hash_value_type_value_index_type", "CodeBleu_score": 39.92289523348914}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.id = id_;\n  description.parent_id = parent_id_;\n  description.transform = transform_;\n  description.bounding_box = bounding_box_;\n  description.attributes = attributes_;\n  return description;\n}\n", "CodeBleu_score": 48.28828912984326}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\n    BlueprintLibrary result;\n\n    for (const auto &blueprint : blueprints) {\n        if (blueprint->HasAttribute(name)) {\n            if (blueprint->GetAttribute(name)->value == value) {\n                result.AddBlueprint(blueprint);\n            }\n        }\n    }\n\n    return result;\n}\n", "CodeBleu_score": 32.586370171661116}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const    BlueprintLibrary result;\n\n    for (const auto& bp : blueprints) {\n      if (bp->HasAttribute(name) && bp->GetAttribute(name) == value) {\n        result.blueprints.push_back(bp);\n      }\n    }\n\n    return std::make_shared<BlueprintLibrary>(result);\n  }\n\n  /*\n   * This function, BlueprintLibrary::FilterByAttribute, filters blueprints by a specified attribute name and value.\\nIt iterates through the blueprints, checks if the attribute exists, and compares its value or recommended values to the specified value.\\nMatching blueprints are added to the result.\\nFinally, it returns a new BlueprintLibrary containing the filtered blueprints.\n   */\n  SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n    const std::string &name, const std::vector<std::string>& values) const {\n    BlueprintLibrary result;\n\n    for (const auto& bp : blueprints) {\n      if (bp->HasAttribute(name) && std::find(values.begin(), values.end(), bp->GetAttribute(name)) != values.end()) {\n        result.blueprints.push_back(bp);\n      }\n    }\n\n    return std::make_shared<BlueprintLibrary>(result);\n  }\n\n  /*\n   * This function, BlueprintLibrary::FilterByAttribute, filters blueprints by a specified attribute name and value.\\nIt iterates through the blueprints, checks if the attribute exists, and compares its value or recommended values to the specified value.\\nMatching blueprints are added to the result.\\nFinally, it returns a new BlueprintLibrary containing the filtered blueprints.\n   */\n  SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n    const std::string &name, const std::vector<int>& values) const {\n    BlueprintLibrary result;\n\n    for (const auto& bp : blueprints) {\n      if (bp->HasAttribute(name) && std::find(values.begin(), values.end(), bp->GetAttribute(name)) != values.end()) {\n        result.blueprint", "CodeBleu_score": 51.3725517918742}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const    std::vector<SharedPtr<Blueprint>> result;\n    for (auto &bp : blueprints_) {\n      if (bp->HasAttribute(name)) {\n        auto attr = bp->GetAttribute(name);\n        if (attr->GetValue() == value) {\n          result.push_back(bp);\n        }\n      }\n    }\n    return std::make_shared<BlueprintLibrary>(result);\n  }\n", "CodeBleu_score": 36.11007888549231}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullpath = GetFullPath(path);\n\tif (!ValidatePath(fullpath)) {\n\t\treturn false;\n\t}\n\n\tstd::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 41.290417680599525}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullPath = GetFullPath(path);\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 38.11175787940366}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\t// Construct the full file path using the base folder and version information\n\tstd::string fullPath = baseFolder + path + \".\" + std::to_string(version);\n\n\t// Validate the file path\n\tif (fullPath.empty() || fullPath.length() >= MAX_PATH) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\n\t// If the file is successfully opened, write the content and close the file\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\n\t// If the file cannot be opened, return false\n\treturn false;\n}\n", "CodeBleu_score": 44.51661415381069}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  // Create a bounding box for the given frame and transform\n  auto bounds = std::make_shared<Bounds>(frame, transform);\n\n  // Add the parent's bounding box location to the transform's location\n  const auto location = transform.location + parent_->bounds_->location;\n\n  // Calculate the four corners of the bounding box by rotating the extents based on the yaw angle\n  const auto yaw = transform.rotation.yaw;\n  const auto cos_yaw = std::cos(yaw);\n  const auto sin_yaw = std::sin(yaw);\n  const auto x_extent = transform.scale.x * extents_.x;\n  const auto y_extent = transform.scale.y * extents_.y;\n  const auto z_extent = transform.scale.z * extents_.z;\n  const auto x_min = location.x - x_extent * cos_yaw - y_extent * sin_yaw;\n  const auto x_max = location.x + x_extent * cos_yaw - y_extent * sin_yaw;\n  const auto y_min = location.y - x_extent * sin_yaw + y_extent * cos_yaw;\n  const auto y_max = location.y + x_extent * sin_yaw + y_extent * cos_yaw;\n  const auto z_min = location.z - z_extent;\n  const auto z_max = location.z + z_extent;\n\n  // Set the four corners of the bounding box\n  bounds->corners_[0].x = x_min;\n  bounds->corners_[0].y = y_min;\n  bounds->corners_[0].z = z_min;\n  bounds->corners_[1].x = x_min;\n  bounds->corners_[1].y = y_max;\n  bounds->corners_[1].z = z_min;\n  bounds->corners_[2].x = x_max;\n  bounds->corners_[2].y = y_max;\n", "CodeBleu_score": 49.58452800624325}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  // Get the parent's bounding box\n  const auto parent_bounds = this->parent_->Bounds(frame);\n  if (parent_bounds == nullptr) {\n    return nullptr;\n  }\n\n  // Get the transform's location\n  const auto location = transform.location();\n\n  // Get the transform's orientation\n  const auto orientation = transform.orientation();\n\n  // Get the transform's yaw angle\n  const auto yaw = orientation.yaw();\n\n  // Get the transform's pitch angle\n  const auto pitch = orientation.pitch();\n\n  // Get the transform's roll angle\n  const auto roll = orientation.roll();\n\n  // Get the transform's extents\n  const auto extents = transform.extents();\n\n  // Create a vector of four corners for the bounding box\n  std::vector<geom::Vector3D> corners;\n\n  // Calculate the four corners of the bounding box\n  corners.push_back(geom::Vector3D(\n        parent_bounds->corners[0].x() + extents.x() * std::cos(yaw) + extents.y() * std::sin(yaw),\n        parent_bounds->corners[0].y() + extents.x() * std::sin(yaw) - extents.y() * std::cos(yaw),\n        parent_bounds->corners[0].z() + extents.z()));\n\n  corners.push_back(geom::Vector3D(\n        parent_bounds->corners[1].x() + extents.x() * std::cos(yaw) + extents.y() * std::sin(yaw),\n        parent_bounds->corners[1].y() + extents.x() * std::sin(yaw) - extents.y() * std::cos(yaw),\n        parent_bounds->corners[1].z() + extents.z()));\n\n  corners.push_back(geom::Vector3D(\n        parent_bounds->corners[2].x() + extents.x() * std::cos(yaw) + extents.y() *", "CodeBleu_score": 38.67413835831298}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  // Calculate the location of the bounding box\n  const auto location = transform.Location() + parent_->bounds_.Location();\n\n  // Calculate the four corners of the bounding box\n  const auto x_extent = transform.Rotation().Rotate(extent_);\n  const auto x_corner = location + x_extent;\n  const auto y_extent = transform.Rotation().Rotate(geom::Vector3D(extent_.y(), 0, 0));\n  const auto y_corner = location + y_extent;\n  const auto z_extent = transform.Rotation().Rotate(geom::Vector3D(0, 0, extent_.z()));\n  const auto z_corner = location + z_extent;\n\n  // Return a shared pointer to a Bounds object\n  return std::make_shared<const Bounds>(frame, x_corner, y_corner, z_corner);\n}\n", "CodeBleu_score": 40.4193310809418}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()\t//Lock the mutex\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t//Get the current state of the lights from the server\n\tstd::vector<Light> lights = server->QueryLightsState();\n\n\t//Update the local light states\n\tfor (Light light : lights) {\n\t\tif (_lights.find(light.GetId()) == _lights.end()) {\n\t\t\t//The light does not exist in the map\n\t\t\t//Create a new light object\n\t\t\tLight newLight(light.GetId(), light.GetName(), light.GetState(), light.GetColor(), light.GetBrightness(), light.GetColorTemperature(), light.GetPower(), light.GetPosition(), light.GetPositionX(), light.GetPositionY(), light.GetPositionZ(), light.GetPositionW(), light.GetDirection(), light.GetDirectionX(), light.GetDirectionY(), light.GetDirectionZ(), light.GetDirectionW(), light.GetRadius(), light.GetAngle(), light.GetAngleX(), light.GetAngleY(), light.GetAngleZ(), light.GetAngleW(), light.GetFalloff(), light.GetCutoff(), light.GetConstant(), light.GetLinear(), light.GetQuadratic());\n\t\t\t_lights[light.GetId()] = newLight;\n\t\t}\n\t\telse {\n\t\t\t//The light exists in the map\n\t\t\t//Update the light object\n\t\t\t_lights[light.GetId()].SetName(light.GetName());\n\t\t\t_lights[light.GetId()].SetState(light.GetState());\n\t\t\t_lights[light.GetId()].SetColor(light.GetColor());\n\t\t\t_lights[light.GetId()].SetBrightness(light.GetBrightness());\n\t\t\t_lights[light.GetId()].SetColorTemperature(light.GetColorTemperature());\n\t\t\t_lights[light.GetId()].SetPower(light.GetPower());\n\t\t\t_lights[light.GetId()].SetPosition(light.GetPosition());\n\t\t\t_lights[light", "CodeBleu_score": 26.519478854568394}, {"code": "void LightManager::QueryLightsStateToServer()\t//Lock the mutex\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t//Get the light states from the server\n\tstd::vector<LightState> states = _server->GetLightStates();\n\n\t//For each light state\n\tfor (const LightState& state : states) {\n\t\t//If the light does not already exist\n\t\tif (_lights.find(state.id) == _lights.end()) {\n\t\t\t//Create a new light object and add it to the map\n\t\t\t_lights[state.id] = new Light(state.id, state.color, state.brightness);\n\t\t}\n\t\t//Otherwise\n\t\telse {\n\t\t\t//Update the light object's state\n\t\t\t_lights[state.id]->UpdateState(state.color, state.brightness);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 31.774508119446292}, {"code": "void LightManager::QueryLightsStateToServer()\t// Lock mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Retrieve light states from server\n\tstd::map<std::string, std::string> lightStates = server->GetLightsState();\n\n\t// Update local light states\n\tfor (auto lightState : lightStates) {\n\t\t// Get light state\n\t\tstd::string lightStateString = lightState.second;\n\n\t\t// Get light name\n\t\tstd::string lightName = lightState.first;\n\n\t\t// Get light state\n\t\tLightState lightStateEnum = LightStateFromString(lightStateString);\n\n\t\t// Update local light state\n\t\tlights[lightName]->SetLightState(lightStateEnum);\n\t}\n}\n", "CodeBleu_score": 31.09642694375898}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)    std::lock_guard<std::mutex> lock(light_mutex);\n    if (dirty) {\n        std::string msg = \"lights\";\n        msg += \"|\";\n        for (int i = 0; i < 16; i++) {\n            if (light_states[i] != last_light_states[i]) {\n                msg += std::to_string(i);\n                msg += \":\";\n                msg += std::to_string(light_states[i]);\n                msg += \";\";\n            }\n        }\n        if (discard_client) {\n            msg += \"|discard\";\n        }\n        msg += \"|\";\n        std::cout << msg << std::endl;\n        socket->send(msg);\n        last_light_states = light_states;\n        dirty = false;\n    }\n}\n", "CodeBleu_score": 39.54436642945282}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)    std::lock_guard<std::mutex> lock(lights_mutex);\n    if (lights_changed) {\n        std::vector<LightState> light_states;\n        for (auto light : lights) {\n            light_states.push_back(light->GetLightState());\n        }\n        if (!discard_client) {\n            Message message = Message(MessageType::LIGHT_STATE_UPDATE, light_states);\n            server->SendMessage(message);\n        }\n        lights_changed = false;\n        dirty = true;\n    }\n}\n", "CodeBleu_score": 35.0961527964355}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)    std::lock_guard<std::mutex> lock(light_mutex);\n    if (lights_dirty) {\n        std::vector<Light> lights_to_send;\n        for (auto &light : lights) {\n            if (light.dirty) {\n                lights_to_send.push_back(light);\n            }\n        }\n        if (lights_to_send.size() > 0) {\n            Message msg;\n            msg.type = Message::Type::LIGHT_STATE_CHANGE;\n            msg.data.resize(sizeof(Light) * lights_to_send.size());\n            memcpy(msg.data.data(), lights_to_send.data(), sizeof(Light) * lights_to_send.size());\n            if (discard_client) {\n                msg.flags |= Message::Flag::DISCARD_CLIENT;\n            }\n            msg.size = sizeof(Light) * lights_to_send.size();\n            server_socket->SendMessage(msg);\n        }\n        for (auto &light : lights) {\n            light.dirty = false;\n        }\n        lights_dirty = false;\n    }\n}\n", "CodeBleu_score": 43.62186521010833}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)\tif (this->id != \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"Warning: Sensor ID is not 'sensor.other.v2x_custom', not sending message.\" << std::endl;\n\t\treturn;\n\t}\n\tthis->episode->SendMessage(this->context, message);\n}\n", "CodeBleu_score": 29.81237490962414}, {"code": "void ServerSideSensor::Send(std::string message)  if (this->GetID() == \"sensor.other.v2x_custom\") {\n    Log::Warning(\"V2X Sensor: Send() called with message: \" + message);\n  }\n}\n", "CodeBleu_score": 25.454261017525724}, {"code": "void ServerSideSensor::Send(std::string message)\t// This function, ServerSideSensor::Send, logs a debug message when called.\\nIt checks if the sensor's ID is \"sensor.other.v2x_custom\" and logs a warning if it is not, then returns.\\nIf the sensor's ID matches, it sends a message to the episode using the sensor's context.\n\tif (this->id != \"sensor.other.v2x_custom\") {\n\t\tstd::cerr << \"ServerSideSensor::Send: WARNING: Sensor ID is not 'sensor.other.v2x_custom', it is \" << this->id << std::endl;\n\t\treturn;\n\t}\n\t// If the sensor's ID matches, it sends a message to the episode using the sensor's context.\n\tthis->context->Send(message);\n}\n", "CodeBleu_score": 38.48576408650134}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)    if (enabled) {\n        if (tm_port == 0) {\n            tm_port = 8000;\n        }\n        // Register with TM\n        std::string tm_error;\n        int tm_status = -1;\n        tm_status = TM_RegisterAgent(tm_port, this->vehicle_id, &tm_error);\n        if (tm_status != 0) {\n            std::cout << \"Error occurred while registering with TM: \" << tm_error << std::endl;\n        }\n    } else {\n        // Unregister with TM\n        std::string tm_error;\n        int tm_status = -1;\n        tm_status = TM_UnregisterAgent(this->vehicle_id, &tm_error);\n        if (tm_status != 0) {\n            std::cout << \"Error occurred while unregistering with TM: \" << tm_error << std::endl;\n        }\n    }\n}\n", "CodeBleu_score": 36.96295246635886}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)    if (enabled) {\n        // Enable autopilot\n        if (tm_port != 0) {\n            // Register with TM\n            traffic_mgr_port = tm_port;\n            tm_enabled = true;\n            tm_connected = false;\n            tm_error = false;\n            tm_last_error = \"\";\n            tm_socket = -1;\n            tm_buffer_size = 0;\n            tm_buffer = NULL;\n            tm_buffer_index = 0;\n            tm_buffer_index_read = 0;\n            tm_buffer_index_write = 0;\n            tm_buffer_index_read_last = 0;\n            tm_buffer_index_write_last = 0;\n            tm_buffer_index_read_last_last = 0;\n            tm_buffer_index_write_last_last = 0;\n            tm_buffer_index_read_last_last_last = 0;\n            tm_buffer_index_write_last_last_last = 0;\n            tm_buffer_index_read_last_last_last_last = 0;\n            tm_buffer_index_write_last_last_last_last = 0;\n            tm_buffer_index_read_last_last_last_last_last = 0;\n            tm_buffer_index_write_last_last_last_last_last = 0;\n            tm_buffer_index_read_last_last_last_last_last_last = 0;\n            tm_buffer_index_write_last_last_last_last_last_last = 0;\n            tm_buffer_index_read_last_last_last_last_last_last_last = 0;\n            tm_buffer_index_write_last_last_last_last_last_last_last = 0;\n            tm_buffer_index_read_last_last_last_last_last_last_last_last = 0;\n            tm_buffer_index_write_last_last_last_last_last_last_last_last = 0;\n            tm_buffer_index_read_last_last_last", "CodeBleu_score": 21.77907372028799}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)    if (enabled) {\n        // Register with the Traffic Manager\n        this->traffic_mgr_port = tm_port;\n        this->RegisterWithTM(tm_port);\n    } else {\n        // Unregister with the Traffic Manager\n        this->DeregisterFromTM();\n    }\n}\n", "CodeBleu_score": 39.72358644310702}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()\tSuper::Start();\n\t// Get the walker actor\n\tauto walker = GetPawn();\n\tif (walker) {\n\t\t// Get the current location\n\t\tauto location = walker->GetActorLocation();\n\t\t// Add the walker actor to the navigation system\n\t\tauto navSys = GetWorld()->GetNavigationSystem();\n\t\tnavSys->SimpleMoveToLocation(walker, location);\n\t\t// Disable the physics simulation and collisions for the walker actor\n\t\twalker->SetActorEnableCollision(false);\n\t\twalker->SetActorEnableCollision(true);\n\t}\n}\n", "CodeBleu_score": 42.45411818438898}, {"code": "void WalkerAIController::Start()    // Get the walker actor\n    FActorSpawnParameters SpawnInfo;\n    SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n    AActor *Walker = GetWorld()->SpawnActor(WalkerClass, GetActorLocation(), GetActorRotation(), SpawnInfo);\n    if (Walker) {\n        // Disable the physics simulation and collisions for the walker actor\n        Walker->SetActorEnableCollision(false);\n        Walker->SetActorSimulatePhysics(false);\n        // Add the walker actor to the navigation system with its current location\n        UNavigationSystemV1 *NavSys = UNavigationSystemV1::GetNavigationSystem(GetWorld());\n        if (NavSys) {\n            NavSys->RegisterNavigationDataInstance(Walker);\n            UNavigationSystemV1::SimpleMoveToLocation(this, Walker->GetActorLocation());\n        }\n    }\n}\n", "CodeBleu_score": 40.35727128861248}, {"code": "void WalkerAIController::Start()\tSuper::Start();\n\n\t// Get the walker actor\n\tUWalkerCharacter* Walker = Cast<UWalkerCharacter>(GetPawn());\n\tif (Walker) {\n\t\t// Get the location of the walker actor\n\t\tFVector Location = Walker->GetActorLocation();\n\t\t// Add the walker actor to the navigation system\n\t\tUNavigationSystemV1* NavSys = UNavigationSystemV1::GetNavigationSystem(GetWorld());\n\t\tif (NavSys) {\n\t\t\t// Add the walker actor to the navigation system\n\t\t\tNavSys->RegisterNavAgent(Walker, 0.f, false);\n\t\t}\n\t\t// Disable the physics simulation and collisions for the walker actor\n\t\tWalker->SetActorEnableCollision(false);\n\t\tWalker->SetActorHiddenInGame(true);\n\t\tWalker->DisableAI(true);\n\t}\n}\n", "CodeBleu_score": 39.61981018975651}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)    // Check if the navigation instance is valid\n    if (navigation_instance_ == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation instance is nullptr\"));\n        return;\n    }\n\n    // Get the parent walker\n    auto walker = Cast<AWalker>(GetPawn());\n    if (walker == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Walker is nullptr\"));\n        return;\n    }\n\n    // Attempt to set the maximum speed\n    if (!navigation_instance_->SetMaxSpeed(walker, max_speed)) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set maximum speed\"));\n    }\n}\n", "CodeBleu_score": 44.00420086053557}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  // get the navigation instance\n  UAIPerceptionSystem* perception_system = UAIPerceptionSystem::GetCurrent(GetWorld());\n  UNavigationSystem* navigation_system = perception_system ? perception_system->GetNavigationSystem() : nullptr;\n  if (!navigation_system) {\n    UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to retrieve the navigation system from the perception system.\"));\n    return;\n  }\n\n  // get the parent walker\n  AWalker* walker = Cast<AWalker>(GetPawn());\n  if (!walker) {\n    UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to retrieve the walker from the controller.\"));\n    return;\n  }\n\n  // attempt to set the maximum speed\n  if (!navigation_system->SetMaxSpeed(walker, max_speed)) {\n    UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set the maximum speed for the walker.\"));\n  }\n}\n", "CodeBleu_score": 40.77999087031798}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)    auto* nav_instance = GetWorld()->GetNavigationSystem();\n    if (nav_instance) {\n        auto* walker = Cast<AWalker>(GetPawn());\n        if (walker) {\n            walker->SetMaxSpeed(max_speed);\n            UE_LOG(LogTemp, Log, TEXT(\"WalkerAIController::SetMaxSpeed: %f\"), max_speed);\n        } else {\n            UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: walker not found\"));\n        }\n    } else {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: navigation instance not found\"));\n    }\n}\n", "CodeBleu_score": 45.969820783498804}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const  std::vector<SharedPtr<Waypoint>> result;\n  if (distance <= 0.0) {\n    return result;\n  }\n  double current_distance = 0.0;\n  std::vector<SharedPtr<Waypoint>> previous_waypoints = GetParentMap()->GetPreviousWaypoints(GetId());\n  for (auto wp = previous_waypoints.begin(); wp != previous_waypoints.end(); ++wp) {\n    double wp_distance = GetDistance(*wp);\n    if (current_distance + wp_distance >= distance) {\n      break;\n    }\n    SharedPtr<Waypoint> new_wp = new Waypoint(*wp);\n    result.push_back(new_wp);\n    current_distance += wp_distance;\n  }\n  return result;\n}\n", "CodeBleu_score": 54.27371689978753}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const  std::vector<SharedPtr<Waypoint>> result;\n  if (distance <= 0) {\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> previousWaypoints = GetParentMap()->GetPreviousWaypoints(this, distance);\n  for (const auto& wp : previousWaypoints) {\n    result.push_back(new Waypoint(wp));\n  }\n\n  return result;\n}\n", "CodeBleu_score": 49.18204996784779}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const  std::vector<SharedPtr<Waypoint>> result;\n  if (distance <= 0)\n    return result;\n\n  // Get the previous waypoints from the parent map\n  std::vector<SharedPtr<Waypoint>> previous_waypoints = parent_map_->GetPrevious(this, distance);\n  for (auto& wp : previous_waypoints) {\n    // Create a new Waypoint object and add it to the result vector\n    result.push_back(new Waypoint(*wp));\n  }\n\n  return result;\n}\n", "CodeBleu_score": 52.361084436282056}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::set<SharedPtr<Signal>> unique_signals;\n  for (auto signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      result.push_back(signal->GetLandmark());\n    }\n  }\n  return result;\n}\n", "CodeBleu_score": 35.15675558711563}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  // TODO: Implement this function\n  std::vector<SharedPtr<Landmark>> landmarks;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::set<SharedPtr<Signal>> unique_signals;\n  for (auto signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      SharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(signal));\n      landmarks.push_back(landmark);\n    }\n  }\n  return landmarks;\n}\n", "CodeBleu_score": 43.646765818944274}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> landmarks;\n\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::vector<SharedPtr<Signal>>::iterator it;\n  std::vector<SharedPtr<Signal>>::iterator end = signals.end();\n  for (it = signals.begin(); it != end; ++it) {\n    SharedPtr<Landmark> landmark = GetLandmark(*it);\n    if (landmark) {\n      if (std::find(landmarks.begin(), landmarks.end(), landmark) == landmarks.end()) {\n        landmarks.push_back(landmark);\n      }\n    }\n  }\n\n  return landmarks;\n}\n", "CodeBleu_score": 41.78669631113918}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)    // TODO: This function is too long, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too complex, refactor it.\n    // TODO: This function is too", "CodeBleu_score": 3.155955238531317}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  if (!IsOpen()) {\n    return 0;\n  }\n\n  // Apply settings\n  uint64_t new_settings_id = 0;\n  try {\n    new_settings_id = ApplySettingsImpl(settings, timeout);\n  } catch (const std::exception &e) {\n    LogError(\"Failed to apply settings: \" + std::string(e.what()));\n  }\n\n  return new_settings_id;\n}\n", "CodeBleu_score": 18.48507311707338}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (settings.synchronous_mode) {\n    // If we are in synchronous mode, we need to set the synchronous time\n    // before we apply the settings\n    SetSynchronousTime(settings.fixed_delta_seconds);\n  }\n\n  // Apply the settings\n  ApplySettingsInternal(settings, timeout);\n\n  // Return the settings id\n  return settings_id_;\n}\n", "CodeBleu_score": 10.796315139949995}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tpublic:\n\t\t/**\n\t\t * @brief Calculates the shortest distance from a point to a line segment in 2D space.\n\t\t * @param point The point to calculate the distance from.\n\t\t * @param segmentStart The start of the segment.\n\t\t * @param segmentEnd The end of the segment.\n\t\t * @return A pair of floats. The first float is the distance along the segment, and the second float is the distance from the projection to the point.\n\t\t */\n\t\tstd::pair<float, float> operator()(const glm::vec2& point, const glm::vec2& segmentStart, const glm::vec2& segmentEnd) const {\n\t\t\tfloat lengthSquared = glm::length2(segmentEnd - segmentStart);\n\t\t\tfloat length = sqrtf(lengthSquared);\n\t\t\tfloat dot = glm::dot(segmentEnd - segmentStart, point - segmentStart);\n\t\t\tfloat projection = dot / lengthSquared;\n\t\t\tif (projection <= 0.0f) {\n\t\t\t\treturn { 0.0f, glm::distance(point, segmentStart) };\n\t\t\t} else if (projection >= 1.0f) {\n\t\t\t\treturn { length, glm::distance(point, segmentEnd) };\n\t\t\t} else {\n\t\t\t\treturn { projection, glm::distance(point, segmentStart + projection * (segmentEnd - segmentStart)) };\n\t\t\t}\n\t\t}\n};\n", "CodeBleu_score": 40.93796609203855}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tstd::pair<float, float>(\n\t\t/*\n\t\t * This function, Math::DistanceSegmentToPoint, calculates the shortest distance from a point to a line segment in 2D space.\\nIt first computes the squared length of the segment and its length.\\nIf the segment length is zero, it returns zero and the distance from the point to one endpoint.\\nOtherwise, it projects the point onto the segment, clamps the projection, and returns the distance along the segment and the distance from the projection to the point.\n\t\t */\n\t\t[](const std::pair<float, float>& point, const std::pair<float, float>& segmentA, const std::pair<float, float>& segmentB) {\n\t\t\t// Compute the squared length of the segment and its length.\n\t\t\tconst float squaredLength = Math::SquaredDistance(segmentA, segmentB);\n\t\t\tconst float length = std::sqrt(squaredLength);\n\t\t\t// If the segment length is zero, it returns zero and the distance from the point to one endpoint.\n\t\t\tif (length == 0) {\n\t\t\t\treturn std::make_pair(0, std::abs(point.first - segmentA.first) + std::abs(point.second - segmentA.second));\n\t\t\t}\n\t\t\t// Otherwise, it projects the point onto the segment, clamps the projection, and returns the distance along the segment and the distance from the projection to the point.\n\t\t\tconst float t = Math::Clamp(Math::Dot(point, segmentA, segmentB) / squaredLength, 0, 1);\n\t\t\tconst float projectionX = segmentA.first + t * (segmentB.first - segmentA.first);\n\t\t\tconst float projectionY = segmentA.second + t * (segmentB.second - segmentA.second);\n\t\t\treturn std::make_pair(t * length, std::abs(point.first - projectionX) + std::abs(point.second - projectionY));\n\t\t}\n\t)\n};\n", "CodeBleu_score": 45.04519709083869}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tstd::pair<float, float> Math::DistanceSegmentToPoint(const Vector2& a, const Vector2& b, const Vector2& p) {\n\t\tfloat l2 = (b - a).LengthSquared();\n\t\tif (l2 == 0.0f) return std::pair<float, float>(0.0f, (p - a).Length());\n\t\tfloat t = ((p - a) * (b - a)) / l2;\n\t\tif (t < 0.0f) return std::pair<float, float>(0.0f, (p - a).Length());\n\t\tif (t > 1.0f) return std::pair<float, float>(l2, (p - b).Length());\n\t\tVector2 projection = a + t * (b - a);\n\t\treturn std::pair<float, float>(l2, (p - projection).Length());\n\t}\n};\n", "CodeBleu_score": 44.87415244257753}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tindex_type index = (index_type)vertices.size();\n\tAddVertices(vertices);\n\tfor (index_type i = 0; i < index - 2; ++i)\n\t\tAddTriangle(index, i + 1, i);\n}\n", "CodeBleu_score": 37.15334938553831}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n\n    size_t initialIndex = this->vertices.size();\n    this->vertices.insert(this->vertices.end(), vertices.begin(), vertices.end());\n\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n        this->indices.push_back(initialIndex);\n        this->indices.push_back(initialIndex + i);\n        this->indices.push_back(initialIndex + i + 1);\n    }\n}\n", "CodeBleu_score": 35.92929910014917}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tindex_type initial_index = AddVertices(vertices);\n\tfor (size_t i = 1; i < vertices.size() - 1; ++i) {\n\t\tAddTriangle(initial_index, initial_index + i, initial_index + i + 1);\n\t}\n}\n", "CodeBleu_score": 38.459159939966014}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (message->IsValid()) {\n    std::weak_ptr<Primary> self_weak(shared_from_this());\n    boost::asio::post(\n        strand,\n        [self_weak, message]() {\n          auto self = self_weak.lock();\n          if (self) {\n            if (self->_socket.is_open()) {\n              self->_timer.expires_from_now(boost::posix_time::seconds(self->_timeout));\n              self->_timer.async_wait(\n                  [self](const boost::system::error_code &error) {\n                    if (!error) {\n                      self->Close();\n                    }\n                  });\n              self->_socket.async_write_some(\n                  boost::asio::buffer(message->GetData(), message->GetSize()),\n                  [self](const boost::system::error_code &error, std::size_t) {\n                    self->HandleSent(error);\n                  });\n            } else {\n              self->Close();\n            }\n          }\n        });\n  } else {\n    Close();\n  }\n}\n", "CodeBleu_score": 40.91197757557431}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (message->Valid()) {\n    std::lock_guard<std::mutex> lock(_mutex);\n    if (_socket.is_open()) {\n      _socket.expires_after(std::chrono::milliseconds(timeout));\n      _socket.async_write_some(\n          boost::asio::buffer(message->data(), message->size()),\n          boost::asio::bind_executor(\n              _strand,\n              std::bind(\n                  &Primary::handle_sent,\n                  this,\n                  std::placeholders::_1,\n                  std::placeholders::_2,\n                  message)));\n    }\n  }\n}\n", "CodeBleu_score": 24.72051096967319}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (message->IsValid()) {\n    _strand.post([this, message]() {\n      if (_socket.is_open()) {\n        _socket.expires_after(std::chrono::seconds(10));\n        _socket.async_write_some(\n            boost::asio::buffer(message->Data(), message->Size()),\n            std::bind(&Primary::handle_sent, shared_from_this(), std::placeholders::_1, std::placeholders::_2, message));\n      }\n    });\n  } else {\n    Log(\"Invalid message.\");\n  }\n}\n", "CodeBleu_score": 24.10187111249784}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)    // Cancel the timer\n    if (timer.expires_at() != boost::asio::steady_timer::time_point()) {\n        timer.cancel();\n    }\n\n    // If there is an error, log it\n    if (ec) {\n        // If the error is not \"operation canceled\", log it\n        if (ec.value() != boost::system::errc::operation_canceled) {\n            // If the error is not \"connection reset by peer\" or \"connection aborted\", log it\n            if (ec.value() != boost::system::errc::connection_reset && ec.value() != boost::system::errc::connection_aborted) {\n                LOG_ERROR(\"Error closing socket: \" << ec.message());\n            }\n        }\n    }\n\n    // If the socket is open, attempt to shut it down and close it\n    if (socket.is_open()) {\n        boost::system::error_code ignored_ec;\n        socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n        socket.close(ignored_ec);\n    }\n\n    // Call the on_closed callback\n    if (on_closed) {\n        on_closed(shared_from_this());\n    }\n\n    // Log that the session has been closed\n    LOG_INFO(\"Session closed\");\n}\n", "CodeBleu_score": 47.446316832892556}, {"code": "void Primary::CloseNow(boost::system::error_code ec)    // cancel the timer\n    if (timer_ != nullptr) {\n        timer_->cancel();\n    }\n\n    // shutdown and close the socket\n    if (ec == boost::system::error_code() && socket_.is_open()) {\n        boost::system::error_code ec;\n        socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        socket_.close(ec);\n    }\n\n    // log that the session has been closed\n    if (ec) {\n        LOG_ERROR << \"Error closing socket: \" << ec.message();\n    } else {\n        LOG_INFO << \"Session closed\";\n    }\n\n    // trigger the on_closed callback\n    if (on_closed_) {\n        on_closed_(ec);\n    }\n}\n", "CodeBleu_score": 47.47123308748308}, {"code": "void Primary::CloseNow(boost::system::error_code ec)    // Cancel the timer\n    m_deadlineTimer.cancel();\n\n    // If no error code is provided, attempt to shut down and close the socket\n    if (!ec) {\n        // Shutdown the socket\n        boost::system::error_code ignoredEc;\n        m_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignoredEc);\n\n        // Close the socket\n        m_socket.close();\n    }\n\n    // Trigger the on_closed callback\n    m_onClosed(ec);\n\n    // Log that the session has been closed\n    std::stringstream ss;\n    ss << \"Closed connection to \" << m_socket.remote_endpoint().address().to_string() << \":\" << m_socket.remote_endpoint().port();\n    if (ec) {\n        ss << \" - \" << ec.message();\n    }\n    std::cout << ss.str() << std::endl;\n}\n", "CodeBleu_score": 48.89855000745607}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()    char *buffer = new char[strlen(IS_ALIVE) + 1];\n    strcpy(buffer, IS_ALIVE);\n    log_send_message(buffer);\n    send_to_next_router(buffer, YOU_ALIVE);\n    delete[] buffer;\n    char *response = receive_from_next_router();\n    log_receive_message(response);\n    delete[] response;\n}\n", "CodeBleu_score": 28.343638061740645}, {"code": "void PrimaryCommands::SendIsAlive()    // Create the message buffer\n    char * buffer = new char[20];\n    // Fill the buffer with the message\n    sprintf(buffer, \"Are you alive?\");\n    // Log the sending action\n    Logging::Log(\"Sending 'Are you alive?'\");\n    // Write the buffer to the next router\n    Write(YOU_ALIVE, buffer);\n    // Wait for and log the response from the system\n    WaitForResponse(buffer);\n}\n", "CodeBleu_score": 19.787888524957857}, {"code": "void PrimaryCommands::SendIsAlive()    char message[100] = \"Are you alive?\";\n    char buffer[100];\n    int length = strlen(message);\n    int i;\n    for (i = 0; i < length; i++) {\n        buffer[i] = message[i];\n    }\n    buffer[i] = '\\0';\n    cout << \"Sending: \" << buffer << endl;\n    int command = YOU_ALIVE;\n    int commandLength = sizeof(command);\n    int commandLengthBuffer[commandLength];\n    int j;\n    for (j = 0; j < commandLength; j++) {\n        commandLengthBuffer[j] = command;\n    }\n    for (j = 0; j < commandLength; j++) {\n        buffer[i] = commandLengthBuffer[j];\n        i++;\n    }\n    buffer[i] = '\\0';\n    write(nextRouter, buffer, i);\n    char response[100];\n    read(nextRouter, response, 100);\n    cout << \"Response: \" << response << endl;\n}\n", "CodeBleu_score": 35.25181201193151}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if the sensor has been activated on any server\n    if (!sensor_ids.empty()) {\n        // Create a buffer with the sensor ID\n        std::vector<uint8_t> buffer;\n        buffer.push_back(sensor_id);\n\n        // Send the ENABLE_ROS command to the router\n        router->send(ENABLE_ROS, buffer);\n\n        // Wait for and process the response\n        std::vector<uint8_t> response = router->receive();\n        if (response.empty()) {\n            // Log an error message\n            std::cerr << \"No response from the router.\" << std::endl;\n        } else if (response.size() == 1) {\n            // Check if the response is a valid sensor ID\n            if (response[0] == sensor_id) {\n                // Log a success message\n                std::cout << \"ROS enabled for sensor \" << (int) sensor_id << \".\" << std::endl;\n            } else {\n                // Log an error message\n                std::cerr << \"Invalid sensor ID \" << (int) response[0] << \" received from the router.\" << std::endl;\n            }\n        } else {\n            // Log an error message\n            std::cerr << \"Invalid response received from the router.\" << std::endl;\n        }\n    } else {\n        // Log an error message\n        std::cerr << \"Sensor \" << (int) sensor_id << \" is not activated on any secondary server.\" << std::endl;\n    }\n}\n", "CodeBleu_score": 41.254323864016484}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    if (sensor_id == 0) {\n        return;\n    }\n    if (sensor_id > 1000) {\n        sensor_id = sensor_id - 1000;\n    }\n    if (sensor_id < 0 || sensor_id > 1000) {\n        ROS_ERROR(\"Invalid sensor ID\");\n        return;\n    }\n    if (sensor_id < 100) {\n        sensor_id = sensor_id + 1000;\n    }\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0", "CodeBleu_score": 29.913089942324177}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if the sensor has been activated on any secondary server\n    if (SensorActivatedOnSecondary(sensor_id)) {\n        // Create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router\n        std::stringstream buffer;\n        buffer << sensor_id;\n        router->SendCommand(buffer, ENABLE_ROS);\n\n        // Wait for and process the server's response\n        std::string response = router->WaitForResponse();\n        if (response == \"SUCCESS\") {\n            // Log a success message\n            logger->info(\"Successfully enabled sensor {} for ROS\", sensor_id);\n        } else {\n            // Log an error message\n            logger->error(\"Failed to enable sensor {} for ROS\", sensor_id);\n        }\n    } else {\n        // Log an error message\n        logger->error(\"Failed to enable sensor {} for ROS\", sensor_id);\n    }\n}\n", "CodeBleu_score": 41.06509770042704}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)  token_type token;\n  token_type old_token;\n  if (sensor_id == 0) {\n    return 0;\n  }\n  if (sensor_id == 1) {\n    return 1;\n  }\n  if (sensor_id == 2) {\n    return 2;\n  }\n  if (sensor_id == 3) {\n    return 3;\n  }\n  if (sensor_id == 4) {\n    return 4;\n  }\n  if (sensor_id == 5) {\n    return 5;\n  }\n  if (sensor_id == 6) {\n    return 6;\n  }\n  if (sensor_id == 7) {\n    return 7;\n  }\n  if (sensor_id == 8) {\n    return 8;\n  }\n  if (sensor_id == 9) {\n    return 9;\n  }\n  if (sensor_id == 10) {\n    return 10;\n  }\n  if (sensor_id == 11) {\n    return 11;\n  }\n  if (sensor_id == 12) {\n    return 12;\n  }\n  if (sensor_id == 13) {\n    return 13;\n  }\n  if (sensor_id == 14) {\n    return 14;\n  }\n  if (sensor_id == 15) {\n    return 15;\n  }\n  if (sensor_id == 16) {\n    return 16;\n  }\n  if (sensor_id == 17) {\n    return 17;\n  }\n  if (sensor_id == 18) {\n    return 18;\n  }\n  if (sensor_id == 19) {\n    return 19;\n  }\n  if (sensor_id == 20) {\n    return 20;\n  }\n  if (sensor_id == 21)", "CodeBleu_score": 12.031184543658519}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)    // Check if the sensor is already activated.\n    if (activated_sensors.find(sensor_id) != activated_sensors.end()) {\n        // The sensor is already activated, so we return the token associated with the sensor.\n        token_type token = activated_sensors.at(sensor_id);\n        // Log the action.\n        LogAction(\"GetToken\", \"Sensor \" + to_string(sensor_id) + \" is already activated with token \" + to_string(token));\n        return token;\n    }\n    // The sensor is not activated, so we enable the sensor on a secondary server, retrieve a new token, update the maps, log the action, and return the new token.\n    // Enable the sensor on a secondary server.\n    EnableSensor(sensor_id);\n    // Retrieve a new token.\n    token_type token = GetSensorToken(sensor_id);\n    // Update the maps.\n    activated_sensors[sensor_id] = token;\n    activated_tokens[token] = sensor_id;\n    // Log the action.\n    LogAction(\"GetToken\", \"Sensor \" + to_string(sensor_id) + \" is now activated with token \" + to_string(token));\n    return token;\n}\n", "CodeBleu_score": 49.0879961658384}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)  token_type token;\n  token_type new_token;\n\n  // Check if the sensor is already activated\n  if (sensor_tokens.find(sensor_id) != sensor_tokens.end()) {\n    // Sensor is already activated\n    token = sensor_tokens[sensor_id];\n    // Log the action\n    std::stringstream ss;\n    ss << \"Sensor \" << sensor_id << \" is already activated. Returning the existing token.\";\n    LOG(INFO) << ss.str();\n  } else {\n    // Sensor is not activated\n    // Enable the sensor on the secondary server\n    std::stringstream ss;\n    ss << \"Sensor \" << sensor_id << \" is not activated. Enabling the sensor on the secondary server.\";\n    LOG(INFO) << ss.str();\n    // Get a new token\n    new_token = secondary_server_->EnableSensor(sensor_id);\n    // Update the maps\n    sensor_tokens[sensor_id] = new_token;\n    sensor_to_stream_id_map[new_token] = sensor_id;\n    // Log the action\n    ss.str(\"\");\n    ss << \"Sensor \" << sensor_id << \" is now activated. Returning the new token.\";\n    LOG(INFO) << ss.str();\n    token = new_token;\n  }\n  return token;\n}\n", "CodeBleu_score": 47.213025680178674}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file;\n\tfile.open(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> data;\n\tfile.seekg(0, std::ios::end);\n\tdata.resize(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read(&data[0], data.size());\n\tfile.close();\n\treturn Load(data);\n}\n", "CodeBleu_score": 58.41364891205538}, {"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (file) {\n        std::vector<char> buffer;\n        file.seekg(0, std::ios::end);\n        buffer.resize(file.tellg());\n        file.seekg(0, std::ios::beg);\n        file.read(&buffer[0], buffer.size());\n        file.close();\n        return Load(buffer);\n    }\n    return false;\n}\n", "CodeBleu_score": 47.962402247596984}, {"code": "bool Navigation::Load(const std::string &filename)  std::ifstream file(filename, std::ios::binary);\n  if (!file) {\n    std::cerr << \"Cannot open file: \" << filename << std::endl;\n    return false;\n  }\n  std::vector<char> buffer((std::istreambuf_iterator<char>(file)),\n                           (std::istreambuf_iterator<char>()));\n  file.close();\n  return Load(buffer);\n}\n", "CodeBleu_score": 54.51428886916455}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> guard(mutex);\n\tauto walkerIt = walkerMap.find(id);\n\tauto vehicleIt = vehicleMap.find(id);\n\tif (walkerIt != walkerMap.end()) {\n\t\tauto agent = crowd->getAgent(walkerIt->second);\n\t\tif (agent != nullptr) {\n\t\t\tcrowd->removeAgent(agent);\n\t\t}\n\t\twalkerMap.erase(walkerIt);\n\t\twalkerManager.RemoveAgent(id);\n\t\treturn true;\n\t}\n\telse if (vehicleIt != vehicleMap.end()) {\n\t\tauto agent = crowd->getAgent(vehicleIt->second);\n\t\tif (agent != nullptr) {\n\t\t\tcrowd->removeAgent(agent);\n\t\t}\n\t\tvehicleMap.erase(vehicleIt);\n\t\tvehicleManager.RemoveAgent(id);\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 56.191489777113404}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (walkerManager != nullptr) {\n\t\tif (walkerManager->RemoveAgent(id)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (vehicleManager != nullptr) {\n\t\tif (vehicleManager->RemoveAgent(id)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 26.70993616104881}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!IsReady()) return false;\n\tif (crowd == nullptr) return false;\n\tif (walker_mapping.find(id) != walker_mapping.end()) {\n\t\tstd::lock_guard<std::mutex> guard(walker_mapping_mutex);\n\t\tif (crowd->removeAgent(walker_mapping[id])) {\n\t\t\twalker_mapping.erase(id);\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (vehicle_mapping.find(id) != vehicle_mapping.end()) {\n\t\tstd::lock_guard<std::mutex> guard(vehicle_mapping_mutex);\n\t\tif (crowd->removeAgent(vehicle_mapping[id])) {\n\t\t\tvehicle_mapping.erase(id);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 43.89797425245884}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    std::set<int> currentVehicles;\n    for (auto it = this->vehicles.begin(); it != this->vehicles.end(); ++it) {\n        currentVehicles.insert(it->first);\n    }\n    for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n        if (currentVehicles.find(it->id) != currentVehicles.end()) {\n            this->vehicles[it->id].Update(it->position, it->velocity, it->acceleration, it->jerk, it->updated);\n        } else {\n            this->vehicles[it->id] = Vehicle(it->id, it->position, it->velocity, it->acceleration, it->jerk, it->updated);\n        }\n    }\n    for (auto it = currentVehicles.begin(); it != currentVehicles.end(); ++it) {\n        if (this->vehicles[*it].updated == false) {\n            this->vehicles.erase(*it);\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 47.57171091965835}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\t// Collect the IDs of currently mapped vehicles into a set.\n\tstd::set<int> ids;\n\tfor (auto it = m_vehicles.begin(); it != m_vehicles.end(); it++) {\n\t\tids.insert(it->first);\n\t}\n\n\t// Add or update vehicles from the provided list, marking them as updated.\n\tfor (auto it = vehicles.begin(); it != vehicles.end(); it++) {\n\t\tm_vehicles[it->id] = *it;\n\t\tm_vehicles[it->id].updated = true;\n\t}\n\n\t// Remove vehicles not marked as updated, indicating they do not exist in the current frame.\n\tfor (auto it = m_vehicles.begin(); it != m_vehicles.end();) {\n\t\tif (!it->second.updated) {\n\t\t\tit = m_vehicles.erase(it);\n\t\t}\n\t\telse {\n\t\t\tit++;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 45.85198817557536}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> ids;\n\tfor (auto& v : vehicles) {\n\t\tids.insert(v.id);\n\t\tif (v.updated) {\n\t\t\tif (v.id == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (m_vehicles.find(v.id) == m_vehicles.end()) {\n\t\t\t\tm_vehicles.insert(std::pair<int, Vehicle>(v.id, Vehicle()));\n\t\t\t}\n\t\t\tm_vehicles[v.id].Update(v);\n\t\t}\n\t\telse {\n\t\t\tif (v.id != -1) {\n\t\t\t\tm_vehicles.erase(v.id);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto& v : m_vehicles) {\n\t\tif (ids.find(v.first) == ids.end()) {\n\t\t\tm_vehicles.erase(v.first);\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 50.140883813909895}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  if (id == 0) {\n    return false;\n  }\n  auto it = walkers.find(id);\n  if (it != walkers.end()) {\n    return false;\n  }\n  it = vehicles.find(id);\n  if (it != vehicles.end()) {\n    return false;\n  }\n  return HasVehicleNear(id, distance, direction);\n}\n", "CodeBleu_score": 43.40571830217325}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  if (id == 0) {\n    return false;\n  }\n\n  // Search for the actor in the walkers and vehicles.\n  auto it = std::find_if(walkers.begin(), walkers.end(), [&id](const Walker& w) { return w.id == id; });\n  if (it != walkers.end()) {\n    return HasVehicleNear(*it, distance, direction);\n  }\n\n  it = std::find_if(vehicles.begin(), vehicles.end(), [&id](const Vehicle& v) { return v.id == id; });\n  if (it != vehicles.end()) {\n    return HasVehicleNear(*it, distance, direction);\n  }\n\n  return false;\n}\n", "CodeBleu_score": 48.91929034136974}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  std::lock_guard<std::mutex> lock(this->mutex);\n  auto it = this->actors.find(id);\n  if (it != this->actors.end()) {\n    auto vehicle = it->second;\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Any) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Bus) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Trailer) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Taxi) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Truck) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Train) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Emergency) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Motorcycle) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::MonsterTruck) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Service) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Car) {\n      return false;\n    }\n    if (vehicle->GetVehicleType() == carla::rpc::VehicleType::Bicycle) {\n      return false;\n", "CodeBleu_score": 28.67643470823718}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)  // TODO:\n  // 1. Retrieve the current route point\n  // 2. Create a WalkerEventVisitor with the current context\n  // 3. Use it to process the event at the current route point using boost::variant2::visit\n  // 4. Return the result of the event execution\n  return EventResult::Success;\n}\n", "CodeBleu_score": 9.989416055911729}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)    WalkerEventVisitor visitor(id, info, delta);\n    auto &route_point = info.route_points[info.current_route_point];\n    return boost::apply_visitor(visitor, route_point.event);\n}\n", "CodeBleu_score": 46.326410211670236}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)  WalkerEventVisitor visitor(delta, *this, id);\n  return boost::apply_visitor(visitor, info.route[info.current_route_point].event);\n}\n", "CodeBleu_score": 50.05487694234474}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"roads\").children(\"road\")) {\n\n    // Extract the road ID\n    std::string road_id = road_node.attribute(\"id\").value();\n\n    // Iterate through each lane section node\n    for (pugi::xml_node lane_section_node : road_node.children(\"laneSection\")) {\n\n      // Extract the lane section ID\n      std::string lane_section_id = lane_section_node.attribute(\"id\").value();\n\n      // Iterate through each lane node\n      for (pugi::xml_node lane_node : lane_section_node.children(\"lane\")) {\n\n        // Extract the lane ID\n        std::string lane_id = lane_node.attribute(\"id\").value();\n\n        // Iterate through each lane marking node\n        for (pugi::xml_node lane_marking_node : lane_node.children(\"laneMarking\")) {\n\n          // Extract the lane marking type\n          std::string lane_marking_type = lane_marking_node.attribute(\"type\").value();\n\n          // Iterate through each lane marking element node\n          for (pugi::xml_node lane_marking_element_node : lane_marking_node.children(\"laneMarkingElement\")) {\n\n            // Extract the lane marking element type\n            std::string lane_marking_element_type = lane_marking_element_node.attribute(\"type\").value();\n\n            // Extract the lane marking element position\n            double lane_marking_element_position = std::stod(lane_marking_element_node.attribute(\"position\").value());\n\n            // Extract the lane marking element width\n            double lane_marking_element_width = std::stod(lane_marking_element_node.attribute(\"width\").value());\n\n            // Extract the lane marking element color\n            std::string lane_marking_element_color = lane_mark", "CodeBleu_score": 42.7016400914289}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"roads\").children(\"road\")) {\n    // Extract the road ID\n    auto road_id = road_node.attribute(\"id\").as_uint();\n\n    // Iterate through each lane section node\n    for (pugi::xml_node lane_section_node : road_node.children(\"laneSection\")) {\n      // Extract the lane section ID\n      auto lane_section_id = lane_section_node.attribute(\"id\").as_uint();\n\n      // Iterate through each lane node\n      for (pugi::xml_node lane_node : lane_section_node.children(\"lane\")) {\n        // Extract the lane ID\n        auto lane_id = lane_node.attribute(\"id\").as_uint();\n\n        // Extract the lane type\n        auto lane_type = lane_node.attribute(\"type\").as_string();\n\n        // Extract the lane width\n        auto lane_width = lane_node.attribute(\"width\").as_double();\n\n        // Extract the lane speed limit\n        auto lane_speed_limit = lane_node.attribute(\"speedLimit\").as_double();\n\n        // Extract the lane left nodes\n        auto left_nodes = lane_node.child(\"left\");\n\n        // Extract the lane center nodes\n        auto center_nodes = lane_node.child(\"center\");\n\n        // Extract the lane right nodes\n        auto right_nodes = lane_node.child(\"right\");\n\n        // Parse the left lane\n        ParseLanes(\n            left_nodes,\n            lane_id,\n            lane_type,\n            lane_width,\n            lane_speed_limit,\n            map_builder);\n\n        // Parse the center lane\n        ParseLanes(\n            center_nodes,\n            lane_id,\n            lane_type,\n            lane_width,\n            lane_speed_limit,\n            map_builder);\n\n        // Parse the right lane\n        ParseL", "CodeBleu_score": 55.2598841303908}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"roads\").children(\"road\")) {\n    // Extract the road ID\n    auto road_id = road_node.attribute(\"id\").as_uint();\n\n    // Iterate through each lane section node\n    for (pugi::xml_node lane_section_node : road_node.children(\"laneSection\")) {\n      // Extract the lane section ID\n      auto lane_section_id = lane_section_node.attribute(\"id\").as_uint();\n\n      // Iterate through each lane node\n      for (pugi::xml_node lane_node : lane_section_node.children(\"lane\")) {\n        // Extract the lane ID\n        auto lane_id = lane_node.attribute(\"id\").as_uint();\n\n        // Parse the lane node\n        ParseLanes(lane_node, map_builder, road_id, lane_section_id, lane_id);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 41.292443570857984}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    if (info.current_count_change == 1) {\n        if (info.total_count == 1) {\n            // first connection\n            first_connection_ = true;\n        }\n        matched_count_ += info.current_count_change;\n    } else if (info.current_count_change == -1) {\n        matched_count_ += info.current_count_change;\n    } else {\n        std::cout << \"Invalid count change: \" << info.current_count_change << std::endl;\n    }\n}\n", "CodeBleu_score": 69.23698821092783}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)  if (info.current_count_change == 1) {\n    if (info.total_count == 0) {\n      // This should never happen.\n      std::cout << \"Error: Publication count is 0.\" << std::endl;\n    } else if (info.total_count == 1) {\n      // This is the first connection.\n      std::cout << \"CarlaListenerImpl: First connection.\" << std::endl;\n      matched_count_ = 1;\n      first_connection_ = true;\n    } else {\n      // This is an additional connection.\n      std::cout << \"CarlaListenerImpl: Additional connection.\" << std::endl;\n      matched_count_++;\n    }\n  } else if (info.current_count_change == -1) {\n    // This is a lost connection.\n    std::cout << \"CarlaListenerImpl: Lost connection.\" << std::endl;\n    matched_count_--;\n  } else {\n    // This is an invalid count change.\n    std::cout << \"CarlaListenerImpl: Invalid count change.\" << std::endl;\n  }\n}\n", "CodeBleu_score": 55.91716401148297}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)  if (info.current_count_change == 1) {\n    if (info.total_count == 0) {\n      // this is the first connection, so we set the matched count to 1\n      matched_count_ = 1;\n      first_connection_ = true;\n    } else {\n      // this is a new match, so we update the matched count\n      matched_count_++;\n    }\n  } else if (info.current_count_change == -1) {\n    // this is a lost match, so we update the matched count\n    matched_count_--;\n  } else {\n    // this is an invalid count change, so we log an error message\n    std::stringstream ss;\n    ss << \"Invalid publication count change: \" << info.current_count_change;\n    error_msg_ = ss.str();\n    RCLCPP_ERROR(get_logger(), error_msg_.c_str());\n  }\n}\n", "CodeBleu_score": 59.6963647176754}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        if (info.last_publication_handle == cdr::dds::core::null) {\n            first_connected = true;\n        }\n        matched++;\n    } else if (info.current_count_change == -1) {\n        matched--;\n        if (matched == 0) {\n            delete this;\n        }\n    } else {\n        std::cerr << \"Error: CarlaSubscriberListenerImpl::on_subscription_matched: invalid change count \" << info.current_count_change << std::endl;\n    }\n}\n", "CodeBleu_score": 63.03809344007107}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        if (info.current_count == 1) {\n            std::cout << \"Subscriber matched.\" << std::endl;\n            first_connected = true;\n        } else {\n            std::cout << \"Subscriber matched \" << info.current_count << \" times.\" << std::endl;\n        }\n    } else if (info.current_count_change == -1) {\n        if (info.current_count == 0) {\n            std::cout << \"Subscriber unmatched.\" << std::endl;\n            if (--matched_count == 0) {\n                std::cout << \"No more subscribers. Deleting subscriber.\" << std::endl;\n                delete this;\n            }\n        } else {\n            std::cout << \"Subscriber unmatched \" << info.current_count << \" times.\" << std::endl;\n        }\n    } else {\n        std::cout << \"Invalid count change \" << info.current_count_change << \".\" << std::endl;\n    }\n}\n", "CodeBleu_score": 56.68313033086132}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)  if (info.current_count_change == 1) {\n    std::cout << \"Subscription matched.\" << std::endl;\n    this->matched_count++;\n    if (this->matched_count == 1) {\n      this->first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    std::cout << \"Subscription unmatched.\" << std::endl;\n    this->matched_count--;\n    if (this->matched_count == 0) {\n      this->first_connected = false;\n    }\n  } else {\n    std::cout << \"Invalid subscription change count.\" << std::endl;\n  }\n}\n", "CodeBleu_score": 51.34472839840624}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    uint32_t md5 = 0;\n    const char* key = NULL;\n    key = p_type->collision_event.collision_event_id.c_str();\n    size_t key_len = strlen(key) + 1;\n    if (force_md5) {\n        md5 = md5sum(key, key_len);\n    }\n    handle->value[0] = md5;\n    memcpy(&handle->value[1], key, key_len);\n    return true;\n}\n", "CodeBleu_score": 31.54071655750274}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    if (!p_type) {\n        return false;\n    }\n    if (p_type->getKey(handle, force_md5)) {\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 16.94503629839115}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if (!m_get_key) {\n        return false;\n    }\n    CarlaCollisionEvent* p = (CarlaCollisionEvent*)data;\n    m_get_key(p, handle, force_md5);\n    return true;\n}\n", "CodeBleu_score": 14.879356763404166}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)\n    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness(); // Set endianness\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        p_type->serialize(ser); // Serialize the object:\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\n        return false;\n    }\n\n    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}\n", "CodeBleu_score": 68.46266094775889}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness();\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        p_type->serialize(ser); // Serialize the object:\n    } catch (std::exception& e) {\n        std::cout << \"Exception: \" << e.what() << std::endl;\n        return false;\n    }\n\n    payload->length = (uint32_t)ser.getSerializedDataLength(); // Get the serialized length\n    return true;\n}\n", "CodeBleu_score": 65.39829381207183}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness(); // Set encapsulation.\n    try {\n        p_type->serialize(ser); // Serialize the object.\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n    payload->length = (uint32_t)ser.getSerializedDataLength(); // Get the serialized length.\n    return true;\n}\n", "CodeBleu_score": 67.08518348537343}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    if (target_set) {\n        return;\n    }\n\n    if (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n        return;\n    }\n\n    mavlink_heartbeat_t hb;\n    mavlink_msg_heartbeat_decode(&msg, &hb);\n\n    if (hb.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    if (hb.autopilot != MAV_AUTOPILOT_INVALID) {\n        return;\n    }\n\n    if (hb.base_mode & MAV_MODE_FLAG_CUSTOM_MODE_ENABLED) {\n        return;\n    }\n\n    target_sysid = hb.sysid;\n\n    if (!target_sysid) {\n        return;\n    }\n\n    request_streams();\n\n    target_set = true;\n}\n", "CodeBleu_score": 43.77031440788592}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    // Check if the target is already set\n    if (target_set) {\n        return;\n    }\n\n    // Check the message type\n    switch (msg.msgid) {\n    case MAVLINK_MSG_ID_HEARTBEAT:\n    case MAVLINK_MSG_ID_SYS_STATUS:\n    case MAVLINK_MSG_ID_SYSTEM_TIME:\n    case MAVLINK_MSG_ID_SYSTEM_TIME_CORRECTION:\n    case MAVLINK_MSG_ID_GPS_RAW_INT:\n    case MAVLINK_MSG_ID_GPS_STATUS_REPORT:\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n    case MAVLINK_MSG_ID_ALTITUDE:\n    case MAVLINK_MSG_ID_ATTITUDE:\n    case MAVLINK_MSG_ID_ATTITUDE_QUATERNION:\n    case MAVLINK_MSG_ID_ATTITUDE_TARGET:\n    case MAVLINK_MSG_ID_EXTENDED_SYS_STATE:\n    case MAVLINK_MSG_ID_EXTENDED_STATES:\n    case MAVLINK_MSG_ID_HIL_SENSOR:\n    case MAVLINK_MSG_ID_HIL_STATE_QUATERNION:\n    case MAVLINK_MSG_ID_HIL_STATE_VELOCITY_NED:\n    case MAVLINK_MSG_ID_HIL_CONTROLS:\n    case MAVLINK_MSG_ID_HIL_ACTUATOR_CONTROLS:\n    case MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW:\n    case MAVLINK_MSG_ID_HIL_OPTICAL_FLOW:\n    case MAVLINK_MSG_ID_HIL_STATE_INTEGRATOR_QUATERNION:\n    case", "CodeBleu_score": 16.501065739890308}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_SYS_STATUS:\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\tcase MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n\tcase MAVLINK_MSG_ID_ALTITUDE:\n\tcase MAVLINK_MSG_ID_HIGHRES_IMU:\n\tcase MAVLINK_MSG_ID_EXTENDED_SYS_STATE:\n\tcase MAVLINK_MSG_ID_SYSTEM_TIME:\n\tcase MAVLINK_MSG_ID_PING:\n\tcase MAVLINK_MSG_ID_RC_CHANNELS_RAW:\n\tcase MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:\n\tcase MAVLINK_MSG_ID_RADIO_STATUS:\n\tcase MAVLINK_MSG_ID_BATTERY_STATUS:\n\tcase MAVLINK_MSG_ID_RADIO_CONTROL:\n\tcase MAVLINK_MSG_ID_REQUEST_DATA_STREAM:\n\tcase MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE:\n\tcase MAVLINK_MSG_ID_PARAM_REQUEST_READ:\n\tcase MAVLINK_MSG_ID_PARAM_REQUEST_LIST:\n\tcase MAVLINK_MSG_ID_PARAM_VALUE:\n\tcase MAVLINK_MSG_ID_PARAM_SET:\n\tcase MAVLINK_MSG_ID_PARAM_EXT_ACK:\n\tcase MAVLINK_MSG_ID_MISSION_REQUEST_LIST:\n\tcase MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST:\n\tcase MAVLINK_MSG_ID_MISSION", "CodeBleu_score": 11.568525826545198}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 68.3167231949276}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 68.3167231949276}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = _handle_command_preflight_calibration(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _altitude_calibration_required = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 50.86277163002645}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (packet.param1 == 1.0) {\n        result = MAV_RESULT_ACCEPTED;\n        for (int i = 0; i < _servo_count; i++) {\n            _servo_disarmed[i] = false;\n        }\n    } else if (packet.param1 == 0.0) {\n        result = MAV_RESULT_ACCEPTED;\n        for (int i = 0; i < _servo_count; i++) {\n            _servo_disarmed[i] = true;\n        }\n    }\n    return result;\n}\n", "CodeBleu_score": 47.86063239184131}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\n\t// Check if the command is supported\n\tif (packet.param1 != 0.0f && packet.param1 != 1.0f) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is accepted\n\tif (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n\n\t\t// Check if the command is accepted\n\t\tif (packet.param1 == 1.0f) {\n\t\t\t// Arm the servos\n\t\t\tarm_servos();\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\t// Disarm the servos\n\t\t\tdisarm_servos();\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t}\n\n\t// If the command is not supported\n\treturn MAV_RESULT_UNSUPPORTED;\n}\n", "CodeBleu_score": 56.601090463099155}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tuint8_t component_id = packet.target_component;\n\tuint8_t command_id = packet.command;\n\tfloat param1 = packet.param1;\n\tfloat param2 = packet.param2;\n\tfloat param3 = packet.param3;\n\tfloat param4 = packet.param4;\n\tfloat param5 = packet.param5;\n\tfloat param6 = packet.param6;\n\tfloat param7 = packet.param7;\n\tif (component_id == MAV_COMP_ID_ALL) {\n\t\t// TODO: implement\n\t} else {\n\t\tif (component_id == MAV_COMP_ID_SERVO1) {\n\t\t\tif (command_id == MAV_CMD_COMPONENT_ARM_DISARM) {\n\t\t\t\tif (param1 == 1.0) {\n\t\t\t\t\t// TODO: implement\n\t\t\t\t\tresult = MAV_RESULT_ACCEPTED;\n\t\t\t\t} else if (param1 == 0.0) {\n\t\t\t\t\t// TODO: implement\n\t\t\t\t\tresult = MAV_RESULT_ACCEPTED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 41.566815954495404}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    for (uint8_t i = 0; i < _gcs_channels_count; i++) {\n        if (_gcs_channels[i].payload_available()) {\n            _gcs_channels[i].send_request_datastream_position(sysid, compid);\n            return;\n        }\n    }\n}\n", "CodeBleu_score": 42.13554667808119}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)  // Iterate over the available GCS channels\n  for (uint8_t i = 0; i < _gcs_channels_available; i++) {\n    // Check if the channel is connected\n    if (_gcs_channels[i].connected) {\n      // Check if there is enough space in the payload buffer\n      if (_gcs_channels[i].payload_available() >= MAVLINK_MSG_ID_POSITION_TARGET_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n        // Send the request\n        _gcs_channels[i].mavlink_stream_send_position_target_global_int(sysid, compid);\n        break;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 47.53647683231482}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    // Iterate over the available GCS channels and check for available payload space\n    for (int i = 0; i < GCS_CHANNELS_MAX; i++) {\n        // If the channel is available, send a request to start the data stream on the corresponding channel\n        if (gcs_channels[i].available()) {\n            // Send a request to start the data stream on the corresponding channel with the specified update rate\n            gcs_channels[i].request_datastream_position(sysid, compid);\n            // Exit the loop\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 38.77060302377885}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)  AHRS* ahrs = get_ahrs();\n  float bf_pitch_cosine = ahrs->get_pitch_cosine();\n  if (bf_pitch_cosine != 0) {\n    float bf_pitch_sine = ahrs->get_pitch_sine();\n    float bf_yaw = ahrs->get_yaw();\n    ef_pitch = atan2(bf_pitch_sine, bf_pitch_cosine);\n    ef_yaw = bf_yaw - atan2(bf_pitch_cosine * sin(yaw), cos(yaw));\n    return true;\n  }\n  else {\n    return false;\n  }\n}\n", "CodeBleu_score": 45.82460600521774}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\n    // retrieve the AHRS instance\n    AHRS* ahrs = AHRS::instance();\n\n    // check for a zero pitch cosine to avoid division by zero\n    if (ahrs->pitch_cos == 0) {\n        return false;\n    }\n\n    // calculate the earth frame pitch and yaw using trigonometric conversions\n    ef_pitch = atan2(ahrs->pitch_sin, ahrs->pitch_cos) * 180 / M_PI;\n    ef_yaw = atan2(ahrs->yaw_sin, ahrs->yaw_cos) * 180 / M_PI;\n\n    // return true\n    return true;\n}\n", "CodeBleu_score": 43.3420859575923}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    AHRS* ahrs = AHRS::getInstance();\n    float cos_pitch = ahrs->get_cos_pitch();\n    if (cos_pitch == 0) {\n        return false;\n    }\n    ef_pitch = asin(cos_pitch * sin(pitch));\n    ef_yaw = yaw - atan2(cos_pitch * sin(yaw), cos(yaw));\n    return true;\n}\n", "CodeBleu_score": 48.67147311119875}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)    // Check if the direction is reversed\n    if (nav_status.direction_reversed) {\n        // The direction is reversed\n        // Set the direction reversed flag\n        direction_reversed = true;\n    } else {\n        // The direction is not reversed\n        // Reset the direction reversed flag\n        direction_reversed = false;\n    }\n\n    // Check if the target distance is valid\n    if (nav_status.target_distance_valid) {\n        // The target distance is valid\n        // Set the target distance valid flag\n        target_distance_valid = true;\n    } else {\n        // The target distance is not valid\n        // Reset the target distance valid flag\n        target_distance_valid = false;\n    }\n\n    // Check if the minimum distance is valid\n    if (nav_status.minimum_distance_valid) {\n        // The minimum distance is valid\n        // Set the minimum distance valid flag\n        minimum_distance_valid = true;\n    } else {\n        // The minimum distance is not valid\n        // Reset the minimum distance valid flag\n        minimum_distance_valid = false;\n    }\n\n    // Check if the target distance is valid or the minimum distance is not valid\n    if (target_distance_valid || !minimum_distance_valid) {\n        // The target distance is valid or the minimum distance is not valid\n        // Calculate the target yaw and pitch in centidegrees\n        target_yaw = (nav_status.target_yaw * 100.0f);\n        target_pitch = (nav_status.target_pitch * 100.0f);\n    } else {\n        // The target distance is not valid and the minimum distance is not valid\n        // Calculate the target yaw and pitch in centidegrees\n        target_yaw = (nav_status.minimum_yaw * 100.0f);\n        target_pitch = (nav_status.minimum_pitch * 100.0f);\n    }\n\n    // Check if the target yaw is valid\n    if (nav_status.target_yaw_valid) {\n        // The target", "CodeBleu_score": 32.48046336695242}, {"code": "void Mode::update_auto(void)  if (nav_status.valid_target) {\n    // Calculate the target yaw and pitch\n    if (nav_status.target_direction == 1) {\n      target_yaw = nav_status.target_bearing;\n    } else {\n      target_yaw = 36000 - nav_status.target_bearing;\n    }\n    target_pitch = nav_status.target_elevation;\n\n    // Check if the direction is reversed\n    if (nav_status.reversed) {\n      target_yaw = 36000 - target_yaw;\n    }\n\n    // Calculate the angle error\n    angle_error_yaw = target_yaw - nav_status.yaw;\n    angle_error_pitch = target_pitch - nav_status.pitch;\n\n    // Convert the errors to body frame\n    if (nav_status.yaw_rotation == 1) {\n      angle_error_yaw = 36000 - angle_error_yaw;\n    }\n    if (nav_status.pitch_rotation == 1) {\n      angle_error_pitch = 36000 - angle_error_pitch;\n    }\n\n    // If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly\n    if (nav_status.valid_target_distance || !nav_status.min_distance_set) {\n      // Update the pitch servo\n      if (nav_status.pitch_rotation == 0) {\n        if (nav_status.pitch_mode == 0) {\n          if (nav_status.pitch_angle_mode == 0) {\n            pitch_servo.write(map(angle_error_pitch, -10000, 10000, 1000, 2000));\n          } else {\n            pitch_servo.write(map(angle_error_pitch, -10000, 10000, 1000, 2000) + 100", "CodeBleu_score": 34.35153564161288}, {"code": "void Mode::update_auto(void)    if (nav.status == NAV_STATUS_NONE) {\n        return;\n    }\n\n    // Calculate target yaw and pitch\n    target_yaw = nav.yaw;\n    target_pitch = nav.pitch;\n\n    if (nav.status == NAV_STATUS_TARGET) {\n        // Reverse direction if necessary\n        if (nav.target_direction == NAV_TARGET_DIRECTION_REVERSE) {\n            target_yaw += 18000;\n            if (target_yaw > 36000) {\n                target_yaw -= 36000;\n            }\n        }\n\n        // Check if the target distance is valid\n        if (nav.target_distance_valid) {\n            // Calculate target distance\n            target_distance = nav.target_distance;\n        } else {\n            // Calculate target distance\n            target_distance = nav.distance;\n        }\n    }\n\n    // Calculate angle error\n    angle_error_yaw = target_yaw - yaw;\n    angle_error_pitch = target_pitch - pitch;\n\n    // Convert angle errors from earth frame to body frame\n    if (angle_error_yaw < -18000) {\n        angle_error_yaw += 36000;\n    } else if (angle_error_yaw > 18000) {\n        angle_error_yaw -= 36000;\n    }\n\n    if (angle_error_pitch < -18000) {\n        angle_error_pitch += 36000;\n    } else if (angle_error_pitch > 18000) {\n        angle_error_pitch -= 36000;\n    }\n\n    // Check if the target distance is valid or no minimum distance is set\n    if (nav.target_distance_valid || !nav.min_distance_valid) {\n        // Update pitch and yaw servos\n        update_servos();\n    }\n}\n", "CodeBleu_score": 31.91813437090918}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)  // Check if the GPS is connected\n  if (gps.charsProcessed() < 10) {\n    return;\n  }\n\n  // Check if the GPS is valid\n  if (gps.location.isValid() && gps.location.isValid() && gps.location.isValid()) {\n    // Update the GPS data\n    gps_lat = gps.location.lat();\n    gps_long = gps.location.lng();\n    gps_alt = gps.altitude.meters();\n    gps_speed = gps.speed.kmph();\n    gps_course = gps.course.deg();\n    gps_satellites = gps.satellites.value();\n    gps_status = gps.status();\n  }\n  else {\n    gps_lat = 0;\n    gps_long = 0;\n    gps_alt = 0;\n    gps_speed = 0;\n    gps_course = 0;\n    gps_satellites = 0;\n    gps_status = 0;\n  }\n\n  // Check if the GPS status is at least 3D fix\n  if (gps_status >= 3) {\n    // Check if the last message time has changed\n    if (last_gps_message != gps.lastNMEAMessage()) {\n      // Reset the countdown\n      ground_start_countdown = 10;\n    }\n    // Update the last message time\n    last_gps_message = gps.lastNMEAMessage();\n  }\n  else {\n    // Reset the countdown\n    ground_start_countdown = 10;\n  }\n\n  // Check if the countdown has reached one\n  if (ground_start_countdown == 1) {\n    // Check if the GPS is valid\n    if (gps.location.isValid() && gps.location.isValid() && gps.location.isValid()) {\n      // Set the home location\n      home_lat = gps_lat;\n      home_long = gps_long", "CodeBleu_score": 44.0983289957649}, {"code": "void Tracker::update_GPS(void)  // If the GPS status is at least 3D fix\n  if (gps.status >= 3) {\n    // If the last message time has changed\n    if (gps.last_message_time != gps.last_message_time_prev) {\n      // If the countdown is greater than zero, decrement it\n      if (ground_start_countdown > 0) {\n        ground_start_countdown--;\n      }\n      // If the countdown is zero or less, set the home location if the current location is valid\n      else if (ground_start_countdown <= 0) {\n        // If the current location is valid, set the home location\n        if (gps.location.isValid()) {\n          home_lat = gps.location.lat();\n          home_lon = gps.location.lng();\n          home_alt = gps.altitude;\n          ground_start_countdown = GROUND_START_COUNTDOWN_MAX;\n        }\n        // If the current location is invalid, reset the countdown\n        else {\n          ground_start_countdown = GROUND_START_COUNTDOWN_MAX;\n        }\n      }\n    }\n  }\n  // If the GPS status is less than 3D fix\n  else {\n    // Reset the countdown\n    ground_start_countdown = GROUND_START_COUNTDOWN_MAX;\n  }\n  // Update the last message time\n  gps.last_message_time_prev = gps.last_message_time;\n}\n", "CodeBleu_score": 43.57652342747139}, {"code": "void Tracker::update_GPS(void)  // If the GPS is not yet initialized, initialize it.\n  if (gps_status == 0) {\n    // If the GPS is not yet initialized, initialize it.\n    if (gps.charsProcessed() < 10) {\n      // If the GPS is not yet initialized, initialize it.\n      gps_status = 0;\n    }\n    // If the GPS is initialized, check if the GPS status is at least 3D fix.\n    else {\n      // If the GPS is initialized, check if the GPS status is at least 3D fix.\n      if (gps.location.isValid() && gps.location.isUpdated()) {\n        // If the GPS is initialized, check if the GPS status is at least 3D fix.\n        gps_status = 1;\n        // If the GPS is initialized, check if the GPS status is at least 3D fix.\n        gps_lat = gps.location.lat();\n        gps_lon = gps.location.lng();\n        gps_alt = gps.altitude.meters();\n        gps_time = gps.dateTime;\n        gps_speed = gps.speed.kmph();\n        gps_course = gps.course.deg();\n        gps_hdop = gps.hdop.value();\n        gps_vdop = gps.vdop.value();\n        gps_pdop = gps.pdop.value();\n        gps_satellites = gps.satellites.value();\n      }\n      // If the GPS is initialized, check if the GPS status is at least 3D fix.\n      else {\n        // If the GPS is initialized, check if the GPS status is at least 3D fix.\n        gps_status = 0;\n      }\n    }\n  }\n  // If the GPS is initialized, check if the GPS status is at least 3D fix.\n  else {\n    // If the GPS is initialized, check if the GPS status is at least 3D fix.\n    if (gps.location.isValid", "CodeBleu_score": 37.171878963881674}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    // pitch on/off servo\n    if (pitch < 0.5) {\n        pitch_onoff_servo.write(90);\n    } else {\n        pitch_onoff_servo.write(0);\n    }\n}\n", "CodeBleu_score": 13.864276189470498}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    //if(pitch_onoff_servo_enabled) {\n        //pitch_onoff_servo.write(pitch);\n    //}\n}\n", "CodeBleu_score": 4.6194308467785685}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    // pitch_onoff_servo_->write(pitch);\n    // pitch_onoff_servo_->attach(PITCH_ONOFF_SERVO_PIN);\n    // pitch_onoff_servo_->write(pitch);\n    // pitch_onoff_servo_->detach();\n}\n", "CodeBleu_score": 4.619460454754564}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    bool result = AP_Arming::barometer_checks(display_failure);\n    if (result) {\n        if (AP_Baro::barometer->get_reference_altitude() != 0 &&\n                fabs(AP_Baro::barometer->get_altitude() -\n                     AP_Baro::barometer->get_reference_altitude()) >\n                AP_ARMING_BARO_REF_ALT_MAX_DISPARITY) {\n            if (display_failure) {\n                AP_Notify::flags.baro_ref_alt_disparity = true;\n            }\n            result = false;\n        }\n    }\n    return result;\n}\n", "CodeBleu_score": 35.066131695650995}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    bool ret = AP_Arming::barometer_checks(display_failure);\n", "CodeBleu_score": 9.4715980333225}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    // call base class's barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if we are using a barometer, check the barometer\n    if (_barometer.enabled()) {\n        // get barometer altitude\n        float baro_alt = _barometer.get_altitude();\n        // get inertial nav altitude\n        float inertial_alt = _ahrs.get_altitude();\n        // get barometer reference altitude\n        float baro_ref_alt = _barometer.get_reference_altitude();\n        // get barometer reference altitude\n        float baro_ref_alt_diff = baro_ref_alt - inertial_alt;\n        // get barometer altitude\n        float baro_alt_diff = baro_alt - inertial_alt;\n        // check barometer altitude\n        if (abs(baro_alt_diff) > _baro_alt_diff_limit) {\n            // log failure\n            if (display_failure) {\n                _arming_check_failures |= ARMING_CHECK_BARO;\n                AP_Notify::notify(AP_NOTIFY_WARNING, AP_ARMING_C_NAME, AP_ARMING_C_BARO_ALT_FAIL);\n            }\n            return false;\n        }\n        // check barometer reference altitude\n        if (abs(baro_ref_alt_diff) > _baro_ref_alt_diff_limit) {\n            // log failure\n            if (display_failure) {\n                _arming_check_failures |= ARMING_CHECK_BARO;\n                AP_Notify::notify(AP_NOTIFY_WARNING, AP_ARMING_C_NAME, AP_ARMING_C_BARO_REF_ALT_FAIL);\n            }\n            return false;\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 47.79234583347126}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const    return AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 19.606385152707517}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    if (g.get_terrain_source() == TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (g.get_terrain_source() == TERRAIN_SOURCE_TERRAIN_DB && g.get_rtl_altitude_type() == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 62.904617796569475}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    return (\n        AP_Arming::terrain_database_required() &&\n        (\n            (terrain_source == TS_TERRAIN_DATABASE) &&\n            (rtl_alt_type == RTL_ALT_TERRAIN)\n        )\n    );\n}\n", "CodeBleu_score": 24.64427553415762}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()    // get loop time\n    uint32_t now = hal.scheduler->micros();\n    uint32_t dt = now - _last_loop_time;\n    _last_loop_time = now;\n\n    // update rate controller timers\n    attitude_control.rate_controller_update(dt);\n    position_control.rate_controller_update(dt);\n    attitude_control.update_mc_rate_controller(dt);\n\n    // run the rate controllers\n    attitude_control.rate_controller_execute(dt);\n    position_control.rate_controller_execute(dt);\n\n    // run the motor controller\n    if (control_mode == MANUAL) {\n        attitude_control.manual_control_execute();\n    } else if (control_mode == ACRO) {\n        attitude_control.acro_control_execute();\n    } else if (control_mode == AUTO) {\n        attitude_control.auto_control_execute();\n    } else if (control_mode == RATES) {\n        attitude_control.rates_control_execute();\n    } else if (control_mode == ALTITUDE) {\n        attitude_control.altitude_control_execute();\n    } else if (control_mode == POSITION) {\n        attitude_control.position_control_execute();\n    } else if (control_mode == MOTORS) {\n        attitude_control.motors_test_execute();\n    } else if (control_mode == STABILIZE) {\n        attitude_control.stabilize_control_execute();\n    } else if (control_mode == TRAINING) {\n        attitude_control.training_control_execute();\n    } else if (control_mode == FLY_BY_WIRE_A) {\n        attitude_control.fly_by_wire_a_execute();\n    } else if (control_mode == FLY_BY_WIRE_B) {\n        attitude_control.fly_by_wire_b_execute();\n    } else if (control_mode == AUTOTUNE) {\n        attitude_control.autotune_execute();\n    } else if (control_mode == AUT", "CodeBleu_score": 40.015789743623486}, {"code": "void Copter::run_rate_controller()\n    /*\n     * This function, Copter::run_attitude_controller, runs the attitude controller.\n     */\n    run_attitude_controller();\n\n    /*\n     * This function, Copter::run_position_controller, runs the position controller.\n     */\n    run_position_controller();\n\n    /*\n     * This function, Copter::run_altitude_controller, runs the altitude controller.\n     */\n    run_altitude_controller();\n\n    /*\n     * This function, Copter::run_mc_rate_controller, runs the multicopter rate controller.\n     */\n    run_mc_rate_controller();\n\n    /*\n     * This function, Copter::run_mc_attitude_controller, runs the multicopter attitude controller.\n     */\n    run_mc_attitude_controller();\n\n    /*\n     * This function, Copter::run_fw_attitude_controller, runs the fixed wing attitude controller.\n     */\n    run_fw_attitude_controller();\n\n    /*\n     * This function, Copter::run_fw_position_controller, runs the fixed wing position controller.\n     */\n    run_fw_position_controller();\n\n    /*\n     * This function, Copter::run_mc_pos_control, runs the multicopter position controller.\n     */\n    run_mc_pos_control();\n\n    /*\n     * This function, Copter::run_fw_pos_control, runs the fixed wing position controller.\n     */\n    run_fw_pos_control();\n\n    /*\n     * This function, Copter::run_mc_alt_control, runs the multicopter altitude controller.\n     */\n    run_mc_alt_control();\n\n    /*\n     * This function, Copter::run_fw_alt_control, runs the fixed wing altitude controller.\n     */\n    run_fw_alt_control();\n\n    /*\n     * This function, Copter::run_mc_yaw_control, runs the multicopter yaw controller.\n     */\n    run_mc_yaw_control();\n\n    /*\n     * This function, Copter::run_fw_yaw_", "CodeBleu_score": 10.630505626046538}, {"code": "void Copter::run_rate_controller()\n\t// this is the time at which the controller should run\n\t// it is based on the system clock, which is based on the RTIMER\n\tuint32_t now = rtimer_arch_now();\n\n\t// we have a new attitude, so we can calculate the attitude rates\n\tif (attitude_updated) {\n\n\t\t// we have a new attitude, so we can calculate the attitude rates\n\t\t// we also have a new position, so we can calculate the position rates\n\t\tif (position_updated) {\n\n\t\t\t// we have a new attitude, so we can calculate the attitude rates\n\t\t\t// we also have a new position, so we can calculate the position rates\n\t\t\tif (velocity_updated) {\n\n\t\t\t\t// we have a new attitude, so we can calculate the attitude rates\n\t\t\t\t// we also have a new position, so we can calculate the position rates\n\t\t\t\t// we also have a new velocity, so we can calculate the velocity rates\n\t\t\t\tif (acceleration_updated) {\n\n\t\t\t\t\t// we have a new attitude, so we can calculate the attitude rates\n\t\t\t\t\t// we also have a new position, so we can calculate the position rates\n\t\t\t\t\t// we also have a new velocity, so we can calculate the velocity rates\n\t\t\t\t\t// we also have a new acceleration, so we can calculate the acceleration rates\n\t\t\t\t\tif (gyro_updated) {\n\n\t\t\t\t\t\t// we have a new attitude, so we can calculate the attitude rates\n\t\t\t\t\t\t// we also have a new position, so we can calculate the position rates\n\t\t\t\t\t\t// we also have a new velocity, so we can calculate the velocity rates\n\t\t\t\t\t\t// we also have a new acceleration, so we can calculate the acceleration rates\n\t\t\t\t\t\t// we also have a new gyro, so we can calculate the gyro rates\n\t\t\t\t\t\tif (mag_updated) {\n\n\t\t\t\t\t\t\t// we have a new attitude, so we can calculate the attitude rates\n\t\t\t\t\t\t\t// we also have a new position, so we", "CodeBleu_score": 7.305478846314362}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (new_loc.distance(old_loc) > 1.0f) {\n\t\t/* if the new waypoint is more than 1m away from the old waypoint, set it as the target */\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t_navigator->set_can_loiter_at_sp(false);\n\t\t", "CodeBleu_score": 33.64445328031276}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    if (old_loc.distance_to(new_loc) > 0.01f) {\n        return false;\n    }\n\n    if (old_loc.alt != new_loc.alt) {\n        return false;\n    }\n\n    set_target_location(new_loc);\n    return true;\n}\n", "CodeBleu_score": 49.79164995218341}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.alt == new_loc.alt && old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng) {\n\t\treturn false;\n\t}\n\n\ttarget_location = new_loc;\n\treturn true;\n}\n", "CodeBleu_score": 39.46056048624917}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (ch_flag == AuxSwitchPos::HIGH) {\n        set_mode(mode);\n    } else if (ch_flag == AuxSwitchPos::LOW && get_mode() == mode) {\n        rc().reset_mode_switch();\n    }\n}\n", "CodeBleu_score": 47.69904573002046}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)  // If the switch is in the HIGH position, set the mode\n  if (ch_flag == AuxSwitchPos::HIGH) {\n    // If the mode is valid, set it\n    if (mode >= Mode::MIN && mode <= Mode::MAX) {\n      set_mode(mode);\n    }\n    // If the mode is invalid, reset the mode switch\n    else {\n      rc().reset_mode_switch();\n    }\n  }\n  // If the switch is not in the HIGH position and the current mode matches the given mode, reset the mode switch\n  else if (ch_flag == AuxSwitchPos::LOW && get_mode() == mode) {\n    rc().reset_mode_switch();\n  }\n}\n", "CodeBleu_score": 57.93970815433842}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)  if (ch_flag == AuxSwitchPos::HIGH) {\n    set_mode(mode);\n  } else if (get_mode() == mode) {\n    reset_mode_switch();\n  }\n}\n", "CodeBleu_score": 35.65334329103259}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()    // roll trim\n    _trim_roll = (float)(_control_in.get_channel_rad(ROLL_AXIS) - _control_in.get_channel_rad(ROLL_AXIS_REV)) / 2;\n    // pitch trim\n    _trim_pitch = (float)(_control_in.get_channel_rad(PITCH_AXIS) - _control_in.get_channel_rad(PITCH_AXIS_REV)) / 2;\n\n    // save trim values\n    _ahrs.set_trim(_trim_roll, _trim_pitch);\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send confirmation message\n    _mavlink->send_statustext_critical();\n}\n", "CodeBleu_score": 45.85563086197581}, {"code": "void Copter::save_trim()\t// get the trim values\n\tfloat trim_roll = get_control_in( ROLL );\n\tfloat trim_pitch = get_control_in( PITCH );\n\n\t// convert to radians\n\ttrim_roll *= DEG_TO_RAD;\n\ttrim_pitch *= DEG_TO_RAD;\n\n\t// add to AHRS trim\n\tahrs.set_trim( trim_roll, trim_pitch );\n\n\t// log the event\n\tlog_trim();\n\n\t// send confirmation message\n\tsend_text_P(SEVERITY_INFO,PSTR(\"Trim saved\"));\n}\n", "CodeBleu_score": 44.80797775891997}, {"code": "void Copter::save_trim()\t// save trim values\n\ttrim_roll = (int16_t)(((float)ahrs.roll_sensor * 100.0f) + 0.5f);\n\ttrim_pitch = (int16_t)(((float)ahrs.pitch_sensor * 100.0f) + 0.5f);\n\n\t// log event\n\tlog_WriteEvent(SYSTEMEVENT_SAVE_TRIM, 0, 0, 0);\n\n\t// send confirmation message\n\tmavlink_log_info(mavlink_fd, \"[fc] Trim saved\");\n}\n", "CodeBleu_score": 25.03696455762882}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()  float look_ahead_yaw;\n  float speed_squared = _velocity.x * _velocity.x + _velocity.y * _velocity.y;\n  if (_position_valid && speed_squared > _min_speed_squared) {\n    look_ahead_yaw = atan2(_velocity.y, _velocity.x);\n  } else {\n    look_ahead_yaw = _yaw;\n  }\n  return look_ahead_yaw;\n}\n", "CodeBleu_score": 36.65333278352194}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\t// Retrieve the copter's velocity.\n\tVector3 velocity = _parent->get_velocity();\n\t// Calculate the speed squared.\n\tfloat speed_squared = velocity.length_squared();\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components.\n\tif (_parent->get_position().is_valid() && speed_squared > MINIMUM_SPEED_SQUARED) {\n\t\t// Update the look-ahead yaw angle using the arctangent of the velocity components.\n\t\t_look_ahead_yaw = atan2(velocity.y, velocity.x);\n\t}\n\t// Return the computed look-ahead yaw angle.\n\treturn _look_ahead_yaw;\n}\n", "CodeBleu_score": 48.52322507770419}, {"code": "float Mode::AutoYaw::look_ahead_yaw()  // Retrieve the copter's velocity\n  float vel_x = _state.velocity.x;\n  float vel_y = _state.velocity.y;\n\n  // Calculate the speed squared\n  float speed_sq = vel_x * vel_x + vel_y * vel_y;\n\n  // Check if the copter's position is valid and the speed exceeds a minimum threshold\n  if (is_valid_position() && speed_sq > MIN_SPEED_SQ) {\n    // Calculate the look-ahead yaw angle using the arctangent of the velocity components\n    float look_ahead_yaw = atan2(vel_y, vel_x);\n\n    // Update the look-ahead yaw angle\n    _look_ahead_yaw = look_ahead_yaw;\n  }\n\n  // Return the computed look-ahead yaw angle\n  return _look_ahead_yaw;\n}\n", "CodeBleu_score": 47.201373620616494}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::RUDDER) {\n        if (g.rudder_arming_disabled) {\n            return false;\n        }\n        if (throttle_control.get_control_in() != 0) {\n            return false;\n        }\n    }\n    if (g.watchdog_armed) {\n        return true;\n    }\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 50.21755518865804}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::RUDDER) {\n        if (armed_state.disabled) {\n            return true;\n        }\n        if (armed_state.watchdog_armed) {\n            return true;\n        }\n        if (_rudder_arming_disabled) {\n            return false;\n        }\n        if (_throttle_zero) {\n            return false;\n        }\n    }\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 51.620573462876315}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    bool ret = true;\n    if (method == AP_Arming::RUDDER) {\n        if (_disabled) {\n            ret = false;\n        } else {\n            if (throttle_control_in == 0) {\n                ret = false;\n            }\n        }\n    }\n    if (ret && !_watchdog_armed) {\n        ret = AP_Arming::arm_checks(method);\n    }\n    return ret;\n}\n", "CodeBleu_score": 40.07713067657582}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\tif (method == AP_ARMING_METHOD_ARMED) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming method\n\tif (method == AP_ARMING_METHOD_NONE) {\n\t\t// this should not happen\n\t\treturn false;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_ARMED) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_STANDBY) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_RECOVERING) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_IN_AIR) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_DISARMED) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_STANDBY_ERROR) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_ARMED_ERROR) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_ARMED_IN_ERROR) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check for a valid arming state\n\tif (_arming_state == AP_ARMING_STATE_RECOVERING", "CodeBleu_score": 30.828738926114873}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    if (in_air()) {\n        return false;\n    }\n\n    // check for throttle\n    if (!_throttle_armed) {\n        send_text_P(MAV_SEVERITY_CRITICAL,PSTR(\"Throttle not armed\"));\n        return false;\n    }\n\n    // check for gps lock\n    if (!_gps->status_gps_fixed_position() && !_gps->status_gps_fixed_home()) {\n        send_text_P(MAV_SEVERITY_CRITICAL,PSTR(\"GPS not locked\"));\n        return false;\n    }\n\n    // check for home position\n    if (!_gps->status_gps_fixed_home()) {\n        send_text_P(MAV_SEVERITY_CRITICAL,PSTR(\"Home not set\"));\n        return false;\n    }\n\n    // check for airspeed\n    if (_airspeed->enabled() && _airspeed->get_airspeed() < _airspeed->get_min_airspeed()) {\n        send_text_P(MAV_SEVERITY_CRITICAL,PSTR(\"Airspeed too low\"));\n        return false;\n    }\n\n    // check for battery voltage\n    if (_battery->voltage() < _battery->get_min_voltage()) {\n        send_text_P(MAV_SEVERITY_CRITICAL,PSTR(\"Battery voltage too low\"));\n        return false;\n    }\n\n    // check for battery current\n    if (_battery->current() < _battery->get_min_current()) {\n        send_text_P(MAV_SEVERITY_CRITICAL,PSTR(\"Battery current too low\"));\n        return false;\n    }\n\n    // check for battery capacity\n    if (_battery->capacity() < _battery->get_min_capacity()) {\n        send_text_P(MAV_SEVERITY_CRITICAL,PSTR(\"Battery capacity too low\"));\n        return false;\n    }\n\n    // check for battery voltage", "CodeBleu_score": 44.148426922675995}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    // check for arming checks\n    if (do_arming_checks) {\n        // check for GPS lock\n        if (!_ahrs->gps_position_available()) {\n            _arming_status_text = F(\"GPS LOCK\");\n            return false;\n        }\n\n        // check for home location\n        if (!_home.valid()) {\n            _arming_status_text = F(\"HOME LOC\");\n            return false;\n        }\n\n        // check for throttle low\n        if (_throttle_min_us > _throttle_analog_us) {\n            _arming_status_text = F(\"THROTTLE\");\n            return false;\n        }\n\n        // check for airspeed\n        if (_airspeed_check.enabled() && !_airspeed_check.check()) {\n            _arming_status_text = F(\"AIRSPEED\");\n            return false;\n        }\n\n        // check for airspeed\n        if (_airspeed_check.enabled() && !_airspeed_check.check()) {\n            _arming_status_text = F(\"AIRSPEED\");\n            return false;\n        }\n    }\n\n    // set arming state\n    _arming_state = AP_Arming::ARMED;\n\n    // set delay arming flag\n    _delay_arming_flag = true;\n\n    // update home location\n    _ahrs->set_home(_home);\n\n    // update current location\n    _ahrs->set_location(_home);\n\n    // send arming status text\n    _arming_status_text = F(\"THROTTLE ARMED\");\n\n    // return success\n    return true;\n}\n", "CodeBleu_score": 47.18316012029092}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\n    // if we are already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // if we are not armed, check if we have a disarm button\n    if (AP_Param::get(AP_PARAM_FENCE_DISARM_BUTTON) == 0) {\n        // no disarm button - display failure and return false\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Arming checks failed - no disarm button\\n\"));\n        }\n        return false;\n    }\n\n    // we have a disarm button, so call the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 64.13561019503082}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    if (_armed) {\n        return true;\n    }\n\n    if (!_disarm_btn_enabled) {\n        if (display_failure) {\n            _arm_failure_message = _arm_failure_message_no_disarm;\n            display_arm_failure();\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 64.0494450433866}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    if (armed()) {\n        return true;\n    }\n\n    if (disarm_button == DISARM_BUTTON_NONE) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Disarm button not configured\\n\"));\n        }\n        return false;\n    }\n\n    if (hal.util->get_soft_armed()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Disarm button pressed\\n\"));\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 57.949283410167226}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    float ne_x = x * cos(yaw) - y * sin(yaw);\n    float ne_y = x * sin(yaw) + y * cos(yaw);\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 56.006161570633026}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\n    // Rotation matrix\n    float rotation_matrix[3][3] = {\n        {cos(yaw), -sin(yaw), 0},\n        {sin(yaw), cos(yaw), 0},\n        {0, 0, 1}\n    };\n\n    // Rotate x and y\n    float ne_x = rotation_matrix[0][0] * x + rotation_matrix[0][1] * y;\n    float ne_y = rotation_matrix[1][0] * x + rotation_matrix[1][1] * y;\n\n    // Update x and y\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 47.67033609006574}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    float ne_x, ne_y;\n    ne_x = x * cos(yaw) - y * sin(yaw);\n    ne_y = x * sin(yaw) + y * cos(yaw);\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 54.70989369478214}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    MAV_RESULT result = MAV_RESULT_DENIED;\n    uint16_t condition_yaw_target_system = packet.target_system;\n    uint8_t condition_yaw_target_component = packet.target_component;\n    uint16_t condition_yaw_seq = packet.seq;\n    uint16_t condition_yaw_frame = packet.frame;\n    float condition_yaw_yaw_angle_deg = packet.param1;\n    float condition_yaw_yaw_rate_deg_s = packet.param2;\n    float condition_yaw_min_duration_s = packet.param3;\n    float condition_yaw_yaw_distance_deg = packet.param4;\n    uint8_t condition_yaw_condition_number = packet.param5;\n    uint8_t condition_yaw_target_system_id = packet.target_system;\n    uint8_t condition_yaw_target_component_id = packet.target_component;\n    uint8_t condition_yaw_seq_id = packet.seq;\n    uint8_t condition_yaw_frame_id = packet.frame;\n    uint8_t condition_yaw_condition_number_id = packet.param5;\n    uint8_t condition_yaw_target_system_id_id = packet.target_system;\n    uint8_t condition_yaw_target_component_id_id = packet.target_component;\n    uint8_t condition_yaw_seq_id_id = packet.seq;\n    uint8_t condition_yaw_frame_id_id = packet.frame;\n    uint8_t condition_yaw_condition_number_id_id = packet.param5;\n    uint8_t condition_yaw_yaw_angle_deg_id = packet.param1;\n    uint8_t condition_yaw_yaw_rate_deg_s_id = packet.param2;\n    uint8_t condition_yaw_min_duration_s_id = packet.param3;\n    uint8_t condition_yaw_yaw_distance", "CodeBleu_score": 37.75504178229952}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    MAV_RESULT result = MAV_RESULT_DENIED;\n    // Check if the command is valid\n    if (packet.param1 >= 0 && packet.param1 <= 360 && packet.param2 >= -180 && packet.param2 <= 180 && packet.param3 >= 0 && packet.param3 <= 360 && packet.param4 >= 0 && packet.param4 <= 1000) {\n        // Set the yaw heading\n        _yaw_heading = packet.param1;\n        _yaw_angle = packet.param2;\n        _yaw_rate = packet.param3;\n        _yaw_time = packet.param4;\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}\n", "CodeBleu_score": 51.085136428117416}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// The yaw angle is in degrees and param4 is the yaw speed.\n\t// The yaw speed is in degrees/second.\n\t// The yaw angle is relative to the current heading.\n\t// The yaw speed is relative to the current yaw speed.\n\t// The yaw angle and speed can be positive or negative.\n\t// The yaw angle and speed can be greater than 360.\n\t// The yaw angle and speed can be less than -360.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The yaw angle and speed can be greater than 180.\n\t// The yaw angle and speed can be less than -180.\n\t// The", "CodeBleu_score": 3.733162600597442}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n        return (uint8_t) (waypoint_bearing / 2);\n    } else {\n        return 0;\n    }\n}\n", "CodeBleu_score": 38.29383048509577}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    return _high_latency_tgt_heading;\n}\n", "CodeBleu_score": 5.8809906132134815}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn _high_latency_tgt_heading;\n}\n", "CodeBleu_score": 5.801350011259761}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (Log_Enabled) {\n\t\tLog_Packet p;\n\t\tp.id = id;\n\t\tp.value = value;\n\t\tp.time = HAL_GetTick();\n\t\tp.type = LOG_DATA_INT;\n\t\tHAL_SemaphoreTake(Log_Sem, 1000);\n\t\tLog_Queue.push(p);\n\t\tHAL_SemaphoreGive(Log_Sem);\n\t}\n}\n", "CodeBleu_score": 37.8261334654295}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (log_enabled) {\n\t\tLog_Packet packet;\n\t\tpacket.time = HAL_GetTick();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tpacket.size = sizeof(packet.time) + sizeof(packet.id) + sizeof(packet.value);\n\t\tpacket.type = LOG_TYPE_INT32;\n\t\tpacket.crc = Crc_Calc(packet.data, packet.size);\n\t\tHAL_CriticalBlock(enter_critical_1);\n\t\tHAL_UART_Transmit(&huart1, (uint8_t*)&packet, packet.size, 0xFFFF);\n\t\tHAL_CriticalBlock(exit_critical_1);\n\t}\n}\n", "CodeBleu_score": 39.92488356568058}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (log_enabled) {\n\t\tLogPacket packet = {\n\t\t\t.time = Get_Time_Microseconds(),\n\t\t\t.id = id,\n\t\t\t.value = value\n\t\t};\n\t\tLog_Write_Packet(&packet);\n\t}\n}\n", "CodeBleu_score": 31.18911234314965}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()\tif (home.is_set()) {\n\t\treturn;\n\t}\n\n\tif (armed.armed) {\n\t\thome.set(ekf.get_position());\n\t} else {\n\t\thome.set(ekf.get_position());\n\t}\n}\n", "CodeBleu_score": 22.756827208951705}, {"code": "void Sub::update_home_from_EKF()\tif (status.condition_home_position_valid) {\n\t\treturn;\n\t}\n\n\tif (status.condition_local_position_valid && status.condition_global_position_valid) {\n\t\t/* we have a position lock */\n\t\tif (!status.condition_home_position_valid) {\n\t\t\t/* set home to current position */\n\t\t\thome.setCurrentHomePosition();\n\t\t\tset_home_position();\n\t\t}\n\n\t} else if (status.condition_local_position_valid && !status.condition_global_position_valid) {\n\t\t/* we have a local position, but no global */\n\t\tif (!status.condition_home_position_valid) {\n\t\t\t/* set home to current position */\n\t\t\thome.setCurrentHomePosition();\n\t\t\tset_home_position();\n\t\t}\n\n\t} else if (status.condition_global_position_valid && !status.condition_local_position_valid) {\n\t\t/* we have a global position, but no local */\n\t\tif (!status.condition_home_position_valid) {\n\t\t\t/* set home to current position */\n\t\t\thome.setCurrentHomePosition();\n\t\t\tset_home_position();\n\t\t}\n\n\t} else if (!status.condition_local_position_valid && !status.condition_global_position_valid) {\n\t\t/* we have no position */\n\t\tif (!status.condition_home_position_valid) {\n\t\t\t/* set home to current position */\n\t\t\thome.setCurrentHomePosition();\n\t\t\tset_home_position();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 19.02711758788608}, {"code": "void Sub::update_home_from_EKF()  // if home is already set, exit immediately\n  if (home.is_set()) {\n    return;\n  }\n\n  // if motors are armed, set home to current location in-flight\n  if (armed.armed) {\n    home.set(local_pos.ref_lat, local_pos.ref_lon, local_pos.ref_alt);\n    return;\n  }\n\n  // if motors are not armed, set home to current EKF location\n  home.set(ekf.lat, ekf.lon, ekf.alt);\n}\n", "CodeBleu_score": 27.005949014831486}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()\t/*\n\t * If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\t */\n\tif (!motorsArmed) {\n\t\tthrottle = 0;\n\t\tspoolState = SPOOL_STATE_UNLIMITED_THROTTLE;\n\t\trelaxAttitudeControl();\n\t\treturn;\n\t}\n\n\t/*\n\t * If armed, set the spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run the attitude controller with these rates.\n\t */\n\tspoolState = SPOOL_STATE_UNLIMITED_THROTTLE;\n\tratesDesired = getRatesDesired();\n\trunAttitudeController();\n\n\t/*\n\t * Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\t */\n\tthrottle = pilotThrottle;\n\tsetMotorOutputs();\n}\n", "CodeBleu_score": 15.959360906923582}, {"code": "void ModeAcro::run()    if (!armed) {\n        throttle = 0;\n        spool.set_throttle(throttle);\n        relax_attitude_controllers();\n        return;\n    }\n\n    spool.set_throttle(throttle);\n    spool.set_unlimited_throttle();\n\n    if (pilot_input.get_mode() == PilotInput::Mode::ANGLE_BOOST) {\n        pilot_input.set_mode(PilotInput::Mode::ANGLE_BOOST_ACRO);\n    }\n\n    pilot_input.convert_to_body_rates();\n\n    attitude_controller.run(pilot_input.get_body_rates(), pilot_input.get_throttle());\n\n    motor_inputs.set_throttle(throttle);\n    motor_inputs.set_body_rates(attitude_controller.get_body_rates());\n    motor_inputs.set_forward_lateral_motor_inputs();\n}\n", "CodeBleu_score": 49.54517867063911}, {"code": "void ModeAcro::run()  if (!armed) {\n    // if not armed, set throttle to zero and relax attitude controller\n    throttle = 0;\n    attitude_control.relax_controller();\n  } else {\n    // if armed, set throttle to unlimited and run attitude controller\n    throttle = 1;\n    attitude_control.set_throttle_out_unstabilized(throttle);\n    attitude_control.run_direct_angle_acro(roll_control_input, pitch_control_input, yaw_control_input);\n  }\n\n  // set motor outputs\n  motor_outputs[0] = -motor_rates_0[0];\n  motor_outputs[1] = -motor_rates_0[1];\n  motor_outputs[2] = -motor_rates_0[2];\n  motor_outputs[3] = -motor_rates_0[3];\n\n  // set motor outputs\n  motor_outputs[0] = -motor_rates_0[0];\n  motor_outputs[1] = -motor_rates_0[1];\n  motor_outputs[2] = -motor_rates_0[2];\n  motor_outputs[3] = -motor_rates_0[3];\n\n  // set motor outputs\n  motor_outputs[0] = -motor_rates_0[0];\n  motor_outputs[1] = -motor_rates_0[1];\n  motor_outputs[2] = -motor_rates_0[2];\n  motor_outputs[3] = -motor_rates_0[3];\n\n  // set motor outputs\n  motor_outputs[0] = -motor_rates_0[0];\n  motor_outputs[1] = -motor_rates_0[1];\n  motor_outputs[2] = -motor_rates_0[2];\n  motor_outputs[3] = -motor_rates_0[3];\n\n  // set motor outputs\n  motor_outputs[0", "CodeBleu_score": 39.66057044102787}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()    // Check if we are in guided mode\n    if (_control_mode != MANUAL && _control_mode != ALTCTL) {\n        // If we are not, set the mode to guided\n        _control_mode = GUIDED;\n    }\n\n    // Set the current waypoint to the stopping point\n    _mission_type = MISSION_TYPE_NONE;\n    _mission_item.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    _mission_item.set_position(_pos_sp(0), _pos_sp(1));\n    _mission_item.set_velocity(0, 0);\n    _mission_item.set_yaw(0);\n    _mission_item.set_loiter_radius(0);\n    _mission_item.set_loiter_direction(0);\n    _mission_item.set_loiter_time(0);\n    _mission_item.set_pitch_min(0);\n    _mission_item.set_pitch_max(0);\n    _mission_item.set_autocontinue(false);\n    _mission_item.set_origin(0, 0);\n    _mission_item.set_mission_type(MISSION_TYPE_NONE);\n\n    // Set the current waypoint to the stopping point\n    _waypoint_position_reached = true;\n    _waypoint_velocity_accepted = true;\n    _waypoint_item_reached = true;\n    _waypoint_time_reached = true;\n    _waypoint_position_previous = _pos_sp;\n\n    // Set the current waypoint to the stopping point\n    _mission_item_previous.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    _mission_item_previous.set_position(_pos_sp(0), _pos", "CodeBleu_score": 27.801947377840165}, {"code": "void ModeGuided::guided_pos_control_start()\n\t/*\n\t * Initialize position control mode.\n\t */\n\t_control_mode.flag_control_position_enabled = true;\n\t_control_mode.flag_control_velocity_enabled = false;\n\t_control_mode.flag_control_climb_rate_enabled = false;\n\t_control_mode.flag_control_altitude_enabled = false;\n\t_control_mode.flag_control_termination_enabled = false;\n\n\t/*\n\t * Initialize the waypoint controller.\n\t */\n\t_waypoint_navigation.set_waypoint_position(_pos_sp_triplet.current.lat, _pos_sp_triplet.current.lon);\n\t_waypoint_navigation.set_waypoint_velocity(_pos_sp_triplet.current.vx, _pos_sp_triplet.current.vy);\n\t_waypoint_navigation.set_waypoint_yaw(_pos_sp_triplet.current.yaw, _pos_sp_triplet.current.yaw_valid);\n\n\t/*\n\t * Initialize the yaw controller.\n\t */\n\t_yaw_controller.set_yaw_target_to_current_heading();\n\n\t/*\n\t * Set the stopping point as the waypoint destination.\n\t */\n\t_waypoint_navigation.set_stop_position(_pos_sp_triplet.current.lat, _pos_sp_triplet.current.lon);\n\n\t/*\n\t * Set the default auto yaw mode.\n\t */\n\t_yaw_controller.set_auto_yaw_mode(_pos_sp_triplet.current.yaw_valid);\n\n\t/*\n\t * Set the default yaw rate.\n\t */\n\t_yaw_controller.set_yaw_rate(0.0f);\n\n\t/*\n\t * Set the default yaw offset.\n\t */\n\t_yaw_controller.set_yaw_offset(_pos_sp_triplet.current.yaw);\n\n\t/*\n\t * Set the default yaw speed.\n\t */\n\t_yaw_controller.set_yaw_speed(0.0", "CodeBleu_score": 35.845678110865535}, {"code": "void ModeGuided::guided_pos_control_start()    // initialize position controller states\n    _pos_sp_triplet.current.valid = false;\n    _pos_sp_triplet.previous.valid = false;\n    _pos_sp_triplet.next.valid = false;\n\n    // reset altitude controller state\n    _alt_sp = _pos_sp.alt;\n\n    // reset yaw controller state\n    _yaw_sp = NAN;\n\n    // reset altitude controller state\n    _alt_sp_prev = _pos_sp.alt;\n\n    // reset velocity controller state\n    _vel_sp_prev = _vel_sp;\n\n    // reset altitude controller state\n    _vel_sp_prev.z = _vel_sp.z;\n\n    // reset the altitude controller integral (i.e. force it to zero)\n    _thrust_int = 0.0f;\n\n    // reset the altitude controller integral (i.e. force it to zero)\n    _alt_int = 0.0f;\n\n    // reset the altitude controller integral (i.e. force it to zero)\n    _vel_int = 0.0f;\n\n    // reset the altitude controller integral (i.e. force it to zero)\n    _vel_int_z = 0.0f;\n\n    // reset the altitude controller integral (i.e. force it to zero)\n    _vel_int_xy = 0.0f;\n\n    // reset the altitude controller integral (i.e. force it to zero)\n    _vel_ff.x = 0.0f;\n    _vel_ff.y = 0.0f;\n    _vel_ff.z = 0.0f;\n\n    // reset the altitude controller integral (i.e. force it to zero)\n    _vel_ff_prev.x = 0.0f;\n    _vel_ff_prev.y = 0.0f;\n    _vel_ff_prev.z = 0.0f;\n\n    // reset the altitude controller integral (i.e. force it to zero)\n    _vel_ff_prev_z = ", "CodeBleu_score": 28.693941927569387}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()    // initialize vertical speed and acceleration\n    _speed_z_setpoint = _speed_z;\n    _acceleration_z_setpoint = _acceleration_z;\n\n    // initialize horizontal speed and acceleration\n    _speed_xy_setpoint = _speed_xy;\n    _acceleration_xy_setpoint = _acceleration_xy;\n\n    // initialize yaw control mode\n    _yaw_control_mode = YAW_AUTO_HOLD;\n\n    // initialize the vertical and horizontal velocity controllers\n    _vel_sp_prev.zero();\n    _vel_sp_prev.yaw = _yaw;\n\n    _vel_err_d.zero();\n    _vel_err_d.yaw = _yaw_rate;\n\n    _vel_err_prev.zero();\n    _vel_err_prev.yaw = _yaw_rate;\n\n    _vel_ff.zero();\n    _vel_ff.yaw = _yaw_rate;\n\n    _vel_sp.zero();\n    _vel_sp.yaw = _yaw_rate;\n\n    // set the yaw control mode to AUTO_HOLD\n    _yaw_control_mode = YAW_AUTO_HOLD;\n\n    // set the yaw setpoint to the current yaw\n    _yaw_sp = _yaw;\n\n    // set the yaw speed setpoint to zero\n    _yaw_sp_move_rate = 0.0f;\n}\n", "CodeBleu_score": 35.434089669115444}, {"code": "void ModeGuided::guided_vel_control_start()    // initialize vertical maximum speeds and acceleration\n    _vel_max_up.set(fabs(_param_mpc_z_vel_max_up.get()), 1.0f);\n    _vel_max_down.set(fabs(_param_mpc_z_vel_max_dn.get()), 1.0f);\n    _acceleration_z_max.set(fabs(_param_mpc_z_acc_max.get()), 1.0f);\n    _acceleration_z_min.set(fabs(_param_mpc_z_acc_min.get()), 1.0f);\n\n    // initialize vertical velocity controller\n    _vel_sp_prev.zero();\n    _vel_err_d_prev.zero();\n    _vel_int.resetIntegral();\n\n    // initialize horizontal velocity controller\n    _vel_sp_prev_hor.zero();\n    _vel_err_d_prev_hor.zero();\n    _vel_int_hor.resetIntegral();\n\n    // initialize yaw controller\n    _yaw_int.resetIntegral();\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    _yaw_control_mode = YAW_CTRL_AUTO_HOLD_FRONT_POINTING;\n\n    // set the current mode to GUIDED_VEL_CONTROL\n    _control_mode.flag_control_velocity_enabled = true;\n    _control_mode.flag_control_manual_enabled = false;\n    _control_mode.flag_control_auto_enabled = false;\n    _control_mode.flag_control_offboard_enabled = false;\n    _control_mode.flag_control_rates_enabled = false;\n    _control_mode.flag_control_climb_rate_enabled = false;\n    _control_mode.flag_control_altitude_enabled = false;\n    _control_mode.flag_control_position_enabled = false;\n    _control_mode.flag_control_termination_enabled = false;\n    _control_mode.flag_control_velocity_enabled = true;", "CodeBleu_score": 34.076384335425445}, {"code": "void ModeGuided::guided_vel_control_start()    // set the mode to guided\n    _control_mode.flag_control_velocity_enabled = true;\n    _control_mode.flag_control_manual_enabled = false;\n    _control_mode.flag_control_auto_enabled = false;\n    _control_mode.flag_control_rates_enabled = false;\n    _control_mode.flag_control_offboard_enabled = false;\n    _control_mode.flag_control_climb_rate_enabled = false;\n    _control_mode.flag_control_altitude_enabled = false;\n    _control_mode.flag_control_position_enabled = false;\n    _control_mode.flag_control_termination_enabled = false;\n\n    // reset the horizontal and vertical velocity controllers\n    _vel_control.reset();\n\n    // set the yaw control mode to AUTO_YAW_HOLD\n    _control_mode.flag_control_yaw_enabled = true;\n    _control_mode.yaw_ctrl_mode = YAW_CTRL_AUTO;\n\n    // set the maximum vertical speed\n    _vel_control.setVerticalMaxSpeed(_params.vel_max_up.get());\n\n    // set the maximum vertical acceleration\n    _vel_control.setVerticalAccelerationMax(_params.acc_max_up.get());\n\n    // set the maximum horizontal speed\n    _vel_control.setHorizontalMaxSpeed(_params.vel_max_xy.get());\n\n    // set the maximum horizontal acceleration\n    _vel_control.setHorizontalAccelerationMax(_params.acc_max_xy.get());\n\n    // set the maximum yaw rate\n    _vel_control.setYawMaxSpeed(_params.vel_max_yaw.get());\n\n    // set the maximum yaw acceleration\n    _vel_control.setYawAccelerationMax(_params.acc_max_yaw.get());\n\n    // set the minimum pitch\n    _vel_control.setPitchMin(_params.pitch_min.get());\n\n    // set the maximum pitch\n    _vel_control.setPitchMax(_params.pitch_max.get());\n\n    // set the", "CodeBleu_score": 44.174010117293996}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()  // Check if we are below the minimum altitude\n  if (_global_pos.alt < _min_alt) {\n    return true;\n  }\n\n  // Check if we are above the maximum altitude\n  if (_global_pos.alt > _max_alt) {\n    return true;\n  }\n\n  // Check if we have moved more than the specified horizontal distance\n  if (get_distance_to_next_waypoint() > _max_distance) {\n    return true;\n  }\n\n  // Check if we have exceeded the specified timeout\n  if (hrt_elapsed_time(&_time_first_pass) > _timeout) {\n    return true;\n  }\n\n  // Check if we are in a non-recoverable position\n  if (_non_recoverable_pos_flag) {\n    return true;\n  }\n\n  // If we get here, guided mode should not be terminated\n  return false;\n}\n", "CodeBleu_score": 26.23406337152471}, {"code": "bool ModeGuided::guided_limit_check()\n    if (failsafe.check(&mavlink_fd, &status, &failure_detector, &reasons, &failure_data, &mavlink_log_pub, &status_flags, &status_changed)) {\n        return true;\n    }\n\n    if (status.condition_landed) {\n        return true;\n    }\n\n    if (status.condition_landing_gear) {\n        return true;\n    }\n\n    if (status.condition_manual_control_lost) {\n        return true;\n    }\n\n    if (status.condition_auto_mission_available && status.condition_auto_mode_available) {\n        return true;\n    }\n\n    if (status.condition_system_sensors_initialized) {\n        return true;\n    }\n\n    if (status.condition_global_position_valid) {\n        return true;\n    }\n\n    if (status.condition_home_position_valid) {\n        return true;\n    }\n\n    if (status.condition_local_position_valid) {\n        return true;\n    }\n\n    if (status.condition_local_altitude_valid) {\n        return true;\n    }\n\n    if (status.condition_airspeed_valid) {\n        return true;\n    }\n\n    if (status.condition_power_input_valid) {\n        return true;\n    }\n\n    if (status.condition_battery_voltage_valid) {\n        return true;\n    }\n\n    if (status.condition_battery_current_valid) {\n        return true;\n    }\n\n    if (status.condition_battery_remaining_valid) {\n        return true;\n    }\n\n    if (status.condition_system_sensors_initialized) {\n        return true;\n    }\n\n    if (status.condition_engine_failure) {\n        return true;\n    }\n\n    if (status.condition_mission_failure) {\n        return true;\n    }\n\n    if (status.condition_gps_fix_3d) {\n        return", "CodeBleu_score": 34.259907267929954}, {"code": "bool ModeGuided::guided_limit_check()  // Check if we're still in guided mode\n  if (!_control_mode.flag_control_altitude_enabled || !_control_mode.flag_control_position_enabled) {\n    return false;\n  }\n\n  // Check if we have reached the maximum altitude\n  if (_global_pos.alt < -_param_lndmc_alt_max.get()) {\n    return true;\n  }\n\n  // Check if we have reached the minimum altitude\n  if (_global_pos.alt > _param_lndmc_alt_min.get()) {\n    return true;\n  }\n\n  // Check if we have moved beyond the maximum distance\n  if (_global_pos.distance > _param_lndmc_dist_max.get()) {\n    return true;\n  }\n\n  // Check if we have reached the maximum horizontal speed\n  if (_global_pos.vel_n > _param_lndmc_speed_max.get()) {\n    return true;\n  }\n\n  // Check if we have reached the maximum vertical speed\n  if (_global_pos.vel_d > _param_lndmc_speed_max.get()) {\n    return true;\n  }\n\n  // Check if we have reached the maximum horizontal acceleration\n  if (_global_pos.accel_hor > _param_lndmc_acc_max.get()) {\n    return true;\n  }\n\n  // Check if we have reached the maximum vertical acceleration\n  if (_global_pos.accel_ver > _param_lndmc_acc_max.get()) {\n    return true;\n  }\n\n  // Check if we have reached the maximum climb rate\n  if (_global_pos.vel_d > _param_lndmc_climb_max.get()) {\n    return true;\n  }\n\n  // Check if we have reached the maximum descent rate\n  if (_global_pos.vel_d < -_param_lndmc_descent_max.get()) {\n    return true;\n  }\n\n  // Check if we have reached the maximum roll rate\n  if (_global_pos.rollspeed > _param_lndmc_roll_max.", "CodeBleu_score": 38.90647227634537}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()    bool pass = true;\n    if (motor_test_requests.size() == 0) {\n        pass = false;\n        if (motor_test_enabled) {\n            if (motor_test_start_time == 0) {\n                motor_test_start_time = millis();\n            } else if ((millis() - motor_test_start_time) > 2000) {\n                motor_test_start_time = 0;\n                pass = false;\n            }\n        }\n    } else {\n        motor_test_start_time = 0;\n    }\n    if (!pass) {\n        Serial.println(\"Motor test timed out\");\n        motor_test_enabled = false;\n        motor_test_start_time = 0;\n        motor_test_requests.clear();\n        motor_test_timeout = millis();\n        motor_test_pass = false;\n        Sub::arm_system(false);\n        Sub::record_failure_time(millis());\n        return false;\n    } else {\n        return true;\n    }\n}\n", "CodeBleu_score": 52.173671942344136}, {"code": "bool Sub::verify_motor_test()  // Check if the motor test has been requested\n  if (motor_test_requested) {\n    // Check if the motor test has been completed\n    if (motor_test_completed) {\n      // Check if the motor test has been verified\n      if (motor_test_verified) {\n        // Reset the motor test verification flag\n        motor_test_verified = false;\n        // Check if the motor test has passed\n        if (motor_test_passed) {\n          // Reset the motor test passed flag\n          motor_test_passed = false;\n          // Reset the motor test completed flag\n          motor_test_completed = false;\n          // Reset the motor test requested flag\n          motor_test_requested = false;\n          // Reset the motor test timeout counter\n          motor_test_timeout_counter = 0;\n          // Reset the motor test timeout flag\n          motor_test_timeout = false;\n          // Reset the motor test timeout message flag\n          motor_test_timeout_message = false;\n          // Reset the motor test timeout message counter\n          motor_test_timeout_message_counter = 0;\n          // Reset the motor test timeout message timer\n          motor_test_timeout_message_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test timeout timer\n          motor_test_timeout_timer = 0;\n          // Reset the motor test", "CodeBleu_score": 30.22551521107653}, {"code": "bool Sub::verify_motor_test()  bool pass = true;\n  if (motor_test_request_count < 2) {\n    pass = false;\n    Serial.println(\"Motor test failed. No motor test requests received.\");\n    Serial.println(\"Disabling motor test and arming system.\");\n    motor_test_enabled = false;\n    arm_system();\n    failure_time = millis();\n  }\n  return pass;\n}\n", "CodeBleu_score": 48.93734642293489}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\n  // if wp_nav is not available, return\n  if (!wp_nav_available) {\n    return;\n  }\n\n  // if wp_nav is available, set lateral_out and forward_out to wp_nav's roll and pitch targets\n  lateral_out = wp_nav.roll;\n  forward_out = wp_nav.pitch;\n\n  // if lateral_out and forward_out are both zero, return\n  if (lateral_out == 0 && forward_out == 0) {\n    return;\n  }\n\n  // if lateral_out is zero, return\n  if (lateral_out == 0) {\n    return;\n  }\n\n  // if forward_out is zero, return\n  if (forward_out == 0) {\n    return;\n  }\n\n  // if lateral_out is greater than 30 degrees, return\n  if (lateral_out > 3000) {\n    return;\n  }\n\n  // if forward_out is greater than 30 degrees, return\n  if (forward_out > 3000) {\n    return;\n  }\n\n  // if lateral_out is less than -30 degrees, return\n  if (lateral_out < -3000) {\n    return;\n  }\n\n  // if forward_out is less than -30 degrees, return\n  if (forward_out < -3000) {\n    return;\n  }\n\n  // if lateral_out and forward_out are both greater than 30 degrees, return\n  if (lateral_out > 3000 && forward_out > 3000) {\n    return;\n  }\n\n  // if lateral_out and forward_out are both less than -30 degrees, return\n  if (lateral_out < -3000 && forward_out < -3000) {\n    return;\n  }\n\n  // if lateral_out is greater than 30 degrees and forward_out is less than -30 degrees, return\n  if (lateral_out >", "CodeBleu_score": 21.669316284303985}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target, pitch_target;\n\troll_target = wp_nav.wp_cmd.param1;\n\tpitch_target = wp_nav.wp_cmd.param2;\n\t//constrain roll and pitch targets to maximum angle range\n\troll_target = constrain_int(roll_target, -MAX_ANGLE, MAX_ANGLE);\n\tpitch_target = constrain_int(pitch_target, -MAX_ANGLE, MAX_ANGLE);\n\t//normalize roll and pitch targets\n\tfloat roll_normalized = (roll_target + MAX_ANGLE) / (2 * MAX_ANGLE);\n\tfloat pitch_normalized = (pitch_target + MAX_ANGLE) / (2 * MAX_ANGLE);\n\t//assign normalized roll and pitch targets to lateral and forward outputs\n\tlateral_out = roll_normalized;\n\tforward_out = pitch_normalized;\n}\n", "CodeBleu_score": 38.03715552098404}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)    // Convert centidegrees to radians\n    float roll_target = (wp_nav.roll_target * 0.01f);\n    float pitch_target = (wp_nav.pitch_target * 0.01f);\n\n    // Constrain roll and pitch targets within a specified maximum angle range\n    roll_target = constrain_float(roll_target, -max_roll_pitch_angle, max_roll_pitch_angle);\n    pitch_target = constrain_float(pitch_target, -max_roll_pitch_angle, max_roll_pitch_angle);\n\n    // Normalize roll and pitch targets\n    float roll_target_norm = normalize_float(roll_target, -max_roll_pitch_angle, max_roll_pitch_angle);\n    float pitch_target_norm = normalize_float(pitch_target, -max_roll_pitch_angle, max_roll_pitch_angle);\n\n    // Assign normalized values to lateral_out and forward_out\n    lateral_out = roll_target_norm;\n    forward_out = pitch_target_norm;\n}\n", "CodeBleu_score": 41.18860977545475}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()    if (barometer.healthy()) {\n        barometer_calibration.update(barometer.altitude());\n        if (depth_sensor) {\n            depth_sensor->set_healthy(true);\n        }\n    } else {\n        if (depth_sensor) {\n            depth_sensor->set_healthy(false);\n        }\n    }\n}\n", "CodeBleu_score": 38.528257060150786}, {"code": "void Sub::read_barometer()  // Read the barometer\n  float altitude = barometer.readAltitude(sea_level_pressure);\n  if (altitude < 0) {\n    altitude = 0;\n  }\n  // Update the barometer calibration\n  if (altitude > 0) {\n    barometer_calibration = altitude;\n  }\n  // Update the sensor health status\n  if (altitude > 0) {\n    barometer_health = true;\n  }\n  else {\n    barometer_health = false;\n  }\n}\n", "CodeBleu_score": 49.10736417493804}, {"code": "void Sub::read_barometer()\t// TODO: Check if we have a barometer\n\t// TODO: Check if we have a depth sensor\n\t// TODO: Check if we have a barometer calibration\n\t// TODO: Check if the barometer is healthy\n\t// TODO: Check if the depth sensor is healthy\n\t// TODO: Check if the barometer calibration is healthy\n\t// TODO: Update the barometer calibration\n\t// TODO: Update the depth sensor health status\n\t// TODO: Update the barometer health status\n\t// TODO: Update the barometer calibration health status\n\t// TODO: Update the barometer calibration\n\t// TODO: Update the barometer\n}\n", "CodeBleu_score": 3.5100903084647426}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()\tif (!_in_air) {\n\t\t// not in air, so always return true\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of GPS\n\tif (_gps_position_ok) {\n\t\t// GPS is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of optical flow\n\tif (_flow_position_ok) {\n\t\t// optical flow is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of vision\n\tif (_vision_position_ok) {\n\t\t// vision is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of external vision\n\tif (_ev_pos_ok) {\n\t\t// external vision is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of a range finder\n\tif (_range_position_ok) {\n\t\t// range finder is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of a distance sensor\n\tif (_dist_position_ok) {\n\t\t// distance sensor is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of a global position estimate\n\tif (_global_position_ok) {\n\t\t// global position estimate is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of a local position estimate\n\tif (_local_position_ok) {\n\t\t// local position estimate is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the presence of a mission command\n\tif (_mission_position_ok) {\n\t\t// mission command is present, so we can use it\n\t\treturn true;\n\t}\n\n\t// if we are in air, check for the", "CodeBleu_score": 7.046605155405845}, {"code": "bool Sub::ekf_position_ok()\tif (!_att_sp.disable_pos_ctrl) {\n\t\tif (!_control_mode.flag_control_manual_enabled) {\n\t\t\tif (_control_mode.flag_control_auto_enabled) {\n\t\t\t\tif (_control_mode.flag_control_altitude_enabled) {\n\t\t\t\t\tif (PX4_ISFINITE(_pos_sp_triplet.current.lat) && PX4_ISFINITE(_pos_sp_triplet.current.lon)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 32.45634285429369}, {"code": "bool Sub::ekf_position_ok()\tif (!_control_mode.flag_control_altitude_enabled && !_control_mode.flag_control_position_enabled) {\n\t\treturn false;\n\t}\n\n\tif (!_vehicle_status.is_rotary_wing) {\n\t\treturn false;\n\t}\n\n\tif (_control_mode.flag_armed) {\n\t\tif (!_vehicle_status.condition_local_position_valid || !_vehicle_status.condition_local_velocity_valid) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (_vehicle_status.condition_local_altitude_valid) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// if we are not in constant position mode, we require a good EKF position\n\t\tif (!_control_mode.flag_control_altitude_enabled) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if we are in constant position mode, we require a good EKF altitude\n\t\tif (_local_pos.xy_valid && _local_pos.z_valid) {\n\t\t\treturn true;\n\t\t}\n\n\t} else {\n\t\tif (_vehicle_status.condition_local_position_valid) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 37.18141536390217}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    bool ret = true;\n    if (control_mode == MANUAL || control_mode == STABILIZE) {\n        return ret;\n    }\n    ret = AP_Arming::gps_checks(display_failure);\n    if (!ret) {\n        return ret;\n    }\n    if (!ahrs.get_ahrs_initialized()) {\n        if (display_failure) {\n            hal.console->printf(\"GPS: AHRS not initialized\\n\");\n        }\n        return false;\n    }\n    if (ekf_check_failure()) {\n        if (display_failure) {\n            hal.console->printf(\"GPS: EKF check failure\\n\");\n        }\n        return false;\n    }\n    if (!ekf_position_valid()) {\n        if (display_failure) {\n            hal.console->printf(\"GPS: EKF position invalid\\n\");\n        }\n        return false;\n    }\n    return ret;\n}\n", "CodeBleu_score": 47.81419246473985}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    if (!ahrs.get_ahrs_initialised()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"GPS: AHRS not initialised\\n\"));\n        }\n        return false;\n    }\n\n    if (ahrs.failsafe_enabled()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"GPS: AHRS failsafe\\n\"));\n        }\n        return false;\n    }\n\n    if (!_ahrs_position_valid) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"GPS: AHRS position invalid\\n\"));\n        }\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 50.275368814297096}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!_ahrs.get_control_mode()->flags.control_position_enabled) {\n\t\treturn true;\n\t}\n\n\t// check that the EKF is not in failsafe mode\n\tif (_ahrs.get_control_mode()->flags.control_altitude_enabled && _ahrs.get_control_mode()->flags.control_velocity_enabled) {\n\t\tif (_ekf.failsafe_event()) {\n\t\t\tif (display_failure) {\n\t\t\t\tmavlink_log_critical(_mavlink_fd, \"EKF failsafe\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// check that the AHRS is ready\n\tif (!_ahrs.get_initialized()) {\n\t\tif (display_failure) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"AHRS not ready\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check that the position estimate is valid\n\tif (!_ahrs.get_position_valid()) {\n\t\tif (display_failure) {\n\t\t\tmavlink_log_critical(_mavlink_fd, \"No position\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 53.495467727594836}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    bool success = false;\n    bool do_simple_mode_heading_reset = false;\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {\n        set_arming_status(method);\n    }\n\n    // if we are not already armed, then we need to set the arming status\n    if (!armed()) {", "CodeBleu_score": 29.54512479300997}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    if (method == AP_Arming::INITIALISE) {\n        // initialise arming state\n        _arming_state = ARMING_INITIALISE;\n    } else if (method == AP_Arming::MANUAL) {\n        // manual arming\n        _arming_state = ARMING_MANUAL;\n    } else if (method == AP_Arming::SAFETY_SHUTDOWN) {\n        // safety shutdown\n        _arming_state = ARMING_SAFETY_SHUTDOWN;\n    } else if (method == AP_Arming::SAFETY_ARMED) {\n        // safety armed\n        _arming_state = ARMING_SAFETY_ARMED;\n    } else if (method == AP_Arming::SAFETY_DISARMED) {\n        // safety disarmed\n        _arming_state = ARMING_SAFETY_DISARMED;\n    } else if (method == AP_Arming::GPS_LOCK) {\n        // gps lock\n        _arming_state = ARMING_GPS_LOCK;\n    } else if (method == AP_Arming::RC_ARMED) {\n        // rc armed\n        _arming_state = ARMING_RC_ARMED;\n    } else if (method == AP_Arming::RC_DISARMED) {\n        // rc disarmed\n        _arming_state = ARMING_RC_DISARMED;\n    } else if (method == AP_Arming::MANUAL_DISARMED) {\n        // manual disarmed\n        _arming_state = ARMING_MANUAL_DISARMED;\n    } else if (method == AP_Arming::MANUAL_ARMED) {\n        // manual armed\n        _arming_state = ARMING_MANUAL_ARMED;\n    } else if (method == AP_Arming::MANUAL_DISARMED_BY_USER) {\n        // manual disarmed by user\n        _arming_state = AR", "CodeBleu_score": 19.545795301123935}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\n    if (method == AP_Arming::ARMING_METHOD_SMART_RTL) {\n        // check for smart RTL\n        if (!_smart_rtl_enabled) {\n            // smart RTL not enabled\n            _arming_failed_reason = AP_ARMING_REASON_SMART_RTL_DISABLED;\n            return false;\n        }\n    }\n\n    // check for arming checks\n    if (do_arming_checks) {\n        if (!_check_arming_conditions()) {\n            // arming checks failed\n            _arming_failed_reason = AP_ARMING_REASON_ARMING_CHECKS_FAILED;\n            return false;\n        }\n    }\n\n    // check for armed\n    if (_armed) {\n        // already armed\n        _arming_failed_reason = AP_ARMING_REASON_ALREADY_ARMED;\n        return false;\n    }\n\n    // check for soft armed\n    if (_soft_armed) {\n        // already soft armed\n        _arming_failed_reason = AP_ARMING_REASON_ALREADY_SOFT_ARMED;\n        return false;\n    }\n\n    // check for GPS lock\n    if (!_gps->status().location.isValid()) {\n        // no GPS lock\n        _arming_failed_reason = AP_ARMING_REASON_NO_GPS_LOCK;\n        return false;\n    }\n\n    // check for GPS accuracy\n    if (_gps->status().location.accuracy > _gps_accuracy_threshold) {\n        // GPS accuracy too high\n        _arming_failed_reason = AP_ARMING_REASON_GPS_ACCURACY_TOO_HIGH;\n        return false;\n    }\n\n    // check for battery voltage\n    if (_battery->voltage_filtered_v() < _battery_voltage_threshold) {\n        // battery voltage too low\n        _arming_failed_", "CodeBleu_score": 38.093218487605206}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (charging_enabled) {\n      if (charging_should_continue) {\n        // do nothing\n      } else {\n        charging_enabled = false;\n        charging_disabled_time = millis();\n      }\n    } else {\n      charging_enabled = true;\n      charging_disabled_time = 0;\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      charging_disabled_time = millis();\n    } else {\n      // do nothing\n    }\n  }\n}\n", "CodeBleu_score": 42.63212064538919}, {"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (charging_enabled) {\n      if (charging_should_continue) {\n        if (charging_enabled_time == 0) {\n          charging_enabled_time = millis();\n        }\n      } else {\n        if (millis() - charging_enabled_time > DISABLE_CHARGING_TIME) {\n          charging_enabled = false;\n          charging_enabled_time = 0;\n        }\n      }\n    } else {\n      if (millis() - charging_enabled_time > ENABLE_CHARGING_TIME) {\n        charging_enabled = true;\n        charging_enabled_time = 0;\n      }\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      charging_enabled_time = 0;\n    }\n  }\n}\n", "CodeBleu_score": 46.80779412106105}, {"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (charging_enabled) {\n      if (charging_enabled_time == 0) {\n        charging_enabled_time = millis();\n      } else if (millis() - charging_enabled_time >= charging_enabled_time_limit) {\n        charging_enabled = false;\n        charging_enabled_time = 0;\n      }\n    } else {\n      charging_enabled = true;\n      charging_enabled_time = 0;\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      charging_enabled_time = 0;\n    } else {\n      if (millis() - charging_enabled_time >= charging_enabled_time_limit) {\n        charging_enabled = true;\n        charging_enabled_time = 0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 47.09685318692189}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)  if (ros_running && size >= 4) {\n    uint16_t crc = crc16((uint8_t *)message, size);\n    size_t total_size = size + 2;\n    uint8_t *message_with_crc = (uint8_t *)malloc(total_size);\n    memcpy(message_with_crc, message, size);\n    message_with_crc[size] = crc & 0xFF;\n    message_with_crc[size + 1] = (crc >> 8) & 0xFF;\n    packetSerial.send(message_with_crc, total_size);\n    free(message_with_crc);\n  }\n}\n", "CodeBleu_score": 57.90356676415641}, {"code": "void sendMessage(void *message, size_t size)  if (ros_running && size >= 4) {\n    uint16_t crc = calculateCRC(message, size);\n    uint8_t *message_with_crc = (uint8_t *) message;\n    message_with_crc[size] = crc & 0xFF;\n    message_with_crc[size + 1] = crc >> 8;\n    packetSerial.send(message_with_crc, size + 2);\n  }\n}\n", "CodeBleu_score": 55.19434212905794}, {"code": "void sendMessage(void *message, size_t size)  if (ros_running) {\n    if (size >= 4) {\n      uint16_t crc = crc16(message, size);\n      uint8_t *msg = (uint8_t *)message;\n      msg[size] = (crc >> 8) & 0xFF;\n      msg[size + 1] = crc & 0xFF;\n      packetSerial.send((uint8_t *)message, size + 2);\n    }\n  }\n}\n", "CodeBleu_score": 64.61960259247459}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()  if (!SD.begin(SD_CS)) {\n    Serial.println(\"SD card failed to initialize\");\n    return false;\n  }\n  Serial.println(\"SD card initialized\");\n  if (!SD.exists(\"mp3\")) {\n    Serial.println(\"No mp3 folder found\");\n    return false;\n  }\n  Serial.println(\"mp3 folder found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.mp3\")) {\n    Serial.println(\"No sound files found\");\n    return false;\n  }\n  Serial.println(\"Sound files found\");\n  if (!SD.exists(\"mp3/0.", "CodeBleu_score": 32.788152596238426}, {"code": "bool MP3Sound::begin()  //Initialize serial communication with the sound module\n  if (Serial.begin(9600) == 0) {\n    Serial.println(\"Unable to initialize serial communication with the sound module.\");\n    return false;\n  }\n  //Clear any existing data in the buffer\n  while (Serial.available()) {\n    Serial.read();\n  }\n  //Initialize the sound module\n  if (!init()) {\n    Serial.println(\"Unable to initialize the sound module.\");\n    return false;\n  }\n  //Retrieve the number of sound files available on the SD card\n  if (!getFileCount()) {\n    Serial.println(\"Unable to retrieve the number of sound files available on the SD card.\");\n    return false;\n  }\n  return true;\n}\n", "CodeBleu_score": 40.0716733310429}, {"code": "bool MP3Sound::begin()  Serial.begin(9600);\n  delay(100);\n  Serial.println(\"AT+RST\");\n  delay(100);\n  Serial.println(\"AT+CIPMUX=0\");\n  delay(100);\n  Serial.println(\"AT+CWMODE=1\");\n  delay(100);\n  Serial.println(\"AT+CIPSTART=\\\"TCP\\\",\\\"192.168.4.1\\\",80\");\n  delay(100);\n  Serial.println(\"AT+CIPSEND\");\n  delay(100);\n  Serial.println(\"GET / HTTP/1.1\");\n  delay(100);\n  Serial.println(\"Host: 192.168.4.1\");\n  delay(100);\n  Serial.println(\"User-Agent: ESP8266/1.0\");\n  delay(100);\n  Serial.println(\"Connection: close\");\n  delay(100);\n  Serial.println();\n  delay(100);\n  Serial.println();\n  delay(100);\n  Serial.println(\"AT+CIPCLOSE=0\");\n  delay(100);\n  Serial.println(\"AT+CIPSTATUS\");\n  delay(100);\n  Serial.println(\"AT+CIPMUX=1\");\n  delay(100);\n  Serial.println(\"AT+CWMODE=1\");\n  delay(100);\n  Serial.println(\"AT+CIPSTART=\\\"TCP\\\",\\\"192.168.4.1\\\",80\");\n  delay(100);\n  Serial.println(\"AT+CIPSEND\");\n  delay(100);\n  Serial.println(\"GET / HTTP/1.1\");\n  delay(100);\n  Serial.println(\"Host: 192.168.4.1\");\n  delay(100);\n  Serial.println(\"User-Agent: ESP8266/1.0\");\n  delay(100);\n  Serial.println(\"Connection: close\");\n  delay(1", "CodeBleu_score": 37.987452362475636}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()\tif (activeSounds.empty() || mp3.isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\tSound *s = activeSounds.back();\n\tactiveSounds.pop_back();\n\tif (s->soundType == SoundType::MP3) {\n\t\tmp3.play(s->fileName);\n\t}\n\telse {\n\t\tspeaker.play(s->fileName);\n\t}\n\tdelete s;\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 40.50067895584757}, {"code": "int MP3Sound::processSounds()\tif (activeSounds.size() == 0 || MP3Player.isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\telse {\n\t\tMP3Player.play(activeSounds.back());\n\t\tactiveSounds.pop_back();\n\t\treturn activeSounds.size();\n\t}\n}\n", "CodeBleu_score": 37.03690357559765}, {"code": "int MP3Sound::processSounds()\tif (activeSounds.size() == 0)\n\t\treturn 0;\n\tif (playingMP3)\n\t\treturn activeSounds.size();\n\tif (activeSounds.size() == 1) {\n\t\tplaySound(activeSounds.front());\n\t\tactiveSounds.pop_front();\n\t\treturn 0;\n\t}\n\tif (activeSounds.size() == 2) {\n\t\tplaySound(activeSounds.front());\n\t\tactiveSounds.pop_front();\n\t\tplaySound(activeSounds.front());\n\t\tactiveSounds.pop_front();\n\t\treturn 0;\n\t}\n\tif (activeSounds.size() > 2) {\n\t\tplaySound(activeSounds.front());\n\t\tactiveSounds.pop_front();\n\t\tplaySound(activeSounds.front());\n\t\tactiveSounds.pop_front();\n\t\tplaySound(activeSounds.front());\n\t\tactiveSounds.pop_front();\n\t\treturn 0;\n\t}\n}\n", "CodeBleu_score": 33.90241288347895}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      WbRequest *r = d->request;\n      if (c->memory_mapped_file) {\n        wb_abstract_camera_cleanup_memory_mapped_file(c);\n      }\n      if (r->size == 4) {\n        c->memory_mapped_file = wb_abstract_camera_setup_memory_mapped_file(c, r->data[0], r->data[1], r->data[2], r->data[3]);\n        if (c->memory_mapped_file) {\n          c->memory_mapped_file->device = c;\n          c->memory_mapped_file->buffer = c->memory_mapped_file->data;\n          c->memory_mapped_file->buffer_size = c->memory_mapped_file->size;\n          c->memory_mapped_file->buffer_offset = 0;\n          c->memory_mapped_file->buffer_end = c->memory_mapped_file->buffer_size;\n          c->memory_mapped_file->buffer_position = 0;\n          c->memory_mapped_file->buffer_available = c->memory_mapped_file->buffer_size;\n          c->memory_mapped_file->buffer_available_end = c->memory_mapped_file->buffer_available;\n          c->memory_mapped_file->buffer_available_position = 0;\n          c->memory_mapped_file->buffer_available_end = c->memory_mapped_file->buffer_available;\n          c->memory_mapped_file->buffer_available_position = 0;\n          c->memory_mapped_file->buffer_available_position_end = c->memory_mapped_file->buffer_available;\n          c->memory_mapped_file->buffer_available_position_end = c->memory_mapped_file->buffer_available;\n          c->memory_mapped_file->buffer_available_position_end_end =", "CodeBleu_score": 42.61029312516619}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *c = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      WbCameraRequest *req = wb_camera_request_new(r);\n      if (c->file) {\n        wb_camera_request_cleanup(req);\n        wb_camera_request_delete(req);\n      }\n      c->file = req;\n      c->file->request = req;\n      c->file->device = d;\n      c->file->width = c->width;\n      c->file->height = c->height;\n      c->file->bytesPerPixel = c->bytesPerPixel;\n      c->file->fileSize = c->fileSize;\n      c->file->frameCount = c->frameCount;\n      c->file->frameRate = c->frameRate;\n      c->file->frameRateMultiplier = c->frameRateMultiplier;\n      c->file->imageSize = c->imageSize;\n      c->file->image = c->image;\n      c->file->imageBuffer = c->imageBuffer;\n      c->file->imageBufferSize = c->imageBufferSize;\n      c->file->imageBufferOffset = c->imageBufferOffset;\n      c->file->imageBufferEnd = c->imageBufferEnd;\n      c->file->imageBufferEndOffset = c->imageBufferEndOffset;\n      c->file->imageBufferOffsetNext = c->imageBufferOffsetNext;\n      c->file->imageBufferOffsetPrevious = c->imageBufferOffsetPrevious;\n      c->file->imageBufferOffsetPrevious2 = c->imageBufferOffsetPrevious2;\n      c->file->imageBufferOffsetPrevious3 = c->imageBufferOffsetPrevious3;\n      c->file->imageBufferOffsetPrevious4 = c->imageBufferOffsetPrevious4;\n      c->file->imageBufferOffsetPrevious5 = c->imageBufferOffsetPrevious5;\n      c->file->imageBufferOffsetPrevious6 = c->imageBufferOffsetPrevious6;\n      c->file->imageBufferOffsetPrevious7 = c->imageBufferOffsetPrevious7;\n      c->file", "CodeBleu_score": 41.137082956214776}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *c = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      WbFieldRef f = wb_supervisor_node_get_field(d->node, \"memoryMappedFile\");\n      wb_supervisor_field_set_sf_string(f, wb_request_get_string(r));\n      wb_abstract_camera_cleanup_memory_mapped_file(c);\n      wb_abstract_camera_setup_memory_mapped_file(c);\n      return true;\n    }\n    default:\n      return false;\n  }\n}\n", "CodeBleu_score": 39.468325750809804}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)  int ret;\n  wb_abstract_camera_get_height_lock(d);\n  ret = d->pdata ? d->pdata->height : -1;\n  wb_abstract_camera_get_height_unlock(d);\n  return ret;\n}\n", "CodeBleu_score": 41.83665595198155}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  int height = -1;\n  WbAbstractCamera *camera = d->pdata;\n  pthread_mutex_lock(&camera->mutex);\n  if (camera->data != NULL)\n    height = camera->data->height;\n  pthread_mutex_unlock(&camera->mutex);\n  return height;\n}\n", "CodeBleu_score": 43.817008682158644}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  return wb_abstract_camera_get_height_raw(d);\n}\n", "CodeBleu_score": 3.307166610455929}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period;\n  WbDevice *d = robot_find_device_by_tag(tag);\n  if (d == NULL) {\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\\n\", __FUNCTION__);\n    return -1;\n  }\n  if (d->type != ACCELEROMETER) {\n    fprintf(stderr, \"Error: %s() called on a non accelerometer device.\\n\", __FUNCTION__);\n    return -1;\n  }\n  WbAccelerometer *accelerometer = d->pdata;\n  pthread_mutex_lock(&accelerometer->mutex);\n  if (accelerometer->sampling_period == -1) {\n    fprintf(stderr, \"Error: %s() called on an accelerometer device that is not enabled.\\n\", __FUNCTION__);\n    pthread_mutex_unlock(&accelerometer->mutex);\n    return -1;\n  }\n  sampling_period = accelerometer->sampling_period;\n  pthread_mutex_unlock(&accelerometer->mutex);\n  return sampling_period;\n}\n", "CodeBleu_score": 48.70385636016207}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  WbDevice *d = wb_device_get_struct(tag);\n  if (d == NULL) {\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\\n\", __FUNCTION__);\n    return -1;\n  }\n  pthread_mutex_lock(&d->mutex);\n  if (d->type != ACCELEROMETER) {\n    fprintf(stderr, \"Error: %s() called on a device which is not an Accelerometer.\\n\", __FUNCTION__);\n    pthread_mutex_unlock(&d->mutex);\n    return -1;\n  }\n  Accelerometer *accelerometer = d->pdata;\n  int sampling_period = accelerometer->sampling_period;\n  pthread_mutex_unlock(&d->mutex);\n  return sampling_period;\n}\n", "CodeBleu_score": 49.65115667747947}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period;\n  wb_accelerometer_private_devices_lock();\n  WbAccelerometer *accelerometer = wb_accelerometer_private_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\\n\", __FUNCTION__);\n    sampling_period = -1;\n  }\n  wb_accelerometer_private_devices_unlock();\n  return sampling_period;\n}\n", "CodeBleu_score": 53.253527460199315}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = dms;\n\tfree(dms);\n\treturn result;\n}\n", "CodeBleu_score": 41.4497414307873}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}\n", "CodeBleu_score": 39.356925641872465}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString(dms);\n    free(dms);\n    return dmsString;\n}\n", "CodeBleu_score": 40.74865130796342}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)  dVector3 c;\n  dVector3 p;\n  dVector3 n;\n  dVector3 v;\n  dReal d;\n  int i;\n  dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n  const dReal *R = dGeomGetRotation (g);\n  const dReal *P = dGeomGetPosition (g);\n  dUASSERT (plane, \"argument plane is null\");\n  dUASSERT (x >= -1 && x <= 1, \"argument x is out of range\");\n  dUASSERT (y >= -1 && y <= 1, \"argument y is out of range\");\n  dUASSERT (z >= -1 && z <= 1, \"argument z is out of range\");\n  dUASSERT (R, \"argument rotation is null\");\n  dUASSERT (P, \"argument position is null\");\n  dUASSERT (dGeomBoxGetLength (g, 0) > 0, \"argument length is zero\");\n  dUASSERT (dGeomBoxGetLength (g, 1) > 0, \"argument width is zero\");\n  dUASSERT (dGeomBoxGetLength (g, 2) > 0, \"argument height is zero\");\n  dMULTIPLY0_331 (c, R, P);\n  dMULTIPLY0_331 (p, R, (dVector3){x,y,z});\n  p[0] += c[0];\n  p[1] += c[1];\n  p[2] += c[2];\n  dUASSERT (dFabs (dDOT (p, (dVector3){1,0,0}) - 1) <= 1e-3, \"argument x is not on the box\");\n  dUASSERT (dFabs (dDOT (p, (dVector3){0,1,0}) - 1) <= 1e-3, \"argument y is not on the box\");\n  dUASSERT (dFabs (dDOT (p, (dVector3){0,0,1}) - 1) <= 1", "CodeBleu_score": 33.949106589831445}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)  dAASSERT (g && plane);\n  dUASSERT (g->type == dBoxClass, \"argument not a box\");\n  const dReal *R = dGeomGetRotation (g);\n  const dReal *P = dGeomGetPosition (g);\n  dVector3 p;\n  p[0] = x - P[0];\n  p[1] = y - P[1];\n  p[2] = z - P[2];\n  dMULTIPLY0_331 (p, R, p);\n  if (p[0] < -dGeomBoxGetLength(g)[0]/2) {\n    plane[0] = 1;\n    plane[1] = 0;\n    plane[2] = 0;\n    plane[3] = -dGeomBoxGetLength(g)[0]/2;\n  }\n  else if (p[0] > dGeomBoxGetLength(g)[0]/2) {\n    plane[0] = -1;\n    plane[1] = 0;\n    plane[2] = 0;\n    plane[3] = dGeomBoxGetLength(g)[0]/2;\n  }\n  else if (p[1] < -dGeomBoxGetLength(g)[1]/2) {\n    plane[0] = 0;\n    plane[1] = 1;\n    plane[2] = 0;\n    plane[3] = -dGeomBoxGetLength(g)[1]/2;\n  }\n  else if (p[1] > dGeomBoxGetLength(g)[1]/2) {\n    plane[0] = 0;\n    plane[1] = -1;\n    plane[2] = 0;\n    plane[3] = dGeomBoxGetLength(g)[1]/2;\n  }\n  else if (p[2] < -dGeomBoxGetLength(g)[2]/2) {\n    plane[0] = 0;\n    plane[1] = 0;\n    plane[2] = 1;\n    plane[3] = -dGeomBoxGetLength(g)[", "CodeBleu_score": 32.25973192193561}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)  dAASSERT (g);\n  dUASSERT (g->type == dBoxClass, \"argument not a box\");\n  const dReal *R = dGeomGetRotation (g);\n  const dReal *pos = dGeomGetPosition (g);\n  dVector3 p;\n  p[0] = x - pos[0];\n  p[1] = y - pos[1];\n  p[2] = z - pos[2];\n  dMULTIPLY0_331 (p,R,p);\n  const dReal *side = dGeomBoxGetLengths (g);\n  dReal d[3];\n  d[0] = p[0] - side[0];\n  d[1] = p[1] - side[1];\n  d[2] = p[2] - side[2];\n  dReal mind = d[0];\n  int i = 0;\n  if (d[1] < mind) {\n    mind = d[1];\n    i = 1;\n  }\n  if (d[2] < mind) {\n    mind = d[2];\n    i = 2;\n  }\n  if (mind < 0) {\n    d[i] = 0;\n  }\n  else {\n    d[i] = side[i];\n  }\n  dCROSS (plane,=,d,p);\n  dNormalize3 (plane);\n  dMULTIPLY0_331 (plane,R,plane);\n  d[0] = x - pos[0];\n  d[1] = y - pos[1];\n  d[2] = z - pos[2];\n  dMULTIPLY0_331 (d,R,d);\n  plane[3] = dDOT (d,plane) - d[i];\n}\n\n", "CodeBleu_score": 45.00323707185912}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\n    if (!box || !immersion)\n        return 0;\n\n    if (!(flags & (dxImmersionBoxFlags_Immersion | dxImmersionBoxFlags_Contact)))\n        return 0;\n\n    dImmersionGeomData *data = (dImmersionGeomData*) immersion->data;\n    if (!data) {\n        data = new dImmersionGeomData;\n        immersion->data = data;\n    }\n\n    if (!data->sBoxImmersionData) {\n        data->sBoxImmersionData = new sBoxImmersionData;\n        data->sBoxImmersionData->flags = flags;\n    }\n\n    return dImmerseBox (box, fluidPlane, flags, data->sBoxImmersionData);\n}\n", "CodeBleu_score": 40.985495464493454}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\n   if (box->body == NULL) {\n      dDebug (0,\"dImmerseBox: box has no body\\n\");\n      return 0;\n   }\n   if (flags & ~(dIMMSURF_BOX_BODY_NORMAL_ONLY | dIMMSURF_BOX_BODY_NORMAL_X |\n         dIMMSURF_BOX_BODY_NORMAL_Y | dIMMSURF_BOX_BODY_NORMAL_Z |\n         dIMMSURF_BOX_BODY_SURFACE_ONLY | dIMMSURF_BOX_BODY_SURFACE_X |\n         dIMMSURF_BOX_BODY_SURFACE_Y | dIMMSURF_BOX_BODY_SURFACE_Z |\n         dIMMSURF_BOX_BODY_INNER_ONLY | dIMMSURF_BOX_BODY_INNER_X |\n         dIMMSURF_BOX_BODY_INNER_Y | dIMMSURF_BOX_BODY_INNER_Z |\n         dIMMSURF_BOX_BODY_ALL)) {\n      dDebug (0,\"dImmerseBox: invalid flags\\n\");\n      return 0;\n   }\n\n   // Initialize the sBoxImmersionData object.\n   sBoxImmersionData boxImmersion;\n   boxImmersion.box = box;\n   boxImmersion.fluidPlane = fluidPlane;\n   boxImmersion.flags = flags;\n   boxImmersion.immersion = immersion;\n\n   // Perform the immersion checking.\n   return dImmerseBox_internal (&boxImmersion);\n}\n\n", "CodeBleu_score": 39.433151557591316}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)   dAASSERT (box);\n   dAASSERT (fluidPlane);\n   dAASSERT (immersion);\n\n   // initialize the sBoxImmersionData object\n   sBoxImmersionData *data = (sBoxImmersionData *)immersion->data;\n   data->box = box;\n   data->fluidPlane = fluidPlane;\n   data->flags = flags;\n\n   // check the box and the fluid plane\n   if (!dCheckBox (box, fluidPlane))\n      return 0;\n\n   // check the immersion\n   return dImmerseBoxInternal (data);\n}\n", "CodeBleu_score": 47.82435045327723}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  if (!o1->typep || !o2->typep ||\n      o1->typep != dGeomGetClass (o2) ||\n      !immersion)\n    return 0;\n\n  dVector3 c1, c2;\n  dVector3 p1, p2;\n  dVector3 n1, n2;\n  dVector3 p, q;\n  dVector3 v, w;\n  dVector3 a, b;\n  dVector3 e1, e2;\n  dVector3 e1a, e1b;\n  dVector3 e2a, e2b;\n  dReal R1, R2;\n  dReal R12;\n  dReal R12a, R12b;\n  dReal R12c, R12d;\n  dReal R12e, R12f;\n  dReal R12g, R12h;\n  dReal R12i, R12j;\n  dReal R12k, R12l;\n  dReal R12m, R12n;\n  dReal R12o, R12p;\n  dReal R12q, R12r;\n  dReal R12s, R12t;\n  dReal R12u, R12v;\n  dReal R12w, R12x;\n  dReal R12y, R12z;\n  dReal R12A, R12B;\n  dReal R12C, R12D;\n  dReal R12E, R12F;\n  dReal R12G, R12H;\n  dReal R12I, R12J;\n  dReal R12K, R12L;\n  dReal R12M, R12N;\n  dReal R12O, R12P;\n  dReal R12Q, R12R;\n  dReal R12S, R12T;\n  dReal R12U, R12V;\n  dReal R12W, R12X;", "CodeBleu_score": 16.943324740367803}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    dIASSERT (SafetyChecks);\n    // and return immediately if there is nothing to do\n    if (immersion == NULL)\n        return 0;\n    if ((flags & NUMC_MASK) != 1)\n        return 0;\n    // get the box and capsule\n    dxBox *box = (dxBox*) o1;\n    dxCapsule *capsule = (dxCapsule*) o2;\n    // check the input arguments\n    if (!box || !capsule || !immersion)\n        return 0;\n    // check the input arguments\n    if (box->type != dBoxClass)\n        return 0;\n    if (capsule->type != dCapsuleClass)\n        return 0;\n    // get the box and capsule parameters\n    dVector3 box_pos; dGeomGetPosition(box, box_pos);\n    dMatrix3 box_R; dGeomGetRotation(box, box_R);\n    dVector3 box_size; dGeomBoxGetLengths(box, box_size);\n    dVector3 capsule_pos; dGeomGetPosition(capsule, capsule_pos);\n    dReal capsule_radius; dGeomCapsuleGetParams(capsule, &capsule_radius, NULL);\n    // compute the capsule axis\n    dVector3 capsule_axis; dGeomCapsuleGetAxis(capsule, capsule_axis);\n    // compute the capsule endpoints\n    dVector3 capsule_end; dGeomCapsuleGetEndPoint(capsule, capsule_end);\n    dVector3 capsule_center; dGeomCapsuleGetCenter(capsule, capsule_center);\n    // compute the capsule endpoints in the box's frame\n    dVector3 box_capsule_end; dMULTIPLY0_331 (box_capsule_end, box_R, capsule_end);\n    dVector3 box_capsule_center; dMULTIPLY0_331 (box_capsule_center, box_R, capsule_center);\n   ", "CodeBleu_score": 35.7557858700395}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dIASSERT (SafetyChecks);\n  // and return immediately if they don't overlap\n  if (!dBoxTouchesCapsule (o1, o2)) return 0;\n\n  dVector3 p1, p2, p3, p4;\n  dVector3 side;\n  dVector3 normal;\n  dReal depth;\n  dReal radius;\n  dReal r;\n  dReal side_depth;\n  dReal side_depth_inv;\n  dReal side_depth_inv_2;\n  dReal side_depth_inv_3;\n  dReal side_depth_inv_4;\n  dReal side_depth_inv_5;\n  dReal side_depth_inv_6;\n  dReal side_depth_inv_7;\n  dReal side_depth_inv_8;\n  dReal side_depth_inv_9;\n  dReal side_depth_inv_10;\n  dReal side_depth_inv_11;\n  dReal side_depth_inv_12;\n  dReal side_depth_inv_13;\n  dReal side_depth_inv_14;\n  dReal side_depth_inv_15;\n  dReal side_depth_inv_16;\n  dReal side_depth_inv_17;\n  dReal side_depth_inv_18;\n  dReal side_depth_inv_19;\n  dReal side_depth_inv_20;\n  dReal side_depth_inv_21;\n  dReal side_depth_inv_22;\n  dReal side_depth_inv_23;\n  dReal side_depth_inv_24;\n  dReal side_depth_inv_25;\n  dReal side_depth_inv_26;\n  dReal side_depth_inv_27;\n  dReal side_depth_inv_28;\n  dReal side_depth_inv_29;\n  dReal side_depth_inv_30;\n  dReal side_depth_inv_31;\n  dReal side_depth_inv_32;\n  d", "CodeBleu_score": 11.73780349522037}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal sinTheta0 = dSqrt(1.0 - tanTheta0 * tanTheta0);\n\tdReal sinTheta2 = dSqrt(1.0 - sinTheta1 * sinTheta1);\n\tdReal tanTheta1 = dSqrt(1.0 - sinTheta2 * sinTheta2);\n\n\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal zIOverR3 = zIOverR2 * zIOverR;\n\tdReal zIOverR4 = zIOverR3 * zIOverR;\n\n\tdReal zIOverR5 = zIOverR4 * zIOverR;\n\tdReal zIOverR6 = zIOverR5 * zIOverR;\n\tdReal zIOverR7 = zIOverR6 * zIOverR;\n\n\tdReal zIOverR8 = zIOverR7 * zIOverR;\n\tdReal zIOverR9 = zIOverR8 * zIOverR;\n\tdReal zIOverR10 = zIOverR9 * zIOverR;\n\n\tdReal zIOverR11 = zIOverR10 * zIOverR;\n\tdReal zIOverR12 = zIOverR11 * zIOverR;\n\tdReal zIOverR13 = zIOverR12 * zIOverR;\n\n\tdReal zIOverR14 = zIOverR13 * zIOverR;\n\tdReal zIOverR15 = zIOverR14 * zIOverR;\n\tdReal zIOverR16 = zIOverR15 * zIOverR;\n\n\tdReal zIOverR17 = zIOverR16 * zIOverR;\n\tdReal zIOverR18 = zIOverR17 * zIOverR;\n\tdReal zIOverR19 = zIOverR18 * zIOverR;\n\n\tdReal zIOverR20 = zIOverR19 * zIOverR;\n\tdReal zIOverR21 = z", "CodeBleu_score": 33.11063174654971}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\t// Calculate the normalized volume of the hemisphere\n\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal zIOverR3 = zIOverR2 * zIOverR;\n\tdReal zIOverR4 = zIOverR3 * zIOverR;\n\tdReal zIOverR5 = zIOverR4 * zIOverR;\n\tdReal zIOverR6 = zIOverR5 * zIOverR;\n\tdReal zIOverR7 = zIOverR6 * zIOverR;\n\tdReal zIOverR8 = zIOverR7 * zIOverR;\n\tdReal zIOverR9 = zIOverR8 * zIOverR;\n\tdReal zIOverR10 = zIOverR9 * zIOverR;\n\tdReal zIOverR11 = zIOverR10 * zIOverR;\n\tdReal zIOverR12 = zIOverR11 * zIOverR;\n\tdReal zIOverR13 = zIOverR12 * zIOverR;\n\tdReal zIOverR14 = zIOverR13 * zIOverR;\n\tdReal zIOverR15 = zIOverR14 * zIOverR;\n\tdReal zIOverR16 = zIOverR15 * zIOverR;\n\tdReal zIOverR17 = zIOverR16 * zIOverR;\n\tdReal zIOverR18 = zIOverR17 * zIOverR;\n\tdReal zIOverR19 = zIOverR18 * zIOverR;\n\tdReal zIOverR20 = zIOverR19 * zIOverR;\n\tdReal zIOverR21 = zIOverR20 * zIOverR;\n\tdReal zIOverR22 = zIOverR21 * zIOverR;\n\tdReal zIOverR23 = zIOverR22 * zIOverR;\n\tdReal zIOverR24 =", "CodeBleu_score": 29.443877961012987}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\t// The following variables are used to calculate the volume of the hemisphere using Simpson's rule.\n\tdReal x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63, x64, x65, x66, x67, x68, x69, x70, x71, x72, x73, x74, x75, x76, x77, x78, x79, x80, x81, x82, x83, x84, x85, x86, x87, x88, x89, x90, x91, x92, x93, x94, x95, x96, x97, x98, x99, x100, x101, x102, x103, x104, x105, x106, x107, x108, x109, x110, x111, x112, x113, x114, x115, x116, x117, x118,", "CodeBleu_score": 7.656126831153473}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\t// Calculate the surface area of the hemisphere\n\tdReal surfaceArea = 2 * M_PI * (zIOverR + 1) * (zIOverR + 1);\n\t// Calculate the surface area of the hemisphere's base\n\tdReal baseSurfaceArea = M_PI * (zIOverR * zIOverR);\n\t// Calculate the volume of the hemisphere's base\n\tdReal baseVolume = M_PI * (zIOverR * zIOverR) * zIOverR;\n\t// Calculate the volume of the hemisphere\n\tdReal volumeHemisphere = volume - baseVolume;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeBase = volumeHemisphere - baseVolume;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeTop = volumeHemisphere - volumeBase;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeSide = volumeHemisphere - volumeTop;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeBottom = volumeHemisphere - volumeSide;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeTopSide = volumeHemisphere - volumeTop - volumeSide;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeBottomSide = volumeHemisphere - volumeBottom - volumeSide;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeTopBottomSide = volumeHemisphere - volumeTop - volumeBottom - volumeSide;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeSideTopBottom = volumeHemisphere - volumeSide - volumeTop - volumeBottom;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeTopSideBottom = volumeHemisphere - volumeTop - volumeSide - volumeBottom;\n\t// Calculate the volume of the hemisphere's base\n\tdReal volumeTopBottom = volumeHemisphere - volumeTop - volumeBottom;\n\t// Calculate the volume of the hemis", "CodeBleu_score": 36.15860765695479}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const    dReal xBuoyancyCenter = 0;\n    dReal x0 = 0;\n    dReal x1 = 0;\n    dReal x2 = 0;\n    dReal x3 = 0;\n    dReal x4 = 0;\n    dReal x5 = 0;\n    dReal x6 = 0;\n    dReal x7 = 0;\n    dReal x8 = 0;\n    dReal x9 = 0;\n    dReal x10 = 0;\n    dReal x11 = 0;\n    dReal x12 = 0;\n    dReal x13 = 0;\n    dReal x14 = 0;\n    dReal x15 = 0;\n    dReal x16 = 0;\n    dReal x17 = 0;\n    dReal x18 = 0;\n    dReal x19 = 0;\n    dReal x20 = 0;\n    dReal x21 = 0;\n    dReal x22 = 0;\n    dReal x23 = 0;\n    dReal x24 = 0;\n    dReal x25 = 0;\n    dReal x26 = 0;\n    dReal x27 = 0;\n    dReal x28 = 0;\n    dReal x29 = 0;\n    dReal x30 = 0;\n    dReal x31 = 0;\n    dReal x32 = 0;\n    dReal x33 = 0;\n    dReal x34 = 0;\n    dReal x35 = 0;\n    dReal x36 = 0;\n    dReal x37 = 0;\n    dReal x38 = 0;\n    dReal x39 = 0;\n    dReal x40 = 0;\n    dReal x41 = 0;\n    dReal x42 = 0;\n    dReal x43 = 0;\n    dReal x44 = 0;\n    dReal x45 = 0;\n    dReal", "CodeBleu_score": 10.079301783264274}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal x = 0;\n\tdReal h = 0;\n\tdReal x0 = 0;\n\tdReal x1 = 0;\n\tdReal x2 = 0;\n\tdReal x3 = 0;\n\tdReal x4 = 0;\n\tdReal x5 = 0;\n\tdReal x6 = 0;\n\tdReal x7 = 0;\n\tdReal x8 = 0;\n\tdReal x9 = 0;\n\tdReal x10 = 0;\n\tdReal x11 = 0;\n\tdReal x12 = 0;\n\tdReal x13 = 0;\n\tdReal x14 = 0;\n\tdReal x15 = 0;\n\tdReal x16 = 0;\n\tdReal x17 = 0;\n\tdReal x18 = 0;\n\tdReal x19 = 0;\n\tdReal x20 = 0;\n\tdReal x21 = 0;\n\tdReal x22 = 0;\n\tdReal x23 = 0;\n\tdReal x24 = 0;\n\tdReal x25 = 0;\n\tdReal x26 = 0;\n\tdReal x27 = 0;\n\tdReal x28 = 0;\n\tdReal x29 = 0;\n\tdReal x30 = 0;\n\tdReal x31 = 0;\n\tdReal x32 = 0;\n\tdReal x33 = 0;\n\tdReal x34 = 0;\n\tdReal x35 = 0;\n\tdReal x36 = 0;\n\tdReal x37 = 0;\n\tdReal x38 = 0;\n\tdReal x39 = 0;\n\tdReal x40 = 0;\n\tdReal x41 = 0;\n\tdReal x42 = 0;\n\tdReal x43 = 0;\n\tdReal x44 = 0;\n\tdReal x45 = 0", "CodeBleu_score": 9.732750739290118}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdVector3 normal;\n\tdVector3 center;\n\tdVector3 v1;\n\tdVector3 v2;\n\tdVector3 v3;\n\tdVector3 v4;\n\tdVector3 v5;\n\tdVector3 v6;\n\tdVector3 v7;\n\tdVector3 v8;\n\tdVector3 v9;\n\tdVector3 v10;\n\tdVector3 v11;\n\tdVector3 v12;\n\tdVector3 v13;\n\tdVector3 v14;\n\tdVector3 v15;\n\tdVector3 v16;\n\tdVector3 v17;\n\tdVector3 v18;\n\tdVector3 v19;\n\tdVector3 v20;\n\tdVector3 v21;\n\tdVector3 v22;\n\tdVector3 v23;\n\tdVector3 v24;\n\tdVector3 v25;\n\tdVector3 v26;\n\tdVector3 v27;\n\tdVector3 v28;\n\tdVector3 v29;\n\tdVector3 v30;\n\tdVector3 v31;\n\tdVector3 v32;\n\tdVector3 v33;\n\tdVector3 v34;\n\tdVector3 v35;\n\tdVector3 v36;\n\tdVector3 v37;\n\tdVector3 v38;\n\tdVector3 v39;\n\tdVector3 v40;\n\tdVector3 v41;\n\tdVector3 v42;\n\tdVector3 v43;\n\tdVector3 v44;\n\tdVector3 v45;\n\tdVector3 v46;\n\tdVector3 v47;\n\tdVector3 v48;\n\tdVector3 v49;\n\tdVector3 v50;\n\tdVector3 v51;\n\tdVector3 v52;\n\tdVector3 v53;\n\tdVector3 v54;\n\tdVector3 v55;\n\tdVector3 v56;\n\tdVector", "CodeBleu_score": 5.27290603549485}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\n    // Check the inputs.\n    if (o1->type != dTriMeshClass) {\n        dDebug (0,\"dImmerseCapsuleTrimesh: argument 1 not a trimesh\\n\");\n        return 0;\n    }\n    if (o2->type != dCapsuleClass) {\n        dDebug (0,\"dImmerseCapsuleTrimesh: argument 2 not a capsule\\n\");\n        return 0;\n    }\n\n    // Get the capsule's data.\n    dCapsule *capsule = (dCapsule*) o2;\n    dReal r = capsule->radius;\n    dReal l = capsule->lz;\n    dReal rl = r + l;\n    dReal rr = r - l;\n    dReal rr2 = rr * rr;\n    dReal rl2 = rl * rl;\n    dReal l2 = l * l;\n    dReal rl2_l2 = rl2 - l2;\n    dReal rr2_l2 = rr2 - l2;\n    dReal rl2_l = rl2 - l;\n    dReal rr2_l = rr2 - l;\n    dReal rr_rl = rr - rl;\n    dReal rl_rr = rl - rr;\n    dReal rr_rl_2 = rr_rl * rr_rl;\n    dReal rl_rr_2 = rl_rr * rl_rr;\n    dReal rl_rr_2_2 = rl_rr_2 * rl_rr_2;\n    dReal rr_rl_2_2 = rr_rl_2 * rr_rl_2;\n    dReal rl_rr_2_2_2 = rl_rr_2_2 * rl_rr_2_2;\n    dReal rr_rl_2_2_2 = rr_rl_2_2 * rr_rl_2_2;\n    dReal rl_rr_2_2_2_2 = rl_rr_", "CodeBleu_score": 31.011949281455497}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdIASSERT (SAFE_CONTACT(immersion,1));\n\tdIASSERT (o1->type == dCapsuleClass);\n\tdIASSERT (o2->type == dTriMeshClass);\n\n\tdxCapsule *capsule = (dxCapsule*) o1;\n\tdxTriMesh *mesh = (dxTriMesh*) o2;\n\n\tdVector3 c1, c2;\n\tdVector3 c1a, c1b;\n\tdVector3 c2a, c2b;\n\tdVector3 p1, p2;\n\tdVector3 p1a, p1b;\n\tdVector3 p2a, p2b;\n\tdVector3 n1, n2;\n\tdVector3 n1a, n1b;\n\tdVector3 n2a, n2b;\n\tdReal depth;\n\tdReal depth_ratio;\n\tdReal t1, t2;\n\tdReal s1, s2;\n\tdReal s1a, s1b;\n\tdReal s2a, s2b;\n\tdReal volume;\n\tdReal volume_ratio;\n\tdReal x;\n\tdReal x_ratio;\n\tdReal x_buoyancy_center;\n\tdReal x_buoyancy_center_scaled;\n\tdReal x_buoyancy_center_adjusted;\n\tdReal x_buoyancy_center_scaled_adjusted;\n\tdReal x_buoyancy_center_scaled_adjusted_volume;\n\n\tdVector3 p;\n\tdVector3 n;\n\tdVector3 d;\n\tdVector3 c;\n\tdVector3 a;\n\tdVector3 b;\n\tdVector3 x_buoyancy_center_array[2];\n\tdVector3 x_buoyancy_center_scaled_array[2];\n\tdVector3 x_buoyancy_center_scaled_adjusted_array[2];\n\tdVector3 x_buoyancy_center_scaled_adjusted_volume_array[2];\n\td", "CodeBleu_score": 26.059341073937926}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()  if (!getInput<double>(\"duration\", &duration_)) {\n    return NodeStatus::SUCCESS;\n  }\n  if (duration_ <= 0.0) {\n    return NodeStatus::SUCCESS;\n  }\n  timer_ = std::make_shared<Timer>();\n  timer_->setCallback([this]() {\n    if (timer_waiting_) {\n      return;\n    }\n    timer_waiting_ = true;\n    emitStatusMsg(StatusMsg::WAKE_UP);\n    timer_waiting_ = false;\n  });\n  timer_->start(duration_);\n  return NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 47.79970168787353}, {"code": "NodeStatus SleepNode::onStart()  if (input(\"duration\").isEmpty()) {\n    return NodeStatus::SUCCESS;\n  }\n  const double duration = input(\"duration\").value().asDouble();\n  if (duration <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_waiting_ = true;\n  timer_.start(duration, [this]() {\n    timer_waiting_ = false;\n    emitSignal(\"wake-up\");\n  });\n  return NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 47.728592724133804}, {"code": "NodeStatus SleepNode::onStart()    // Retrieve the sleep duration from the input.\n    std::string sleep_duration;\n    if (getInput<std::string>(\"duration\", sleep_duration)) {\n        // If the duration is missing or non-positive, return SUCCESS.\n        if (sleep_duration.empty() || sleep_duration == \"0\") {\n            return NodeStatus::SUCCESS;\n        }\n\n        // Set the node status to RUNNING.\n        setStatus(NodeStatus::RUNNING);\n\n        // Start a timer.\n        timer_ = std::make_shared<rclcpp::WallTimer<SleepNode>>(\n            std::chrono::milliseconds(std::stoi(sleep_duration)), this);\n\n        // Set a callback to emit a wake-up signal when the timer expires.\n        timer_->setCallback(\n            [this]() {\n                // Ensure the timer_waiting_ flag is reset.\n                timer_waiting_ = false;\n\n                // Emit a wake-up signal.\n                wake_up_signal_->publish(std::make_unique<std_msgs::msg::Empty>());\n            });\n\n        // Start the timer.\n        timer_->reset();\n\n        return NodeStatus::RUNNING;\n    }\n\n    return NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 44.423104503424824}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()\tif (blackboard.contains(entry_name)) {\n\t\tstd::lock_guard<std::mutex> lock(blackboard.getEntryMutex(entry_name));\n\t\tif (blackboard.getEntrySequenceID(entry_name) == sequence_id) {\n\t\t\treturn NodeStatus::FAILURE;\n\t\t}\n\t\telse {\n\t\t\tsequence_id = blackboard.getEntrySequenceID(entry_name);\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\telse {\n\t\treturn NodeStatus::FAILURE;\n\t}\n}\n", "CodeBleu_score": 45.33733949147513}, {"code": "NodeStatus EntryUpdatedAction::tick()    Entry<int> *entry = blackboard->getEntry<int>(entryName);\n    if (entry != nullptr) {\n        std::lock_guard<std::mutex> lock(entry->mutex);\n        if (entry->value != sequenceID) {\n            sequenceID = entry->value;\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 31.193099360609565}, {"code": "NodeStatus EntryUpdatedAction::tick()    Entry *entry = blackboard->getEntry(entryName);\n    if (entry != nullptr) {\n        std::lock_guard<std::mutex> lock(entry->mutex);\n        if (entry->sequenceID != sequenceID) {\n            sequenceID = entry->sequenceID;\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 33.83015108167455}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const    if (successThreshold_ < 0) {\n        return (size_t) (successThreshold_ * (double) children.size());\n    }\n    return successThreshold_;\n}\n", "CodeBleu_score": 51.41524859610368}, {"code": "size_t ParallelNode::successThreshold() const\tif (successThreshold_ < 0) {\n\t\treturn (size_t) (successThreshold_ * children.size());\n\t}\n\treturn successThreshold_;\n}\n", "CodeBleu_score": 47.91947354137734}, {"code": "size_t ParallelNode::successThreshold() const\tif (successThreshold_ < 0) {\n\t\treturn (size_t)(-successThreshold_ * getNumChildren());\n\t}\n\treturn successThreshold_;\n}\n", "CodeBleu_score": 45.40328219227261}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        if (Groot2Publisher::heartbeatStatus == Groot2Publisher::HEARTBEAT_ACTIVE) {\n            if (Groot2Publisher::heartbeatTime.elapsed() > Groot2Publisher::HEARTBEAT_TIMEOUT) {\n                Groot2Publisher::heartbeatStatus = Groot2Publisher::HEARTBEAT_INACTIVE;\n                Groot2Publisher::enableAllBreakpoints();\n            }\n        }\n        else if (Groot2Publisher::heartbeatStatus == Groot2Publisher::HEARTBEAT_INACTIVE) {\n            if (Groot2Publisher::heartbeatTime.elapsed() < Groot2Publisher::HEARTBEAT_TIMEOUT) {\n                Groot2Publisher::heartbeatStatus = Groot2Publisher::HEARTBEAT_ACTIVE;\n                Groot2Publisher::disableAllBreakpoints();\n            }\n        }\n        usleep(10000);\n    }\n}\n", "CodeBleu_score": 28.472777067755274}, {"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();\n        std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();\n        std::chrono::duration<double> elapsed_seconds = end - begin;\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        end = std::chrono::steady_clock::now();\n        elapsed_seconds = end - begin;\n        if (elapsed_seconds.count() >= 1) {\n            if (heartbeatStatus == true) {\n                if (lastHeartbeatTime + 1000 < std::chrono::steady_clock::now().time_since_epoch().count()) {\n                    heartbeatStatus = false;\n                    std::cout << \"Groot2Publisher::heartbeatLoop: Heartbeat status has changed to false.\" << std::endl;\n                }\n            } else {\n                if (lastHeartbeatTime + 1000 < std::chrono::steady_clock::now().time_since_epoch().count()) {\n                    heartbeatStatus = true;\n                    std::cout << \"Groot2Publisher::heartbeatLoop: Heartbeat status has changed to true.\" << std::endl;\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 39.289350158788196}, {"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        if (lastHeartbeatTime.time_since_epoch().count() > 0) {\n            if (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() - lastHeartbeatTime.time_since_epoch().count() > 1000) {\n                if (heartbeatStatus == true) {\n                    std::cout << \"Heartbeat is not active. Disabling breakpoints.\" << std::endl;\n                    heartbeatStatus = false;\n                    disableAllBreakpoints();\n                }\n            }\n            else {\n                if (heartbeatStatus == false) {\n                    std::cout << \"Heartbeat is active. Enabling breakpoints.\" << std::endl;\n                    heartbeatStatus = true;\n                    enableAllBreakpoints();\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 35.83905903246658}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<uint8_t> bb_dump;\n    std::vector<std::string> bb_list_vec;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    while (std::getline(ss, bb_name, ',')) {\n        bb_list_vec.push_back(bb_name);\n    }\n    std::vector<uint8_t> bb_json;\n    std::vector<uint8_t> bb_json_str;\n    std::vector<uint8_t> bb_json_dump;\n    for (auto& bb_name : bb_list_vec) {\n        // Lock the blackboard\n        if (groot2_->lockBlackboard(bb_name, true)) {\n            // Export the blackboard to JSON\n            bb_json = groot2_->exportBlackboard(bb_name);\n            // Convert the JSON to string\n            bb_json_str = json2str(bb_json);\n            // Convert the string to MessagePack\n            bb_json_dump = str2msgpack(bb_json_str);\n            // Add the MessagePack to the dump\n            bb_dump.insert(bb_dump.end(), bb_json_dump.begin(), bb_json_dump.end());\n        }\n    }\n    return bb_dump;\n}\n", "CodeBleu_score": 43.59671416818668}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<uint8_t> dump;\n\n    // Create a JSON object to hold the blackboards\n    json bb_json;\n\n    // Split the input string of blackboard names\n    std::vector<std::string> bb_names;\n    std::stringstream ss(bb_list);\n    std::string item;\n    while (std::getline(ss, item, ',')) {\n        bb_names.push_back(item);\n    }\n\n    // Iterate through the blackboard names\n    for (auto& bb_name : bb_names) {\n        // Lock the blackboard subtree\n        if (!groot2_->lockSubtree(bb_name)) {\n            // If the subtree is not valid, skip it\n            continue;\n        }\n\n        // Export the blackboard to JSON\n        json bb_json_tmp = groot2_->exportBlackboard(bb_name);\n\n        // Add the blackboard to the JSON object\n        bb_json[bb_name] = bb_json_tmp;\n\n        // Unlock the blackboard subtree\n        groot2_->unlockSubtree(bb_name);\n    }\n\n    // Convert the JSON object to MessagePack format\n    dump = json::to_msgpack(bb_json);\n\n    return dump;\n}\n", "CodeBleu_score": 45.235195437711496}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    // Initialize the JSON object.\n    json j;\n\n    // Iterate through the blackboard names.\n    for (const auto& bb_name : split(bb_list, ',')) {\n        // Get the subtree.\n        const auto* subtree = getSubtree(bb_name);\n\n        // If the subtree is not valid, skip it.\n        if (!subtree) {\n            continue;\n        }\n\n        // Lock the subtree.\n        subtree->lock();\n\n        // If the subtree is not valid, skip it.\n        if (!subtree) {\n            continue;\n        }\n\n        // Export the blackboard to JSON.\n        j[bb_name] = subtree->toJSON();\n    }\n\n    // Convert the JSON object to MessagePack format.\n    std::vector<uint8_t> data(j.dump().begin(), j.dump().end());\n\n    // Return the MessagePack format.\n    return data;\n}\n", "CodeBleu_score": 42.249516123590546}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  std::unique_lock<std::mutex> lock(mutex);\n  if (nodes.find(node_uid) == nodes.end()) {\n    return false;\n  }\n  if (!nodes[node_uid].valid) {\n    return false;\n  }\n  if (nodes[node_uid].hook_pos != pos) {\n    return false;\n  }\n  if (nodes[node_uid].hook_status != BREAKPOINT) {\n    return false;\n  }\n  nodes[node_uid].hook_status = result;\n  nodes[node_uid].hook_remove = remove;\n  nodes[node_uid].hook_ready = true;\n  nodes[node_uid].hook_cv.notify_all();\n  return true;\n}\n", "CodeBleu_score": 40.71244662489065}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  Groot2Hook *hook;\n  bool ret = false;\n\n  if (pos < 0 || pos >= GROOT2_MAX_HOOKS) {\n    return ret;\n  }\n\n  if (hooks[pos] == NULL) {\n    return ret;\n  }\n\n  hook = hooks[pos];\n  if (hook->node_uid != node_uid) {\n    return ret;\n  }\n\n  if (hook->valid == false) {\n    return ret;\n  }\n\n  std::lock_guard<std::mutex> lock(hook->mutex);\n\n  if (hook->status != BREAKPOINT) {\n    return ret;\n  }\n\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->cv.notify_all();\n  ret = true;\n\n  return ret;\n}\n", "CodeBleu_score": 44.19224933087828}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  std::lock_guard<std::mutex> lock(mutex_);\n  // Check if the node exists and is valid\n  if (nodes_.find(node_uid) == nodes_.end()) {\n    return false;\n  }\n  Node &node = nodes_[node_uid];\n  if (node.pos != pos || !node.valid) {\n    return false;\n  }\n  // Retrieve the associated hook and lock its mutex\n  Hook &hook = node.hooks[pos];\n  std::lock_guard<std::mutex> hook_lock(hook.mutex);\n  // Check if the hook is in BREAKPOINT mode\n  if (hook.status != BREAKPOINT) {\n    return false;\n  }\n  // Set the desired status and removal flag\n  hook.result = result;\n  hook.remove = remove;\n  // Mark it as ready and notify all waiting threads\n  hook.ready = true;\n  hook.cv.notify_all();\n  return true;\n}\n", "CodeBleu_score": 49.84813708915503}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()  // If the node is IDLE, start a new thread to run the tick function\n  if (status() == NodeStatus::IDLE) {\n    halt_requested_ = false;\n    thread_ = std::thread(&BT::ThreadedAction::executeTickThread, this);\n  }\n\n  // If the tick function has completed without a halt request, update the node status\n  if (!halt_requested_) {\n    if (thread_.joinable()) {\n      thread_.join();\n    }\n    return status();\n  }\n\n  // If an exception occurs, log an error and set the node status to IDLE\n  if (exception_ptr_) {\n    std::stringstream ss;\n    ss << \"Exception occurred in \" << name() << \" tick function:\\n\";\n    try {\n      std::rethrow_exception(exception_ptr_);\n    } catch (const std::exception& e) {\n      ss << e.what();\n    }\n    BT::Logger::get()->write(ss.str());\n    exception_ptr_ = nullptr;\n    status() = NodeStatus::IDLE;\n  }\n\n  // Check for any stored exceptions and rethrow them if present\n  if (exception_ptr_) {\n    std::stringstream ss;\n    ss << \"Exception occurred in \" << name() << \" tick function:\\n\";\n    try {\n      std::rethrow_exception(exception_ptr_);\n    } catch (const std::exception& e) {\n      ss << e.what();\n    }\n    BT::Logger::get()->write(ss.str());\n    exception_ptr_ = nullptr;\n  }\n\n  // Return the current status of the node\n  return status();\n}\n", "CodeBleu_score": 50.48644692147708}, {"code": "NodeStatus BT::ThreadedAction::executeTick()    if (status_ == IDLE) {\n        status_ = RUNNING;\n        halt_requested_ = false;\n        std::thread t(&BT::ThreadedAction::executeTickThread, this);\n        t.detach();\n    }\n    if (halt_requested_) {\n        halt_requested_ = false;\n        status_ = IDLE;\n        return IDLE;\n    }\n    if (exception_ptr_) {\n        std::rethrow_exception(exception_ptr_);\n    }\n    return status_;\n}\n", "CodeBleu_score": 29.606829842062005}, {"code": "NodeStatus BT::ThreadedAction::executeTick()  NodeStatus status = NodeStatus::IDLE;\n  if (status == NodeStatus::IDLE) {\n    status = NodeStatus::RUNNING;\n    halt_requested_ = false;\n    std::thread t(&BT::ThreadedAction::tick, this);\n    t.detach();\n  }\n\n  if (status == NodeStatus::RUNNING) {\n    if (!halt_requested_) {\n      status = NodeStatus::SUCCESS;\n    } else {\n      status = NodeStatus::FAILURE;\n    }\n  }\n\n  if (status == NodeStatus::SUCCESS) {\n    try {\n      rethrow_if_nested(exception_);\n    } catch (const std::exception &e) {\n      RCLCPP_ERROR(\n          rclcpp::get_logger(\"BT\"),\n          \"Exception thrown from the tick() function of node %s: %s\",\n          name_.c_str(), e.what());\n      status = NodeStatus::FAILURE;\n    }\n  }\n\n  return status;\n}\n", "CodeBleu_score": 41.09747392425774}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    stream << \"\\n\";\n    for (int i = 0; i < root_node->depth; i++) {\n        stream << \" \";\n    }\n    stream << root_node->name << std::endl;\n    for (const auto& child : root_node->children) {\n        printTreeRecursively(child.get(), stream);\n    }\n    stream << \"\\n\";\n}\n", "CodeBleu_score": 26.31986180466585}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    auto print_node = [&](const TreeNode* node) {\n        stream << std::string(node->depth, ' ') << node->name << std::endl;\n        if (node->type == NodeType::Control) {\n            for (auto child : node->children) {\n                print_node(child);\n            }\n        }\n        else if (node->type == NodeType::Decorator) {\n            print_node(node->child);\n        }\n    };\n\n    stream << std::string(root_node->depth, ' ') << \"Root\" << std::endl;\n    print_node(root_node);\n    stream << std::string(root_node->depth, ' ') << \"End\" << std::endl;\n}\n", "CodeBleu_score": 34.101268781344054}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    std::function<void(const TreeNode*, int)> print_tree = [&print_tree, &stream](const TreeNode* node, int depth) {\n        stream << std::string(depth * 2, ' ') << node->getName() << std::endl;\n        if (node->getType() == TreeNode::Type::CONTROL) {\n            for (auto child : node->getChildren()) {\n                print_tree(child, depth + 1);\n            }\n        } else if (node->getType() == TreeNode::Type::DECORATOR) {\n            print_tree(node->getChild(), depth + 1);\n        }\n    };\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    print_tree(root_node, 0);\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}\n", "CodeBleu_score": 40.949111093803324}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr) {\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n  }\n\n  visitor(node);\n\n  if (node->type() == TreeNode::Type::CONTROL) {\n    for (const auto& child : node->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->type() == TreeNode::Type::DECORATOR) {\n    applyRecursiveVisitor(node->child(), visitor);\n  }\n}\n", "CodeBleu_score": 47.67062973247743}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr) {\n    throw LogicError(\"Cannot apply a visitor to a null node\");\n  }\n  visitor(node);\n  if (node->isControlNode()) {\n    for (const TreeNode* child : node->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->isDecoratorNode()) {\n    applyRecursiveVisitor(node->child(), visitor);\n  }\n}\n", "CodeBleu_score": 46.45525496856872}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)    if (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: node is null\");\n    }\n    visitor(node);\n    if (node->isControlNode()) {\n        for (const TreeNode* child : node->asControlNode()->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (node->isDecoratorNode()) {\n        applyRecursiveVisitor(node->asDecoratorNode()->child(), visitor);\n    }\n}\n", "CodeBleu_score": 47.41059978252472}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    if (m_builders.find(manifest.getRegistrationId()) != m_builders.end()) {\n        throw BehaviorTreeException(\"NodeBuilder with ID \" + manifest.getRegistrationId() + \" already registered!\");\n    }\n    m_builders.insert(std::make_pair(manifest.getRegistrationId(), builder));\n    m_manifests.insert(std::make_pair(manifest.getRegistrationId(), manifest));\n}\n", "CodeBleu_score": 48.150194595022334}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)  if (m_builders.find(manifest.getRegistrationID()) != m_builders.end()) {\n    throw BehaviorTreeException(\n        \"A builder with the same ID already exists. \"\n        \"Please change the registration ID.\");\n  }\n\n  m_builders.insert(std::make_pair(manifest.getRegistrationID(), builder));\n  m_manifests.insert(std::make_pair(manifest.getRegistrationID(), manifest));\n}\n", "CodeBleu_score": 45.36659828004935}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)  if (builders.find(manifest.getRegistrationID()) != builders.end()) {\n    throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder: \"\n                                \"Registration ID already exists\");\n  }\n  builders.insert(std::make_pair(manifest.getRegistrationID(), builder));\n  manifests.insert(std::make_pair(manifest.getRegistrationID(), manifest));\n}\n", "CodeBleu_score": 45.46806186868053}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  registerSimpleAction(ID, tick_functor, std::move(ports),\n                       SimpleActionNode::default_config());\n}\n", "CodeBleu_score": 27.528899317830724}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  auto builder = [tick_functor](const BT::NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(config, tick_functor);\n  };\n  registerBuilder(ID, builder, ports);\n}\n", "CodeBleu_score": 41.44308733155797}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  registerBuilder(\n      ID, [tick_functor](const BT::NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(config, tick_functor);\n      },\n      std::move(ports));\n}\n", "CodeBleu_score": 39.41145285233192}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.GetSubtrees().size());\n    for (const auto& subtree : tree.GetSubtrees()) {\n        auto backup = std::make_shared<Blackboard>(subtree->GetBlackboard());\n        backups.push_back(backup);\n    }\n    return backups;\n}\n", "CodeBleu_score": 52.24819323192607}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.GetSubtrees().size());\n    for (const auto& subtree : tree.GetSubtrees()) {\n        Blackboard::Ptr backup = std::make_shared<Blackboard>();\n        backup->Clone(subtree->GetBlackboard());\n        backups.push_back(backup);\n    }\n    return backups;\n}\n", "CodeBleu_score": 51.05795548243135}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> blackboard_backups;\n\tblackboard_backups.reserve(tree.GetSubtrees().size());\n\tfor (const auto& subtree : tree.GetSubtrees()) {\n\t\tBlackboard::Ptr blackboard_backup = std::make_shared<Blackboard>();\n\t\tblackboard_backup->Clone(subtree->GetBlackboard());\n\t\tblackboard_backups.push_back(blackboard_backup);\n\t}\n\treturn blackboard_backups;\n}\n", "CodeBleu_score": 48.00021553426116}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (!executor)\n\t\treturn nonstd::make_unexpected(executor.error());\n\treturn executor.value().Execute(env);\n}\n", "CodeBleu_score": 64.20376971822148}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if (executor) {\n        return executor->Execute(env);\n    }\n    else {\n        return nonstd::make_unexpected(executor.error());\n    }\n}\n", "CodeBleu_score": 81.68954276887203}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if (executor) {\n        return executor.value().Execute(env);\n    }\n    return executor.error();\n}\n", "CodeBleu_score": 62.81628829969922}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)  std::unique_lock<std::mutex> lock(mutex);\n  if (loaded) {\n    throw RuntimeError(\"SharedLibrary::load: library already loaded\");\n  }\n  void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle) {\n    const char* err = dlerror();\n    throw RuntimeError(std::string(\"SharedLibrary::load: \") + err);\n  }\n  this->path = path;\n  loaded = true;\n}\n", "CodeBleu_score": 60.17579001136561}, {"code": "void SharedLibrary::load(const std::string& path, int)    std::lock_guard<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded.\");\n    }\n    library = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!library) {\n        const char* error = dlerror();\n        throw RuntimeError(std::string(\"Failed to load library: \") + error);\n    }\n    this->path = path;\n    loaded = true;\n}\n", "CodeBleu_score": 58.3797759804749}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (isLoaded()) {\n\t\tthrow RuntimeError(\"Library already loaded.\");\n\t}\n\tlibrary = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (library == nullptr) {\n\t\tconst char* error = dlerror();\n\t\tthrow RuntimeError(std::string(\"Failed to load library: \") + error);\n\t}\n\tthis->path = path;\n}\n", "CodeBleu_score": 56.337039478892805}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    if (str.size() < 3) return false;\n    StringView stripped = str.trim();\n    if (stripped.size() < 3) return false;\n    if (stripped.front() != '{' || stripped.back() != '}') return false;\n    if (stripped_pointer) *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    return true;\n}\n", "CodeBleu_score": 22.103310378515978}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    if (str.size() < 3) {\n        return false;\n    }\n    StringView stripped = str.substr(1, str.size() - 2);\n    if (stripped_pointer != nullptr) {\n        *stripped_pointer = stripped;\n    }\n    return stripped.starts_with('{') && stripped.ends_with('}');\n}\n", "CodeBleu_score": 23.353647993826748}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.length() < 3)\n\t\treturn false;\n\tStringView stripped = str.strip();\n\tif (stripped.length() < 3)\n\t\treturn false;\n\tif (stripped[0] != '{' || stripped[stripped.length() - 1] != '}')\n\t\treturn false;\n\tif (stripped_pointer != nullptr)\n\t\t*stripped_pointer = stripped.substr(1, stripped.length() - 2);\n\treturn true;\n}\n", "CodeBleu_score": 21.944774916552667}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  double line_cost = 0.0;\n  double point_cost = 0.0;\n  int x = x0;\n  int y = y0;\n  // Create a line iterator to iterate through the line\n  LineIterator it(x0, y0, x1, y1);\n  // Iterate through the line\n  while (it.isValid()) {\n    // Calculate the point cost\n    point_cost = getPointCost(x, y);\n    // If the point cost is negative, return immediately\n    if (point_cost < 0.0)\n      return point_cost;\n    // Update the line cost if the point cost is higher\n    if (point_cost > line_cost)\n      line_cost = point_cost;\n    // Increment the line iterator\n    it.increment();\n    // Update the point coordinates\n    x = it.getX();\n    y = it.getY();\n  }\n  // Return the line cost\n  return line_cost;\n}\n", "CodeBleu_score": 59.227122818279575}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  // Initialize the line cost\n  double line_cost = 0;\n\n  // Iterate through each point on the line\n  for (LineIterator it(x0, y0, x1, y1); it != it.end(); ++it) {\n    // Calculate the point cost\n    double point_cost = pointCost(*it);\n\n    // If the point cost is negative, return the point cost immediately\n    if (point_cost < 0) {\n      return point_cost;\n    }\n\n    // Otherwise, update the line cost if the point cost is higher\n    else if (point_cost > line_cost) {\n      line_cost = point_cost;\n    }\n  }\n\n  // Return the total line cost\n  return line_cost;\n}\n", "CodeBleu_score": 65.81827724929217}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble cost = 0;\n\tdouble pointCost = 0;\n\tdouble lineCost = 0;\n\tLineIterator lineIterator(x0, y0, x1, y1);\n\twhile (lineIterator.isValid()) {\n\t\tpointCost = pointCost(lineIterator.getX(), lineIterator.getY());\n\t\tif (pointCost < 0) {\n\t\t\treturn pointCost;\n\t\t}\n\t\tlineCost += pointCost;\n\t\tlineIterator.increment();\n\t}\n\treturn lineCost;\n}\n", "CodeBleu_score": 58.922272938472986}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.empty()) {\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.header.stamp = path[0].header.stamp;\n\tgui_path.header.frame_id = path[0].header.frame_id;\n\tfor (auto& pose : path) {\n\t\tgeometry_msgs::PoseStamped ps;\n\t\tps.header.stamp = pose.header.stamp;\n\t\tps.header.frame_id = pose.header.frame_id;\n\t\tps.pose = pose.pose;\n\t\tgui_path.poses.push_back(ps);\n\t}\n\tpub.publish(gui_path);\n}\n", "CodeBleu_score": 54.53897833801143}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.empty()) {\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.header.stamp = path.front().header.stamp;\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tfor (auto& pose : path) {\n\t\tgeometry_msgs::PoseStamped ps;\n\t\tps.header.stamp = pose.header.stamp;\n\t\tps.header.frame_id = pose.header.frame_id;\n\t\tps.pose = pose.pose;\n\t\tgui_path.poses.push_back(ps);\n\t}\n\tpub.publish(gui_path);\n}\n", "CodeBleu_score": 48.759769868892455}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)     if (path.empty()) {\n        ROS_WARN(\"The path is empty, not publishing\");\n        return;\n    }\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = path.front().header.frame_id;\n    path_msg.header.stamp = path.front().header.stamp;\n    path_msg.poses.resize(path.size());\n    std::copy(path.begin(), path.end(), path_msg.poses.begin());\n    pub.publish(path_msg);\n}\n", "CodeBleu_score": 47.70230304420318}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  return (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n          abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}\n", "CodeBleu_score": 57.898551750580715}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  return (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}\n", "CodeBleu_score": 63.79021017871749}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\n  // If the robot is stopped, return true\n  if (base_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n      base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n    return true;\n  }\n\n  // If the robot is not stopped, return false\n  return false;\n}\n", "CodeBleu_score": 47.43658205869694}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  if (restore_defaults) {\n    config.setup = false;\n    config.max_velocity_x = 1.0;\n    config.max_velocity_y = 1.0;\n    config.max_velocity_theta = 1.0;\n    config.min_velocity_x = 0.0;\n    config.min_velocity_y = 0.0;\n    config.min_velocity_theta = 0.0;\n    config.max_acceleration_x = 1.0;\n    config.max_acceleration_y = 1.0;\n    config.max_acceleration_theta = 1.0;\n    config.min_acceleration_x = 0.0;\n    config.min_acceleration_y = 0.0;\n    config.min_acceleration_theta = 0.0;\n    config.max_deceleration_x = 1.0;\n    config.max_deceleration_y = 1.0;\n    config.max_deceleration_theta = 1.0;\n    config.min_deceleration_x = 0.0;\n    config.min_deceleration_y = 0.0;\n    config.min_deceleration_theta = 0.0;\n    config.max_velocity_turning_radius = 1.0;\n    config.min_velocity_turning_radius = 0.0;\n    config.max_acceleration_turning_radius = 1.0;\n    config.min_acceleration_turning_radius = 0.0;\n    config.max_deceleration_turning_radius = 1.0;\n    config.min_deceleration_turning_radius = 0.0;\n    config.max_velocity_linear = 1.0;\n    config.min_velocity_linear = 0.0;\n    config.max_acceleration_linear = 1.0;\n    config.min_acceleration", "CodeBleu_score": 17.66840831055093}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\n    if (restore_defaults) {\n        config.max_vel_x = 0.5;\n        config.max_vel_y = 0.5;\n        config.max_vel_z = 0.5;\n        config.max_vel_xy = 0.5;\n        config.max_vel_z_up = 0.5;\n        config.max_vel_z_down = 0.5;\n        config.max_vel_turn = 0.5;\n        config.max_vel_x_backwards = 0.5;\n        config.max_acc_x = 0.5;\n        config.max_acc_y = 0.5;\n        config.max_acc_z = 0.5;\n        config.max_acc_z_up = 0.5;\n        config.max_acc_z_down = 0.5;\n        config.max_acc_turn = 0.5;\n        config.max_acc_x_backwards = 0.5;\n        config.max_jerk_x = 0.5;\n        config.max_jerk_y = 0.5;\n        config.max_jerk_z = 0.5;\n        config.max_jerk_z_up = 0.5;\n        config.max_jerk_z_down = 0.5;\n        config.max_jerk_turn = 0.5;\n        config.max_jerk_x_backwards = 0.5;\n        config.max_snap_x = 0.5;\n        config.max_snap_y = 0.5;\n        config.max_snap_z = 0.5;\n        config.max_snap_z_up = 0.5;\n        config.max_snap_z_down = 0.5;\n        config.max_snap_turn = 0.5;\n        config.max_snap_x_backwards = 0.5;\n        config.max_vel_x_snap = 0.5;\n        config.max_", "CodeBleu_score": 17.44205904160857}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  if (config.setup) {\n    if (restore_defaults) {\n      config.setup = false;\n      config.max_linear_velocity = 0.5;\n      config.max_linear_acceleration = 0.5;\n      config.max_angular_velocity = 0.5;\n      config.max_angular_acceleration = 0.5;\n      config.min_linear_velocity = 0.05;\n      config.min_linear_acceleration = 0.05;\n      config.min_angular_velocity = 0.05;\n      config.min_angular_acceleration = 0.05;\n      config.max_linear_velocity_xy = 0.5;\n      config.max_linear_acceleration_xy = 0.5;\n      config.max_angular_velocity_xy = 0.5;\n      config.max_angular_acceleration_xy = 0.5;\n      config.min_linear_velocity_xy = 0.05;\n      config.min_linear_acceleration_xy = 0.05;\n      config.min_angular_velocity_xy = 0.05;\n      config.min_angular_acceleration_xy = 0.05;\n      config.max_linear_velocity_z = 0.5;\n      config.max_linear_acceleration_z = 0.5;\n      config.max_angular_velocity_z = 0.5;\n      config.max_angular_acceleration_z = 0.5;\n      config.min_linear_velocity_z = 0.05;\n      config.min_linear_acceleration_z = 0.05;\n      config.min_angular_velocity_z = 0.05;\n      config.min_angular_acceleration_z = 0.05;\n      config.max_linear_velocity_yaw = 0.5;\n      config.max_linear_acceleration_y", "CodeBleu_score": 20.736139321233964}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  // check if the cell is an obstacle\n  if (costmap.getCost(check_cell->getX(), check_cell->getY()) == costmap_2d::NO_INFORMATION) {\n    check_cell->setTargetDistance(max_obstacle_cost);\n    return false;\n  }\n  else if (costmap.getCost(check_cell->getX(), check_cell->getY()) == costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->setTargetDistance(max_obstacle_cost);\n    return false;\n  }\n  else if (costmap.getCost(check_cell->getX(), check_cell->getY()) == costmap_2d::FREE_SPACE) {\n    check_cell->setTargetDistance(0);\n    return false;\n  }\n  else if (costmap.getCost(check_cell->getX(), check_cell->getY()) == costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->setTargetDistance(max_obstacle_cost);\n    return false;\n  }\n\n  // calculate the new target distance\n  int new_distance = current_cell->getTargetDistance() +\n                     costmap.getCost(check_cell->getX(), check_cell->getY());\n\n  // update the target distance if the new distance is shorter\n  if (new_distance < check_cell->getTargetDistance()) {\n    check_cell->setTargetDistance(new_distance);\n    return true;\n  }\n\n  // return false if the new distance is longer\n  return false;\n}\n", "CodeBleu_score": 45.87088621503037}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  // check if the cell is an obstacle\n  if (check_cell->isObstacle()) {\n    // set the target distance to the maximum obstacle cost\n    check_cell->setTargetDistance(costmap.getMaxCost());\n    return false;\n  }\n  // check if the cell has information\n  if (check_cell->hasInformation()) {\n    // check if the cell has a target distance\n    if (check_cell->hasTargetDistance()) {\n      // check if the cell's target distance is shorter than the current cell's target distance\n      if (check_cell->getTargetDistance() < current_cell->getTargetDistance()) {\n        // update the target distance\n        current_cell->setTargetDistance(check_cell->getTargetDistance());\n        return true;\n      }\n      // the cell's target distance is not shorter than the current cell's target distance\n      return false;\n    }\n    // the cell does not have a target distance\n    // check if the cell is a potential target\n    if (check_cell->isPotentialTarget()) {\n      // check if the cell's target distance is shorter than the current cell's target distance\n      if (check_cell->getTargetDistance() < current_cell->getTargetDistance()) {\n        // update the target distance\n        current_cell->setTargetDistance(check_cell->getTargetDistance());\n        return true;\n      }\n      // the cell's target distance is not shorter than the current cell's target distance\n      return false;\n    }\n    // the cell is not a potential target\n    // check if the cell is a potential obstacle\n    if (check_cell->isPotentialObstacle()) {\n      // check if the cell's target distance is shorter than the current cell's target distance\n      if (check_cell->getTargetDistance() < current_cell->getTargetDistance()) {\n        // update the target distance\n        current_cell->setTargetDistance(check_cell->getTargetDistance());\n        return true;\n      }\n      // the cell's target distance is not shorter than the current cell's target distance\n      return false;\n    }\n    // the cell is not a potential obstacle\n    // check if the", "CodeBleu_score": 34.81376418284381}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)    double new_dist = current_cell->distance_ +\n      (check_cell->x_ - current_cell->x_) * (check_cell->x_ - current_cell->x_) +\n      (check_cell->y_ - current_cell->y_) * (check_cell->y_ - current_cell->y_);\n    if (check_cell->obstacle_) {\n      check_cell->target_distance_ = std::numeric_limits<double>::max();\n      return false;\n    }\n    if (check_cell->target_distance_ > new_dist) {\n      check_cell->target_distance_ = new_dist;\n    }\n    return true;\n  }\n\n  /*\n   * This function, MapGrid::updatePathCell, updates the target distance of a cell in the pathfinding grid.\\nIt first checks the cost of the cell using the costmap.\\nIf the cell is an obstacle or has no information, it sets the cell's target distance to the maximum obstacle cost and returns false.\\nIf the cell is not an obstacle, it calculates a new target distance and updates the cell's target distance if the new distance is shorter.\\nFinally, it returns true.\n   */\n  inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap, double obstacle_cost) {\n    double new_dist = current_cell->distance_ +\n      (check_cell->x_ - current_cell->x_) * (check_cell->x_ - current_cell->x_) +\n      (check_cell->y_ - current_cell->y_) * (check_cell->y_ - current_cell->y_);\n    if (check_cell->obstacle_) {\n      check_cell->target_distance_ = obstacle_cost;\n      return false;\n    }\n    if (check_cell->target_distance_ > new_dist) {\n      check_cell->target_distance_ = new_dist;\n    }\n    return true;\n  }\n\n  /*\n   * This function, MapGrid::updatePathCell, updates the target distance of", "CodeBleu_score": 44.88447115624763}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0.0;\n  double scale = 1.0;\n  double max_cost = 0.0;\n  if (traj.empty()) {\n    ROS_ERROR(\"Trajectory is empty.\");\n    return -9.0;\n  }\n  for (size_t i = 0; i < traj.size(); ++i) {\n    if (i == 0) {\n      cost = scoreFootprint(traj[i].position, traj[i].velocity, traj[i].acceleration);\n      scale = traj[i].scale;\n    } else {\n      if (sum_scores_) {\n        cost += scoreFootprint(traj[i].position, traj[i].velocity, traj[i].acceleration);\n      } else {\n        double temp_cost = scoreFootprint(traj[i].position, traj[i].velocity, traj[i].acceleration);\n        if (temp_cost > max_cost) {\n          max_cost = temp_cost;\n        }\n      }\n    }\n  }\n  if (sum_scores_) {\n    cost *= scale;\n  } else {\n    cost = max_cost * scale;\n  }\n  return cost;\n}\n", "CodeBleu_score": 49.86795816276283}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0.0;\n  double scaling_factor = 0.0;\n  if (traj.size() == 0) {\n    ROS_ERROR(\"Trajectory is empty!\");\n    return -9.0;\n  }\n  if (traj.size() == 1) {\n    cost = scorePoint(traj[0]);\n    return cost;\n  }\n  if (traj.size() > 1) {\n    cost = scorePoint(traj[0]);\n    scaling_factor = cost;\n    for (int i = 1; i < traj.size(); i++) {\n      cost += scorePoint(traj[i]);\n      if (cost < 0.0) {\n        return cost;\n      }\n      if (sum_scores_) {\n        scaling_factor += cost;\n      } else {\n        if (cost > scaling_factor) {\n          scaling_factor = cost;\n        }\n      }\n    }\n    cost /= scaling_factor;\n  }\n  return cost;\n}\n", "CodeBleu_score": 45.085183654989244}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0;\n  double scale = 1;\n  double max_cost = 0;\n  double min_cost = 0;\n  double max_scale = 1;\n  double min_scale = 1;\n  double scale_factor = 1;\n  double scale_factor_inv = 1;\n  double footprint_cost = 0;\n  double footprint_scale = 1;\n  double footprint_scale_inv = 1;\n  double footprint_cost_inv = 1;\n  double footprint_cost_inv_scale = 1;\n  double footprint_cost_scale = 1;\n  double footprint_cost_scale_inv = 1;\n  double footprint_cost_scale_inv_scale = 1;\n  double footprint_cost_inv_scale_inv = 1;\n  double footprint_cost_inv_scale_inv_scale = 1;\n  double footprint_cost_scale_inv_scale_inv = 1;\n  double footprint_cost_scale_inv_scale_inv_scale = 1;\n  double footprint_cost_scale_inv_scale_inv_scale_inv = 1;\n  double footprint_cost_inv_scale_inv_scale_inv_scale = 1;\n  double footprint_cost_inv_scale_inv_scale_inv_scale_inv = 1;\n  double footprint_cost_inv_scale_inv_scale_inv_scale_inv_scale = 1;\n  double footprint_cost_inv_scale_inv_scale_inv_scale_inv_scale_inv = 1;\n  double footprint_cost_inv_scale_inv_scale_inv_scale_inv_scale_inv_scale = 1;\n  double footprint_cost_inv_scale_inv_scale_inv_scale_inv_scale_inv_scale_inv = 1;\n  double footprint_cost_inv_scale_inv_scale_inv_scale_inv_scale_inv_scale_inv_scale = 1;\n  double footprint_cost_inv_scale_inv_scale_inv_scale_inv_scale_inv", "CodeBleu_score": 12.351326192349909}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n    // Calculate the footprint cost\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size (); ++i) {\n        scaled_footprint.push_back (footprint_spec[i]);\n        scaled_footprint[i].x *= scale;\n        scaled_footprint[i].y *= scale;\n    }\n    double footprint_cost = world_model->footprintCost (x, y, th, scaled_footprint);\n\n    // Calculate the cell cost\n    double cell_cost = costmap->getCost (x, y);\n\n    // Return the maximum cost\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n    if (cell_cost < 0) {\n        return -7.0;\n    }\n    if (footprint_cost > cell_cost) {\n        return footprint_cost;\n    }\n    return cell_cost;\n}\n", "CodeBleu_score": 61.74429553321842}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n    // Calculate the footprint cost\n    double footprint_cost = 0.0;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        double xf = x + scale * footprint_spec[i].x * cos(th) - scale * footprint_spec[i].y * sin(th);\n        double yf = y + scale * footprint_spec[i].x * sin(th) + scale * footprint_spec[i].y * cos(th);\n        if (world_model->isFree(xf, yf)) {\n            footprint_cost += world_model->getCost(xf, yf);\n        } else {\n            footprint_cost = 1000.0;\n            break;\n        }\n    }\n\n    // Calculate the cell cost\n    double cell_cost = 0.0;\n    if (costmap->worldToMap(x, y, cell_x, cell_y)) {\n        cell_cost = costmap->getCost(cell_x, cell_y);\n    } else {\n        cell_cost = 1000.0;\n    }\n\n    // Return the maximum cost\n    if (footprint_cost < 0.0) {\n        return -6.0;\n    } else if (cell_cost < 0.0) {\n        return -7.0;\n    } else {\n        return std::max(footprint_cost, cell_cost);\n    }\n}\n", "CodeBleu_score": 61.0844624024031}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n    double footprint_cost = 0.0;\n    double cell_cost = 0.0;\n    double max_cost = 0.0;\n\n    // Transform the footprint to the robot's frame\n    std::vector<geometry_msgs::Point> footprint_in_robot_frame;\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        geometry_msgs::Point p;\n        p.x = footprint_spec[i].x * cos(th) - footprint_spec[i].y * sin(th);\n        p.y = footprint_spec[i].x * sin(th) + footprint_spec[i].y * cos(th);\n        footprint_in_robot_frame.push_back(p);\n    }\n\n    // Transform the footprint to the world frame\n    std::vector<geometry_msgs::Point> footprint_in_world_frame;\n    for (unsigned int i = 0; i < footprint_in_robot_frame.size(); i++) {\n        geometry_msgs::Point p;\n        p.x = x + footprint_in_robot_frame[i].x * scale;\n        p.y = y + footprint_in_robot_frame[i].y * scale;\n        footprint_in_world_frame.push_back(p);\n    }\n\n    // Compute the footprint cost\n    for (unsigned int i = 0; i < footprint_in_world_frame.size(); i++) {\n        footprint_cost += world_model->footprintCost(footprint_in_world_frame[i].x, footprint_in_world_frame[i].y);\n    }\n\n    // Compute the cell cost\n    cell_cost = costmap->getCost(x, y);\n\n    // Return the maximum cost between the footprint cost and the cell cost\n    if (footprint_cost < 0.0) {\n        return -6.0;\n    } else if (cell_cost < 0.0) {\n        return -7.0;\n    } else {\n", "CodeBleu_score": 56.455424918442866}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)    if (odom_topic.empty()) {\n        ROS_WARN(\"OdometryHelperRos::setOdomTopic: Empty topic, shutting down subscription\");\n        odom_sub_.shutdown();\n        return;\n    }\n    if (odom_topic == odom_topic_) {\n        ROS_WARN(\"OdometryHelperRos::setOdomTopic: Same topic, ignoring\");\n        return;\n    }\n    ROS_INFO(\"OdometryHelperRos::setOdomTopic: New topic: %s\", odom_topic.c_str());\n    odom_topic_ = odom_topic;\n    odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n}\n", "CodeBleu_score": 36.747140644012546}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic, 100, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}\n", "CodeBleu_score": 46.400809169078286}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)    if (odom_topic != odom_topic_ && odom_topic != \"\") {\n        odom_topic_ = odom_topic;\n        odom_subscriber_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else if (odom_topic == \"\") {\n        odom_subscriber_.shutdown();\n    }\n}\n", "CodeBleu_score": 44.15208083938978}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tif (pos.squaredNorm() > 10000 || prev.squaredNorm() > 10000) {\n\t\treturn;\n\t}\n\tfloat dist = (pos - prev).norm();\n\tfloat angle = std::acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n\tif (dist > 0.01 || angle > 0.01) {\n\t\toscillation_flags_[0] = false;\n\t\toscillation_flags_[1] = false;\n\t}\n}\n", "CodeBleu_score": 38.572574263091106}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)    float dist = (pos - prev).norm();\n    float angle = acos(pos.dot(prev) / (dist * prev.norm()));\n    if (dist > 0.01f && angle > 0.01f) {\n        oscillation_detected_ = false;\n        oscillation_detected_once_ = false;\n    }\n}\n", "CodeBleu_score": 31.086565090022443}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)    float distSq = (pos - prev).squaredNorm();\n    float angle = std::abs(std::acos(pos.dot(prev) / (pos.norm() * prev.norm())));\n    if (distSq > 0.00001f && angle > 0.00001f) {\n        oscillation_x_ = false;\n        oscillation_y_ = false;\n        oscillation_z_ = false;\n    }\n}\n", "CodeBleu_score": 32.35704804694761}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// Determine the grid coordinates of the point\n\tint x, y;\n\tif (!getGridCoords(pt, x, y)) return;\n\t// Check if the point is too close to its nearest neighbor\n\tif (!checkDist(pt, x, y)) return;\n\t// Calculate the grid index\n\tint idx = y * width + x;\n\t// Insert the point into the corresponding cell\n\tcells[idx].push_back(pt);\n\tnum_points++;\n}\n", "CodeBleu_score": 49.885401709114966}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)    int i = (int) (pt.x / resolution_);\n    int j = (int) (pt.y / resolution_);\n    int k = (int) (pt.z / resolution_);\n    int idx = i + j * cols_ + k * cols_ * rows_;\n    if (idx >= (int) points_.size() || idx < 0) {\n        ROS_ERROR(\"PointGrid::insert: Invalid index: %d\", idx);\n        return;\n    }\n    if (points_[idx] != NULL) {\n        //ROS_INFO(\"PointGrid::insert: Point already exists at index: %d\", idx);\n        return;\n    }\n    points_[idx] = new Point(pt);\n    //ROS_INFO(\"PointGrid::insert: Inserted point at index: %d\", idx);\n}\n", "CodeBleu_score": 38.039061047735046}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)  int i, j;\n  int x, y;\n  int index;\n  int min_index;\n  int min_distance;\n  double min_distance_squared;\n  double distance_squared;\n  double distance;\n  double x_diff, y_diff;\n  double x_diff_squared, y_diff_squared;\n  double x_diff_squared_sum, y_diff_squared_sum;\n  double x_diff_squared_sum_inv, y_diff_squared_sum_inv;\n  double x_diff_squared_sum_inv_2, y_diff_squared_sum_inv_2;\n  double x_diff_squared_sum_inv_3, y_diff_squared_sum_inv_3;\n  double x_diff_squared_sum_inv_4, y_diff_squared_sum_inv_4;\n  double x_diff_squared_sum_inv_5, y_diff_squared_sum_inv_5;\n  double x_diff_squared_sum_inv_6, y_diff_squared_sum_inv_6;\n  double x_diff_squared_sum_inv_7, y_diff_squared_sum_inv_7;\n  double x_diff_squared_sum_inv_8, y_diff_squared_sum_inv_8;\n  double x_diff_squared_sum_inv_9, y_diff_squared_sum_inv_9;\n  double x_diff_squared_sum_inv_10, y_diff_squared_sum_inv_10;\n  double x_diff_squared_sum_inv_11, y_diff_squared_sum_inv_11;\n  double x_diff_squared_sum_inv_12, y_diff_squared_sum_inv_12;\n  double x_diff_squared_sum_inv_13, y_diff_squared_sum_inv_13;\n  double x_diff_squared_sum_inv_14, y_diff_squared_sum_inv", "CodeBleu_score": 10.751907919561182}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)  Eigen::Vector3f new_vel;\n  new_vel.setZero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i] + acclimits[i] * dt) {\n      new_vel[i] = vel[i] + acclimits[i] * dt;\n    } else if (sample_target_vel[i] < vel[i] - acclimits[i] * dt) {\n      new_vel[i] = vel[i] - acclimits[i] * dt;\n    } else {\n      new_vel[i] = sample_target_vel[i];\n    }\n  }\n  return new_vel;\n}\n", "CodeBleu_score": 71.1110607535057}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      if (vel[i] + acclimits[i] * dt > sample_target_vel[i]) {\n        new_vel[i] = vel[i] + acclimits[i] * dt;\n      } else {\n        new_vel[i] = sample_target_vel[i];\n      }\n    } else if (sample_target_vel[i] < vel[i]) {\n      if (vel[i] - acclimits[i] * dt < sample_target_vel[i]) {\n        new_vel[i] = vel[i] - acclimits[i] * dt;\n      } else {\n        new_vel[i] = sample_target_vel[i];\n      }\n    } else {\n      new_vel[i] = vel[i];\n    }\n  }\n  return new_vel;\n}\n", "CodeBleu_score": 71.49928743789133}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\n    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    // Calculate the new velocities\n    for (int i = 0; i < 3; i++) {\n        // If the target velocity is greater than the current velocity\n        if (sample_target_vel[i] > vel[i]) {\n            // If the current velocity plus the acceleration limit is less than the target velocity\n            if ((vel[i] + acclimits[i]) < sample_target_vel[i]) {\n                // Increase the velocity by the acceleration limit\n                new_vel[i] = vel[i] + acclimits[i];\n            } else {\n                // Otherwise, increase the velocity by the difference between the target velocity and the current velocity\n                new_vel[i] = sample_target_vel[i];\n            }\n        } else {\n            // If the target velocity is less than the current velocity\n            if ((vel[i] - acclimits[i]) > sample_target_vel[i]) {\n                // Decrease the velocity by the acceleration limit\n                new_vel[i] = vel[i] - acclimits[i];\n            } else {\n                // Otherwise, decrease the velocity by the difference between the target velocity and the current velocity\n                new_vel[i] = sample_target_vel[i];\n            }\n        }\n    }\n\n    // Return the new velocity vector\n    return new_vel;\n}\n", "CodeBleu_score": 57.019341428105975}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)    double heading_diff = DBL_MAX;\n    double dist_to_goal = DBL_MAX;\n    double x_goal, y_goal;\n    double x_current, y_current;\n    double x_diff, y_diff;\n    double heading_to_goal;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x_cell, y_cell;\n    int x_cell_goal, y_cell_goal;\n    int x_cell_current, y_cell_current;\n    int x_cell_diff, y_cell_diff;\n    int x_cell_to_goal, y_cell_to_goal;\n    int x_cell_to_current, y_cell_to_current;\n    int x_cell_to_diff, y_cell_to_diff;\n    int x_cell_to_goal_diff, y_cell_to_goal_diff;\n    int x_cell_to_current_diff, y_cell_to_current_diff;\n    int x_cell_to_diff_diff, y_cell_to_diff_diff;\n    int x_cell_to_goal_diff_diff, y_cell_to_goal_diff_diff;\n    int x_cell_to_current_diff_diff, y_cell_to_current_diff_diff;\n    int x_cell_to_diff_diff_diff, y_cell_to_diff_diff_diff;\n    int x_cell_to_goal_diff_diff_diff, y_cell_to_goal_diff_diff_diff;\n    int x_cell_to_current_diff_diff_diff, y_cell_to_current_diff_diff_diff;", "CodeBleu_score": 9.869433577484136}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\n\t// Variables\n\tdouble heading_diff = DBL_MAX;\n\tdouble angle;\n\tdouble current_x, current_y;\n\tdouble goal_x, goal_y;\n\n\t// Iterate through the global plan in reverse\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\n\t\t// If the cell is valid\n\t\tif (global_plan[i].cell_x != -1 && global_plan[i].cell_y != -1) {\n\n\t\t\t// Get the coordinates of the cell\n\t\t\tcurrent_x = global_plan[i].x;\n\t\t\tcurrent_y = global_plan[i].y;\n\n\t\t\t// Get the coordinates of the goal point\n\t\t\tgoal_x = x + (current_x - cell_x) * CELL_SIZE;\n\t\t\tgoal_y = y + (current_y - cell_y) * CELL_SIZE;\n\n\t\t\t// Calculate the angle between the current heading and the direction to the goal point\n\t\t\tangle = atan2(goal_y - y, goal_x - x) - heading;\n\n\t\t\t// If the angle is between 0 and PI, it is in the first quadrant\n\t\t\tif (angle >= 0 && angle <= PI) {\n\n\t\t\t\t// If the angle is between 0 and PI/2, it is in the first quadrant\n\t\t\t\tif (angle >= 0 && angle <= PI / 2) {\n\n\t\t\t\t\t// If the angle is between 0 and PI/4, it is in the first quadrant\n\t\t\t\t\tif (angle >= 0 && angle <= PI / 4) {\n\n\t\t\t\t\t\t// Calculate the difference in heading\n\t\t\t\t\t\theading_diff = fabs(angle);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the angle is between PI/4 and PI/2, it is in the second quadrant\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Calculate the difference in heading\n\t\t", "CodeBleu_score": 46.162305076244095}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)    double dx, dy, dx_new, dy_new, heading_new;\n    double heading_diff = DBL_MAX;\n    int i = 0;\n    while (i < (int)path.size()) {\n        dx = path[i].x - x;\n        dy = path[i].y - y;\n        heading_new = atan2(dy, dx);\n        if (heading_new < 0) {\n            heading_new += 2 * M_PI;\n        }\n        dx_new = path[i].x - cell_x;\n        dy_new = path[i].y - cell_y;\n        if (dx_new * dx + dy_new * dy < 0.1 && heading_new > heading - M_PI / 2 && heading_new < heading + M_PI / 2) {\n            heading_diff = fabs(heading_new - heading);\n            break;\n        }\n        i++;\n    }\n    return heading_diff;\n}\n", "CodeBleu_score": 42.0776942182815}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0) {\n    ROS_DEBUG_STREAM(\"Trajectory is valid\");\n    return true;\n  }\n  ROS_WARN_STREAM(\"Trajectory is invalid with cost: \" << cost);\n  ROS_WARN_STREAM(\"Sample velocities: \" << vx_samp << \", \" << vy_samp << \", \" << vtheta_samp);\n  return false;\n}\n", "CodeBleu_score": 69.45644790010124}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  // TODO: Implement this function\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid\n  // If so, return true\n  // If not, return false\n  // Check if the trajectory is valid", "CodeBleu_score": 10.19467534482851}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0) {\n    return true;\n  } else {\n    ROS_WARN(\"Invalid trajectory: cost = %f, vx = %f, vy = %f, vtheta = %f\", cost, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }\n}\n", "CodeBleu_score": 79.80637650172498}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery: Not initialized!\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery: Costmaps not initialized!\");\n    return;\n  }\n\n  if (affected_maps_ == 0) {\n    ROS_ERROR(\"ClearCostmapRecovery: No maps specified to clear!\");\n    return;\n  }\n\n  ros::Time start_time = ros::Time::now();\n\n  if (affected_maps_ & (1 << 0)) {\n    ROS_WARN(\"ClearCostmapRecovery: Clearing global costmap\");\n    if (force_global_update_) {\n      ROS_WARN(\"ClearCostmapRecovery: Forcing global costmap update\");\n      global_costmap_->updateOrigin(global_costmap_->getOriginX(), global_costmap_->getOriginY());\n    }\n    global_costmap_->clear();\n  }\n\n  if (affected_maps_ & (1 << 1)) {\n    ROS_WARN(\"ClearCostmapRecovery: Clearing local costmap\");\n    if (force_local_update_) {\n      ROS_WARN(\"ClearCostmapRecovery: Forcing local costmap update\");\n      local_costmap_->updateOrigin(local_costmap_->getOriginX(), local_costmap_->getOriginY());\n    }\n    local_costmap_->clear();\n  }\n\n  ros::Time end_time = ros::Time::now();\n  ROS_WARN(\"ClearCostmapRecovery: Time taken: %f\", (end_time - start_time).toSec());\n}\n", "CodeBleu_score": 44.73424759524119}, {"code": "void ClearCostmapRecovery::runBehavior()  if (!isInitialized()) {\n    ROS_ERROR(\"ClearCostmapRecovery is not initialized, but it is being run!\");\n    return;\n  }\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery is not initialized, but it is being run!\");\n    return;\n  }\n\n  // Get the current time\n  ros::Time start_time = ros::Time::now();\n\n  // Check if we are clearing inside or outside the area\n  if (affected_maps_ & AFFECTED_GLOBAL_COSTMAP) {\n    ROS_WARN(\"Clearing the global costmap.\");\n    global_costmap_->clearCostmap();\n  }\n  if (affected_maps_ & AFFECTED_LOCAL_COSTMAP) {\n    ROS_WARN(\"Clearing the local costmap.\");\n    local_costmap_->clearCostmap();\n  }\n\n  // Get the current time\n  ros::Time end_time = ros::Time::now();\n\n  // Log the time taken\n  ROS_WARN(\"Clearing the costmap took %f seconds.\", (end_time - start_time).toSec());\n}\n", "CodeBleu_score": 35.30390372875789}, {"code": "void ClearCostmapRecovery::runBehavior()  // Check if the object is initialized and if the costmaps are not NULL, logging errors if these conditions are not met.\n  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery::runBehavior: The object has not been initialized, please call ClearCostmapRecovery::initialize() before using this object.\");\n    return;\n  }\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery::runBehavior: The global costmap is not set, please call ClearCostmapRecovery::setGlobalCostmap() before using this object.\");\n    return;\n  }\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery::runBehavior: The local costmap is not set, please call ClearCostmapRecovery::setLocalCostmap() before using this object.\");\n    return;\n  }\n\n  // Depending on the invert_area_to_clear_ flag, it logs a warning about clearing inside or outside a specified area.\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing outside the specified area.\");\n  } else {\n    ROS_WARN(\"ClearCostmapRecovery::runBehavior: Clearing inside the specified area.\");\n  }\n\n  // Clear the global and/or local costmap based on the affected_maps_ setting, optionally forcing an update, and logs the time taken for each operation.\n  if (affected_maps_ & AFFECTED_GLOBAL_COSTMAP) {\n    ros::WallTime start = ros::WallTime::now();\n    if (force_global_update_) {\n      global_costmap_->resetLayers();\n    }\n    global_costmap_->clearNonFree(invert_area_to_clear_);\n    ros::WallTime end = ros::WallTime::now();\n    ROS_WARN(\"ClearCostmapRecovery::runBehavior: Global costmap cleared in %f seconds.\", (end - start).toSec());\n  }\n  if (affected_maps_ & AFFECTED_LOCAL_COSTMAP) {\n    ros::", "CodeBleu_score": 41.1803445819576}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  polygon_cells.clear();\n  if (polygon.size() < 3) {\n    ROS_WARN(\"polygon must have at least 3 points\");\n    return;\n  }\n  PolygonOutlineCells polygon_cells_obj;\n  // Iterate through the vertices of the polygon, connecting each consecutive pair of points\n  for (unsigned int i = 0; i < polygon.size(); i++) {\n    if (i == polygon.size() - 1) {\n      polygon_cells_obj.raytraceLine(polygon[i], polygon[0]);\n    } else {\n      polygon_cells_obj.raytraceLine(polygon[i], polygon[i + 1]);\n    }\n  }\n  // If the polygon is not empty, connect the last point to the first\n  if (polygon.size() > 1) {\n    polygon_cells_obj.raytraceLine(polygon[polygon.size() - 1], polygon[0]);\n  }\n  // Copy the cells from the PolygonOutlineCells object\n  polygon_cells = polygon_cells_obj.cells;\n}\n", "CodeBleu_score": 54.50801661260951}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\t// 1. Create a PolygonOutlineCells object to collect the cells.\n\tPolygonOutlineCells polygon_outline_cells;\n\n\t// 2. Iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points.\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\t// 2.1. If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\t\tif (i == 0) {\n\t\t\t// 2.1.1. If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\t\t\tpolygon_outline_cells.addCell(polygon[i]);\n\t\t}\n\t\t// 2.2. If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\t\telse {\n\t\t\t// 2.2.1. If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\t\t\tpolygon_outline_cells.addCell(raytraceLine(polygon[i - 1], polygon[i]));\n\t\t}\n\t}\n\n\t// 3. Return the cells that form the outline of the polygon.\n\tpolygon_cells = polygon_outline_cells.getCells();\n}\n", "CodeBleu_score": 44.29931464692372}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\t// Initialize the PolygonOutlineCells object\n\tPolygonOutlineCells outline_cells;\n\n\t// Iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\t// If the polygon is not empty, it also closes the polygon by connecting the last point to the first\n\t\tif (i == 0) {\n\t\t\traytraceLine(polygon[i], polygon[polygon.size() - 1], outline_cells);\n\t\t} else {\n\t\t\traytraceLine(polygon[i - 1], polygon[i], outline_cells);\n\t\t}\n\t}\n\n\t// Collect the cells\n\tpolygon_cells.clear();\n\tfor (unsigned int i = 0; i < outline_cells.cells.size(); i++) {\n\t\tpolygon_cells.push_back(outline_cells.cells[i]);\n\t}\n}\n", "CodeBleu_score": 49.9465088659949}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  if (!prepared_) {\n    prepareGrid();\n  }\n  publisher_.onNewSubscription(pub);\n}\n", "CodeBleu_score": 60.224785556241514}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  if (!prepared_grid_) {\n    prepareGrid();\n  }\n  publisher_.connect(pub);\n}\n", "CodeBleu_score": 61.719995856696166}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)    boost::recursive_mutex::scoped_lock lock(mutex_);\n    //prepare the grid data\n    prepareGrid();\n    //publish the prepared grid\n    publishGrid(pub);\n}\n", "CodeBleu_score": 51.76566518166928}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()\tboost::mutex::scoped_lock l(costmap_mutex_);\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0;\n\tgrid_.info.origin.orientation.x = 0;\n\tgrid_.info.origin.orientation.y = 0;\n\tgrid_.info.origin.orientation.z = 0;\n\tgrid_.info.origin.orientation.w = 1;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tgrid_.data.assign(grid_.data.size(), -1);\n\torigin_x_ = costmap_->getOriginX();\n\torigin_y_ = costmap_->getOriginY();\n\torigin_theta_ = costmap_->getGlobalRotation();\n\tROS_DEBUG(\"Preparing grid\");\n}\n", "CodeBleu_score": 53.26714113770085}, {"code": "void Costmap2DPublisher::prepareGrid()\n  // Lock the mutex and get the resolution\n  boost::mutex::scoped_lock lock(costmap_mutex_);\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = global_frame_;\n\n  // Set the grid's resolution\n  grid_.info.resolution = resolution;\n\n  // Get the map size\n  unsigned int width = costmap_->getSizeInCellsX();\n  unsigned int height = costmap_->getSizeInCellsY();\n\n  // Set the grid's width and height\n  grid_.info.width = width;\n  grid_.info.height = height;\n\n  // Set the grid's origin\n  grid_.info.origin.position.x = -costmap_->getOriginX();\n  grid_.info.origin.position.y = -costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n\n  // Resize the grid data vector\n  grid_.data.resize(width * height);\n\n  // Populate the grid data\n  for (unsigned int i = 0; i < width; ++i) {\n    for (unsigned int j = 0; j < height; ++j) {\n      grid_.data[i * width + j] = translation_table_[costmap_->getCharMap()[i * width + j]];\n    }\n  }\n}\n", "CodeBleu_score": 61.455867385272796}, {"code": "void Costmap2DPublisher::prepareGrid()  // Lock the mutex\n  boost::recursive_mutex::scoped_lock lock(costmap_mutex_);\n  // Get the resolution\n  double resolution = costmap_->getResolution();\n  // Set the grid's header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  // Set the grid's resolution\n  grid_.info.resolution = resolution;\n  // Set the grid's width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  // Set the grid's origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  // Save the origin coordinates\n  origin_x_ = costmap_->getOriginX();\n  origin_y_ = costmap_->getOriginY();\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  // Populate the grid data from the costmap's character map\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = translation_table_[costmap_->getCharMap()[i]];\n  }\n}\n", "CodeBleu_score": 62.054306743406784}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  // If the footprint and robot radius in the new and old configurations are the same, return immediately.\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If the new configuration contains a valid footprint string, convert the string to a footprint and set it.\n  if (!new_config.footprint.empty()) {\n    try {\n      std::vector<geometry_msgs::Point> points;\n      std::istringstream iss(new_config.footprint);\n      double x, y;\n      while (iss >> x >> y) {\n        points.push_back(geometry_msgs::Point(x, y, 0));\n      }\n      setFootprint(points);\n    } catch (const std::exception &e) {\n      ROS_ERROR_STREAM(\"Invalid footprint string: \" << new_config.footprint);\n    }\n    return;\n  }\n\n  // If the footprint string is invalid, log an error.\n  ROS_ERROR_STREAM(\"No footprint string provided in the new configuration. Setting footprint based on robot radius.\");\n\n  // If no valid footprint string is provided, set the footprint based on the robot radius.\n  setFootprint(new_config.robot_radius);\n}\n", "CodeBleu_score": 62.61844825575461}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  // If the new configuration has a valid footprint, use it.\n  if (new_config.footprint != old_config.footprint) {\n    if (new_config.footprint.size() > 0) {\n      // The footprint is valid.\n      if (new_config.footprint.size() == 4) {\n        // The footprint is a rectangle.\n        if (new_config.robot_radius == old_config.robot_radius) {\n          // The footprint and robot radius are the same.\n          return;\n        }\n        else {\n          // The footprint and robot radius are different.\n          ROS_WARN_STREAM(\"The footprint is a rectangle, but the robot radius is not. \"\n                          \"The footprint will be converted to a circle with a radius of \"\n                          << new_config.robot_radius << \".\");\n          // Convert the footprint to a circle.\n          footprint_spec_.footprint.resize(4, 0.0);\n          footprint_spec_.footprint[0] = new_config.robot_radius;\n          footprint_spec_.footprint[1] = new_config.robot_radius;\n          footprint_spec_.footprint[2] = new_config.robot_radius;\n          footprint_spec_.footprint[3] = new_config.robot_radius;\n          footprint_spec_.is_circle = true;\n          return;\n        }\n      }\n      else {\n        // The footprint is not a rectangle.\n        if (new_config.robot_radius == old_config.robot_radius) {\n          // The footprint and robot radius are the same.\n          return;\n        }\n        else {\n          // The footprint and robot radius are different.\n          ROS_WARN_STREAM(\"The footprint is not a rectangle, but the robot radius is not. \"\n                          \"The footprint will be converted to a circle with a radius of \"\n                          << new_config.robot_radius << \".\");\n          // Convert the footprint to a circle.\n          footprint_spec_.footprint.resize(4, 0.", "CodeBleu_score": 46.69606745568593}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  if (new_config.footprint_padding == old_config.footprint_padding &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n  if (new_config.footprint_padding < 0) {\n    ROS_ERROR(\"Costmap2DROS: footprint_padding must be >= 0\");\n    return;\n  }\n  if (new_config.robot_radius < 0) {\n    ROS_ERROR(\"Costmap2DROS: robot_radius must be >= 0\");\n    return;\n  }\n  std::string footprint_string = new_config.footprint_padding_string;\n  if (footprint_string.empty()) {\n    footprint_string = new_config.robot_radius_string;\n  }\n  if (footprint_string.empty()) {\n    ROS_ERROR(\"Costmap2DROS: footprint_padding_string and robot_radius_string cannot both be empty\");\n    return;\n  }\n  if (footprint_string == old_config.footprint_padding_string &&\n      footprint_string == old_config.robot_radius_string) {\n    return;\n  }\n  if (footprint_string == old_config.footprint_padding_string) {\n    footprint_padding_ = new_config.footprint_padding;\n  } else if (footprint_string == old_config.robot_radius_string) {\n    footprint_padding_ = new_config.robot_radius;\n  } else {\n    if (!(costmap_2d::readVector(footprint_string, footprint_padding_))) {\n      ROS_ERROR(\"Costmap2DROS: footprint_padding_string must be a valid vector\");\n      return;\n    }\n  }\n  if (footprint_padding_.empty()) {\n    ROS_ERROR(\"Costmap2DROS: footprint_padding_string must be a valid vector\");\n    return;\n  }\n  if (footprint_padding_.size() % 2 == 0) {\n    ROS_ERROR(\"Costmap", "CodeBleu_score": 51.302928685098514}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  if (tf_ != NULL) {\n    geometry_msgs::PoseStamped pose;\n    try {\n      pose = tf_->getLatestCommonTime(\"base_link\", \"map\");\n    }\n    catch (tf::TransformException ex) {\n      ROS_WARN(\"%s\", ex.what());\n      return;\n    }\n    new_pose = pose;\n    new_pose_received = true;\n  }\n}\n", "CodeBleu_score": 46.30320518444645}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  tf::Stamped<tf::Pose> robot_pose;\n  try {\n    tf_->transformPose(\"map\", tf::Stamped<tf::Pose>(tf::Pose::getIdentity(), ros::Time::now(), \"base_link\"), robot_pose);\n  }\n  catch (tf::TransformException ex) {\n    ROS_WARN(\"TF Exception %s\", ex.what());\n    return;\n  }\n  geometry_msgs::PoseStamped new_pose;\n  new_pose.header.stamp = ros::Time::now();\n  new_pose.header.frame_id = \"map\";\n  new_pose.pose.position.x = robot_pose.getOrigin().x();\n  new_pose.pose.position.y = robot_pose.getOrigin().y();\n  new_pose.pose.position.z = robot_pose.getOrigin().z();\n  new_pose.pose.orientation = robot_pose.getRotation();\n  new_pose.pose.orientation.x = 0;\n  new_pose.pose.orientation.y = 0;\n  new_pose.pose.orientation.z = 0;\n  new_pose.pose.orientation.w = 1;\n  new_pose.pose.orientation.x = 0;\n  new_pose.pose.orientation.y = 0;\n  new_pose.pose.orientation.z = 0;\n  new_pose.pose.orientation.w = 1;\n  new_pose.pose.orientation.x = 0;\n  new_pose.pose.orientation.y = 0;\n  new_pose.pose.orientation.z = 0;\n  new_pose.pose.orientation.w = 1;\n  new_pose.pose.orientation.x = 0;\n  new_pose.pose.orientation.y = 0;\n  new_pose.pose.orientation.z = 0;\n  new_pose.pose.orientation.w = 1;\n  new_pose.pose.orientation.x = 0;\n  new_pose.pose.orientation.y = 0;\n  new_pose.pose.orientation.", "CodeBleu_score": 39.23961783988978}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  // Get the current pose of the robot\n  geometry_msgs::PoseStamped new_pose;\n  try {\n    new_pose = tf::buffer_.lookupTransform(\"map\", \"base_footprint\", ros::Time(0)).pose;\n  }\n  catch (tf::TransformException ex) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose from TF: %s\", ex.what());\n    return;\n  }\n\n  // If the pose is the same as the last one, we're done.\n  if (new_pose.pose.position.x == current_pose_.pose.position.x && new_pose.pose.position.y == current_pose_.pose.position.y &&\n      new_pose.pose.orientation.x == current_pose_.pose.orientation.x && new_pose.pose.orientation.y == current_pose_.pose.orientation.y &&\n      new_pose.pose.orientation.z == current_pose_.pose.orientation.z && new_pose.pose.orientation.w == current_pose_.pose.orientation.w) {\n    return;\n  }\n\n  // Otherwise, we need to reconfigure the costmap.\n  current_pose_ = new_pose;\n  reconfigure_ = true;\n}\n", "CodeBleu_score": 41.6939067236012}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()  // retrieve the list of plugins\n  std::vector<std::string> plugin_names = getPluginNames();\n  // check if the costmap was stopped\n  if (stopped_) {\n    // if stopped, re-subscribe to topics by activating each plugin and set the stopped flag to false\n    for (std::vector<std::string>::const_iterator plugin_name = plugin_names.begin(); plugin_name != plugin_names.end(); ++plugin_name) {\n      if (plugin_activator_->activate(*plugin_name)) {\n        ROS_INFO_STREAM(\"Re-activated plugin \" << *plugin_name);\n      } else {\n        ROS_ERROR_STREAM(\"Failed to re-activate plugin \" << *plugin_name);\n      }\n    }\n    stopped_ = false;\n  }\n  // set stop_updates_ to false\n  stop_updates_ = false;\n  // wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (ros::ok() && !initialized_ && !stopped_) {\n    ros::Duration(0.1).sleep();\n  }\n}\n", "CodeBleu_score": 52.40719477340144}, {"code": "void Costmap2DROS::start()  // get the list of plugins\n  std::vector<std::string> plugin_list;\n  getPluginsList(plugin_list);\n\n  // check if the costmap was stopped\n  if (stopped_) {\n    // reactivate each plugin\n    for (unsigned int i = 0; i < plugin_list.size(); ++i) {\n      // check if the plugin is a subscriber\n      if (plugin_list[i].find(\"Subscriber\") != std::string::npos) {\n        // get the name of the topic\n        std::string topic_name = plugin_list[i].substr(plugin_list[i].find(\"Subscriber\") + 10, plugin_list[i].find(\"Publisher\") - plugin_list[i].find(\"Subscriber\") - 10);\n        // subscribe to the topic\n        subscribe(topic_name);\n      }\n    }\n\n    // set the stopped flag to false\n    stopped_ = false;\n  }\n\n  // set stop_updates_ to false\n  stop_updates_ = false;\n\n  // wait for ROS to be running\n  while (!ros::master::check()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  // wait until the costmap is initialized\n  while (!initialized_) {\n    ros::Duration(0.01).sleep();\n  }\n\n  // wait until the map update thread is active\n  while (!update_thread_.joinable()) {\n    ros::Duration(0.01).sleep();\n  }\n}\n", "CodeBleu_score": 50.47739781314641}, {"code": "void Costmap2DROS::start()\tROS_INFO(\"Starting costmap2DROS\");\n\t//get the list of plugins\n\tstd::vector<std::string> plugin_list = getPlugins();\n\t//check if the costmap was stopped\n\tif (stopped_) {\n\t\t//re-subscribe to topics by activating each plugin\n\t\tfor (std::vector<std::string>::iterator it = plugin_list.begin(); it != plugin_list.end(); ++it) {\n\t\t\tROS_INFO(\"Activating plugin: %s\", (*it).c_str());\n\t\t\tplugin_loader_->activatePlugin(*it);\n\t\t}\n\t\t//set the stopped flag to false\n\t\tstopped_ = false;\n\t}\n\t//set stop_updates_ to false\n\tstop_updates_ = false;\n\t//wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n\twhile (!ros::ok() || !initialized_ || !map_update_thread_active_) {\n\t\tros::spinOnce();\n\t\tros::Duration(0.01).sleep();\n\t}\n}\n", "CodeBleu_score": 48.99789342755667}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()    // Purge stale observations.\n    if (observation_keep_time_ == 0) {\n        // Keep only the most recent observation.\n        while (observations_.size() > 1) {\n            observations_.pop_front();\n        }\n    } else {\n        // Keep only observations that are not older than the specified keep time.\n        for (auto it = observations_.begin(); it != observations_.end(); ++it) {\n            if ((*it)->getTimestamp() + observation_keep_time_ > ros::Time::now()) {\n                break;\n            }\n            observations_.erase(it);\n        }\n    }\n}\n", "CodeBleu_score": 34.877076793842434}, {"code": "void ObservationBuffer::purgeStaleObservations()    if (observation_keep_time_ == 0) {\n        if (observations_.size() > 1) {\n            observations_.erase(observations_.begin());\n        }\n    } else {\n        ObservationList::iterator it = observations_.begin();\n        while (it != observations_.end()) {\n            if (it->getTime() + observation_keep_time_ < ros::Time::now().toSec()) {\n                it = observations_.erase(it);\n            } else {\n                break;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 38.42601429370435}, {"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\tobservation_list_.erase(std::remove_if(observation_list_.begin(), observation_list_.end(),\n\t\t\t[](const Observation &observation) { return observation.is_valid_; }), observation_list_.end());\n\t} else {\n\t\tauto it = observation_list_.begin();\n\t\twhile (it != observation_list_.end()) {\n\t\t\tif (it->is_valid_ && it->timestamp_ + observation_keep_time_ < ros::Time::now().toSec()) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.61192863018979}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\n    // Get the yaw angles at the start and end indices.\n    double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n    // Determine the shortest angular distance between the yaw angles.\n    double delta_yaw = shortest_angular_distance(start_yaw, end_yaw);\n\n    // Compute the incremental change in angle for each pose in the path.\n    double delta_yaw_per_pose = delta_yaw / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range.\n    for (int i = start_index; i < end_index; i++) {\n        path[i].pose.orientation = tf::createQuaternionMsgFromYaw(start_yaw + delta_yaw_per_pose * (i - start_index));\n    }\n}\n", "CodeBleu_score": 59.71083578222991}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\n    // Calculate the yaw angles at the start and end indices\n    double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n    // Determine the shortest angular distance between them\n    double angular_distance = getAngularDistance(start_yaw, end_yaw);\n\n    // Compute the incremental change in angle for each pose\n    double angular_increment = angular_distance / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range accordingly\n    for (int i = start_index; i < end_index; i++) {\n        double yaw = start_yaw + (i - start_index) * angular_increment;\n        path[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n    }\n}\n", "CodeBleu_score": 61.78531027583731}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)  if (start_index == end_index) {\n    ROS_WARN(\"start_index and end_index are the same.\");\n    return;\n  }\n\n  if (start_index > end_index) {\n    ROS_WARN(\"start_index is greater than end_index.\");\n    return;\n  }\n\n  // Get the start and end yaw angles\n  double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n  // Calculate the shortest angular distance between the start and end yaw angles\n  double shortest_angular_distance = getShortestAngularDistance(start_yaw, end_yaw);\n\n  // Calculate the incremental change in yaw angle for each pose\n  double incremental_change_in_yaw = shortest_angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index; i < end_index; i++) {\n    // Calculate the current yaw angle\n    double current_yaw = start_yaw + incremental_change_in_yaw * (i - start_index);\n\n    // Update the orientation of the pose\n    path[i].pose.orientation = tf::createQuaternionMsgFromYaw(current_yaw);\n  }\n}\n", "CodeBleu_score": 52.65946981971632}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)    // Set the frame_id to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    std::vector<geometry_msgs::PoseStamped> path;\n    bool success = makePlan(req.start, req.goal, path);\n\n    // Update the response with the success status and the generated path\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.poses = path;\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 1;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 1;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 1;\n\n    // Return true to indicate that the service was processed\n    return true;\n}\n", "CodeBleu_score": 60.29224445875898}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tROS_INFO(\"Received a new request to generate a navigation plan.\");\n\tif (req.start.header.frame_id != \"map\" || req.goal.header.frame_id != \"map\") {\n\t\tROS_WARN(\"The start or goal are not in the \\\"map\\\" frame. The request will be ignored.\");\n\t\treturn true;\n\t}\n\n\t// Set the start and goal to the map frame.\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Generate the plan.\n\tbool success = makePlan(req.start, req.goal, resp.plan.header.frame_id, resp.plan.poses);\n\n\t// Update the response with the success status and the generated plan.\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.header.seq = 0;\n\tresp.plan.header.frame_id = resp.plan.header.frame_id;\n\tresp.plan.poses.clear();\n\tresp.plan.poses = resp.plan.poses;\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.header.seq = 0;\n\tresp.plan.header.frame_id = resp.plan.header.frame_id;\n\tresp.plan.poses = resp.plan.poses;\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.header.seq = 0;\n\tresp.plan.header.frame_id = resp.plan.header.frame_id;\n\tresp.plan.poses = resp.plan.poses;\n\n\t// Return true to indicate that the service was processed.\n\treturn true;\n}\n", "CodeBleu_score": 49.497348935285466}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)  ROS_DEBUG(\"Received a service request to create a navigation plan\");\n  ROS_DEBUG(\"Setting the frame_id of the start and goal to \\\"map\\\"\");\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n  ROS_DEBUG(\"Calling makePlan to generate a path\");\n  bool success = makePlan(req.start, req.goal, resp.plan.header.frame_id, resp.plan.header.stamp, resp.plan.poses);\n  ROS_DEBUG(\"Updating the response with the success status and the generated path if a plan is found\");\n  resp.plan.header.stamp = ros::Time::now();\n  resp.plan.header.seq = 0;\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.poses.resize(0);\n  resp.plan.poses.shrink_to_fit();\n  if (success) {\n    resp.plan.header.seq = 1;\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.poses.resize(resp.plan.poses.capacity());\n    resp.plan.poses.shrink_to_fit();\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 0;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.poses.resize(0);\n    resp.plan.poses.shrink_to_fit();\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 1;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.poses.resize(resp.plan.poses.capacity());\n    resp.plan.poses.shrink_to_fit();\n  }\n  ROS_DEBUG(\"Returning true to indicate that the service was processed\");\n  return true;\n}\n", "CodeBleu_score": 53.493797794976025}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    private_nh.param(\"global_frame_id\", global_frame_id_, std::string(\"map\"));\n    private_nh.param(\"global_planner_frequency\", global_planner_frequency_, 10.0);\n    private_nh.param(\"global_planner_patience\", global_planner_patience_, 0.5);\n    private_nh.param(\"global_planner_lookahead_distance\", global_planner_lookahead_distance_, 0.5);\n    private_nh.param(\"global_planner_lookahead_step_size\", global_planner_lookahead_step_size_, 0.1);\n    private_nh.param(\"global_planner_lookahead_step_count\", global_planner_lookahead_step_count_, 10);\n    private_nh.param(\"global_planner_lookahead_goal_distance\", global_planner_lookahead_goal_distance_, 0.5);\n    private_nh.param(\"global_planner_lookahead_goal_count\", global_planner_lookahead_goal_count_, 10);\n    private_nh.param(\"global_planner_lookahead_goal_step_size\", global_planner_lookahead_goal_step_size_, 0.1);\n    private_nh.param(\"global_planner_lookahead_goal_step_count\", global_planner_lookahead_goal_step_count_, 10);\n    private_nh.param(\"global_planner_lookahead_goal_step_size_multiplier\", global_planner_lookahead_goal_step_size_multiplier_, 1.5);\n    private_nh.param(\"global_planner_lookahead_goal_step_count_multiplier\", global_planner_lookahead_goal_step_count_multiplier_, 1.5);\n    private_nh.param(\"global_planner_lookahead_goal_step_size_min\", global_", "CodeBleu_score": 32.968938172743634}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\n    ros::NodeHandle private_nh(\"~/\" + name);\n\n    // Initialize the planner with the given name\n    private_nh.param(\"planner_frequency\", planner_frequency_, 10.0);\n    private_nh.param(\"publish_frequency\", publish_frequency_, 10.0);\n    private_nh.param(\"publish_plans\", publish_plans_, true);\n    private_nh.param(\"publish_global_plan\", publish_global_plan_, true);\n    private_nh.param(\"publish_global_plan_only\", publish_global_plan_only_, false);\n    private_nh.param(\"publish_local_plan_only\", publish_local_plan_only_, false);\n    private_nh.param(\"publish_global_plan_over_robot_model\", publish_global_plan_over_robot_model_, false);\n    private_nh.param(\"global_plan_max_interval\", global_plan_max_interval_, 0.0);\n    private_nh.param(\"global_plan_min_distance\", global_plan_min_distance_, 0.0);\n    private_nh.param(\"global_plan_min_angle\", global_plan_min_angle_, 0.0);\n    private_nh.param(\"global_plan_max_velocity_change_factor\", global_plan_max_velocity_change_factor_, 0.0);\n    private_nh.param(\"global_plan_max_acceleration_change_factor\", global_plan_max_acceleration_change_factor_, 0.0);\n    private_nh.param(\"global_plan_min_forward_progress\", global_plan_min_forward_progress_, 0.0);\n    private_nh.param(\"global_plan_min_turning_radius\", global_plan_min_turning_radius_, 0.0);\n    private_nh.param(\"global_plan_max_turning_radius\", global_plan_max_turning_radius_, 0.0);\n    private_nh.param(\"global_plan_max_backwards", "CodeBleu_score": 32.48912124026747}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    private_nh.param(\"global_planner_frequency\", frequency_, 10.0);\n    private_nh.param(\"global_planner_max_retries\", max_retries_, 5);\n    private_nh.param(\"global_planner_min_distance\", min_distance_, 0.0);\n    private_nh.param(\"global_planner_min_angle\", min_angle_, 0.0);\n    private_nh.param(\"global_planner_max_velocity\", max_velocity_, 0.5);\n    private_nh.param(\"global_planner_max_acceleration\", max_acceleration_, 0.5);\n    private_nh.param(\"global_planner_max_deceleration\", max_deceleration_, 0.5);\n    private_nh.param(\"global_planner_lookahead_distance\", lookahead_distance_, 0.5);\n    private_nh.param(\"global_planner_lookahead_ratio\", lookahead_ratio_, 0.5);\n    private_nh.param(\"global_planner_goal_tolerance\", goal_tolerance_, 0.1);\n    private_nh.param(\"global_planner_goal_sample_rate\", goal_sample_rate_, 1.0);\n    private_nh.param(\"global_planner_obstacle_distance\", obstacle_distance_, 0.5);\n    private_nh.param(\"global_planner_obstacle_angle\", obstacle_angle_, 0.5);\n    private_nh.param(\"global_planner_obstacle_angle_rank\", obstacle_angle_rank_, 0.5);\n    private_nh.param(\"global_planner_obstacle_distance_rank\", obstacle_distance_rank_, 0.5);\n    private_nh.param(\"global_planner_obstacle_angle_threshold\", obstacle_angle_threshold_, 0.5);\n    private_nh", "CodeBleu_score": 32.51610073211428}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (!initialized_) {\n\t\tROS_ERROR(\"GlobalPlanner::worldToMap: This planner has not been initialized yet, please call initialize() before using this planner\");\n\t\treturn false;\n\t}\n\n\t// Check if the point is within the bounds of the costmap\n\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap: The point (%f, %f) is outside the bounds of the costmap\", wx, wy);\n\t\treturn false;\n\t}\n\n\t// Calculate the map coordinates\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\t// Check if the map coordinates are within the costmap's size limits\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap: The point (%f, %f) is outside the bounds of the costmap\", wx, wy);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 40.977798870193595}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)    if (wx < 0 || wx >= world_size_x_ || wy < 0 || wy >= world_size_y_) {\n        return false;\n    }\n    mx = wx / resolution_;\n    my = wy / resolution_;\n    return true;\n}\n", "CodeBleu_score": 23.032165428127954}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (wx < 0 || wx >= costmap_->getSizeInMetersX() || wy < 0 || wy >= costmap_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}\n", "CodeBleu_score": 38.23765128465531}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)     if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, please call initialize() before using this planner\");\n        return;\n    }\n    ROS_DEBUG(\"Publishing a global plan (%lu points)\", path.size());\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = map_frame_;\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses.resize(path.size());\n    std::copy(path.begin(), path.end(), gui_path.poses.begin());\n    plan_pub_.publish(gui_path);\n}\n\n", "CodeBleu_score": 60.4650386286821}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)     if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, please call initialize() before using this planner\");\n        return;\n    }\n    ROS_DEBUG(\"Publishing global plan\");\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = \"map\";\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses.resize(path.size());\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n    plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 84.24343882682983}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, please call initialize() before using this planner\");\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = \"map\";\n  gui_path.header.stamp = ros::Time::now();\n\n  gui_path.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 83.09026651907996}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG(\"Received a new goal\");\n\t// Create a new action goal\n\tmove_base_msgs::MoveBaseGoal action_goal;\n\t// Set the timestamp\n\taction_goal.header.stamp = ros::Time::now();\n\t// Set the target pose\n\taction_goal.target_pose.header.frame_id = goal->header.frame_id;\n\taction_goal.target_pose.header.stamp = goal->header.stamp;\n\taction_goal.target_pose.pose = goal->pose;\n\t// Publish the goal\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 60.88503943804766}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)  ROS_DEBUG(\"Received a new goal\");\n  actionlib_msgs::GoalID goal_id;\n  goal_id.stamp = ros::Time::now();\n  goal_id.id = goal_id_counter++;\n\n  move_base_msgs::MoveBaseGoal goal_msg;\n  goal_msg.goal_id = goal_id;\n  goal_msg.target_pose.header.stamp = ros::Time::now();\n  goal_msg.target_pose.header.frame_id = goal->header.frame_id;\n  goal_msg.target_pose.pose = goal->pose;\n\n  ROS_DEBUG(\"Sending goal\");\n  action_goal_pub_.publish(goal_msg);\n}\n", "CodeBleu_score": 45.77726799130759}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG(\"Received a new goal\");\n\t// Create a MoveBaseActionGoal message\n\tmove_base_msgs::MoveBaseActionGoal goal_msg;\n\t// Set the timestamp to the current time\n\tgoal_msg.header.stamp = ros::Time::now();\n\t// Assign the goal to the target_pose\n\tgoal_msg.goal.target_pose = *goal;\n\t// Publish the goal to the action_goal_pub_ topic\n\taction_goal_pub_.publish(goal_msg);\n}\n", "CodeBleu_score": 56.802578671922824}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)    if (std::pow(current_distance - limited_distance, 2) >= std::pow(0.05, 2)) {\n        ROS_INFO(\"Moving slow and clearing: robot has moved far enough.\");\n        if (remove_limit_thread.joinable()) {\n            remove_limit_thread.join();\n        }\n        remove_limit_thread = std::thread(&MoveSlowAndClear::removeLimit, this);\n        distance_check_timer.stop();\n    }\n}\n", "CodeBleu_score": 53.875976706814136}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tif (currentDistanceSquared >= limitDistanceSquared) {\n\t\tROS_INFO(\"Moving slow and clearing: Distance check complete.\");\n\t\tros::shutdown();\n\t}\n}\n", "CodeBleu_score": 12.956976654054742}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  if (currentDistanceSquared < distanceSquaredLimit) {\n    ROS_INFO(\"Distance check passed. Removing speed limit.\");\n    if (removeLimitThread.joinable()) {\n      removeLimitThread.join();\n    }\n    removeLimitThread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    distanceCheckTimer.stop();\n  }\n}\n", "CodeBleu_score": 38.644642122466294}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\n    // Get the current robot pose\n    getRobotPose(current_pose_);\n\n    // Create a path to the goal\n    std::vector<geometry_msgs::PoseStamped> path;\n    makePlan(current_pose_, *goal, path);\n\n    // If the path is not empty, set the goal pose to the last pose in the path\n    if (!path.empty()) {\n        goal_pose_ = path.back();\n    }\n}\n", "CodeBleu_score": 51.185883625539695}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)    // Get the current global pose of the robot\n    rm::PoseStamped current_pose = getRobotPose();\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<rm::PoseStamped> path;\n    if (makePlan(current_pose, *goal, path)) {\n        // If a path is successfully generated, clear the old path\n        path_msg_.poses.clear();\n\n        // Add the new path to the path message\n        path_msg_.header.frame_id = costmap_ros_->getGlobalFrameID();\n        path_msg_.header.stamp = ros::Time::now();\n        path_msg_.poses = path;\n\n        // Publish the path\n        path_pub_.publish(path_msg_);\n    }\n}\n", "CodeBleu_score": 44.6490902057283}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  // Get the current robot pose\n  rm::PoseStamped current_pose = getRobotPose();\n\n  // Get the current robot position\n  rm::Point current_position = current_pose.pose.position;\n\n  // Get the current robot orientation\n  rm::Quaternion current_orientation = current_pose.pose.orientation;\n\n  // Get the current robot orientation in euler angles\n  double current_roll, current_pitch, current_yaw;\n  tf::Matrix3x3(tf::Quaternion(current_orientation.x, current_orientation.y, current_orientation.z, current_orientation.w)).getRPY(current_roll, current_pitch, current_yaw);\n\n  // Get the goal position\n  rm::Point goal_position = goal->pose.position;\n\n  // Get the goal orientation\n  rm::Quaternion goal_orientation = goal->pose.orientation;\n\n  // Get the goal orientation in euler angles\n  double goal_roll, goal_pitch, goal_yaw;\n  tf::Matrix3x3(tf::Quaternion(goal_orientation.x, goal_orientation.y, goal_orientation.z, goal_orientation.w)).getRPY(goal_roll, goal_pitch, goal_yaw);\n\n  // Get the current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get the current time as a double\n  double current_time_double = current_time.toSec();\n\n  // Get the goal time\n  ros::Time goal_time = goal->header.stamp;\n\n  // Get the goal time as a double\n  double goal_time_double = goal_time.toSec();\n\n  // Get the time difference between the current time and the goal time\n  double time_difference = goal_time_double - current_time_double;\n\n  // If the goal time is in the future\n  if (time_difference > 0) {\n    // If the goal time is in the future\n    if (time_difference < 10) {\n      // If the goal time is in the future and the goal time is within 10 seconds of the current", "CodeBleu_score": 37.29239072383667}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tparam_set_srv_.request.param_id = param_set.param_id;\n\tparam_set_srv_.request.param_value = param_set.param_value;\n\tparam_set_client_.call(param_set_srv_);\n}\n", "CodeBleu_score": 50.71714886118599}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)  param_set_srv_.request.param_id = param_set.param_id;\n  param_set_srv_.request.param_value = param_set.param_value;\n  param_set_client_.call(param_set_srv_);\n}\n", "CodeBleu_score": 51.39023258472128}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value = param_set.value;\n    param_set_client_.call(param_set_srv);\n}\n", "CodeBleu_score": 53.188534957417296}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()    // Wait for a connection\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len = sizeof(client_addr);\n    int new_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_addr_len);\n    if (new_socket < 0) {\n        std::cout << \"Error accepting connection\" << std::endl;\n        return;\n    }\n\n    // Receive data\n    std::vector<char> data(1024);\n    int bytes_received = recv(new_socket, &data[0], data.size(), 0);\n    if (bytes_received < 0) {\n        std::cout << \"Error receiving data\" << std::endl;\n        return;\n    }\n    if (bytes_received == 0) {\n        std::cout << \"Error: received 0 bytes\" << std::endl;\n        return;\n    }\n    data.resize(bytes_received);\n\n    // Decode the message\n    std::string message = std::string(data.begin(), data.end());\n    std::vector<std::string> split_message = split(message, '|');\n    if (split_message.size() != 2) {\n        std::cout << \"Error: received message with incorrect number of parts\" << std::endl;\n        return;\n    }\n    std::string topic = split_message[0];\n    std::string data_str = split_message[1];\n    std::vector<std::string> split_data = split(data_str, ',');\n    if (split_data.size() != 2) {\n        std::cout << \"Error: received data with incorrect number of parts\" << std::endl;\n        return;\n    }\n    std::string data_type = split_data[0];\n    std::string data_str_2 = split_data[1];\n    std::vector<std::string> split_data_2 = split(data_str_2, ':');\n    if (split_data_2.size() != 2) {\n        std::cout << \"Error: received data with", "CodeBleu_score": 38.7558038879135}, {"code": "void CommunicationBridge::serverFun()\tint sockfd, newsockfd, portno, clilen;\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tint n;\n\tchar buffer[256];\n\tstd::string data;\n\tbool isConnected = false;\n\tbool isValid = false;\n\tbool isReady = false;\n\tbool isSent = false;\n\tbool isReceived = false;\n\tbool isError = false;\n\tbool isNewConnection = false;\n\tbool isNewData = false;\n\tbool isNewMessage = false;\n\tbool isNewDataMessage = false;\n\tbool isNewDataMessageReceived = false;\n\tbool isNewDataMessageSent = false;\n\tbool isNewDataMessageError = false;\n\tbool isNewDataMessageReady = false;\n\tbool isNewDataMessageIsValid = false;\n\tbool isNewDataMessageIsReady = false;\n\tbool isNewDataMessageIsValid = false;\n\tbool isNewDataMessageIsSent = false;\n\tbool isNewDataMessageIsReceived = false;\n\tbool isNewDataMessageIsError = false;\n\tbool isNewDataMessageIsNewConnection = false;\n\tbool isNewDataMessageIsNewData = false;\n\tbool isNewDataMessageIsNewMessage = false;\n\tbool isNewDataMessageIsNewDataMessage = false;\n\tbool isNewDataMessageIsNewDataMessageReceived = false;\n\tbool isNewDataMessageIsNewDataMessageSent = false;\n\tbool isNewDataMessageIsNewDataMessageError = false;\n\tbool isNewDataMessageIsNewDataMessageReady = false;\n\tbool isNewDataMessageIsNewDataMessageIsValid = false;\n\tbool isNewDataMessageIsNewDataMessageIsReady = false;\n\tbool isNewDataMessageIsNewDataMessageIsValid = false;\n\tbool isNewDataMessageIsNewDataMessageIsSent = false;\n\tbool isNewDataMessageIsNewDataMessageIsReceived = false;\n\tbool isNewDataMessageIsNewDataMessageIsError = false;\n\tbool isNewDataMessageIsNewDataMessageIsNewConnection = false;\n\tbool isNewDataMessageIsNewDataMessageIsNewData = false;\n\tbool isNewDataMessageIsNew", "CodeBleu_score": 9.075109143440944}, {"code": "void CommunicationBridge::serverFun()    // Wait for a connection from the ground station\n    int new_socket;\n    sockaddr_in client_addr;\n    socklen_t client_addr_size = sizeof(client_addr);\n    new_socket = accept(server_socket, (sockaddr *)&client_addr, &client_addr_size);\n    if (new_socket < 0) {\n        std::cout << \"Error: Failed to accept connection\" << std::endl;\n        return;\n    }\n\n    // Initialize a new socket for the new connection\n    int new_client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (new_client_socket < 0) {\n        std::cout << \"Error: Failed to initialize new socket\" << std::endl;\n        return;\n    }\n\n    // Set the new socket to be non-blocking\n    int flags = fcntl(new_socket, F_GETFL, 0);\n    fcntl(new_socket, F_SETFL, flags | O_NONBLOCK);\n\n    // Set the new socket to be reusable\n    int optval = 1;\n    setsockopt(new_socket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n    // Bind the new socket to the new connection\n    if (bind(new_socket, (sockaddr *)&client_addr, sizeof(client_addr)) < 0) {\n        std::cout << \"Error: Failed to bind new socket\" << std::endl;\n        return;\n    }\n\n    // Log the connection\n    std::cout << \"Connection from \" << inet_ntoa(client_addr.sin_addr) << \":\" << ntohs(client_addr.sin_port) << std::endl;\n\n    // Enter a loop to handle the new connection\n    while (true) {\n        // Receive data from the new connection\n        char buffer[BUFFER_SIZE];\n        int received = recv(new_socket, buffer, BUFFER_SIZE, 0);\n        if (received < 0) {\n            if (errno != EAGA", "CodeBleu_score": 41.39377359857356}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\n    // Check if in simulation mode\n    if (simulation_mode_) {\n\n        // Check if UAV ID is valid\n        if (uav_cmd.uav_id < 1 || uav_cmd.uav_id > swarm_control_simulation_.size()) {\n            ROS_WARN(\"Invalid UAV ID %d\", uav_cmd.uav_id);\n            return;\n        }\n\n        // Publish command to UAV\n        swarm_control_simulation_[uav_cmd.uav_id - 1]->uav_basic_.publishCmd(uav_cmd);\n\n    } else {\n\n        // Publish command to UAV\n        uav_basic_.publishCmd(uav_cmd);\n\n    }\n\n}\n", "CodeBleu_score": 37.11845631491143}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\t//ROS_INFO(\"Received command %d from %d\", uav_cmd.command_id, uav_cmd.uav_id);\n\tif (uav_cmd.uav_id == 0) {\n\t\tif (uav_cmd.command_id == 1) {\n\t\t\tROS_INFO(\"Received command 1 from 0\");\n\t\t\tif (simulation_mode) {\n\t\t\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\t\t\tif (swarm_control_simulation_[i].uav_id == uav_cmd.uav_id) {\n\t\t\t\t\t\tswarm_control_simulation_[i].uav_cmd = uav_cmd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuav_basic_.uav_cmd = uav_cmd;\n\t\t\t}\n\t\t}\n\t\telse if (uav_cmd.command_id == 2) {\n\t\t\tROS_INFO(\"Received command 2 from 0\");\n\t\t\tif (simulation_mode) {\n\t\t\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\t\t\tif (swarm_control_simulation_[i].uav_id == uav_cmd.uav_id) {\n\t\t\t\t\t\tswarm_control_simulation_[i].uav_cmd = uav_cmd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuav_basic_.uav_cmd = uav_cmd;\n\t\t\t}\n\t\t}\n\t\telse if (uav_cmd.command_id == 3) {\n\t\t\tROS_INFO(\"Received command 3 from 0\");\n\t\t\tif (simulation_mode) {\n\t\t\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n", "CodeBleu_score": 38.38979342833743}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\n    if (uav_cmd.uav_id == 0) {\n        ROS_WARN(\"[CommunicationBridge] UAV ID is 0. Not publishing command.\");\n        return;\n    }\n\n    if (simulation_mode_) {\n        for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n            if (swarm_control_simulation_[i]->getUAVID() == uav_cmd.uav_id) {\n                swarm_control_simulation_[i]->sendUAVCommand(uav_cmd);\n                return;\n            }\n        }\n        ROS_WARN(\"[CommunicationBridge] UAV ID not found in simulation mode. Not publishing command.\");\n        return;\n    }\n\n    if (uav_cmd.uav_id == uav_basic_.getUAVID()) {\n        uav_basic_.sendUAVCommand(uav_cmd);\n    } else {\n        ROS_WARN(\"[CommunicationBridge] UAV ID not found. Not publishing command.\");\n    }\n}\n", "CodeBleu_score": 42.912271961864235}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)  if (mode_selection.use_mode == true) {\n    if (mode_selection.mode == REBOOTNX) {\n      createMode(mode_selection.mode);\n    } else if (mode_selection.mode == EXITNX) {\n      createMode(mode_selection.mode);\n    } else {\n      deleteMode(mode_selection.mode);\n    }\n  } else {\n    deleteMode(mode_selection.mode);\n  }\n}\n", "CodeBleu_score": 51.81916095756759}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)  if (mode_selection.use_mode) {\n    createMode(mode_selection.mode);\n  } else {\n    deleteMode(mode_selection.mode);\n  }\n\n  switch (mode_selection.mode) {\n    case REBOOTNX:\n      system(\"reboot\");\n      break;\n    case EXITNX:\n      system(\"exit\");\n      break;\n    default:\n      break;\n  }\n}\n", "CodeBleu_score": 37.07167535699433}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.mode == Mode::REBOOTNX) {\n        system(\"reboot\");\n    }\n    else if (mode_selection.mode == Mode::EXITNX) {\n        exit(0);\n    }\n    else if (mode_selection.mode == Mode::CREATE_MODE) {\n        createMode(mode_selection.mode_name);\n    }\n    else if (mode_selection.mode == Mode::DELETE_MODE) {\n        deleteMode(mode_selection.mode_name);\n    }\n}\n", "CodeBleu_score": 48.75274820107973}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    if (heartbeat_count == 0) {\n        ROS_WARN(\"No heartbeat detected\");\n        if (vehicle_type == \"swarm\") {\n            ROS_ERROR(\"Disconnecting swarm\");\n            disconnect_flag = true;\n        } else if (vehicle_type == \"UAV\") {\n            ROS_ERROR(\"Disconnecting UAV\");\n            disconnect_flag = true;\n        } else if (vehicle_type == \"UGV\") {\n            ROS_ERROR(\"Disconnecting UGV\");\n            disconnect_flag = true;\n        }\n    } else if (heartbeat_count > 0) {\n        if (heartbeat_count == heartbeat_threshold) {\n            ROS_WARN(\"Heartbeat count exceeded threshold\");\n            if (vehicle_type == \"swarm\") {\n                ROS_ERROR(\"Disconnecting swarm\");\n                disconnect_flag = true;\n            } else if (vehicle_type == \"UAV\") {\n                ROS_ERROR(\"Disconnecting UAV\");\n                disconnect_flag = true;\n            } else if (vehicle_type == \"UGV\") {\n                ROS_ERROR(\"Disconnecting UGV\");\n                disconnect_flag = true;\n            }\n        }\n    } else {\n        ROS_WARN(\"Heartbeat count decreased below zero\");\n        if (vehicle_type == \"swarm\") {\n            ROS_ERROR(\"Disconnecting swarm\");\n            disconnect_flag = true;\n        } else if (vehicle_type == \"UAV\") {\n            ROS_ERROR(\"Disconnecting UAV\");\n            disconnect_flag = true;\n        } else if (vehicle_type == \"UGV\") {\n            ROS_ERROR(\"Disconnecting UGV\");\n            disconnect_flag = true;\n        }\n    }\n}\n", "CodeBleu_score": 41.55536346470601}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)  // If the heartbeat count remains unchanged for a specified number of attempts, it prints an error message and triggers appropriate actions based on the type of vehicle (swarm, UAV, or UGV).\n  if (heartbeat_count == prev_heartbeat_count) {\n    ROS_ERROR(\"[%s] Heartbeat count remains unchanged for %d attempts. Check connectivity.\", NODE_NAME, HEARTBEAT_ATTEMPTS);\n\n    // If connectivity is lost, it sets the disconnect_flag to true.\n    disconnect_flag = true;\n\n    // If the vehicle is a swarm, it sets the swarm_disconnect_flag to true.\n    if (vehicle_type == SWARM) {\n      swarm_disconnect_flag = true;\n    }\n\n    // If the vehicle is a UAV, it sets the UAV_disconnect_flag to true.\n    else if (vehicle_type == UAV) {\n      UAV_disconnect_flag = true;\n    }\n\n    // If the vehicle is a UGV, it sets the UGV_disconnect_flag to true.\n    else if (vehicle_type == UGV) {\n      UGV_disconnect_flag = true;\n    }\n  }\n\n  // If the heartbeat count is less than the specified number of attempts, it resets the disconnect_flag to false.\n  else if (heartbeat_count < HEARTBEAT_ATTEMPTS) {\n    disconnect_flag = false;\n  }\n\n  // If the heartbeat count is greater than the specified number of attempts, it resets the disconnect_flag to false.\n  else if (heartbeat_count > HEARTBEAT_ATTEMPTS) {\n    disconnect_flag = false;\n  }\n\n  // If the heartbeat count is equal to the specified number of attempts, it prints a warning message.\n  else if (heartbeat_count == HEARTBEAT_ATTEMPTS) {\n    ROS_WARN(\"[%s] Heartbeat count equals %d attempts. Check connectivity.\", NODE_NAME, HEARTBEAT_", "CodeBleu_score": 43.10267373433053}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\n    // If the heartbeat count remains unchanged for a specified number of attempts, it prints an error message and triggers appropriate actions based on the type of vehicle (swarm, UAV, or UGV).\n    if (heartbeat_count == prev_heartbeat_count) {\n        ROS_ERROR(\"No heartbeat received from %s for %d consecutive times. \\n\", vehicle_type.c_str(), heartbeat_count);\n        if (vehicle_type == \"swarm\") {\n            ROS_ERROR(\"Disconnecting the swarm.\");\n            disconnect_flag = true;\n        } else if (vehicle_type == \"uav\") {\n            ROS_ERROR(\"Disconnecting the UAV.\");\n            disconnect_flag = true;\n        } else if (vehicle_type == \"ugv\") {\n            ROS_ERROR(\"Disconnecting the UGV.\");\n            disconnect_flag = true;\n        }\n    }\n\n    // If connectivity is lost, it sets the disconnect_flag to true.\n    if (disconnect_flag == true) {\n        ROS_ERROR(\"Lost connectivity.\");\n        disconnect_flag = true;\n    }\n\n    // If connectivity is regained, it resets the heartbeat count and disconnect_flag.\n    if (disconnect_flag == false) {\n        heartbeat_count = 0;\n        disconnect_flag = false;\n    }\n\n    // Update the previous heartbeat count.\n    prev_heartbeat_count = heartbeat_count;\n}\n", "CodeBleu_score": 43.578198649425836}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\n    // Initialization\n    int drone_id;\n    int n_traj;\n    int n_points;\n    int n_dims;\n    int n_knots;\n    int n_yaw_points;\n\n    // Get the drone ID\n    drone_id = msg->drone_id;\n\n    // Get the number of trajectories\n    n_traj = msg->n_traj;\n\n    // Get the number of points\n    n_points = msg->n_points;\n\n    // Get the number of dimensions\n    n_dims = msg->n_dims;\n\n    // Get the number of knots\n    n_knots = msg->n_knots;\n\n    // Get the number of yaw points\n    n_yaw_points = msg->n_yaw_points;\n\n    // Create a new MultiBspline struct\n    MultiBspline new_multitraj;\n\n    // Initialize the MultiBspline struct\n    new_multitraj.drone_id = drone_id;\n    new_multitraj.n_traj = n_traj;\n    new_multitraj.n_points = n_points;\n    new_multitraj.n_dims = n_dims;\n    new_multitraj.n_knots = n_knots;\n    new_multitraj.n_yaw_points = n_yaw_points;\n\n    // Allocate memory for the trajectory knots\n    new_multitraj.knots.resize(n_knots);\n\n    // Allocate memory for the trajectory points\n    new_multitraj.points.resize(n_points);\n\n    // Allocate memory for the trajectory yaw points\n    new_multitraj.yaw_points.resize(n_yaw_points);\n\n    // Allocate memory for the trajectory Bsplines\n    new_multitraj.bsplines.resize(n_traj);\n\n    // Extract the knots\n    for (int i = 0; i < n_knots; i++) {", "CodeBleu_score": 29.59771261452949}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    // Check if the number of trajectories is within bounds.\n    if (msg->bsplines.size() > MAX_DRONES) {\n        ROS_WARN(\"[ego_planner_swarm] Received too many trajectories. Ignoring.\");\n        return;\n    }\n\n    // Initialize the Bspline structs.\n    for (int i = 0; i < msg->bsplines.size(); i++) {\n        bsplines[i].id = msg->bsplines[i].id;\n        bsplines[i].num_knots = msg->bsplines[i].num_knots;\n        bsplines[i].num_points = msg->bsplines[i].num_points;\n        bsplines[i].num_yaw = msg->bsplines[i].num_yaw;\n        bsplines[i].knots.resize(msg->bsplines[i].num_knots);\n        bsplines[i].points.resize(msg->bsplines[i].num_points);\n        bsplines[i].yaw.resize(msg->bsplines[i].num_yaw);\n    }\n\n    // Extract the trajectory data from the message and populate the Bspline structs.\n    for (int i = 0; i < msg->bsplines.size(); i++) {\n        for (int j = 0; j < msg->bsplines[i].num_knots; j++) {\n            bsplines[i].knots[j] = msg->bsplines[i].knots[j];\n        }\n        for (int j = 0; j < msg->bsplines[i].num_points; j++) {\n            bsplines[i].points[j] = msg->bsplines[i].points[j];\n        }\n        for (int j = 0; j < msg->bsplines[i].num_yaw; j++) {\n            bsplines[i].yaw[j] = msg->bsplines[i].yaw[j];\n        }\n    }\n\n    // Encode the Bspl", "CodeBleu_score": 56.16092117112464}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\n    //std::cout << \"Received MultiBsplines message\" << std::endl;\n\n    // Initialize TCP connection\n    if (!tcp_client.is_connected()) {\n        tcp_client.connect(tcp_ip, tcp_port);\n    }\n\n    // Initialize TCP message\n    std::string tcp_message;\n\n    // Initialize Bspline struct\n    Bspline bspline;\n\n    // Initialize MultiBsplines message\n    prometheus_msgs::MultiBsplines multi_bsplines;\n\n    // Initialize MultiBsplines message\n    for (int i = 0; i < msg->bsplines.size(); i++) {\n\n        // Initialize Bspline struct\n        Bspline bspline;\n\n        // Initialize MultiBsplines message\n        multi_bsplines.bsplines.push_back(bspline);\n\n        // Set Bspline struct attributes\n        multi_bsplines.bsplines[i].drone_id = msg->bsplines[i].drone_id;\n        multi_bsplines.bsplines[i].n = msg->bsplines[i].n;\n        multi_bsplines.bsplines[i].p = msg->bsplines[i].p;\n        multi_bsplines.bsplines[i].m = msg->bsplines[i].m;\n        multi_bsplines.bsplines[i].t = msg->bsplines[i].t;\n        multi_bsplines.bsplines[i].knots = msg->bsplines[i].knots;\n        multi_bsplines.bsplines[i].position_points = msg->bsplines[i].position_points;\n        multi_bsplines.bsplines[i].yaw_points = msg->bsplines[i].yaw_points;\n\n        // Set Bspline struct knots\n        for (int j = 0; j < multi_bsplines.bsplines[i].n + multi_bsplines.bsplines[i].p + 1; j++) {\n            multi_bsplines.bsplines[i].", "CodeBleu_score": 46.78456361715465}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::fromROSMsg(msg, *cloud);\n    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZI>);\n\n    pcl::PassThrough<pcl::PointXYZI> pass;\n    pass.setInputCloud(cloud);\n    pass.setFilterFieldName(\"z\");\n    pass.setFilterLimits(0.0, 1.0);\n    pass.filter(*cloud_filtered);\n\n    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_downsampled(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::VoxelGrid<pcl::PointXYZI> vg;\n    vg.setInputCloud(cloud_filtered);\n    vg.setLeafSize(0.01f, 0.01f, 0.01f);\n    vg.filter(*cloud_downsampled);\n\n    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_octree(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZI> octree(0.005f);\n    octree.setInputCloud(cloud_downsampled);\n    octree.addPointsFromInputCloud();\n\n    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_output(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::PointXYZI p;\n    int j = 0;\n    for (int i = 0; i < cloud_downsampled->points.size(); i++) {\n        if (octree.isVoxelOccupied(cloud_downsampled->points[i])) {\n            p = cloud_downsampled->points[i];\n            cloud_output->points.push_back(p);\n           ", "CodeBleu_score": 43.33914668844422}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\tsensor_msgs::PointCloud2 compressed_msg;\n\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\tpcl::PointCloud<pcl::PointXYZRGB> cloud_compressed;\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree(0.01);\n\toctree.setInputCloud(cloud.makeShared());\n\toctree.addPointsFromInputCloud();\n\toctree.getPointCloud(cloud_compressed);\n\tpcl::toROSMsg(cloud_compressed, compressed_msg);\n\treturn compressed_msg;\n}\n", "CodeBleu_score": 27.013737936134003}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\n  // Create a new PointCloud2 message\n  sensor_msgs::PointCloud2 compressed_msg;\n\n  // Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Create an octree\n  pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree(0.01);\n  octree.setInputCloud(cloud);\n  octree.addPointsFromInputCloud();\n\n  // Create a vector of points\n  std::vector<int> pointIdxRadiusSearch;\n  std::vector<float> pointRadiusSquaredDistance;\n\n  // Iterate through the cloud and search for the nearest neighbors\n  for (size_t i = 0; i < cloud->points.size(); ++i) {\n    // Search for the nearest neighbors\n    if (octree.radiusSearch(cloud->points[i], 0.01, pointIdxRadiusSearch, pointRadiusSquaredDistance) > 0) {\n      // If there are more than 10 neighbors, remove the point\n      if (pointIdxRadiusSearch.size() > 10) {\n        cloud->points.erase(cloud->points.begin() + i);\n        --i;\n      }\n    }\n  }\n\n  // Convert the pcl::PointCloud to a sensor_msgs::PointCloud2\n  pcl::toROSMsg(*cloud, compressed_msg);\n\n  // Return the compressed message\n  return compressed_msg;\n}\n", "CodeBleu_score": 41.99007980514472}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)    for (int i = 0; i < multi_uav_state_.uav_state_vec_.size(); i++) {\n        if (multi_uav_state_.uav_state_vec_[i].uav_id_ == uav_state.uav_id_) {\n            multi_uav_state_.uav_state_vec_[i] = uav_state;\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 65.67049563064928}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)  for (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n      multi_uav_state_[i] = uav_state;\n    }\n  }\n}\n", "CodeBleu_score": 54.66880153663588}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)  for (int i = 0; i < multi_uav_state_.uav_state_size(); i++) {\n    if (multi_uav_state_.uav_state(i).uav_id() == uav_state.uav_id()) {\n      multi_uav_state_.mutable_uav_state(i)->CopyFrom(uav_state);\n    }\n  }\n}\n", "CodeBleu_score": 55.12585319381266}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    // Create a UGVState message\n    ugv_state_pub_msg.header.stamp = ros::Time::now();\n    ugv_state_pub_msg.header.frame_id = \"world\";\n\n    // Iterate through each UGV\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n        // Populate UGVState message\n        ugv_state_pub_msg.ugv_state[i].id = m_multi_ugv_state.ugv_state[i].id;\n        ugv_state_pub_msg.ugv_state[i].battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state_pub_msg.ugv_state[i].position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        ugv_state_pub_msg.ugv_state[i].position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        ugv_state_pub_msg.ugv_state[i].position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        ugv_state_pub_msg.ugv_state[i].velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        ugv_state_pub_msg.ugv_state[i].velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        ugv_state_pub_msg.ugv_state[i].velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        ugv_state_pub_msg.ugv_state[i].attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        ugv_state_pub_msg.ugv_state[i].attitude", "CodeBleu_score": 37.57620160727264}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\n    // Declare a MultiUGVState message\n    swarm_control::MultiUGVState ugv_state_msg;\n\n    // Initialize the MultiUGVState message\n    ugv_state_msg.header.stamp = ros::Time::now();\n    ugv_state_msg.header.frame_id = \"map\";\n    ugv_state_msg.ugv_count = m_multi_ugv_state.ugv_count;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        ugv_state_msg.ugv_states[i].id = m_multi_ugv_state.ugv_states[i].id;\n        ugv_state_msg.ugv_states[i].battery = m_multi_ugv_state.ugv_states[i].battery;\n        ugv_state_msg.ugv_states[i].position.x = m_multi_ugv_state.ugv_states[i].position.x;\n        ugv_state_msg.ugv_states[i].position.y = m_multi_ugv_state.ugv_states[i].position.y;\n        ugv_state_msg.ugv_states[i].position.z = m_multi_ugv_state.ugv_states[i].position.z;\n        ugv_state_msg.ugv_states[i].velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n        ugv_state_msg.ugv_states[i].velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n        ugv_state_msg.ugv_states[i].velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n", "CodeBleu_score": 38.44541947925128}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    // Initialize a MultiUGVState message\n    swarm_control_msgs::MultiUGVState msg;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_state.size(); i++) {\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        msg.ugv_state.push_back(m_multi_ugv_state.ugv_state[i]);\n        msg.ugv_state[i].id = m_multi_ugv_state.ugv_state[i].id;\n        msg.ugv_state[i].battery = m_multi_ugv_state.ugv_state[i].battery;\n        msg.ugv_state[i].position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        msg.ugv_state[i].position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        msg.ugv_state[i].position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        msg.ugv_state[i].velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        msg.ugv_state[i].velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        msg.ugv_state[i].velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        msg.ugv_state[i].attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        msg.ugv_state[i].attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n        msg.ugv_state[i].attitude.z = m_multi_ugv_state.ugv_state[", "CodeBleu_score": 39.7939705160513}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    cost = 0.0;\n    gradient.setZero(q.rows(), q.cols());\n    for (int i = 0; i < q.rows(); i++) {\n        for (int j = 0; j < q.cols(); j++) {\n            if (i == 0) {\n                if (j == 0) {\n                    Eigen::VectorXd pos = Eigen::VectorXd::Zero(3);\n                    pos(0) = q(i, j);\n                    pos(1) = q(i, j + 1);\n                    pos(2) = q(i, j + 2);\n                    Eigen::VectorXd predPos = this->bspline.getPos(pos);\n                    double dist = (predPos - pos).norm();\n                    if (dist < this->clearance) {\n                        cost += dist;\n                        gradient(i, j) += 1;\n                        gradient(i, j + 1) += 1;\n                        gradient(i, j + 2) += 1;\n                    }\n                } else if (j == 1) {\n                    Eigen::VectorXd pos = Eigen::VectorXd::Zero(3);\n                    pos(0) = q(i, j);\n                    pos(1) = q(i, j - 1);\n                    pos(2) = q(i, j + 1);\n                    Eigen::VectorXd predPos = this->bspline.getPos(pos);\n                    double dist = (predPos - pos).norm();\n                    if (dist < this->clearance) {\n                        cost += dist;\n                        gradient(i, j) += 1;\n                        gradient(i, j - 1) += 1;\n                        gradient(i, j + 1) += 1;\n                    }\n                } else if (j == 2) {\n                    Eigen::VectorXd pos = Eigen::VectorXd::Zero(3);\n                    pos(0) = q(i, j);\n                    pos(1) = q(i, j - 1);\n                ", "CodeBleu_score": 31.675021203248217}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    // Iterate through control points\n    for (int i = 0; i < (int)controlPoints.size(); ++i) {\n        // Compute predicted position of moving object\n        Eigen::Vector3d p = controlPoints[i].p;\n        double t = controlPoints[i].t;\n        Eigen::Vector3d p_pred = Eigen::Vector3d::Zero();\n        for (int j = 0; j < (int)movingObjects.size(); ++j) {\n            p_pred += movingObjects[j].computePredictedPosition(t, q);\n        }\n        // Compute distance between control point and predicted position of moving object\n        double dist = (p - p_pred).norm();\n        // If the distance is less than a specified clearance, update cost and gradient\n        if (dist < clearance) {\n            // Update cost\n            cost += (dist - clearance) * (dist - clearance);\n            // Update gradient\n            gradient(0, i) = 2 * (dist - clearance) * (p_pred.x() - p.x());\n            gradient(1, i) = 2 * (dist - clearance) * (p_pred.y() - p.y());\n            gradient(2, i) = 2 * (dist - clearance) * (p_pred.z() - p.z());\n        }\n    }\n}\n", "CodeBleu_score": 39.96617775179401}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    double cost_tmp;\n    Eigen::MatrixXd gradient_tmp(gradient.rows(), gradient.cols());\n    double clearance = 0.05;\n    double clearance_sq = clearance * clearance;\n    double clearance_sq_inv = 1.0 / clearance_sq;\n    double clearance_sq_inv_2 = clearance_sq_inv * clearance_sq_inv;\n    double clearance_sq_inv_3 = clearance_sq_inv * clearance_sq_inv * clearance_sq_inv;\n    double clearance_sq_inv_4 = clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv;\n    double clearance_sq_inv_5 = clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv;\n    double clearance_sq_inv_6 = clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv;\n    double clearance_sq_inv_7 = clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv;\n    double clearance_sq_inv_8 = clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv;\n    double clearance_sq_inv_9 = clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance_sq_inv;\n    double clearance_sq_inv_10 = clearance_sq_inv * clearance_sq_inv * clearance_sq_inv * clearance", "CodeBleu_score": 17.609617336650356}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    cost = 0;\n    gradient.setZero(n_points, 6);\n\n    // Compute the fitness cost for each control point\n    for (int i = 0; i < n_points; i++) {\n        // Compute the positional error and velocity vector\n        Eigen::Vector3d position_error = q.block<3, 1>(3 * i, 0) - reference_points[i];\n        Eigen::Vector3d velocity = (q.block<3, 1>(3 * i, 3) - q.block<3, 1>(3 * i, 0)) / dt;\n\n        // Compute the cost for this control point\n        double cost_i = a2 * position_error.transpose() * position_error + b2 * velocity.transpose() * velocity;\n\n        // Update the cost and gradient\n        cost += cost_i;\n        gradient.block<3, 1>(3 * i, 0) += 2 * a2 * position_error;\n        gradient.block<3, 1>(3 * i, 3) += 2 * b2 * velocity;\n    }\n}\n", "CodeBleu_score": 26.02088181649896}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n    // Initializing cost to zero\n    cost = 0.0;\n\n    // Iterating through the control points\n    for (int i = 0; i < (int)q.rows(); i++) {\n\n        // Computing the positional error\n        Eigen::Vector3d error = q.row(i) - ref_points_[i];\n\n        // Computing the velocity error\n        Eigen::Vector3d vel_error = q.row(i) - prev_ref_points_[i];\n\n        // Computing the cost\n        cost += a2_ * error.squaredNorm() + b2_ * vel_error.squaredNorm();\n\n        // Updating the gradient\n        gradient.row(i) += 2.0 * a2_ * error + 2.0 * b2_ * vel_error;\n    }\n\n}\n", "CodeBleu_score": 20.547816391300888}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  cost = 0.0;\n  gradient.setZero(q.rows(), q.cols());\n\n  for (int i = 0; i < q.rows(); i++) {\n    Eigen::Vector3d posError = q.row(i) - refPoints.row(i);\n    Eigen::Vector3d velError = (q.row(i + 1) - q.row(i)) - (refPoints.row(i + 1) - refPoints.row(i));\n\n    double posErrorNorm = posError.norm();\n    double velErrorNorm = velError.norm();\n\n    if (posErrorNorm > 0.000001) {\n      double posErrorDeriv = posError.dot(posError) / posErrorNorm;\n      double velErrorDeriv = velError.dot(velError) / velErrorNorm;\n\n      double posErrorNormDeriv = posError.dot(posError) / (posErrorNorm * posErrorNorm);\n      double velErrorNormDeriv = velError.dot(velError) / (velErrorNorm * velErrorNorm);\n\n      double posErrorNormDeriv2 = 2 * posError.dot(posError) / (posErrorNorm * posErrorNorm * posErrorNorm);\n      double velErrorNormDeriv2 = 2 * velError.dot(velError) / (velErrorNorm * velErrorNorm * velErrorNorm);\n\n      double costDeriv = a2 * posErrorDeriv + b2 * velErrorDeriv;\n      double costDeriv2 = a2 * posErrorNormDeriv2 + b2 * velErrorNormDeriv2;\n\n      cost += a2 * posErrorNorm * posErrorNorm + b2 * velErrorNorm * velErrorNorm;\n      gradient.row(i) += a2 * posError + b2 * velError;\n      gradient.row(i + 1) -= a2 * posError + b2 * velError;\n\n      gradient.row(i) *= costDeriv;\n      gradient.row(i + 1) *= costDeriv;\n\n", "CodeBleu_score": 37.28485763952086}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()\tdouble jerk = 0;\n\tfor (int i = 0; i < dimensions; i++) {\n\t\tfor (int j = 0; j < controlPoints; j++) {\n\t\t\tdouble diff = knotTimes[j + 1] - knotTimes[j];\n\t\t\tjerk += (3 * (3 * (3 * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - 1) * (controlPoints - ", "CodeBleu_score": 27.91693636878613}, {"code": "double UniformBspline::getJerk()\t// Compute the third derivative of the spline to obtain the jerk trajectory\n\tUniformBspline jerkTraj = getThirdDerivative();\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tvector<double> jerkKnotTimes = jerkTraj.getKnotTimes();\n\tvector<vector<double>> jerkControlPoints = jerkTraj.getControlPoints();\n\t// Initialize the jerk value\n\tdouble jerk = 0;\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < jerkControlPoints.size(); i++) {\n\t\tfor (int j = 0; j < jerkControlPoints[i].size(); j++) {\n\t\t\t// Sum the squared control point values multiplied by the differences in knot times\n\t\t\tjerk += pow(jerkControlPoints[i][j], 3) * (jerkKnotTimes[i + 1] - jerkKnotTimes[i]);\n\t\t}\n\t}\n\t// Return the total jerk value\n\treturn jerk;\n}\n", "CodeBleu_score": 45.342130646074494}, {"code": "double UniformBspline::getJerk()\t//Compute the third derivative of the spline to obtain the jerk trajectory.\n\tUniformBspline jerk = getThirdDerivative();\n\n\t//Retrieve the knot times and control points of the jerk trajectory.\n\tdouble knotTimes[jerk.getNumKnots()];\n\tdouble controlPoints[jerk.getNumDimensions()][jerk.getNumControlPoints()];\n\tjerk.getKnotTimes(knotTimes);\n\tjerk.getControlPoints(controlPoints);\n\n\t//Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times.\n\tdouble jerkValue = 0;\n\tfor (int i = 0; i < jerk.getNumDimensions(); i++) {\n\t\tfor (int j = 0; j < jerk.getNumControlPoints() - 1; j++) {\n\t\t\tjerkValue += pow(controlPoints[i][j + 1] - controlPoints[i][j], 3) * (knotTimes[j + 1] - knotTimes[j]);\n\t\t}\n\t}\n\n\t//Return the total jerk value.\n\treturn jerkValue;\n}\n", "CodeBleu_score": 40.99461679873217}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \n\t// Calculate 4D position vector\n\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1.0;\n\n\t// Return 4D position vector\n\treturn pos;\n}\n", "CodeBleu_score": 61.572215524441845}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \n    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1.0;\n\n    return pos;\n}\n", "CodeBleu_score": 64.22543857345599}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}\n", "CodeBleu_score": 73.22526008508646}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)    try {\n        int droneID = getDroneID(odom.child_frame_id);\n        rcvDroneOdomCallbackBase(odom, droneID);\n    } catch (DroneDetectorException& e) {\n        ROS_ERROR_STREAM(e.what());\n    }\n}\n", "CodeBleu_score": 47.5816054066878}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\tint drone_id = getDroneID(odom.child_frame_id);\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (int e) {\n\t\tROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: Exception caught. Drone ID: \" << e);\n\t}\n}\n", "CodeBleu_score": 48.704933313976454}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\tint droneID = getDroneID(odom.child_frame_id);\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (int e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: Exception %d\", e);\n\t}\n}\n", "CodeBleu_score": 42.85348972909509}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // Get the current time\n    ros::Time current_time = ros::Time::now();\n\n    // Get the current camera pose\n    Eigen::Matrix4d camera_pose = getCameraPose();\n\n    // Get the current world pose\n    Eigen::Matrix4d world_pose = getWorldPose();\n\n    // Get the camera to world transformation matrix\n    Eigen::Matrix4d camera_to_world = camera_pose.inverse() * world_pose;\n\n    // Get the drone to camera transformation matrix\n    Eigen::Matrix4d drone_to_camera = getDroneToCamera(drone_id);\n\n    // Get the drone to world transformation matrix\n    Eigen::Matrix4d drone_to_world = drone_to_camera * camera_to_world;\n\n    // Get the drone to camera transformation matrix\n    Eigen::Matrix4d drone_to_camera_inv = drone_to_camera.inverse();\n\n    // Get the drone to world transformation matrix\n    Eigen::Matrix4d drone_to_world_inv = drone_to_world.inverse();\n\n    // Get the drone position in the camera frame\n    Eigen::Vector4d drone_position_camera = drone_to_camera_inv * Eigen::Vector4d(true_pixel[0], true_pixel[1], 1.0, 1.0);\n\n    // Get the drone position in the world frame\n    Eigen::Vector4d drone_position_world = drone_to_world_inv * Eigen::Vector4d(true_pixel[0], true_pixel[1], 1.0, 1.0);\n\n    // Get the drone position in the camera frame\n    Eigen::Vector3d drone_position_camera_3d = drone_position_camera.head<3>() / drone_position_camera[3];\n\n    // Get the drone position in the world frame\n    Eigen::Vector3d drone_position_world_3d = drone_position_world.head<3>() / drone_position_world[3];\n\n    // Get the", "CodeBleu_score": 25.948152130641617}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\n    // Get the drone's pose from the true pixel position\n    Eigen::Vector3d drone_pos;\n    if (getDronePosition(true_pixel, drone_pos)) {\n        // Get the drone's pose from the true pixel position\n        Eigen::Vector3d drone_pos;\n        if (getDronePosition(true_pixel, drone_pos)) {\n            // Compute the pose error\n            Eigen::Vector3d drone_pos_error = drone_pos - drone_pos_prev;\n            // Update the debug result\n            debug_result.drone_pos_error = drone_pos_error;\n            // Publish the pose error\n            publishPoseError(drone_id, drone_pos_error);\n        }\n    }\n    // Update the previous drone position\n    drone_pos_prev = drone_pos;\n    // Update the debug result\n    debug_result.success = true;\n}\n", "CodeBleu_score": 29.307656300780284}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // Get the camera intrinsic parameters\n    double fx = camera_info_.K[0];\n    double fy = camera_info_.K[4];\n    double cx = camera_info_.K[2];\n    double cy = camera_info_.K[5];\n\n    // Get the camera extrinsic parameters\n    double tx = camera_info_.P[3];\n    double ty = camera_info_.P[7];\n    double tz = camera_info_.P[11];\n    double qx = camera_info_.P[8];\n    double qy = camera_info_.P[9];\n    double qz = camera_info_.P[10];\n    double qw = camera_info_.P[15];\n\n    // Get the drone size\n    double drone_width = drone_info_.width;\n    double drone_height = drone_info_.height;\n\n    // Get the drone position in the camera frame\n    double drone_x = drone_info_.x;\n    double drone_y = drone_info_.y;\n    double drone_z = drone_info_.z;\n\n    // Get the drone yaw in the camera frame\n    double drone_yaw = drone_info_.yaw;\n\n    // Get the drone pitch in the camera frame\n    double drone_pitch = drone_info_.pitch;\n\n    // Get the drone roll in the camera frame\n    double drone_roll = drone_info_.roll;\n\n    // Get the drone ID\n    int drone_id_ = drone_info_.id;\n\n    // Get the drone size\n    double drone_size = drone_info_.size;\n\n    // Get the drone position in the world frame\n    double world_x = drone_info_.world_x;\n    double world_y = drone_info_.world_y;\n    double world_z = drone_info_.world_z;\n\n    // Get the drone yaw in the world frame\n    double world_yaw = drone_info_.world_yaw;\n\n    // Get the drone pitch in the world frame", "CodeBleu_score": 24.669975420461412}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getParent() != NULL) {\n        current = current->getParent();\n        path.push_back(current);\n    }\n    return path;\n}\n", "CodeBleu_score": 79.02783757121793}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != startNode) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n", "CodeBleu_score": 65.26534869832341}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getParent() != nullptr) {\n\t\tcurrent = current->getParent();\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n", "CodeBleu_score": 65.21813636010975}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\tbool success = true;\n\tstart_idx = ConvertToIndex(start_pt);\n\tend_idx = ConvertToIndex(end_pt);\n\t\n\tif (IsInObstacle(start_idx)) {\n\t\tsuccess = AdjustStartPoint(start_idx, end_idx);\n\t}\n\t\n\tif (IsInObstacle(end_idx)) {\n\t\tsuccess = AdjustEndPoint(start_idx, end_idx);\n\t}\n\t\n\treturn success;\n}\n", "CodeBleu_score": 25.17842483799319}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\tbool success = false;\n\t// Convert the start and end points to indices\n\tif (ConvertToIndex(start_pt, start_idx) && ConvertToIndex(end_pt, end_idx)) {\n\t\t// Check if the start and end points are inside obstacles\n\t\tif (obstacle_map_[start_idx.x()][start_idx.y()][start_idx.z()] == 1) {\n\t\t\t// Adjust the start point\n\t\t\tsuccess = AdjustStartPoint(start_pt, start_idx);\n\t\t}\n\t\telse {\n\t\t\tsuccess = true;\n\t\t}\n\t\tif (success) {\n\t\t\tif (obstacle_map_[end_idx.x()][end_idx.y()][end_idx.z()] == 1) {\n\t\t\t\t// Adjust the end point\n\t\t\t\tsuccess = AdjustEndPoint(end_pt, end_idx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuccess = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn success;\n}\n", "CodeBleu_score": 28.167384751276625}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t//Convert start and end points to grid indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t//If start and end points are inside obstacles, adjust them until they are not\n\tif (IsInsideObstacle(start_idx)) {\n\t\t//Adjust start point\n\t\twhile (IsInsideObstacle(start_idx)) {\n\t\t\t//Adjust start point away from end point\n\t\t\tstart_idx[0] += (start_pt[0] > end_pt[0]) ? 1 : -1;\n\t\t\tstart_idx[1] += (start_pt[1] > end_pt[1]) ? 1 : -1;\n\t\t\tstart_idx[2] += (start_pt[2] > end_pt[2]) ? 1 : -1;\n\t\t}\n\t}\n\tif (IsInsideObstacle(end_idx)) {\n\t\t//Adjust end point\n\t\twhile (IsInsideObstacle(end_idx)) {\n\t\t\t//Adjust end point away from start point\n\t\t\tend_idx[0] += (end_pt[0] > start_pt[0]) ? 1 : -1;\n\t\t\tend_idx[1] += (end_pt[1] > start_pt[1]) ? 1 : -1;\n\t\t\tend_idx[2] += (end_pt[2] > start_pt[2]) ? 1 : -1;\n\t\t}\n\t}\n\n\t//Check if start and end points are still inside obstacles\n\tif (IsInsideObstacle(start_idx)) {\n\t\treturn false;\n\t}\n\tif (IsInsideObstacle(end_idx)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 44.19031638738463}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  // Check if the buffer is initialized\n  if (!occupancy_buffer_inflate_) {\n    ROS_WARN(\"The occupancy buffer is not initialized. Please call initializeBuffer() before resetBuffer().\");\n    return;\n  }\n\n  // Check if the buffer is big enough to contain the region\n  if (occupancy_buffer_inflate_->size() < (max_pos - min_pos).array().abs().maxCoeff() + 1) {\n    ROS_WARN(\"The occupancy buffer is not big enough to contain the region. Please call initializeBuffer() with a bigger size.\");\n    return;\n  }\n\n  // Get the corresponding grid coordinates\n  Eigen::Vector3i min_id = worldToMap(min_pos);\n  Eigen::Vector3i max_id = worldToMap(max_pos);\n\n  // Iterate over the grid coordinates and reset the buffer\n  for (int x = min_id[0]; x <= max_id[0]; x++) {\n    for (int y = min_id[1]; y <= max_id[1]; y++) {\n      for (int z = min_id[2]; z <= max_id[2]; z++) {\n        occupancy_buffer_inflate_->at(x, y, z) = 0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 39.7339533542666}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  // Check if the map is initialized\n  if (!isInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: map is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isInflateBufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: inflate buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isDistanceBufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: distance buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isColorBufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: color buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isInfoBufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: info buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isExtraBufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: extra buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isExtra2BufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: extra2 buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isExtra3BufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: extra3 buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isExtra4BufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: extra4 buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is initialized\n  if (!isExtra5BufferInitialized()) {\n    ROS_ERROR(\"[GridMap::resetBuffer] Error: extra5 buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the", "CodeBleu_score": 10.841353943841256}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  Eigen::Vector3i min_id = world2map(min_pos);\n  Eigen::Vector3i max_id = world2map(max_pos);\n\n  for (int x = min_id[0]; x <= max_id[0]; x++) {\n    for (int y = min_id[1]; y <= max_id[1]; y++) {\n      for (int z = min_id[2]; z <= max_id[2]; z++) {\n        if (isValidIndex(Eigen::Vector3i(x, y, z))) {\n          occupancy_buffer_inflate_(x, y, z) = 0;\n          distance_buffer_(x, y, z) = std::numeric_limits<float>::infinity();\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 41.87083818953599}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    // compute the difference vector between the point and the camera position\n    Eigen::Vector3d diff_vec = pt - camera_pt;\n\n    // determine the maximum and minimum translation coefficients along each axis\n    double x_min = (x_min_ - diff_vec.x()) / diff_vec.x();\n    double x_max = (x_max_ - diff_vec.x()) / diff_vec.x();\n    double y_min = (y_min_ - diff_vec.y()) / diff_vec.y();\n    double y_max = (y_max_ - diff_vec.y()) / diff_vec.y();\n    double z_min = (z_min_ - diff_vec.z()) / diff_vec.z();\n    double z_max = (z_max_ - diff_vec.z()) / diff_vec.z();\n\n    // iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    double x_scale = 1.0;\n    double y_scale = 1.0;\n    double z_scale = 1.0;\n    if (diff_vec.x() > 0.0) {\n        x_scale = x_min;\n    }\n    else if (diff_vec.x() < 0.0) {\n        x_scale = x_max;\n    }\n    if (diff_vec.y() > 0.0) {\n        y_scale = y_min;\n    }\n    else if (diff_vec.y() < 0.0) {\n        y_scale = y_max;\n    }\n    if (diff_vec.z() > 0.0) {\n        z_scale = z_min;\n    }\n    else if (diff_vec.z() < 0.0) {\n        z_scale = z_max;\n    }\n\n    // return the adjusted point near the boundary\n    return camera_pt + diff_vec * std::min(std::min(x_scale, y_scale), z_scale);\n}\n", "CodeBleu_score": 34.813963532252146}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d diff = pt - camera_pt;\n    double x_min = (diff.x() > 0) ? diff.x() : 0;\n    double x_max = (diff.x() < 0) ? -diff.x() : 0;\n    double y_min = (diff.y() > 0) ? diff.y() : 0;\n    double y_max = (diff.y() < 0) ? -diff.y() : 0;\n    double z_min = (diff.z() > 0) ? diff.z() : 0;\n    double z_max = (diff.z() < 0) ? -diff.z() : 0;\n    double x_scale = x_min / x_max;\n    double y_scale = y_min / y_max;\n    double z_scale = z_min / z_max;\n    double scale = std::min(std::min(x_scale, y_scale), z_scale);\n    return camera_pt + diff * scale;\n}\n", "CodeBleu_score": 34.31270069440649}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d pt_diff = pt - camera_pt;\n    double max_x = std::min(std::abs(pt_diff[0]), (double) (width - 1));\n    double max_y = std::min(std::abs(pt_diff[1]), (double) (height - 1));\n    double max_z = std::min(std::abs(pt_diff[2]), (double) (depth - 1));\n    double min_x = 0;\n    double min_y = 0;\n    double min_z = 0;\n    if (pt_diff[0] > 0) {\n        min_x = max_x;\n    } else {\n        min_x = 0;\n    }\n    if (pt_diff[1] > 0) {\n        min_y = max_y;\n    } else {\n        min_y = 0;\n    }\n    if (pt_diff[2] > 0) {\n        min_z = max_z;\n    } else {\n        min_z = 0;\n    }\n    double min_scale = std::min(std::min(min_x, min_y), min_z);\n    return camera_pt + (pt_diff * min_scale);\n}\n", "CodeBleu_score": 40.388263767090244}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\n  // Update the last occupancy update time.\n  lastOccupancyUpdateTime_ = ros::Time::now();\n\n  // If the local map has been updated, clear and inflate the local map.\n  if (localMapUpdated_) {\n    localMapUpdated_ = false;\n    clearLocalMap();\n    inflateLocalMap();\n  }\n\n  // If an update is needed, project the depth image into points and process them with raycasting.\n  if (updateNeeded_) {\n    updateNeeded_ = false;\n\n    // If the odometry has not been updated, set the update flag to false.\n    if (odometryUpdateNeeded_) {\n      ROS_WARN_THROTTLE(1, \"Odometry update is needed, but no odometry has been received.\");\n      odometryUpdateNeeded_ = false;\n      updateNeeded_ = true;\n    }\n\n    // If the depth image has not been updated, set the update flag to false.\n    if (depthImageUpdateNeeded_) {\n      ROS_WARN_THROTTLE(1, \"Depth image update is needed, but no depth image has been received.\");\n      depthImageUpdateNeeded_ = false;\n      updateNeeded_ = true;\n    }\n\n    // If both the odometry and depth image have been updated, update the occupancy grid.\n    if (!updateNeeded_) {\n      // Get the latest odometry.\n      odom_ = odomQueue_.getLatest();\n\n      // Get the latest depth image.\n      depthImage_ = depthImageQueue_.getLatest();\n\n      // If the odometry and depth image are not valid, set the update flag to false.\n      if (!odom_.data_valid || !depthImage_.data_valid) {\n        ROS_WARN_THROTTLE(1, \"Odometry or depth image is not valid.\");\n        updateNeeded_ = true;\n      }\n\n      // If both the odometry and depth image are valid, update the occupancy grid.\n      if (!updateNeeded_) {\n        // Update the occupancy grid.\n        updateOccupancy();\n      }\n    }\n  }\n}\n", "CodeBleu_score": 38.03826594765171}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\n    // check for odometry update\n    if (!odom_updated_) {\n        ROS_WARN(\"Odometry not updated.\");\n        return;\n    }\n\n    // check for depth update\n    if (!depth_updated_) {\n        ROS_WARN(\"Depth not updated.\");\n        return;\n    }\n\n    // update the last update time\n    last_update_time_ = ros::Time::now();\n\n    // update the occupancy grid\n    updateOccupancyGrid();\n}\n", "CodeBleu_score": 17.12119747303466}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\n  // update last update time\n  lastUpdateTime_ = ros::Time::now();\n\n  // check if depth image is available\n  if (!depthImage_.data.empty()) {\n\n    // check if odometry is available\n    if (!odometry_.header.stamp.isZero()) {\n\n      // check if map is available\n      if (!map_.data.empty()) {\n\n        // check if map is updated\n        if (mapUpdate_) {\n\n          // clear and inflate map\n          clearAndInflateMap();\n\n        }\n\n        // check if map is updated\n        if (mapUpdate_) {\n\n          // process depth image\n          processDepthImage();\n\n        }\n\n      } else {\n\n        // set flag\n        mapUpdate_ = false;\n\n      }\n\n    } else {\n\n      // set flag\n      odometryUpdate_ = false;\n\n    }\n\n  } else {\n\n    // set flag\n    depthUpdate_ = false;\n\n  }\n\n  // check if odometry is available\n  if (!odometry_.header.stamp.isZero()) {\n\n    // check if map is available\n    if (!map_.data.empty()) {\n\n      // check if map is updated\n      if (mapUpdate_) {\n\n        // check if map is updated\n        if (mapUpdate_) {\n\n          // check if map is updated\n          if (mapUpdate_) {\n\n            // check if map is updated\n            if (mapUpdate_) {\n\n              // check if map is updated\n              if (mapUpdate_) {\n\n                // check if map is updated\n                if (mapUpdate_) {\n\n                  // check if map is updated\n                  if (mapUpdate_) {\n\n                    // check if map is updated\n                    if (mapUpdate_) {\n\n                      // check if map is updated\n                      if (mapUpdate_) {\n\n                        // check if map is updated\n                        if (mapUpdate_) {\n\n                          // check if map is updated\n                          if (mapUpdate_) {\n\n                            // check if map is updated\n                            if (mapUpdate_) {\n\n                              // check if map is updated\n                              if (map", "CodeBleu_score": 33.25264735090445}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat sum_f_measure = 0.0;\n\tint num_images = image_fns.size();\n\tfor(int i = 0; i < num_images; i++) {\n\t\tstring image_fn = image_fns[i];\n\t\tstring gt_fn = gt_fns[i];\n\t\tstring dt_fn = dt_fns[i];\n\t\tcout << \"image: \" << image_fn << endl;\n\t\tcout << \"ground truth: \" << gt_fn << endl;\n\t\tcout << \"detected: \" << dt_fn << endl;\n\t\tcv::Mat image = cv::imread(image_fn, CV_LOAD_IMAGE_COLOR);\n\t\tcv::Mat gt = cv::imread(gt_fn, CV_LOAD_IMAGE_COLOR);\n\t\tcv::Mat dt = cv::imread(dt_fn, CV_LOAD_IMAGE_COLOR);\n\t\tif(image.empty() || gt.empty() || dt.empty()) {\n\t\t\tcout << \"Error: image, ground truth, or detected image is empty!\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t// convert image to grayscale\n\t\tcv::Mat gray;\n\t\tcv::cvtColor(image, gray, CV_BGR2GRAY);\n\t\t// convert ground truth to grayscale\n\t\tcv::Mat gt_gray;\n\t\tcv::cvtColor(gt, gt_gray, CV_BGR2GRAY);\n\t\t// convert detected to grayscale\n\t\tcv::Mat dt_gray;\n\t\tcv::cvtColor(dt, dt_gray, CV_BGR2GRAY);\n\t\t// convert gt_angle to radians\n\t\tif(!gt_angle_radians) {\n\t\t\tfor(int i = 0; i < gt.rows; i++) {\n\t\t\t\tfor(int j = 0; j < gt.cols; j++) {\n\t\t\t\t\tgt.at<cv::Vec3b>(i, j)[2] = 180.0 / CV_PI * atan2(double(", "CodeBleu_score": 44.72696715830886}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)    int num_images = image_fns.size();\n    float total_f_measure = 0;\n    for (int i = 0; i < num_images; ++i) {\n        Mat image = imread(image_fns[i], CV_LOAD_IMAGE_COLOR);\n        Mat gt = imread(gt_fns[i], CV_LOAD_IMAGE_COLOR);\n        vector<Mat> detections;\n        for (int j = 0; j < dt_fns.size(); ++j) {\n            Mat detection = imread(dt_fns[j], CV_LOAD_IMAGE_COLOR);\n            detections.push_back(detection);\n        }\n        float f_measure = ellipse_evaluate(image, gt, detections, gt_angle_radians);\n        total_f_measure += f_measure;\n    }\n    return total_f_measure / num_images;\n}\n", "CodeBleu_score": 52.357150230494284}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\t\n\t// Initialize the F-measure accumulator\n\tfloat f_measure = 0;\n\t\n\t// Iterate through the image filenames\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\t\n\t\t// Load the image\n\t\tMat image = imread(image_fns[i], CV_LOAD_IMAGE_COLOR);\n\t\t\n\t\t// Load the ground truth\n\t\tvector<Ellipse> gt_ellipse;\n\t\t_ellipse_load(gt_fns[i], gt_ellipse, gt_angle_radians);\n\t\t\n\t\t// Load the detected ellipses\n\t\tvector<Ellipse> dt_ellipse;\n\t\t_ellipse_load(dt_fns[i], dt_ellipse, gt_angle_radians);\n\t\t\n\t\t// Calculate the F-measure\n\t\tf_measure += _ellipse_f_measure(image, gt_ellipse, dt_ellipse, gt_angle_radians);\n\t\t\n\t\t// Display the progress\n\t\tprintf(\"Evaluating image %d of %d\\r\", i+1, image_fns.size());\n\t\tfflush(stdout);\n\t}\n\t\n\t// Return the average F-measure\n\treturn f_measure / (float)image_fns.size();\n}\n", "CodeBleu_score": 58.88395518386933}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float angle;\n    if (foci != NULL) {\n        float dx1 = x - foci[0];\n        float dy1 = y - foci[1];\n        float dx2 = x - foci[2];\n        float dy2 = y - foci[3];\n        float dx = dx1 - dx2;\n        float dy = dy1 - dy2;\n        angle = atan2f(dy, dx);\n        if (angle < 0) {\n            angle += 2 * PI;\n        }\n        angle = atan2f(dy, dx);\n        if (angle < 0) {\n            angle += 2 * PI;\n        }\n    } else {\n        angle = 0;\n    }\n    return angle;\n}\n", "CodeBleu_score": 41.39836818859571}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float angle_to_focus_1 = atan2(y - foci[1], x - foci[0]);\n    float angle_to_focus_2 = atan2(y - foci[3], x - foci[2]);\n    float angle_to_focus_1_2 = angle_to_focus_2 - angle_to_focus_1;\n    float angle_to_focus_2_1 = angle_to_focus_1 - angle_to_focus_2;\n    float angle_to_focus_1_2_abs = fabs(angle_to_focus_1_2);\n    float angle_to_focus_2_1_abs = fabs(angle_to_focus_2_1);\n    float angle_to_focus_1_2_sign = copysign(1.0f, angle_to_focus_1_2);\n    float angle_to_focus_2_1_sign = copysign(1.0f, angle_to_focus_2_1);\n    float normal_angle;\n    if (angle_to_focus_1_2_abs > angle_to_focus_2_1_abs) {\n        normal_angle = angle_to_focus_1_2_sign * angle_to_focus_1_2;\n    } else {\n        normal_angle = angle_to_focus_2_1_sign * angle_to_focus_2_1;\n    }\n    normal_angle = normal_angle > 0.0f ? normal_angle : normal_angle + 2.0f * M_PI_F;\n    return normal_angle;\n}\n", "CodeBleu_score": 43.00891242060764}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float dx1 = x - foci[0];\n    float dy1 = y - foci[1];\n    float dx2 = x - foci[2];\n    float dy2 = y - foci[3];\n    float angle1 = atan2(dy1, dx1);\n    float angle2 = atan2(dy2, dx2);\n    float angle = angle2 - angle1;\n    if (angle > M_PI) {\n        angle -= 2.0 * M_PI;\n    }\n    if (angle < -M_PI) {\n        angle += 2.0 * M_PI;\n    }\n    return angle;\n}\n", "CodeBleu_score": 40.78897130707507}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)\tif (start == end) return false;\n\tif (start == end - 1) {\n\t\treturn (vp1[start].x - vp1[end].x) * (vp1[start].y + vp1[end].y) < 0;\n\t}\n\tint min_x = vp1[start].x;\n\tint max_x = vp1[start].x;\n\tint min_y = vp1[start].y;\n\tint max_y = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\tint area = (max_x - min_x) * (max_y + min_y);\n\tint sum = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tsum += vp1[i].x * vp1[i + 1].y - vp1[i + 1].x * vp1[i].y;\n\t}\n\tsum += vp1[end].x * vp1[start].y - vp1[start].x * vp1[end].y;\n\tif (sum < area) return true;\n\telse return false;\n}\n", "CodeBleu_score": 35.01407848273013}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\t// if the number of points in the polygon is less than 3, return false\n\tif (vp1.size() < 3)\n\t\treturn false;\n\n\t// if the start index is greater than the end index, return false\n\tif (start > end)\n\t\treturn false;\n\n\t// if the start index is greater than or equal to the number of points, return false\n\tif (start >= vp1.size())\n\t\treturn false;\n\n\t// if the end index is greater than or equal to the number of points, set it equal to the number of points\n\tif (end >= vp1.size())\n\t\tend = vp1.size() - 1;\n\n\t// initialize the min and max x and y values\n\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\n\t// initialize the integral above and below the polygon section\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\t// loop through the points in the section\n\tfor (int i = start; i <= end; i++) {\n\t\t// if the current x value is less than the min x value, set the min x value equal to the current x value\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\n\t\t// if the current x value is greater than the max x value, set the max x value equal to the current x value\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\n\t\t// if the current y value is less than the min y value, set the min y value equal to the current y value\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\n\t\t// if the current y value is greater than the max y value, set the max y value equal to the current y value\n\t\t", "CodeBleu_score": 33.039177153136784}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\t//Check if the section is concave\n\tif (end - start < 3) {\n\t\treturn false;\n\t}\n\tint max_x = vp1[start].x;\n\tint max_y = vp1[start].y;\n\tint min_x = vp1[start].x;\n\tint min_y = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t}\n\tint integral_above = 0;\n\tint integral_below = 0;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tintegral_above += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y + vp1[i - 1].y);\n\t}\n\tfor (int i = end - 2; i > start; i--) {\n\t\tintegral_below += (vp1[i].x - vp1[i + 1].x) * (vp1[i].y + vp1[i + 1].y);\n\t}\n\tif (integral_above < integral_below) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 34.270102059279395}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)  if(msg->detections.size() > 0) {\n    for(int i = 0; i < msg->detections.size(); i++) {\n      if(msg->detections[i].label == \"T\") {\n        num_regain++;\n        num_lost = 0;\n      }\n      else {\n        num_lost++;\n        num_regain = 0;\n      }\n    }\n  }\n\n  if(num_lost >= VISION_THRES) {\n    is_detected = false;\n  }\n  else if(num_regain >= VISION_THRES) {\n    is_detected = true;\n  }\n\n  if(is_detected) {\n    ellipse_det.sight_angle = msg->detections[0].sight_angle;\n  }\n  else {\n    ellipse_det.sight_angle = msg->detections[1].sight_angle;\n  }\n}\n", "CodeBleu_score": 63.646409681533235}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)  // std::cout << \"ellipse_det_cb\" << std::endl;\n  for (int i = 0; i < msg->detections.size(); ++i) {\n    if (msg->detections[i].id == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    }\n    else {\n      num_regain = 0;\n      num_lost++;\n    }\n  }\n\n  if (num_lost > VISION_THRES) {\n    is_detected = false;\n  }\n  else if (num_regain > VISION_THRES) {\n    is_detected = true;\n  }\n\n  if (is_detected) {\n    ellipse_det.sight_angle = -ellipse_det.sight_angle;\n  }\n}\n", "CodeBleu_score": 61.60876447094059}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)    // Check if the detection info is empty\n    if (msg->detections.empty()) {\n        //ROS_WARN(\"[ellipse_det_cb] No detection info.\");\n        return;\n    }\n\n    // Check if the detection info is from the right camera\n    if (msg->detections[0].camera_id != 0) {\n        //ROS_WARN(\"[ellipse_det_cb] Detection info is not from the right camera.\");\n        return;\n    }\n\n    // Check if the detection info is from the right camera\n    if (msg->detections[0].camera_id != 0) {\n        //ROS_WARN(\"[ellipse_det_cb] Detection info is not from the right camera.\");\n        return;\n    }\n\n    // Check if the detection info is from the right camera\n    if (msg->detections[0].camera_id != 0) {\n        //ROS_WARN(\"[ellipse_det_cb] Detection info is not from the right camera.\");\n        return;\n    }\n\n    // Check if the detection info is from the right camera\n    if (msg->detections[0].camera_id != 0) {\n        //ROS_WARN(\"[ellipse_det_cb] Detection info is not from the right camera.\");\n        return;\n    }\n\n    // Check if the detection info is from the right camera\n    if (msg->detections[0].camera_id != 0) {\n        //ROS_WARN(\"[ellipse_det_cb] Detection info is not from the right camera.\");\n        return;\n    }\n\n    // Check if the detection info is from the right camera\n    if (msg->detections[0].camera_id != 0) {\n        //ROS_WARN(\"[ellipse_det_cb] Detection info is not from the right camera.\");\n        return;\n    }\n\n    // Check if the detection info is from the right camera\n    if (msg->detections[0].camera_id != 0) {\n        //ROS_WARN(\"[ellipse_det", "CodeBleu_score": 23.693528784877596}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\n    // check safety\n    double safety_distance = 0.0;\n    bool safe = true;\n    for (int i = 0; i < 3; i++) {\n        safety_distance += (cur_pos[i] - safe_distance) * (cur_pos[i] - safe_distance);\n    }\n    if (safety_distance < 1e-3) {\n        safe = false;\n    }\n\n    return safe;\n}\n", "CodeBleu_score": 43.81537083537843}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)    bool safe = true;\n    if (Occupy_map_ptr != NULL) {\n        int mx, my, mz;\n        if (check_in_map(cur_pos, mx, my, mz)) {\n            if (Occupy_map_ptr->getOccupancy(mx, my, mz) >= 0.5) {\n                safe = false;\n            }\n        }\n    }\n    return safe;\n}\n", "CodeBleu_score": 44.896516864992805}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)    Eigen::Vector3d safe_pos = cur_pos;\n    safe_pos[2] += safe_distance;\n    double safe_yaw = getYaw(cur_pos);\n    double safe_yaw_rate = 0.0;\n    double safe_velocity = 0.0;\n    double safe_acceleration = 0.0;\n    double safe_jerk = 0.0;\n    double safe_time = 0.0;\n    double safe_distance_to_goal = 0.0;\n    double safe_distance_to_obs = 0.0;\n    double safe_distance_to_obs_front = 0.0;\n    double safe_distance_to_obs_back = 0.0;\n    double safe_distance_to_obs_left = 0.0;\n    double safe_distance_to_obs_right = 0.0;\n    double safe_distance_to_obs_front_left = 0.0;\n    double safe_distance_to_obs_front_right = 0.0;\n    double safe_distance_to_obs_back_left = 0.0;\n    double safe_distance_to_obs_back_right = 0.0;\n    bool safe = true;\n    bool safe_front = true;\n    bool safe_back = true;\n    bool safe_left = true;\n    bool safe_right = true;\n    bool safe_front_left = true;\n    bool safe_front_right = true;\n    bool safe_back_left = true;\n    bool safe_back_right = true;\n    bool safe_yaw_rate = true;\n    bool safe_velocity = true;\n    bool safe_acceleration = true;\n    bool safe_jerk = true;\n    bool safe_time = true;\n    bool safe_distance_to_goal = true;\n    bool safe_distance_to_obs = true;\n    bool safe_distance_to_obs_front = true;\n    bool safe_distance_to_obs_back = true;\n    bool safe_distance_to_obs_left = true;\n    bool safe_", "CodeBleu_score": 34.21879393582221}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n    while (current_node->getParent() != nullptr) {\n        current_node = current_node->getParent();\n        path_nodes_.push_back(current_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 62.12647026427312}, {"code": "void Astar::retrievePath(NodePtr end_node)    path_nodes_.clear();\n    NodePtr current_node = end_node;\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 57.957570702315095}, {"code": "void Astar::retrievePath(NodePtr end_node)\tNodePtr current_node = end_node;\n\tpath_nodes_.push_back(current_node);\n\twhile (current_node != start_node_) {\n\t\tcurrent_node = current_node->parent;\n\t\tpath_nodes_.push_back(current_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 59.74219919649051}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     //ROS_INFO(\"nei_odom_cb\");\n    if (id == 0) {\n        state_nei[0][0] = odom->pose.pose.position.x;\n        state_nei[0][1] = odom->pose.pose.position.y;\n        state_nei[0][2] = odom->pose.pose.position.z;\n        state_nei[0][3] = odom->twist.twist.linear.x;\n        state_nei[0][4] = odom->twist.twist.linear.y;\n        state_nei[0][5] = odom->twist.twist.linear.z;\n        state_nei[0][6] = odom->twist.twist.angular.x;\n        state_nei[0][7] = odom->twist.twist.angular.y;\n        state_nei[0][8] = odom->twist.twist.angular.z;\n        state_nei[0][9] = odom->twist.twist.linear.x;\n        state_nei[0][10] = odom->twist.twist.linear.y;\n        state_nei[0][11] = odom->twist.twist.linear.z;\n        state_nei[0][12] = odom->twist.twist.angular.x;\n        state_nei[0][13] = odom->twist.twist.angular.y;\n        state_nei[0][14] = odom->twist.twist.angular.z;\n        state_nei[0][15] = odom->twist.twist.linear.x;\n        state_nei[0][16] = odom->twist.twist.linear.y;\n        state_nei[0][17] = odom->twist.twist.linear.z;\n        state_nei[0][18] = odom->twist.twist.angular.x;\n        state_nei[0][", "CodeBleu_score": 31.05796975501717}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)   // ROS_INFO(\"nei_odom_cb\");\n  double x, y, z;\n  x = odom->pose.pose.position.x;\n  y = odom->pose.pose.position.y;\n  z = odom->pose.pose.position.z;\n  state_nei[id][0] = x;\n  state_nei[id][1] = y;\n  state_nei[id][2] = z;\n  if (sim_mode) {\n    if (sqrt(pow(x-start_x,2)+pow(y-start_y,2))>5) {\n      get_nei_state[id] = false;\n    }\n    else {\n      get_nei_state[id] = true;\n    }\n  }\n  else {\n    get_nei_state[id] = true;\n  }\n}\n", "CodeBleu_score": 58.11175776897164}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     double x_nei = odom->pose.pose.position.x;\n    double y_nei = odom->pose.pose.position.y;\n    double z_nei = odom->pose.pose.position.z;\n    double yaw_nei = tf::getYaw(odom->pose.pose.orientation);\n    state_nei[id][0] = x_nei;\n    state_nei[id][1] = y_nei;\n    state_nei[id][2] = z_nei;\n    state_nei[id][3] = yaw_nei;\n    if (simulation_mode) {\n        if (sqrt(pow(x_nei - start_pos[0], 2) + pow(y_nei - start_pos[1], 2)) > 5) {\n            get_nei_state[id] = false;\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n    else {\n        get_nei_state[id] = true;\n    }\n}\n", "CodeBleu_score": 59.038938062551}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    if (odom_ready) {\n        sensor_ready = true;\n        update_counter++;\n        if (update_counter % 5 == 0) {\n            if (!map_ready) {\n                std::cout << \"Received first point cloud data. Creating Astar map.\" << std::endl;\n                create_map(msg);\n                map_ready = true;\n            } else {\n                std::cout << \"Updating Astar map with new point cloud data.\" << std::endl;\n                update_map(msg);\n            }\n            update_counter = 0;\n        }\n    }\n}\n", "CodeBleu_score": 51.295385727381195}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  // Check if odometry is ready\n  if (!odom_ready)\n    return;\n\n  // If odometry is ready, set sensor_ready flag to true\n  sensor_ready = true;\n\n  // Increment update counter\n  update_counter++;\n\n  // If update counter is divisible by 5, update Astar map\n  if (update_counter % 5 == 0) {\n    // Update Astar map\n    update_astar_map(msg);\n\n    // Reset update counter\n    update_counter = 0;\n  }\n}\n", "CodeBleu_score": 48.410632367380934}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    if (!odometry_ready) {\n        return;\n    }\n    sensor_ready = true;\n    if (update_counter % 5 == 0) {\n        pcl::fromROSMsg(*msg, *pcl_ptr);\n        pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_ptr_new(new pcl::PointCloud<pcl::PointXYZI>);\n        pcl::fromROSMsg(*msg, *pcl_ptr_new);\n        Astar_map.updateMap(pcl_ptr_new);\n        update_counter = 0;\n    }\n    update_counter++;\n}\n", "CodeBleu_score": 55.594679562889674}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_pcl);\n    inflate_map();\n  }\n}\n", "CodeBleu_score": 41.19947302097076}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\n  // If the global map has not been updated yet, set the flag and convert the sensor message to a point cloud.\n  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_pcl);\n  }\n\n  // Inflate the point cloud.\n  pcl::VoxelGrid<pcl::PointXYZ> voxel_filter;\n  voxel_filter.setInputCloud(global_pcl);\n  voxel_filter.setLeafSize(0.1f, 0.1f, 0.1f);\n  voxel_filter.filter(*global_pcl);\n\n  // Store the inflated point cloud.\n  pcl::io::savePCDFileASCII(\"map.pcd\", *global_pcl);\n}\n", "CodeBleu_score": 50.78501711505938}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, global_pcl);\n    inflate_pointcloud(global_pcl);\n  }\n}\n", "CodeBleu_score": 46.297207525357045}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\n  // Convert laser scan message to a PointCloud2 message\n  sensor_msgs::PointCloud2 laserCloud;\n  pcl::PointCloud<pcl::PointXYZ> laserCloud_temp;\n  pcl::fromROSMsg(*local_point, laserCloud);\n  pcl::toROSMsg(laserCloud, laserCloud_temp);\n\n  // Convert the laser scan message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloudIn(new pcl::PointCloud<pcl::PointXYZ>());\n  pcl::fromROSMsg(laserCloud_temp, *laserCloudIn);\n\n  // Create a PointCloud for storing the projected laser scan data\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloudOut(new pcl::PointCloud<pcl::PointXYZ>());\n\n  // Create a PointCloud for storing the projected laser scan data\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloudOut_temp(new pcl::PointCloud<pcl::PointXYZ>());\n\n  // Create a PointCloud for storing the projected laser scan data\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloudOut_temp2(new pcl::PointCloud<pcl::PointXYZ>());\n\n  // Create a PointCloud for storing the projected laser scan data\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloudOut_temp3(new pcl::PointCloud<pcl::PointXYZ>());\n\n  // Create a PointCloud for storing the projected laser scan data\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloudOut_temp4(new pcl::PointCloud<pcl::PointXYZ>());\n\n  // Create a PointCloud for storing the projected laser scan data\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloudOut_temp5(new pcl::PointCloud<pcl::PointXYZ>());\n\n  // Create a PointCloud for storing the projected laser scan data\n", "CodeBleu_score": 41.449857952864036}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\n    // Transform the laser scan into a PointCloud2 format\n    sensor_msgs::PointCloud2 laserCloud;\n    laserCloud.header.stamp = local_point->header.stamp;\n    laserCloud.header.frame_id = local_point->header.frame_id;\n    laserCloud.height = 1;\n    laserCloud.width = local_point->ranges.size();\n    laserCloud.fields.resize(2);\n    laserCloud.fields[0].name = \"x\";\n    laserCloud.fields[0].offset = 0;\n    laserCloud.fields[0].datatype = sensor_msgs::PointField::FLOAT32;\n    laserCloud.fields[0].count = 1;\n    laserCloud.fields[1].name = \"y\";\n    laserCloud.fields[1].offset = 4;\n    laserCloud.fields[1].datatype = sensor_msgs::PointField::FLOAT32;\n    laserCloud.fields[1].count = 1;\n    laserCloud.is_bigendian = false;\n    laserCloud.point_step = 8;\n    laserCloud.row_step = laserCloud.point_step * laserCloud.width;\n    laserCloud.data.resize(laserCloud.row_step * laserCloud.height);\n    for (size_t i = 0; i < laserCloud.width; ++i) {\n        float * point = (float *) (&laserCloud.data[i * laserCloud.point_step]);\n        point[0] = local_point->ranges[i] * cos(local_point->angle_min + i * local_point->angle_increment);\n        point[1] = local_point->ranges[i] * sin(local_point->angle_min + i * local_point->angle_increment);\n    }\n\n    // Convert the PointCloud2 format to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> laserCloud_pcl;\n    pcl::fromROSMsg(laserCloud, las", "CodeBleu_score": 39.023350982802874}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// Conversion from laser scan to PointCloud2 format\n\tsensor_msgs::PointCloud2 local_point_cloud;\n\tsensor_msgs::PointCloud2ConstPtr local_point_cloud_ptr(new sensor_msgs::PointCloud2(*local_point));\n\tpcl::PointCloud<pcl::PointXYZ> local_point_cloud_pcl;\n\tpcl::fromROSMsg(*local_point_cloud_ptr, local_point_cloud_pcl);\n\n\t// Conversion from odometry to PointCloud2 format\n\tsensor_msgs::PointCloud2 odom_point_cloud;\n\tsensor_msgs::PointCloud2ConstPtr odom_point_cloud_ptr(new sensor_msgs::PointCloud2(odom.pose.pose.position));\n\tpcl::PointCloud<pcl::PointXYZ> odom_point_cloud_pcl;\n\tpcl::fromROSMsg(*odom_point_cloud_ptr, odom_point_cloud_pcl);\n\n\t// If in simulation mode, it merges the local map with the odometry data.\n\tif (simulation_mode) {\n\t\tpcl::PointCloud<pcl::PointXYZ> merged_point_cloud;\n\t\tpcl::concatenatePointCloud(local_point_cloud_pcl, odom_point_cloud_pcl, merged_point_cloud);\n\t\tpcl::toROSMsg(merged_point_cloud, local_point_cloud);\n\t}\n\n\t// If in simulation mode, it publishes the local map\n\tif (simulation_mode) {\n\t\tlocal_map_pub.publish(local_point_cloud);\n\t}\n\n\t// Conversion from laser scan to pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_point_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(local_point_cloud_pcl));\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr odom_point_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(odom_point", "CodeBleu_score": 42.99176026594154}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)    // Convert the map to a ROS message\n    sensor_msgs::PointCloud2 map_pcl;\n    pcl::toROSMsg(map_cloud, map_pcl);\n    map_pcl.header.stamp = ros::Time::now();\n    map_pcl.header.frame_id = \"world\";\n\n    // Publish the map point cloud\n    global_pcl_pub.publish(map_pcl);\n\n    // Publish the inflated point cloud\n    sensor_msgs::PointCloud2 inflated_pcl;\n    pcl::toROSMsg(inflate_cloud, inflated_pcl);\n    inflated_pcl.header.stamp = ros::Time::now();\n    inflated_pcl.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflated_pcl);\n}\n", "CodeBleu_score": 56.415006903324304}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)    // convert global map to ROS message\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl_map, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_msg.header.stamp = ros::Time::now();\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // convert inflated map to ROS message\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl_map, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_msg.header.stamp = ros::Time::now();\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 55.8393979343643}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)    // Convert the occupancy grid to a point cloud and publish it\n    pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_map(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_map_inflate(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_map_inflate_filtered(new pcl::PointCloud<pcl::PointXYZI>);\n\n    // Convert the occupancy grid to a point cloud\n    grid_map::GridMapRosConverter::toPCL(*grid_map_ptr_, *pcl_map);\n\n    // Convert the occupancy grid to a point cloud\n    grid_map::GridMapRosConverter::toPCL(*grid_map_ptr_, *pcl_map_inflate, \"inflate\");\n\n    // Filter the inflated point cloud\n    pcl::PassThrough<pcl::PointXYZI> pass;\n    pass.setInputCloud(pcl_map_inflate);\n    pass.setFilterFieldName(\"z\");\n    pass.setFilterLimits(0.0, 1.0);\n    pass.filter(*pcl_map_inflate_filtered);\n\n    // Publish the point cloud\n    global_pcl_pub.publish(pcl_map);\n\n    // Publish the inflated point cloud\n    inflate_pcl_pub.publish(pcl_map_inflate_filtered);\n\n    // Publish the point cloud map\n    grid_map_msgs::GridMap msg;\n    grid_map::GridMapRosConverter::toMessage(*grid_map_ptr_, msg);\n    map_pub.publish(msg);\n}\n", "CodeBleu_score": 45.94121908909594}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\n  // get the current time\n  ros::Time current_time = ros::Time::now();\n\n  // check if the UAV is ready\n  if (uav_ready) {\n    // check if the sensor is ready\n    if (!sensor_ready) {\n      // check if the sensor is ready\n      if (current_time - odom_time < ros::Duration(0.5)) {\n        sensor_ready = true;\n        // update the A* algorithm's map\n        update_map();\n      }\n    }\n  }\n}\n", "CodeBleu_score": 51.80945320537616}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\n    //If odometry is not ready, do not process point cloud\n    if (!odometry_ready) {\n        ROS_DEBUG(\"Odometry is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the sensor is not ready, do not process point cloud\n    if (!sensor_ready) {\n        ROS_DEBUG(\"Sensor is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready, do not process point cloud\n    if (!map_ready) {\n        ROS_DEBUG(\"Map is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready, do not process point cloud\n    if (!path_ready) {\n        ROS_DEBUG(\"Path is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready, do not process point cloud\n    if (!traj_ready) {\n        ROS_DEBUG(\"Trajectory is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready, do not process point cloud\n    if (!pose_ready) {\n        ROS_DEBUG(\"Pose is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready, do not process point cloud\n    if (!goal_ready) {\n        ROS_DEBUG(\"Goal is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready, do not process point cloud\n    if (!sensor_ready) {\n        ROS_DEBUG(\"Sensor is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready, do not process point cloud\n    if (!map_ready) {\n        ROS_DEBUG(\"Map is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready, do not process point cloud\n    if (!path_ready) {\n        ROS_DEBUG(\"Path is not ready, not processing point cloud.\");\n        return;\n    }\n\n    //If the map is not ready,", "CodeBleu_score": 40.6882650886913}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    // Convert the incoming point cloud message to a pcl::PointCloud<pcl::PointXYZ>\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*msg, cloud);\n\n    // Convert the point cloud to a pcl::PointCloud<pcl::PointXYZRGB>\n    pcl::PointCloud<pcl::PointXYZRGB> cloud_rgb;\n    pcl::copyPointCloud(cloud, cloud_rgb);\n\n    // Convert the point cloud to a pcl::PointCloud<pcl::PointXYZI>\n    pcl::PointCloud<pcl::PointXYZI> cloud_intensity;\n    pcl::copyPointCloud(cloud, cloud_intensity);\n\n    // Convert the point cloud to a pcl::PointCloud<pcl::PointXYZRGBL>\n    pcl::PointCloud<pcl::PointXYZRGBL> cloud_rgbl;\n    pcl::copyPointCloud(cloud, cloud_rgbl);\n\n    // Convert the point cloud to a pcl::PointCloud<pcl::PointXYZINormal>\n    pcl::PointCloud<pcl::PointXYZINormal> cloud_normals;\n    pcl::copyPointCloud(cloud, cloud_normals);\n\n    // Convert the point cloud to a pcl::PointCloud<pcl::PointXYZINormal>\n    pcl::PointCloud<pcl::PointXYZINormal> cloud_normals_intensity;\n    pcl::copyPointCloud(cloud, cloud_normals_intensity);\n\n    // Convert the point cloud to a pcl::PointCloud<pcl::PointXYZINormal>\n    pcl::PointCloud<pcl::PointXYZINormal> cloud_normals_intensity_rgb;\n    pcl::copyPointCloud(cloud, cloud_normals_intensity_rgb);\n\n    // Convert the point cloud to a pcl::PointCloud<pcl::PointXYZINormal>\n    pcl::PointCloud<pcl::PointXYZINormal> cloud_normals_intensity_rgbl;\n    pcl::copyPointCloud(cloud", "CodeBleu_score": 37.084766517351646}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Get the current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get the current pose\n  geometry_msgs::Pose current_pose;\n  current_pose = body_controller_.getPose();\n\n  // Get the current velocity\n  geometry_msgs::Twist current_velocity;\n  current_velocity = body_controller_.getVelocity();\n\n  // Get the current foot positions\n  std::vector<geometry_msgs::Pose> current_foot_positions;\n  for (int leg_index = 0; leg_index < 4; leg_index++) {\n    current_foot_positions.push_back(leg_controller_[leg_index].getPose());\n  }\n\n  // Get the current foot velocities\n  std::vector<geometry_msgs::Twist> current_foot_velocities;\n  for (int leg_index = 0; leg_index < 4; leg_index++) {\n    current_foot_velocities.push_back(leg_controller_[leg_index].getVelocity());\n  }\n\n  // Get the current foot accelerations\n  std::vector<geometry_msgs::Twist> current_foot_accelerations;\n  for (int leg_index = 0; leg_index < 4; leg_index++) {\n    current_foot_accelerations.push_back(leg_controller_[leg_index].getAcceleration());\n  }\n\n  // Get the current foot torques\n  std::vector<double> current_foot_torques;\n  for (int leg_index = 0; leg_index < 4; leg_index++) {\n    current_foot_torques.push_back(leg_controller_[leg_index].getTorque());\n  }\n\n  // Get the current joint positions\n  std::vector<double> current_joint_positions;\n  for (int leg_index = 0; leg_index < 4; leg_index++) {\n    current_joint_positions.push_back(leg_controller_[leg_index].getJointPosition());\n  }\n\n", "CodeBleu_score": 31.811312110814338}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Get the current pose\n\tgeometry_msgs::PoseStamped current_pose;\n\tcurrent_pose.header.stamp = current_time;\n\tcurrent_pose.header.frame_id = \"world\";\n\tif (odom_sub_.getNumPublishers() > 0) {\n\t\todom_pub_.publish(current_pose);\n\t}\n\n\t// Get the current foot positions\n\tstd::vector<geometry_msgs::PoseStamped> current_foot_positions;\n\tfor (int leg = 0; leg < 4; leg++) {\n\t\tcurrent_foot_positions.push_back(getFootPose(leg));\n\t}\n\n\t// Get the current joint positions\n\tstd::vector<double> current_joint_positions;\n\tfor (int joint = 0; joint < 12; joint++) {\n\t\tcurrent_joint_positions.push_back(getJointPosition(joint));\n\t}\n\n\t// Get the current foot velocities\n\tstd::vector<geometry_msgs::TwistStamped> current_foot_velocities;\n\tfor (int leg = 0; leg < 4; leg++) {\n\t\tcurrent_foot_velocities.push_back(getFootVelocity(leg));\n\t}\n\n\t// Get the current joint velocities\n\tstd::vector<double> current_joint_velocities;\n\tfor (int joint = 0; joint < 12; joint++) {\n\t\tcurrent_joint_velocities.push_back(getJointVelocity(joint));\n\t}\n\n\t// Get the current foot accelerations\n\tstd::vector<geometry_msgs::TwistStamped> current_foot_accelerations;\n\tfor (int leg = 0; leg < 4; leg++) {\n\t\tcurrent_foot_accelerations.push_back(getFootAcceleration(leg));\n\t}\n\n\t// Get the current joint accelerations\n\tstd::vector<double> current_joint_accelerations;", "CodeBleu_score": 39.55825447242992}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\n  // Get the current time\n  ros::Time time = ros::Time::now();\n\n  // Get the current time\n  double time_now = time.toSec();\n\n  // Get the current time\n  double time_prev = time_now - dt_;\n\n  // Get the current time\n  double time_prev2 = time_now - 2 * dt_;\n\n  // Get the current time\n  double time_prev3 = time_now - 3 * dt_;\n\n  // Get the current time\n  double time_prev4 = time_now - 4 * dt_;\n\n  // Get the current time\n  double time_prev5 = time_now - 5 * dt_;\n\n  // Get the current time\n  double time_prev6 = time_now - 6 * dt_;\n\n  // Get the current time\n  double time_prev7 = time_now - 7 * dt_;\n\n  // Get the current time\n  double time_prev8 = time_now - 8 * dt_;\n\n  // Get the current time\n  double time_prev9 = time_now - 9 * dt_;\n\n  // Get the current time\n  double time_prev10 = time_now - 10 * dt_;\n\n  // Get the current time\n  double time_prev11 = time_now - 11 * dt_;\n\n  // Get the current time\n  double time_prev12 = time_now - 12 * dt_;\n\n  // Get the current time\n  double time_prev13 = time_now - 13 * dt_;\n\n  // Get the current time\n  double time_prev14 = time_now - 14 * dt_;\n\n  // Get the current time\n  double time_prev15 = time_now - 15 * dt_;\n\n  // Get the current time\n  double time_prev16 = time_now - 16 * dt_;\n\n  // Get the current time\n  double time_prev17 = time_now - 17 * dt_;\n\n  // Get the current time\n  double time_prev18 = time_now - 18 * dt_;\n\n  // Get the current time", "CodeBleu_score": 33.66377141304565}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])    if (foot_contacts_publishing_enabled_) {\n        if (robot_in_gazebo_) {\n            if (foot_contacts_publisher_ == nullptr) {\n                ROS_ERROR_NAMED(name_,\"foot_contacts_publisher_ is nullptr\");\n                return;\n            }\n            for (int i = 0; i < 4; i++) {\n                std_msgs::Bool msg;\n                msg.data = foot_contacts[i];\n                foot_contacts_publisher_->publish(msg);\n            }\n        } else {\n            if (contacts_stamped_publisher_ == nullptr) {\n                ROS_ERROR_NAMED(name_,\"contacts_stamped_publisher_ is nullptr\");\n                return;\n            }\n            contacts_stamped_publisher_->publish(contacts_stamped_msg_);\n        }\n    }\n}\n", "CodeBleu_score": 38.26343982807139}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])    if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n        contacts_stamped_.header.stamp = ros::Time::now();\n        contacts_stamped_.contacts.resize(4);\n        for (int i = 0; i < 4; i++) {\n            contacts_stamped_.contacts[i].phase = current_gait_phase_[i];\n            contacts_stamped_.contacts[i].state = foot_contacts[i];\n        }\n        foot_contacts_publisher_.publish(contacts_stamped_);\n    }\n}\n", "CodeBleu_score": 52.965307601651624}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])    // Publish foot contact information\n    if (foot_contacts_publisher_ != NULL) {\n        if (foot_contacts_publisher_->trylock()) {\n            foot_contacts_publisher_->msg_.contacts.resize(4);\n            for (int i = 0; i < 4; i++) {\n                foot_contacts_publisher_->msg_.contacts[i].name = leg_names_[i];\n                foot_contacts_publisher_->msg_.contacts[i].in_contact = foot_contacts[i];\n            }\n            foot_contacts_publisher_->msg_.header.stamp = ros::Time::now();\n            foot_contacts_publisher_->unlockAndPublish();\n        }\n    }\n}\n", "CodeBleu_score": 50.47980093198421}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)    joints_msg = JointState()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joints_msg.position = [joints.position.joint_1, joints.position.joint_2, joints.position.joint_3, joints.position.joint_4, joints.position.joint_5, joints.position.joint_6, joints.position.joint_7, joints.position.joint_8, joints.position.joint_9, joints.position.joint_10, joints.position.joint_11, joints.position.joint_12]\n    joints_msg.velocity = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    joints_msg.effort = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    self.pub_joints.publish(joints_msg)\n\n    joints_traj_msg = JointTrajectory()\n    joints_traj_msg.header.stamp = rospy.Time.now()\n    joints_traj_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joints_traj_msg.points = [JointTra", "CodeBleu_score": 36.015749308459164}, {"code": "def joints_cmd_callback(self, joints)    joints_msg = JointState()\n    joints_msg.header = Header()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.header.frame_id = \"base_link\"\n    joints_msg.name = [\"shoulder_pan_joint\", \"shoulder_lift_joint\", \"elbow_joint\", \"wrist_1_joint\", \"wrist_2_joint\", \"wrist_3_joint\", \"torso_lift_joint\", \"torso_roll_joint\", \"head_pan_joint\", \"head_tilt_joint\", \"head_lift_joint\"]\n    joints_msg.position = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10]]\n    self.pub_joints.publish(joints_msg)\n    self.traj_msg.header = Header()\n    self.traj_msg.header.stamp = rospy.Time.now()\n    self.traj_msg.header.frame_id = \"base_link\"\n    self.traj_msg.joint_names = [\"shoulder_pan_joint\", \"shoulder_lift_joint\", \"elbow_joint\", \"wrist_1_joint\", \"wrist_2_joint\", \"wrist_3_joint\", \"torso_lift_joint\", \"torso_roll_joint\", \"head_pan_joint\", \"head_tilt_joint\", \"head_lift_joint\"]\n    self.traj_msg.points.append(JointTrajectoryPoint())\n    self.traj_msg.points[0].positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[", "CodeBleu_score": 34.79872832772758}, {"code": "def joints_cmd_callback(self, joints)    rospy.loginfo(\"Received joints command\")\n    joints_msg = JointState()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    joints_msg.position = [joints.joint_1, joints.joint_2, joints.joint_3, joints.joint_4, joints.joint_5, joints.joint_6, joints.joint_7, joints.joint_8, joints.joint_9, joints.joint_10, joints.joint_11, joints.joint_12]\n    self.joint_pub.publish(joints_msg)\n    self.joint_traj_pub.publish(self.construct_joint_trajectory(joints_msg.position, 1.0))\n}\n", "CodeBleu_score": 36.128852188688526}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)    for (unsigned int i = 0; i < _msg->contact_size(); i++) {\n        std::string contact_name = _msg->contact(i).collision2();\n        if (contact_name.find(\"l_foot_contact\") != std::string::npos) {\n            l_foot_contact = true;\n        } else if (contact_name.find(\"r_foot_contact\") != std::string::npos) {\n            r_foot_contact = true;\n        }\n    }\n}\n", "CodeBleu_score": 34.80864255640121}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::string collision = _msg->contact(i).collision2();\n    std::string link = collision.substr(0, collision.find_first_of(\"_\"));\n    if (link == \"foot_left\" || link == \"foot_right\") {\n      if (link == \"foot_left\") {\n        left_contact = true;\n      } else {\n        right_contact = true;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 40.32314179534484}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    footContact[i] = false;\n  }\n\n  // For each contact in the message, split the collision string to identify the contact link\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string\n    std::vector<std::string> collision_split = split(_msg->contact(i).collision2(), '/');\n\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (collision_split[collision_split.size() - 1] == \"l_foot_contact\") {\n      footContact[0] = true;\n    } else if (collision_split[collision_split.size() - 1] == \"r_foot_contact\") {\n      footContact[1] = true;\n    } else if (collision_split[collision_split.size() - 1] == \"l_foot_contact_2\") {\n      footContact[2] = true;\n    } else if (collision_split[collision_split.size() - 1] == \"r_foot_contact_2\") {\n      footContact[3] = true;\n    }\n  }\n}\n", "CodeBleu_score": 49.37408675713601}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Check if the controller is active.\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute the desired acceleration.\n  Eigen::Vector3d desired_acceleration =\n      -k_p_.cwiseProduct(error_) - k_d_.cwiseProduct(error_dot_);\n\n  // Compute the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration =\n      -k_p_.cwiseProduct(error_angular_) - k_d_.cwiseProduct(error_angular_dot_);\n\n  // Project the desired acceleration onto the body z-axis.\n  Eigen::Vector3d desired_acceleration_body_z =\n      body_z_ * desired_acceleration.dot(body_z_);\n\n  // Combine the desired angular acceleration and acceleration.\n  Eigen::Vector3d desired_acceleration_and_angular_acceleration =\n      desired_acceleration_body_z + desired_angular_acceleration;\n\n  // Compute the rotor velocities.\n  Eigen::Vector3d rotor_velocities_raw =\n      k_i_.cwiseProduct(error_integral_) +\n      k_ff_.cwiseProduct(desired_acceleration_and_angular_acceleration);\n\n  // Ensure the rotor velocities are non-negative.\n  for (int i = 0; i < 3; i++) {\n    if (rotor_velocities_raw[i] < 0.0) {\n      rotor_velocities_raw[i] = 0.0;\n    }\n  }\n\n  // Compute the rotor velocities.\n  *rotor_velocities = rotor_velocities_raw.cwiseSqrt();\n}\n", "CodeBleu_score": 38.71860948325503}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Check that the input and parameters are valid.\n  if (!rotor_velocities) {\n    ROS_ERROR(\"LeePositionController::CalculateRotorVelocities: rotor_velocities is null.\");\n    return;\n  }\n  if (!parameters_initialized_) {\n    ROS_ERROR(\"LeePositionController::CalculateRotorVelocities: parameters are not initialized.\");\n    return;\n  }\n  if (!input_initialized_) {\n    ROS_ERROR(\"LeePositionController::CalculateRotorVelocities: input is not initialized.\");\n    return;\n  }\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!controller_active_) {\n    (*rotor_velocities).setZero();\n    return;\n  }\n\n  // Compute the desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n  ComputeDesiredAccelerationAndAngularAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n  // Project the thrust onto the body z-axis.\n  Eigen::Vector3d thrust_body;\n  thrust_body << desired_acceleration(0), desired_acceleration(1), desired_acceleration(2);\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d angular_thrust;\n  angular_thrust << desired_angular_acceleration(0), desired_angular_acceleration(1), desired_angular_acceleration(2);\n  angular_thrust += thrust_body.cross(rotor_orientations_);\n\n  // Compute the rotor velocities.\n  Eigen::VectorXd rotor_velocities_temp(kNumMotors);\n  rotor_velocities_temp.setZero();\n  for (int i = 0; i < kNumMotors; ++i) {\n    rotor_velocities_temp(i) = rotor_veloc", "CodeBleu_score": 44.2427854692523}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const    /*\n     * The rotor velocities are calculated as a function of the desired acceleration and angular acceleration.\n     * The rotor velocities are calculated by multiplying the rotor velocities matrix with a vector of the desired acceleration and angular acceleration.\n     * The rotor velocities matrix is a 4x3 matrix with the following entries:\n     *\n     * 1  0  0\n     * 0  1  0\n     * 0  0  1\n     * 0  0  0\n     *\n     * The first three entries are the desired acceleration in the body x, y, and z directions.\n     * The fourth entry is the desired angular acceleration in the body z direction.\n     */\n    if (rotor_velocities == nullptr) {\n        throw std::invalid_argument(\"rotor_velocities is nullptr.\");\n    }\n\n    if (!is_active_) {\n        rotor_velocities->setZero();\n        return;\n    }\n\n    Eigen::Vector3d desired_acceleration = Eigen::Vector3d::Zero();\n    Eigen::Vector3d desired_angular_acceleration = Eigen::Vector3d::Zero();\n\n    if (desired_acceleration_ != nullptr) {\n        desired_acceleration = *desired_acceleration_;\n    }\n\n    if (desired_angular_acceleration_ != nullptr) {\n        desired_angular_acceleration = *desired_angular_acceleration_;\n    }\n\n    Eigen::VectorXd rotor_velocities_vector = rotor_velocities_matrix_ * (desired_acceleration + desired_angular_acceleration);\n\n    // Project thrust onto body z-axis\n    rotor_velocities_vector(3) = rotor_velocities_vector.dot(body_z_);\n\n    // Combine angular acceleration and thrust\n    rotor_velocities_vector = rotor_velocities_vector.cwiseProduct(rotor_velocities_vector);\n\n    // Take square root of each component\n    rotor_velocities->resize(rotor", "CodeBleu_score": 34.98521839728939}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\n    // Calculate the position and velocity errors\n    Eigen::Vector3d position_error = _command_trajectory.GetPosition() - _odometry.GetPosition();\n    Eigen::Vector3d velocity_error = _command_trajectory.GetVelocity() - _odometry.GetVelocity();\n\n    // Transform the velocity error to the world frame\n    velocity_error = _odometry.GetOrientation().inverse() * velocity_error;\n\n    // Compute the desired acceleration\n    *acceleration = _position_gain * position_error + _velocity_gain * velocity_error + _mass * _gravity;\n\n    // Adjust the acceleration for the commanded acceleration\n    *acceleration += _command_trajectory.GetAcceleration();\n\n    // Adjust the acceleration for the commanded jerk\n    *acceleration += _command_trajectory.GetJerk() / _command_trajectory.GetTimestep();\n}\n", "CodeBleu_score": 36.192484104544604}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_velocity;\n  Eigen::Vector3d current_velocity;\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  Eigen::Vector3d desired_position;\n  Eigen::Vector3d current_position;\n  Eigen::Vector3d desired_acceleration_world;\n  Eigen::Vector3d desired_velocity_world;\n  Eigen::Vector3d current_velocity_world;\n  Eigen::Vector3d desired_acceleration_body;\n  Eigen::Vector3d desired_velocity_body;\n  Eigen::Vector3d current_velocity_body;\n\n  desired_position = trajectory_->GetPosition(current_time_);\n  current_position = odometry_->GetPosition();\n  position_error = desired_position - current_position;\n\n  desired_velocity = trajectory_->GetVelocity(current_time_);\n  current_velocity = odometry_->GetVelocity();\n  velocity_error = desired_velocity - current_velocity;\n\n  desired_acceleration = position_error * position_gain_ + velocity_error * velocity_gain_;\n\n  desired_velocity_world = desired_velocity;\n  current_velocity_world = current_velocity;\n  desired_velocity_body = transform_->TransformVector(desired_velocity_world, current_position);\n  current_velocity_body = transform_->TransformVector(current_velocity_world, current_position);\n  desired_acceleration_world = transform_->TransformVector(desired_acceleration, current_position);\n  desired_acceleration_body = transform_->TransformVector(desired_acceleration_world, current_position);\n\n  *acceleration = desired_acceleration_body;\n}\n", "CodeBleu_score": 43.56075605173177}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const    // Compute the position error in the world frame\n    Eigen::Vector3d position_error = world_to_local_ * (command_trajectory_.position - odometry_.position);\n\n    // Compute the velocity error in the world frame\n    Eigen::Vector3d velocity_error = world_to_local_ * (command_trajectory_.velocity - odometry_.velocity);\n\n    // Transform the commanded acceleration to the world frame\n    Eigen::Vector3d commanded_acceleration = world_to_local_ * command_trajectory_.acceleration;\n\n    // Compute the desired acceleration\n    *acceleration = commanded_acceleration + position_gain_ * position_error + velocity_gain_ * velocity_error;\n\n    // Adjust for vehicle mass and gravity\n    *acceleration += gravity_ * mass_;\n\n    // Adjust for the commanded acceleration\n    *acceleration += command_trajectory_.acceleration;\n}\n", "CodeBleu_score": 42.46533050846205}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const    if (rotor_velocities == nullptr) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is nullptr.\");\n    }\n    if (rotor_velocities->size() != rotor_count_) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities->size() != rotor_count_.\");\n    }\n    if (thrust_reference_ == nullptr) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference_ is nullptr.\");\n    }\n    if (thrust_reference_->size() != rotor_count_) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference_->size() != rotor_count_.\");\n    }\n    if (angular_acceleration_ == nullptr) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: angular_acceleration_ is nullptr.\");\n    }\n    if (angular_acceleration_->size() != 3) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: angular_acceleration_->size() != 3.\");\n    }\n    if (rotor_velocities_matrix_ == nullptr) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities_matrix_ is nullptr.\");\n    }\n    if (rotor_velocities_matrix_->size() != rotor_count_) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities_matrix_->size() != rotor_count_.\");\n    }\n    if (rotor_velocities_matrix_->cols() != 3) {\n        throw std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: rotor_", "CodeBleu_score": 27.247890972084367}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  if (rotor_velocities == nullptr) {\n    throw std::invalid_argument(\n        Formatting::Format(\"AttitudeControllerSamy::CalculateRotorVelocities - rotor_velocities is nullptr\"));\n  }\n\n  if (rotor_velocities->size() != 4) {\n    throw std::invalid_argument(\n        Formatting::Format(\"AttitudeControllerSamy::CalculateRotorVelocities - rotor_velocities size is not 4\"));\n  }\n\n  if (rotor_velocities_ == nullptr) {\n    throw std::invalid_argument(\n        Formatting::Format(\"AttitudeControllerSamy::CalculateRotorVelocities - rotor_velocities_ is nullptr\"));\n  }\n\n  if (rotor_velocities_->size() != 4) {\n    throw std::invalid_argument(\n        Formatting::Format(\"AttitudeControllerSamy::CalculateRotorVelocities - rotor_velocities_ size is not 4\"));\n  }\n\n  if (thrust_reference_ == nullptr) {\n    throw std::invalid_argument(\n        Formatting::Format(\"AttitudeControllerSamy::CalculateRotorVelocities - thrust_reference_ is nullptr\"));\n  }\n\n  if (thrust_reference_->size() != 3) {\n    throw std::invalid_argument(\n        Formatting::Format(\"AttitudeControllerSamy::CalculateRotorVelocities - thrust_reference_ size is not 3\"));\n  }\n\n  if (attitude_reference_ == nullptr) {\n    throw std::invalid_argument(\n        Formatting::Format(\"AttitudeControllerSamy::CalculateRotorVelocities - attitude_reference_ is nullptr\"));\n  }\n\n  if (attitude_reference_->size() != 3) {\n    throw std::invalid_argument(\n        Formatting::Format(\"AttitudeControllerSamy::CalculateRotorVelocities - attitude_reference_ size is not 3\"));\n  }\n\n  if (rotor_velocities_->size() != 4) {\n   ", "CodeBleu_score": 27.75066272035961}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const    if (!rotor_velocities) {\n        std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: ERROR - rotor_velocities is NULL\" << std::endl;\n        return;\n    }\n\n    if (!IsValid()) {\n        std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: ERROR - controller is not valid\" << std::endl;\n        return;\n    }\n\n    if (rotor_velocities->size() != rotor_velocities_->size()) {\n        rotor_velocities->resize(rotor_velocities_->size());\n    }\n\n    Eigen::VectorXd desired_angular_acceleration(3);\n    desired_angular_acceleration.setZero();\n\n    // Compute desired angular acceleration\n    desired_angular_acceleration = rotor_thrust_to_angular_acceleration_ * thrust_reference_;\n\n    // Combine desired angular acceleration and thrust reference into a single vector\n    Eigen::VectorXd desired_angular_acceleration_and_thrust_reference(6);\n    desired_angular_acceleration_and_thrust_reference.head<3>() = desired_angular_acceleration;\n    desired_angular_acceleration_and_thrust_reference.tail<3>() = thrust_reference_;\n\n    // Multiply desired angular acceleration and thrust reference with the rotor velocity matrix\n    *rotor_velocities = rotor_velocity_matrix_ * desired_angular_acceleration_and_thrust_reference;\n\n    // Ensure rotor velocities are at least 1\n    for (int i = 0; i < rotor_velocities->size(); i++) {\n        if ((*rotor_velocities)(i) < 1) {\n            (*rotor_velocities)(i) = 1;\n        }\n    }\n\n    // Take the square root of each component\n    *rotor_velocities = rotor_velocities->array().sqrt();\n}\n", "CodeBleu_score": 43.642226761594024}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    # Check if the start and end times are within the object's time range\n    if start_time < self.time[0] or end_time > self.time[-1]:\n      raise ValueError(\"The start or end time is outside the time range of the object.\")\n    # Find the indices of the start and end times\n    start_index = np.where(self.time == start_time)[0][0]\n    end_index = np.where(self.time == end_time)[0][0]\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n    # Update the time attribute of the sliced object\n    sliced_object.time = self.time[start_index:end_index+1]\n    # Update the attributes of the sliced object\n    for attr in self.attributes:\n      sliced_object.__dict__[attr] = self.__dict__[attr][start_index:end_index+1]\n    # Return the sliced object\n    return sliced_object\n", "CodeBleu_score": 43.109058141468694}, {"code": "def slice(self, start_time, end_time)\n    start_index = self.time_array.index(start_time)\n    end_index = self.time_array.index(end_time)\n    new_object = deepcopy(self)\n    new_object.time_array = self.time_array[start_index:end_index]\n    new_object.x_array = self.x_array[start_index:end_index]\n    new_object.y_array = self.y_array[start_index:end_index]\n    new_object.z_array = self.z_array[start_index:end_index]\n    new_object.x_velocity_array = self.x_velocity_array[start_index:end_index]\n    new_object.y_velocity_array = self.y_velocity_array[start_index:end_index]\n    new_object.z_velocity_array = self.z_velocity_array[start_index:end_index]\n    new_object.x_acceleration_array = self.x_acceleration_array[start_index:end_index]\n    new_object.y_acceleration_array = self.y_acceleration_array[start_index:end_index]\n    new_object.z_acceleration_array = self.z_acceleration_array[start_index:end_index]\n    new_object.x_acceleration_squared_array = self.x_acceleration_squared_array[start_index:end_index]\n    new_object.y_acceleration_squared_array = self.y_acceleration_squared_array[start_index:end_index]\n    new_object.z_acceleration_squared_array = self.z_acceleration_squared_array[start_index:end_index]\n    new_object.x_acceleration_cubed_array = self.x_acceleration_cubed_array[start_index:end_index]\n    new_object.y_acceleration_cub", "CodeBleu_score": 13.54015271331989}, {"code": "def slice(self, start_time, end_time)\n    # Get the indices of the start and end times\n    start_idx = self.get_idx_from_time(start_time)\n    end_idx = self.get_idx_from_time(end_time)\n\n    # Create a deep copy of the object\n    copy = copy.deepcopy(self)\n\n    # Update the attributes of the copied object to contain only the sliced data\n    copy.time = copy.time[start_idx:end_idx]\n    copy.position = copy.position[start_idx:end_idx]\n    copy.velocity = copy.velocity[start_idx:end_idx]\n    copy.acceleration = copy.acceleration[start_idx:end_idx]\n    copy.jerk = copy.jerk[start_idx:end_idx]\n    copy.snap = copy.snap[start_idx:end_idx]\n    copy.heading = copy.heading[start_idx:end_idx]\n    copy.roll = copy.roll[start_idx:end_idx]\n    copy.pitch = copy.pitch[start_idx:end_idx]\n    copy.yaw = copy.yaw[start_idx:end_idx]\n    copy.yaw_rate = copy.yaw_rate[start_idx:end_idx]\n    copy.roll_rate = copy.roll_rate[start_idx:end_idx]\n    copy.pitch_rate = copy.pitch_rate[start_idx:end_idx]\n    copy.yaw_acceleration = copy.yaw_acceleration[start_idx:end_idx]\n    copy.roll_acceleration = copy.roll_acceleration[start_idx:end_idx]\n    copy.pitch_acceleration = copy.pitch_acceleration[start_idx:end_idx]\n    copy.yaw_jerk = copy.yaw_jerk[start_idx:end_idx]\n    copy.roll_jerk = copy.roll_jerk[start_idx:end_idx]\n    copy.pitch_jerk = copy.p", "CodeBleu_score": 12.292324993544732}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation from the message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    euler_angles = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is None or self.last_waypoint.position != point or self.last_waypoint.yaw != euler_angles[2]:\n        # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaws.append(euler_angles[2])\n        self.msg_times.append(msg_time)\n        self.bag_times.append(bag_time)\n        self.last_waypoint = waypoint_msg\n", "CodeBleu_score": 26.497767898344215}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert the rotation to Euler angles\n    yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])[2]\n    # Create a Point object from the position\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if not self.last_waypoint or not self.last_waypoint.position.is_equal(point) or not self.last_waypoint.yaw == yaw:\n        # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaws.append(yaw)\n        self.msg_times.append(msg_time)\n        self.bag_times.append(bag_time)\n        self.last_waypoint = waypoint_msg\n", "CodeBleu_score": 25.3618811125827}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Get the position and rotation from the waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the waypoint is different from the last one\n    if self.last_point is None or not self.last_point.equal(point):\n      # Append the new point, yaw, and corresponding times to their respective arrays\n      self.points.append(point)\n      self.yaws.append(euler[2])\n      self.msg_times.append(msg_time)\n      self.bag_times.append(bag_time)\n      # Set the last point to the current point\n      self.last_point = point\n\n  def append_gps(self, gps_msg, msg_time, bag_time):\n    \"\"\"This function, append_gps, appends data from a gps message to its corresponding arrays.\\nIt extracts the position and creates a Point object.\\nIt checks if the current gps is different from the last one by comparing position values.\\nIf the gps is different, it appends the new point and corresponding times to their respective arrays.\"\"\"\n    # Get the position from the gps message\n    position = gps_msg.pose.position\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the gps is different from the last one\n    if self.last_point is None or not self.last_point.equal(point):\n      # Append the new point and corresponding times to their respective arrays\n      self.points.append(point)\n      self.msg_times.append(msg_time)\n      self.bag_times.append(bag_time)\n      # Set the last point to the current point\n      self.last_point = point\n\n  def append_imu(self, imu_msg, msg_time,", "CodeBleu_score": 32.710750324646284}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == '/imu/data':\n      self.acceleration_x += msg.linear_acceleration.x\n      self.acceleration_y += msg.linear_acceleration.y\n      self.acceleration_z += msg.linear_acceleration.z\n      self.time_message += msg.header.stamp.to_sec()\n      self.time_bag += bag_time\n\n  def extract_odom_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract_odom_topics, appends Odom topic message content to velocity attributes.\\nIt converts the message timestamp to seconds.\\nFor each Odom topic, if the topic matches, it appends the linear velocity data to the corresponding x, y, and z attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n    if topic == '/odom':\n      self.velocity_x += msg.twist.twist.linear.x\n      self.velocity_y += msg.twist.twist.linear.y\n      self.velocity_z += msg.twist.twist.linear.z\n      self.time_message += msg.header.stamp.to_sec()\n      self.time_bag += bag_time\n\n  def extract_ground_truth_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract_ground_truth_topics, appends Ground Truth topic message content to pose attributes.\\nIt converts the message timestamp to seconds.\\nFor each Ground Truth topic, if the topic matches, it appends the pose data to the corresponding x, y, and z attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n    if topic == '/ground_truth/state':\n      self.pose_x += msg.pose.pose.position.x\n      self.pose_y += msg.pose.pose.position.y\n      self.pose_z += msg.pose.pose.position.z\n      self.time_message += msg.header.stamp.to_sec()\n      self.time_bag += bag_time\n\n", "CodeBleu_score": 28.06962776310392}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu_0/data\":\n        self.imu_0_time = msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9\n        self.imu_0_linear_acceleration_x = msg.linear_acceleration.x\n        self.imu_0_linear_acceleration_y = msg.linear_acceleration.y\n        self.imu_0_linear_acceleration_z = msg.linear_acceleration.z\n        self.imu_0_time_bag = bag_time\n    elif topic == \"/imu_1/data\":\n        self.imu_1_time = msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9\n        self.imu_1_linear_acceleration_x = msg.linear_acceleration.x\n        self.imu_1_linear_acceleration_y = msg.linear_acceleration.y\n        self.imu_1_linear_acceleration_z = msg.linear_acceleration.z\n        self.imu_1_time_bag = bag_time\n    elif topic == \"/imu_2/data\":\n        self.imu_2_time = msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9\n        self.imu_2_linear_acceleration_x = msg.linear_acceleration.x\n        self.imu_2_linear_acceleration_y = msg.linear_acceleration.y\n        self.imu_2_linear_acceleration_z = msg.linear_acceleration.z\n        self.imu_2_time_bag = bag_time\n    elif topic == \"/imu_3/data\":\n        self.imu_3_time = msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9\n        self.imu_3_linear_ac", "CodeBleu_score": 23.591182252992716}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == '/imu/data':\n      self.imu_msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs/1000000000.0\n      self.imu_msg_bag_time = bag_time\n      self.imu_linear_acceleration_x = msg.linear_acceleration.x\n      self.imu_linear_acceleration_y = msg.linear_acceleration.y\n      self.imu_linear_acceleration_z = msg.linear_acceleration.z\n\n  def extract_odom_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract_odom_topics, appends odom topic message content to position and orientation attributes.\\nIt converts the message timestamp to seconds.\\nFor each odom topic, if the topic matches, it appends the position data to the corresponding x, y, and z attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n    if topic == '/odom':\n      self.odom_msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs/1000000000.0\n      self.odom_msg_bag_time = bag_time\n      self.odom_position_x = msg.pose.pose.position.x\n      self.odom_position_y = msg.pose.pose.position.y\n      self.odom_position_z = msg.pose.pose.position.z\n      self.odom_orientation_x = msg.pose.pose.orientation.x\n      self.odom_orientation_y = msg.pose.pose.orientation.y\n      self.odom_orientation_z = msg.pose.pose.orientation.z\n      self.odom_orientation_w = msg.pose.pose.orientation.w\n\n  def extract_gps_topics(self, topic, msg, bag_time):\n    \"\"\"This function, extract_gps_topics, appends gps topic message content to position and orientation attributes.\\n", "CodeBleu_score": 26.53798950709906}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\n    # Create a figure\n    fig = plt.figure(figsize=(12, 8))\n    ax = fig.add_subplot(111)\n\n    # Set the title\n    fig.suptitle(\"Accelerations\")\n\n    # Add a subplot\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Plot the data\n    ax.plot(self.x_acceleration, color=\"red\", label=\"x\")\n    ax.plot(self.y_acceleration, color=\"blue\", label=\"y\")\n    ax.plot(self.z_acceleration, color=\"green\", label=\"z\")\n\n    # Add a legend\n    ax.legend()\n\n    # Save the plot if saving is enabled\n    if plot_suffix is not None:\n        fig.savefig(f\"plots/accelerations_{plot_suffix}.png\")\n\n", "CodeBleu_score": 27.143675299297996}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\n    # Create figure\n    fig = plt.figure()\n    fig.suptitle(\"Accelerations\")\n    ax = fig.add_subplot(111)\n\n    # Plot data\n    for dataset in self.accelerations:\n        ax.plot(self.accelerations[dataset]['x'], self.accelerations[dataset]['y'], self.accelerations[dataset]['z'], label=dataset)\n\n    # Add labels and legend\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend(loc='best')\n\n    # Save figure\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        fig.savefig(filename)\n", "CodeBleu_score": 33.740197645044866}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\n    # Generate the plot\n    fig = plt.figure()\n    fig.suptitle(\"Acceleration Data\")\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    for acc in self.accelerations:\n        ax.plot(self.time, acc.x, label=\"x\")\n        ax.plot(self.time, acc.y, label=\"y\")\n        ax.plot(self.time, acc.z, label=\"z\")\n    ax.legend()\n\n    # Save the plot if saving plots is enabled\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        filename = \"accelerations\" + plot_suffix + \".png\"\n        fig.savefig(filename)\n        print(\"Saved plot to \" + filename)\n\n    # Show the plot if showing plots is enabled\n    if self.show_plots:\n        plt.show()\n", "CodeBleu_score": 36.40549413602794}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    for i in range(len(pose_indeces)-1):\n        for j in range(i+1,len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 26.78775157626302}, {"code": "def compare_positions(self, pose_indeces)\n    for i in range(len(pose_indeces)-1):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 27.922393085103224}, {"code": "def compare_positions(self, pose_indeces)\n    for i in range(len(pose_indeces)-1):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 27.922393085103224}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for i in range(len(self.wrench)):\n      if start_time <= self.wrench[i][0] <= end_time:\n        collision_times.append(self.wrench[i][0])\n    return collision_times\n\n  def get_collisions_by_time(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collisions_by_time, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for i in range(len(self.wrench)):\n      if start_time <= self.wrench[i][0] <= end_time:\n        collision_times.append(self.wrench[i][0])\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for i in range(len(self.wrench)):\n      if start_time <= self.wrench[i][0] <= end_time:\n        collision_times.append(self.wrench[i][0])\n    return collision_times\n\n  def get_collisions_by_time_and_force(self, start_time=None, end_time=None, force=None):\n    \"\"\"This function, get_collisions_by_time_and_force, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each", "CodeBleu_score": 30.105673590041466}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for i in range(len(self.wrench)):\n        if self.wrench[i].header.stamp.secs >= start_time and self.wrench[i].header.stamp.secs <= end_time:\n            collision_times.append(self.wrench[i].header.stamp.secs)\n    return collision_times\n", "CodeBleu_score": 37.56373651026637}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 30.087936187511037}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    absolute_start_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(absolute_start_time, end_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 30.112439094104193}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n", "CodeBleu_score": 32.10207328495848}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n  float multiplier =\n      (depth_scale_ / 1000.0) * (focal_length_ / 1000.0) *\n      (focal_length_ / 1000.0) / (width * height);\n\n  Eigen::VectorXf depth_data(width * height);\n  for (uint32_t i = 0; i < width * height; i++) {\n    depth_data[i] = data[i];\n  }\n  Eigen::VectorXf noise_values =\n      depth_data.unaryExpr([multiplier](float x) { return multiplier * x; });\n  float rms_noise = noise_values.array().square().mean();\n  rms_noise = sqrt(rms_noise);\n  float noise_value = rms_noise * noise_multiplier_;\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data[i] != 0 && data[i] != bad_point_value_) {\n      data[i] += noise_value * noise_distribution_(random_engine_);\n    } else {\n      data[i] = bad_point_value_;\n    }\n  }\n}\n", "CodeBleu_score": 50.58553752590975}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) return;\n  // Calculate multiplier based on camera parameters\n  float multiplier =\n      static_cast<float>(this->noise_multiplier_) /\n      (this->noise_multiplier_ + this->depth_multiplier_);\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n  // Compute RMS noise and noise values\n  float rms_noise =\n      static_cast<float>(sqrt(this->rms_noise_)) * multiplier;\n  float noise_value =\n      static_cast<float>(this->noise_value_) * multiplier;\n  // Apply noise\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (depth_data[i] != 0 && depth_data[i] != this->bad_point_value_) {\n      if (depth_data[i] < rms_noise) {\n        depth_data[i] = noise_value;\n      } else {\n        depth_data[i] +=\n            static_cast<float>(rand()) / static_cast<float>(RAND_MAX) *\n            rms_noise;\n      }\n    } else {\n      depth_data[i] = this->bad_point_value_;\n    }\n  }\n}\n", "CodeBleu_score": 55.82943743610611}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n\n  const float multiplier =\n      static_cast<float>(kDepthMultiplier) /\n      static_cast<float>(kDepthNoiseMultiplier);\n\n  Eigen::VectorXf depth_data(width * height);\n  for (uint32_t i = 0; i < width * height; i++) {\n    depth_data(i) = data[i] * multiplier;\n  }\n\n  Eigen::VectorXf noise_values =\n      ComputeNoiseValues(depth_data, width, height);\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data[i] > 0.0f) {\n      data[i] = data[i] + noise_values(i);\n    } else {\n      data[i] = kBadPointValue;\n    }\n  }\n}\n", "CodeBleu_score": 46.235627477210436}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get simulation time\n  common::Time sim_time = world->GetSimTime();\n  ros::Time ros_time(sim_time.sec, sim_time.nsec);\n\n  // Write waypoint message to bag file\n  waypoint_bag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n}\n", "CodeBleu_score": 54.71842488932809}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  ros::Time current_time = ros::Time::now();\n  ros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n\n  if (trajectory_msg->header.frame_id == \"world\") {\n    trajectory_msgs::MultiDOFJointTrajectory trajectory_msg_copy;\n    trajectory_msg_copy = *trajectory_msg;\n    trajectory_msg_copy.header.stamp = ros_time;\n    trajectory_msg_copy.header.frame_id = \"world\";\n    trajectory_bag_ << trajectory_msg_copy;\n  } else if (trajectory_msg->header.frame_id == \"base_link\") {\n    trajectory_msgs::MultiDOFJointTrajectory trajectory_msg_copy;\n    trajectory_msg_copy = *trajectory_msg;\n    trajectory_msg_copy.header.stamp = ros_time;\n    trajectory_msg_copy.header.frame_id = \"base_link\";\n    trajectory_bag_ << trajectory_msg_copy;\n  } else {\n    ROS_WARN(\"Waypoint message frame_id is not world or base_link.\");\n  }\n}\n", "CodeBleu_score": 44.24919312399568}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get simulation time\n  gazebo::common::Time current_time = world->SimTime();\n  ros::Time ros_current_time(current_time.sec, current_time.nsec);\n\n  // Write the trajectory message to the bag file\n  trajectory_msg->header.stamp = ros_current_time;\n  trajectory_msg->header.frame_id = \"world\";\n  trajectory_bag->write(waypoint_topic, ros_current_time, trajectory_msg);\n}\n", "CodeBleu_score": 49.65673984027867}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\n  // Convert Gazebo time to ROS time\n  ros::Time ros_now = ros::Time::now();\n  ros_now.sec = now.sec;\n  ros_now.nsec = now.nsec;\n\n  // Create message\n  gazebo_msgs::Actuators msg;\n  msg.header.stamp = ros_now;\n  msg.header.frame_id = \"base_link\";\n\n  // Iterate through motor joints\n  for (int i = 0; i < motor_joints_.size(); i++) {\n    // Get motor joint\n    physics::JointPtr motor_joint = motor_joints_[i];\n    // Get motor joint name\n    std::string motor_joint_name = motor_joint->GetName();\n    // Get motor joint velocity\n    double motor_joint_velocity = motor_joint->GetVelocity(0);\n    // Get motor joint position\n    double motor_joint_position = motor_joint->GetAngle(0).Radian();\n    // Get motor joint axis\n    math::Vector3 motor_joint_axis = motor_joint->GetGlobalAxis(0);\n    // Get motor joint axis direction\n    math::Vector3 motor_joint_axis_direction = motor_joint_axis.Normalize();\n    // Get motor joint axis direction angle\n    double motor_joint_axis_direction_angle = motor_joint_axis_direction.GetAngle().Radian();\n    // Get motor joint axis direction angle in degrees\n    double motor_joint_axis_direction_angle_degrees = motor_joint_axis_direction_angle * 180 / M_PI;\n    // Get motor joint axis direction angle in degrees\n    if (motor_joint_axis_direction_angle_degrees < 0) {\n      motor_joint_axis_direction_angle_degrees += 360;\n    }\n    // Get motor joint axis direction angle in degrees\n    if (motor_joint_axis_direction_angle_degrees > 360) {\n      motor_joint_axis_direction_angle_degrees -= 360;\n    }\n    // Calculate slowed-down rotational velocity", "CodeBleu_score": 39.41520610099399}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)    // Get the current simulation time and convert it to ROS time\n    ros::Time sim_time = ros::Time(now.sec, now.nsec);\n\n    // Prepare the message for motor velocities\n    gazebo_msgs::JointState msg;\n    msg.header.stamp = sim_time;\n    msg.name.resize(motor_names_.size());\n    msg.velocity.resize(motor_names_.size());\n\n    // Iterate through the motor joints and calculate the slowed-down rotational velocities\n    for (int i = 0; i < motor_names_.size(); i++) {\n        physics::JointPtr joint = model_->GetJoint(motor_names_[i]);\n        double velocity = joint->GetVelocity(0);\n        msg.velocity[i] = velocity * slowdown_factor_;\n        msg.name[i] = motor_names_[i];\n    }\n\n    // Write the data to the bag file\n    motor_velocities_publisher_.publish(msg);\n}\n", "CodeBleu_score": 52.109109899492424}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)  ros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n  // Create a message for motor velocities.\n  sensor_msgs::JointState motor_velocities;\n  motor_velocities.header.stamp = ros_time;\n  motor_velocities.name.resize(motor_velocities.name.size() + motor_velocities_names.size());\n  motor_velocities.velocity.resize(motor_velocities.velocity.size() + motor_velocities_names.size());\n\n  // Iterate through the motor joints.\n  for (int i = 0; i < motor_velocities_names.size(); i++) {\n    // Calculate the slowed-down rotational velocities.\n    double motor_velocity = motor_velocities_joints[i]->GetVelocity(0) / motor_velocities_slowdowns[i];\n\n    // Assign the slowed-down rotational velocities to the message.\n    motor_velocities.name[i] = motor_velocities_names[i];\n    motor_velocities.velocity[i] = motor_velocity;\n  }\n\n  // Write the message to a bag file.\n  motor_velocities_pub.publish(motor_velocities);\n}\n", "CodeBleu_score": 52.11103017186639}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_print_) {\n    gzdbg << __FUNCTION__ << \" called\\n\";\n  }\n\n  double roll_norm = roll_pitch_yawrate_thrust_msg->roll_norm;\n  double pitch_norm = roll_pitch_yawrate_thrust_msg->pitch_norm;\n  double yawrate_norm = roll_pitch_yawrate_thrust_msg->yawrate_norm;\n  double thrust_norm = roll_pitch_yawrate_thrust_msg->thrust_norm;\n\n  // Convert roll, pitch, and yaw rate to control surface angles\n  double aileron_angle =\n      -roll_norm * roll_pitch_yawrate_thrust_msg->aileron_max_angle;\n  double elevator_angle =\n      pitch_norm * roll_pitch_yawrate_thrust_msg->elevator_max_angle;\n  double rudder_angle =\n      yawrate_norm * roll_pitch_yawrate_thrust_msg->rudder_max_angle;\n\n  // Set throttle from thrust\n  double throttle = thrust_norm * roll_pitch_yawrate_thrust_msg->throttle_max;\n\n  // Set the control surface angles\n  aileron_angle_ = aileron_angle;\n  elevator_angle_ = elevator_angle;\n  rudder_angle_ = rudder_angle;\n  throttle_ = throttle;\n\n  // Set the current time\n  current_time_ = roll_pitch_yawrate_thrust_msg->time;\n}\n", "CodeBleu_score": 43.14308816869617}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_print_) {\n    gzdbg << __FUNCTION__ << \" called.\\n\";\n  }\n\n  // convert roll, pitch, yaw rate to ailerons, elevator, rudder\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll_angle();\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch_angle();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // convert normalized roll, pitch, yaw rate to control surface angles\n  double ailerons = NormalizedToControlSurfaceAngle(roll_angle);\n  double elevator = NormalizedToControlSurfaceAngle(pitch_angle);\n  double rudder = NormalizedToControlSurfaceAngle(yaw_rate);\n\n  // set throttle\n  double throttle = thrust;\n\n  // set the control surface angles\n  ailerons_angle_ = ailerons;\n  elevator_angle_ = elevator;\n  rudder_angle_ = rudder;\n  throttle_ = throttle;\n\n  // log the control surface angles\n  if (debug_print_) {\n    gzdbg << \"ailerons: \" << ailerons << \" elevator: \" << elevator\n          << \" rudder: \" << rudder << \" throttle: \" << throttle << \"\\n\";\n  }\n}\n", "CodeBleu_score": 46.77350494699676}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  // If debug printing is enabled, print that the callback was called.\n  if (debug_print_) {\n    gzdbg << __FUNCTION__ << \" called.\\n\";\n  }\n\n  // Convert roll, pitch, and yaw rate to control surface angles.\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll * roll_pitch_yawrate_thrust_msg->roll;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch * roll_pitch_yawrate_thrust_msg->pitch;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yawrate;\n\n  // Set the aileron, elevator, and rudder angles.\n  double aileron_angle = roll_angle;\n  double elevator_angle = pitch_angle;\n  double rudder_angle = yaw_rate;\n\n  // Set the throttle value.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Set the control surface angles.\n  aileron_angle_ = aileron_angle;\n  elevator_angle_ = elevator_angle;\n  rudder_angle_ = rudder_angle;\n  throttle_ = throttle;\n\n  // If debug printing is enabled, print the control surface angles and throttle value.\n  if (debug_print_) {\n    gzdbg << __FUNCTION__ << \":\\n\"\n          << \"  roll_angle: \" << roll_angle << \"\\n\"\n          << \"  pitch_angle: \" << pitch_angle << \"\\n\"\n          << \"  yaw_rate: \" << yaw_rate << \"\\n\"\n          << \"  aileron_angle: \" << aileron_angle << \"\\n\"\n          << \"  elevator_angle: \" << elevator_angle << \"\\n\"\n          << \"  rudder_angle: \" << rudder_angle << \"\\n\"\n          << \"  throttle: \" << throttle << \"\\n\";\n  }\n}\n", "CodeBleu_score": 38.2854288158765}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // Convert the timeout to a timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Perform a poll operation on file descriptors\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(this->serial_fd, &read_fds);\n  int ret = select(this->serial_fd + 1, &read_fds, NULL, NULL, &timeout);\n\n  if (ret == -1) {\n    // An error occurred\n    gzerr << \"Error in select()\\n\";\n    return;\n  } else if (ret == 0) {\n    // Timeout occurred\n    return;\n  } else {\n    // Data is available\n    // Receive the data\n    uint8_t buffer[1024];\n    ssize_t bytes_received = recv(this->serial_fd, buffer, sizeof(buffer), 0);\n    if (bytes_received < 0) {\n      gzerr << \"Error in recv()\\n\";\n      return;\n    }\n\n    // Parse the MAVLink messages\n    for (int i = 0; i < bytes_received; ++i) {\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status);\n\n      // Forward the message to the serial connection\n      if (this->serial_fd >= 0) {\n        ssize_t bytes_sent = send(this->serial_fd, buffer + i, 1, 0);\n        if (bytes_sent < 0) {\n          gzerr << \"Error in send()\\n\";\n          return;\n        }\n      }\n\n      // Handle the message\n      switch (msg.msgid) {\n        case MAVLINK_MSG_ID_HEARTBEAT:\n          this->", "CodeBleu_score": 53.55594870546086}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  struct timeval timeout;\n  timeout.tv_sec = _dt / 1000.0;\n  timeout.tv_usec = (_dt - timeout.tv_sec * 1000.0) * 1000.0;\n\n  // FIXME: this is a hack to avoid the first message being dropped\n  // when the serial connection is opened.\n  if (this->serial_fd > 0 && this->first_message_received == false) {\n    this->first_message_received = true;\n    return;\n  }\n\n  // Poll for new data on the file descriptor.\n  int poll_ret = poll(&this->poll_fd, 1, _timeoutMs);\n\n  // Check for errors.\n  if (poll_ret == -1) {\n    gzerr << \"poll() failed. Error: \" << strerror(errno) << \"\\n\";\n    return;\n  }\n\n  // Check if data is available.\n  if (poll_ret == 0) {\n    // No data available.\n    return;\n  }\n\n  // Data is available.\n  int bytes_read = read(this->serial_fd, this->buffer,\n                        sizeof(this->buffer));\n\n  // Check for errors.\n  if (bytes_read < 0) {\n    gzerr << \"read() failed. Error: \" << strerror(errno) << \"\\n\";\n    return;\n  }\n\n  // No data available.\n  if (bytes_read == 0) {\n    return;\n  }\n\n  // Data is available.\n  this->buffer_index = 0;\n  this->buffer_end = bytes_read;\n\n  while (this->buffer_index < this->buffer_end) {\n    // Get the message length.\n    int message_length = mavlink_message_length(this->buffer[this->buffer_index]);\n\n    // Check if the message is complete.\n    if (this->buffer_index + message_length <= this->buffer_end) {\n      // Parse the message.\n      mavlink_message_t message;\n", "CodeBleu_score": 35.43336658742676}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // convert timeout to timeval\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // poll for data\n  struct pollfd fds[1];\n  fds[0].fd = this->mavlink_udp_port_->GetFileDescriptor();\n  fds[0].events = POLLIN;\n  int ret = poll(fds, 1, _timeoutMs);\n\n  // if data is available, receive it and parse MAVLink messages\n  if (ret > 0) {\n    // receive data\n    uint8_t buffer[1024];\n    unsigned int length = this->mavlink_udp_port_->Receive(buffer, 1024);\n    if (length > 0) {\n      // parse MAVLink messages\n      this->parseMAVLinkMessages(buffer, length);\n    }\n  }\n}\n", "CodeBleu_score": 42.750063762955}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close()     boost::mutex::scoped_lock lock(mutex);\n    if (is_open) {\n        if (io_service_running) {\n            io_service_running = false;\n            io_service.stop();\n            io_service_thread.join();\n        }\n        serial_dev.close();\n        is_open = false;\n    }\n}\n", "CodeBleu_score": 50.690295294996204}, {"code": "void GazeboMavlinkInterface::close()     if (this->io_service_thread.joinable()) {\n        this->io_service_thread.join();\n    }\n    this->serial_dev->close();\n    this->serial_dev = NULL;\n    this->io_service.stop();\n    this->serial_dev_mutex.unlock();\n}\n", "CodeBleu_score": 29.257401486480873}, {"code": "void GazeboMavlinkInterface::close()     std::lock_guard<std::mutex> guard(mutex);\n    if (!is_open) {\n        return;\n    }\n    is_open = false;\n    io_service.stop();\n    if (io_thread.joinable()) {\n        io_thread.join();\n    }\n    serial_port->Close();\n}\n", "CodeBleu_score": 56.651067568271486}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    [](const ignition::math::Vector3d& a, const ignition::math::Vector3d& b, double t) -> ignition::math::Vector3d {\n        ignition::math::Vector3d result;\n        result.X() = a.X() + t * (b.X() - a.X());\n        result.Y() = a.Y() + t * (b.Y() - a.Y());\n        result.Z() = a.Z() + t * (b.Z() - a.Z());\n        return result;\n    }\n};\n", "CodeBleu_score": 41.271581200375316}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    // The first point\n    ignition::math::Vector3d point1,\n    // The second point\n    ignition::math::Vector3d point2,\n    // The position of the point to be interpolated\n    ignition::math::Vector3d position\n}", "CodeBleu_score": 23.14062576106965}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    double x0, x1, y0, y1, z0, z1;\n    x0 = x1 = y0 = y1 = z0 = z1 = 0;\n    if (x < x0)\n        return ignition::math::Vector3d(0, 0, 0);\n    else if (x > x1)\n        return ignition::math::Vector3d(0, 0, 0);\n    else {\n        double t = (x - x0) / (x1 - x0);\n        return ignition::math::Vector3d(y0 + t * (y1 - y0), z0 + t * (z1 - z0), 0);\n    }\n}\n", "CodeBleu_score": 38.2971385519815}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)\tif (this->time != _time) {\n\t\tthis->time = _time;\n\t\tif (this->loop) {\n\t\t\tthis->time = fmod(this->time, this->length);\n\t\t\tif (this->time < 0.0) {\n\t\t\t\tthis->time += this->length;\n\t\t\t}\n\t\t} else {\n\t\t\tthis->time = std::min(std::max(this->time, 0.0), this->length);\n\t\t}\n\t\tthis->Update();\n\t}\n}\n", "CodeBleu_score": 55.510083025554046}, {"code": "void Animation::SetTime(double _time)\tif (m_looping) {\n\t\tif (_time < 0) {\n\t\t\t_time = m_length - fmod(-_time, m_length);\n\t\t}\n\t\telse if (_time > m_length) {\n\t\t\t_time = fmod(_time, m_length);\n\t\t}\n\t}\n\telse {\n\t\t_time = std::min(std::max(_time, 0.0), m_length);\n\t}\n\n\tif (_time != m_time) {\n\t\tm_time = _time;\n\t\tm_time_changed = true;\n\t}\n}\n", "CodeBleu_score": 34.92113443325462}, {"code": "void Animation::SetTime(double _time)\tif (time != _time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\ttime = fmod(time, length);\n\t\t} else {\n\t\t\ttime = std::min(std::max(time, 0.0), length);\n\t\t}\n\t\tUpdate();\n\t}\n}\n", "CodeBleu_score": 31.055170172145047}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n    # Set the coordinate frame and motion type\n    self.vehicle.commands.set_message_type(mavutil.mavlink.MAVLINK_MSG_ID_SET_MESSAGE_INTERVAL)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_LOITER_RAD', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_LOITER_TOTAL_GYM', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_LOITER_TIME', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_LOITER_UNLIM', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_RCL_ACT', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_RCL_TOT', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_RCL_TOT_G', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_RCL_X_PCT', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_RCL_Y_PCT', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_RCL_Z_PCT', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_SPD_MAX', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_SPD_MIN', value=1)\n    self.vehicle.commands.set_param_float_send(param_id='NAV_", "CodeBleu_score": 11.772612680724768}, {"code": "def hover(self)\n    # Set the vehicle's coordinate frame to 1 and motion type to 0\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_STATE, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_CONTROLS, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_GPS, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_SENSOR, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_STATE, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_CONTROLS, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_GPS, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_SENSOR, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_STATE, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_CONTROLS, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_GPS, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_SENSOR, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_STATE, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_CONTROLS, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_GPS, 10)\n    self.vehicle.commands.set_message_rate(\n        Message.HIL_SENSOR, 10)\n    self.ve", "CodeBleu_score": 5.366871196832728}, {"code": "def hover(self)\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    self.set_target_position(self.get_position()[0], self.get_position()[1], self.get_position()[2])\n    self.set_target_yaw(self.get_yaw())\n    print(\"Vehicle type: \" + self.get_vehicle_type())\n    print(\"Vehicle ID: \" + self.get_id())\n    print(\"Flight mode: \" + self.get_flight_mode())\n\n", "CodeBleu_score": 22.067711659297125}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    # Check if the flight mode is 'HOVER'\n    if self.flight_mode == 'HOVER':\n        # Set the hover flag to 1\n        self.hover = 1\n        # Call the hover method\n        self.hover()\n        # Return True\n        return True\n    else:\n        # Attempt to switch modes using flightModeService\n        try:\n            # Call the flightModeService\n            self.flight_mode_service.request.value = self.flight_mode\n            # Call the flightModeService\n            self.flight_mode_service.call()\n            # Print a success message\n            print('Successfully switched to ' + self.flight_mode + ' mode.')\n            # Return True\n            return True\n        except rospy.ServiceException:\n            # Print a failure message\n            print('Failed to switch to ' + self.flight_mode + ' mode.')\n            # Return False\n            return False\n\n", "CodeBleu_score": 36.003357792636365}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover()\n        return True\n    else:\n        if self.set_flight_mode(self.flight_mode):\n            print(\"Successfully switched to flight mode: \" + self.flight_mode)\n            return True\n        else:\n            print(\"Failed to switch to flight mode: \" + self.flight_mode)\n            return False\n", "CodeBleu_score": 34.10357258402985}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover()\n        return True\n    else:\n        try:\n            self.client.call(\"mavros.set_mode\", custom_mode=self.flight_mode)\n            rospy.sleep(1)\n            self.flight_mode = self.client.call(\"mavros.get_mode\").mode\n            if self.flight_mode == self.flight_mode:\n                print(\"Mode switch successful.\")\n                return True\n            else:\n                print(\"Mode switch failed.\")\n                return False\n        except rospy.ServiceException as e:\n            print(\"Mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 33.42326372854551}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, \"enu\")\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_velocity = [msg.linear.x, msg.linear.y, msg.angular.z]\n", "CodeBleu_score": 43.31854211605396}, {"code": "def cmd_vel_enu_callback(self, msg)\n    self.cmd_vel_enu_msg = msg\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.angular.z)\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.angular.z]\n        self.target_motion_enu = [msg.linear.x, msg.angular.z]\n", "CodeBleu_score": 42.757145019450796}, {"code": "def cmd_vel_enu_callback(self, msg)\n    # Call the hover state transition\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n\n    # Check if we are hovering\n    if not self.hover_flag:\n        # Call the hold state transition\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, 'enu')\n\n    # Check if we are holding\n    if not self.hold_flag:\n        # Set the coordinate frame and motion type\n        self.coordinate_frame = 1\n        self.motion_type = 1\n\n        # Construct the target motion\n        self.target_motion = np.array([msg.linear.x, msg.linear.y, msg.angular.z])\n\n", "CodeBleu_score": 42.726794696496434}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n    if self.flight_mode != 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and w < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover_action()\n", "CodeBleu_score": 80.75073357858751}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.flight_mode == \"HOVER\":\n        if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n    else:\n        if (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005):\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover_action()\n\n", "CodeBleu_score": 69.45273186889678}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.flight_mode != 'HOVER':\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n    else:\n        if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n", "CodeBleu_score": 50.55395982739126}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        q = Quaternion(q)\n        return q.yaw()\n", "CodeBleu_score": 24.533049656991263}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n", "CodeBleu_score": 19.528210155997467}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n", "CodeBleu_score": 24.26411761619382}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    # Update the coordinate frame and motion type.\n    self.vehicle.commands.set_return_to_launch_docking_enabled(True)\n    self.vehicle.commands.set_return_to_launch_after_mission(True)\n    self.vehicle.commands.set_return_to_launch_heading(self.vehicle.heading)\n    self.vehicle.commands.set_return_to_launch_position(self.vehicle.location.global_frame)\n    self.vehicle.commands.set_return_to_launch_motion_type(Vehicle.RTL_MOTION_TYPE_HOLD_ALTITUDE)\n    self.vehicle.commands.set_return_to_launch_altitude(self.vehicle.location.global_frame.alt)\n    self.vehicle.commands.set_return_to_launch_altitude_min(self.vehicle.location.global_frame.alt)\n    self.vehicle.commands.set_return_to_launch_altitude_max(self.vehicle.location.global_frame.alt)\n    self.vehicle.commands.set_return_to_launch_target(self.vehicle.location.global_frame)\n    # Construct a target motion using the current position and yaw values.\n    self.vehicle.commands.set_return_to_launch_target(\n        LocationGlobalRelative(self.vehicle.location.global_frame.lat,\n                               self.vehicle.location.global_frame.lon,\n                               self.vehicle.location.global_frame.alt))\n    self.vehicle.commands.set_return_to_launch_yaw(self.vehicle.heading)\n    # Set the flight mode.\n    self.vehicle.mode = VehicleMode(\"RTL\")\n    # Print the vehicle type, vehicle ID, and flight mode.\n    print(\"Vehicle type: \" + self.vehicle.type)\n    print(\"Vehicle ID: \" + self.vehicle.id)\n   ", "CodeBleu_score": 20.750697321878224}, {"code": "def hover(self)\n    # Set the coordinate frame and motion type\n    self.vehicle.commands.set_message_rate(MessageType.CMD_SET_ATTITUDE, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_NAV_CONTROLLER_OUTPUT, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_NAV_CONTROLLER_INPUT, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_MODE, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_LOCATION, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_WPNEXT_OFFSET, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_WPINDEX, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_NONE, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_TO_POSITION, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_TO_VEHICLE_OFFSET, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_TO_LANDMARK, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_TO_SPEED_BUFFER, 1)\n    self.vehicle.commands.set_message_rate(MessageType.CMD_DO_SET_ROI_TO", "CodeBleu_score": 6.134406068309096}, {"code": "def hover(self)\n\n    # Set the coordinate frame and motion type\n    self.set_coordinate_frame(CoordinateFrame.GLOBAL_TERRAIN)\n    self.set_motion_type(MotionType.HOVER)\n\n    # Construct a target motion\n    self.target_motion = TargetMotion(\n        position=self.position,\n        yaw=self.yaw,\n        velocity=self.velocity,\n        acceleration=self.acceleration,\n        jerk=self.jerk,\n        snap=self.snap,\n        snap_velocity=self.snap_velocity,\n        snap_acceleration=self.snap_acceleration,\n    )\n\n    # Set the flight mode\n    self.set_flight_mode(FlightMode.HOVER)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(f\"Vehicle type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight mode: {self.flight_mode}\")\n\n", "CodeBleu_score": 28.739833957677575}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\n    # Check if flight mode is hover\n    if self.flight_mode == 'HOVER':\n        # Set hover flag\n        self.hover = True\n        # Call hover method\n        self.hover()\n        return True\n    else:\n        # Attempt to switch flight mode\n        try:\n            # Call flight mode service\n            self.flightModeService(flightMode=self.flight_mode)\n            # Print new flight mode\n            rospy.loginfo('Flight mode set to ' + self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            # Print failure message\n            rospy.loginfo('Failed to set flight mode: ' + str(e))\n            return False\n\n", "CodeBleu_score": 50.33769074922765}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(0, self.flight_mode)\n            rospy.loginfo(\"Flight mode switched to \" + self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            rospy.loginfo(\"Flight mode switch failed: \" + str(e))\n            return False\n", "CodeBleu_score": 42.02322136029884}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.client.call('mavros.set_mode', custom_mode=self.flight_mode)\n            rospy.loginfo(\"Flight mode switched to \" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.loginfo(\"Flight mode switch failed: \" + str(e))\n            return False\n", "CodeBleu_score": 41.788002325779026}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 51.10360294045804}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 51.633144163431034}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 51.10360294045804}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\n    if msg.id == i:\n        self.local_pose[i] = msg\n        self.global_pose[i] = self.local_pose[i]\n        self.global_pose[i].x += self.global_pose_bias.x\n        self.global_pose[i].y += self.global_pose_bias.y\n        self.global_pose[i].z += self.global_pose_bias.z\n\n        if msg.id == self.uav_id:\n            self.takeoff_target_pose = self.local_pose[i]\n            self.hover_target_pose = self.local_pose[i]\n\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = self.local_pose[i]\n            self.hover_target_pose = self.local_pose[i]\n        elif self.gcs_command == \"land\":\n            self.takeoff_target_pose.x = 0\n            self.takeoff_target_pose.y = 0\n            self.takeoff_target_pose.z = 0\n            self.hover_target_pose.x = 0\n            self.hover_target_pose.y = 0\n            self.hover_target_pose.z = 0\n\n    return\n", "CodeBleu_score": 23.995623489516458}, {"code": "def local_pose_callback(self, msg, i)\n    if msg.id == i:\n      self.local_pose[i] = msg\n      self.global_pose[i] = msg\n      if self.takeoff_target_pose[i].id == i:\n        self.takeoff_target_pose[i] = msg\n      if self.hover_target_pose[i].id == i:\n        self.hover_target_pose[i] = msg\n      self.global_pose[i].x += self.x_bias\n      self.global_pose[i].y += self.y_bias\n      self.global_pose[i].z += self.z_bias\n      self.global_pose[i].yaw += self.yaw_bias\n\n  def local_velocity_callback(self, msg, i):\n    \"\"\"This function, local_velocity_callback, updates the UAV's local velocity based on incoming messages.\\nIf the message index matches the UAV ID, it sets the local_velocity to the message.\"\"\"\n    if msg.id == i:\n      self.local_velocity[i] = msg\n\n  def local_acceleration_callback(self, msg, i):\n    \"\"\"This function, local_acceleration_callback, updates the UAV's local acceleration based on incoming messages.\\nIf the message index matches the UAV ID, it sets the local_acceleration to the message.\"\"\"\n    if msg.id == i:\n      self.local_acceleration[i] = msg\n\n  def local_angular_velocity_callback(self, msg, i):\n    \"\"\"This function, local_angular_velocity_callback, updates the UAV's local angular velocity based on incoming messages.\\nIf the message index matches the UAV ID, it sets the local_angular_velocity to the message.\"\"\"\n    if msg.id == i:\n      self.local_angular_velocity[i] = msg\n\n  def local_angular_acceleration_callback(self, msg, i):\n    \"\"\"This function, local_angular_acceleration_callback, updates the UAV's local angular acceleration based on incoming messages.\\nIf the message index matches the U", "CodeBleu_score": 21.27631231895012}, {"code": "def local_pose_callback(self, msg, i)\n    if msg.id == i:\n        self.local_pose = msg\n        if self.takeoff_target_pose.position.x == 0 and self.takeoff_target_pose.position.y == 0 and self.takeoff_target_pose.position.z == 0:\n            self.takeoff_target_pose.position.x = msg.position.x\n            self.takeoff_target_pose.position.y = msg.position.y\n            self.takeoff_target_pose.position.z = msg.position.z\n        if self.hover_target_pose.position.x == 0 and self.hover_target_pose.position.y == 0 and self.hover_target_pose.position.z == 0:\n            self.hover_target_pose.position.x = msg.position.x\n            self.hover_target_pose.position.y = msg.position.y\n            self.hover_target_pose.position.z = msg.position.z\n        self.global_pose.position.x = msg.position.x + self.bias.position.x\n        self.global_pose.position.y = msg.position.y + self.bias.position.y\n        self.global_pose.position.z = msg.position.z + self.bias.position.z\n        self.global_pose.orientation.x = msg.orientation.x\n        self.global_pose.orientation.y = msg.orientation.y\n        self.global_pose.orientation.z = msg.orientation.z\n        self.global_pose.orientation.w = msg.orientation.w\n        self.global_pose.covariance = msg.covariance\n        self.global_pose.header.stamp = msg.header.stamp\n        self.global_pose.header.frame_id = msg.header.frame_id\n", "CodeBleu_score": 18.753186790446367}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    return self.uav_data['altitude'] > 0.2 and self.uav_data['arm_state'] == 1\n", "CodeBleu_score": 39.621662251139036}, {"code": "def takeoff_detection(self)\n    return self.arm_state and self.altitude > 0.2\n", "CodeBleu_score": 32.79117124019157}, {"code": "def takeoff_detection(self)\n    return self.uav_state.altitude > 0.2 and self.uav_state.arm_state == \"active\"\n", "CodeBleu_score": 41.81075568799051}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    # Get the number of UAVs in the original and changed formations\n    num_orig_uavs = orig_formation.shape[0]\n    num_change_uavs = change_formation.shape[0]\n    # Initialize the distance matrix\n    dist_matrix = np.zeros((num_orig_uavs, num_change_uavs))\n    # Iterate through the rows of the distance matrix\n    for row in range(num_orig_uavs):\n        # Iterate through the columns of the distance matrix\n        for col in range(num_change_uavs):\n            # Calculate the distance between the UAVs in the original and changed formations\n            dist_matrix[row, col] = np.linalg.norm(orig_formation[row, :] - change_formation[col, :])\n            # Adjust the distance by subtracting it from 50 and converting it to an integer\n            dist_matrix[row, col] = int(50 - dist_matrix[row, col])\n    # Return the distance matrix\n    return dist_matrix\n\n", "CodeBleu_score": 23.554062119186476}, {"code": "def build_graph(self, orig_formation, change_formation)\n    formation_distance_matrix = []\n    for i in range(len(orig_formation)):\n        formation_distance_matrix.append([])\n        for j in range(len(change_formation)):\n            formation_distance_matrix[i].append(self.euclidean_distance(orig_formation[i], change_formation[j]))\n            formation_distance_matrix[i][j] = int(50 - formation_distance_matrix[i][j])\n    return formation_distance_matrix\n", "CodeBleu_score": 27.157166840347696}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # Initialize the distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = np.linalg.norm(np.array(orig_formation[i]) - np.array(change_formation[j])) - 50\n    # Convert the distances to integers\n    dist_matrix = np.around(dist_matrix).astype(int)\n    # Return the distance matrix\n    return dist_matrix\n", "CodeBleu_score": 25.890098329946575}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    self.left[i] = True\n    for j in self.right[i]:\n        if self.right[i][j] == 0:\n            continue\n        elif self.left[j]:\n            continue\n        elif self.slack[i][j] == 0:\n            self.left[j] = True\n            if self.find_path(j):\n                return True\n            else:\n                self.left[j] = False\n        else:\n            self.slack[i][j] = self.slack[i][j] - self.match[j]\n            if self.find_path(j):\n                return True\n            else:\n                self.slack[i][j] = self.slack[i][j] + self.match[j]\n    return False\n\n", "CodeBleu_score": 32.74611240789389}, {"code": "def find_path(self, i)\n    self.left_vertex[i].visited = True\n    for j in self.right_vertex[i].adjacent:\n        if not self.right_vertex[j].visited:\n            self.right_vertex[j].visited = True\n            self.gap = self.left_vertex[i].label - self.right_vertex[j].label\n            if self.gap == 0:\n                self.right_vertex[j].visited = False\n                if self.augment_path(i, j):\n                    return True\n            elif self.gap < 0:\n                self.right_vertex[j].slack = self.gap\n                self.augment_path(i, j)\n    return False\n\n", "CodeBleu_score": 30.881733616548967}, {"code": "def find_path(self, i)\n    self.left[i] = True\n    for j in self.right[i]:\n        if self.right[i][j] == 0:\n            continue\n        if not self.left[j]:\n            if self.find_path(j):\n                return True\n            else:\n                self.right[i][j] = 0\n        elif self.left[j] and self.left[j] != i:\n            if self.slack[i][j] == 0:\n                self.slack[i][j] = self.label[i] - self.label[j]\n            if self.slack[i][j] > 0:\n                self.slack[i][j] = 0\n            else:\n                self.slack[i][j] = self.label[i] - self.label[j]\n                if self.slack[i][j] == 0:\n                    self.match[i] = j\n                    self.match[j] = i\n                    return True\n    return False\n", "CodeBleu_score": 32.33705544510963}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n    # Initialize variables\n    self.visit = [False for _ in range(len(self.UAVs))]\n    self.slack = [0 for _ in range(len(self.UAVs))]\n    self.match = [0 for _ in range(len(self.UAVs))]\n    self.min_slack = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 10.939117712469839}, {"code": "def KM(self)\n\n    # Initialize slack variables and visit arrays\n    self.slack = [0] * len(self.UAVs)\n    self.visit = [0] * len(self.UAVs)\n\n    # Iterate over UAVs\n    for i in range(len(self.UAVs)):\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit = [0] * len(self.UAVs)\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit = [0] * len(self.UAVs)\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit = [0] * len(self.UAVs)\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit = [0] * len(self.UAVs)\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit = [0] * len(self.UAVs)\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit = [0] * len(self.UAVs)\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit = [0] * len(self.UAVs)\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit = [0] * len(self.UAVs)\n\n        # Initialize slack variables and reset visit arrays\n        self.slack = [0] * len(self.UAVs)\n        self.visit =", "CodeBleu_score": 22.807162891697324}, {"code": "def KM(self)\n    # Initialize slack variables\n    slack = [0] * self.num_uavs\n    # Initialize visit arrays\n    visited_uavs = [False] * self.num_uavs\n    visited_edges = [False] * self.num_edges\n    # Initialize label arrays\n    labels = [0] * self.num_uavs\n    # Initialize slack array\n    slack = [0] * self.num_uavs\n    # Initialize match arrays\n    matches = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n    # Initialize matching\n    matching = [0] * self.num_uavs\n   ", "CodeBleu_score": 15.487853180485331}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n    # Converting the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Creating a mask for yellow color\n    mask = cv2.inRange(hsv, (20, 100, 100), (30, 255, 255))\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 21.084117785810303}, {"code": "def yellow_dectection(image)\n    # Converting to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Defining lower and upper bounds for yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # Creating a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription    const TagDescriptionContainer& descriptionContainer = standalone_tag_descriptions_[id];\n    if (descriptionContainer.isNull()) {\n        if (printWarning) {\n            LOG(WARNING) << \"TagDetector::findStandaloneTagDescription: No standalone tag description found for ID \" << id;\n        }\n        return false;\n    }\n    description = descriptionContainer;\n    return true;\n}\n", "CodeBleu_score": 34.94754968488584}, {"code": "bool TagDetector::findStandaloneTagDescription    const std::string &id,\n    TagDescription &descriptionContainer,\n    bool printWarning = true\n} {\n    if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            ROS_WARN(\"No standalone tag description found for ID: %s\", id.c_str());\n        }\n        return false;\n    }\n    descriptionContainer = standalone_tag_descriptions_[id];\n    return true;\n}\n", "CodeBleu_score": 51.44922283130426}, {"code": "bool TagDetector::findStandaloneTagDescription    std::string descriptionContainer;\n    return findStandaloneTagDescription(id, descriptionContainer, printWarning);\n}\n", "CodeBleu_score": 5.018809472101965}]}
