{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t *cur_desc;\n\n\tcur_desc = (uint8_t *) desc;\n\twhile (cur_desc < (uint8_t *) desc + desc->bLength) {\n\t\tif (((usb_conf_desc_t *) cur_desc)->bDescriptorType == desc_id) {\n\t\t\treturn (usb_conf_desc_t *) cur_desc;\n\t\t}\n\t\tcur_desc += ((usb_conf_desc_t *) cur_desc)->bLength;\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 32.630304340800606}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t *p = (uint8_t *) desc;\n\tuint8_t desc_len;\n\n\twhile (p < (uint8_t *) &desc->next) {\n\t\tdesc_len = *p;\n\t\tif (desc_len == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (desc_len == 1) {\n\t\t\t/* End of configuration descriptor. */\n\t\t\treturn NULL;\n\t\t}\n\t\tif (desc_id == p[1]) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += desc_len;\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 34.58915244648017}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t *ptr = (uint8_t *) desc;\n\tptr += desc->bLength;\n\twhile (ptr < (uint8_t *) &desc->bLength + desc->wTotalLength) {\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc_tmp = (usb_conf_desc_t\n\t\t\t\tUDC_DESC_STORAGE *) ptr;\n\t\tif (desc_tmp->bDescriptorType == desc_id) {\n\t\t\treturn desc_tmp;\n\t\t}\n\t\tptr += desc_tmp->bLength;\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 38.698454788817294}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (udc_config_num == 0) {\n\t\treturn false;\n\t}\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\tuint8_t *desc = udc_config_desc->desc;\n\tuint16_t len = udc_config_desc->wTotalLength;\n\tuint16_t pos = 0;\n\twhile (pos < len) {\n\t\tif (desc[pos] == DTYPE_INTERFACE) {\n\t\t\tif (desc[pos + 2] == iface_num && desc[pos + 3] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tpos += desc[pos];\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 34.31302827419033}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tuint8_t *p = (uint8_t *)&usb_config_descriptor;\n\tuint8_t *end = p + usb_config_descriptor.wTotalLength;\n\tuint8_t *iface_desc;\n\tuint8_t *ep_desc;\n\tuint8_t i;\n\tuint8_t ep_count = 0;\n\n\tif (iface_num >= usb_config_descriptor.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tiface_desc = p + usb_config_descriptor.bLength;\n\n\twhile (iface_desc < end) {\n\t\tif (iface_desc->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num) {\n\t\t\t\tif (iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\t\tep_desc = iface_desc + iface_desc->bLength;\n\t\t\t\t\twhile (ep_desc < end) {\n\t\t\t\t\t\tif (ep_desc->bDescriptorType == USB_DESC_TYPE_ENDPOINT) {\n\t\t\t\t\t\t\tep_count++;\n\t\t\t\t\t\t\tep_desc += ep_desc->bLength;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tiface_desc += iface_desc->bLength;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 41.60541817645039}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\tuint8_t *desc = udc_config_desc;\n\twhile (desc < udc_config_desc + udc_config_desc->wTotalLength) {\n\t\tif (desc[0] == 0x04 && desc[2] == iface_num && desc[3] == setting_num) {\n\t\t\treturn true;\n\t\t}\n\t\tdesc += desc[0];\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 30.628904553956037}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void)\tuint8_t ep_num = (uint8_t)((uint16_t)UDC_SETUP_BUF[1] >> 4);\n\tuint8_t ep_status;\n\n\t/* Check if request length matches the size of the endpoint status variable */\n\tif (UDC_SETUP_BUF[6] != 2) {\n\t\treturn false;\n\t}\n\n\t/* Determine the status of the specified endpoint */\n\tif (udc_ep_halted(ep_num)) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\t/* Set up the response payload with the endpoint status */\n\tUDC_SETUP_BUF[3] = ep_status;\n\tUDC_SETUP_BUF[4] = ep_status;\n\n\t/* Return \"true\" */\n\treturn true;\n}\n", "CodeBleu_score": 31.089943816706224}, {"code": "static bool udc_req_std_ep_get_status(void)\tif (req->wLength != sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\tep_status = udc_ep_get_status(req->wIndex);\n\treturn udc_req_setup_response(req->wIndex, sizeof(ep_status), &ep_status);\n}\n", "CodeBleu_score": 39.069815930065424}, {"code": "static bool udc_req_std_ep_get_status(void)\tuint8_t ep_num = req_setup.wIndex;\n\tuint8_t ep_status = 0;\n\n\t/* Check if the request length matches the size of the endpoint status variable. */\n\tif (req_setup.wLength != 2) {\n\t\treturn false;\n\t}\n\n\t/* Determine the status of the specified endpoint, setting the status to \"halted\" if the endpoint is halted, or \"0\" if it is not. */\n\tif (udc_ep_is_halted(ep_num)) {\n\t\tep_status = 1;\n\t}\n\n\t/* Set up the response payload with the endpoint status. */\n\tudc_setup_payload_set(0, &ep_status, 2);\n\n\t/* Return \"true\". */\n\treturn true;\n}\n", "CodeBleu_score": 20.88311824251396}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void)\tuint8_t bInterfaceNumber;\n\tuint8_t bAlternateSetting;\n\tuint8_t bNumEndpoints;\n\tuint8_t bInterfaceClass;\n\tuint8_t bInterfaceSubClass;\n\tuint8_t bInterfaceProtocol;\n\tuint8_t bInterface;\n\tuint8_t iInterface;\n\tuint8_t *pDescriptor;\n\tuint8_t *pDescriptorEnd;\n\tuint8_t *pDescriptorType;\n\tuint8_t *pDescriptorClass;\n\tuint8_t *pDescriptorSubClass;\n\tuint8_t *pDescriptorProtocol;\n\tuint8_t *pDescriptorInterface;\n\tuint8_t *pDescriptorEndpoints;\n\tuint8_t *pDescriptorEndpoint;\n\tuint8_t *pDescriptorEndpointType;\n\tuint8_t *pDescriptorEndpointAddress;\n\tuint8_t *pDescriptorEndpointAttributes;\n\tuint8_t *pDescriptorEndpointSize;\n\tuint8_t *pDescriptorEndpointInterval;\n\tuint8_t *pDescriptorInterfaceString;\n\tuint8_t *pDescriptorEndpointString;\n\tuint8_t *pDescriptorInterfaceStringIndex;\n\tuint8_t *pDescriptorEndpointStringIndex;\n\tuint8_t *pDescriptorInterfaceStringLength;\n\tuint8_t *pDescriptorEndpointStringLength;\n\tuint8_t *pDescriptorInterfaceStringIndexEnd;\n\tuint8_t *pDescriptorEndpointStringIndexEnd;\n\tuint8_t *pDescriptorInterfaceStringLengthEnd;\n\tuint8_t *pDescriptorEndpointStringLengthEnd;\n\tuint8_t *pDescriptorInterfaceString;\n\tuint8_t *pDescriptorEndpointString;\n\tuint8_t *pDescriptorInterfaceStringEnd;\n\tuint8_t *pDescriptorEndpointStringEnd;\n\tuint8_t *pDescriptorInterface;\n\tuint8_t *pDescriptorInterfaceEnd;\n\tuint8_t *pDescriptorEndpointsEnd;\n\tuint8_t *pDescriptorEndpoint;\n\tuint8_t *pDescriptorEndpointEnd;\n\tuint8_t *pDescriptorInterfaceStringIndex;\n\tuint8_t *pDescriptorEndpointStringIndex;\n\tuint8", "CodeBleu_score": 8.33834157446877}, {"code": "static bool udc_req_iface(void)\tuint8_t iface = UDC_SETUP.wIndex.bytes[0];\n\tuint8_t alt = UDC_SETUP.wValue.bytes[0];\n\tif (udc_state != UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\tif (iface >= USB_NUM_INTERFACES) {\n\t\treturn false;\n\t}\n\tif (alt >= USB_NUM_ALT_INTERFACES) {\n\t\treturn false;\n\t}\n\tif (UDC_SETUP.bmRequestType.Recipient != REQTYPE_RECIPIENT_INTERFACE) {\n\t\treturn false;\n\t}\n\tif (UDC_SETUP.bmRequestType.Direction != REQTYPE_DIRECTION_HOST_TO_DEVICE) {\n\t\treturn false;\n\t}\n\tif (UDC_SETUP.bmRequestType.Type != REQTYPE_TYPE_STANDARD) {\n\t\treturn false;\n\t}\n\tif (UDC_SETUP.bRequest != REQ_SET_INTERFACE) {\n\t\treturn false;\n\t}\n\tif (udc_iface_alt_settings[iface] != alt) {\n\t\tif (udc_iface_alt_settings[iface] == 0) {\n\t\t\tudc_iface_alt_settings[iface] = alt;\n\t\t\tudc_iface_settings[iface] = &udc_iface_settings_list[iface][alt];\n\t\t\tif (udc_iface_settings[iface]->init != NULL) {\n\t\t\t\tudc_iface_settings[iface]->init();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (udc_iface_settings[iface]->deinit != NULL) {\n\t\t\t\tudc_iface_settings[iface]->deinit();\n\t\t\t}\n\t\t\tudc_iface_alt_settings[iface] = alt;\n\t\t\tudc_iface_settings[iface] = &udc_if", "CodeBleu_score": 46.48839574103982}, {"code": "static bool udc_req_iface(void)\tuint8_t iface = 0;\n\tuint8_t alt_setting = 0;\n\tuint8_t ep = 0;\n\tuint8_t i = 0;\n\tuint8_t j = 0;\n\tuint8_t n = 0;\n\tuint8_t iface_class = 0;\n\tuint8_t iface_subclass = 0;\n\tuint8_t iface_protocol = 0;\n\tuint8_t iface_index = 0;\n\tuint8_t ep_addr = 0;\n\tuint8_t ep_type = 0;\n\tuint8_t ep_size = 0;\n\tuint8_t ep_bank = 0;\n\tuint8_t ep_interval = 0;\n\tuint8_t ep_max_packet_size = 0;\n\tuint8_t ep_max_packet_count = 0;\n\tuint8_t ep_max_packet_count_tx = 0;\n\tuint8_t ep_max_packet_count_rx = 0;\n\tuint8_t ep_max_packet_count_tx_dma = 0;\n\tuint8_t ep_max_packet_count_rx_dma = 0;\n\tuint8_t ep_max_packet_size_dma = 0;\n\tuint8_t ep_max_packet_size_dma_tx = 0;\n\tuint8_t ep_max_packet_size_dma_rx = 0;\n\tuint8_t ep_max_packet_size_dma_tx_dma = 0;\n\tuint8_t ep_max_packet_size_dma_rx_dma = 0;\n\tuint8_t ep_max_packet_size_dma_tx_dma_tx = 0;\n\tuint8_t ep_max_packet_size_dma_rx_dma_rx = 0;\n\tuint8_t ep_max_packet_size_dma_tx_dma_rx =", "CodeBleu_score": 4.036804059471401}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void)\t// Check if the interface is already enabled\n\tif (udi_msc_state != UDI_MSC_UNINIT) {\n\t\treturn false;\n\t}\n\n\t// Initialize the internal state variables\n\tudi_msc_state = UDI_MSC_INIT;\n\tudi_msc_nb_lun = udi_msc_get_nb_lun();\n\tudi_msc_lun_in_use = 0;\n\tudi_msc_cbw_received = false;\n\tudi_msc_cbw_valid = false;\n\tudi_msc_csw_send = false;\n\tudi_msc_csw_valid = false;\n\tudi_msc_csw_status = 0;\n\tudi_msc_trans_in_progress = false;\n\tudi_msc_trans_pos = 0;\n\tudi_msc_trans_size = 0;\n\tudi_msc_trans_size_tot = 0;\n\tudi_msc_trans_size_short = 0;\n\tudi_msc_trans_size_long = 0;\n\tudi_msc_trans_direction = UDI_MSC_TRANS_NONE;\n\tudi_msc_trans_cbw_tag = 0;\n\tudi_msc_trans_cbw_lun = 0;\n\tudi_msc_trans_cbw_length = 0;\n\tudi_msc_trans_cbw_flags = 0;\n\tudi_msc_trans_cbw_length_valid = false;\n\tudi_msc_trans_cbw_data_residue = 0;\n\tudi_msc_trans_cbw_data_length = 0;\n\tudi_msc_trans_cbw_data_length_valid = false;\n\tudi_msc_trans_cbw_data_length_tot = 0;\n\tudi_msc_trans_cbw_data_length_short = 0;\n\tudi_msc_trans_cbw_data_length_long = 0;\n\tudi_msc_trans_", "CodeBleu_score": 33.16185848409769}, {"code": "bool udi_msc_enable(void)\tbool ret = false;\n\tuint8_t i;\n\n\t// Initialize the MSC interface\n\tfor (i = 0; i < UDI_MSC_NUM_LUN; i++) {\n\t\tudi_msc_lun[i].in_use = false;\n\t}\n\tudi_msc_nb_lun = 0;\n\n\t// Check if the LUNs are available\n\tfor (i = 0; i < UDI_MSC_NUM_LUN; i++) {\n\t\tif (udi_msc_enable_lun(i)) {\n\t\t\tudi_msc_nb_lun++;\n\t\t}\n\t}\n\n\tif (udi_msc_nb_lun) {\n\t\tudi_msc_cbw.dCBWTag = 0;\n\t\tudi_msc_cbw.dCBWDataTransferLength = 0;\n\t\tudi_msc_cbw.bmCBWFlags = 0;\n\t\tudi_msc_cbw.bCBWLUN = 0;\n\t\tudi_msc_cbw.bCBWCBLength = 0;\n\n\t\tudi_msc_csw.dCSWTag = 0;\n\t\tudi_msc_csw.dCSWDataResidue = 0;\n\t\tudi_msc_csw.bCSWStatus = 0;\n\n\t\tudi_msc_lun[0].in_use = true;\n\t\tudi_msc_lun[0].unit_ready = false;\n\t\tudi_msc_lun[0].read_only = false;\n\n\t\tudi_msc_lun[0].address = 0;\n\t\tudi_msc_lun[0].size = UDI_MSC_LUN_0_MEDIA_SIZE;\n\t\tudi_msc_lun[0].block_size = UDI_MSC_LUN_0_BLOCK_SIZE;\n\t\tudi_msc_lun[0].block_count = UDI_MSC_LUN_0_MEDIA_", "CodeBleu_score": 33.622691473415614}, {"code": "bool udi_msc_enable(void)\tbool ret = false;\n\tuint8_t i;\n\t\n\t// Initialize the LUNs\n\tfor(i = 0; i < UDI_MSC_LUN_QTY; i++) {\n\t\tudi_msc_lun[i].udi_msc_lun_in_use = false;\n\t\tudi_msc_lun[i].udi_msc_lun_status = UDI_MSC_LUN_NOT_READY;\n\t\tudi_msc_lun[i].udi_msc_lun_state = UDI_MSC_LUN_IDLE;\n\t\tudi_msc_lun[i].udi_msc_lun_address = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_erase = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_read_only = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_remaining = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_used = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_block = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_block_remaining = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_block_used = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_block_erase = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_block_read_only = 0;\n\t\tudi_msc_lun[i].udi_msc_lun_size_block_remaining = 0;\n\t\tudi_msc_lun[i", "CodeBleu_score": 31.14664565696038}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\n\tif (status != UDD_EP_TRANSFER_OK) {\n\t\t// A transfer error occurs\n\t\t// Wait for a MSC reset to restart CBW reception\n\t\tudi_msc_reset_state();\n\t\treturn;\n\t}\n\n\t// Check if a transfer is ongoing\n\tif (udi_msc_trans_on_going()) {\n\t\t// Decrease the data residue in the CSW by the amount of data sent\n\t\tudi_msc_csw_data_residue_dec(nb_sent);\n\n\t\t// Process the updated CSW\n\t\tudi_msc_process_csw();\n\t}\n}\n\n", "CodeBleu_score": 48.90081354989502}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\n\t// Check if a data transfer is ongoing\n\tif (udi_msc_trans_on_going) {\n\t\t// Check the status of the transfer\n\t\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t\t// Decrease the data residue in the CSW\n\t\t\tudi_msc_csw_residue -= nb_sent;\n\t\t\t// If the data residue is 0, the transfer is complete\n\t\t\tif (udi_msc_csw_residue == 0) {\n\t\t\t\t// Update the sense data\n\t\t\t\tudi_msc_update_sense_data(udi_msc_cbw.bLUN,\n\t\t\t\t\t\tudi_msc_cbw.dCBWDataTransferLength,\n\t\t\t\t\t\tudi_msc_cbw.bmCBWFlags);\n\t\t\t\t// Send the CSW\n\t\t\t\tudi_msc_send_csw();\n\t\t\t}\n\t\t} else {\n\t\t\t// If the transfer is not successful, wait for a MSC setup reset to restart CBW reception\n\t\t\tudi_msc_trans_on_going = false;\n\t\t\tudi_msc_wait_for_cbw = true;\n\t\t}\n\t}\n}\n\n", "CodeBleu_score": 47.809803205134564}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\n\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t// Decrease the data residue in the CSW by the amount of data sent\n\t\tudi_msc_cbw.bCBWDataTransferLength -= nb_sent;\n\t\t// Update the sense data\n\t\tudi_msc_cbw.bCSWStatus = UDI_MSC_CBW_STATUS_PASSED;\n\t\t// Update the CSW\n\t\tudi_msc_update_csw();\n\t\t// Increment the number of data sent\n\t\tudi_msc_nb_data_sent += nb_sent;\n\t\t// If all data are sent, then send the CSW\n\t\tif (udi_msc_nb_data_sent == udi_msc_cbw.dCBWDataTransferLength) {\n\t\t\tudi_msc_send_csw();\n\t\t}\n\t} else {\n\t\t// If the transfer is not successful, then wait for a MSC setup reset to restart CBW reception\n\t\tudi_msc_cbw_reset();\n\t}\n}\n\n", "CodeBleu_score": 47.369289164459936}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void)\tuint16_t csw_data_residue;\n\tuint8_t csw_status;\n\tuint8_t csw_tag;\n\n\tif (udi_msc_cbw.dCBWDataTransferLength) {\n\t\tcsw_data_residue = udi_msc_cbw.dCBWDataTransferLength;\n\t\tcsw_status = CSW_CMD_PASSED;\n\t\tif (udi_msc_cbw.bmCBWFlags & 0x80) {\n\t\t\tcsw_data_residue = 0;\n\t\t\tcsw_status = CSW_CMD_FAILED;\n\t\t}\n\t} else {\n\t\tcsw_data_residue = udi_msc_cbw.dCBWDataTransferLength;\n\t\tcsw_status = CSW_CMD_PASSED;\n\t}\n\n\t// Prepare the Command Status Wrapper (CSW)\n\tudi_msc_csw.dCSWSignature = CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le16(csw_data_residue);\n\tudi_msc_csw.bCSWStatus = csw_status;\n\n\t// Send the Command Status Wrapper (CSW)\n\tudi_msc_csw_send();\n}\n\n", "CodeBleu_score": 47.83621425195796}, {"code": "static void udi_msc_csw_process(void)\tuint16_t res_len;\n\tuint16_t res_len_le;\n\n\t// If the data residue is not zero, stall the appropriate endpoint\n\tif (udi_msc_cbw.dCBWDataTransferLength != 0) {\n\t\tif (udi_msc_cbw.bmCBWFlags & MSC_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_stall_in_endpoint();\n\t\t} else {\n\t\t\tudi_msc_stall_out_endpoint();\n\t\t}\n\t}\n\n\t// Prepare the CSW\n\tudi_msc_csw.dCSWSignature = MSC_CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = 0;\n\tudi_msc_csw.bCSWStatus = MSC_CSW_COMMAND_PASSED;\n\n\t// Convert the data residue to little-endian format\n\tres_len = udi_msc_cbw.dCBWDataTransferLength;\n\tres_len_le = udi_msc_swap_bytes(res_len);\n\tudi_msc_csw.dCSWDataResidue = res_len_le;\n\n\t// Send the CSW\n\tudi_msc_trans_in_progress = false;\n\tudi_msc_trans_in_progress = udi_msc_trans_in_progress_cbw;\n\tudi_msc_trans_in_progress_cbw = false;\n\tudi_msc_trans_in_progress_csw = true;\n\tudi_msc_trans_in_progress_cbw_fail = false;\n\tudi_msc_trans_in_progress_csw_fail = false;\n\tudi_msc_trans_in_progress_csw_fail_stall = false;\n\tudi_msc_trans_in_progress_csw_fail_stall", "CodeBleu_score": 48.049967719259655}, {"code": "static void udi_msc_csw_process(void)\tuint32_t residue = udi_msc_residue();\n\tif (residue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & 0x80) {\n\t\t\t// Data-In\n\t\t\tudc_stall_data_in_ep(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\t// Data-Out\n\t\t\tudc_stall_data_out_ep(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(residue);\n\tudi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_PASSED;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw_send();\n}\n", "CodeBleu_score": 54.626791659581706}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)  if (b_enable) {\n    /* DTR is enabled, cancel any pending reset */\n    cancelReset(port);\n  } else {\n    /* DTR is disabled, schedule a reset */\n    scheduleReset(port);\n  }\n}\n", "CodeBleu_score": 36.58621939974924}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)    if (b_enable) {\n        /*\n         * If the DTR signal is enabled, cancel any scheduled reset.\n         */\n        cancelReset(port);\n    } else {\n        /*\n         * If the DTR signal is disabled, check if the DTR rate is 1200.\n         */\n        if (g_dtrRate[port] == 1200) {\n            /*\n             * If the DTR rate is 1200, schedule a delayed system reset.\n             */\n            scheduleReset(port);\n        }\n    }\n}\n", "CodeBleu_score": 44.30940122499058}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (b_enable) {\n\t\t// Cancel any pending resets\n\t\tcancelReset(port);\n\t} else {\n\t\t// Schedule a reset after 100ms\n\t\tscheduleReset(port, 100);\n\t}\n}\n", "CodeBleu_score": 29.704896677515674}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)\tuint8_t request_index;\n\tuint8_t *request_payload;\n\tuint16_t request_size;\n\n\trequest_index = usb_control_request_index();\n\trequest_payload = usb_control_request_payload();\n\trequest_size = usb_control_request_size();\n\n\t// Check for request type\n\tif (usb_control_request_type() != REQUEST_TYPE_VENDOR) {\n\t\treturn false;\n\t}\n\n\t// Check for specific request indices\n\tswitch (request_index) {\n\t\tcase 0x04:\n\t\t\t// Set up pointer and size for Microsoft-compatible ID descriptor\n\t\t\tusb_control_request_payload_set(usb_microsoft_compatible_id_descriptor_payload);\n\t\t\tusb_control_request_size_set(sizeof(usb_microsoft_compatible_id_descriptor_payload));\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\t// Set up pointer and size for Microsoft-compatible extended properties descriptor\n\t\t\tusb_control_request_payload_set(usb_microsoft_compatible_extended_properties_descriptor_payload);\n\t\t\tusb_control_request_size_set(sizeof(usb_microsoft_compatible_extended_properties_descriptor_payload));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Request index not recognized\n\t\t\treturn false;\n\t}\n\n\t// Update control request payload and size\n\tusb_control_request_payload_set(request_payload);\n\tusb_control_request_size_set(request_size);\n\n\t// Request processed\n\treturn true;\n}\n", "CodeBleu_score": 25.49658046220223}, {"code": "bool usb_task_other_requests(void)    uint8_t request_index;\n    uint16_t payload_size;\n\n    /* Check the request type. */\n    if (usb_device_state == USB_DEVICE_STATE_CONFIGURED) {\n        if (usb_control_request_type == USB_REQUEST_TYPE_VENDOR) {\n            /* Check the request index. */\n            request_index = usb_control_request_index;\n            if (request_index == 0x04) {\n                /* Set up a pointer to the Microsoft-compatible ID descriptor. */\n                usb_control_request_payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n                /* Set the size of the payload. */\n                payload_size = sizeof(microsoft_compatible_id_descriptor);\n            } else if (request_index == 0x05) {\n                /* Set up a pointer to the Microsoft-compatible extended properties descriptor. */\n                usb_control_request_payload = (uint8_t*)&microsoft_compatible_extended_properties_descriptor;\n                /* Set the size of the payload. */\n                payload_size = sizeof(microsoft_compatible_extended_properties_descriptor);\n            } else {\n                /* The request index is not recognized. */\n                return false;\n            }\n            /* Update the control request payload and size. */\n            usb_control_request_size = payload_size;\n            return true;\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 31.40270488330647}, {"code": "bool usb_task_other_requests(void)    // Check the request type\n    if (USB_CTRL_REQ_TYPE_VENDOR != usb_ctrl_req_type) {\n        return false;\n    }\n\n    // Process the request index\n    switch (usb_ctrl_req_index) {\n        case 0x04:\n            // Set up pointer and size for Microsoft-compatible ID descriptor\n            usb_ctrl_payload_ptr = (uint8_t *)&usb_microsoft_compatible_id_descriptor;\n            usb_ctrl_payload_size = sizeof(usb_microsoft_compatible_id_descriptor);\n            break;\n\n        case 0x05:\n            // Set up pointer and size for Microsoft-compatible extended properties descriptor\n            usb_ctrl_payload_ptr = (uint8_t *)&usb_microsoft_extended_properties_descriptor;\n            usb_ctrl_payload_size = sizeof(usb_microsoft_extended_properties_descriptor);\n            break;\n\n        default:\n            return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 22.586940005475242}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tuint16_t i;\n\tfor (i = 0; i < nbyte; i++) {\n\t\tif (i == nbyte - 1) {\n\t\t\tspiRec(buf[i]);\n\t\t} else {\n\t\t\tspiSend(0x00);\n\t\t\tbuf[i] = spiRec(0x00);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 45.713825098770656}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)    if (nbyte == 0) {\n        return;\n    }\n    SPI1->DR = 0xFF;\n    for (uint16_t i = 0; i < nbyte - 1; i++) {\n        while (!(SPI1->SR & SPI_SR_RXNE));\n        buf[i] = SPI1->DR;\n        SPI1->DR = 0xFF;\n    }\n    while (!(SPI1->SR & SPI_SR_RXNE));\n    buf[nbyte - 1] = SPI1->DR;\n}\n", "CodeBleu_score": 50.42776029575852}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)  if (nbyte == 0) return;\n\n  uint16_t i;\n  for (i = 0; i < nbyte - 1; i++) {\n    SPI.transfer(0x00);\n    buf[i] = spiRec();\n  }\n  buf[i] = spiRec();\n}\n", "CodeBleu_score": 50.04018439356577}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    pfnISR_Handler oldHandler = (pfnISR_Handler) (&__vector_table[irq]);\n    __disable_irq();\n    __set_isr(irq, newHandler);\n    __enable_irq();\n    return oldHandler;\n}\n", "CodeBleu_score": 42.682622573675125}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)  pfnISR_Handler oldHandler;\n  uint32_t *p_vector_table = (uint32_t *)SCB->VTOR;\n\n  __disable_irq();\n\n  oldHandler = (pfnISR_Handler)p_vector_table[irq];\n  p_vector_table[irq] = (uint32_t)newHandler;\n\n  __enable_irq();\n\n  return oldHandler;\n}\n", "CodeBleu_score": 50.90750167880059}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    pfnISR_Handler oldHandler;\n    uint32_t *vectorTable = (uint32_t *)SCB->VTOR;\n    uint32_t *irqVector = (uint32_t *)(vectorTable + irq);\n    uint32_t *irqHandler = (uint32_t *)(*irqVector);\n    uint32_t *irqHandler_end = irqHandler + 1;\n    uint32_t *irqHandler_new = (uint32_t *)newHandler;\n\n    __disable_irq();\n\n    oldHandler = (pfnISR_Handler)irqHandler_new;\n\n    /* Copy the original ISR handler to the new location */\n    for (; irqHandler < irqHandler_end; irqHandler++, irqHandler_new++) {\n        *irqHandler = *irqHandler_new;\n    }\n\n    __enable_irq();\n\n    return oldHandler;\n}\n", "CodeBleu_score": 43.57398348809066}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek()  if (usb_serial_available()) return usb_serial_getchar();\n  return -1;\n}\n", "CodeBleu_score": 6.4398373129174065}, {"code": "int MarlinSerialUSB::peek()  if (serialUSB.available()) {\n    return serialUSB.peek();\n  }\n  return -1;\n}\n", "CodeBleu_score": 15.38336918384173}, {"code": "int MarlinSerialUSB::peek()  if (USB_Available()) {\n    uint8_t b = USB_RecvChar();\n    if (b == 0x03) {\n      emergency_parser();\n      b = USB_RecvChar();\n    }\n    return b;\n  }\n  return -1;\n}\n", "CodeBleu_score": 35.84248954123825}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read()  if (rx_buffer_head != rx_buffer_tail) {\n    uint8_t c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % BUFFER_SIZE;\n    return c;\n  }\n  if (!cdc_enabled) return -1;\n  if (!cdc_configured) return -1;\n  if (!cdc_rx_available()) return -1;\n  uint8_t c = cdc_read();\n  if (emergency_parser_enabled) emergency_parser_rx_byte(c);\n  return c;\n}\n", "CodeBleu_score": 39.893516949797956}, {"code": "int MarlinSerialUSB::read()  int c = -1;\n  if (rx_buffer_head != rx_buffer_tail) {\n    c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) & BUFFER_MASK;\n  }\n  else if (usb_configuration) {\n    if (usb_cdc_rx_available()) {\n      c = usb_cdc_rx_getchar();\n      if (emergency_parser_enabled)\n        emergency_parser_rx_byte(c);\n    }\n  }\n  return c;\n}\n", "CodeBleu_score": 33.91747044318755}, {"code": "int MarlinSerialUSB::read()  int c = -1;\n\n  if (rx_buffer_head != rx_buffer_tail) {\n    c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % BUFFER_SIZE;\n  }\n  else if (usb_configuration) {\n    if (usb_serial_available()) {\n      c = usb_serial_getchar();\n      if (emergency_parser_enabled) emergency_parser_state = c;\n    }\n  }\n  return c;\n}\n", "CodeBleu_score": 33.57278078159525}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available()  if (rx_buffer_head != rx_buffer_tail) {\n    return (rx_buffer_head - rx_buffer_tail);\n  }\n  if (rx_buffer_head == rx_buffer_tail) {\n    if (cdc_available()) {\n      return 1;\n    }\n    return 0;\n  }\n  return 0;\n}\n", "CodeBleu_score": 38.15686051916867}, {"code": "int MarlinSerialUSB::available()  int count = 0;\n\n  if (rx_buffer_head != rx_buffer_tail) {\n    count = rx_buffer_head - rx_buffer_tail;\n    if (count < 0)\n      count += SERIAL_RX_BUFFER_SIZE;\n  }\n\n  if (!count && (rx_buffer_head == rx_buffer_tail)) {\n    if (USB_Configuration) {\n      if (USB_DeviceState == DEVICE_STATE_Configured) {\n        if (USB_Device_CDC_IsReady())\n          return 1;\n      }\n    }\n  }\n\n  return count;\n}\n", "CodeBleu_score": 41.1212744227082}, {"code": "int MarlinSerialUSB::available()  if (rx_buffer_head != rx_buffer_tail) {\n    uint16_t head = rx_buffer_head;\n    uint16_t tail = rx_buffer_tail;\n    if (head >= RX_BUFFER_SIZE) head = 0;\n    if (tail >= RX_BUFFER_SIZE) tail = 0;\n    uint16_t n = head - tail;\n    if (n < 0) n += RX_BUFFER_SIZE;\n    return n;\n  }\n  if (usb_configuration) {\n    if (rx_available) return 1;\n    if (rx_overflow) return -1;\n    return 0;\n  }\n  return -1;\n}\n", "CodeBleu_score": 30.052797779698782}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)  if (size == 0) return true;\n  if (pos >= size()) return false;\n  if (pos + size > size()) size = size() - pos;\n  if (value) {\n    for (size_t i = 0; i < size; i++) {\n      *value++ = read_byte(pos++);\n      if (writing) *crc += *value;\n    }\n  }\n  else {\n    pos += size;\n  }\n  return true;\n}\n", "CodeBleu_score": 45.65713794964481}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\tif (pos + size > size()) return false;\n\tif (value) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tvalue[i] = read_byte(pos);\n\t\t\tif (writing) crc16(crc, value[i]);\n\t\t\tpos++;\n\t\t}\n\t}\n\telse {\n\t\tpos += size;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 47.19244221844497}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\n\tif (!writing) {\n\t\treturn true;\n\t}\n\n\tif (size == 0) {\n\t\treturn true;\n\t}\n\n\tif (value == nullptr) {\n\t\treturn true;\n\t}\n\n\tif (crc == nullptr) {\n\t\treturn true;\n\t}\n\n\tif (pos < 0) {\n\t\treturn true;\n\t}\n\n\tuint16_t crc_local = *crc;\n\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = read_byte(pos);\n\t\tcrc_local = crc_ccitt_update(crc_local, value[i]);\n\t}\n\n\t*crc = crc_local;\n\n\treturn true;\n}\n", "CodeBleu_score": 42.532909312248535}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)    if (pin >= PINS_COUNT) return;\n\n    if (pin >= PINS_COUNT) return;\n\n    if (pin < PINS_COUNT && pin >= 0) {\n        if (pin < PINS_COUNT && pin >= 0) {\n            if (pin < PINS_COUNT && pin >= 0) {\n                if (pin < PINS_COUNT && pin >= 0) {\n                    if (pin < PINS_COUNT && pin >= 0) {\n                        if (pin < PINS_COUNT && pin >= 0) {\n                            if (pin < PINS_COUNT && pin >= 0) {\n                                if (pin < PINS_COUNT && pin >= 0) {\n                                    if (pin < PINS_COUNT && pin >= 0) {\n                                        if (pin < PINS_COUNT && pin >= 0) {\n                                            if (pin < PINS_COUNT && pin >= 0) {\n                                                if (pin < PINS_COUNT && pin >= 0) {\n                                                    if (pin < PINS_COUNT && pin >= 0) {\n                                                        if (pin < PINS_COUNT && pin >= 0) {\n                                                            if (pin < PINS_COUNT && pin >= 0) {\n                                                                if (pin < PINS_COUNT && pin >= 0) {\n                                                                    if (pin < PINS_COUNT && pin >= 0) {\n                                                                        if (pin < PINS_COUNT && pin >= 0) {\n                                                                            if (pin < PINS_COUNT && pin >= 0) {\n                                                                                if (pin < PINS_COUNT && pin >= 0) {\n                                                                                    if (pin < PINS_COUNT && pin >= 0) {\n                                                                                        if (pin < PINS_COUNT && pin >= 0) {\n                                                                                            if (pin < PINS_COUNT && pin >= 0) {\n                                                                                                if (pin < PINS", "CodeBleu_score": 16.9693852912795}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  if (pin >= PWM_MAX_PINS) return;\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == 255) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (freq == 0) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value > 128) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (freq > PWM_MAX_FREQ) return;\n  if (res > PWM_MAX_RES) return;\n  if (res < PWM_MIN_RES) return;\n  if (freq < PWM_MIN_FREQ) return;\n\n  if (pin >= PWM_MAX_PINS) return;\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == 255) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (freq == 0) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value > 128) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (freq > PWM_MAX_FREQ) return;\n  if (res > PWM_MAX_RES) return;\n  if (res < PWM_MIN_RES) return;\n  if (freq < PWM_MIN_FREQ) return;\n\n  if (pin >= PWM_MAX_PINS) return;\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == 255)", "CodeBleu_score": 41.035598113964255}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)    if (value == 0) {\n        digitalWrite(pin, LOW);\n    } else {\n        if (value == 255) {\n            digitalWrite(pin, HIGH);\n        } else {\n            uint32_t period = 1000000UL / freq;\n            uint32_t pulse = (period * value) / 255;\n            uint32_t duty = (period * res) / 255;\n            if (pulse < duty) {\n                pulse = duty;\n            }\n            if (pulse > period) {\n                pulse = period;\n            }\n            ledcWrite(pin, pulse);\n        }\n    }\n}\n", "CodeBleu_score": 40.166799946859214}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value)\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == 16, \"The servo delay array length must be 16.\");\n\tif (servo_attach()) {\n\t\tservo_write(value);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tservo_detach();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 30.94035378372353}, {"code": "void Servo::move(const int value)\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == 16, \"The length of the servo delay array must be 16\");\n\tif (servo.attach(servoPin)) {\n\t\tservo.write(value);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tservo.detach();\n\t\t}\n\t}\n\telse {\n\t\tSerial.println(\"Servo not attached\");\n\t}\n\tdelay(servoDelayArray[servoChannel]);\n}\n", "CodeBleu_score": 48.27491513252711}, {"code": "void Servo::move(const int value)\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == 16, \"The servo delay array length must be 16.\");\n\n\tif (attach()) {\n\t\twrite(value);\n\t\tdelay(servo_delay_array[servo_channel]);\n\n\t\t#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n\t\t\tdetach();\n\t\t#endif\n\t}\n}\n", "CodeBleu_score": 36.53490758972017}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample()  uint8_t i;\n  uint32_t *port_data = (uint32_t *)(I2S_DMA_BUFFER_BASE + (I2S_BUFFER_SIZE * I2S_BUFFER_INDEX));\n  uint32_t *port_data_next = (uint32_t *)(I2S_DMA_BUFFER_BASE + (I2S_BUFFER_SIZE * (I2S_BUFFER_INDEX + 1)));\n  uint32_t port_data_mask;\n  uint32_t port_data_next_mask;\n  uint32_t port_data_shift;\n  uint32_t port_data_next_shift;\n  uint32_t port_data_mask_next;\n  uint32_t port_data_shift_next;\n  uint32_t port_data_mask_next_shift;\n  uint32_t port_data_mask_next_shift_next;\n  uint32_t port_data_mask_next_shift_next_mask;\n  uint32_t port_data_mask_next_shift_next_mask_next;\n  uint32_t port_data_mask_next_shift_next_mask_next_shift;\n  uint32_t port_data_mask_next_shift_next_mask_next_shift_next;\n  uint32_t port_data_mask_next_shift_next_mask_next_shift_next_mask;\n  uint32_t port_data_mask_next_shift_next_mask_next_shift_next_mask_next;\n  uint32_t port_data_mask_next_shift_next_mask_next_shift_next_mask_next_shift;\n  uint32_t port_data_mask_next_shift_next_mask_next_shift_next_mask_next_shift_next;\n  uint32_t port_data_mask_next_shift_next_mask_next_shift_next_mask_next_shift_next_mask;\n  uint32_t port_data_mask_next", "CodeBleu_score": 10.669593139652847}, {"code": "void i2s_push_sample()    int i;\n    for (i = 0; i < 8; i++) {\n        if (PWM_STATE[i] == 0) {\n            PORTB_DMA[i] = 0;\n        } else {\n            if (PWM_TICK_COUNT[i] == 0) {\n                PORTB_DMA[i] = PORTB_DMA[i] ^ (1 << i);\n                PWM_TICK_COUNT[i] = PWM_TICK_COUNT[i] + PWM_TICK_RATE[i];\n            } else {\n                PWM_TICK_COUNT[i] = PWM_TICK_COUNT[i] - 1;\n            }\n        }\n    }\n    DMA_BUFFER_POSITION = DMA_BUFFER_POSITION + 1;\n    if (DMA_BUFFER_POSITION == DMA_BUFFER_SIZE) {\n        DMA_BUFFER_POSITION = 0;\n    }\n}\n", "CodeBleu_score": 33.82564319161263}, {"code": "void i2s_push_sample()  // Push the sample to the DMA buffer\n  // Update the PWM states for each pin\n  // Write the resulting data to the DMA buffer\n  for (int i = 0; i < NUM_PINS; i++) {\n    if (pwm_duty[i] > 0) {\n      if (pwm_tick[i] == 0) {\n        // Toggle the pin state\n        if (pwm_state[i] == HIGH) {\n          pwm_state[i] = LOW;\n        } else {\n          pwm_state[i] = HIGH;\n        }\n        // Set the tick count for the next transition\n        pwm_tick[i] = pwm_duty[i];\n      }\n      // Store the updated port data into the current position of the DMA buffer\n      *(dma_buffer + dma_buffer_position) = pwm_state[i];\n    } else {\n      // Store a zero value for the current position of the DMA buffer\n      *(dma_buffer + dma_buffer_position) = 0;\n    }\n    // Increment the buffer position\n    dma_buffer_position++;\n    // If the buffer position reaches the end of the buffer, reset it to the beginning\n    if (dma_buffer_position >= DMA_BUFFER_SIZE) {\n      dma_buffer_position = 0;\n    }\n  }\n}\n", "CodeBleu_score": 33.84607165520562}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)    hal_timer_t timer_count = 0;\n    if (timer_num < HAL_TIMER_MAX_NUM) {\n        timer_count = hal_timer_base[timer_num]->CNT;\n    }\n    return timer_count;\n}\n", "CodeBleu_score": 36.753413721658}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)  hal_timer_t timer_count;\n\n  switch (timer_num) {\n    case 0:\n      timer_count = TIMER0->CNT;\n      break;\n    case 1:\n      timer_count = TIMER1->CNT;\n      break;\n    case 2:\n      timer_count = TIMER2->CNT;\n      break;\n    case 3:\n      timer_count = TIMER3->CNT;\n      break;\n    case 4:\n      timer_count = TIMER4->CNT;\n      break;\n    case 5:\n      timer_count = TIMER5->CNT;\n      break;\n    case 6:\n      timer_count = TIMER6->CNT;\n      break;\n    case 7:\n      timer_count = TIMER7->CNT;\n      break;\n    case 8:\n      timer_count = TIMER8->CNT;\n      break;\n    case 9:\n      timer_count = TIMER9->CNT;\n      break;\n    case 10:\n      timer_count = TIMER10->CNT;\n      break;\n    case 11:\n      timer_count = TIMER11->CNT;\n      break;\n    case 12:\n      timer_count = TIMER12->CNT;\n      break;\n    case 13:\n      timer_count = TIMER13->CNT;\n      break;\n    case 14:\n      timer_count = TIMER14->CNT;\n      break;\n    case 15:\n      timer_count = TIMER15->CNT;\n      break;\n    case 16:\n      timer_count = TIMER16->CNT;\n      break;\n    case 17:\n      timer_count = TIMER17->CNT;\n      break;\n    case 18:\n      timer_count = TIMER18->CNT;\n      break;\n    case 19:\n      timer_count = TIMER19", "CodeBleu_score": 26.366038900573336}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\treturn (hal_timer_t)HAL_timer_get_raw_count(timer_num);\n}\n", "CodeBleu_score": 15.042320342598181}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)    uint16_t crc_value = 0;\n    for (size_t i = 0; i < size; i++) {\n        if (writing) value[i] = eeprom_read_byte((uint8_t *)(pos + i));\n        crc_value = _crc_update(crc_value, value[i]);\n    }\n    if (crc) *crc = crc_value;\n    pos += size;\n    return false;\n}\n", "CodeBleu_score": 65.70018979124981}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  if (!eeprom_is_ready()) return false;\n  if (size == 0) return true;\n  if (value == NULL) return false;\n  if (crc == NULL) return false;\n\n  // Read data from EEPROM\n  for (size_t i = 0; i < size; i++) {\n    value[i] = eeprom_read_byte((uint8_t *)(pos + i));\n    *crc = _crc_update(*crc, value[i]);\n  }\n\n  // Write data into buffer\n  if (writing) {\n    for (size_t i = 0; i < size; i++) {\n      eeprom_write_byte((uint8_t *)(pos + i), value[i]);\n    }\n  }\n\n  pos += size;\n  return false;\n}\n", "CodeBleu_score": 58.540739733492764}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  uint16_t crc_value = 0;\n  if (crc) crc_value = *crc;\n  for (size_t i = 0; i < size; i++) {\n    if (writing) value[i] = eeprom_read_byte((uint8_t *)(pos + i));\n    crc_value = _crc_ccitt_update(crc_value, value[i]);\n  }\n  if (crc) *crc = crc_value;\n  pos += size;\n  return false;\n}\n", "CodeBleu_score": 66.32052352923408}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (sdio == nullptr) {\n\t\tprintf(\"SDIO_WriteBlock: SDIO handle is null\\n\");\n\t\treturn false;\n\t}\n\tif (src == nullptr) {\n\t\tprintf(\"SDIO_WriteBlock: Source pointer is null\\n\");\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < SDIO_MAX_RETRIES; i++) {\n\t\tif (sdio->writeBlock(block, src)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tprintf(\"SDIO_WriteBlock: Write operation failed\\n\");\n\treturn false;\n}\n", "CodeBleu_score": 37.830873669084454}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    if (sdio == NULL || src == NULL) {\n        return false;\n    }\n\n    for (int i = 0; i < SDIO_MAX_RETRIES; i++) {\n        if (sdio->writeBlock(block, src)) {\n            return true;\n        }\n    }\n\n    Serial.println(\"[SDIO] Failed to write block!\");\n    return false;\n}\n", "CodeBleu_score": 31.939744081356004}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (sdio == NULL || src == NULL) {\n\t\tfprintf(stderr, \"SDIO_WriteBlock: SDIO handle or source pointer is null.\\n\");\n\t\treturn false;\n\t}\n\tuint32_t block_addr = block * 512;\n\tuint32_t retries = 0;\n\twhile (retries < MAX_RETRIES) {\n\t\tif (SD_WriteBlock(sdio, block_addr, src)) {\n\t\t\treturn true;\n\t\t}\n\t\tretries++;\n\t}\n\tfprintf(stderr, \"SDIO_WriteBlock: Failed to write block %u.\\n\", block);\n\treturn false;\n}\n", "CodeBleu_score": 43.36100053199618}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)  if (timer_num == TIMER_CHANNEL_TEMP) {\n    TCCR1B = _BV(CS11) | _BV(CS10); // 64 prescaler\n    OCR1A = (F_CPU / 64) / frequency - 1;\n    TIMSK1 |= _BV(OCIE1A);\n  }\n  else if (timer_num == TIMER_CHANNEL_STEP) {\n    TCCR2B = _BV(CS21) | _BV(CS20); // 64 prescaler\n    OCR2A = (F_CPU / 64) / frequency - 1;\n    TIMSK2 |= _BV(OCIE2A);\n  }\n  else {\n    #if ENABLED(DEBUG_TIMER_RATE)\n      SERIAL_ECHO_START;\n      SERIAL_ECHOPGM(MSG_TIMER_START);\n      SERIAL_ECHO(timer_num);\n      SERIAL_ECHOPAIR(MSG_TIMER_FREQUENCY, frequency);\n      SERIAL_ECHOLNPAIR(MSG_TIMER_PRESCALE, 64);\n    #endif\n    TERN_(DEBUG_TIMER_RATE, HAL_timer_start_stop(false));\n    TERN_(DEBUG_TIMER_RATE, HAL_timer_start_stop(true));\n    UNREACHABLE_RETURN;\n  }\n}\n", "CodeBleu_score": 40.95123379977929}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)  switch (timer_num) {\n    case TIMER_CH_0:\n      // set timer frequency\n      TIMER_CH0->CTL = (TIMER_CH0->CTL & ~(TIMER_CTL_PSC_Msk | TIMER_CTL_CMP_Msk)) | (frequency << TIMER_CTL_PSC_Pos) | (frequency << TIMER_CTL_CMP_Pos);\n      // enable timer interrupt\n      TIMER_CH0->CTL |= TIMER_CTL_INTEN_Msk;\n      break;\n    case TIMER_CH_1:\n      // set timer frequency\n      TIMER_CH1->CTL = (TIMER_CH1->CTL & ~(TIMER_CTL_PSC_Msk | TIMER_CTL_CMP_Msk)) | (frequency << TIMER_CTL_PSC_Pos) | (frequency << TIMER_CTL_CMP_Pos);\n      // enable timer interrupt\n      TIMER_CH1->CTL |= TIMER_CTL_INTEN_Msk;\n      break;\n    case TIMER_CH_2:\n      // set timer frequency\n      TIMER_CH2->CTL = (TIMER_CH2->CTL & ~(TIMER_CTL_PSC_Msk | TIMER_CTL_CMP_Msk)) | (frequency << TIMER_CTL_PSC_Pos) | (frequency << TIMER_CTL_CMP_Pos);\n      // enable timer interrupt\n      TIMER_CH2->CTL |= TIMER_CTL_INTEN_Msk;\n      break;\n    case TIMER_CH_3:\n      // set timer frequency\n      TIMER_CH3->CTL = (TIMER_CH3->CTL & ~(TIMER_CTL_PSC_Msk | TIMER_CTL_CMP_Msk)) | (frequency << TIMER_CTL_PSC_Pos) | (frequency <<", "CodeBleu_score": 32.29032820817874}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)  #if ENABLED(TEMP_TIMER)\n    if (timer_num == TEMP_TIMER) {\n      HAL_timer_set_temp_ISR_frequency(frequency);\n      return;\n    }\n  #endif\n\n  #if ENABLED(STEPPER_TIMER)\n    if (timer_num == STEPPER_TIMER) {\n      HAL_timer_set_stepper_ISR_frequency(frequency);\n      return;\n    }\n  #endif\n\n  #if ENABLED(TEMP_TIMER) && ENABLED(STEPPER_TIMER)\n    if (timer_num == TEMP_TIMER || timer_num == STEPPER_TIMER) {\n      // Both timers are used. Start the timer with the highest frequency.\n      if (frequency > TEMP_TIMER_FREQUENCY)\n        HAL_timer_set_temp_ISR_frequency(frequency);\n      else\n        HAL_timer_set_stepper_ISR_frequency(frequency);\n      return;\n    }\n  #endif\n\n  // If we get here, the timer channel is invalid.\n  UNUSED(timer_num);\n  UNUSED(frequency);\n  HAL_assert_ex(false, \"Invalid timer channel\");\n}\n", "CodeBleu_score": 44.031699705159454}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start()  // Open the file for reading and writing.\n  // If the file doesn't exist, it will be created.\n  // If the file is too small, it will be extended.\n  // If the file is too large, it will be truncated.\n  if (!file.open(file_name, O_RDWR | O_CREAT | O_TRUNC)) {\n    return false;\n  }\n  // Get the file size.\n  file_size = file.size();\n  // If the file is smaller than the expected EEPROM size, fill the remainder of the buffer with a default erase value.\n  if (file_size < size) {\n    memset(&buffer[file_size], EEPROM_DEFAULT_ERASE_VALUE, size - file_size);\n    file_size = size;\n  }\n  // Read the file's contents into the buffer.\n  file.read(buffer, file_size);\n  // Close the file.\n  file.close();\n  // Return \"true\" to indicate success.\n  return true;\n}\n", "CodeBleu_score": 29.735145916913204}, {"code": "bool PersistentStore::access_start()  if (!SPIFFS.begin()) {\n    Serial.println(\"SPIFFS Mount Failed\");\n    return false;\n  }\n  File file = SPIFFS.open(FILE_NAME, FILE_READ);\n  if (!file) {\n    Serial.println(\"Failed to open file for reading\");\n    return false;\n  }\n  // get length of file and allocate a buffer\n  fileSize = file.size();\n  if (fileSize > EEPROM_SIZE) {\n    Serial.print(\"EEPROM size is smaller than file size\");\n    return false;\n  }\n  buffer = (uint8_t *)malloc(fileSize);\n  if (!buffer) {\n    Serial.println(\"Not enough memory\");\n    return false;\n  }\n  // read file and place data into buffer\n  file.read(buffer, fileSize);\n  // close file and return\n  file.close();\n  return true;\n}\n", "CodeBleu_score": 36.11488450548963}, {"code": "bool PersistentStore::access_start()  if (!_initialized) {\n    // Check if the file exists and can be opened\n    if (!_file.open(_path, O_RDWR)) {\n      // If not, create a new file\n      if (!_file.open(_path, O_RDWR | O_CREAT | O_TRUNC)) {\n        return false;\n      }\n    }\n    // Check the file size\n    _file_size = _file.size();\n    if (_file_size < _size) {\n      // If the file is smaller than the expected EEPROM size, fill the remainder with a default erase value\n      _file.write(_erase_value, _size - _file_size);\n      _file_size = _size;\n    }\n    // Read the file's contents into the buffer\n    _file.read(_buffer, _size);\n    // Close the file\n    _file.close();\n    // Mark the buffer as initialized\n    _initialized = true;\n  }\n  return true;\n}\n", "CodeBleu_score": 36.69883954830947}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t i, r = 0;\n    for (i = 0; i < 8; i++) {\n        SPI_STM32_CLOCK_LOW();\n        SPI_STM32_MOSI_WRITE(b & 0x80);\n        SPI_STM32_CLOCK_HIGH();\n        r = (r << 1) | SPI_STM32_MISO_READ();\n        b = b << 1;\n    }\n    SPI_STM32_DELAY();\n    return r;\n}\n", "CodeBleu_score": 38.187530228833175}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i;\n\tuint8_t r = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiTransfer_Mode_1(b & 0x80);\n\t\tr = (r << 1) | HAL_SPI_STM32_SpiTransfer_Mode_2();\n\t\tb <<= 1;\n\t}\n\treturn r;\n}\n", "CodeBleu_score": 28.67023084307952}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t i;\n\tuint8_t c;\n\tuint8_t d;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiClockLow();\n\t\tHAL_SPI_STM32_SpiWriteMosi(b);\n\t\tHAL_SPI_STM32_SpiClockHigh();\n\t\tc = HAL_SPI_STM32_SpiReadMiso();\n\t\td = (b << 1) | (c & 0x01);\n\t\tb = d;\n\t}\n\tHAL_SPI_STM32_SpiDelay();\n\treturn b;\n}\n", "CodeBleu_score": 37.22821222808507}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}\n", "CodeBleu_score": 79.58798619099609}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 80.59593798820907}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 80.59593798820907}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  uint8_t c;\n  if (!(obj->rx_buff.sts & SERIAL_RX_STS_FRAMING_ERR)) {\n    c = obj->serial.rx_fifo_read();\n    if (obj->rx_buff.head == obj->rx_buff.tail) {\n      // Buffer full.\n      obj->rx_buff.sts |= SERIAL_RX_STS_FULL;\n    }\n    else {\n      obj->rx_buff.buffer[obj->rx_buff.head] = c;\n      obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n    }\n    if (obj->rx_buff.sts & SERIAL_RX_STS_FRAMING_ERR) {\n      obj->rx_buff.sts &= ~SERIAL_RX_STS_FRAMING_ERR;\n    }\n  }\n  else {\n    obj->rx_buff.sts |= SERIAL_RX_STS_FRAMING_ERR;\n  }\n}\n", "CodeBleu_score": 40.53495688450014}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  uint8_t c;\n  uint8_t *buf;\n  int16_t i;\n  int16_t rx_head;\n  int16_t rx_tail;\n  int16_t rx_size;\n\n  // Get index of internal buffer to store new data\n  rx_head = rx_buffer_head;\n  rx_tail = rx_buffer_tail;\n  rx_size = sizeof(rx_buffer) / sizeof(rx_buffer[0]);\n\n  // Get data from serial peripheral\n  c = obj->char_rx;\n\n  // Check if buffer is full\n  if (((rx_head + 1) % rx_size) != rx_tail) {\n    // Store new data in internal buffer\n    buf = &rx_buffer[rx_head];\n    *buf = c;\n\n    // Update head pointer\n    rx_head++;\n    if (rx_head >= rx_size) {\n      rx_head = 0;\n    }\n  }\n\n  // Update the head pointer\n  rx_buffer_head = rx_head;\n\n  // Check if emergency parser needs to be updated\n  if (rx_buffer_head != rx_buffer_tail) {\n    // Get next byte from buffer\n    buf = &rx_buffer[rx_buffer_tail];\n\n    // Check if buffer is empty\n    if (rx_buffer_tail == rx_head) {\n      // Buffer is empty\n      rx_buffer_tail = rx_head;\n    } else {\n      // Buffer is not empty\n      // Check if emergency parser is enabled\n      if (rx_buffer_tail != rx_buffer_head) {\n        // Emergency parser is enabled\n        // Check if emergency parser is ready\n        if (!rx_buffer_flag) {\n          // Emergency parser is not ready\n          // Check if emergency parser is in idle state\n          if (rx_buffer_state == STATE_IDLE) {\n            // Emergency parser is in idle state\n            // Check if the first byte is a start byte\n            if (buf[0] == ST", "CodeBleu_score": 26.839601546061836}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  uint8_t c;\n  int16_t i = (int16_t)(obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\n  if (i != obj->rx_tail) {\n    c = obj->serial_in;\n    obj->rx_buffer[obj->rx_head] = c;\n    obj->rx_head = i;\n\n    // Check if the received byte is an emergency stop character\n    if (c == SERIAL_ECHO_PREFIX) {\n      echo_buffer_head = (echo_buffer_head + 1) % BUF_SIZE;\n      echo_buffer[echo_buffer_head] = c;\n    }\n  }\n}\n", "CodeBleu_score": 57.900459960331155}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)  if (timer_num < TIMER_COUNT) {\n    if (timer_num == MF_TIMER_STEP) {\n      if (step_timer_interrupt_flag == 0) {\n        step_timer_interrupt_flag = 1;\n        attachInterrupt(digitalPinToInterrupt(STEP_TIMER_INTERRUPT_PIN), Step_Handler, CHANGE);\n      }\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n      if (temp_timer_interrupt_flag == 0) {\n        temp_timer_interrupt_flag = 1;\n        attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_INTERRUPT_PIN), Temp_Handler, CHANGE);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 34.718012144511135}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)    if (timer_num >= MF_TIMER_STEP && timer_num <= MF_TIMER_TEMP) {\n        if (timer_num == MF_TIMER_STEP) {\n            if (step_timer_interrupt_attached == false) {\n                step_timer_interrupt_attached = true;\n                switch (step_timer_mode) {\n                    case MF_TIMER_MODE_16BIT:\n                        HAL_timer_attach_interrupt(step_timer_num, &Step_Handler, MF_TIMER_MODE_16BIT);\n                        break;\n                    case MF_TIMER_MODE_8BIT:\n                        HAL_timer_attach_interrupt(step_timer_num, &Step_Handler, MF_TIMER_MODE_8BIT);\n                        break;\n                    case MF_TIMER_MODE_32BIT:\n                        HAL_timer_attach_interrupt(step_timer_num, &Step_Handler, MF_TIMER_MODE_32BIT);\n                        break;\n                }\n            }\n        }\n        if (timer_num == MF_TIMER_TEMP) {\n            if (temp_timer_interrupt_attached == false) {\n                temp_timer_interrupt_attached = true;\n                switch (temp_timer_mode) {\n                    case MF_TIMER_MODE_16BIT:\n                        HAL_timer_attach_interrupt(temp_timer_num, &Temp_Handler, MF_TIMER_MODE_16BIT);\n                        break;\n                    case MF_TIMER_MODE_8BIT:\n                        HAL_timer_attach_interrupt(temp_timer_num, &Temp_Handler, MF_TIMER_MODE_8BIT);\n                        break;\n                    case MF_TIMER_MODE_32BIT:\n                        HAL_timer_attach_interrupt(temp_timer_num, &Temp_Handler, MF_TIMER_MODE_32BIT);\n                        break", "CodeBleu_score": 33.33775406147476}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (!(TIFR & (1 << TOV1))) {\n\t\t\tTIMSK |= (1 << TOIE1);\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (!(TIFR & (1 << TOV2))) {\n\t\t\tTIMSK |= (1 << TOIE2);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 22.277804110789795}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tn := len(s)\n\tk := len(sep)\n\tif n < k {\n\t\treturn -1\n\t}\n\tif k == 0 {\n\t\treturn n\n\t}\n\n\t// Rabin-Karp search\n\th := hash(sep, k)\n\tif h == 0 {\n\t\treturn 0\n\t}\n\tr := 1\n\tfor i := 1; i < k; i++ {\n\t\tr = (r * 256) % h\n\t}\n\tc := 0\n\tfor i := 0; i < k; i++ {\n\t\tc = (c * 256) % h\n\t\tc += int(s[i])\n\t\tc %= h\n\t}\n\tfor i := n - k; i >= 0; i-- {\n\t\tif c == 0 && s[i:i+k] == sep {\n\t\t\treturn i\n\t\t}\n\t\tif i < n-k {\n\t\t\tc = (c*256 + int(s[i+k]) - int(s[i])*r) % h\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 41.54902448189589}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tn := len(s)\n\tm := len(sep)\n\tif n < m {\n\t\treturn -1\n\t}\n\n\tvar h1, h2 uint64\n\tfor i := 0; i < m; i++ {\n\t\th1 = h1*primeRK + uint64(s[i])\n\t\th2 = h2*primeRK + uint64(sep[i])\n\t}\n\n\tvar p uint64 = 1\n\tfor i := 0; i < m-1; i++ {\n\t\tp = p * primeRK\n\t}\n\n\tfor i := n - m; i >= 0; i-- {\n\t\tif h1 == h2 && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t\th1 -= p * uint64(s[i])\n\t\th1 *= primeRK\n\t\th1 += uint64(s[i+m])\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 41.63082317506207}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tn := len(s)\n\tm := len(sep)\n\tif n < m {\n\t\treturn -1\n\t}\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif n == 0 {\n\t\treturn -1\n\t}\n\tif m == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\n\th1 := Hash(s[:m])\n\th2 := Hash(sep)\n\tif h1 == h2 {\n\t\tfor i := n - m; i >= 0; i-- {\n\t\t\tif s[i:i+m] == sep {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := n - m; i >= 0; i-- {\n\t\th1 = (h1 - Hash(s[i]) + Hash(s[i+m])) % P\n\t\tif h1 == h2 {\n\t\t\tfor j := 0; j < m; j++ {\n\t\t\t\tif s[i+j] != sep[j] {\n\t\t\t\t\tgoto next\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i\n\t\t}\n\tnext:\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 41.50133173398389}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.bus.store(&usbcdc.USBCDC_Flush)\n}\n", "CodeBleu_score": 7.024475267295056}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.waitTxc = false\n\tif usbcdc.TxBuf.Len() == 0 {\n\t\treturn\n\t}\n\tusbcdc.SendUSBInPacket()\n}\n", "CodeBleu_score": 22.43980765149063}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.bus.store(&usbcdc.USBCDC_Flush)\n}\n", "CodeBleu_score": 7.024475267295056}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.control.Clear(I2C_CTRL_IF)\n\ti2c.control.SetBits(I2C_CTRL_START)\n\ti2c.control.SetBits(I2C_CTRL_IEN)\n\ti2c.address.Set(uint32(address) << 1)\n\tif write {\n\t\ti2c.control.ClearBits(I2C_CTRL_READ)\n\t} else {\n\t\ti2c.control.SetBits(I2C_CTRL_READ)\n\t}\n\tfor !i2c.control.GetBits(I2C_CTRL_IF) {\n\t}\n}\n", "CodeBleu_score": 29.638744435505927}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.ctrl.Clear(I2C_CTRL_IF)\n\ti2c.ctrl.Set(I2C_CTRL_START)\n\ti2c.waitForInterrupt()\n\ti2c.address.Set(uint32(address) << 1)\n\tif write {\n\t\ti2c.ctrl.Set(I2C_CTRL_ACK)\n\t}\n\ti2c.ctrl.Set(I2C_CTRL_EN)\n\ti2c.waitForInterrupt()\n}\n", "CodeBleu_score": 26.794620947656732}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.clearInterrupt()\n\ti2c.setStart()\n\ti2c.waitForStart()\n\ti2c.write(address<<1 | uint8(write))\n}\n", "CodeBleu_score": 20.265343211556786}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\treturn nil\n}\n", "CodeBleu_score": 3.283230433686614}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tif start < 0 || len < 0 || start+len > f.NumBlocks() {\n\t\treturn errors.New(\"invalid block range\")\n\t}\n\tif f.isBusy() {\n\t\treturn errors.New(\"flash busy\")\n\t}\n\tf.setMode(flashErase)\n\tfor i := int64(0); i < len; i++ {\n\t\taddr := f.blockAddress(start + i)\n\t\tif err := f.waitForReady(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := f.eraseBlock(addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := f.waitForReady(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tf.setMode(flashRead)\n\treturn nil\n}\n", "CodeBleu_score": 32.09546689561119}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tvar err error\n\t// set the flash to erase mode\n\tf.setEraseMode()\n\t// calculate the start address of the first block to be erased\n\tstartAddr := f.startAddress + start*f.blockSize\n\t// erase blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// erase the block\n\t\terr = f.eraseBlock(startAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// wait until the flash is no longer busy\n\t\terr = f.waitUntilNotBusy()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// increment the start address\n\t\tstartAddr += f.blockSize\n\t}\n\t// set the flash to read mode\n\tf.setReadMode()\n\treturn nil\n}\n", "CodeBleu_score": 34.727792011503155}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 {\n\t\treturn 0, errors.New(\"WriteAt: offset cannot be less than zero\")\n\t}\n\tif int64(len(p))+off > f.size {\n\t\treturn 0, errors.New(\"WriteAt: write size exceeds flash memory bounds\")\n\t}\n\tif off%int64(f.blockSize) != 0 {\n\t\treturn 0, errors.New(\"WriteAt: offset must be a multiple of block size\")\n\t}\n\tif len(p)%f.blockSize != 0 {\n\t\treturn 0, errors.New(\"WriteAt: write size must be a multiple of block size\")\n\t}\n\tstartAddr := uint32(off)\n\tfor i := 0; i < len(p); i += f.blockSize {\n\t\tif err := f.enableWrite(); err != nil {\n\t\t\treturn i, err\n\t\t}\n\t\tif err := f.writeBlock(startAddr, p[i:i+f.blockSize]); err != nil {\n\t\t\treturn i, err\n\t\t}\n\t\tif err := f.waitReady(); err != nil {\n\t\t\treturn i, err\n\t\t}\n\t\tstartAddr += f.blockSize\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 26.31145191990496}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 {\n\t\treturn 0, errors.New(\"offset is less than zero\")\n\t}\n\tif off >= f.size {\n\t\treturn 0, errors.New(\"offset exceeds flash memory bounds\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > f.size {\n\t\treturn 0, errors.New(\"write exceeds flash memory bounds\")\n\t}\n\tif len(p)%f.blockSize != 0 {\n\t\tp = append(p, make([]byte, f.blockSize-(len(p)%f.blockSize))...)\n\t}\n\tstart := off / int64(f.blockSize)\n\tend := (off + int64(len(p))) / int64(f.blockSize)\n\tfor i := start; i < end; i++ {\n\t\tif err := f.enableWriteMode(i); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif err := f.writeBlock(p, i); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif err := f.waitForWrite(i); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 30.11871906965709}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 {\n\t\treturn 0, errors.New(\"WriteAt: offset is negative\")\n\t}\n\tif off >= f.size {\n\t\treturn 0, errors.New(\"WriteAt: offset is larger than the flash memory size\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, errors.New(\"WriteAt: byte slice is empty\")\n\t}\n\tif len(p) > int(f.size-off) {\n\t\treturn 0, errors.New(\"WriteAt: byte slice is larger than the flash memory size\")\n\t}\n\n\t// Calculate start address for writing\n\tstartAddress := uint32(off)\n\n\t// Pad byte slice to fit the write block size\n\tpad := make([]byte, f.writeBlockSize-len(p)%f.writeBlockSize)\n\tp = append(p, pad...)\n\n\t// Enable write mode on the flash memory controller\n\tf.flash.CR.Store(f.flash.CR.Load() | flash.CR_PG)\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(p); i += int(f.writeBlockSize) {\n\t\t// Write the block\n\t\tf.flash.CR.Store(f.flash.CR.Load() | flash.CR_SER)\n\t\tfor j := 0; j < int(f.writeBlockSize); j++ {\n\t\t\tf.flash.CR.Store(f.flash.CR.Load() & ^flash.CR_SNB)\n\t\t\tf.flash.CR.Store(f.flash.CR.Load() | uint32(j))\n\t\t\tf.flash.CR.Store(f.flash.CR.Load() | flash.CR_STRT)\n\t\t\tf.flash.CR.Store(f.flash.CR.Load() | flash.CR_PG)\n\t\t\tfor !f.flash.SR.HasBits(flash.SR_EOP) {\n\t\t\t}\n\t\t\tf.flash.SR.Store(f.flash.SR.Load() & ^flash.SR_EOP)\n\t\t}\n\n", "CodeBleu_score": 31.55191493216248}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor.\n\tdupFD, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory.\n\tdir, err := syscall.Fdopendir(dupFD)\n\tif err != nil {\n\t\tsyscall.Close(dupFD)\n\t\treturn 0, \"\", err\n\t}\n\n\t// Close the duplicated file descriptor.\n\tsyscall.Close(dupFD)\n\n\t// Return the directory pointer.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}\n", "CodeBleu_score": 56.198738014145746}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory.\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\n\t\t// If we encountered EINTR, we need to retry.\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If we get here, we encountered an error other than EINTR.\n\t// Close the duplicated file descriptor and return the error.\n\tsyscall.Close(dupFd)\n\treturn 0, \"\", err\n}\n", "CodeBleu_score": 61.43110003142937}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor.\n\tdup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"dup: %w\", err)\n\t}\n\tdefer syscall.Close(dup)\n\n\t// Attempt to open the directory.\n\tdir, err := syscall.Fdopendir(dup)\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"fdopendir: %w\", err)\n\t}\n\n\t// Success!\n\treturn uintptr(dir), \"\", nil\n}\n", "CodeBleu_score": 49.13840424105578}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response)  uint32_t size = 0;\n  esp_partition_t* partition = esp_ota_get_running_partition();\n  esp_image_metadata_t data;\n  if (esp_ota_get_partition_description(partition, &data) == ESP_OK) {\n    if (response) {\n      size = data.image.image_size;\n    } else {\n      size = data.image.app_data_len;\n    }\n  }\n  return size;\n}\n", "CodeBleu_score": 43.22317362064851}, {"code": "static uint32_t sketchSize(sketchSize_t response)    uint32_t size = 0;\n    esp_partition_t *partition = esp_ota_get_running_partition();\n    if (partition == NULL) {\n        return 0;\n    }\n    if (partition->address == 0x1000) {\n        size = spi_flash_get_chip_size() / 0x1000;\n    } else {\n        if (esp_ota_get_partition_description(partition, &ota_data) == ESP_OK) {\n            if (ota_data.image_len != 0) {\n                size = ota_data.image_len;\n            }\n        }\n    }\n    if (response == true) {\n        return size;\n    } else {\n        return size - partition->size;\n    }\n}\n", "CodeBleu_score": 48.68433769996789}, {"code": "static uint32_t sketchSize(sketchSize_t response)    esp_partition_t *partition = esp_ota_get_running_partition();\n    uint32_t size = 0;\n    if (partition == NULL) {\n        ESP_LOGE(TAG, \"Error: esp_ota_get_running_partition() failed\");\n        return 0;\n    }\n    if (esp_ota_get_partition_description(partition, &size, NULL, NULL) != ESP_OK) {\n        ESP_LOGE(TAG, \"Error: esp_ota_get_partition_description() failed\");\n        return 0;\n    }\n    if (response) {\n        return size;\n    } else {\n        return esp_ota_get_image_size(partition);\n    }\n}\n", "CodeBleu_score": 40.012266282695606}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\tuint32_t disk_sectors;\n\tuint16_t bytes_per_sector;\n\tuint16_t sectors_per_cluster;\n\tuint16_t reserved_sectors;\n\tuint16_t root_dir_entries;\n\tuint32_t total_clusters;\n\tuint16_t fat_sectors;\n\tuint32_t fat_offset;\n\tuint32_t root_offset;\n\tuint32_t data_offset;\n\tuint32_t i;\n\tuint8_t *fat_table;\n\tuint8_t *root_dir;\n\tuint8_t *data_area;\n\tuint16_t *boot_sector;\n\tbool result = false;\n\n\t/* Calculate the required disk sectors */\n\tdisk_sectors = (msc_update_data_size + MSC_UPDATE_SECTORS_PER_FAT - 1) / MSC_UPDATE_SECTORS_PER_FAT;\n\tif (disk_sectors < MSC_UPDATE_MINIMUM_DISK_SECTORS) {\n\t\tdisk_sectors = MSC_UPDATE_MINIMUM_DISK_SECTORS;\n\t}\n\n\t/* Allocate memory for the RAM disk */\n\tmsc_update_ram_disk_size = disk_sectors * MSC_UPDATE_SECTOR_SIZE;\n\tmsc_update_ram_disk = malloc(msc_update_ram_disk_size);\n\tif (msc_update_ram_disk == NULL) {\n\t\tmsc_update_log_error(MSC_UPDATE_ERROR_MEMORY_ALLOCATION_FAILED);\n\t\treturn false;\n\t}\n\n\t/* Set up the boot sector */\n\tboot_sector = (uint16_t *)msc_update_ram_disk;\n\tboot_sector[0] = 0xEB;\n\tboot_sector[1] = 0x3C;\n\tboot_sector[2] = 0x90;\n\tboot_sector[3] = ", "CodeBleu_score": 28.553273975130427}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)    uint32_t i;\n    uint32_t j;\n    uint32_t first_sector;\n    uint32_t fat_sector;\n    uint32_t fat_sector_count;\n    uint32_t fat_sector_offset;\n    uint32_t fat_sector_size;\n    uint32_t fat_sector_total;\n    uint32_t root_sector;\n    uint32_t root_sector_count;\n    uint32_t root_sector_size;\n    uint32_t root_sector_total;\n    uint32_t root_sector_total_size;\n    uint32_t root_sector_total_size_fat;\n    uint32_t root_sector_total_size_root;\n    uint32_t root_sector_total_size_root_fat;\n    uint32_t root_sector_total_size_root_fat_boot;\n    uint32_t root_sector_total_size_root_fat_boot_root;\n    uint32_t root_sector_total_size_root_fat_boot_root_fat;\n    uint32_t root_sector_total_size_root_fat_boot_root_fat_boot;\n    uint32_t root_sector_total_size_root_fat_boot_root_fat_boot_root;\n    uint32_t root_sector_total_size_root_fat_boot_root_fat_boot_root_fat;\n    uint32_t root_sector_total_size_root_fat_boot_root_fat_boot_root_fat_boot;\n    uint32_t root_sector_total_size_root_fat_boot_root_fat_boot_root_fat_boot_root;\n    uint32_t root_sector_total_size_root_fat_boot_root_fat_boot_root_fat_boot_root", "CodeBleu_score": 9.970541253662653}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\n\t/* The size of the RAM disk in bytes. */\n\tuint32_t disk_size_bytes;\n\n\t/* The number of disk sectors required. */\n\tuint32_t disk_sectors;\n\n\t/* The number of bytes required for the file allocation table. */\n\tuint32_t fat_size_bytes;\n\n\t/* The number of bytes required for the boot sector. */\n\tuint32_t boot_sector_size_bytes;\n\n\t/* The number of bytes required for the root directory. */\n\tuint32_t root_directory_size_bytes;\n\n\t/* The number of bytes required for the data area. */\n\tuint32_t data_area_size_bytes;\n\n\t/* The number of bytes required for the root directory entry. */\n\tuint32_t root_directory_entry_size_bytes;\n\n\t/* The number of bytes required for the firmware file. */\n\tuint32_t firmware_file_size_bytes;\n\n\t/* The number of bytes required for the root directory entry. */\n\tuint32_t firmware_file_root_directory_entry_size_bytes;\n\n\t/* The number of bytes required for the root directory entry. */\n\tuint32_t firmware_file_root_directory_entry_size_bytes;\n\n\t/* The number of bytes required for the root directory entry. */\n\tuint32_t firmware_file_root_directory_entry_size_bytes;\n\n\t/* The number of bytes required for the root directory entry. */\n\tuint32_t firmware_file_root_directory_entry_size_bytes;\n\n\t/* The number of bytes required for the root directory entry. */\n\tuint32_t firmware_file_root_directory_entry_size_bytes;\n\n\t/* The number of bytes required for the root directory entry. */\n\tuint32_t firmware_file_root_directory_entry_size_bytes;\n\n\t/* The number of bytes required for the root directory entry. */\n\tuint32_t firmware_file_root_directory_entry_size_bytes;\n\n\t/* The number of bytes required for", "CodeBleu_score": 9.695059814055389}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    esp_err_t err;\n    uint32_t aligned_offset = offset & ~(SECTOR_SIZE - 1);\n    uint32_t aligned_size = size + (offset - aligned_offset);\n    uint32_t erase_size = aligned_size;\n    uint32_t write_size = size;\n    uint32_t write_offset = offset;\n\n    if (aligned_offset != offset) {\n        // If the offset is not aligned with the flash sector size, we need to erase the corresponding sector.\n        erase_size = SECTOR_SIZE;\n        write_size = aligned_size - SECTOR_SIZE;\n        write_offset = aligned_offset;\n    }\n\n    err = esp_partition_erase_range(partition, aligned_offset, erase_size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase flash sector\");\n        return err;\n    }\n\n    err = esp_partition_write(partition, write_offset, data, write_size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to flash\");\n        return err;\n    }\n\n    return ESP_OK;\n}\n", "CodeBleu_score": 53.577565291384076}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    esp_err_t err;\n    if (size == 0) {\n        return ESP_OK;\n    }\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"offset 0x%x is not aligned with 0x%x\", offset, SPI_FLASH_SEC_SIZE);\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (size % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"size 0x%x is not aligned with 0x%x\", size, SPI_FLASH_SEC_SIZE);\n        return ESP_ERR_INVALID_SIZE;\n    }\n    err = spi_flash_erase_range(offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to erase 0x%x bytes at 0x%x\", size, offset);\n        return err;\n    }\n    err = spi_flash_write(offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to write 0x%x bytes at 0x%x\", size, offset);\n        return err;\n    }\n    return ESP_OK;\n}\n", "CodeBleu_score": 46.93803789515004}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    uint32_t start_sector = offset / FLASH_SECTOR_SIZE;\n    uint32_t end_sector = (offset + size - 1) / FLASH_SECTOR_SIZE;\n    if (start_sector == end_sector) {\n        return esp_partition_write(partition, offset, data, size);\n    } else {\n        esp_err_t err = esp_partition_erase_range(partition, offset, FLASH_SECTOR_SIZE * (end_sector - start_sector));\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Erase operation failed with error %d\", err);\n            return err;\n        }\n        err = esp_partition_write(partition, offset, data, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Write operation failed with error %d\", err);\n        }\n        return err;\n    }\n}\n", "CodeBleu_score": 54.601165673638455}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i, j;\n\tfor (i = 0, j = 0; i < maxlen && *in; i++) {\n\t\tif (isxdigit((int)*in)) {\n\t\t\tout[j++] = (unsigned char)hex2byte(*in);\n\t\t}\n\t\tin++;\n\t}\n\treturn j;\n}\n", "CodeBleu_score": 29.243734798070616}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i, j, len = 0;\n\tfor (i = 0, j = 0; in[i] && len < maxlen; i++) {\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tout[j] = in[i] - '0';\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tout[j] = in[i] - 'a' + 10;\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tout[j] = in[i] - 'A' + 10;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (++i) {\n\t\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\t\tout[j] <<= 4;\n\t\t\t\tout[j] += in[i] - '0';\n\t\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\t\tout[j] <<= 4;\n\t\t\t\tout[j] += in[i] - 'a' + 10;\n\t\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\t\tout[j] <<= 4;\n\t\t\t\tout[j] += in[i] - 'A' + 10;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\treturn j;\n}\n", "CodeBleu_score": 38.126464948397}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i, j, len, outlen;\n\tunsigned char c;\n\tlen = strlen(in);\n\toutlen = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tc = in[i];\n\t\tif ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) {\n\t\t\tout[outlen] = (unsigned char)((c >= '0' && c <= '9') ? c - '0' : (c >= 'A' && c <= 'F') ? c - 'A' + 10 : c - 'a' + 10);\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tout[outlen] <<= 4;\n\t\t\t} else {\n\t\t\t\toutlen++;\n\t\t\t\tif (outlen == maxlen) {\n\t\t\t\t\treturn outlen;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn outlen;\n}\n", "CodeBleu_score": 35.62381137318265}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void)    if (txLock == NULL || txBuf == NULL) {\n        return 0;\n    }\n    if (xSemaphoreTake(txLock, txTimeout) == pdTRUE) {\n        int ret = txBuf->available();\n        xSemaphoreGive(txLock);\n        return ret;\n    }\n    return 0;\n}\n", "CodeBleu_score": 60.034463984317476}, {"code": "int HWCDC::availableForWrite(void)    if (tx_buffer == NULL) {\n        return 0;\n    }\n    if (tx_buffer->lock == NULL) {\n        return 0;\n    }\n    if (!xSemaphoreTake(tx_buffer->lock, tx_buffer->timeout)) {\n        return 0;\n    }\n    int free_size = tx_buffer->size - tx_buffer->count;\n    xSemaphoreGive(tx_buffer->lock);\n    return free_size;\n}\n", "CodeBleu_score": 45.46517712451922}, {"code": "int HWCDC::availableForWrite(void)  if (!initialized || !lock) return 0;\n  if (xSemaphoreTake(lock, portMAX_DELAY) != pdPASS) return 0;\n  int result = (int)txRingBuffer.free();\n  xSemaphoreGive(lock);\n  return result;\n}\n", "CodeBleu_score": 35.60898779706421}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)  // Lock the serial mutex\n  portENTER_CRITICAL(&_rxMutex);\n\n  // Assign the callback function\n  _onReceiveCB = function;\n\n  // Configure the receive timeout behavior\n  if (onlyOnTimeout) {\n    // Only call the callback function if the receive buffer is empty\n    _rxTimeout = true;\n  } else {\n    // Always call the callback function\n    _rxTimeout = false;\n  }\n\n  // If the callback is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n  if (function) {\n    // Set the FIFO full threshold\n    _serial->setRxFifoFullThreshold(SERIAL_RX_FIFO_FULL_THRESHOLD);\n\n    // Create an event task if it does not already exist\n    if (_eventTask == NULL) {\n      // Create the event task\n      _eventTask = xTaskCreate(eventTask, \"HardwareSerialEventTask\", SERIAL_EVENT_TASK_STACK_SIZE, this, SERIAL_EVENT_TASK_PRIORITY, &_eventTaskHandle);\n    }\n  } else {\n    // Disable the FIFO full threshold\n    _serial->setRxFifoFullThreshold(0);\n\n    // Delete the event task if it exists\n    if (_eventTask != NULL) {\n      // Delete the event task\n      vTaskDelete(_eventTaskHandle);\n\n      // Clear the event task\n      _eventTask = NULL;\n    }\n  }\n\n  // Unlock the serial mutex\n  portEXIT_CRITICAL(&_rxMutex);\n}\n", "CodeBleu_score": 47.22935024499214}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)  // Lock the serial mutex\n  xSemaphoreTake(rxMutex, portMAX_DELAY);\n\n  // Assign the provided callback function to \"_onReceiveCB\"\n  _onReceiveCB = function;\n\n  // Configure the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n  if (onlyOnTimeout) {\n    // If the onlyOnTimeout parameter is true, the receive timeout behavior is set to only call the callback function when the receive buffer is full\n    _rxTimeout = RX_TIMEOUT_ONLY;\n  } else if (_rxTimeout == RX_TIMEOUT_ONLY) {\n    // If the onlyOnTimeout parameter is false and the receive timeout behavior was set to only call the callback function when the receive buffer is full, the receive timeout behavior is set to call the callback function when the receive buffer is empty\n    _rxTimeout = RX_TIMEOUT_ALWAYS;\n  }\n\n  // If the callback is not NULL, it sets the FIFO full threshold and creates an event task if it does not already exist\n  if (_onReceiveCB != NULL) {\n    // Set the FIFO full threshold to 1\n    _rxFifo.setThreshold(1);\n\n    // If the receive event task does not already exist, create it\n    if (!rxTask) {\n      // Create the receive event task\n      rxTask = xTaskCreate(rxTaskFunc, \"rxTask\", 256, (void *)this, 1, NULL);\n\n      // If the receive event task was not created, set the FIFO full threshold to 0 and return\n      if (rxTask == NULL) {\n        _rxFifo.setThreshold(0);\n        return;\n      }\n    }\n  }\n\n  // Unlock the serial mutex\n  xSemaphoreGive(rxMutex);\n}\n", "CodeBleu_score": 50.176298653680654}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)  if (function == NULL) {\n    _onReceiveCB = NULL;\n    _rxTimeout = 0;\n  } else {\n    _onReceiveCB = function;\n    _rxTimeout = onlyOnTimeout ? 0 : _rxTimeout;\n  }\n\n  // If we're not using interrupts, we don't need to do anything\n  if (!_rx_buffer_is_interrupt_driven) {\n    return;\n  }\n\n  // If we have a callback, create the task if it doesn't already exist\n  if (_onReceiveCB != NULL && _onReceiveTask == NULL) {\n    _onReceiveTask = xTaskCreate(onReceiveTask, \"onReceiveTask\", configMINIMAL_STACK_SIZE, this, 1, &_onReceiveTaskHandle);\n  }\n\n  // If we have no callback, delete the task if it exists\n  if (_onReceiveCB == NULL && _onReceiveTask != NULL) {\n    vTaskDelete(_onReceiveTaskHandle);\n    _onReceiveTask = NULL;\n  }\n}\n", "CodeBleu_score": 47.990930727839235}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) {\n            break;\n        }\n        buffer[index++] = c;\n    }\n    return index;\n}\n", "CodeBleu_score": 70.47109529685338}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)  int index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[index++] = (char)c;\n    if (c == terminator) {\n      break;\n    }\n  }\n  return index;\n}\n", "CodeBleu_score": 67.05659879705341}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)    if (length < 1) {\n        return 0;\n    }\n\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) {\n            break;\n        }\n        buffer[index++] = c;\n    }\n\n    return index;\n}\n", "CodeBleu_score": 84.71201691041468}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  if (pin >= 0 && pin <= 13) {\n    if (tonePins[pin] == 0) {\n      tonePins[pin] = frequency;\n      toneDuration[pin] = duration;\n      toneStart[pin] = millis();\n      toneState[pin] = 1;\n      Serial.println(\"Tone command received: \" + String(pin) + \" \" + String(frequency) + \" \" + String(duration));\n      toneQueue.enqueue(pin);\n    }\n    else {\n      Serial.println(\"Error: pin \" + String(pin) + \" already in use. Stop the current tone on the pin first.\");\n    }\n  }\n  else {\n    Serial.println(\"Error: invalid pin number. Pin must be 0-13.\");\n  }\n}\n", "CodeBleu_score": 38.49287798622677}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  if (pin >= TONE_MAX_PIN) {\n    Serial.println(\"Error: Pin not available\");\n    return;\n  }\n  if (tone_pins[pin] != 0) {\n    Serial.println(\"Error: Pin already in use\");\n    return;\n  }\n  tone_pins[pin] = frequency;\n  tone_durations[pin] = duration;\n  tone_start_queue.enqueue(pin);\n}\n", "CodeBleu_score": 30.77921166481937}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  if (pin < 14) {\n    if (pins[pin] == 0) {\n      pins[pin] = 1;\n      tone_queue.enqueue(pin);\n      tone_queue.enqueue(frequency);\n      tone_queue.enqueue(duration);\n      tone_queue.enqueue(0);\n    } else {\n      Serial.println(\"Error: Pin is already in use.\");\n    }\n  } else {\n    Serial.println(\"Error: Pin is out of range.\");\n  }\n}\n", "CodeBleu_score": 32.55511224353897}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled)  if (!usbStarted) {\n    webUSBEnabled = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (usbVersion < 0x0210) {\n      return true;\n    }\n    usb.enableWebUSB(true);\n  } else {\n    usb.enableWebUSB(false);\n  }\n  return false;\n}\n", "CodeBleu_score": 43.27746345441419}, {"code": "bool ESPUSB::webUSB(bool enabled)  if (usbStarted) {\n    if (enabled) {\n      if (webUSBEnabled) {\n        return false;\n      }\n      webUSBEnabled = true;\n      if (usbVersion < 0x0210) {\n        usbVersion = 0x0210;\n      }\n    } else {\n      if (!webUSBEnabled) {\n        return false;\n      }\n      webUSBEnabled = false;\n    }\n  } else {\n    webUSBEnabled = enabled;\n    if (enabled) {\n      usbVersion = 0x0210;\n    }\n  }\n  return !usbStarted;\n}\n", "CodeBleu_score": 56.436561204168726}, {"code": "bool ESPUSB::webUSB(bool enabled)  if (enabled) {\n    if (!_usbStarted) {\n      if (_usbVersion < 0x0210) {\n        return true;\n      }\n      _webUSB = true;\n      return false;\n    }\n    return false;\n  }\n  if (_usbStarted) {\n    _webUSB = false;\n  }\n  return false;\n}\n", "CodeBleu_score": 35.85549478602577}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX()  // Read data\n  uint16_t rxBytes = _usb->read(rxBuffer, USB_CDC_RX_BUFFER_SIZE);\n  if (rxBytes == 0) return;\n\n  // Send data to receive queue\n  uint16_t droppedBytes = 0;\n  for (uint16_t i = 0; i < rxBytes; i++) {\n    if (!_rxQueue.push(rxBuffer[i])) {\n      droppedBytes++;\n      _log(LOG_ERROR, F(\"USB CDC: Receive queue overflow\"));\n    }\n  }\n\n  // Post receive event\n  if (droppedBytes == 0) {\n    _postEvent(USB_CDC_EVENT_RECEIVE, rxBytes);\n  } else {\n    _postEvent(USB_CDC_EVENT_RECEIVE_OVERFLOW, rxBytes, droppedBytes);\n  }\n}\n", "CodeBleu_score": 28.873716288137636}, {"code": "void USBCDC::_onRX()    uint8_t *buf = (uint8_t *)_rxBuf;\n    uint32_t len = _rxLen;\n    uint32_t i;\n    uint32_t dropped = 0;\n\n    // Send each byte to the receive queue\n    for (i = 0; i < len; i++) {\n        if (!_rxQueue.put(buf[i])) {\n            dropped++;\n        }\n    }\n\n    // Post overflow event if any bytes were dropped\n    if (dropped > 0) {\n        _overflowEvent.post(dropped);\n        _log->error(\"USBCDC\", \"RX overflow: %d bytes dropped\", dropped);\n    }\n\n    // Post receive event\n    _rxEvent.post(len);\n}\n", "CodeBleu_score": 21.774472664801163}, {"code": "void USBCDC::_onRX()  uint8_t rx;\n  uint16_t i = 0;\n  uint16_t dropped = 0;\n\n  while (rx_buffer.available()) {\n    if (rx_buffer.read(&rx, 1) == 1) {\n      if (!rx_queue.write(&rx, 1)) {\n        dropped++;\n        log_e(\"[USBCDC] RX overflow (%d dropped)\", dropped);\n      }\n      i++;\n    }\n  }\n\n  if (i) {\n    post(USBCDC::Event::Receive, i);\n  }\n\n  if (dropped) {\n    post(USBCDC::Event::Overflow, dropped);\n  }\n}\n", "CodeBleu_score": 20.275999504307187}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\ta.log.Errorf(\"Error getting robot: %s\", err)\n\t\thttp.Error(res, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif robot == nil {\n\t\ta.log.Errorf(\"No robot found with name %s\", robotName)\n\t\thttp.Error(res, \"No robot found with that name\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get devices associated with the robot\n\tdevices, err := a.db.GetDevices(robotName)\n\tif err != nil {\n\t\ta.log.Errorf(\"Error getting devices: %s\", err)\n\t\thttp.Error(res, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write JSON response\n\tif err := json.NewEncoder(res).Encode(devices); err != nil {\n\t\ta.log.Errorf(\"Error encoding devices: %s\", err)\n\t\thttp.Error(res, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 31.41174082436636}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the URL.\n\trobotName := req.URL.Query().Get(\"name\")\n\n\t// Check if the robot exists.\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err != nil {\n\t\ta.respondWithError(res, http.StatusNotFound, \"No robot found with that name\")\n\t\treturn\n\t}\n\n\t// Get the devices associated with the robot.\n\tdevices, err := a.db.GetDevicesByRobot(robot.ID)\n\tif err != nil {\n\t\ta.respondWithError(res, http.StatusInternalServerError, \"Error getting devices\")\n\t\treturn\n\t}\n\n\t// Convert the devices into a JSON format and write to the HTTP response writer.\n\tjson.NewEncoder(res).Encode(devices)\n}\n", "CodeBleu_score": 35.04423874892081}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the name of the robot from the URL\n\trobotName := mux.Vars(req)[\"name\"]\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\t// If the robot does not exist, return a JSON response with an error message\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, `{\"error\": \"No robot found with the specified name\"}`)\n\t\treturn\n\t}\n\t// If the robot exists, gather its devices into a JSON format\n\tdevices, err := a.db.GetRobotDevices(robotName)\n\tif err != nil {\n\t\t// If there is an error, return a JSON response with an error message\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(res, `{\"error\": \"Error gathering devices for the specified robot\"}`)\n\t\treturn\n\t}\n\t// Write the JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprint(res, `{\"devices\": [`)\n\tfor i, device := range devices {\n\t\tfmt.Fprint(res, `{\"name\": \"`+device.Name+`\", \"type\": \"`+device.Type+`\"}`)\n\t\tif i < len(devices)-1 {\n\t\t\tfmt.Fprint(res, `,`)\n\t\t}\n\t}\n\tfmt.Fprint(res, `]}`)\n}\n", "CodeBleu_score": 37.9278218775404}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Iterate through the connections of the robot\n\tconnections := make([]Connection, len(robot.Connections))\n\tfor i, connection := range robot.Connections {\n\t\tconnections[i] = connection\n\t}\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}\n", "CodeBleu_score": 37.95613894739177}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\tif err == db.ErrRobotNotFound {\n\t\t\thttp.Error(res, \"No robot with the specified name was found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(res, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tconnections := make([]connection, len(robot.Connections))\n\tfor i, conn := range robot.Connections {\n\t\tconnections[i] = connection{\n\t\t\tName:     conn.Name,\n\t\t\tProtocol: conn.Protocol,\n\t\t\tAddress:  conn.Address,\n\t\t\tPort:     conn.Port,\n\t\t}\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\terr = json.NewEncoder(res).Encode(connections)\n\tif err != nil {\n\t\thttp.Error(res, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 42.360265666286956}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\ta.log.Debugf(\"robotConnections: %s\", robotName)\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\ta.log.Errorf(\"robotConnections: %s\", err)\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif robot == nil {\n\t\ta.log.Errorf(\"robotConnections: %s\", err)\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := make([]*Connection, 0)\n\tfor _, connection := range robot.Connections {\n\t\tconnections = append(connections, connection)\n\t}\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\ta.log.Errorf(\"robotConnections: %s\", err)\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}\n", "CodeBleu_score": 42.03797434408777}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Get the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot and device names are not empty.\n\tif robotName == \"\" || deviceName == \"\" {\n\t\t// If the robot or device names are empty, write a JSON response with an error message.\n\t\ta.writeJSONError(res, req, \"The robot or device name is empty.\")\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tif !a.robotDeviceExists(robotName, deviceName) {\n\t\t// If the device does not exist, write a JSON response with an error message.\n\t\ta.writeJSONError(res, req, \"The device does not exist.\")\n\t\treturn\n\t}\n\n\t// Get the command name from the URL query parameters.\n\tcommandName := req.URL.Query().Get(\"command\")\n\n\t// Check if the command name is not empty.\n\tif commandName == \"\" {\n\t\t// If the command name is empty, write a JSON response with an error message.\n\t\ta.writeJSONError(res, req, \"The command name is empty.\")\n\t\treturn\n\t}\n\n\t// Get the command parameters from the URL query parameters.\n\tcommandParameters := req.URL.Query().Get(\"parameters\")\n\n\t// Check if the command parameters are not empty.\n\tif commandParameters == \"\" {\n\t\t// If the command parameters are empty, write a JSON response with an error message.\n\t\ta.writeJSONError(res, req, \"The command parameters are empty.\")\n\t\treturn\n\t}\n\n\t// Convert the command parameters to a JSON object.\n\tvar commandParametersJSON map[string]interface{}\n\terr := json.Unmarshal([]byte(commandParameters), &commandParametersJSON)\n\tif err != nil {\n\t\t// If an error occurs while converting the command parameters to a JSON object, write a JSON response with an error message.\n\t\ta.writeJSONError(res, req, \"The command parameters are not valid JSON.\")\n\t\treturn\n\t}\n\n\t// Get the command parameters", "CodeBleu_score": 47.65492314556522}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Get the robot name and device name from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot name is valid.\n\tif !a.isValidRobotName(robotName) {\n\t\ta.writeErrorResponse(res, http.StatusBadRequest, \"invalid robot name\")\n\t\treturn\n\t}\n\n\t// Check if the device name is valid.\n\tif !a.isValidDeviceName(deviceName) {\n\t\ta.writeErrorResponse(res, http.StatusBadRequest, \"invalid device name\")\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tif !a.isDeviceRegistered(robotName, deviceName) {\n\t\ta.writeErrorResponse(res, http.StatusNotFound, \"device not found\")\n\t\treturn\n\t}\n\n\t// Get the command name from the URL query parameters.\n\tcommandName := req.URL.Query().Get(\"command\")\n\n\t// Check if the command name is valid.\n\tif !a.isValidCommandName(commandName) {\n\t\ta.writeErrorResponse(res, http.StatusBadRequest, \"invalid command name\")\n\t\treturn\n\t}\n\n\t// Get the command parameters from the URL query parameters.\n\tcommandParameters := req.URL.Query().Get(\"parameters\")\n\n\t// Check if the command parameters are valid.\n\tif !a.isValidCommandParameters(commandParameters) {\n\t\ta.writeErrorResponse(res, http.StatusBadRequest, \"invalid command parameters\")\n\t\treturn\n\t}\n\n\t// Get the command parameters as a JSON object.\n\tvar commandParametersAsObject map[string]interface{}\n\terr := json.Unmarshal([]byte(commandParameters), &commandParametersAsObject)\n\tif err != nil {\n\t\ta.writeErrorResponse(res, http.StatusBadRequest, \"invalid command parameters\")\n\t\treturn\n\t}\n\n\t// Get the command parameters as a JSON array.\n\tvar commandParametersAsArray []interface{}\n\terr = json.Unmarshal([]byte(commandParameters), &", "CodeBleu_score": 47.78320885418681}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Get the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\t// Check if the device exists.\n\tdevice, err := a.getDevice(robotName, deviceName)\n\tif err != nil {\n\t\t// If the device does not exist, write the error message as a JSON response.\n\t\tlog.Println(err)\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device.\n\tswitch command {\n\tcase \"forward\":\n\t\tdevice.Forward()\n\tcase \"backward\":\n\t\tdevice.Backward()\n\tcase \"left\":\n\t\tdevice.Left()\n\tcase \"right\":\n\t\tdevice.Right()\n\tcase \"stop\":\n\t\tdevice.Stop()\n\t}\n\n\t// Write the response as a JSON object.\n\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(map[string]interface{}{\"message\": \"command executed\"})\n}\n", "CodeBleu_score": 48.585373216236064}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif username != pair[0] || password != pair[1] {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 49.459538417212435}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif username != pair[0] || password != pair[1] {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// authentication succeeded\n\t}\n}\n", "CodeBleu_score": 49.317479999416555}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Authentication succeeded\n\t\tr.Header.Del(\"Authorization\")\n\t}\n}\n", "CodeBleu_score": 53.99786440524543}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\tif a.analogSensor == nil {\n\t\treturn 0, 0, ErrNotSupported\n\t}\n\n\ta.analogSensor.Lock()\n\tdefer a.analogSensor.Unlock()\n\n\tif a.analogSensor.analogRead == nil {\n\t\treturn 0, 0, ErrNotSupported\n\t}\n\n\traw, err := a.analogSensor.analogRead()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.analogSensor.scaleFactor\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 45.59777482187878}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the sensor for reading.\n\tif err := a.lock(); err != nil {\n\t\treturn 0, 0, err\n\t}\n\tdefer a.unlock()\n\n\t// Check if the connection supports analog reading.\n\tif !a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, ErrAnalogReadingNotSupported\n\t}\n\n\t// Retrieve the raw sensor value.\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration.\n\tvar scaledValue float64\n\tswitch a.configuration.Scale {\n\tcase AnalogScaleLinear:\n\t\tscaledValue = float64(rawValue) * a.configuration.ScaleFactor\n\tcase AnalogScaleLogarithmic:\n\t\tscaledValue = math.Pow(10, float64(rawValue)*a.configuration.ScaleFactor)\n\tdefault:\n\t\treturn 0, 0, ErrInvalidAnalogScale\n\t}\n\n\t// Update the last read values.\n\ta.lastReadRawValue = rawValue\n\ta.lastReadScaledValue = scaledValue\n\n\t// Return the raw and scaled values.\n\treturn rawValue, scaledValue, nil\n}\n", "CodeBleu_score": 49.34598373469902}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the sensor for reading.\n\tif err := a.lock(); err != nil {\n\t\treturn 0, 0, err\n\t}\n\tdefer a.unlock()\n\n\t// Check if the connection supports analog reading.\n\tif a.connection.AnalogReading() == false {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\t// Retrieve the raw sensor value.\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration.\n\tvar scaledValue float64\n\tswitch a.scale {\n\tcase AnalogScaleLinear:\n\t\tscaledValue = float64(rawValue) * a.scaleFactor\n\tcase AnalogScaleLogarithmic:\n\t\tscaledValue = math.Pow(10, float64(rawValue)*a.scaleFactor)\n\t}\n\n\t// Update the last read values.\n\ta.lastReadRaw = rawValue\n\ta.lastReadScaled = scaledValue\n\n\t// Return the raw and scaled values.\n\treturn rawValue, scaledValue, nil\n}\n", "CodeBleu_score": 51.037281938514056}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tdrv := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:              \"GroveSoundSensorDriver\",\n\t}\n\treturn drv\n}\n", "CodeBleu_score": 41.2080497602394}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tif len(opts) == 0 {\n\t\treturn &GroveSoundSensorDriver{\n\t\t\tname:       defaultName,\n\t\t\tanalogRead: a,\n\t\t\tpin:        pin,\n\t\t}\n\t}\n\treturn &GroveSoundSensorDriver{\n\t\tname:       opts[0].(string),\n\t\tanalogRead: a,\n\t\tpin:        pin,\n\t}\n}\n", "CodeBleu_score": 27.95786568366915}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: *NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               DefaultGroveSoundSensorName,\n\t}\n\td.SensorDriver = *NewSensorDriver(d, DefaultGroveSoundSensorName)\n\treturn d\n}\n", "CodeBleu_score": 42.561374166750575}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error\t// Write the soft reset command to the command register\n\td.writeCommand(softResetCommand)\n\n\t// Wait for the command to complete\n\ttime.Sleep(softResetDelay)\n\n\t// Check the status of the command register\n\tstatus := d.readRegister(commandReg)\n\tif status&0x08 != 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 24.939648535268315}, {"code": "func (d *MFRC522Common) softReset() error\td.command(cmdSoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tif d.command(cmdGetCommandReg) != cmdSoftReset {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 24.814027138609134}, {"code": "func (d *MFRC522Common) softReset() error\t// Write the soft reset command to the command register.\n\td.writeRegister(CommandReg, SoftReset)\n\n\t// Wait for the command to complete.\n\ttime.Sleep(10 * time.Microsecond)\n\n\t// Check if the command is still active.\n\tif d.readRegister(CommandReg) != 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 27.035848239566047}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Read the FIFO level\n\tfifoLevel, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check for overflow\n\tif fifoLevel > 0x3F {\n\t\treturn 0, fmt.Errorf(\"fifo overflow\")\n\t}\n\n\t// Check for underflow\n\tif fifoLevel < len(backData) {\n\t\treturn 0, fmt.Errorf(\"fifo underflow\")\n\t}\n\n\t// Read the FIFO buffer\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\treturn d.readRegister(ControlReg)\n}\n", "CodeBleu_score": 45.60480672662684}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Check buffer size\n\tvar status uint8\n\tstatus = d.readRegister(regFIFOLevel)\n\tif status&0x80 == 0 {\n\t\treturn status, errors.New(\"readFifo: FIFO buffer is empty\")\n\t}\n\tif status&0x7F < uint8(len(backData)) {\n\t\treturn status, errors.New(\"readFifo: FIFO buffer has less elements than expected\")\n\t}\n\n\t// Read data\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readRegister(regFIFOData)\n\t}\n\n\t// Return last bits\n\tstatus = d.readRegister(regFIFOLevel)\n\treturn status, nil\n}\n", "CodeBleu_score": 33.825955275028484}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Check buffer size\n\tvar status uint8\n\tvar size uint8\n\tvar lastBits uint8\n\n\tstatus, size, lastBits = d.readRegister(d.FIFODataReg)\n\tif size > uint8(len(backData)) {\n\t\treturn status, errors.New(\"FIFO buffer overrun\")\n\t}\n\n\t// Read data\n\tfor i := 0; i < int(size); i++ {\n\t\tbackData[i] = d.readRegister(d.FIFODataReg)\n\t}\n\n\treturn status, nil\n}\n", "CodeBleu_score": 26.923545414415152}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error\t// Log a debug message if debugging is enabled.\n\tif d.debug {\n\t\tfmt.Println(\"Halting communication with PICC.\")\n\t}\n\n\t// Create a halt command.\n\tcommand := []byte{piccHalt}\n\n\t// Calculate the CRC_A for the command.\n\tcrc := d.calculateCRC(command)\n\n\t// Append the CRC to the command.\n\tcommand = append(command, crc)\n\n\t// Send the command.\n\tresponse, err := d.transceive(command)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check the response.\n\tif !bytes.Equal(response, []byte{piccError}) {\n\t\treturn errors.New(\"Error in communication.\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 38.80315446831752}, {"code": "func (d *MFRC522Common) piccHalt() error\tif d.debug {\n\t\td.logf(\"piccHalt()\")\n\t}\n\n\t// Build command\n\tcommand := []byte{piccHalt}\n\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(command)\n\n\t// Store CRC_A in array\n\tcommand = append(command, crc)\n\n\t// Send the command\n\tresponse, err := d.transceive(command)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check response\n\tif bytes.Compare(response, []byte{piccError}) != 0 {\n\t\treturn fmt.Errorf(\"expected %v, got %v\", piccError, response)\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 35.89464411232307}, {"code": "func (d *MFRC522Common) piccHalt() error\tif d.debug {\n\t\td.debugLog.Print(\"Halting communication with PICC\")\n\t}\n\n\t// Build command\n\tcommand := []byte{piccHalt}\n\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(command)\n\n\t// Store CRC_A in command\n\tcommand = append(command, crc)\n\n\t// Send command and expect error\n\terr := d.sendCommand(command)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 30.10444447948085}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\t// Sanity check\n\tif block > 15 {\n\t\treturn nil, fmt.Errorf(\"block out of range\")\n\t}\n\n\t// Build command buffer\n\t//\t7\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "CodeBleu_score": 6.600497240263224}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tvar err error\n\t// Sanity check\n\tif block > 15 {\n\t\treturn nil, errors.New(\"block must be 0-15\")\n\t}\n\n\t// Build command\n\tcmd := []byte{piccRead, block}\n\t// Calculate CRC_A\n\tcrc := crc.New(crc.CRC16, []byte{0x63, 0x63})\n\tcrc.Write(cmd)\n\tcmd = append(cmd, crc.Sum(nil)...)\n\n\t// Send command\n\td.ClearBitMask(status2Reg, 0x08) // Clear the FIFO_RDY flag\n\terr = d.setCommand(cmdPCD_TRANSCEIVE, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Wait for response\n\tn, _ := d.WaitForResponse(0x00, 0x00)\n\tif n != 0 {\n\t\treturn nil, errors.New(\"response length is not 0\")\n\t}\n\n\t// Read block\n\tdata := make([]byte, 16)\n\tn, _ = d.WaitForResponse(0x00, 0xFF)\n\tif n != 16 {\n\t\treturn nil, errors.New(\"response length is not 16\")\n\t}\n\tfor i := 0; i < 16; i++ {\n\t\tdata[i] = d.ReadReg(fifoDataReg)\n\t}\n\n\t// Clear bit mask\n\td.ClearBitMask(status2Reg, 0x08) // Clear the FIFO_RDY flag\n\n\treturn data, nil\n}\n", "CodeBleu_score": 46.20480091567861}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\t// Build command\n\tcmd := []byte{MF522_READ}\n\tcmd = append(cmd, block)\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\t// Transmit the READ command\n\tstatus, _ := d.transceive(cmd, nil, false)\n\tif status != MI_OK {\n\t\treturn nil, fmt.Errorf(\"Failed to read block %d\", block)\n\t}\n\t// Read the returned data\n\tdata := make([]byte, 18)\n\t_, err := d.reader.Read(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Verify CRC_A\n\tcrc = d.calculateCRC(data[0 : 16])\n\tif data[16] != crc[0] || data[17] != crc[1] {\n\t\treturn nil, fmt.Errorf(\"CRC_A failed\")\n\t}\n\t// Copy block data\n\tresult := make([]byte, 16)\n\tcopy(result, data[1:17])\n\treturn result, nil\n}\n", "CodeBleu_score": 46.35330077153406}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn ErrAnswerTooShort\n\t}\n\t// Clear the answer buffer by using the clearCommandBuffer function\n\td.clearCommandBuffer()\n\t// Copy the data to send into the command buffer\n\td.commandBuffer[0] = reqMode\n\t// Calculate CRC_A\n\td.calculateCRC(d.commandBuffer[:1], d.commandBuffer[2:4])\n\t// Transmit the command and receive the response, validate CRC_A\n\tif err := d.transceive(d.commandBuffer[:4], answer[:2], true); err != nil {\n\t\treturn err\n\t}\n\t// Check response header\n\tif answer[0] != reqMode {\n\t\treturn ErrResponseHeaderMismatch\n\t}\n\t// Copy the response into the answer buffer\n\tcopy(answer, answer[2:])\n\t// Set bit adjustments\n\tif reqMode == reqA {\n\t\t// Values after collPos in the answer is undefined, so let's clear the whole buffer\n\t\td.clearCommandBuffer()\n\t\t// Copy only the 7 bit UID bytes into the answer buffer\n\t\tcopy(answer, answer[:7])\n\t\t// PICC only returns 4 bytes\n\t\treturn nil\n\t}\n\tif reqMode == reqB {\n\t\t// Copy only the 7 bit UID bytes into the answer buffer\n\t\tcopy(answer, answer[:7])\n\t\t// PICC only returns 4 bytes\n\t\treturn nil\n\t}\n\tif reqMode == reqF {\n\t\t// PICC returns 16 bytes\n\t\treturn nil\n\t}\n\t// PICC returns 4 bytes\n\treturn nil\n}\n", "CodeBleu_score": 43.552775245187}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\td.clearBitMask(d.regColl, 0x80) // Clear the collision bit\n\td.clearBitMask(d.regRxSel, 0x80) // Clear the buffer overflow bit\n\td.write(d.regTxMode, 0x40|reqMode)\n\td.setBitMask(d.regTxMode, 0x80) // Request mode\n\td.write(d.regCommIEn, 0x80)     // Interrupt request\n\td.write(d.regCommIrq, 0x7F)     // Clear all seven interrupt request bits\n\td.write(d.regCommIEn, 0x86)     // Interrupt request enabled\n\td.write(d.regRFCfg, 0x0F)       // RF configuration\n\td.write(d.regTMode, 0x8D)       // Timer mode\n\td.write(d.regTPrescaler, 0x3E)  // Timer prescaler\n\td.write(d.regTReloadL, 0x3D)    // Timer reload value\n\td.write(d.regTReloadH, 0x03)    //\n\td.write(d.regTxASKL, 0x40)      // Transmitter auto retransmission\n\td.write(d.regTxASKH, 0x00)      //\n\td.write(d.regMode, 0x3D)        // Mode normal\n\td.write(d.regCommIEn, 0x86)     // Interrupt request enabled\n\td.write(d.regDivlEn, 0x4F)      //\n\td.write(d.regColl, 0x00)        // Collision window\n\td.write(d.regRxSel, 0x86)       // Select the valid bits of the last received data in the data buffer\n\td.write(d.regSel, 0", "CodeBleu_score": 25.865054803030706}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn ErrBufferTooSmall\n\t}\n\n\t// Clear the answer buffer by setting the length to 0.\n\td.clearAnswerBuffer()\n\n\t// Clear the bits in the collision register.\n\td.clearCollReg()\n\n\t// Set the request mode in the FIFO.\n\td.setFIFO(reqMode)\n\n\t// If we are in the state of Idle, we can now execute the command.\n\tif d.state == StateIdle {\n\t\t// Tell the MFRC522 to start the command.\n\t\td.writeReg(RegCommandReg, cmdPCDRequest)\n\n\t\t// Wait for the command to complete.\n\t\terr := d.wait(d.cmdReg(cmdPCDRequest), 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// If we are in the state of Idle, we can now execute the command.\n\tif d.state == StateIdle {\n\t\t// Tell the MFRC522 to start the command.\n\t\td.writeReg(RegCommandReg, cmdPCDAnticoll)\n\n\t\t// Wait for the command to complete.\n\t\terr := d.wait(d.cmdReg(cmdPCDAnticoll), 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Copy the content of the FIFO into the buffer array.\n\td.getFIFO(answer)\n\n\t// Return the error code from the collision register.\n\treturn d.errReg()\n}\n", "CodeBleu_score": 52.41672798226106}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == nil {\n\t\treturn errors.New(\"step pin not set\")\n\t}\n\n\tif d.directionPin == nil {\n\t\treturn errors.New(\"direction pin not set\")\n\t}\n\n\tif d.enablePin == nil {\n\t\treturn errors.New(\"enable pin not set\")\n\t}\n\n\tif d.stepDelay == 0 {\n\t\treturn errors.New(\"step delay not set\")\n\t}\n\n\tif d.stepNumber == 0 {\n\t\treturn errors.New(\"step number not set\")\n\t}\n\n\tif d.stepDirection == 0 {\n\t\treturn errors.New(\"step direction not set\")\n\t}\n\n\tif d.stepDirection == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\tif d.stepNumber == d.stepLimit {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber < 0 {\n\t\td.stepNumber = d.stepLimit - 1\n\t}\n\n\terr := d.stepPin.DigitalWrite(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.enablePin.DigitalWrite(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Duration(d.stepDelay) * time.Millisecond)\n\n\terr = d.stepPin.DigitalWrite(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.enablePin.DigitalWrite(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 48.398304162754116}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif d.stepPin != nil {\n\t\td.stepPin.Low()\n\t\ttime.Sleep(d.delay)\n\t\td.stepPin.High()\n\t\tif d.direction == 1 {\n\t\t\td.stepNumber++\n\t\t} else {\n\t\t\td.stepNumber--\n\t\t}\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 35.10389457780432}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low\n\tif err := d.stepPin.Clear(); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the delay\n\ttime.Sleep(d.delay)\n\n\t// Set the step pin high\n\tif err := d.stepPin.Set(); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 62.20535965525177}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor <- true\n\td.stopDistanceMonitor = make(chan bool)\n\td.distanceMonitorRunning = true\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitor:\n\t\t\t\td.distanceMonitorRunning = false\n\t\t\t\td.wg.Done()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %v\\n\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distance = distance\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.measurementInterval)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n", "CodeBleu_score": 40.69092408252224}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.distanceMonitorRunning = true\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitorWg = new(sync.WaitGroup)\n\td.distanceMonitorWg.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}\n", "CodeBleu_score": 30.7810710950545}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitor != nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.stopDistanceMonitor = make(chan struct{})\n\td.wg.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}\n", "CodeBleu_score": 26.49746452691965}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar startTime time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestampExt uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else {\n\t\t\tif startTime.IsZero() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\td.ch <- time.Since(startTime)\n\t\t\tstartTime = time.Time{}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.26254832703168}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar startTime time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestampMicros uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else {\n\t\t\td.publish(d.Pin, startTime.Sub(time.Now()).Seconds()*1000)\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.06085024534226}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar start time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestamp32 uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else {\n\t\t\td.ch <- time.Since(start).Microseconds()\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.12008348423945}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\t// Trigger the sensor.\n\td.gpio.Out(gpio.High)\n\ttime.Sleep(10 * time.Microsecond)\n\td.gpio.Out(gpio.Low)\n\t// Wait for the sensor to finish the measurement.\n\ttimeout := time.After(100 * time.Millisecond)\n\tstart := time.Now()\n\tfor {\n\t\tif d.gpio.Read() == gpio.High {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(start) > timeout {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t}\n\t// Wait for the sensor to finish the measurement.\n\ttimeout = time.After(100 * time.Millisecond)\n\tstart = time.Now()\n\tfor {\n\t\tif d.gpio.Read() == gpio.Low {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(start) > timeout {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t}\n\t// Get the measured time in microseconds.\n\tduration := time.Since(start)\n\t// Calculate the distance in centimeters.\n\td.distance = duration.Microseconds() / 29. / 2.\n\treturn nil\n}\n", "CodeBleu_score": 48.40408429314961}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\td.gpioTrigger.Out(gpio.High)\n\ttime.Sleep(20 * time.Microsecond)\n\td.gpioTrigger.Out(gpio.Low)\n\n\t// Wait for the sensor to measure the distance\n\ttimeout := time.After(time.Second)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout\")\n\t\tdefault:\n\t\t\tif d.gpioEcho.Read() == gpio.Low {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ttime.Sleep(10 * time.Microsecond)\n\t\t}\n\t}\n\n\t// Wait for the sensor to finish measuring the distance\n\ttimeout = time.After(time.Second)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout\")\n\t\tdefault:\n\t\t\tif d.gpioEcho.Read() == gpio.High {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ttime.Sleep(10 * time.Microsecond)\n\t\t}\n\t}\n\n\t// Measure the time it took the sensor to measure the distance\n\tstart := time.Now()\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout\")\n\t\tdefault:\n\t\t\tif d.gpioEcho.Read() == gpio.Low {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ttime.Sleep(10 * time.Microsecond)\n\t\t}\n\t}\n\tduration := time.Since(start)\n\n\t// Calculate the distance\n\tdistance := float64(duration.Microseconds()) / 58.0\n\n\t// Store the measured distance\n\td.distance = distance\n\n\treturn nil\n}\n", "CodeBleu_score": 47.55214112422515}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\td.triggerPin.Out(gpio.High)\n\ttime.Sleep(time.Microsecond)\n\td.triggerPin.Out(gpio.Low)\n\n\t// Wait for the sensor to measure\n\tstart := time.Now()\n\tfor {\n\t\tif time.Since(start) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout\")\n\t\t}\n\n\t\tif d.echoPin.Read() == gpio.Low {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Wait for the sensor to stop measuring\n\tstart = time.Now()\n\tfor {\n\t\tif time.Since(start) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout\")\n\t\t}\n\n\t\tif d.echoPin.Read() == gpio.High {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Store the measured time in microseconds\n\td.measurement = time.Since(start)\n\n\treturn nil\n}\n", "CodeBleu_score": 50.28815337593954}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n    try:\n        if self.authentication_token:\n            return self.authentication_token\n        else:\n            if self.refresh_token and self.expiration_time and datetime.datetime.now() < self.expiration_time:\n                self.authentication_token = self.fetch_new_authentication_token()\n                return self.authentication_token\n            else:\n                raise AccountNotAuthorized(self.user_id)\n    except Exception as e:\n        raise AccountNotAuthorized(self.user_id)\n\n", "CodeBleu_score": 17.707779136509096}, {"code": "def fetch_authentication_token(self)\n    try:\n        if self.access_token:\n            return self.access_token\n        elif self.refresh_token:\n            return self.refresh_token\n        elif self.access_token_expiry:\n            if self.access_token_expiry < datetime.now():\n                self.refresh_access_token()\n                return self.access_token\n            else:\n                return self.access_token\n        else:\n            raise AccountNotAuthorized(\"Access token not found.\")\n    except AttributeError:\n        raise AccountNotAuthorized(\"Access token not found.\")\n", "CodeBleu_score": 23.286184167102007}, {"code": "def fetch_authentication_token(self)\n    try:\n        token = os.environ['AUTHENTICATION_TOKEN']\n    except KeyError:\n        try:\n            token = self.state.get('authentication_token')\n            expiration_time = self.state.get('authentication_token_expiration_time')\n            if expiration_time and expiration_time > time.time():\n                return token\n        except KeyError:\n            pass\n        try:\n            refresh_token = self.state.get('authentication_refresh_token')\n            if not refresh_token:\n                raise AccountNotAuthorized('No authentication token or refresh token available.')\n            response = requests.post('https://accounts.spotify.com/api/token', data={'grant_type': 'refresh_token', 'refresh_token': refresh_token})\n            response.raise_for_status()\n            data = response.json()\n            self.state['authentication_token'] = data['access_token']\n            self.state['authentication_token_expiration_time'] = time.time() + data['expires_in']\n            return data['access_token']\n        except KeyError:\n            raise AccountNotAuthorized('No authentication token or refresh token available.')\n", "CodeBleu_score": 39.08748947627216}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n    try:\n        self.refresh_token = self.get_refresh_token()\n        self.session.cookies.clear()\n        self.session.post(self.base_url + \"/v1/logout\", data={\"refresh_token\": self.refresh_token})\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 47.119011295584045}, {"code": "def logout(self)\n    self.refresh_token = self.session.cookies.get(\"refresh_token\")\n    self.session.cookies.clear()\n    try:\n        self.session.post(\"/v1/logout\", data={\"refresh_token\": self.refresh_token})\n    except AccountError:\n        pass\n    return True\n", "CodeBleu_score": 49.281572305393354}, {"code": "def logout(self)\n    try:\n        refresh_token = self.session.cookies.get_dict()[\"refresh_token\"]\n        self.session.cookies.clear()\n        response = self.session.post(\n            self.base_url + \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer \" + refresh_token},\n        )\n        if response.status_code != 200:\n            raise AccountError(response.text, response.status_code)\n        return True\n    except AccountError as error:\n        raise error\n    except Exception as error:\n        raise AccountError(str(error), 500)\n\n", "CodeBleu_score": 37.870053405955964}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n    used_packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        used_packages.append(\n            {\n                \"name\": package.name,\n                \"version\": package.version,\n                \"source\": package.source,\n            }\n        )\n    return used_packages\n\n", "CodeBleu_score": 22.645725469062654}, {"code": "def dump_used_packages(self)\n    used_packages = []\n    for package in self.packages:\n        if package.is_optional:\n            continue\n        package_info = {\n            \"name\": package.name,\n            \"version\": package.version,\n            \"source\": package.source\n        }\n        used_packages.append(package_info)\n    return used_packages\n\n", "CodeBleu_score": 27.088277027268603}, {"code": "def dump_used_packages(self)\n    packages = self.get_used_packages()\n    result = []\n    for package in packages:\n        if package.is_optional():\n            continue\n        result.append({\n            \"name\": package.name,\n            \"version\": package.version,\n            \"url\": package.source_url,\n        })\n    return result\n", "CodeBleu_score": 21.497562174664825}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    pass\n\n", "CodeBleu_score": 5.2564102564107245}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    return cls._from_env(env, targets, autoinstall)\n\n", "CodeBleu_score": 7.3829732927470415}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    \n    if not env:\n        raise ValueError(\"No environment specified\")\n    \n    platform = cls.platforms.get(env)\n    if not platform:\n        raise UndefinedEnvPlatformError(\"Environment '{}' is not defined in the project configuration\".format(env))\n    \n    instance = cls(platform, autoinstall)\n    instance.set_env(env)\n    \n    if targets:\n        instance.configure(targets)\n    \n    return instance\n\n", "CodeBleu_score": 33.51208387197343}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)\tuint8_t i;\n\tuint8_t Data;\n\tuint8_t Ack;\n\n\tWire.beginTransmission(AXP192_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\n\tWire.requestFrom(AXP192_ADDR, Size);\n\tfor (i = 0; i < Size; i++) {\n\t\tif (i == (Size - 1)) {\n\t\t\tAck = 1;\n\t\t} else {\n\t\t\tAck = 0;\n\t\t}\n\t\tData = Wire.read();\n\t\tBuff[i] = Data;\n\t}\n}\n", "CodeBleu_score": 55.82912452922475}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)    Wire.beginTransmission(AXP192_ADDRESS);\n    Wire.write(Addr);\n    Wire.endTransmission();\n    Wire.requestFrom(AXP192_ADDRESS, Size);\n    for (uint8_t i = 0; i < Size; i++) {\n        Buff[i] = Wire.read();\n    }\n}\n", "CodeBleu_score": 64.56394305243852}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(AXP192_ADDR);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(AXP192_ADDR, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}\n", "CodeBleu_score": 63.060587817801704}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us)  if (time_in_us != 0) {\n    SetSleep();\n    EnableTimerWakeup(time_in_us);\n  } else {\n    SetSleep();\n  }\n  if (time_in_us == 0) {\n    DisableTimerWakeup();\n  }\n  if (time_in_us != 0) {\n    //Serial.println(\"DeepSleep with timer\");\n    ESP.deepSleep(time_in_us);\n  } else {\n    //Serial.println(\"DeepSleep\");\n    ESP.deepSleep(0);\n  }\n}\n", "CodeBleu_score": 59.7711403934431}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)    if (time_in_us > 0) {\n        SetSleep();\n        EnableTimerWakeup(time_in_us);\n    } else {\n        SetSleep();\n        DisableTimerWakeup();\n    }\n    if (time_in_us == 0) {\n        _power_off_timer = 0;\n        _power_off_timer_en = 0;\n    } else {\n        _power_off_timer = time_in_us;\n        _power_off_timer_en = 1;\n    }\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;\n    _power_off_timer_start = 1;\n    _power_off_timer_end = 1;\n    _power_off_timer_en = 1;", "CodeBleu_score": 53.339880252756224}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)  SetSleep();\n  if (time_in_us > 0) {\n    EnableTimerWakeup(time_in_us);\n  } else {\n    DisableTimerWakeup();\n  }\n  if (time_in_us == 0) {\n    DeepSleep();\n  } else {\n    DeepSleep(time_in_us);\n  }\n}\n", "CodeBleu_score": 57.080299887452504}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)  int y_prev = y_start;\n  int y_curr = y_start;\n  int y_next = y_start;\n  int x_next = 0;\n  int x_prev = 0;\n  int x_curr = 0;\n  int height = tft.fontHeight();\n\n  if (y_start >= (height * 2) && y_start <= (height * 3)) {\n    y_prev = (height * 2);\n    y_curr = (height * 3);\n    y_next = (height * 4);\n    x_prev = 0;\n    x_curr = 0;\n    x_next = 0;\n  } else if (y_start >= (height * 3) && y_start <= (height * 4)) {\n    y_prev = (height * 3);\n    y_curr = (height * 4);\n    y_next = (height * 5);\n    x_prev = 0;\n    x_curr = 0;\n    x_next = 0;\n  } else if (y_start >= (height * 4) && y_start <= (height * 5)) {\n    y_prev = (height * 4);\n    y_curr = (height * 5);\n    y_next = (height * 6);\n    x_prev = 0;\n    x_curr = 0;\n    x_next = 0;\n  } else if (y_start >= (height * 5) && y_start <= (height * 6)) {\n    y_prev = (height * 5);\n    y_curr = (height * 6);\n    y_next = (height * 7);\n    x_prev = 0;\n    x_curr = 0;\n    x_next = 0;\n  } else if (y_start >= (height * 6) && y_start <= (height * 7)) {\n    y_prev = (height * 6);\n    y_curr = (height * 7);\n    y_next = (height * 8);\n    x_prev = 0;\n    x", "CodeBleu_score": 23.920611796747686}, {"code": "int Display::scroll_line(uint32_t color)\tint ret = 0;\n\tif (scroll_y < (HEIGHT - FIXED_BOTTOM)) {\n\t\t// Normal scrolling\n\t\tret = scroll_y;\n\t\tfillRect(0, scroll_y, WIDTH, FIXED_BOTTOM, color);\n\t\tscroll_y += TEXT_HEIGHT;\n\t\tif (scroll_y >= (HEIGHT - FIXED_BOTTOM)) {\n\t\t\tscroll_y = 0;\n\t\t}\n\t} else {\n\t\t// Scroll to top\n\t\tret = scroll_y;\n\t\tfillRect(0, 0, WIDTH, FIXED_BOTTOM, color);\n\t\tscroll_y = 0;\n\t}\n\tsetScroll(scroll_y);\n\treturn ret;\n}\n", "CodeBleu_score": 27.13613372950779}, {"code": "int Display::scroll_line(uint32_t color)  int y = _y;\n  _y = _y + _font_height;\n  if (_y > _height - _bottom_fixed_area) {\n    _y = _top_fixed_area;\n  }\n  fillRect(_x, y, _width, _font_height, color);\n  return y;\n}\n", "CodeBleu_score": 16.390536987385396}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if (!ssids) {\n    Serial.println(\"EvilPortal::begin: ssids is NULL.\");\n    return false;\n  }\n  if (!access_points) {\n    Serial.println(\"EvilPortal::begin: access_points is NULL.\");\n    return false;\n  }\n  if (ssids->getSize() == 0) {\n    Serial.println(\"EvilPortal::begin: ssids is empty.\");\n    return false;\n  }\n  if (access_points->getSize() == 0) {\n    Serial.println(\"EvilPortal::begin: access_points is empty.\");\n    return false;\n  }\n\n  ssid_list = ssids;\n  access_point_list = access_points;\n\n  // Set up access points\n  if (!setAccessPoints()) {\n    Serial.println(\"EvilPortal::begin: Failed to set up access points.\");\n    return false;\n  }\n\n  // Set up HTML content\n  if (!setHTML()) {\n    Serial.println(\"EvilPortal::begin: Failed to set up HTML content.\");\n    return false;\n  }\n\n  // Start portal\n  if (!startPortal()) {\n    Serial.println(\"EvilPortal::begin: Failed to start portal.\");\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 45.36419776179337}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if (ssids == NULL || access_points == NULL) {\n    return false;\n  }\n  _ssids = ssids;\n  _access_points = access_points;\n  return begin();\n}\n", "CodeBleu_score": 50.47776260136172}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)    if (ssids == NULL || access_points == NULL) {\n        return false;\n    }\n    if (!_setup_access_points(access_points)) {\n        return false;\n    }\n    if (!_setup_html(ssids)) {\n        return false;\n    }\n    if (!_setup_portal()) {\n        return false;\n    }\n    return true;\n}\n", "CodeBleu_score": 51.38060187478509}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\tif (queue_ptr == NULL) {\n\t\t\tqueue_ptr = new Queue(queue_size);\n\t\t\ttext_ptr = new Text(queue_size);\n\t\t\ttext_in_ptr = new Text(queue_size);\n\t\t}\n\t} else {\n\t\tqueue_enabled_flag = true;\n\t\tif (queue_ptr != NULL) {\n\t\t\tdelete queue_ptr;\n\t\t\tqueue_ptr = NULL;\n\t\t}\n\t\tif (text_ptr != NULL) {\n\t\t\tdelete text_ptr;\n\t\t\ttext_ptr = NULL;\n\t\t}\n\t\tif (text_in_ptr != NULL) {\n\t\t\tdelete text_in_ptr;\n\t\t\ttext_in_ptr = NULL;\n\t\t}\n\t\tqueue_ptr = new Queue(queue_size);\n\t\ttext_ptr = new Text(queue_size);\n\t\ttext_in_ptr = new Text(queue_size);\n\t}\n}\n", "CodeBleu_score": 8.157413224267831}, {"code": "void GpsInterface::enable_queue()    if (queue_enabled_flag) {\n        if (!queue) {\n            queue = new Queue(200, sizeof(GpsData));\n            text = new Text(200, sizeof(GpsData));\n            text_in = new Text(200, sizeof(GpsData));\n        }\n    } else {\n        if (queue) {\n            queue->flush();\n            delete queue;\n            queue = NULL;\n        }\n        queue_enabled_flag = true;\n    }\n}\n", "CodeBleu_score": 12.876630259490682}, {"code": "void GpsInterface::enable_queue()\tif (!queue_enabled_flag) {\n\t\tqueue_enabled_flag = true;\n\t\tqueue.flush();\n\t\ttext.clear();\n\t\ttext_in.clear();\n\t}\n}\n", "CodeBleu_score": 5.22483698329511}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea()    if (queue_nmea == NULL) {\n        queue_nmea = new Queue<NMEASentence *>();\n    } else {\n        delete queue_nmea;\n        queue_nmea = new Queue<NMEASentence *>();\n    }\n}\n", "CodeBleu_score": 41.54623915356716}, {"code": "void GpsInterface::flush_queue_nmea()    if (nmea_queue != NULL) {\n        delete nmea_queue;\n        nmea_queue = new queue<string>;\n    } else {\n        nmea_queue = new queue<string>;\n    }\n}\n", "CodeBleu_score": 43.159726869288264}, {"code": "void GpsInterface::flush_queue_nmea()\tif (queue_nmea != NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\tqueue_nmea = new queue_nmea_t();\n}\n", "CodeBleu_score": 33.869779249621274}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    uint32_t x;\n    uint32_t y;\n\n    /*Serial.printf(\"flush: (%d, %d) -> (%d, %d)\\n\", area->x1, area->y1, area->x2, area->y2);*/\n\n    /* The most external pixel of the display */\n    int32_t x_end = (area->x2 == disp->hor_res - 1) ? (LV_HOR_RES_MAX - 1) : (area->x2);\n    int32_t y_end = (area->y2 == disp->ver_res - 1) ? (LV_VER_RES_MAX - 1) : (area->y2);\n\n    /* The coordinates of the left-top corner in the color buffer */\n    int32_t cbuf_x1 = area->x1 + disp->disp_buf->x_ofs;\n    int32_t cbuf_y1 = area->y1 + disp->disp_buf->y_ofs;\n\n    /* The coordinates of the right-bottom corner in the color buffer */\n    int32_t cbuf_x2 = area->x2 + disp->disp_buf->x_ofs;\n    int32_t cbuf_y2 = area->y2 + disp->disp_buf->y_ofs;\n\n    /* The coordinates of the left-top corner in the display */\n    int32_t disp_x1 = area->x1 + disp->disp_buf->x_ofs;\n    int32_t disp_y1 = area->y1 + disp->disp_buf->y_ofs;\n\n    /* The coordinates of the right-bottom corner in the display */\n    int32_t disp_x2 = area->x2 + disp->disp_buf->x_ofs;\n    int32_t disp_y2 = area->y2 + disp->disp_buf->y_ofs;\n\n    /* The coordinates of the left-top corner in the display buffer */\n    int32_t dbuf_x1 = area->x1 + disp->dis", "CodeBleu_score": 29.423268189271763}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    uint16_t x, y;\n    uint32_t i;\n    uint32_t size = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n    uint32_t index = 0;\n\n    /* Get the buffer's address */\n    uint8_t *buf_ptr = (uint8_t *)color_p;\n\n    /* Set the starting address of the display */\n    uint32_t x_start = area->x1;\n    uint32_t y_start = area->y1;\n    uint32_t x_end = area->x2;\n    uint32_t y_end = area->y2;\n\n    /* Set the starting address of the display */\n    uint32_t x_start_phys = x_start * LV_HOR_RES_MAX;\n    uint32_t y_start_phys = y_start * LV_VER_RES_MAX;\n    uint32_t x_end_phys = x_end * LV_HOR_RES_MAX;\n    uint32_t y_end_phys = y_end * LV_VER_RES_MAX;\n\n    /* Start a write transaction */\n    LCD_WriteStart();\n\n    /* Set the address window to the area to be updated */\n    LCD_SetAddressWindow(x_start_phys, y_start_phys, x_end_phys, y_end_phys);\n\n    /* Iterate through each pixel in the area to be updated */\n    for (y = y_start; y <= y_end; y++) {\n        for (x = x_start; x <= x_end; x++) {\n            /* Write the color data to the display */\n            LCD_WriteData(buf_ptr[index]);\n            index++;\n        }\n    }\n\n    /* End the write transaction */\n    LCD_WriteEnd();\n\n    /* Notify that the display flush is complete */\n    disp->driver.buffer->flushing = 0;\n}\n", "CodeBleu_score": 48.71517330384007}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    uint32_t x, y;\n    uint32_t x_act;\n    uint32_t y_act;\n    uint32_t i;\n\n    /*Get the index of the current buffer*/\n    uint8_t buf_act = lv_disp_get_buf_act(disp);\n\n    /*The coordinates of the display*/\n    lv_coord_t hres = disp->hor_res;\n    lv_coord_t vres = disp->ver_res;\n\n    /*The coordinates of the area to refresh*/\n    uint32_t x1 = area->x1;\n    uint32_t x2 = area->x2;\n    uint32_t y1 = area->y1;\n    uint32_t y2 = area->y2;\n\n    /*Truncate the area to the res*/\n    x2 = LV_MATH_MIN(x2, hres - 1);\n    y2 = LV_MATH_MIN(y2, vres - 1);\n\n    /* Refresh the content of the memory with the new color data. `color_p` has the\n     * data. `area` has the coordinates of the area to refresh. `hres` and `vres` are the resolutions.\n     * `copy_byte_dsc` describes the memory layout of the display.*/\n    for (y = y1; y <= y2; y++) {\n        for (x = x1; x <= x2; x++) {\n            /*Set the address*/\n            x_act = x;\n            y_act = vres - y - 1;\n            /*Write the pixel to the address*/\n            lv_disp_buf_t *disp_buf = lv_disp_get_buf(disp);\n            uint32_t bpp = disp_buf->header.cf == LV_IMG_CF_RAW ? disp->driver.color_size / 8 : 1;\n            uint8_t *buf_w = (uint8_t *)disp_buf->buf1;\n            uint8_t *buf_r = (uint", "CodeBleu_score": 39.09647577545103}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    for (int i = 0; i < menu->getNumberOfNodes(); i++) {\n        for (int j = 0; j < layer; j++) {\n            cout << \"  \";\n        }\n        cout << menu->getNode(i)->getName() << endl;\n        if (menu->getNode(i)->getType() == MENU) {\n            showMenuList(menu->getNode(i)->getMenu(), layer + 1);\n        }\n    }\n}\n", "CodeBleu_score": 46.552456070963586}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    if (menu == NULL) {\n        return;\n    }\n    MenuNode * node = menu->getFirstNode();\n    while (node != NULL) {\n        for (int i = 0; i < layer; i++) {\n            cout << \"    \";\n        }\n        cout << node->getName() << endl;\n        showMenuList(node->getSubMenu(), layer + 1);\n        node = node->getNextNode();\n    }\n}\n", "CodeBleu_score": 44.22679388674483}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tfor (int i = 0; i < menu->getNumNodes(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \"  \";\n\t\t}\n\t\tcout << menu->getNode(i)->getName() << endl;\n\t\tif (menu->getNode(i)->getNumNodes() > 0) {\n\t\t\tshowMenuList(menu->getNode(i), layer + 1);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.00789551710739}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count)  int ssidCount = 0;\n  for (int i = 0; i < count; i++) {\n    char ssid[7];\n    for (int j = 0; j < 6; j++) {\n      ssid[j] = random(97, 123);\n    }\n    ssid[6] = '\\0';\n    ssidCount++;\n    String str = String(ssid);\n    ssids.push_back(str);\n    Serial.print(\"SSID: \");\n    Serial.println(str);\n  }\n  return ssidCount;\n}\n", "CodeBleu_score": 40.53501932311466}, {"code": "int WiFiScan::generateSSIDs(int count)  int generatedSSIDs = 0;\n  for (int i = 0; i < count; i++) {\n    String newSSID = generateRandomSSID();\n    if (newSSID != \"\") {\n      generatedSSIDs++;\n      Serial.println(newSSID);\n    }\n  }\n  return generatedSSIDs;\n}\n", "CodeBleu_score": 27.365507151413244}, {"code": "int WiFiScan::generateSSIDs(int count)  int generated = 0;\n  while (generated < count) {\n    String ssid = generateSSID();\n    if (ssid.length() == 6) {\n      generated++;\n      Serial.println(ssid);\n    }\n  }\n  return generated;\n}\n", "CodeBleu_score": 21.486309414116153}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n    topic = publisher_client.create_topic(topic_path)\n    print(f'Topic created: {topic}')\n\n", "CodeBleu_score": 36.09601103776862}, {"code": "def create_topic(project_id, topic_name)\n    # [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    # TODO project_id = \"Your Google Cloud project ID\"\n    # TODO topic_name = \"Your Pub/Sub topic name\"\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # The `create_topic` method returns a future. Calling result() on the\n    # future blocks until the topic is created.\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 84.76902520791279}, {"code": "def create_topic(project_id, topic_name)\n    # [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Topic created: {topic}\")\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 78.74405938741704}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n    # Import the cryptographic modules\n    import jwt\n    import datetime\n\n    # Read the private key file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n\n    return encoded_jwt\n\n", "CodeBleu_score": 56.17255775810883}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print(\"Creating JWT using {} from private key file {}\".format(\n        algorithm, private_key_file))\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    encoded_token = jwt.encode(token, private_key, algorithm=algorithm)\n\n    return encoded_token\n\n", "CodeBleu_score": 74.26000274782845}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    # Import the PyJWT library to generate the JWT.\n    import pyjwt\n\n    # Import the datetime library to get the current time.\n    import datetime\n\n    # Create the JWT.\n    current_time = datetime.datetime.utcnow()\n    payload = {\n        # The time that the token was issued at.\n        'iat': current_time,\n        # The time the token expires.\n        'exp': current_time + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    # Create the JWT.\n    jwt = pyjwt.encode(payload, private_key, algorithm=algorithm)\n\n    return jwt\n\n", "CodeBleu_score": 61.26257191490135}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n    payload = message.payload.decode()\n    print(\"Received message: \" + str(payload))\n    print(\"From topic: \" + str(message.topic))\n    print(\"QoS: \" + str(message.qos))\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        camera.capture(\"preview.jpg\")\n        print(\"Uploading preview image to bucket...\")\n        bucket.blob(\"preview.jpg\").upload_from_filename(\"preview.jpg\")\n        print(\"Publishing preview image URL to event topic...\")\n        client.publish(event_topic, \"https://storage.googleapis.com/{}preview.jpg\".format(bucket_name))\n    elif payload == \"off\":\n        print(\"Preview image is off.\")\n    else:\n        print(\"Unknown payload: \" + str(payload))\n\n", "CodeBleu_score": 28.69315025097868}, {"code": "def on_message(unused_client, unused_userdata, message)\n\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received a message: \" + str(payload))\n\n    if payload == \"on\":\n        print(\"Capturing a preview image...\")\n        preview_image = capture_preview_image()\n\n        print(\"Uploading the preview image to the bucket...\")\n        preview_image_url = upload_file_to_bucket(preview_image)\n\n        print(\"Publishing the preview image's URL to the MQTT event topic...\")\n        publish_preview_image_url(preview_image_url)\n\n        print(\"Deleting the preview image...\")\n        delete_preview_image(preview_image)\n\n    else:\n        print(\"Payload is not 'on'.\")\n\n", "CodeBleu_score": 26.71532845738207}, {"code": "def on_message(unused_client, unused_userdata, message)\n    payload = str(message.payload.decode(\"utf-8\"))\n    topic = message.topic\n    qos = message.qos\n    print(\"Received message with payload \" + payload + \" on topic \" + topic + \" with QoS \" + str(qos))\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        capture_preview_image()\n        print(\"Uploading preview image to bucket...\")\n        upload_preview_image()\n        print(\"Publishing preview image URL to event topic...\")\n        publish_preview_image_url()\n    else:\n        print(\"Received payload \" + payload + \" on topic \" + topic + \" with QoS \" + str(qos))\n        print(\"Payload is not 'on'\")\n\n", "CodeBleu_score": 26.16025986672643}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n    import argparse\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Google Cloud project ID',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument(\n        '--registry_id',\n        help='Registry ID',\n        required=True)\n    parser.add_argument(\n        '--device_id',\n        help='Device ID',\n        required=True)\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.',\n        required=True)\n    parser.add_argument(\n        '--algorithm',\n        help='Encryption algorithm to use to generate the JWT.',\n        default='RS256')\n    parser.add_argument(\n        '--cloud_region',\n        help='GCP cloud region',\n        default='us-central1')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root certificate.',\n        default='roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        help='Number of messages to publish.',\n        default=10)\n    parser.add_argument(\n        '--message_type',\n        help='Type of message to publish.',\n        choices=('event', 'state'),\n        default='event')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='MQTT bridge hostname.',\n        default='mqtt.googleapis.com')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        help='MQTT bridge port.',\n        choices=(8883, 443),\n        default=8883)\n    parser.add_argument(\n        '--mqtt_topic',\n        help='MQTT topic to subscribe to.',\n        default='/devices/{}/events'.format(args.device_id))\n    parser.add", "CodeBleu_score": 35.07049650067599}, {"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(description='Command line arguments for Google Cloud IoT MQTT device connection.')\n    parser.add_argument('--project_id', help='GCP cloud project name', required=False)\n    parser.add_argument('--registry_id', help='Registry ID', required=True)\n    parser.add_argument('--device_id', help='Device ID', required=True)\n    parser.add_argument('--private_key_file', help='Path to private key file', required=True)\n    parser.add_argument('--algorithm', help='Encryption algorithm', required=False)\n    parser.add_argument('--ca_certs', help='CA root certificate', required=True)\n    parser.add_argument('--num_messages', help='Number of messages to publish', required=False, default=10)\n    parser.add_argument('--message_type', help='Type of message to publish', required=False, default='event')\n    parser.add_argument('--mqtt_bridge_hostname', help='MQTT bridge hostname', required=False, default='mqtt.googleapis.com')\n    parser.add_argument('--mqtt_bridge_port', help='MQTT bridge port', required=False, default=8883)\n    parser.add_argument('--jwt_expires_minutes', help='Expiration time for JWT tokens, in minutes', required=False, default=20)\n    parser.add_argument('--jwt_refresh_minutes', help='Refresh time for JWT tokens, in minutes', required=False, default=15)\n    parser.add_argument('--state_topic', help='MQTT topic where device state will be published', required=False, default='state')\n    parser.add_argument('--command_topic', help='MQTT topic where device commands will be subscribed', required=False, default='commands')\n    parser.add_argument('--event_topic', help='MQTT topic where device events will be published', required=False, default='events')\n    parser.add_argument('--log_file', help='File to write logs', required=False, default='mqtt_example_device.log')", "CodeBleu_score": 31.41807141823118}, {"code": "def parse_command_line_args()\n    import argparse\n    parser = argparse.ArgumentParser(description='Arguments for Google Cloud IoT Core MQTT example.')\n    parser.add_argument('--project_id', help='GCP cloud project name.', default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument('--registry_id', help='Cloud IoT Core registry ID.', required=True)\n    parser.add_argument('--device_id', help='Cloud IoT Core device ID.', required=True)\n    parser.add_argument('--private_key_file', help='Path to private key file.', required=True)\n    parser.add_argument('--algorithm', help='Encryption algorithm to use to generate the JWT.', default='RS256')\n    parser.add_argument('--cloud_region', help='GCP cloud region.', default='us-central1')\n    parser.add_argument('--ca_certs', help='CA root certificate.', default='roots.pem')\n    parser.add_argument('--num_messages', help='Number of messages to publish.', default=10)\n    parser.add_argument('--message_type', help='Type of message to publish.', choices=['event', 'state'], default='event')\n    parser.add_argument('--mqtt_bridge_hostname', help='MQTT bridge hostname.', default='mqtt.googleapis.com')\n    parser.add_argument('--mqtt_bridge_port', help='MQTT bridge port.', default=8883)\n    parser.add_argument('--jwt_expires_minutes', help='Expiration time, in minutes, for JWT tokens.', default=20)\n    parser.add_argument('--jwt_refresh_minutes', help='Refresh time, in minutes, for JWT tokens.', default=15)\n    parser.add_argument('--mqtt_topic', help='MQTT topic to subscribe to.', default='/devices/{device_id}/events')\n    parser.add_argument('--mqtt_sub_topic', help='MQTT topic to subscribe to.', default='/dev", "CodeBleu_score": 34.42357517563255}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n    # The following imports are necessary to use the Google Cloud IoT Core service\n    from google.oauth2 import service_account\n    from google.cloud import iot_v1\n    from google.api_core.exceptions import GoogleAPICallError\n    from google.api_core.exceptions import RetryError\n\n    # The following is a list of the scopes required for the Google Cloud IoT Core service\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # The following is the version of the Google Cloud IoT Core service to use\n    VERSION = 'v1'\n\n    # The following is the discovery URL for the Google Cloud IoT Core service\n    DISCOVERY_URL = ('https://cloudiot.googleapis.com/$discovery/rest?'\n                     'version={}'.format(VERSION))\n\n    # The following is the path to the service account JSON file\n    SERVICE_ACCOUNT_FILE = service_account_json\n\n    # The following is the name of the Google Cloud IoT Core registry\n    REGISTRY_ID = 'my-registry'\n\n    # The following is the name of the Google Cloud IoT Core device\n    DEVICE_ID = 'my-device'\n\n    # The following is the path to the RSA private key file\n    PRIVATE_KEY_FILE = 'rsa_private.pem'\n\n    # The following is the name of the RSA private key file\n    PRIVATE_KEY = 'private_key.pem'\n\n    # The following is the name of the RSA certificate file\n    CERTIFICATE_FILE = 'rsa_cert.pem'\n\n    # The following is the name of the RSA certificate file\n    CERTIFICATE = 'certificate.pem'\n\n    # The following is the name of the RSA public key file\n    PUBLIC_KEY_FILE = 'rsa_public.pem'\n\n    # The following is the name of the RSA public key file\n    PUBLIC_KEY = 'public_key.pem'\n\n    # The following is the name of the RSA public key file\n    PUBLIC_", "CodeBleu_score": 32.92805235912664}, {"code": "def get_client(service_account_json)\n\n    # Import the client library\n    from google.oauth2 import service_account\n    from google.cloud.iot_v1 import enums\n    from google.api_core.client_options import ClientOptions\n\n    # Create the client object\n    client = None\n\n    # Create the credentials object\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n\n    # Scopes are defined in the Google Cloud IoT Core documentation\n    scopes = [\n        'https://www.googleapis.com/auth/cloud-platform',\n        'https://www.googleapis.com/auth/cloudiot',\n        'https://www.googleapis.com/auth/cloudiot.admin',\n        'https://www.googleapis.com/auth/cloudiot.devices',\n        'https://www.googleapis.com/auth/cloudiot.devices.commands',\n        'https://www.googleapis.com/auth/cloudiot.devices.configVersions',\n        'https://www.googleapis.com/auth/cloudiot.devices.events',\n        'https://www.googleapis.com/auth/cloudiot.devices.state',\n        'https://www.googleapis.com/auth/cloudiot.registries',\n        'https://www.googleapis.com/auth/cloudiot.registries.configVersions',\n        'https://www.googleapis.com/auth/cloudiot.registries.devices',\n        'https://www.googleapis.com/auth/cloudiot.registries.state',\n        'https://www.googleapis.com/auth/pubsub',\n        'https://www.googleapis.com/auth/pubsub.admin',\n        'https://www.googleapis.com/auth/pubsub.publish',\n        'https://www.googleapis.com/auth/pubsub.subscribe',\n        'https://www.googleapis.com/auth/pubsub.viewer',\n        'https://www.googleapis.com/auth/service.management.servicecontrol',\n        'https://www.googleapis.com/auth/service.management.service.bindings.create',\n        'https://www.googleapis.com/auth/servicecontrol',", "CodeBleu_score": 20.010910832664994}, {"code": "def get_client(service_account_json)\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(\n        [\"https://www.googleapis.com/auth/cloud-platform\"])\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest?version=v1\"\n    return discovery.build(\"cloudiot\", \"v1\", credentials=scoped_credentials,\n                           discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 19.21692026192449}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n    hash_method_code = hash_method_to_asn1(hash_method)\n    if hash_method_code == None:\n        raise Exception('Invalid hash method')\n    hash_value = bytes(hash_value)\n    padded_hash = pad_hash(hash_value)\n    encrypted_signature = encrypt_signature(padded_hash, priv_key)\n    return encrypted_signature\n", "CodeBleu_score": 24.557044777457516}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    # Retrieve the ASN1 code for the hash method and raise an error if the hash method is invalid.\n    if hash_method == \"SHA256\":\n        hash_method_code = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"SHA384\":\n        hash_method_code = b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"SHA512\":\n        hash_method_code = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise ValueError(\"Invalid hash method.\")\n\n    # Concatenate the ASN1 code with the hash value, pad the result for signing, and encrypt the padded hash using the private key.\n    hash_value = hash_method_code + hash_value\n    hash_value = hash_value + (b\"\\x00\" * ((512 - len(hash_value)) % 512))\n    signature = priv_key.sign(hash_value, padding.PKCS1v15(), hashes.SHA512())\n\n    return signature\n\n", "CodeBleu_score": 28.493472592056573}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    if hash_method == \"SHA1\":\n        hash_method_asn1 = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\"\n    elif hash_method == \"SHA256\":\n        hash_method_asn1 = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"SHA384\":\n        hash_method_asn1 = b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"SHA512\":\n        hash_method_asn1 = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise ValueError(\"Invalid hash method\")\n    padded_hash = hash_method_asn1 + hash_value\n    padded_hash = padded_hash + b\"\\x00\" * (128 - len(padded_hash) % 128)\n    return priv_key.encrypt(padded_hash, padding.PKCS1v15())\n\n", "CodeBleu_score": 19.3708527161971}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n    try:\n        signature = int(signature, 16)\n    except ValueError:\n        raise ValueError(\"The signature must be a hexadecimal number.\")\n    if signature < 0:\n        raise ValueError(\"The signature must be a positive number.\")\n    if signature > 2**256 - 1:\n        raise ValueError(\"The signature must be less than 256 bits long.\")\n    if len(pub_key) != 66:\n        raise ValueError(\"The public key must be a hexadecimal number of 66 characters.\")\n    pub_key = int(pub_key, 16)\n    if pub_key < 0:\n        raise ValueError(\"The public key must be a positive number.\")\n    if pub_key > 2**256 - 1:\n        raise ValueError(\"The public key must be less than 256 bits long.\")\n    if message[:2] == \"0x\":\n        message = message[2:]\n    if len(message) % 2 != 0:\n        raise ValueError(\"The message must be a hexadecimal number.\")\n    message = int(message, 16)\n    if message < 0:\n        raise ValueError(\"The message must be a positive number.\")\n    if message > 2**256 - 1:\n        raise ValueError(\"The message must be less than 256 bits long.\")\n    if message == 0:\n        raise ValueError(\"The message must be different from 0.\")\n    if pub_key == 0:\n        raise ValueError(\"The public key must be different from 0.\")\n    if pub_key == 1:\n        raise ValueError(\"The public key must be different from 1.\")\n    if signature == 0:\n        raise ValueError(\"The signature must be different from 0.\")\n    if signature == 1:\n        raise ValueError(\"The signature must be different from 1.\")\n    hash_methods = [\"sha256\", \"sha384\", \"sha512\", \"ripemd160\", \"whirlpool\"]\n    for hash_method in hash_methods:\n        hash_method_int = hash_methods.index", "CodeBleu_score": 22.56720580950479}, {"code": "def verify(message, signature, pub_key)\n    # convert the signature to an integer\n    signature = int(signature, 16)\n    # decrypt the signature\n    clear_signature = decrypt(signature, pub_key)\n    # determine the hash method used\n    hash_method = clear_signature[0]\n    # compute the hash of the message\n    hash_value = hash_function(hash_method, message)\n    # reconstruct the expected padded hash\n    expected_hash = int(hash_value, 16)\n    # verify the signature\n    if clear_signature[1] != expected_hash:\n        raise ValueError('Signature is invalid.')\n    # return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 13.311600673716564}, {"code": "def verify(message, signature, pub_key)\n    signature = int(signature, 16)\n    if signature == 0:\n        raise ValueError(\"Signature is zero\")\n    if signature < 0:\n        raise ValueError(\"Signature is negative\")\n    if pub_key < 0:\n        raise ValueError(\"Public key is negative\")\n    if pub_key == 0:\n        raise ValueError(\"Public key is zero\")\n    if message == \"\":\n        raise ValueError(\"Message is empty\")\n    if signature > pub_key:\n        raise ValueError(\"Signature is larger than public key\")\n    if signature % 2 == 0:\n        raise ValueError(\"Signature is even\")\n    if pub_key % 2 == 0:\n        raise ValueError(\"Public key is even\")\n    if pub_key < 3:\n        raise ValueError(\"Public key is too small\")\n    if signature < 3:\n        raise ValueError(\"Signature is too small\")\n    if signature > 2*pub_key:\n        raise ValueError(\"Signature is too large\")\n    if pub_key > 2**255:\n        raise ValueError(\"Public key is too large\")\n    if signature > 2**255:\n        raise ValueError(\"Signature is too large\")\n    if pub_key % 3 == 2:\n        raise ValueError(\"Public key is not a prime\")\n    if signature % 3 == 2:\n        raise ValueError(\"Signature is not a prime\")\n    if pub_key % 4 == 0:\n        raise ValueError(\"Public key is not a prime\")\n    if signature % 4 == 0:\n        raise ValueError(\"Signature is not a prime\")\n    if pub_key % 5 == 0:\n        raise ValueError(\"Public key is not a prime\")\n    if signature % 5 == 0:\n        raise ValueError(\"Signature is not a prime\")\n    if pub_key % 7 == 0:\n        raise ValueError(\"Public key is not a prime\")\n    if signature % 7 == 0:\n        raise ValueError(\"Signature is not a prime\")\n    if pub_key % 11 == 0:\n        raise", "CodeBleu_score": 9.570213839457178}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT()  // Retrieve the current time\n  time_t now = time(NULL);\n  if (now > 1516239022) {\n    // If the time is valid, update the JWT using the current UNIX time format\n    jwt.update(String(now).c_str());\n  }\n  // Connect to the MQTT client\n  client.connect();\n  // Set a flag to send an MQTT SUBSCRIBE packet after the connection is established\n  subscribeMQTT = true;\n  // Print a debug message indicating the MQTT connection attempt\n  Serial.println(\"MQTT: Connecting\");\n}\n", "CodeBleu_score": 24.744323092329644}, {"code": "static void connectMQTT()\n    // Get the current time\n    time_t now = time(NULL);\n\n    // Check if the time is valid\n    if (now > 0) {\n\n        // Update the JWT\n        updateJWT(now);\n\n    }\n\n    // Connect to the MQTT client\n    connectMQTTClient();\n\n    // Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n    mqttSubscribe = true;\n\n    // Print a debug message\n    DEBUG_MSG(\"MQTT connection attempt\\n\");\n\n}\n", "CodeBleu_score": 25.215390037826662}, {"code": "static void connectMQTT()  // Get the current time\n  time_t now = time(NULL);\n  // Check if the time is valid\n  if (now > 1451602800) {\n    // Update the JWT using the current UNIX time format\n    updateJWT(now);\n  }\n  // Connect to the MQTT client\n  client.connect(DEVICE_ID);\n  // Set a flag to send an MQTT SUBSCRIBE packet after the connection is established\n  subscribeMQTT = true;\n  // Print a debug message\n  Serial.println(\"MQTT: Connecting to MQTT broker\");\n}\n", "CodeBleu_score": 24.58045027912868}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\t*num = 0;\n\tfor (int i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\t*num = *num * 10 + (str[i] - '0');\n\t}\n\treturn str + width;\n}\n", "CodeBleu_score": 20.43792021628091}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t value = 0;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        value = (value * 10) + (str[i] - '0');\n    }\n\n    *num = value;\n    return str + width;\n}\n", "CodeBleu_score": 22.756639758465266}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t value = 0;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9') {\n            return str - 1;\n        }\n        value = value * 10 + (c - '0');\n    }\n    *num = value;\n    return str;\n}\n", "CodeBleu_score": 21.402420246765587}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = 0;\n\tuint8_t* cert_pos = build_state->cert_def->cert_template + build_state->cert_pos;\n\tsize_t cert_size = build_state->cert_def->cert_template_size - build_state->cert_pos;\n\tsize_t cert_size_left = build_state->cert_def->cert_template_size - build_state->cert_pos;\n\tsize_t cert_size_needed = 0;\n\tsize_t cert_size_written = 0;\n\tsize_t cert_size_remaining = 0;\n\tuint8_t* cert_pos_start = cert_pos;\n\tuint8_t* cert_pos_end = cert_pos;\n\tuint8_t* cert_pos_end_of_contents = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_start = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_start = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_end = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_end_start = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_end_end = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_end_end_start = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_end_end_end = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_end_end_end_start = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_end_end_end_end = cert_pos;\n\tuint8_t* cert_pos_end_of_contents_end_end_end_end_end_start = cert_pos;\n\tuint8_t* cert", "CodeBleu_score": 11.768373376764183}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\tint ret = ATCACERT_E_SUCCESS;\n\tint cert_size = 0;\n\tuint8_t* cert_ptr = NULL;\n\tuint8_t* cert_end = NULL;\n\tint i = 0;\n\tuint8_t* cert_start = NULL;\n\tuint8_t* cert_end_temp = NULL;\n\tuint8_t* cert_end_temp2 = NULL;\n\tuint8_t* cert_end_temp3 = NULL;\n\n\tif (!build_state || !build_state->cert_def || !build_state->cert_def->cert_template || !build_state->cert_def->cert_template_size) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tcert_start = build_state->cert_def->cert_template;\n\tcert_end = build_state->cert_def->cert_template + build_state->cert_def->cert_template_size;\n\n\tcert_ptr = cert_start;\n\tcert_end_temp = cert_end;\n\n\t// Build the TBSCertificate\n\tcert_ptr = atcacert_write_uint8(cert_ptr, cert_end_temp, 0x30);\n\tcert_ptr = atcacert_write_length(cert_ptr, cert_end_temp, cert_ptr - cert_start);\n\tcert_ptr = atcacert_write_uint8(cert_ptr, cert_end_temp, 0xA0);\n\tcert_ptr = atcacert_write_length(cert_ptr, cert_end_temp, cert_ptr - cert_start);\n\tcert_ptr = atcacert_write_uint8(cert_ptr, cert_end_temp, 0x03);\n\tcert_ptr = atcacert_write_length(cert_ptr, cert_end_temp, cert_ptr - cert_start);\n\tcert_ptr = atcacert_write_uint8(cert_ptr, cert_end_temp, 0x02);\n\tcert_ptr = atcacert_write_length", "CodeBleu_score": 42.012729777835204}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    int ret = 0;\n    uint8_t* cert_pos = build_state->cert_def->cert_template;\n    size_t cert_pos_size = build_state->cert_def->cert_template_size;\n    size_t cert_pos_offset = 0;\n    size_t cert_pos_size_left = cert_pos_size;\n    size_t cert_pos_size_left_max = cert_pos_size;\n    size_t cert_pos_size_left_max_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    size_t cert_pos_size_left_max_prev_prev_prev_prev_prev_prev_prev_prev_", "CodeBleu_score": 12.03268726992069}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int                     ret = 0;\n    atcacert_der_enc_ctx_t  der_enc_ctx;\n    atcacert_cert_element_t element;\n    uint8_t                 tbs_digest[32];\n    uint8_t                 signature[64];\n    size_t                  signature_size = 0;\n    size_t                  element_size = 0;\n    size_t                  i = 0;\n\n    if (!cert_def || !cert || !ca_public_key) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Retrieve the TBS digest\n    ret = atcacert_der_enc_init(&der_enc_ctx, tbs_digest, sizeof(tbs_digest));\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    for (i = 0; i < cert_def->cert_elements_count; i++) {\n        element = cert_def->cert_elements[i];\n        if (element.element_id == ATCACERT_ELEMENT_TBS_DIGEST) {\n            ret = atcacert_der_enc_element(&der_enc_ctx, cert, cert_size, element.element_id, element.loc.offset, element.loc.size);\n            if (ret != ATCACERT_E_SUCCESS) {\n                return ret;\n            }\n            break;\n        }\n    }\n    if (i == cert_def->cert_elements_count) {\n        return ATCACERT_E_INVALID_PARAMS;\n    }\n    ret = atcacert_der_enc_finish(&der_enc_ctx, &element_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Retrieve the signature\n    ret = atcacert_der_enc_init(&der_enc_ctx, signature, sizeof(signature));\n    if (ret != ATCACERT_E_SUCCESS) {", "CodeBleu_score": 51.11234278183889}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int                     ret = 0;\n    atcacert_cert_element_t cert_elements[ATCACERT_CERT_MAX_ELEMENTS];\n    size_t                  cert_elements_count = 0;\n    atcacert_cert_element_t ca_public_key_element;\n    uint8_t                 tbs_digest[32];\n    uint8_t                 signature[64];\n    size_t                  signature_size = 0;\n\n    if (!cert_def || !cert || !ca_public_key) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the elements of the certificate\n    ret = atcacert_get_cert_elements(cert_def, cert, cert_size, cert_elements, &cert_elements_count);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the CA public key element\n    ret = atcacert_get_cert_element(cert_def, cert_elements, cert_elements_count, ATCACERT_ELEM_CA_PUBLIC_KEY, &ca_public_key_element);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the TBS digest and signature\n    ret = atcacert_get_cert_element(cert_def, cert_elements, cert_elements_count, ATCACERT_ELEM_TBS_DIGEST, &cert_elements[0]);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    ret = atcacert_get_cert_element(cert_def, cert_elements, cert_elements_count, ATCACERT_ELEM_SIGNATURE, &cert_elements[1]);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the TBS digest\n    ret = atcacert_get_tbs_digest(cert_", "CodeBleu_score": 57.63400558971276}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int                     ret = 0;\n    atcacert_cert_element_t cert_element;\n    uint8_t                 tbs_digest[32];\n    uint8_t                 signature[64];\n    size_t                  signature_size = 0;\n    size_t                  i;\n\n    if (!cert_def || !cert || !ca_public_key) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the certificate element\n    ret = atcacert_get_element_size(cert_def, cert, cert_size, cert_def->cert_elements_size, &cert_element);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the TBS digest\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, cert_element.tbs_digest_start, cert_element.tbs_digest_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the signature\n    signature_size = cert_element.signature_start + cert_element.signature_size - cert_element.tbs_digest_start;\n    for (i = 0; i < signature_size; i++) {\n        signature[i] = cert[cert_element.signature_start + i];\n    }\n\n    // Verify the signature\n    ret = atcacert_verify_signature(tbs_digest, sizeof(tbs_digest), signature, signature_size, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}\n", "CodeBleu_score": 56.23226001023156}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{    timerStruct_t * volatile *curr;\n    timerStruct_t * volatile *prev;\n    if ((curr = &list[0]) == ((timerStruct_t * volatile *) 0x0)) {\n        return false;\n    }\n    while ((*curr) != ((timerStruct_t *) 0x0)) {\n        if ((*curr) == timer) {\n            if ((prev = &list[0]) == ((timerStruct_t * volatile *) 0x0)) {\n                return false;\n            }\n            while ((*curr) != ((timerStruct_t *) 0x0)) {\n                if ((*curr) != timer) {\n                    prev = curr;\n                    curr = &(*curr)->next;\n                    continue;\n                }\n                if ((*curr)->next == ((timerStruct_t *) 0x0)) {\n                    *prev = ((timerStruct_t *) 0x0);\n                    break;\n                }\n                *prev = (*curr)->next;\n                break;\n            }\n            return true;\n        }\n        prev = curr;\n        curr = &(*curr)->next;\n    }\n    return false;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 38.59777143880232}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{  timerStruct_t * volatile *list_index;\n  timerStruct_t * volatile *list_index_1;\n  timerStruct_t * volatile *list_index_2;\n  timerStruct_t * volatile *list_index_3;\n  timerStruct_t * volatile *list_index_4;\n  timerStruct_t * volatile *list_index_5;\n  timerStruct_t * volatile *list_index_6;\n  timerStruct_t * volatile *list_index_7;\n  timerStruct_t * volatile *list_index_8;\n  timerStruct_t * volatile *list_index_9;\n  timerStruct_t * volatile *list_index_10;\n  timerStruct_t * volatile *list_index_11;\n  timerStruct_t * volatile *list_index_12;\n  timerStruct_t * volatile *list_index_13;\n  timerStruct_t * volatile *list_index_14;\n  timerStruct_t * volatile *list_index_15;\n  timerStruct_t * volatile *list_index_16;\n  timerStruct_t * volatile *list_index_17;\n  timerStruct_t * volatile *list_index_18;\n  timerStruct_t * volatile *list_index_19;\n  timerStruct_t * volatile *list_index_20;\n  timerStruct_t * volatile *list_index_21;\n  timerStruct_t * volatile *list_index_22;\n  timerStruct_t * volatile *list_index_23;\n  timerStruct_t * volatile *list_index_24;\n  timerStruct_t * volatile *list_index_25;\n  timerStruct_t * volatile *list_index_26;\n  timerStruct_t * volatile *list_index_27;\n  timerStruct_t * volatile *list_index_28;\n  timerStruct_t * volatile *list_index_29;\n  timerStruct_t * volatile *list_index_3", "CodeBleu_score": 8.111538502573017}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{    if (list == (timerStruct_t * volatile *) 0x0) {\n        return false;\n    }\n    if (timer == (timerStruct_t *) 0x0) {\n        return false;\n    }\n    if (*list == (timerStruct_t *) 0x0) {\n        return false;\n    }\n    if (timer == *list) {\n        *list = (*list)->next;\n        return true;\n    }\n    timerStruct_t * volatile *tmp = list;\n    while (true) {\n        if (*tmp == (timerStruct_t *) 0x0) {\n            return false;\n        }\n        if (*tmp == timer) {\n            (*tmp)->next = timer->next;\n            return true;\n        }\n        tmp = &((*tmp)->next);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 42.22086377086332}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket)    int status;\n    struct socket_info *socket_info;\n    struct socket_info *prev_socket_info;\n\n    /* Retrieve the socket information */\n    socket_info = retrieve_socket_info(socket);\n\n    /* Check if the socket exists */\n    if (socket_info == NULL) {\n        /* Set the error number */\n        errno = EBADF;\n\n        /* Return the error */\n        return BSD_ERROR;\n    }\n\n    /* Set the socket state to \"NOT_A_SOCKET\" */\n    socket_info->state = NOT_A_SOCKET;\n\n    /* Call the close function */\n    status = close(socket);\n\n    /* Check if an error occurred */\n    if (status == BSD_ERROR) {\n        /* Set the error number */\n        errno = EBADF;\n\n        /* Return the error */\n        return BSD_ERROR;\n    }\n\n    /* Remove the socket information from the list */\n    prev_socket_info = socket_info->prev_socket_info;\n    if (prev_socket_info != NULL) {\n        prev_socket_info->next_socket_info = socket_info->next_socket_info;\n    }\n    if (socket_info->next_socket_info != NULL) {\n        socket_info->next_socket_info->prev_socket_info = prev_socket_info;\n    }\n    if (socket_info == head_socket_info) {\n        head_socket_info = socket_info->next_socket_info;\n    }\n    if (socket_info == tail_socket_info) {\n        tail_socket_info = socket_info->prev_socket_info;\n    }\n    free(socket_info);\n\n    /* Return the status code */\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 44.51504601131833}, {"code": "int BSD_close(int socket)    if (socket < 0) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n    if (socket >= MAX_SOCKETS) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n    if (socket_table[socket].state != SOCKET_STATE_IN_USE) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n    int ret = close(socket_table[socket].fd);\n    if (ret == -1) {\n        if (errno == EBADF) {\n            errno = EBADF;\n            return BSD_ERROR;\n        }\n        if (errno == ENOTSOCK) {\n            errno = ENOTSOCK;\n            return BSD_ERROR;\n        }\n        if (errno == EINVAL) {\n            errno = EINVAL;\n            return BSD_ERROR;\n        }\n        if (errno == ECONNRESET) {\n            errno = ECONNRESET;\n            return BSD_ERROR;\n        }\n        if (errno == ECONNABORTED) {\n            errno = ECONNABORTED;\n            return BSD_ERROR;\n        }\n        if (errno == ENOTCONN) {\n            errno = ENOTCONN;\n            return BSD_ERROR;\n        }\n        if (errno == EINPROGRESS) {\n            errno = EINPROGRESS;\n            return BSD_ERROR;\n        }\n        if (errno == EOPNOTSUPP) {\n            errno = EOPNOTSUPP;\n            return BSD_ERROR;\n        }\n        if (errno == EISCONN) {\n            errno = EISCONN;\n            return BSD_ERROR;\n        }\n        if (errno == ESHUTDOWN) {\n            errno = ESHUTDOWN;\n            return BSD_ERROR;\n        }\n        if (errno == ETOOMANYREFS) {\n            errno = ETOOMANY", "CodeBleu_score": 33.73236198995361}, {"code": "int BSD_close(int socket)    struct socket_info* socket_info = get_socket_info(socket);\n    if (socket_info == NULL) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n    int result = close(socket);\n    if (result == -1) {\n        errno = result;\n        return BSD_ERROR;\n    }\n    socket_info->state = NOT_A_SOCKET;\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 35.13493156643167}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog)\tint status;\n\t\n\tstatus = listen(socket, backlog);\n\tif (status == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tBSD_setError(BSD_EBADF);\n\t\t\t\tbreak;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\tBSD_setError(BSD_EOPNOTSUPP);\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\tBSD_setError(BSD_EINVAL);\n\t\t\t\tbreak;\n\t\t\tcase ENFILE:\n\t\t\t\tBSD_setError(BSD_ENFILE);\n\t\t\t\tbreak;\n\t\t\tcase ENOBUFS:\n\t\t\t\tBSD_setError(BSD_ENOBUFS);\n\t\t\t\tbreak;\n\t\t\tcase ENOMEM:\n\t\t\t\tBSD_setError(BSD_ENOMEM);\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\tBSD_setError(BSD_ENOTSOCK);\n\t\t\t\tbreak;\n\t\t\tcase EINTR:\n\t\t\t\tBSD_setError(BSD_EINTR);\n\t\t\t\tbreak;\n\t\t\tcase EACCES:\n\t\t\t\tBSD_setError(BSD_EACCES);\n\t\t\t\tbreak;\n\t\t\tcase EADDRINUSE:\n\t\t\t\tBSD_setError(BSD_EADDRINUSE);\n\t\t\t\tbreak;\n\t\t\tcase EADDRNOTAVAIL:\n\t\t\t\tBSD_setError(BSD_EADDRNOTAVAIL);\n\t\t\t\tbreak;\n\t\t\tcase EAFNOSUPPORT:\n\t\t\t\tBSD_setError(BSD_EAFNOSUPPORT);\n\t\t\t\tbreak;\n\t\t\tcase EFAULT:\n\t\t\t\tBSD_setError(BSD_EFAULT);\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK", "CodeBleu_score": 36.61625476726223}, {"code": "int BSD_listen(int socket, int backlog)    int status = listen(socket, backlog);\n    if (status == -1) {\n        switch (errno) {\n            case EBADF:\n                errno = BSD_EBADF;\n                break;\n            case EINVAL:\n                errno = BSD_EINVAL;\n                break;\n            case EMFILE:\n                errno = BSD_EMFILE;\n                break;\n            case ENFILE:\n                errno = BSD_ENFILE;\n                break;\n            case ENOTSOCK:\n                errno = BSD_ENOTSOCK;\n                break;\n            default:\n                errno = BSD_EUNKNOWN;\n                break;\n        }\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 40.29195531540925}, {"code": "int BSD_listen(int socket, int backlog)    int response;\n    response = listen(socket, backlog);\n    if (response == -1) {\n        switch (errno) {\n            case EBADF:\n                errno = BSD_EBADF;\n                break;\n            case EINVAL:\n                errno = BSD_EINVAL;\n                break;\n            case ENOTSOCK:\n                errno = BSD_ENOTSOCK;\n                break;\n            default:\n                errno = BSD_ERROR;\n                break;\n        }\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 43.362758319544184}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)    /*\n     * The function \"BSD_accept\" attempts to accept a connection on a given socket.\\nIt converts the socket address to a supported format and checks the address family.\\nIf the address family is supported, it calls the accept function to accept the connection.\\nIf the address family is not supported, it sets an error and returns an error code.\\nIf the accept function fails, it sets the appropriate error based on the socket value and returns an error code.\\nIf the accept function succeeds, it returns a success code.\n     */\n    int new_socket = -1;\n    int result = -1;\n    struct sockaddr_in *addr_in = NULL;\n    struct sockaddr_in6 *addr_in6 = NULL;\n    struct sockaddr_un *addr_un = NULL;\n    socklen_t len = sizeof(struct sockaddr_in);\n    socklen_t len6 = sizeof(struct sockaddr_in6);\n    socklen_t len_un = sizeof(struct sockaddr_un);\n    struct sockaddr *addr_s = NULL;\n    struct sockaddr_in *addr_in_s = NULL;\n    struct sockaddr_in6 *addr_in6_s = NULL;\n    struct sockaddr_un *addr_un_s = NULL;\n    if (addr == NULL) {\n        errno = EFAULT;\n        return -1;\n    }\n    switch (addr->sa_family) {\n        case AF_INET:\n            addr_in = (struct sockaddr_in *)addr;\n            addr_in_s = (struct sockaddr_in *)&addr_s;\n            *addr_in_s = *addr_in;\n            addr_s->sa_family = AF_INET;\n            addr_s->sa_data[2] = 0;\n            addr_s->sa_data[3] = 0;\n            addr_s->sa_data[4] = 0;\n            addr_s->sa_data[5] = 0;\n            addr_s->sa_data[6] = 0;\n            addr_s->sa_data[7] = 0;", "CodeBleu_score": 23.55308608704642}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint result;\n\tstruct sockaddr_storage addrStorage;\n\tsocklen_t addrLen = sizeof(addrStorage);\n\t\n\tresult = accept(socket, (struct sockaddr *)&addrStorage, &addrLen);\n\tif (result == -1) {\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tswitch (addrStorage.ss_family) {\n\t\tcase AF_INET:\n\t\t\t*addr = (struct bsd_sockaddr) {\n\t\t\t\t.sa_family = AF_INET,\n\t\t\t\t.sa_data = {\n\t\t\t\t\t.sin_port = ((struct sockaddr_in *)&addrStorage)->sin_port,\n\t\t\t\t\t.sin_addr = ((struct sockaddr_in *)&addrStorage)->sin_addr\n\t\t\t\t}\n\t\t\t};\n\t\t\t*addrlen = sizeof(struct bsd_sockaddr_in);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t*addr = (struct bsd_sockaddr) {\n\t\t\t\t.sa_family = AF_INET6,\n\t\t\t\t.sa_data = {\n\t\t\t\t\t.sin6_port = ((struct sockaddr_in6 *)&addrStorage)->sin6_port,\n\t\t\t\t\t.sin6_flowinfo = ((struct sockaddr_in6 *)&addrStorage)->sin6_flowinfo,\n\t\t\t\t\t.sin6_addr = ((struct sockaddr_in6 *)&addrStorage)->sin6_addr,\n\t\t\t\t\t.sin6_scope_id = ((struct sockaddr_in6 *)&addrStorage)->sin6_scope_id\n\t\t\t\t}\n\t\t\t};\n\t\t\t*addrlen = sizeof(struct bsd_sockaddr_in6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = EAFNOSUPPORT;\n\t\t\treturn BSD_ERROR;\n\t}\n\t\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 43.20633670690545}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)    int result = 0;\n    int sock_addr_len = 0;\n    struct sockaddr_storage sock_addr;\n    struct sockaddr * sock_addr_ptr = (struct sockaddr *)&sock_addr;\n\n    if (addr != NULL) {\n        sock_addr_len = sizeof(sock_addr);\n    }\n\n    result = accept(socket, sock_addr_ptr, &sock_addr_len);\n    if (result == -1) {\n        return -1;\n    }\n\n    if (addr != NULL) {\n        if (sock_addr_ptr->sa_family == AF_INET) {\n            struct sockaddr_in * addr_in = (struct sockaddr_in *)sock_addr_ptr;\n            addr->bsd_family = AF_INET;\n            addr->bsd_addr.addr_in.sin_addr.s_addr = addr_in->sin_addr.s_addr;\n            addr->bsd_addr.addr_in.sin_port = addr_in->sin_port;\n            addr->bsd_addr.addr_in.sin_zero[0] = 0;\n            addr->bsd_addr.addr_in.sin_zero[1] = 0;\n            addr->bsd_addr.addr_in.sin_zero[2] = 0;\n            addr->bsd_addr.addr_in.sin_zero[3] = 0;\n        } else if (sock_addr_ptr->sa_family == AF_INET6) {\n            struct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *)sock_addr_ptr;\n            addr->bsd_family = AF_INET6;\n            addr->bsd_addr.addr_in6.sin6_addr = addr_in6->sin6_addr;\n            addr->bsd_addr.addr_in6.sin6_port = addr_in6->sin6_port;\n            addr->bsd_addr.addr_in6.sin6_flowinfo = addr_in6->sin6_flowinfo;\n            addr->bsd", "CodeBleu_score": 35.72492407713779}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT()  if (getTime()) {\n    // Set the JWT time offset to the current time\n    setJWTTime();\n    // Initiate the MQTT connection\n    client.connect(mqttClientID, mqttUser, mqttPassword);\n    // Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n    mqttConnected = true;\n    // Print debug message\n    Serial.println(\"MQTT connected\");\n  } else {\n    // Print debug message\n    Serial.println(\"Error: Failed to retrieve time\");\n  }\n}\n", "CodeBleu_score": 43.57627717392562}, {"code": "static void connectMQTT()  int8_t ret;\n  // get the current time in UNIX format\n  time_t now = time(NULL);\n  // check if the time is valid\n  if (now < 946681200) {\n    // the time is not valid, so set the time to 1.1.2000\n    now = 946681200;\n  }\n  // update the JWT with the current time offset\n  updateJWT(now);\n  // initiate the MQTT connection\n  ret = MQTTConnect();\n  if (ret == 0) {\n    // the connection was successful, so set the flag to send an MQTT SUBSCRIBE packet\n    sendSubscribe = true;\n    // print a debug message\n    Serial.println(F(\"MQTT connection established\"));\n  } else {\n    // the connection was not successful, so print a debug message\n    Serial.println(F(\"MQTT connection failed\"));\n  }\n}\n", "CodeBleu_score": 26.776242842046464}, {"code": "static void connectMQTT()  // Get current time in UNIX format\n  long now = millis();\n\n  // Check if the current time is valid\n  if (now > 1514764800000 && now < 1517356800000) {\n    // Set the JWT expiration time to the current time + 30 seconds\n    unsigned long expirationTime = now + 30000;\n\n    // Create a JSON object to store the JWT\n    JsonObject jwt = doc.createNestedObject(\"jwt\");\n\n    // Set the JWT expiration time\n    jwt[\"exp\"] = expirationTime;\n\n    // Create a JSON object to store the MQTT connection information\n    JsonObject mqtt = doc.createNestedObject(\"mqtt\");\n\n    // Set the MQTT connection information\n    mqtt[\"host\"] = mqttHost;\n    mqtt[\"port\"] = mqttPort;\n    mqtt[\"username\"] = mqttUsername;\n    mqtt[\"password\"] = mqttPassword;\n\n    // Create a JSON object to store the MQTT subscription information\n    JsonObject sub = doc.createNestedObject(\"sub\");\n\n    // Set the MQTT subscription information\n    sub[\"topic\"] = mqttTopic;\n    sub[\"qos\"] = 1;\n\n    // Create a JSON object to store the MQTT publish information\n    JsonObject pub = doc.createNestedObject(\"pub\");\n\n    // Set the MQTT publish information\n    pub[\"topic\"] = mqttTopic;\n    pub[\"qos\"] = 1;\n\n    // Create a JSON object to store the MQTT connection information\n    JsonObject mqtt = doc.createNestedObject(\"mqtt\");\n\n    // Set the MQTT connection information\n    mqtt[\"host\"] = mqttHost;\n    mqtt[\"port\"] = mqttPort;\n    mqtt[\"username\"] = mqttUsername;\n    mqtt[\"password\"] = mqttPassword;\n\n    // Create a JSON object to store the MQTT subscription information\n    JsonObject sub =", "CodeBleu_score": 34.99587586609359}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void)\tif (MQTT_get_connection_state() == CONNECTED) {\n\t\tMQTT_get_client_info(client_id, client_ip, client_port);\n\t\tMQTT_disconnect();\n\t}\n\tDEBUG_LOG(DBG_CLOUD, \"Disconnected from the cloud service.\");\n}\n", "CodeBleu_score": 47.789531956609004}, {"code": "void CLOUD_disconnect(void)    if (CLOUD_mqtt_state == CONNECTED) {\n        CLOUD_mqtt_state = DISCONNECTING;\n        MQTT_Disconnect(&CLOUD_mqtt_client);\n        CLOUD_mqtt_state = DISCONNECTED;\n        CLOUD_mqtt_client_connected = false;\n        CLOUD_log_debug(\"MQTT client disconnected\");\n    }\n}\n", "CodeBleu_score": 44.28398873942264}, {"code": "void CLOUD_disconnect(void)\tif (CLOUD_mqtt_state == CLOUD_MQTT_STATE_CONNECTED) {\n\t\tCLOUD_mqtt_state = CLOUD_MQTT_STATE_DISCONNECTING;\n\t\tCLOUD_log_debug(\"Disconnecting from cloud service\");\n\t\tCLOUD_mqtt_client_disconnect(CLOUD_mqtt_client);\n\t}\n}\n", "CodeBleu_score": 40.9408877018908}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  bool connection_success = false;\n  int8_t connection_status;\n  int8_t wifi_connection_status;\n  uint8_t wifi_connection_attempts = 0;\n\n  // If the Wi-Fi is not enabled, enable it.\n  if (wifi_enabled == false) {\n    wifi_enable();\n  }\n\n  // If new credentials are passed, attempt to connect to the access point.\n  if (passed_wifi_creds == 1) {\n    // If the Wi-Fi is enabled, connect to the access point.\n    if (wifi_enabled == true) {\n      // If the Wi-Fi is not already connected, attempt to connect to the access point.\n      if (wifi_connected == false) {\n        // If the Wi-Fi is not already attempting to connect, attempt to connect to the access point.\n        if (wifi_connecting == false) {\n          wifi_connecting = true;\n          connection_status = wifi_connect(wifi_ssid, wifi_auth, wifi_password);\n          wifi_connecting = false;\n          if (connection_status == RTW_SUCCESS) {\n            connection_success = true;\n            wifi_connected = true;\n            wifi_connection_attempts = 0;\n          } else {\n            // If the connection failed, log an error message and update the networking error status.\n            wifi_connection_status = wifi_get_last_error();\n            if (wifi_connection_status == RTW_CONNECTION_NO_AP_FOUND) {\n              printf(\"Wi-Fi connection failed: No access point found.\\n\");\n              wifi_connection_attempts++;\n              if (wifi_connection_attempts >= 3) {\n                wifi_connection_attempts = 0;\n                wifi_connected = false;\n                wifi_connected_previous = false;\n                wifi_connection_status = 0;\n                wifi_connecting = false;\n                wifi_enabled = false;\n                wifi_enabled_previous = false;\n                wifi_error_status =", "CodeBleu_score": 35.59027031256065}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  // Check if the Wi-Fi credentials are valid\n  if (wifi_creds[0] == '\\0' || wifi_creds[1] == '\\0' || wifi_creds[2] == '\\0' || wifi_creds[3] == '\\0' || wifi_creds[4] == '\\0' || wifi_creds[5] == '\\0') {\n    // Wi-Fi credentials are invalid\n    if (passed_wifi_creds == 0) {\n      // Wi-Fi credentials are not valid and are not being passed\n      // Log an error message\n      Serial.println(\"ERROR: Wi-Fi credentials are invalid\");\n      // Update the networking error status\n      networking_error = 1;\n      // Return false\n      return false;\n    } else {\n      // Wi-Fi credentials are not valid but are being passed\n      // Attempt to connect to the access point using the passed credentials\n      // Log the attempt\n      Serial.println(\"Attempting to connect to the access point using the passed credentials\");\n      // Connect to the access point\n      if (wifi_connectToAp(wifi_creds[0], wifi_creds[1], wifi_creds[2], wifi_creds[3], wifi_creds[4], wifi_creds[5])) {\n        // Connection succeeded\n        // Log the success\n        Serial.println(\"Successfully connected to the access point using the passed credentials\");\n        // Return true\n        return true;\n      } else {\n        // Connection failed\n        // Log the failure\n        Serial.println(\"Failed to connect to the access point using the passed credentials\");\n        // Update the networking error status\n        networking_error = 1;\n        // Return false\n        return false;\n      }\n    }\n  } else {\n    // Wi-Fi credentials are valid\n    // Attempt to connect to the access point using the default credentials\n    // Log the attempt\n    Serial.println(\"Attempting to connect to the access point using the default credentials\");\n    // Connect to the access point\n    if (wifi_connectToAp(wifi_creds[0], wifi_creds[1], wifi_creds", "CodeBleu_score": 36.99761057418992}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  // If new credentials are provided, connect using the specified SSID, authentication type, and password.\n  if (passed_wifi_creds == 1) {\n    if (wifi_ssid == NULL || wifi_auth == NULL || wifi_pass == NULL) {\n      // If any of the Wi-Fi credentials are NULL, log an error and return false.\n      Serial.println(\"Error: Wi-Fi credentials are NULL.\");\n      return false;\n    }\n    WiFi.begin(wifi_ssid, wifi_pass, wifi_auth);\n  }\n  // If not, connect using the default Wi-Fi settings.\n  else {\n    WiFi.begin();\n  }\n\n  // Log the connection status.\n  Serial.print(\"Connecting to Wi-Fi access point: \");\n  Serial.println(wifi_ssid);\n\n  // Attempt to connect to the Wi-Fi access point.\n  while (WiFi.status() != WL_CONNECTED) {\n    // If the connection fails, log an error message and update the networking error status.\n    Serial.print(\".\");\n    networking_error = true;\n    delay(1000);\n  }\n  // If the connection succeeds, log a success message and return true.\n  Serial.println(\"Wi-Fi connected.\");\n  networking_error = false;\n  return true;\n}\n", "CodeBleu_score": 37.60313607811191}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map)  var client = new ApolloClient({\n    uri: \"https://api.spacexdata.com/v3/\",\n    cache: new InMemoryCache(),\n  });\n\n  var query = gql`\n    query {\n      launchesPast(limit: 100) {\n        launches {\n          rocket {\n            firstStage {\n              cores {\n                landSuccess\n                landingIntent\n                landingType\n                landingVehicle\n                landingVehicleType\n                landingAttempt\n                landingLat\n                landingLng\n                landingVehicleSerial\n                landingVehicleID\n                landingVehicleName\n                landingVehicleType\n                landingVehicleRole\n                landingVehicleAgency\n                landingVehicleAgencyShort\n                landingVehicleAgencyURL\n                landingVehicleWikiURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n                landingVehicleImageURL\n                landingVehicleImageThumbnailURL\n", "CodeBleu_score": 10.013736883188857}, {"code": "async function DisplaySensors(map)  const client = new ApolloClient({\n    uri: \"https://api.spacex.land/graphql/\",\n  });\n\n  const query = gql`\n    {\n      launchesPast(limit: 1) {\n        launches {\n          rocket {\n            second_stage {\n              payloads {\n                payload {\n                  orbit_params {\n                    reference_system\n                    regime\n                    longitude\n                    latitude\n                    altitude_km\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `;\n\n  const response = await client.query({ query });\n\n  if (response.data.launchesPast.launches.length > 0) {\n    console.log(\"Retrieved sensors\");\n    response.data.launchesPast.launches.forEach((launch) => {\n      launch.rocket.second_stage.payloads.forEach((payload) => {\n        payload.payload.orbit_params.forEach((orbit) => {\n          console.log(\n            \"Sensor:\",\n            orbit.reference_system,\n            orbit.regime,\n            orbit.longitude,\n            orbit.latitude,\n            orbit.altitude_km\n          );\n          const marker = new google.maps.Marker({\n            position: {\n              lat: orbit.latitude,\n              lng: orbit.longitude,\n            },\n            map: map,\n            title: \"Sensor\",\n          });\n        });\n      });\n    });\n  }\n}\n", "CodeBleu_score": 33.163390498195575}, {"code": "async function DisplaySensors(map)    // Create a client\n    const client = new ApolloClient({\n        uri: 'https://api.spacexdata.com/v3/',\n        cache: new InMemoryCache(),\n    });\n\n    // Create a GraphQL query\n    const query = gql`\n        query {\n            launchesPast(limit: 100) {\n                launches {\n                    rocket {\n                        second_stage {\n                            payloads {\n                                customers\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    `;\n\n    // Send the query to the API and log the response\n    const response = await client.query({ query });\n    console.log(response);\n\n    // If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\n    if (response.data) {\n        console.log('Retrieved sensors');\n        response.data.launchesPast.launches.forEach(function (launch) {\n            if (launch.rocket.second_stage.payloads[0].customers.includes('ISS')) {\n                console.log('Retrieved sensor');\n                // Create a marker\n                var marker = new google.maps.Marker({\n                    position: { lat: launch.rocket.second_stage.payloads[0].decay_degree.latitude, lng: launch.rocket.second_stage.payloads[0].decay_degree.longitude },\n                    map: map,\n                    title: launch.rocket.second_stage.payloads[0].customers[0],\n                    icon: {\n                        url: 'https://cdn.iconscout.com/icon/free/png-256/space-rocket-10-1175130.png',\n                        scaledSize: new google.maps.Size(30, 30),\n                        origin: new google.maps.Point(0, 0),\n                        anchor: new google.maps.Point(0, 0)\n                    }\n                });\n            }\n        });\n    }\n}\n", "CodeBleu_score": 35.10827168429822}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.backgroundColor = 'black';\n    marker.style.border = '1px solid black';\n    return marker;\n}\n", "CodeBleu_score": 35.09208368770446}, {"code": "const CreateSensorMarker = (sensor) =>    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';\n    marker.style.border = '1px solid black';\n    marker.style.width = '10px';\n    marker.style.height = '10px';\n    marker.style.borderRadius = '50%';\n    return marker;\n};\n", "CodeBleu_score": 34.025732826376036}, {"code": "const CreateSensorMarker = (sensor) =>  const sensorMarker = document.createElement('div');\n  sensorMarker.id = sensor.id;\n  sensorMarker.classList.add('sensor');\n  sensorMarker.style.backgroundColor = 'rgb(255, 255, 255)';\n  sensorMarker.style.border = '1px solid rgb(255, 255, 255)';\n  return sensorMarker;\n};\n", "CodeBleu_score": 32.277990740891184}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    if not module_name:\n        raise ValueError(\"No module name provided.\")\n    module_path = f\"{MFA_MODULES_PATH}/{module_name}\"\n    if not os.path.isdir(module_path):\n        raise ValueError(f\"Module {module_name} does not exist.\")\n    module_name = f\"{module_name}.{module_name}\"\n    try:\n        module = importlib.import_module(module_name)\n    except ImportError as error:\n        _LOGGER.error(\"Unable to import module %s: %s\", module_name, error)\n        raise\n    if not hasattr(module, \"MFA_MODULE_NAME\"):\n        raise ValueError(f\"Module {module_name} does not contain an MFA_MODULE_NAME attribute.\")\n    if not hasattr(module, \"MFA_MODULE_VERSION\"):\n        raise ValueError(f\"Module {module_name} does not contain an MFA_MODULE_VERSION attribute.\")\n    if not hasattr(module, \"MFA_MODULE_ISSUER\"):\n        raise ValueError(f\"Module {module_name} does not contain an MFA_MODULE_ISSUER attribute.\")\n    if not hasattr(module, \"MFA_MODULE_SECRET\"):\n        raise ValueError(f\"Module {module_name} does not contain an MFA_MODULE_SECRET attribute.\")\n    if not hasattr(module, \"MFA_MODULE_QRCODE\"):\n        raise ValueError(f\"Module {module_name} does not contain an MFA_MODULE_QRCODE attribute.\")\n    if not hasattr(module, \"MFA_MODULE_QRCODE_SIZE\"):\n        raise ValueError(f\"Module {module_name} does not contain an MFA_MODULE_QRCODE_SIZE attribute.\")\n    if not hasattr(module, \"MFA_MODULE_QRCODE_IMAGE\"):\n        raise ValueError(f\"Module {module_name} does not contain an MFA_MODULE_QRCODE_IMAGE", "CodeBleu_score": 30.40038422791511}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"{MODULES_PATH}/{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(f\"MFA module {module_name} not found\")\n        raise\n    except Exception as e:\n        _LOGGER.error(f\"MFA module {module_name} failed to load: {e}\")\n        raise\n\n    if not module.SKIP_PIP_INSTALL:\n        if module.REQUIREMENTS:\n            if module_name not in MODULE_REQUIREMENTS:\n                _LOGGER.info(f\"Installing requirements for module {module_name}\")\n                for requirement in module.REQUIREMENTS:\n                    try:\n                        _LOGGER.info(f\"Installing requirement {requirement}\")\n                        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", requirement])\n                    except subprocess.CalledProcessError:\n                        _LOGGER.error(f\"Failed to install requirement {requirement}\")\n                        raise\n                MODULE_REQUIREMENTS.append(module_name)\n            else:\n                _LOGGER.info(f\"Skipping installation of requirements for module {module_name}\")\n        else:\n            _LOGGER.info(f\"Skipping installation of requirements for module {module_name}\")\n\n    return module\n\n", "CodeBleu_score": 33.089832212744476}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"homeassistant.components.{module_name}\"\n    module_name = module_name.replace(\"_\", \"-\")\n    module_name = module_name.replace(\".\", \"_\")\n    module = importlib.import_module(module_path)\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not hass.config.skip_pip:\n            async_process_requirements(hass, module_name, module.REQUIREMENTS)\n    return module\n\n", "CodeBleu_score": 22.38773309147169}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    if not self._data:\n        self._data = []\n    for entry in self._data:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = setup_data\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": setup_data})\n\n", "CodeBleu_score": 57.86883325797327}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    if user_id not in self.data:\n        self.data[user_id] = setup_data\n    else:\n        self.data[user_id] = setup_data\n\n    return True\n\n", "CodeBleu_score": 25.102057226272834}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    if user_id in self.data:\n        self.data[user_id] = setup_data\n    else:\n        self.data[user_id] = setup_data\n\n    return setup_data\n", "CodeBleu_score": 25.47342325444531}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n    if self._initialized:\n      return\n    with self._initialization_lock:\n      if self._initialized:\n        return\n      self._initialized = True\n      self._settings = {}\n      self._settings = self._store.load()\n      if not self._settings:\n        self._settings = {}\n      for user in self._settings:\n        self._settings[user] = NotifySetting(user, self._settings[user])\n\n  def _async_save(self) -> None:\n    \"\"\"The function \"_async_save\" asynchronously saves user data.\\nIt acquires a save lock to ensure thread safety and checks if user settings are already saved.\\nIf not, it attempts to save data to the user store.\"\"\"\n    if self._saved:\n      return\n    with self._save_lock:\n      if self._saved:\n        return\n      self._saved = True\n      self._store.save(self._settings)\n\n  def _get_setting(self, user: str, setting: str) -> Any:\n    \"\"\"The function \"_get_setting\" gets the value of a user setting.\\nIt checks if the user is registered and if the setting is valid.\\nIf not, it returns None.\"\"\"\n    if user not in self._settings:\n      return None\n    if setting not in self._settings[user].settings:\n      return None\n    return self._settings[user].settings[setting]\n\n  def _set_setting(self, user: str, setting: str, value: Any) -> None:\n    \"\"\"The function \"_set_setting\" sets the value of a user setting.\\nIt checks if the user is registered and if the setting is valid.\\nIf not, it does nothing.\"\"\"\n    if user not in self._settings:\n      return\n    if setting not in self._settings[user].settings:\n      return\n    self._settings[user].settings[setting] = value\n\n  def _get_settings(self, user: str) -> Dict[str, Any]:\n    \"\"\"The function \"_get_settings\" gets the user settings.\\nIt checks if the user is registered.\\nIf not, it returns an empty dictionary.\"\"\"\n    if user not in self._settings:\n      return {}\n", "CodeBleu_score": 28.485938522942206}, {"code": "async def _async_load(self) -> None\n    with self._init_lock:\n      if self._loaded:\n        return\n      try:\n        data = self._store.load()\n      except:\n        data = {}\n      if not data:\n        data = {}\n      self._data = data\n      for user in data:\n        self._data[user] = NotifySetting(user, data[user])\n      self._loaded = True\n\n  def _async_save(self) -> None:\n    \"\"\"The function \"_async_save\" asynchronously saves user data.\\nIt acquires a save lock to ensure thread safety and checks if user settings are already loaded.\\nIf not, it returns. Otherwise, it saves the user settings to the user store.\"\"\"\n    with self._save_lock:\n      if not self._loaded:\n        return\n      self._store.save(self._data)\n\n  def _async_remove(self, user: str) -> None:\n    \"\"\"The function \"_async_remove\" asynchronously removes user data.\\nIt acquires a save lock to ensure thread safety and checks if user settings are already loaded.\\nIf not, it returns. Otherwise, it removes the user settings from the user store.\"\"\"\n    with self._save_lock:\n      if not self._loaded:\n        return\n      del self._data[user]\n      self._store.save(self._data)\n\n  def _async_update(self, user: str, setting: str, value: str) -> None:\n    \"\"\"The function \"_async_update\" asynchronously updates user data.\\nIt acquires a save lock to ensure thread safety and checks if user settings are already loaded.\\nIf not, it returns. Otherwise, it updates the user settings in the user store.\"\"\"\n    with self._save_lock:\n      if not self._loaded:\n        return\n      if user not in self._data:\n        self._data[user] = NotifySetting(user, {})\n      self._data[user][setting] = value\n      self._store.save(self._data)\n\n  def _async_add(self, user: str, setting: str, value: str) -> None:\n    \"\"\"The function \"_async_add\" asynchronously adds user data.\\nIt acqu", "CodeBleu_score": 30.29367056105332}, {"code": "async def _async_load(self) -> None\n    if self._initialized:\n      return\n    self._initialized = True\n    self._lock.acquire()\n    if not self._loaded:\n      self._loaded = True\n      try:\n        if self._store.get_user_data(self._user_id) is not None:\n          data = self._store.get_user_data(self._user_id)\n          self._settings = {}\n          for user in data:\n            self._settings[user] = NotifySetting(user, data[user])\n      except Exception as e:\n        self._logger.error(f\"Failed to load user data: {e}\")\n        self._settings = {}\n    self._lock.release()\n\n  def _async_save(self) -> None:\n    \"\"\"The function \"_async_save\" asynchronously saves user data.\\nIt acquires an initialization lock to ensure thread safety and checks if user settings are already loaded.\\nIf not, it attempts to load data from the user store.\\nIf the data is empty, it initializes an empty dictionary for user settings.\\nIt then populates the user settings by creating \"NotifySetting\" objects for each user based on the loaded data.\"\"\"\n    if not self._initialized:\n      return\n    self._lock.acquire()\n    if self._loaded:\n      self._loaded = False\n      try:\n        data = {}\n        for user in self._settings:\n          data[user] = self._settings[user].get_data()\n        self._store.set_user_data(self._user_id, data)\n      except Exception as e:\n        self._logger.error(f\"Failed to save user data: {e}\")\n    self._lock.release()\n\n  def _get_setting(self, user: str) -> NotifySetting:\n    \"\"\"The function \"_get_setting\" returns the \"NotifySetting\" object for the given user.\\nIf the user is not in the settings, a new \"NotifySetting\" object is created for the user.\"\"\"\n    if user in self._settings:\n      return self._settings[user]\n    else:\n      self._settings[user] = NotifySetting(user)\n      return self._settings[user]\n\n", "CodeBleu_score": 26.499185668048597}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\"\"\"\n\n", "CodeBleu_score": 13.273694390715669}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\"\"\"\n\n", "CodeBleu_score": 13.273694390715669}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\"\"\"\n", "CodeBleu_score": 13.273694390715669}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    area_entry = perm_lookup.get_area(area_id)\n    if not area_entry:\n        return None\n    return area_dict.get(area_entry.area_id)\n\n", "CodeBleu_score": 53.191021834431886}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 47.22039460883292}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.get_entity_entry(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.get_device_entry(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    if not device_entry.area_id:\n        return None\n\n    area_id = device_entry.area_id\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.092603343707054}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    policy = {}\n    seen = set()\n    for p in policies:\n        for cat in p:\n            if cat not in seen:\n                seen.add(cat)\n                policy[cat] = p[cat]\n    return PolicyType(policy)\n\n", "CodeBleu_score": 27.460941586762555}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                merged_policy[category] = policy[category]\n                seen_categories.add(category)\n            else:\n                merged_policy[category].update(policy[category])\n    return merged_policy\n\n", "CodeBleu_score": 52.56412716273642}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    new_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                new_policy[category] = policy[category]\n            else:\n                new_policy[category].update(policy[category])\n    return new_policy\n\n", "CodeBleu_score": 46.43994959976835}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        return importlib.import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Unable to import auth provider %s\", provider)\n        raise HomeAssistantError(f\"Unable to import auth provider {provider}\")\n\n", "CodeBleu_score": 14.948223692161703}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError:\n        raise HomeAssistantError(f\"Unable to load auth provider {provider}\")\n\n    if not hasattr(module, \"async_setup_auth\"):\n        raise HomeAssistantError(f\"Auth provider {provider} does not have async_setup_auth\")\n\n    return module\n\n", "CodeBleu_score": 23.644815092423986}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError:\n        _LOGGER.error(\"Unable to load auth provider %s\", provider)\n        raise HomeAssistantError(f\"Unable to load auth provider {provider}\")\n\n    return module\n\n", "CodeBleu_score": 21.450685720596447}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n    try:\n      with open(self.file_path, \"r\") as f:\n        self.users = json.load(f)\n    except FileNotFoundError:\n      self.users = []\n    for user in self.users:\n      if user[\"username\"] not in user[\"normalized_username\"]:\n        user[\"normalized_username\"] = user[\"username\"]\n\n  def _save(self) -> None:\n    \"\"\"The function \"_save\" saves the users list to the store.\"\"\"\n    with open(self.file_path, \"w\") as f:\n      json.dump(self.users, f)\n\n  def _get_user(self, username: str) -> dict:\n    \"\"\"The function \"_get_user\" returns the user data for a given username.\"\"\"\n    for user in self.users:\n      if user[\"username\"] == username:\n        return user\n    return None\n\n  def _get_user_by_id(self, user_id: str) -> dict:\n    \"\"\"The function \"_get_user_by_id\" returns the user data for a given user ID.\"\"\"\n    for user in self.users:\n      if user[\"id\"] == user_id:\n        return user\n    return None\n\n  def _get_user_by_normalized_username(self, normalized_username: str) -> dict:\n    \"\"\"The function \"_get_user_by_normalized_username\" returns the user data for a given normalized username.\"\"\"\n    for user in self.users:\n      if user[\"normalized_username\"] == normalized_username:\n        return user\n    return None\n\n  def _add_user(self, user: dict) -> None:\n    \"\"\"The function \"_add_user\" adds a user to the users list.\"\"\"\n    self.users.append(user)\n\n  def _delete_user(self, user_id: str) -> None:\n    \"\"\"The function \"_delete_user\" deletes a user from the users list.\"\"\"\n    for user in self.users:\n      if user[\"id\"] == user_id:\n        self.users.remove(user)\n\n  def _update_user(self, user_id: str", "CodeBleu_score": 23.21979110544005}, {"code": "async def async_load(self) -> None\n    try:\n      with open(self.store_path, \"r\") as store:\n        self.users = json.load(store)\n        for user in self.users:\n          if not user[\"username\"] == user[\"username\"].lower():\n            self.users[self.users.index(user)][\"username\"] = user[\"username\"].lower()\n    except FileNotFoundError:\n      self.users = []\n\n  def async_save(self) -> None:\n    \"\"\"The function \"async_save\" asynchronously saves user data.\\nIt serializes the users list and writes it to the store.\"\"\"\n    with open(self.store_path, \"w\") as store:\n      json.dump(self.users, store)\n\n  def add_user(self, username: str, password: str) -> None:\n    \"\"\"The function \"add_user\" adds a user to the users list.\\nIt checks if the username is already in use and if the password is not empty.\\nIt then adds the user to the users list and saves the data.\"\"\"\n    if username in [user[\"username\"] for user in self.users]:\n      raise UsernameTakenException\n    elif password == \"\":\n      raise EmptyPasswordException\n    else:\n      self.users.append({\n        \"username\": username,\n        \"password\": password\n      })\n      self.async_save()\n\n  def remove_user(self, username: str) -> None:\n    \"\"\"The function \"remove_user\" removes a user from the users list.\\nIt checks if the username is in use and if it is not the last user.\\nIt then removes the user from the users list and saves the data.\"\"\"\n    if username not in [user[\"username\"] for user in self.users]:\n      raise UsernameNotFoundException\n    elif len(self.users) == 1:\n      raise LastUserException\n    else:\n      self.users.remove(next(user for user in self.users if user[\"username\"] == username))\n      self.async_save()\n\n  def change_password(self, username: str, password: str) -> None:\n    \"\"\"The function \"change_password\" changes the password of a user.\\nIt checks if the username is", "CodeBleu_score": 23.084881804733442}, {"code": "async def async_load(self) -> None\n    try:\n      with open(self.path, 'r') as file:\n        self.data = json.load(file)\n    except FileNotFoundError:\n      self.data = {}\n      with open(self.path, 'w') as file:\n        json.dump(self.data, file)\n    self.users = self.data.get('users', [])\n    self.normalize()\n\n  def normalize(self) -> None:\n    \"\"\"The function \"normalize\" normalizes usernames in the loaded data.\\nIt iterates over the loaded data and normalizes usernames if they are not normalized.\"\"\"\n    for user in self.users:\n      if not user['username'].islower():\n        self.users[self.users.index(user)]['username'] = user['username'].lower()\n    self.data['users'] = self.users\n\n  def save(self) -> None:\n    \"\"\"The function \"save\" saves the users data to the store.\\nIt first normalizes the data and then saves it to the store.\"\"\"\n    self.normalize()\n    with open(self.path, 'w') as file:\n      json.dump(self.data, file)\n\n  def get_user(self, username: str) -> dict:\n    \"\"\"The function \"get_user\" gets the user with the specified username.\\nIt returns the user if found and None if not found.\"\"\"\n    for user in self.users:\n      if user['username'] == username.lower():\n        return user\n    return None\n\n  def add_user(self, username: str, password: str) -> None:\n    \"\"\"The function \"add_user\" adds a user to the store.\\nIt first checks if the username is already taken and returns if it is.\\nIt then hashes the password and adds the user to the store.\"\"\"\n    if self.get_user(username):\n      return\n    hashed_password = hashlib.sha256(password.encode('utf-8')).hexdigest()\n    self.users.append({'username': username.lower(), 'password': hashed_password})\n    self.save()\n\n  def delete_user(self, username:", "CodeBleu_score": 27.5349416524734}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = user[\"password\"]\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            raise InvalidAuth\n    raise InvalidAuth\n", "CodeBleu_score": 34.99857124156749}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            password_hash = user[\"password_hash\"]\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    raise InvalidAuth(\"Invalid username\")\n\n", "CodeBleu_score": 36.133313623153114}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = normalize_username(username)\n    dummy_hash = hash_password(password)\n    for user in self.users:\n        if user.username == username:\n            stored_password_hash = user.password_hash\n            if verify_password(password, stored_password_hash):\n                return\n            else:\n                raise InvalidAuth()\n    raise InvalidAuth()\n\n", "CodeBleu_score": 29.70290565731237}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n    username = normalize_username(username)\n    if username in self.users:\n        del self.users[username]\n    else:\n        raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 20.758332295049204}, {"code": "def async_remove_auth(self, username: str) -> None\n    try:\n        username = normalize_username(username)\n        if username in self.users:\n            del self.users[username]\n        else:\n            raise InvalidUser(\"user_not_found\")\n    except Exception as e:\n        raise e\n\n", "CodeBleu_score": 30.045510327401548}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = self.normalize(username)\n    for i in range(len(self.users)):\n        if self.users[i][0] == username:\n            del self.users[i]\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 29.844330432054445}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    self.async_initialize_credentials()\n    try:\n        self.credentials.remove(credentials)\n        self.async_save_credentials()\n    except ValueError:\n        pass\n", "CodeBleu_score": 35.495501387628806}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.data:\n        await self.async_initialize_data()\n    if credentials.username in self.data:\n        del self.data[credentials.username]\n        await self.async_save_data()\n\n    # If the credentials were invalid, it will not be in the data.\n    # So we can safely ignore the exception.\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 45.56041575357135}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.credentials_file.exists():\n        self.async_initialize_credentials()\n    try:\n        self.credentials_file.remove_credentials(credentials.username)\n        self.credentials_file.save_credentials()\n    except InvalidUsernameException:\n        pass\n\n", "CodeBleu_score": 47.20845559840167}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    if log:\n        print(\"Waiting for threads to finish...\")\n    joined_threads = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        if not thread.ident:\n            joined_threads.add(thread)\n            continue\n        thread_timeout = timeout - time.time()\n        if thread_timeout <= 0:\n            joined_threads.add(thread)\n            continue\n        try:\n            thread.join(thread_timeout)\n            joined_threads.add(thread)\n        except TimeoutError:\n            pass\n    if log:\n        for thread in threads:\n            if thread.is_alive():\n                print(f\"Thread {thread.name} is still running...\")\n    for thread in threads:\n        if not thread.is_alive():\n            continue\n        if not thread.ident:\n            continue\n        try:\n            thread.raise_exception()\n        except SystemExit:\n            pass\n    return joined_threads\n\n", "CodeBleu_score": 41.02660251448196}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        timeout_thread = threading.Timer(\n            timeout, interrupt_thread, args=(thread,)\n        )\n        timeout_thread.start()\n        try:\n            thread.join(timeout=timeout)\n        except (SystemExit, KeyboardInterrupt):\n            raise\n        except:\n            pass\n        timeout_thread.cancel()\n        if thread.is_alive():\n            if log:\n                print(f\"Thread {thread.name} still running\")\n        else:\n            joined.add(thread)\n    try:\n        for thread in threads:\n            if thread.ident:\n                interrupt_thread(thread)\n    except (SystemExit, KeyboardInterrupt):\n        raise\n    except:\n        pass\n    return joined\n\n", "CodeBleu_score": 44.93273845058684}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined_threads = set()\n    for thread in threads:\n        if thread.ident is None:\n            joined_threads.add(thread)\n            continue\n        try:\n            thread.join(timeout=timeout)\n        except Exception as e:\n            if log:\n                print(f\"Thread {thread.name} has not finished after {timeout} seconds.\")\n            thread.interrupt()\n        else:\n            joined_threads.add(thread)\n    try:\n        raise SystemExit\n    except SystemExit:\n        for thread in threads:\n            if thread.ident is None:\n                joined_threads.add(thread)\n                continue\n            if thread.is_alive():\n                if log:\n                    print(f\"Thread {thread.name} has not finished after {timeout} seconds.\")\n                thread.interrupt()\n    return joined_threads\n\n", "CodeBleu_score": 42.37337910203033}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n    if not is_main_thread():\n        raise RuntimeError(\"deadlock_safe_shutdown() must be called from the main thread.\")\n    if not is_shutdown_thread():\n        raise RuntimeError(\"deadlock_safe_shutdown() must be called from a shutdown thread.\")\n    if not is_shutdown_thread_alive():\n        raise RuntimeError(\"deadlock_safe_shutdown() must be called from an alive shutdown thread.\")\n    if not is_shutdown_thread_daemon():\n        raise RuntimeError(\"deadlock_safe_shutdown() must be called from a daemon shutdown thread.\")\n    if not is_shutdown_thread_main():\n        raise RuntimeError(\"deadlock_safe_shutdown() must be called from a non-main shutdown thread.\")\n\n    # Get the total shutdown timeout\n    total_shutdown_timeout = get_shutdown_timeout()\n\n    # Get the number of remaining threads\n    remaining_thread_count = get_remaining_thread_count()\n\n    # Calculate the timeout for each thread\n    timeout = total_shutdown_timeout / remaining_thread_count\n\n    # Get the list of non-main, non-daemon, alive threads\n    threads = get_non_main_non_daemon_alive_threads()\n\n    # Join each thread within the calculated timeout\n    for thread in threads:\n        try:\n            thread.join(timeout=timeout)\n        except Exception as e:\n            print(f\"Warning: Failed to join thread {thread.name}: {e}\")\n\n", "CodeBleu_score": 20.748698349553923}, {"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import time\n\n    def get_thread_timeout(thread: threading.Thread) -> float:\n        \"\"\"The function \"get_thread_timeout\" calculates a timeout for a thread based on the total shutdown timeout divided by the number of remaining threads.\"\"\"\n        remaining_threads = threading.enumerate()\n        remaining_threads.remove(thread)\n        remaining_threads.remove(threading.main_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove(threading.current_thread())\n        remaining_threads.remove", "CodeBleu_score": 16.396661277365904}, {"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import time\n    import logging\n    import sys\n    import traceback\n\n    def _deadlock_safe_shutdown(timeout: float) -> None:\n        \"\"\"The function \"_deadlock_safe_shutdown\" performs a shutdown that avoids deadlocks.\\nIt identifies all non-main, non-daemon, alive threads and calculates a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\\nIt then attempts to join each thread within the calculated timeout and logs a warning if joining a thread fails.\"\"\"\n        threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon and t.is_alive()]\n        for t in threads:\n            try:\n                t.join(timeout=timeout / len(threads))\n            except Exception as e:\n                logging.warning(f\"Failed to join thread {t}: {e}\")\n                traceback.print_exc(file=sys.stderr)\n\n    def _deadlock_safe_shutdown_thread() -> None:\n        \"\"\"The function \"_deadlock_safe_shutdown_thread\" performs a shutdown that avoids deadlocks.\\nIt identifies all non-main, non-daemon, alive threads and calculates a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\\nIt then attempts to join each thread within the calculated timeout and logs a warning if joining a thread fails.\"\"\"\n        import signal\n        import time\n        import logging\n        import sys\n        import traceback\n\n        def _deadlock_safe_shutdown(timeout: float) -> None:\n            \"\"\"The function \"_deadlock_safe_shutdown\" performs a shutdown that avoids deadlocks.\\nIt identifies all non-main, non-daemon, alive threads and calculates a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\\nIt then attempts to join each thread within the calculated timeout and logs a warning if joining a thread fails.\"\"\"\n            threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.", "CodeBleu_score": 46.25232262050607}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if not self._remaining_setups or remaining_with_setup_started:\n      self._remaining_setups = remaining_with_setup_started\n      self._dispatcher.emit(self._remaining_setups)\n\n  def _async_dispatch_setup_started(self, setup_name: str, setup_started_time: float) -> None:\n    \"\"\"The function \"_async_dispatch_setup_started\" dispatches a signal with the setup name and the time at which it started.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._remaining_setups = {**self._remaining_setups, setup_name: setup_started_time}\n    self._dispatcher.emit(self._remaining_setups)\n\n  def _async_dispatch_setup_finished(self, setup_name: str, setup_finished_time: float) -> None:\n    \"\"\"The function \"_async_dispatch_setup_finished\" dispatches a signal with the setup name and the time at which it finished.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._remaining_setups = {**self._remaining_setups, setup_name: setup_finished_time}\n    self._dispatcher.emit(self._remaining_setups)\n\n  def _async_dispatch_setup_failed(self, setup_name: str, setup_failed_time: float) -> None:\n    \"\"\"The function \"_async_dispatch_setup_failed\" dispatches a signal with the setup name and the time at which it failed.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._remaining_setups = {**self._remaining_setups, setup_name: setup_failed_time}\n    self._dispatcher.emit(self._remaining_setups)\n\n  def _async_dispatch_setup_finished_or_failed(self, setup_name: str, setup_finished_or_failed_time: float) -> None:\n    \"\"\"The function \"_async_dispatch_setup_finished_or_failed\" dispatches a signal with the setup name and", "CodeBleu_score": 38.26395266489729}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n      if remaining_with_setup_started:\n        self._dispatch_signal(remaining_with_setup_started)\n      self._remaining_with_setup_started = {}\n    else:\n      self._remaining_with_setup_started = {}\n\n  def _dispatch_signal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_dispatch_signal\" dispatches a signal based on the state of remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._signal_dispatcher.dispatch_signal(remaining_with_setup_started)\n\n  def _dispatch_signal_async(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_dispatch_signal_async\" dispatches a signal based on the state of remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._signal_dispatcher.dispatch_signal_async(remaining_with_setup_started)\n\n  def _dispatch_signal_async_with_callback(self, remaining_with_setup_started: dict[str, float], callback: Callable[[], None]) -> None:\n    \"\"\"The function \"_dispatch_signal_async_with_callback\" dispatches a signal based on the state of remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._signal_dispatcher.dispatch_signal_async_with_callback(remaining_with_setup_started, callback)\n\n  def _dispatch_signal_async_with_callback_and_args(self, remaining_with_setup_started: dict[str, float], callback: Callable[[], None], *args: Any) -> None:\n    \"\"\"The function \"_dispatch_signal_async_with_callback_and_args\" dispatches a signal based on the state of remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._signal_dispatcher.dispatch_signal_async_with_callback_and_args(rem", "CodeBleu_score": 44.02043484573916}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if self._remaining_setups or remaining_with_setup_started:\n      self._remaining_setups = remaining_with_setup_started\n      self._dispatch_signal.emit(remaining_with_setup_started)\n    else:\n      self._remaining_setups = {}\n\n  def _setup_finished(self, setup_name: str) -> None:\n    \"\"\"The function \"_setup_finished\" is called when a setup has finished.\\nIt removes the setup from the internal dictionary of remaining setups.\"\"\"\n    if setup_name in self._remaining_setups:\n      del self._remaining_setups[setup_name]\n    self._async_dispatch(self._remaining_setups)\n\n  def _setup_failed(self, setup_name: str) -> None:\n    \"\"\"The function \"_setup_failed\" is called when a setup has failed.\\nIt removes the setup from the internal dictionary of remaining setups.\"\"\"\n    if setup_name in self._remaining_setups:\n      del self._remaining_setups[setup_name]\n    self._async_dispatch(self._remaining_setups)\n\n  def _setup_started(self, setup_name: str) -> None:\n    \"\"\"The function \"_setup_started\" is called when a setup has started.\\nIt adds the setup to the internal dictionary of remaining setups.\"\"\"\n    self._remaining_setups[setup_name] = time.time()\n    self._async_dispatch(self._remaining_setups)\n\n  def _setup_aborted(self, setup_name: str) -> None:\n    \"\"\"The function \"_setup_aborted\" is called when a setup has been aborted.\\nIt removes the setup from the internal dictionary of remaining setups.\"\"\"\n    if setup_name in self._remaining_setups:\n      del self._remaining_setups[setup_name]\n    self._async_dispatch(self._remaining_setups)\n\n  def _setup_interrupted(self, setup_name: str) -> None:\n    \"\"\"The function \"_setup_interrupted\" is called when a setup has been interrupted.\\nIt removes the setup", "CodeBleu_score": 36.53895502507773}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # Read the current content of bluetooth.py\n    current_bluetooth_content = read_bluetooth_py(config)\n    # Generate the content of bluetooth.py\n    bluetooth_content = generate_bluetooth_content(integrations)\n    # Check if the generated content is up to date\n    if bluetooth_content == current_bluetooth_content:\n        # If the content is up to date, exit the function\n        return\n    # If the content is not up to date, add an error to the configuration\n    config.add_error(\n        \"bluetooth.py is not up to date\",\n        \"bluetooth.py is not up to date. Please run 'hass-config-util fix bluetooth' to fix the issue.\",\n    )\n\n", "CodeBleu_score": 34.13835898802536}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\n    # Get the current content of bluetooth.py\n    current_bluetooth_content = get_current_bluetooth_content()\n\n    # Get the current content of bluetooth.py from the configuration cache\n    current_bluetooth_content_from_cache = get_bluetooth_content_from_cache()\n\n    # Generate the bluetooth content\n    generated_bluetooth_content = generate_bluetooth_content(integrations, config)\n\n    # Compare the current content of bluetooth.py with the generated content\n    if current_bluetooth_content != generated_bluetooth_content:\n        # The current content of bluetooth.py is not up to date\n        # Add an error to the configuration\n        config.add_error(\n            \"The current content of bluetooth.py is not up to date. Please run `make generate` to update it.\"\n        )\n\n        # If the current content of bluetooth.py is not up to date and the current content of bluetooth.py from the configuration cache is not empty, then we can provide a fixable suggestion\n        if current_bluetooth_content_from_cache != \"\":\n            # Add a fixable suggestion to the configuration\n            config.add_fixable_suggestion(\n                \"Update bluetooth.py\",\n                \"Please run `make generate` to update bluetooth.py.\",\n            )\n\n    # Store the generated bluetooth content in the configuration cache\n    set_bluetooth_content_in_cache(generated_bluetooth_content)\n\n", "CodeBleu_score": 36.28394230265665}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # Get the current bluetooth.py content\n    current_content = config.get_bluetooth_content()\n    # Generate the bluetooth.py content\n    generated_content = generate_bluetooth_content(integrations)\n    # Compare the generated content with the current content\n    if current_content != generated_content:\n        # The contents differ, so bluetooth.py is not up to date\n        # Add an error to the configuration\n        config.add_error(\n            \"bluetooth.py is not up to date. Please run 'hass-config-util bluetooth' to update it.\"\n        )\n        # Add a fixable suggestion to the configuration\n        config.add_suggestion(\n            \"bluetooth.py is not up to date. Please run 'hass-config-util bluetooth' to update it.\",\n            \"bluetooth\",\n            \"Run 'hass-config-util bluetooth'\",\n        )\n    else:\n        # The contents are the same, so bluetooth.py is up to date\n        # Remove the error from the configuration\n        config.remove_error(\"bluetooth.py is not up to date.\")\n        # Remove the fixable suggestion from the configuration\n        config.remove_suggestion(\n            \"bluetooth.py is not up to date. Please run 'hass-config-util bluetooth' to update it.\"\n        )\n\n", "CodeBleu_score": 39.011948458069604}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error\t// The Dropbox OAuth2 token endpoint.\n\ttokenEndpoint := \"https://api.dropbox.com/oauth2/token\"\n\n\t// The HTTP client.\n\tclient := &http.Client{}\n\n\t// The POST request.\n\treq, err := http.NewRequest(\"POST\", tokenEndpoint, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers.\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// The request body.\n\treqBody := url.Values{}\n\treqBody.Set(\"grant_type\", \"refresh_token\")\n\treqBody.Set(\"refresh_token\", d.refreshToken)\n\treqBody.Set(\"client_id\", d.appKey)\n\treqBody.Set(\"client_secret\", d.appSecret)\n\treq.Body = ioutil.NopCloser(strings.NewReader(reqBody.Encode()))\n\n\t// The response.\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// The response body.\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// The response JSON.\n\tvar tokenResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tScope       string `json:\"scope\"`\n\t\tError       string `json:\"error\"`\n\t\tErrorDesc   string `json:\"error_description\"`\n\t}\n\n\t// Unmarshal the response body into the response struct.\n\terr = json.Unmarshal(body, &tokenResponse)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check for errors.\n\tif tokenResponse.Error != \"\" {\n\t\treturn fmt.Errorf(\"Error: %s\\nDescription: %s\", tokenResponse.Error, tokenResponse.ErrorDesc)\n\t}\n\n\t// Update the access token.\n\t", "CodeBleu_score": 47.13034531875727}, {"code": "func (d *Dropbox) refreshToken() error\t// Create a new request.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/2/auth/token/from_refresh_token\", nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the headers.\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Create the body.\n\tbody := url.Values{}\n\tbody.Add(\"grant_type\", \"refresh_token\")\n\tbody.Add(\"refresh_token\", d.refreshToken)\n\tbody.Add(\"client_id\", d.appKey)\n\tbody.Add(\"client_secret\", d.appSecret)\n\n\t// Set the body.\n\treq.Body = ioutil.NopCloser(strings.NewReader(body.Encode()))\n\n\t// Send the request.\n\tres, err := d.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\t// Read the response.\n\tbody, err = ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Parse the response.\n\tvar response struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t}\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Update the access token.\n\td.accessToken = response.AccessToken\n\td.expiresIn = response.ExpiresIn\n\n\t// Return the response.\n\treturn nil\n}\n", "CodeBleu_score": 48.50801360419682}, {"code": "func (d *Dropbox) refreshToken() error\t// Get the access token\n\taccessToken := d.GetAccessToken()\n\t// Get the refresh token\n\trefreshToken := d.GetRefreshToken()\n\t// Get the app key\n\tappKey := d.GetAppKey()\n\t// Get the app secret\n\tappSecret := d.GetAppSecret()\n\n\t// Create the form data\n\tform := url.Values{}\n\tform.Add(\"grant_type\", \"refresh_token\")\n\tform.Add(\"refresh_token\", refreshToken)\n\tform.Add(\"client_id\", appKey)\n\tform.Add(\"client_secret\", appSecret)\n\n\t// Create the request\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(form.Encode()))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Get the response\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Unmarshal the response\n\tvar response struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tScope       string `json:\"scope\"`\n\t\tError       string `json:\"error\"`\n\t\tErrorDesc   string `json:\"error_description\"`\n\t}\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check for errors\n\tif response.Error != \"\" {\n\t\treturn fmt.Errorf(\"Dropbox error: %s\", response.ErrorDesc)\n\t}\n\n\t// Update the access token\n\td.SetAccessToken(response.AccessToken)\n\td.SetExpiresIn(response", "CodeBleu_score": 46.313141725509645}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\tvar (\n\t\terr    error\n\t\tresult []byte\n\t)\n\tfor i := 0; i < 3; i++ {\n\t\tresult, err = d.requestOnce(url, method, callback, resp)\n\t\tif err == nil {\n\t\t\treturn result, nil\n\t\t}\n\t\tif !d.isTokenExpired(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err = d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nil, err\n}\n", "CodeBleu_score": 33.82742434153806}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\t// Check if the request is to a Google Drive URL.\n\tif !strings.HasPrefix(url, \"https://drive.google.com\") {\n\t\treturn nil, fmt.Errorf(\"invalid Google Drive URL: %s\", url)\n\t}\n\n\t// Create the request.\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the authorization header.\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.accessToken)\n\n\t// Set the parameters for supporting all drives.\n\treq.Header.Set(\"X-Goog-AuthUser\", \"0\")\n\treq.Header.Set(\"X-Goog-Encode-Response-If-Executable\", \"base64\")\n\n\t// Customize the request.\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\t// Send the request.\n\tresp, err := d.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Handle the response.\n\tif resp.StatusCode == http.StatusUnauthorized {\n\t\t// Refresh the token.\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Retry the request.\n\t\treturn d.request(url, method, callback, resp)\n\t} else if resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected HTTP status code: %d\", resp.StatusCode)\n\t}\n\n\t// Set the result.\n\tif resp != nil {\n\t\tif err := json.NewDecoder(resp.Body).Decode(resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Return the response body.\n\treturn ioutil.ReadAll(resp.Body)\n}\n", "CodeBleu_score": 58.38293882998079}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\tvar err error\n\tvar body []byte\n\tvar req *http.Request\n\tvar respBody []byte\n\tvar respStatus int\n\tvar respHeader http.Header\n\tvar retry bool\n\tvar retryCount int\n\tvar retryDelay time.Duration\n\n\tif callback == nil {\n\t\tcallback = func(req *http.Request) {\n\t\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\t\t\treq.Header.Set(\"X-Goog-AuthUser\", \"0\")\n\t\t\treq.Header.Set(\"X-Goog-Encode-Response-If-Executable\", \"base64\")\n\t\t\treq.Header.Set(\"X-Goog-Upload-Protocol\", \"raw\")\n\t\t}\n\t}\n\n\tif resp == nil {\n\t\tresp = &base.Response{}\n\t}\n\n\tfor {\n\t\tretry = false\n\t\tretryCount = 0\n\t\tretryDelay = 0\n\n\t\treq, err = http.NewRequest(method, url, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcallback(req)\n\n\t\trespBody, respStatus, respHeader, err = d.client.DoRequest(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif respStatus == http.StatusUnauthorized {\n\t\t\tif retryCount < 3 {\n\t\t\t\tretry = true\n\t\t\t\tretryCount++\n\t\t\t\tretryDelay = time.Duration(math.Pow(2, float64(retryCount))) * time.Second\n\t\t\t\ttime.Sleep(retryDelay)\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, errors.New(\"unauthorized\")\n\t\t}\n\n\t\tif respStatus == http.StatusOK {\n\t\t\tif resp != nil {", "CodeBleu_score": 46.432075937442875}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Get the file size.\n\tsize, err := stream.Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the chunk size.\n\tchunkSize := d.chunkSize(size)\n\n\t// Get the file name.\n\tname, err := stream.Name()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the file MIME type.\n\tmimeType, err := stream.MimeType()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the parent ID.\n\tparentID, err := d.getParentID(ctx, stream)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create the file.\n\tfile := &drive.File{\n\t\tName:     name,\n\t\tMimeType: mimeType,\n\t\tParents:  []string{parentID},\n\t}\n\n\t// Create the file.\n\tfile, err = d.service.Files.Create(file).SupportsTeamDrives(true).Fields(\"id\").Do()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Upload the file in chunks.\n\tfor i := 0; i < int(size/chunkSize); i++ {\n\t\t// Check for context cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Get the chunk.\n\t\tchunk, err := stream.Chunk(i, chunkSize)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Upload the chunk.\n\t\t_, err = d.uploadChunk(ctx, url, file.Id, i, chunk)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Check for the last chunk.\n\tif size%chunkSize != 0 {\n\t\t// Check for context cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n", "CodeBleu_score": 40.788412133155575}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate the chunk size\n\tchunkSize, err := d.chunkSize(ctx, stream)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Upload the file in chunks\n\tfor {\n\t\t// Get the next chunk\n\t\tchunk, err := stream.NextChunk()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Upload the chunk\n\t\tif err := d.uploadChunk(ctx, url, chunk, chunkSize); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Complete the upload\n\tif err := d.completeUpload(ctx, stream); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 25.772565006829566}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Create a new HTTP client with the appropriate headers\n\tclient := d.newHTTPClient()\n\n\t// Get the file size\n\tsize, err := stream.Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the chunk size\n\tchunkSize := d.getChunkSize(size)\n\n\t// Get the file name\n\tname, err := stream.Name()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the MIME type\n\tmimeType, err := stream.MimeType()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the parent folder ID\n\tparent, err := stream.Parent()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the file ID\n\tid, err := stream.ID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the file description\n\tdescription, err := stream.Description()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the file visibility\n\tvisibility, err := stream.Visibility()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the file sharing\n\tsharing, err := stream.Sharing()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a new file\n\tfile := &drive.File{\n\t\tName:        name,\n\t\tMimeType:    mimeType,\n\t\tDescription: description,\n\t\tParents:     []string{parent},\n\t\tId:          id,\n\t\tVisibility:  visibility,\n\t\tSharing:     sharing,\n\t}\n\n\t// Create a new file on Google Drive\n\t_, err = d.service.Files.Create(file).Media(stream).Do()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a new progress bar\n\tprogress := d.newProgressBar(size)\n\n\t// Create a new buffer to store the chunk\n\tbuf := make([]byte, chunkSize)\n\n\t// Read the file and upload the chunks\n\tfor {\n\t\t// Check", "CodeBleu_score": 42.627597057651435}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error\t// Get the request context\n\trc := ctx.Request().Context()\n\n\t// Bind the request body to the request context\n\tvar req models.UmountStorageRequest\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Get the mount point from the request context\n\tmountPoint := ctx.Param(\"mountPoint\")\n\n\t// Check if the mount point is empty\n\tif mountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Mount point is empty\")\n\t}\n\n\t// Attempt to unmount the storage\n\tif err := umountStorage(rc, mountPoint); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the configuration\n\tif err := deleteConfig(rc, mountPoint); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, models.UmountStorageResponse{\n\t\tMountPoint: mountPoint,\n\t})\n}\n", "CodeBleu_score": 40.82652436178615}, {"code": "func UmountStorage(ctx echo.Context) error\tvar req UnmountStorageRequest\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"mount point is required\")\n\t}\n\tif err := umountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"unmounted\")\n}\n", "CodeBleu_score": 25.97010985833664}, {"code": "func UmountStorage(ctx echo.Context) error\t// Bind the request body to a struct.\n\tvar requestBody UmountStorageRequest\n\tif err := ctx.Bind(&requestBody); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\t// Validate the request data.\n\tif err := requestBody.validate(); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\t// Unmount the storage device.\n\tif err := umountStorage(requestBody.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, &UmountStorageResponse{\n\t\tMessage: \"The storage device has been unmounted.\",\n\t})\n}\n", "CodeBleu_score": 30.557619062704966}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided.\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"Path is missing\",\n\t\t})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\n\t// Open the file.\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": \"Failed to open file\",\n\t\t})\n\t}\n\tdefer file.Close()\n\n\t// Get the file size.\n\tfileInfo, _ := file.Stat()\n\tfileSize := fileInfo.Size()\n\n\t// Set the HTTP response headers.\n\tctx.Response().Header().Set(echo.HeaderContentType, echo.MIMETextPlain)\n\tctx.Response().Header().Set(echo.HeaderContentDisposition, fmt.Sprintf(\"attachment; filename=%s\", filepath.Base(filePath)))\n\tctx.Response().Header().Set(echo.HeaderContentLength, fmt.Sprintf(\"%d\", fileSize))\n\n\t// Send the file to the client.\n\t_, err = io.Copy(ctx.Response(), file)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": \"Failed to send file to client\",\n\t\t})\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 36.70904907224448}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"filePath\")\n\t// Check if the path is provided.\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The file path is missing.\"})\n\t}\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The file does not exist.\"})\n\t}\n\t// Open the file.\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The file could not be opened.\"})\n\t}\n\t// Defer the closing of the file until after the function returns.\n\tdefer file.Close()\n\t// Get the file size.\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The file size could not be obtained.\"})\n\t}\n\t// Get the mime type of the file.\n\tmimeType := mime.TypeByExtension(filepath.Ext(filePath))\n\t// Return the file to the client.\n\treturn ctx.Stream(http.StatusOK, stat.Size(), func(w io.Writer) bool {\n\t\t// Read the file content in chunks.\n\t\tbuffer := make([]byte, 1024)\n\t\tfor {\n\t\t\t// Read the next chunk of the file.\n\t\t\tn, err := file.Read(buffer)\n\t\t\tif err != nil {\n\t\t\t\t// Return a JSON response with an appropriate error message.\n\t\t\t\treturn ctx.JSON(http.StatusBadRequest, map[", "CodeBleu_score": 35.681765577348735}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\t// Check if the path is provided.\n\tif path == \"\" {\n\t\t// If the path is missing, return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The path parameter is missing.\"})\n\t}\n\t// Check if the file exists.\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\t// If the file does not exist, return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"The file does not exist.\"})\n\t}\n\t// If the file exists, return the file to the client.\n\treturn ctx.File(path)\n}\n", "CodeBleu_score": 39.94406171872949}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"missing name\")\n\t}\n\tif err := sendNotification(name, message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\"status\": \"ok\"})\n}\n", "CodeBleu_score": 54.23186252379965}, {"code": "func PostNotifyMessage(ctx echo.Context) error\t// Get the name parameter from the request context.\n\tname := ctx.Param(\"name\")\n\t// Bind the request body to a message map.\n\tmessage := map[string]string{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// Return a bad request error with the binding error message.\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\t// Send the notification using the \"name\" and \"message\".\n\tif err := SendNotification(name, message[\"message\"]); err != nil {\n\t\t// Return a bad request error with the binding error message.\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"message\": \"Notification sent successfully\",\n\t})\n}\n", "CodeBleu_score": 50.80887243606236}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.FormValue(\"name\")\n\tif name == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"missing name\")\n\t}\n\tmessage := ctx.FormValue(\"message\")\n\tif message == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"missing message\")\n\t}\n\tmessageMap := map[string]interface{}{\"message\": message}\n\tif err := ctx.Bind(messageMap); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tif err := Notify(name, messageMap); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\"status\": \"success\"})\n}\n", "CodeBleu_score": 44.942852639925114}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error\t// Get the WebSocket connection from the context\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the WebSocket connection to the list of connections\n\tconnectionsMutex.Lock()\n\tconnections = append(connections, ws)\n\tconnectionsMutex.Unlock()\n\n\t// Start the message sending service\n\tgo messageSendingService()\n\n\t// Enter the loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type and message\n\t\tlog.Printf(\"Received message: %s\", message)\n\t\tlog.Printf(\"Received message type: %d\", messageType)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tconnectionsMutex.Lock()\n\tfor i, connection := range connections {\n\t\tif connection == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\tconnectionsMutex.Unlock()\n\n\treturn nil\n}\n", "CodeBleu_score": 46.925496755489185}, {"code": "func NotifyWS(ctx echo.Context) error\t// The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(\"error upgrading websocket:\", err)\n\t\treturn err\n\t}\n\n\t// The function then enters a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"error reading websocket message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"received: %s\", message)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 40.008624189797345}, {"code": "func NotifyWS(ctx echo.Context) error\t// The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\\nThe function then enters a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\t// The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\\nThe function then enters a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\t// The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\\nThe function then enters a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\t// The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\\nThe function then enters a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\t// The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\\nThe function then enters a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\t// The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\\nThe function then enters a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\t// The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\\nThe function then enters a loop to continuously", "CodeBleu_score": 2.9266740186155165}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Declare a variable of type map[string]interface{} and set it to a new empty map.\n\t// This will be used to store the data to be returned as a JSON response.\n\tvar systemHardwareInfo map[string]interface{}\n\n\t// Create a new variable of type *cpu.InfoStat and set it to the result of calling the function \"cpu.Info\".\n\t// This will be used to store CPU information.\n\tvar cpuInfo *cpu.InfoStat\n\n\t// Create a new variable of type []*cpu.InfoStat and set it to the result of calling the function \"cpu.Info\".\n\t// This will be used to store CPU information.\n\tvar cpuInfoAll []*cpu.InfoStat\n\n\t// Create a new variable of type []*cpu.InfoStat and set it to the result of calling the function \"cpu.Info\".\n\t// This will be used to store CPU information.\n\tvar cpuInfoCache []*cpu.InfoStat\n\n\t// Create a new variable of type []*cpu.InfoStat and set it to the result of calling the function \"cpu.Info\".\n\t// This will be used to store CPU information.\n\tvar cpuInfoCores []*cpu.InfoStat\n\n\t// Create a new variable of type []*cpu.InfoStat and set it to the result of calling the function \"cpu.Info\".\n\t// This will be used to store CPU information.\n\tvar cpuInfoLogical []*cpu.InfoStat\n\n\t// Create a new variable of type []*cpu.InfoStat and set it to the result of calling the function \"cpu.Info\".\n\t// This will be used to store CPU information.\n\tvar cpuInfoProcessors []*cpu.InfoStat\n\n\t// Create a new variable of type []*cpu.InfoStat and set it to the result of calling the function \"cpu.Info\".\n\t// This will be used to store CPU information.\n\tvar cpuInfoThreads []*cpu.InfoStat\n\n\t// Create a new variable of type []*cpu.InfoStat and set it to the result of calling the function \"cpu.Info\".\n\t// This will be used to store CPU information.\n\tvar cpuInfoVendors []*cpu.InfoStat\n\n\t// Create a new variable of type []*cpu", "CodeBleu_score": 4.6185326302056104}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tvar (\n\t\terr error\n\t\t// systemHardwareInfo is the struct that will be returned as a JSON response.\n\t\tsystemHardwareInfo = new(SystemHardwareInfo)\n\t)\n\n\t// Get the system hardware information.\n\tsystemHardwareInfo, err = getSystemHardwareInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return the system hardware information as a JSON response.\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}\n", "CodeBleu_score": 16.48220946921605}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Create a new system hardware info object.\n\tsystemHardwareInfo := systemhardware.NewSystemHardwareInfo()\n\n\t// Retrieve system hardware information.\n\terr := systemHardwareInfo.GetSystemHardwareInfo()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Return system hardware information as a JSON response.\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}\n", "CodeBleu_score": 12.948083996381826}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error)\tvar services []string\n\tvar err error\n\tvar running []string\n\tvar notRunning []string\n\n\t// Get the list of services\n\tservices, err = s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Separate the services into running and not running lists\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tstatus, err := s.ServiceStatus(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif status {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the list of services\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}\n", "CodeBleu_score": 53.69066343569449}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tvar (\n\t\trunningServices []string\n\t\tnotRunningServices []string\n\t)\n\n\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif service[0] == '+' {\n\t\t\t\trunningServices = append(runningServices, service[1:])\n\t\t\t} else if service[0] == '-' {\n\t\t\t\tnotRunningServices = append(notRunningServices, service[1:])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}\n", "CodeBleu_score": 57.049403499340265}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tvar services []string\n\tvar running []string\n\tvar notRunning []string\n\n\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, service := range services {\n\t\tstatus, err := s.systemctl.GetServiceStatus(service)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif status == \"running\" {\n\t\t\trunning = append(running, service)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}\n", "CodeBleu_score": 60.179230370174885}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tvar err error\n\tvar payload []byte\n\tvar response *http.Response\n\tvar status int\n\n\tif payload, err = json.Marshal(message); err != nil {\n\t\ti.logger.Error(fmt.Sprintf(\"Failed to marshal message: %v\", err))\n\t\treturn\n\t}\n\n\tif response, err = i.client.Post(i.config.NotifyEndpoint, \"application/json\", bytes.NewReader(payload)); err != nil {\n\t\ti.logger.Error(fmt.Sprintf(\"Failed to send notification: %v\", err))\n\t\treturn\n\t}\n\n\tdefer response.Body.Close()\n\n\tif status = response.StatusCode; status != http.StatusOK {\n\t\tvar details []byte\n\n\t\tif details, err = ioutil.ReadAll(response.Body); err != nil {\n\t\t\ti.logger.Error(fmt.Sprintf(\"Failed to read response body: %v\", err))\n\t\t} else {\n\t\t\ti.logger.Error(fmt.Sprintf(\"Failed to send notification: %s\", details))\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.51835979992003}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\t// Create a new context with a timeout value of 10 seconds.\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Create a new publisher client.\n\tpublisherClient, err := i.publisherClient.Publisher(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create publisher client: %v\", err)\n\t}\n\tdefer publisherClient.Close()\n\n\t// Create a new event.\n\tevent := &pb.Event{\n\t\tName: name,\n\t\t// Set the event type to application/json.\n\t\tContentType: \"application/json\",\n\t\t// Set the event time to the current time.\n\t\tTime: timestamppb.Now(),\n\t\t// Set the event data to the JSON string of the message.\n\t\tData: &any.Any{\n\t\t\tValue: []byte(message),\n\t\t},\n\t}\n\n\t// Publish the event.\n\tresponse, err := publisherClient.PublishEvent(ctx, event)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to publish event: %v\", err)\n\t}\n\n\t// Log the result.\n\tlog.Printf(\"Published event: %s\\n\", response.String())\n}\n", "CodeBleu_score": 36.69437344592045}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\t// Serialize the message values to JSON strings.\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to serialize message values: %v\", err)\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\terr = i.bus.Publish(name, jsonMessage)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to publish event: %v\", err)\n\t\treturn\n\t}\n\n\t// Log the event.\n\tlog.Printf(\"Published event: %s\", name)\n}\n", "CodeBleu_score": 32.59451858563648}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\treturn message_bus.NewClientWithResponses(c.config.MessageBus.RuntimePath)\n}\n", "CodeBleu_score": 8.31561864274266}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses()\n\tclient.Init()\n\taddress, err := c.GetMessageBusAddress()\n\tif err != nil {\n\t\tclient.SetServer(defaultErrorMessage)\n\t} else {\n\t\tclient.SetServer(address)\n\t}\n\treturn client\n}\n", "CodeBleu_score": 32.440771517328066}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tvar err error\n\tvar address string\n\tvar client *message_bus.ClientWithResponses\n\n\tif address, err = c.GetMessageBusAddress(); err != nil {\n\t\tclient = message_bus.NewClientWithResponses(c.GetDefaultMessageBusAddress())\n\t} else {\n\t\tclient = message_bus.NewClientWithResponses(address)\n\t}\n\n\treturn client\n}\n", "CodeBleu_score": 34.98908525689272}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \":\") {\n\t\tip = strings.Split(ip, \":\")[0]\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 65.62835178732257}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 52.79684118758402}, {"code": "func GetIP(request *http.Request) string\t// Get the IP address from the \"x-forwarded-for\" header.\n\tforwarded := request.Header.Get(\"X-Forwarded-For\")\n\tif forwarded != \"\" {\n\t\t// Get the first IP address from the list.\n\t\tparts := strings.Split(forwarded, \",\")\n\t\tif len(parts) > 0 {\n\t\t\tip := strings.TrimSpace(parts[0])\n\t\t\t// Check if the IP is a loopback address.\n\t\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\t\treturn \"127.0.0.1\"\n\t\t\t}\n\t\t\treturn ip\n\t\t}\n\t}\n\t// Get the IP address from the request's remote address.\n\tip, _, err := net.SplitHostPort(request.RemoteAddr)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\t// Check if the IP is a loopback address.\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 43.88986073968312}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\tvar modulesDirPath string\n\tvar entryFilePath string\n\tvar err error\n\tvar moduleEntryFilePaths []string\n\tvar moduleEntryFilePathsJSON []byte\n\tvar moduleEntryFilePathsJSONString string\n\tvar moduleEntryFilePathsJSONBytes []byte\n\tvar moduleEntryFilePathsJSONMap map[string]interface{}\n\tvar moduleEntryFilePathsJSONArray []interface{}\n\tvar moduleEntryFilePathsJSONArrayString string\n\tvar moduleEntryFilePathsJSONArrayBytes []byte\n\tvar moduleEntryFilePathsJSONArrayMap map[string]interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMap map[string]interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArray []interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayString string\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayBytes []byte\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMap map[string]interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArray []interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayString string\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayBytes []byte\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMap map[string]interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArray []interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayString string\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayBytes []byte\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayMap map[string]interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayMapArray []interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayMapArrayString string\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayMapArrayBytes []byte\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayMapArrayMap map[string]interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayMapArrayMapArray []interface{}\n\tvar moduleEntryFilePathsJSONArrayMapMapArrayMapArrayMapArrayMapArrayMapArray", "CodeBleu_score": 4.371720462896497}, {"code": "func (c *systemService) GenreateSystemEntry()\tvar err error\n\n\t// Get the path to the modules directory\n\tmodulesDirPath := c.getModulesDirPath()\n\n\t// Get the path to the entry file\n\tentryFilePath := c.getEntryFilePath()\n\n\t// Create the modules directory if it doesn't exist\n\tif _, err = os.Stat(modulesDirPath); os.IsNotExist(err) {\n\t\terr = os.Mkdir(modulesDirPath, 0755)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"ERROR: %s\", err)\n\t\t}\n\t}\n\n\t// Create the entry file if it doesn't exist\n\tif _, err = os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t_, err = os.Create(entryFilePath)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"ERROR: %s\", err)\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tfiles, err := ioutil.ReadDir(modulesDirPath)\n\tif err != nil {\n\t\tlog.Printf(\"ERROR: %s\", err)\n\t}\n\n\t// Create an array to hold the JSON content of each entry.json file\n\tvar entryJSON []byte\n\n\t// Concatenate the content of each entry.json file into a single JSON array\n\tfor _, f := range files {\n\t\tif f.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.HasSuffix(f.Name(), \".json\") {\n\t\t\tif strings.Contains(f.Name(), \"entry\") {\n\t\t\t\tentryJSON, err = ioutil.ReadFile(modulesDirPath + \"/\" + f.Name())\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"ERROR: %s\", err)\n\t\t\t\t}\n\t\t\t\t// Append the JSON content of each entry.json file to the array\n\t\t\t\tentryJSON = append(entryJSON, []byte(\",\")...)\n\t\t\t\tentryJSON = append(entryJSON, []byte(string(entryJSON)).", "CodeBleu_score": 44.9037590464199}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Get the modules directory path from the configuration file.\n\tmodulesDirPath := c.config.GetString(\"modulesDir\")\n\t// Get the entry file path from the configuration file.\n\tentryFilePath := c.config.GetString(\"entryFile\")\n\t// Create a new system entry JSON file.\n\tfile, err := os.Create(entryFilePath)\n\tif err != nil {\n\t\t// Log the error.\n\t\tc.logger.Error(\"Error creating system entry file: \" + err.Error())\n\t\treturn\n\t}\n\t// Close the file.\n\tdefer file.Close()\n\t// Create a new JSON array.\n\tvar array []interface{}\n\t// Get the list of module directories.\n\tmoduleDirs, err := ioutil.ReadDir(modulesDirPath)\n\tif err != nil {\n\t\t// Log the error.\n\t\tc.logger.Error(\"Error reading modules directory: \" + err.Error())\n\t\treturn\n\t}\n\t// Loop through the module directories.\n\tfor _, moduleDir := range moduleDirs {\n\t\t// Get the module directory path.\n\t\tmoduleDirPath := path.Join(modulesDirPath, moduleDir.Name())\n\t\t// Get the list of module files.\n\t\tmoduleFiles, err := ioutil.ReadDir(moduleDirPath)\n\t\tif err != nil {\n\t\t\t// Log the error.\n\t\t\tc.logger.Error(\"Error reading module directory: \" + err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Loop through the module files.\n\t\tfor _, moduleFile := range moduleFiles {\n\t\t\t// Get the module file path.\n\t\t\tmoduleFilePath := path.Join(moduleDirPath, moduleFile.Name())\n\t\t\t// Check if the file is an entry file.\n\t\t\tif moduleFile.IsDir() || moduleFile.Name() != \"entry.json\" {\n\t\t\t\t// Skip the file.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Open the file.\n\t\t\tfile, err := os.Open(moduleFilePath)\n\t\t\tif err != nil {\n\t\t\t\t// Log the error", "CodeBleu_score": 38.986082581424014}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, intf := range interfaces {\n\t\tfor _, netName := range networkNames {\n\t\t\tif intf.Name == netName {\n\t\t\t\treturn intf.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"Could not find a network interface with a matching name\")\n}\n", "CodeBleu_score": 64.58536756327935}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tvar macAddress string\n\tvar err error\n\t// Get a list of network interfaces:\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Get a list of network names:\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Iterate over the interfaces:\n\tfor _, iface := range ifaces {\n\t\t// Iterate over the network names:\n\t\tfor _, networkName := range networkNames {\n\t\t\t// Check if the interface name matches the network name:\n\t\t\tif iface.Name == networkName {\n\t\t\t\t// Get the MAC address:\n\t\t\t\tmacAddress = iface.HardwareAddr.String()\n\t\t\t\t// Return the MAC address:\n\t\t\t\treturn macAddress, nil\n\t\t\t}\n\t\t}\n\t}\n\t// Return an error if no matching interface is found:\n\treturn \"\", errors.New(\"no matching network interface found\")\n}\n", "CodeBleu_score": 61.4838844735183}, {"code": "func (c *systemService) GetMacAddress() (string, error) \t// Get a list of network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names, returning the MAC address of the first matching interface\n\tfor _, iface := range interfaces {\n\t\tfor _, networkName := range networkNames {\n\t\t\tif iface.Name == networkName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return an error if no matching interface is found\n\treturn \"\", fmt.Errorf(\"could not find a matching network interface\")\n}\n", "CodeBleu_score": 64.02638334020803}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t iRet = 0;\n\tint32_t iTscObjIdx = 0;\n\tint32_t iRequestIdx = 0;\n\tSTscObj *pTscObjIter = NULL;\n\tSRequestObj *pRequestIter = NULL;\n\tSRequestObj *pRequestNew = NULL;\n\tSRequestObj *pRequestLast = NULL;\n\tSRequestObj *pRequestFirst = NULL;\n\tSRequestObj *pRequestIterPrev = NULL;\n\tSRequestObj *pRequestIterNext = NULL;\n\tSRequestObj *pRequestIterNextPrev = NULL;\n\tSRequestObj *pRequestIterNextNext = NULL;\n\tSRequestObj *pRequestIterNextNextPrev = NULL;\n\tSTscObj *pTscObjFirst = NULL;\n\tSTscObj *pTscObjLast = NULL;\n\tSTscObj *pTscObjNew = NULL;\n\tSTscObj *pTscObjPrev = NULL;\n\tSTscObj *pTscObjNext = NULL;\n\tSTscObj *pTscObjNextPrev = NULL;\n\tSTscObj *pTscObjNextNext = NULL;\n\tSTscObj *pTscObjNextNextPrev = NULL;\n\tSTscObj *pTscObjIterPrev = NULL;\n\tSTscObj *pTscObjIterNext = NULL;\n\tSTscObj *pTscObjIterNextPrev = NULL;\n\tSTscObj *pTscObjIterNextNext = NULL;\n\tSTscObj *pTscObjIterNextNextPrev = NULL;\n\tSTscObj *pTscObjIterPrevPrev = NULL;\n\tSTscObj *pTscObjIterNextNextNext = NULL;\n\tSTscObj *pTscObjIterNextNextNextPrev = NULL;\n\tSTscObj *pTscObjIterNextNextNextNext = NULL;\n\tSTscObj *pTscObjIterNextNextNextNextPrev = NULL;\n\tSTscObj *pTscObjIterNextNextNextNextNext = NULL;\n\tSTscObj *pTscObjIterNextNextNextNextNextPrev = NULL;\n", "CodeBleu_score": 6.1162810777202505}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t ret = 0;\n\tSAppInfo *pAppInfo = NULL;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tret = -1;\n\t\tgoto end;\n\t}\n\n\tpRequest->pTscObj = pTscObj;\n\tpRequest->pAppInfo = pTscObj->pAppInfo;\n\n\tif (pRequest->pAppInfo != NULL) {\n\t\tpAppInfo = pRequest->pAppInfo;\n\t\tpAppInfo->nRequests++;\n\t\tpAppInfo->nCurrentRequests++;\n\t\tpAppInfo->nTotalRequests++;\n\t}\n\n\tpTscObj->nRequests++;\n\tpTscObj->nCurrentRequests++;\n\tpTscObj->nTotalRequests++;\n\n\tret = 1;\n", "CodeBleu_score": 32.11647122667421}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)    int32_t nRet = 0;\n\n    // Add a reference to the request object\n    pRequest->pNext = pTscObj->pRequests;\n    pTscObj->pRequests = pRequest;\n\n    // Increment the request count for the TSC object\n    pTscObj->nRequests++;\n\n    // Update the application's request summary\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->nTotalRequests++;\n        pTscObj->pAppInfo->nCurrentRequests++;\n    }\n\n    // Log debug information about the new request\n    if (pTscObj->nDebugLevel >= 2) {\n        nRet = snprintf(pTscObj->pDebugBuf, pTscObj->nDebugBufSize,\n                        \"registerRequest: Registered request %p for TSC %p\\n\",\n                        pRequest, pTscObj);\n        if (nRet < 0) {\n            logError(pTscObj, \"registerRequest\", \"snprintf\", nRet);\n        } else if (pTscObj->nDebugLevel >= 3) {\n            nRet = writeLog(pTscObj, pTscObj->pDebugBuf, nRet);\n            if (nRet < 0) {\n                logError(pTscObj, \"registerRequest\", \"writeLog\", nRet);\n            }\n        }\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 42.67236678794909}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    char *pDb = NULL;\n    char *pDbList = NULL;\n    char *pDbName = NULL;\n    bool isExceptDb = false;\n\n    if (pRequest == NULL || exceptDb == NULL) {\n        return false;\n    }\n\n    pDb = pRequest->pDb;\n    pDbList = pRequest->pDbList;\n\n    if (pDb != NULL) {\n        if (strcmp(pDb, exceptDb) != 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    if (pDbList != NULL) {\n        pDbName = pDbList;\n        while (pDbName != NULL) {\n            if (strcmp(pDbName, exceptDb) != 0) {\n                isExceptDb = true;\n            }\n            pDbName = strchr(pDbName, ',');\n            if (pDbName != NULL) {\n                pDbName++;\n            }\n        }\n    }\n\n    return isExceptDb;\n}\n", "CodeBleu_score": 42.19913992221019}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    int i;\n    char *dbName = NULL;\n    char *tmpDbName = NULL;\n    char *tmpDbName2 = NULL;\n    char *tmpDbName3 = NULL;\n    char *tmpDbName4 = NULL;\n    char *tmpDbName5 = NULL;\n    char *tmpDbName6 = NULL;\n    char *tmpDbName7 = NULL;\n    char *tmpDbName8 = NULL;\n    char *tmpDbName9 = NULL;\n    char *tmpDbName10 = NULL;\n    char *tmpDbName11 = NULL;\n    char *tmpDbName12 = NULL;\n    char *tmpDbName13 = NULL;\n    char *tmpDbName14 = NULL;\n    char *tmpDbName15 = NULL;\n    char *tmpDbName16 = NULL;\n    char *tmpDbName17 = NULL;\n    char *tmpDbName18 = NULL;\n    char *tmpDbName19 = NULL;\n    char *tmpDbName20 = NULL;\n    char *tmpDbName21 = NULL;\n    char *tmpDbName22 = NULL;\n    char *tmpDbName23 = NULL;\n    char *tmpDbName24 = NULL;\n    char *tmpDbName25 = NULL;\n    char *tmpDbName26 = NULL;\n    char *tmpDbName27 = NULL;\n    char *tmpDbName28 = NULL;\n    char *tmpDbName29 = NULL;\n    char *tmpDbName30 = NULL;\n    char *tmpDbName31 = NULL;\n    char *tmpDbName32 = NULL;\n    char *tmpDbName33 = NULL;\n    char *tmpDbName34 = NULL;\n    char *tmpDbName35 = NULL;\n    char *tmpDbName36 = NULL;\n    char *tmpDbName37 = NULL;\n    char *tmpDbName38 = NULL;\n    char *tmpDbName39 = NULL;\n    char *tmpDbName40 = NULL;\n    char *tmpDbName41 = NULL;\n    char *tmpDbName42 = NULL;\n    char *tmp", "CodeBleu_score": 6.379779809853257}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    char *db = NULL;\n    char *p = NULL;\n    char *q = NULL;\n    int i = 0;\n    int j = 0;\n    bool result = true;\n\n    if (pRequest == NULL || exceptDb == NULL) {\n        return result;\n    }\n\n    db = pRequest->db;\n    if (db == NULL) {\n        return result;\n    }\n\n    if (strcmp(db, exceptDb) != 0) {\n        p = db;\n        while (*p != '\\0') {\n            if (*p == '.') {\n                *p = '\\0';\n                break;\n            }\n            p++;\n        }\n        if (strcmp(db, exceptDb) != 0) {\n            p = db;\n            q = db;\n            while (*p != '\\0') {\n                if (*p == '.') {\n                    *p = '\\0';\n                    if (strcmp(q, exceptDb) == 0) {\n                        result = false;\n                        break;\n                    }\n                    q = p + 1;\n                }\n                p++;\n            }\n        }\n    }\n\n    if (result) {\n        i = pRequest->db_count;\n        if (i > 0) {\n            for (j = 0; j < i; j++) {\n                db = pRequest->dbs[j];\n                if (db == NULL) {\n                    continue;\n                }\n\n                if (strcmp(db, exceptDb) != 0) {\n                    p = db;\n                    while (*p != '\\0') {\n                        if (*p == '.') {\n                            *p = '\\0';\n                            break;\n                        }\n                        p++;\n                    }\n                    if (strcmp(db, exceptDb) != 0) {\n                        p = db;\n                        q = db;\n                        while (*p != '\\0') {\n                            if (*p == '.') {\n                                *p = '\\0';\n                                if (strcmp(q, exceptDb) == 0) {\n                                    result =", "CodeBleu_score": 38.419658012874685}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    bool ret = false;\n\n    if (code == 10000) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10001) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10002) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10003) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10004) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10005) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10006) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10007) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10008) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10009) {\n        if (msgType != MSG_RPC_CLIENT_RPC_REPLY) {\n            ret = true;\n        }\n    } else if (code == 10010) {\n", "CodeBleu_score": 17.176739485530586}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tif (code != 0) {\n\t\tif (msgType != tmsg_t::RPC_RESPONSE_ERROR_MSG) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 21.30130113439719}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    bool result = false;\n\n    if (code == EBADRQC) {\n        if (msgType != MSG_RPC_REDIRECT_RFP_REQ && msgType != MSG_RPC_REDIRECT_RFP_RESP) {\n            result = true;\n        }\n    }\n\n    return result;\n}\n", "CodeBleu_score": 28.848586554163237}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests)    SHashNode *pNode;\n    SRequest *pRequest;\n    int i;\n\n    if (pRequests == NULL)\n        return;\n\n    for (i = 0; i < pRequests->size; i++) {\n        pNode = pRequests->pArray[i];\n        while (pNode != NULL) {\n            pRequest = (SRequest *) pNode->pObject;\n            if (pRequest != NULL) {\n                if (pRequest->query != NULL) {\n                    stopQuery(pRequest->query);\n                    pRequest->query = NULL;\n                }\n                releaseRequest(pRequest);\n            }\n            pNode = pNode->pNext;\n        }\n    }\n}\n", "CodeBleu_score": 37.97744382613031}, {"code": "void stopAllRequests(SHashObj *pRequests)    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i1 = 0;\n    int j1 = 0;\n    int k1 = 0;\n    int l1 = 0;\n    int m1 = 0;\n    int n1 = 0;\n    int o1 = 0;\n    int p1 = 0;\n    int q1 = 0;\n    int r1 = 0;\n    int s1 = ", "CodeBleu_score": 5.541762515549773}, {"code": "void stopAllRequests(SHashObj *pRequests)    // Iterate through the hash table\n    int i = 0;\n    for (i = 0; i < pRequests->tableSize; i++) {\n        // Acquire the request by the request ID\n        Request *pRequest = (Request *) getValue(pRequests, i);\n        // Check if the request is valid\n        if (pRequest != NULL) {\n            // Stop the query associated with the request\n            if (pRequest->query != NULL) {\n                stopQuery(pRequest->query);\n            }\n            // Release the request\n            releaseRequest(pRequest);\n        }\n    }\n}\n", "CodeBleu_score": 42.97876968119283}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport()    if (!tscCrashReportEnabled()) {\n        return;\n    }\n    if (!tscAtomicCompareAndExchange(&tscClientStop, 0, 1)) {\n        tscLog(\"tscStopCrashReport: crash report thread already stopped\");\n        return;\n    }\n    while (tscClientStop) {\n        usleep(10000);\n    }\n}\n", "CodeBleu_score": 57.49623471286027}, {"code": "void tscStopCrashReport()    if (!tscIsCrashReportingEnabled()) {\n        return;\n    }\n    if (tscAtomicCompareAndExchange(&clientStop, 0, 1) != 0) {\n        tscLogMessage(\"Crash report thread already stopped\");\n        return;\n    }\n    while (clientStop != 0) {\n        usleep(100000);\n    }\n}\n", "CodeBleu_score": 57.278873659675}, {"code": "void tscStopCrashReport()  if (tscCrashReportingEnabled) {\n    if (tscAtomicCompareAndExchange(&tscCrashReportingEnabled, 0, 1) != 0) {\n      TSC_LOG_ERROR(\"tscStopCrashReport: Crash reporting is already disabled. Returning.\");\n      return;\n    }\n    TSC_LOG_INFO(\"tscStopCrashReport: Stopping crash report thread.\");\n    tscCrashReportingEnabled = 0;\n    while (tscAtomicCompareAndExchange(&tscCrashReportingEnabled, 0, 1) == 0) {\n      sleep(1);\n    }\n    TSC_LOG_INFO(\"tscStopCrashReport: Crash report thread stopped.\");\n  }\n}\n", "CodeBleu_score": 47.281538354804894}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t n = 0;\n\tint32_t viewId = 0;\n\tint32_t numCols = 0;\n\tint32_t numViews = 0;\n\tint32_t numViewsInRsp = 0;\n\tint32_t numViewsInCatalog = 0;\n\tint32_t numViewsToAdd = 0;\n\tint32_t numViewsToRemove = 0;\n\tint32_t numViewsToUpdate = 0;\n\tint32_t numViewsToUpdateInRsp = 0;\n\tint32_t numViewsToUpdateInCatalog = 0;\n\tint32_t numColsInRsp = 0;\n\tint32_t numColsInCatalog = 0;\n\tint32_t numColsToAdd = 0;\n\tint32_t numColsToRemove = 0;\n\tint32_t numColsToUpdate = 0;\n\tint32_t numColsToUpdateInRsp = 0;\n\tint32_t numColsToUpdateInCatalog = 0;\n\tint32_t numColsToUpdateInView = 0;\n\tint32_t numColsToUpdateInViewInRsp = 0;\n\tint32_t numColsToUpdateInViewInCatalog = 0;\n\tint32_t numColsToUpdateInViewInView = 0;\n\tint32_t numColsToUpdateInViewInViewInRsp = 0;\n\tint32_t numColsToUpdateInViewInViewInCatalog = 0;\n\tint32_t numColsToUpdateInViewInViewInView = 0;\n\tint32_t numColsToUpdateInViewInViewInViewInRsp = 0;\n\tint32_t numColsToUpdateInViewInViewInViewIn", "CodeBleu_score": 8.513243417239908}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t i;\n\tint32_t j;\n\tint32_t k;\n\tint32_t nViews;\n\tint32_t nCols;\n\tint32_t nColsInView;\n\tint32_t nColsInCatalog;\n\tint32_t nColsInResponse;\n\tint32_t nColsToRemove;\n\tint32_t nColsToAdd;\n\tint32_t nColsToUpdate;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInCatalog;\n\tint32_t nColsToUpdateInResponse;\n\tint32_t nColsToUpdateInC", "CodeBleu_score": 5.128661040588932}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t l = 0;\n\tint32_t m = 0;\n\tint32_t n = 0;\n\tint32_t o = 0;\n\tint32_t p = 0;\n\tint32_t q = 0;\n\tint32_t r = 0;\n\tint32_t s = 0;\n\tint32_t t = 0;\n\tint32_t u = 0;\n\tint32_t v = 0;\n\tint32_t w = 0;\n\tint32_t x = 0;\n\tint32_t y = 0;\n\tint32_t z = 0;\n\tint32_t A = 0;\n\tint32_t B = 0;\n\tint32_t C = 0;\n\tint32_t D = 0;\n\tint32_t E = 0;\n\tint32_t F = 0;\n\tint32_t G = 0;\n\tint32_t H = 0;\n\tint32_t I = 0;\n\tint32_t J = 0;\n\tint32_t K = 0;\n\tint32_t L = 0;\n\tint32_t M = 0;\n\tint32_t N = 0;\n\tint32_t O = 0;\n\tint32_t P = 0;\n\tint32_t Q = 0;\n\tint32_t R = 0;\n\tint32_t S = 0;\n\tint32_t T = 0;\n\tint32_t U = 0;\n\tint32_t V = 0;\n\tint32_t W = 0;\n\tint32_t X = 0;\n\tint32_t Y =", "CodeBleu_score": 5.994337966410139}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3Status status = S3StatusOK;\n    S3PutObjectHandler *putObjectHandler = (S3PutObjectHandler *) callbackData;\n\n    if (properties->contentLength > 0) {\n        putObjectHandler->contentLength = properties->contentLength;\n    } else {\n        putObjectHandler->contentLength = 0;\n    }\n\n    return status;\n}\n", "CodeBleu_score": 70.47775716697198}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3Status status = S3StatusOK;\n    CallbackData *data = (CallbackData *) callbackData;\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    }\n    return status;\n}\n", "CodeBleu_score": 64.19090521278247}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    if (properties->contentLength > 0) {\n        ((CallbackData *)callbackData)->contentLength = properties->contentLength;\n    } else {\n        ((CallbackData *)callbackData)->contentLength = 0;\n    }\n    return S3StatusOK;\n}\n", "CodeBleu_score": 66.786444569915}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync()  // Create the checkpoint backup directory if it does not exist.\n  if (!fs::exists(checkpointBackupDir)) {\n    if (!fs::create_directory(checkpointBackupDir)) {\n      logError(\"Failed to create checkpoint backup directory.\");\n    }\n  }\n\n  // Remove empty directories.\n  removeEmptyDirectories(checkpointBackupDir);\n\n  // Generate the Rsync configuration file.\n  if (!generateRsyncConfigFile()) {\n    logError(\"Failed to generate Rsync configuration file.\");\n    return;\n  }\n\n  // Construct and execute the Rsync command to start the Rsync daemon.\n  std::string command = \"rsync --daemon --config \" + rsyncConfigFile + \" --port \" + std::to_string(rsyncPort);\n  if (system(command.c_str()) != 0) {\n    logError(\"Failed to start Rsync daemon.\");\n  } else {\n    logInfo(\"Rsync daemon started successfully.\");\n  }\n}\n", "CodeBleu_score": 29.204042881330395}, {"code": "void startRsync()\n    // Create the checkpoint backup directory and log an error if it fails.\n    if (!createDirectory(checkpointBackupDir)) {\n        logError(\"Failed to create checkpoint backup directory.\");\n        return;\n    }\n\n    // Remove empty directories and generate an Rsync configuration file.\n    if (!removeEmptyDirectories(checkpointBackupDir)) {\n        logError(\"Failed to remove empty directories.\");\n        return;\n    }\n    if (!generateRsyncConfig(checkpointBackupDir)) {\n        logError(\"Failed to generate Rsync configuration file.\");\n        return;\n    }\n\n    // Construct and execute a command to start the Rsync daemon with the specified port and configuration file.\n    string command = \"rsync --daemon --port \" + to_string(checkpointRsyncPort) + \" --config \" + checkpointRsyncConfigFile;\n    if (system(command.c_str()) != 0) {\n        logError(\"Failed to start Rsync daemon.\");\n        return;\n    }\n\n    // Log whether the Rsync server started successfully or if it encountered an error.\n    if (checkpointRsyncPort == 873) {\n        logInfo(\"Rsync daemon started successfully.\");\n    } else {\n        logInfo(\"Rsync daemon started successfully on port \" + to_string(checkpointRsyncPort) + \".\");\n    }\n}\n", "CodeBleu_score": 27.510909597628114}, {"code": "void startRsync()\tchar *path = malloc(sizeof(char) * 1024);\n\tchar *cmd = malloc(sizeof(char) * 1024);\n\tchar *config = malloc(sizeof(char) * 1024);\n\tchar *port = malloc(sizeof(char) * 1024);\n\tchar *checkpoint = malloc(sizeof(char) * 1024);\n\tchar *backup = malloc(sizeof(char) * 1024);\n\tchar *log = malloc(sizeof(char) * 1024);\n\tchar *rsync = malloc(sizeof(char) * 1024);\n\tchar *tmp = malloc(sizeof(char) * 1024);\n\tchar *tmp2 = malloc(sizeof(char) * 1024);\n\tchar *tmp3 = malloc(sizeof(char) * 1024);\n\tchar *tmp4 = malloc(sizeof(char) * 1024);\n\tchar *tmp5 = malloc(sizeof(char) * 1024);\n\tchar *tmp6 = malloc(sizeof(char) * 1024);\n\tchar *tmp7 = malloc(sizeof(char) * 1024);\n\tchar *tmp8 = malloc(sizeof(char) * 1024);\n\tchar *tmp9 = malloc(sizeof(char) * 1024);\n\tchar *tmp10 = malloc(sizeof(char) * 1024);\n\tchar *tmp11 = malloc(sizeof(char) * 1024);\n\tchar *tmp12 = malloc(sizeof(char) * 1024);\n\tchar *tmp13 = malloc(sizeof(char) * 1024);\n\tchar *tmp14 = malloc(sizeof(char) * 1024);\n\tchar *tmp15 = malloc(sizeof(char) * 1024);\n\tchar *tmp16 = malloc(sizeof(char) * 1024);\n\tchar *tmp17 = malloc(sizeof(char) * 1024);\n\tchar *tmp18 = malloc(sizeof", "CodeBleu_score": 2.796526984937882}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId)\t\tif (dispatcherId == null || dispatcherId.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\"dispatcherId cannot be null or empty\");\n\t\t}\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\t\tif (dispatcher == null) {\n\t\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t\t}\n\t\tdispatcher.shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t\tdispatcher.getExecutor().shutdown();\n\t\tdispatcher.getExecutor().shutdownNow();\n\t}\n\n\t/**\n\t * The function \"getDispatcher\" retrieves a dispatcher identified by its ID.\\nIt retrieves the dispatcher from the dispatchers collection and, if found, returns it.\\nIf the dispatcher is not found, it throws a runtime exception indicating that the dispatcher with the specified ID is not registered.\n\t */\n\tpublic Dispatcher getDispatcher(String dispatcherId) {\n\t\tif (dispatcherId == null || dispatcherId.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\"dispatcherId cannot be null or empty\");\n\t\t}\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\t\tif (dispatcher == null) {\n\t\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t\t}\n\t\treturn dispatcher;\n\t}\n\n\t/**\n\t * The function \"getDispatchers\" retrieves all the dispatchers registered in the dispatchers collection.\\nIt returns an immutable collection of dispatchers.\n\t */\n\tpublic Collection<Dispatcher> getDispatchers() {\n\t\treturn Collections.unmodifiableCollection(dispatchers.values());\n\t}\n\n\t/**\n\t * The function \"registerDispatcher\" registers a dispatcher in the dispatchers collection.\\nIt retrieves the dispatcher from the dispatchers collection and, if found, throws a runtime exception indicating that the dispatcher with the specified ID is already registered.\\nIf the dispatcher is not found, it creates a new dispatcher with the specified ID and adds it to the dispatchers collection.\n\t */\n\tpublic void registerDispatcher(String dispatcher", "CodeBleu_score": 54.302689384509485}, {"code": "public void destroyDispatcher(String dispatcherId)\tDispatcher dispatcher = this.dispatchers.get(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n\tdispatcher.shutdown();\n\tthis.dispatchers.remove(dispatcherId);\n}\n", "CodeBleu_score": 58.79047771003959}, {"code": "public void destroyDispatcher(String dispatcherId)    if (dispatchers.containsKey(dispatcherId)) {\n        Dispatcher dispatcher = dispatchers.get(dispatcherId);\n        dispatcher.shutdown();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found\");\n    }\n}\n", "CodeBleu_score": 63.91091786362324}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    TbActorId parentId = parent;\n    if (parentId == null) {\n      return;\n    }\n    List<TbActorId> children = childrenMap.get(parentId);\n    if (children != null) {\n      for (TbActorId child : children) {\n        if (childFilter.test(child)) {\n          if (highPriority) {\n            actorSystem.tell(new TbActorToActorMsgWrapper(child, msg), ActorRef.noSender());\n          } else {\n            actorSystem.tell(msg, child);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n   */\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg) {\n    broadcastToChildren(parent, childFilter, msg, false);\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n   */\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorSystemMsg msg) {\n    broadcastToChildren(parent, childFilter, msg, false);\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high", "CodeBleu_score": 42.98345889808949}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)        if (parent == null) {\n            log.warn(\"Can't broadcast message to children of null parent\");\n            return;\n        }\n        TbActorId parentId = parent.getId();\n        Map<TbActorId, TbActorRef> children = childrenMap.get(parentId);\n        if (children == null) {\n            log.warn(\"Can't broadcast message to children of unregistered parent actor [{}].\", parentId);\n            return;\n        }\n        children.entrySet().stream().filter(e -> childFilter.test(e.getKey())).forEach(e -> {\n            TbActorRef actorRef = e.getValue();\n            if (actorRef.isActive()) {\n                if (highPriority) {\n                    actorRef.tellWithHighPriority(msg);\n                } else {\n                    actorRef.tell(msg);\n                }\n            } else {\n                log.warn(\"Can't broadcast message to inactive child actor [{}].\", e.getKey());\n            }\n        });\n    }\n\n", "CodeBleu_score": 39.50117584876077}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    TbActorId parentId = parent.getId();\n    if (children.containsKey(parentId)) {\n        for (TbActorId child : children.get(parentId)) {\n            if (childFilter.test(child)) {\n                if (highPriority) {\n                    actorService.tellWithHighPriority(child, msg);\n                } else {\n                    actorService.tell(child, msg);\n                }\n            }\n        }\n    } else {\n        log.warn(\"[{}] Failed to broadcast message to children of [{}]\", msg.getId(), parentId);\n    }\n}", "CodeBleu_score": 39.459320780870534}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (destroyed) {\n        if (msg.getMsgType() == TbActorMsg.RULE_NODE_UPDATED_MSG) {\n            if (highPriority) {\n                if (initFailed) {\n                    init();\n                }\n            } else {\n                msg.onFailure(new RuntimeException(\"Actor is destroyed\"));\n            }\n        } else {\n            msg.onFailure(new RuntimeException(\"Actor is destroyed\"));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        process();\n    }\n}\n", "CodeBleu_score": 52.50295303859702}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (msg.getMsgType() == TbActorMsg.TB_ACTOR_MSG_TYPE.RULE_NODE_UPDATED_MSG) {\n        TbRuleNodeUpdatedMsg nodeUpdatedMsg = (TbRuleNodeUpdatedMsg) msg;\n        if (nodeUpdatedMsg.getNodeId().equals(ruleNodeId)) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            processQueue();\n        }\n    } else {\n        if (destroying) {\n            if (msg.getMsgType() == TbActorMsg.TB_ACTOR_MSG_TYPE.RULE_CHAIN_UPDATED_MSG) {\n                TbRuleChainUpdatedMsg ruleChainUpdatedMsg = (TbRuleChainUpdatedMsg) msg;\n                if (ruleChainUpdatedMsg.getRuleChainId().equals(ruleChainId)) {\n                    if (highPriority) {\n                        highPriorityMsgs.add(msg);\n                    } else {\n                        normalPriorityMsgs.add(msg);\n                    }\n                    processQueue();\n                }\n            } else {\n                if (msg.getMsgType() == TbActorMsg.TB_ACTOR_MSG_TYPE.RULE_CHAIN_NODE_MSG) {\n                    TbRuleChainNodeMsg ruleChainNodeMsg = (TbRuleChainNodeMsg) msg;\n                    if (ruleChainNodeMsg.getNodeId().equals(ruleNodeId)) {\n                        if (highPriority) {\n                            highPriorityMsgs.add(msg);\n                        } else {\n                            normalPriorityMsgs.add(msg);\n                        }\n                        processQueue();\n                    }\n                }\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            processQueue();\n        }\n    }\n}\n", "CodeBleu_score": 53.28640668819651}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (destroyed) {\n        if (msg instanceof RuleNodeUpdatedMsg) {\n            if (highPriority) {\n                reinitialize(msg);\n            } else {\n                msg.onFailure(new RuntimeException(\"Actor is being destroyed\"));\n            }\n        } else {\n            msg.onFailure(new RuntimeException(\"Actor is being destroyed\"));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueues();\n    }\n}\n", "CodeBleu_score": 47.701830273646664}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox()    if (this.status == ActorStatus.DESTROYED) {\n        return;\n    }\n    if (this.status == ActorStatus.INITIALIZING) {\n        if (this.initFailure != null) {\n            this.setStopReason(this.initFailure);\n            this.destroy();\n            return;\n        }\n        this.setStatus(ActorStatus.IDLE);\n    }\n    if (this.status == ActorStatus.IDLE) {\n        if (this.processFailure != null) {\n            this.setStopReason(this.processFailure);\n            this.destroy();\n            return;\n        }\n        this.setStatus(ActorStatus.PROCESSING);\n    }\n    if (this.status == ActorStatus.PROCESSING) {\n        if (this.processFailure != null) {\n            this.setStopReason(this.processFailure);\n            this.destroy();\n            return;\n        }\n        if (this.throughputLimit > 0) {\n            if (this.throughputCounter >= this.throughputLimit) {\n                this.setStatus(ActorStatus.IDLE);\n                return;\n            }\n            this.throughputCounter++;\n        }\n        if (this.mailbox.highPriority.isEmpty() && this.mailbox.normalPriority.isEmpty()) {\n            this.setStatus(ActorStatus.IDLE);\n            return;\n        }\n        if (!this.mailbox.highPriority.isEmpty()) {\n            this.processMessage(this.mailbox.highPriority.poll());\n            if (this.mailbox.highPriority.isEmpty()) {\n                this.mailbox.highPriority = null;\n            }\n            return;\n        }\n        if (!this.mailbox.normalPriority.isEmpty()) {\n            this.processMessage(this.mailbox.normalPriority.poll());\n            if (this.mailbox.normalPriority.isEmpty()) {\n                this.mailbox.normalPriority = null;\n            }\n            return;\n        }\n    }\n}", "CodeBleu_score": 20.648518578403895}, {"code": "private void processMailbox()    while (true) {\n        try {\n            if (highPriorityQueue.size() > 0) {\n                processMessages(highPriorityQueue, highThroughput);\n            } else if (normalPriorityQueue.size() > 0) {\n                processMessages(normalPriorityQueue, normalThroughput);\n            } else {\n                setStatus(Status.FREE);\n                scheduleProcessingAttempt();\n                break;\n            }\n        } catch (Exception e) {\n            log.error(\"Processing messages from mailbox failed: \" + e.getMessage(), e);\n            if (e instanceof ActorInitializationException) {\n                setStopReason(StopReason.INITIALIZATION_FAILURE);\n                destroy();\n            } else {\n                applyProcessFailureStrategy(e);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 25.41115678267089}, {"code": "private void processMailbox()\tboolean success = true;\n\tboolean isHighPriority = true;\n\t\n\twhile (success) {\n\t\t// If there are messages in the high priority queue, process them first\n\t\twhile (isHighPriority && !highPriorityQueue.isEmpty()) {\n\t\t\tsuccess = process(highPriorityQueue);\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If there are still messages in the high priority queue, process them\n\t\twhile (!highPriorityQueue.isEmpty()) {\n\t\t\tsuccess = process(highPriorityQueue);\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If there are messages in the normal priority queue, process them\n\t\twhile (!normalPriorityQueue.isEmpty()) {\n\t\t\tsuccess = process(normalPriorityQueue);\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If there are messages in the high priority queue, process them\n\t\twhile (isHighPriority && !highPriorityQueue.isEmpty()) {\n\t\t\tsuccess = process(highPriorityQueue);\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If there are still messages in the high priority queue, process them\n\t\twhile (!highPriorityQueue.isEmpty()) {\n\t\t\tsuccess = process(highPriorityQueue);\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If there are still messages in the normal priority queue, process them\n\t\twhile (!normalPriorityQueue.isEmpty()) {\n\t\t\tsuccess = process(normalPriorityQueue);\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If there are no more messages in the queues, set the actor's status to free and schedule a queue processing attempt\n\t\tif (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n", "CodeBleu_score": 14.389524893669476}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause)    if (!isStopped()) {\n        if (stopReason == null) {\n            stopReason = new ActorStoppedException(cause);\n        }\n        if (!isDestroyed()) {\n            setDestroyed(true);\n            setReady(false);\n            getContext().getSystem().scheduler().scheduleOnce(Duration.ZERO, getContext().getDispatcher(), new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        if (isDestroyed()) {\n                            if (log.isDebugEnabled()) log.debug(\"{} is being destroyed with cause {}\", ActorCell.this, cause);\n                            if (isInitialized()) {\n                                getSelf().tell(new Destroy(cause));\n                            } else {\n                                destroy();\n                            }\n                        }\n                    } catch (Throwable t) {\n                        log.warning(\"Exception during actor destruction: \" + t.getMessage(), t);\n                    }\n                }\n            });\n        }\n    }\n}\n", "CodeBleu_score": 36.73931509434068}, {"code": "public void destroy(Throwable cause)    if (stopReason == null) {\n        stopReason = new DestroyReason(cause);\n    }\n    if (isStopped) {\n        return;\n    }\n    isStopped = true;\n    isDestroyed = true;\n    if (isReadinessChecking) {\n        return;\n    }\n    isReadinessChecking = true;\n    isReadiness = false;\n    isReadinessChecking = false;\n    executor.execute(() -> {\n        try {\n            if (!isStopped) {\n                return;\n            }\n            isStopped = false;\n            if (isReadiness) {\n                return;\n            }\n            isReadiness = true;\n            if (isReadinessChecking) {\n                return;\n            }\n            isReadinessChecking = true;\n            isReadiness = false;\n            isReadinessChecking = false;\n            if (isStopped) {\n                return;\n            }\n            isStopped = true;\n            if (isDestroyed) {\n                return;\n            }\n            isDestroyed = true;\n            if (isReadiness) {\n                return;\n            }\n            isReadiness = true;\n            if (isReadinessChecking) {\n                return;\n            }\n            isReadinessChecking = true;\n            isReadiness = false;\n            isReadinessChecking = false;\n            if (isStopped) {\n                return;\n            }\n            isStopped = true;\n            if (isDestroyed) {\n                return;\n            }\n            isDestroyed = true;\n            if (isReadiness) {\n                return;\n            }\n            isReadiness = true;\n            if (isReadinessChecking) {\n                return;\n            }\n            isReadinessChecking = true;\n            isReadiness = false;\n            isReadinessChecking = false;\n            if (isStopped) {\n                return;\n            }\n            isStopped = true;\n            if (isDestroyed) {\n                return;\n            }\n            isDestroyed = true;\n            if (isReadiness)", "CodeBleu_score": 23.092083614232873}, {"code": "public void destroy(Throwable cause)    if (stopReason == null) {\n        stopReason = StopReason.STOPPED;\n    }\n    if (stopReason == StopReason.STOPPED) {\n        stopReason = StopReason.DESTROYED;\n    }\n    if (stopReason == StopReason.STOPPED || stopReason == StopReason.DESTROYED) {\n        return;\n    }\n    if (cause == null) {\n        cause = new Exception(\"Destroyed\");\n    }\n    if (cause instanceof ActorKilledException) {\n        stopReason = StopReason.KILLED;\n    } else if (cause instanceof ActorStoppedException) {\n        stopReason = StopReason.STOPPED;\n    } else if (cause instanceof ActorDeletedException) {\n        stopReason = StopReason.DELETED;\n    } else if (cause instanceof ActorRestartedException) {\n        stopReason = StopReason.RESTARTED;\n    } else if (cause instanceof ActorStoppedException) {\n        stopReason = StopReason.STOPPED;\n    } else if (cause instanceof ActorDeletedException) {\n        stopReason = StopReason.DELETED;\n    } else if (cause instanceof ActorRestartedException) {\n        stopReason = StopReason.RESTARTED;\n    } else if (cause instanceof ActorKilledException) {\n        stopReason = StopReason.KILLED;\n    } else if (cause instanceof ActorStoppedException) {\n        stopReason = StopReason.STOPPED;\n    } else if (cause instanceof ActorDeletedException) {\n        stopReason = StopReason.DELETED;\n    } else if (cause instanceof ActorRestartedException) {\n        stopReason = StopReason.RESTARTED;\n    } else if (cause instanceof ActorKilledException) {\n        stopReason = StopReason.KILLED;\n    } else if (cause instanceof ActorStoppedException) {\n", "CodeBleu_score": 29.858520138827327}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.isSystem()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfiguration rateLimitConfiguration = rateLimitConfigurationCache.get(tenantProfile.getId());\n    if (rateLimitConfiguration == null) {\n        rateLimitConfiguration = rateLimitConfigurationService.findByTenantId(tenantProfile.getId(), api);\n        rateLimitConfigurationCache.put(tenantProfile.getId(), rateLimitConfiguration);\n    }\n    RateLimit rateLimit = rateLimitConfiguration.getRateLimit(level);\n    if (rateLimit == null) {\n        return true;\n    }\n    if (rateLimit.isExceeded(api)) {\n        rateLimitNotificationService.processNotification(tenantId, api, level, rateLimit.getLimit());\n    }\n    return rateLimit.checkLimit(api);\n}\n", "CodeBleu_score": 57.907741775753564}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.isNullUid()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId.getId());\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        }\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n    RateLimitConfiguration rateLimitConfiguration = rateLimitConfigurationCache.get(tenantProfile.getId());\n    if (rateLimitConfiguration == null) {\n        rateLimitConfiguration = rateLimitConfigurationService.findByTenantId(tenantId.getId());\n        if (rateLimitConfiguration == null) {\n            rateLimitConfiguration = new RateLimitConfiguration();\n        }\n        rateLimitConfigurationCache.put(tenantProfile.getId(), rateLimitConfiguration);\n    }\n    RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitCounter counter = rateLimitCounterCache.get(rateLimit.getId());\n    if (counter == null) {\n        counter = rateLimitCounterService.findCounter(rateLimit.getId());\n        if (counter == null) {\n            counter = new RateLimitCounter();\n        }\n        rateLimitCounterCache.put(rateLimit.getId(), counter);\n    }\n    long now = System.currentTimeMillis();\n    long timestamp = now - (now % rateLimit.getPeriod());\n    if (counter.getTimestamp() != timestamp) {\n        counter.setTimestamp(timestamp);\n        counter.setCount(0);\n    }\n    if (counter.getCount() >= rateLimit.getLimit()) {\n        processRateLimit(rateLimit, level);\n        return false;\n    }\n    counter.setCount(counter.getCount() + 1);\n    return true;\n}\n", "CodeBleu_score": 48.424313938370545}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.isNullUid()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    long currentTime = System.currentTimeMillis();\n    long currentCount = rateLimit.getCurrentCount();\n    long currentLimit = rateLimit.getLimit();\n    long currentPeriod = rateLimit.getPeriod();\n    long currentTs = rateLimit.getLastTs();\n    long currentLevel = rateLimit.getLevel();\n    long newLevel = level != null ? (long) level : 0;\n    if (currentTime - currentTs < currentPeriod) {\n        if (currentCount < currentLimit) {\n            rateLimit.setCurrentCount(currentCount + newLevel);\n            return true;\n        }\n    } else {\n        rateLimit.setCurrentCount(newLevel);\n        rateLimit.setLastTs(currentTime);\n        return true;\n    }\n    if (rateLimitConfiguration.getNotifications() != null) {\n        RateLimitNotification notification = rateLimitConfiguration.getNotifications().get(api);\n        if (notification != null) {\n            rateLimitNotificationService.processNotification(notification, tenantId, api, currentLimit, currentCount, currentLevel, newLevel);\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 52.609543535493344}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions()    long currentTime = System.currentTimeMillis();\n    long expirationTime = currentTime - inactivityTimeout;\n    for (Iterator<Entry<String, DTLSContext>> it = dtlsSessions.entrySet().iterator(); it.hasNext();) {\n        Entry<String, DTLSContext> entry = it.next();\n        DTLSContext dtlsContext = entry.getValue();\n        if (dtlsContext.getLastActivityTime() < expirationTime) {\n            logger.debug(\"Removing DTLS session for {}\", dtlsContext.getPeerAddress());\n            it.remove();\n        }\n    }\n}\n", "CodeBleu_score": 40.92573960225807}, {"code": "public void evictTimeoutSessions()    if (inactivityTimeout > 0) {\n        long now = System.currentTimeMillis();\n        long expirationTime = now - inactivityTimeout;\n        for (Iterator<Entry<String, DTLSServerSession>> iterator = sessions.entrySet().iterator(); iterator.hasNext();) {\n            Entry<String, DTLSServerSession> entry = iterator.next();\n            DTLSServerSession session = entry.getValue();\n            if (session.getLastActivityTime() < expirationTime) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Evicting DTLS session for \" + entry.getKey() + \" with last activity time \" + session.getLastActivityTime());\n                }\n                iterator.remove();\n                try {\n                    session.close();\n                } catch (IOException e) {\n                    LOG.warn(\"Failed to close DTLS session for \" + entry.getKey(), e);\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 33.53086056052137}, {"code": "public void evictTimeoutSessions()    long now = System.currentTimeMillis();\n    long timeout = now - inactivityTimeout;\n    for (Iterator<Map.Entry<String, DtlsSession>> i = sessions.entrySet().iterator(); i.hasNext(); ) {\n        Map.Entry<String, DtlsSession> e = i.next();\n        if (e.getValue().getLastActivityTime() < timeout) {\n            logger.log(Level.INFO, \"evictTimeoutSessions: Removing inactive session \" + e.getKey());\n            i.remove();\n        }\n    }\n}\n", "CodeBleu_score": 40.582454268626}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>(timeseries.size());\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        for (JsonNode value : values) {\n            result.add(new BasicTsKvEntry(Long.parseLong(key), toTsValue(value)));\n        }\n    }\n    return result;\n}\n", "CodeBleu_score": 44.851301687065764}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> ts = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        for (JsonNode value : entry.getValue()) {\n            ts.add(new BasicTsKvEntry(Long.parseLong(key), parseValue(value)));\n        }\n    }\n    return ts;\n}\n", "CodeBleu_score": 40.563345624537874}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries == null || timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> tsKvEntries = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        for (JsonNode value : values) {\n            tsKvEntries.add(new BasicTsKvEntry(Long.parseLong(value.get(\"t\").textValue()),\n                    new LongDataEntry(key, Long.parseLong(value.get(\"v\").textValue()))));\n        }\n    }\n    return tsKvEntries;\n}", "CodeBleu_score": 42.75762960870048}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken()    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refreshToken\", this.refreshToken);\n    requestMap.put(\"clientId\", this.clientId);\n    requestMap.put(\"clientSecret\", this.clientSecret);\n    requestMap.put(\"grantType\", \"refresh_token\");\n    requestMap.put(\"redirectUri\", this.redirectUri);\n    requestMap.put(\"scope\", this.scope);\n    requestMap.put(\"responseType\", \"token\");\n    requestMap.put(\"state\", this.state);\n    requestMap.put(\"codeVerifier\", this.codeVerifier);\n    requestMap.put(\"codeChallenge\", this.codeChallenge);\n    requestMap.put(\"codeChallengeMethod\", this.codeChallengeMethod);\n    requestMap.put(\"clientAssertionType\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n    requestMap.put(\"clientAssertion\", this.clientAssertion);\n    requestMap.put(\"accessToken\", this.accessToken);\n    requestMap.put(\"tokenType\", this.tokenType);\n    requestMap.put(\"expiresIn\", this.expiresIn);\n    requestMap.put(\"refreshToken\", this.refreshToken);\n    requestMap.put(\"idToken\", this.idToken);\n    requestMap.put(\"scope\", this.scope);\n    requestMap.put(\"tokenResponse\", this.tokenResponse);\n    requestMap.put(\"tokenResponseBody\", this.tokenResponseBody);\n    requestMap.put(\"tokenResponseJson\", this.tokenResponseJson);\n    requestMap.put(\"tokenResponseJsonObject\", this.tokenResponseJsonObject);\n    requestMap.put(\"tokenResponseJsonObjectKeys\", this.tokenResponseJsonObjectKeys);\n    requestMap.put(\"tokenResponseJsonObjectValues\", this.tokenResponseJsonObjectValues);\n    requestMap.put(\"tokenResponseJsonObjectEntrySet\", this.tokenResponseJsonObjectEntrySet);\n    requestMap.put(\"tokenResponseJsonObjectKeySet\", this.tokenResponseJsonObjectKeySet);\n    requestMap.put(\"tokenResponseJsonObjectValues\", this.tokenResponseJsonObjectValues);\n    requestMap.put(\"tokenResponseJsonObject", "CodeBleu_score": 23.675032643049782}, {"code": "public void refreshToken()    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refreshToken\", this.refreshToken);\n    try {\n        Response response = Unirest.post(this.authenticationEndpoint)\n                .header(\"Content-Type\", \"application/json\")\n                .body(requestMap)\n                .asString();\n        this.token = response.getBody();\n        this.tokenExpiry = Instant.now().plus(this.tokenExpiryDuration, ChronoUnit.MINUTES);\n        this.refreshToken = response.getHeaders().getFirst(\"refreshToken\");\n    } catch (UnirestException e) {\n        e.printStackTrace();\n    }\n}\n", "CodeBleu_score": 43.58810934208392}, {"code": "public void refreshToken()\n    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", refreshToken);\n    requestMap.put(\"grant_type\", \"refresh_token\");\n    requestMap.put(\"client_id\", clientId);\n    requestMap.put(\"client_secret\", clientSecret);\n\n    try {\n        HttpClient httpClient = HttpClientBuilder.create().build();\n        HttpPost httpPost = new HttpPost(authEndpoint);\n        httpPost.setHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        for (Map.Entry<String, String> entry : requestMap.entrySet()) {\n            urlParameters.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));\n        }\n\n        httpPost.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        HttpResponse response = httpClient.execute(httpPost);\n        HttpEntity entity = response.getEntity();\n        String responseString = EntityUtils.toString(entity);\n\n        JSONObject jsonObject = new JSONObject(responseString);\n        accessToken = jsonObject.getString(\"access_token\");\n        refreshToken = jsonObject.getString(\"refresh_token\");\n        tokenExpiration = jsonObject.getLong(\"expires_in\");\n        tokenExpiration = System.currentTimeMillis() + (tokenExpiration * 1000);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "CodeBleu_score": 41.564604011672955}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin()\n        try {\n            // Capture the current timestamp\n            long timestamp = System.currentTimeMillis();\n\n            // Create the login request map\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", username);\n            loginRequest.put(\"password\", password);\n\n            // Send the request and capture the response\n            Response response = Unirest.post(\"http://localhost:8080/api/auth/login\")\n                    .header(\"Content-Type\", \"application/json\")\n                    .body(loginRequest)\n                    .asString();\n\n            // Update the token information with the response data and the timestamp\n            tokenInfo.setAccessToken(response.getBody().toString());\n            tokenInfo.setTimestamp(timestamp);\n        } catch (UnirestException e) {\n            e.printStackTrace();\n        }\n    }\n", "CodeBleu_score": 62.55554285316249}, {"code": " private void doLogin()        try {\n            String timestamp = String.valueOf(System.currentTimeMillis());\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", username);\n            loginRequest.put(\"password\", password);\n            loginRequest.put(\"timestamp\", timestamp);\n            String response = Request.Post(\"http://localhost:8080/api/auth/login\")\n                    .addHeader(\"Content-Type\", \"application/json\")\n                    .bodyString(new JSONObject(loginRequest).toString(), ContentType.APPLICATION_JSON)\n                    .execute()\n                    .returnContent()\n                    .asString();\n            JSONObject responseJson = new JSONObject(response);\n            token = responseJson.getString(\"token\");\n            timestamp = responseJson.getString(\"timestamp\");\n            System.out.println(\"Token: \" + token);\n            System.out.println(\"Timestamp: \" + timestamp);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * The function \"doLogout\" performs a logout operation by sending a POST request to the logout endpoint.\\nIt captures the current timestamp, creates a logout request map with the token, and sends the request to the \"/api/auth/logout\" URL.\\nUpon receiving the response, it updates the token information with the response data and the timestamp.\n     */\n    private void doLogout() {\n        try {\n            String timestamp = String.valueOf(System.currentTimeMillis());\n            Map<String, String> logoutRequest = new HashMap<>();\n            logoutRequest.put(\"token\", token);\n            logoutRequest.put(\"timestamp\", timestamp);\n            String response = Request.Post(\"http://localhost:8080/api/auth/logout\")\n                    .addHeader(\"Content-Type\", \"application/json\")\n                    .bodyString(new JSONObject(logoutRequest).toString(), ContentType.APPLICATION_JSON)\n                    .execute()\n                    .returnContent()\n                    .asString();\n            JSONObject responseJson = new JSONObject(response);\n            token = responseJson.getString(\"token\");\n            timestamp = responseJson.getString(\"timestamp\");", "CodeBleu_score": 45.99008535573138}, {"code": " private void doLogin()        String url = \"http://192.168.1.110:8080/api/auth/login\";\n        String username = \"admin\";\n        String password = \"admin\";\n        String timestamp = String.valueOf(System.currentTimeMillis());\n        String token = \"\";\n        String nonce = \"\";\n        String hash = \"\";\n        String signature = \"\";\n        String body = \"\";\n        String request = \"\";\n        String response = \"\";\n        try {\n            // create a map with the credentials\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", username);\n            loginRequest.put(\"password\", password);\n            loginRequest.put(\"timestamp\", timestamp);\n            loginRequest.put(\"nonce\", nonce);\n            loginRequest.put(\"hash\", hash);\n            loginRequest.put(\"signature\", signature);\n            loginRequest.put(\"body\", body);\n            // send the POST request to the authentication endpoint\n            request = sendRequest(url, loginRequest, \"POST\");\n            // parse the response\n            response = parseResponse(request);\n            // update the token information\n            token = getToken(response);\n            nonce = getNonce(response);\n            hash = getHash(response);\n            signature = getSignature(response);\n            timestamp = getTimestamp(response);\n            // create a map with the token information\n            Map<String, String> tokenInfo = new HashMap<>();\n            tokenInfo.put(\"token\", token);\n            tokenInfo.put(\"nonce\", nonce);\n            tokenInfo.put(\"hash\", hash);\n            tokenInfo.put(\"signature\", signature);\n            tokenInfo.put(\"timestamp\", timestamp);\n            tokenInfo.put(\"body\", body);\n            // set the token information in the session\n            setToken(tokenInfo);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "CodeBleu_score": 39.67352794065285}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    String url = \"/api/device/\" + deviceId;\n    return getDevice(url);\n}\n", "CodeBleu_score": 6.0631427706970795}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        return Optional.ofNullable(getRestClient().get(Device.class, \"/api/device/\" + deviceId.toString()));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}\n", "CodeBleu_score": 45.63407062519546}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        ResponseEntity<Device> responseEntity = restTemplate.getForEntity(\n                \"/api/device/{deviceId}\",\n                Device.class,\n                deviceId);\n        return Optional.ofNullable(responseEntity.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    }\n}", "CodeBleu_score": 46.89850637958807}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(String.format(\"%s/api/device-with-credentials\", this.baseUrl)))\n                .POST(HttpRequest.BodyPublishers.ofString(new ObjectMapper().writeValueAsString(new DeviceWithCredentials(device, credentials))))\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"Accept\", \"application/json\")\n                .header(\"Authorization\", String.format(\"Bearer %s\", this.token))\n                .build();\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n        if (response.statusCode() == 201) {\n            return Optional.of(new ObjectMapper().readValue(response.body(), Device.class));\n        }\n        if (response.statusCode() == 404) {\n            return Optional.empty();\n        }\n        throw new Exception(String.format(\"Received status code %d\", response.statusCode()));\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw e;\n    }\n}", "CodeBleu_score": 44.32376887616287}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    Request request = new Request.Builder()\n            .url(baseUrl + \"/api/device-with-credentials\")\n            .post(RequestBody.create(JSON, new Gson().toJson(new DeviceWithCredentials(device, credentials))))\n            .build();\n\n    try {\n        Response response = client.newCall(request).execute();\n        if (response.code() == 200) {\n            return Optional.of(new Gson().fromJson(response.body().string(), Device.class));\n        } else if (response.code() == 404) {\n            return Optional.empty();\n        } else {\n            throw new IOException(\"Unexpected response code: \" + response.code());\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n", "CodeBleu_score": 51.2220920401286}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        HttpResponse<String> response = Unirest.post(\"http://localhost:8080/api/device-with-credentials\")\n                .header(\"Content-Type\", \"application/json\")\n                .body(new Gson().toJson(new DeviceWithCredentials(device, credentials)))\n                .asString();\n        if (response.getStatus() == 200) {\n            return Optional.of(new Gson().fromJson(response.getBody(), Device.class));\n        }\n        return Optional.empty();\n    } catch (UnirestException e) {\n        if (e.getCause() instanceof HttpResponseException) {\n            HttpResponseException responseException = (HttpResponseException) e.getCause();\n            if (responseException.getStatus() == 404) {\n                return Optional.empty();\n            }\n        }\n        throw e;\n    }\n}\n", "CodeBleu_score": 46.964410878633316}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val)    if (arguments.length == 1) {\n        val = addr;\n        addr = null;\n    }\n    if (addr != null) {\n        if (val < 0) {\n            val = 0;\n        } else if (val > 100) {\n            val = 100;\n        }\n        val = Math.floor(val * 15 / 100);\n        this.setDevice(addr, {\n            brightness: val\n        });\n    } else {\n        for (var i = 0; i < this.devices.length; i++) {\n            var device = this.devices[i];\n            if (device.type == 'led') {\n                if (val < 0) {\n                    val = 0;\n                } else if (val > 100) {\n                    val = 100;\n                }\n                val = Math.floor(val * 15 / 100);\n                this.setDevice(device.addr, {\n                    brightness: val\n                });\n            }\n        }\n    }\n    return this;\n}\n", "CodeBleu_score": 49.35802891749022}, {"code": "brightness(addr, val)  if (arguments.length === 1) {\n    val = addr;\n    addr = null;\n  }\n\n  if (addr !== null) {\n    this.setBrightness(addr, val);\n  } else {\n    for (let i = 0; i < this.devices.length; i++) {\n      this.setBrightness(this.devices[i].addr, val);\n    }\n  }\n\n  return this;\n}\n", "CodeBleu_score": 62.86423130257568}, {"code": "brightness(addr, val)    if (arguments.length === 1) {\n        this.brightness = addr;\n        return this;\n    }\n    if (arguments.length === 2) {\n        this.brightness = val;\n        this.send({\n            address: addr,\n            brightness: val\n        });\n        return this;\n    }\n}\n", "CodeBleu_score": 51.311942883619864}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr)    var obj = {};\n    for (var key in this) {\n        if (typeof this[key] === 'function') {\n            obj[key] = this[key].bind(this, addr);\n        } else {\n            obj[key] = this[key];\n        }\n    }\n    return obj;\n}\n", "CodeBleu_score": 39.02973050372147}, {"code": "device(addr)  const obj = {};\n  const keys = Object.keys(this);\n  keys.forEach(key => {\n    obj[key] = this[key].bind(this, addr);\n  });\n  return obj;\n}\n", "CodeBleu_score": 36.35500329304967}, {"code": "device(addr)    let obj = {};\n    for (let key in LedControl.prototype) {\n        if (typeof LedControl.prototype[key] === 'function') {\n            obj[key] = LedControl.prototype[key].bind(this, addr);\n        }\n    }\n    for (let key in this) {\n        if (typeof this[key] === 'function') {\n            obj[key] = this[key].bind(this, addr);\n        }\n    }\n    return obj;\n}\n", "CodeBleu_score": 51.29538876804587}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) =>     for (let method of methods) {\n        target[method] = function (...args) {\n            let duration = args.length > 1 && typeof args[args.length - 1] === 'number' ? args.pop() : 1000;\n            let callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;\n            let promises = [];\n            this.forEach(function (element) {\n                promises.push(element[method](...args));\n            });\n            if (callback) {\n                Promise.all(promises).then(() => callback());\n            }\n            return new Promise(function (resolve, reject) {\n                setTimeout(() => resolve(Promise.all(promises)), duration);\n            });\n        };\n    }\n};\n", "CodeBleu_score": 33.827143236132386}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>     if (methods.length === 0) {\n        return;\n    }\n    const methodNames = methods.map(method => method.name);\n    const methodNamesString = methodNames.join(', ');\n    const methodNamesStringPlural = methodNames.length > 1 ? `${methodNamesString}s` : methodNamesString;\n    const methodNamesStringSingular = methodNames.length > 1 ? `${methodNamesString} was` : `${methodNamesString} was`;\n    const methodNamesStringPluralPast = methodNames.length > 1 ? `${methodNamesString} had` : `${methodNamesString} had`;\n    const methodNamesStringSingularPast = methodNames.length > 1 ? `${methodNamesString} had` : `${methodNamesString} had`;\n    const methodNamesStringPluralPresent = methodNames.length > 1 ? `${methodNamesString} are` : `${methodNamesString} is`;\n    const methodNamesStringSingularPresent = methodNames.length > 1 ? `${methodNamesString} is` : `${methodNamesString} is`;\n    const methodNamesStringPluralFuture = methodNames.length > 1 ? `${methodNamesString} will` : `${methodNamesString} will`;\n    const methodNamesStringSingularFuture = methodNames.length > 1 ? `${methodNamesString} will` : `${methodNamesString} will`;\n    const methodNamesStringPluralPastFuture = methodNames.length > 1 ? `${methodNamesString} will have` : `${methodNamesString} will have`;\n    const methodNamesStringSingularPastFuture = methodNames.length > 1 ? `${methodNamesString} will have` : `${methodNamesString} will have`;\n    const methodNamesStringPluralPresentFuture = methodNames.length > 1 ? `${methodNamesString} will be` : `${methodNamesString} will be`;\n    const methodNamesStringSingularPresentFuture = methodNames.length > 1 ? `${methodNamesString} will be` : `${methodNamesString} will be`;\n    const methodNamesStringPluralPastFuturePresent = methodNames.length > 1 ? `${methodNamesString} will be", "CodeBleu_score": 18.038894215851993}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>     methods.forEach(method => {\n        target[method] = (duration, callback) => {\n            if (duration === undefined) duration = 1000;\n            if (callback === undefined) callback = function () {};\n            if (typeof callback !== 'function') throw new Error('Callback is not a function');\n            let promises = [];\n            target.forEach(element => {\n                promises.push(new Promise((resolve, reject) => {\n                    let timer = setTimeout(() => {\n                        element[method]().then(resolve).catch(reject);\n                    }, duration);\n                }));\n            });\n            return Promise.all(promises).then(() => {\n                callback();\n            });\n        };\n    });\n};\n", "CodeBleu_score": 41.95055516194491}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen()  var data = \"\";\n  var port = new SerialPort(this.port, {\n    baudRate: this.baudRate,\n    parser: SerialPort.parsers.readline(\"\\r\\n\")\n  });\n  port.on(\"data\", function(data) {\n    data = data.toString(\"utf8\");\n    var sentences = data.split(\"\\r\\n\");\n    var sentence = \"\";\n    for (var i = 0; i < sentences.length; i++) {\n      sentence += sentences[i];\n      if (sentence.endsWith(\"$\")) {\n        sentence = sentence.substring(0, sentence.length - 1);\n        parseNmeaSentence(sentence);\n        sentence = \"\";\n      }\n    }\n    if (sentence.length > 0) {\n      data = sentence;\n    }\n  });\n  port.on(\"error\", function(error) {\n    console.log(error);\n  });\n  port.on(\"close\", function() {\n    console.log(\"Port closed\");\n  });\n}\n", "CodeBleu_score": 39.64728256062857}, {"code": "listen()  var serialPort = new SerialPort(this.portName, {\n    baudRate: this.baudRate,\n    autoOpen: false,\n    parser: SerialPort.parsers.readline(\"\\r\\n\")\n  });\n  var self = this;\n  serialPort.open(function(err) {\n    if (err) {\n      console.error(err);\n    } else {\n      console.log('Serial port open');\n      var input = \"\";\n      serialPort.on('data', function(data) {\n        input += data;\n        var sentences = input.split(\"\\r\\n\");\n        for (var i = 0; i < sentences.length - 1; i++) {\n          self.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      });\n    }\n  });\n}\n", "CodeBleu_score": 51.362717896612196}, {"code": "listen()  var port = this.port;\n  var input = \"\";\n  var complete = false;\n  var i;\n  var j;\n  var sentence;\n  var sentences = [];\n  var sentenceCount = 0;\n  var sentenceLength = 0;\n  var sentenceStart = 0;\n  var sentenceEnd = 0;\n  var sentenceIndex = 0;\n  var sentenceType = \"\";\n  var sentenceId = \"\";\n  var sentenceData = \"\";\n  var sentenceChecksum = \"\";\n  var sentenceChecksumValid = false;\n  var sentenceChecksumComputed = \"\";\n  var sentenceChecksumExpected = \"\";\n  var sentenceChecksumError = \"\";\n  var sentenceParsed = false;\n  var sentenceParsedError = \"\";\n  var sentenceParsedData = {};\n  var sentenceParsedFields = [];\n  var sentenceParsedFieldCount = 0;\n  var sentenceParsedFieldIndex = 0;\n  var sentenceParsedFieldName = \"\";\n  var sentenceParsedFieldValue = \"\";\n  var sentenceParsedFieldValueError = \"\";\n  var sentenceParsedFieldValueValid = false;\n  var sentenceParsedFieldValid = false;\n  var sentenceParsedValid = false;\n  var sentenceParsedError = \"\";\n  var sentenceParsedErrorCount = 0;\n  var sentenceParsedErrorIndex = 0;\n  var sentenceParsedErrorMessage = \"\";\n  var sentenceParsedErrorName = \"\";\n  var sentenceParsedErrorValue = \"\";\n  var sentenceParsedErrorValid = false;\n  var sentenceParsedErrorValidCount = 0;\n  var sentenceParsedErrorValidIndex = 0;\n  var sentenceParsedErrorValidMessage = \"\";\n  var sentenceParsedErrorValidName = \"\";\n  var sentenceParsedErrorValidValue = \"\";\n  var sentenceParsedErrorValidValid = false;\n  var sentenceParsedFieldValidCount = 0;\n  var sentenceParsedFieldValidIndex = 0;\n  var sentenceParsedFieldValidMessage = \"\";\n  var sentenceParsedFieldValidName = \"\";\n  var sentenceParsedFieldValidValue =", "CodeBleu_score": 14.193088914254004}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *cfg = dev->config;\n\tuint8_t active_channels = 0;\n\tuint32_t buffer_size;\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->resolution != ADC_RESOLUTION_12_BIT) {\n\t\t\tLOG_ERR(\"Only 12-bit resolution is supported\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tif (sequence->options[i].channel_id != ADC_ACQUISITION_LIST) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = active_channels * sequence->buffer_size;\n\tif (buffer_size > cfg->buffer_size) {\n\t\tLOG_ERR(\"Insufficient memory for the sequence\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 38.560470452813426}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tint ret = 0;\n\tuint8_t num_channels = 0;\n\tuint32_t buffer_size = 0;\n\n\t/* Get number of channels */\n\tnum_channels = adc_ad559x_get_num_channels(dev, sequence->channels);\n\n\t/* Get buffer size */\n\tbuffer_size = num_channels * sequence->resolution;\n\n\t/* Check buffer size */\n\tif (sequence->buffer_size < buffer_size) {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 49.40276513890378}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *cfg = dev->config;\n\tuint8_t num_channels = sequence->channels->mask_array[0];\n\tuint8_t num_active_channels = 0;\n\tuint16_t sample_size = sequence->resolution;\n\tuint32_t buffer_size = sequence->buffer_size;\n\tuint32_t needed_buffer_size;\n\n\tif (num_channels > 1) {\n\t\tLOG_ERR(\"AD559X only supports single channel conversion\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested sample size is supported */\n\tif (sample_size != 16) {\n\t\tLOG_ERR(\"AD559X only supports 16-bit sample size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested number of channels is supported */\n\tif (num_channels > cfg->num_channels) {\n\t\tLOG_ERR(\"AD559X only supports %d channels\", cfg->num_channels);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Calculate the number of active channels */\n\tfor (uint8_t i = 0; i < num_channels; i++) {\n\t\tif (sequence->channels->mask_array[i] & cfg->channel_mask) {\n\t\t\tnum_active_channels++;\n\t\t}\n\t}\n\n\t/* Calculate the needed buffer size */\n\tneeded_buffer_size = num_active_channels * sample_size / 8;\n\n\t/* Check if the buffer size is sufficient */\n\tif (buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"AD559X buffer size is insufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 47.83700599023643}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_cfg *cfg = dev->config;\n\tint ret = 0;\n\tuint8_t resolution;\n\tuint8_t channel;\n\tuint8_t channel_mask;\n\tuint8_t channel_shift;\n\tuint8_t channel_count;\n\tuint8_t channel_index;\n\tuint8_t channel_index_mask;\n\tuint8_t channel_index_shift;\n\tuint8_t channel_index_count;\n\tuint8_t channel_index_first;\n\tuint8_t channel_index_last;\n\tuint8_t channel_index_current;\n\tuint8_t channel_index_next;\n\tuint8_t channel_index_prev;\n\tuint8_t channel_index_last_prev;\n\tuint8_t channel_index_last_next;\n\tuint8_t channel_index_last_first;\n\tuint8_t channel_index_last_last;\n\tuint8_t channel_index_last_count;\n\tuint8_t channel_index_last_index;\n\tuint8_t channel_index_last_index_mask;\n\tuint8_t channel_index_last_index_shift;\n\tuint8_t channel_index_last_index_count;\n\tuint8_t channel_index_last_index_first;\n\tuint8_t channel_index_last_index_last;\n\tuint8_t channel_index_last_index_count;\n\tuint8_t channel_index_last_index_index;\n\tuint8_t channel_index_last_index_index_mask;\n\tuint8_t channel_index_last_index_index_shift;\n\tuint8_t channel_index_last_index_index_count;\n\tuint8_t channel_index_last_index_index_first;\n\tuint8_t channel_index_last_index_index_last;\n\tuint8_t channel_index_last_index_index_count;\n\tuint8_t channel_", "CodeBleu_score": 12.776578053204101}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *cfg = DEV_CFG(dev);\n\tstruct adc_ad559x_data *data = DEV_DATA(dev);\n\tint ret;\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\tuint8_t l;\n\tuint8_t m;\n\tuint8_t n;\n\tuint8_t o;\n\tuint8_t p;\n\tuint8_t q;\n\tuint8_t r;\n\tuint8_t s;\n\tuint8_t t;\n\tuint8_t u;\n\tuint8_t v;\n\tuint8_t w;\n\tuint8_t x;\n\tuint8_t y;\n\tuint8_t z;\n\tuint8_t zz;\n\tuint8_t aa;\n\tuint8_t bb;\n\tuint8_t cc;\n\tuint8_t dd;\n\tuint8_t ee;\n\tuint8_t ff;\n\tuint8_t gg;\n\tuint8_t hh;\n\tuint8_t ii;\n\tuint8_t jj;\n\tuint8_t kk;\n\tuint8_t ll;\n\tuint8_t mm;\n\tuint8_t nn;\n\tuint8_t oo;\n\tuint8_t pp;\n\tuint8_t qq;\n\tuint8_t rr;\n\tuint8_t ss;\n\tuint8_t tt;\n\tuint8_t uu;\n\tuint8_t vv;\n\tuint8_t ww;\n\tuint8_t xx;\n\tuint8_t yy;\n\tuint8_t zz_0;\n\tuint8_t aa_0;\n\tuint8_t bb_0;\n\tuint8_t cc_0;\n\tuint8_t dd_0;\n\tuint8_t ee_0;\n\tuint8_t ff_0;\n\tuint8_t gg_0;\n\tuint8_t hh_0;", "CodeBleu_score": 8.970507393514051}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)    struct adc_ad559x_data *data = dev->data;\n    const struct adc_ad559x_config *cfg = dev->config;\n    int ret;\n\n    if (sequence->channels == NULL || sequence->num_channels == 0) {\n        LOG_ERR(\"No channels specified\");\n        return -EINVAL;\n    }\n\n    if (sequence->channels[0].channel_id >= cfg->channels) {\n        LOG_ERR(\"Invalid channel\");\n        return -EINVAL;\n    }\n\n    if (sequence->resolution != 16) {\n        LOG_ERR(\"Invalid resolution\");\n        return -EINVAL;\n    }\n\n    if (sequence->buffer_size < sequence->num_channels) {\n        LOG_ERR(\"Invalid buffer size\");\n        return -ENOMEM;\n    }\n\n    if (data->read_pending) {\n        LOG_ERR(\"Read already pending\");\n        return -EBUSY;\n    }\n\n    data->read_pending = true;\n\n    ret = adc_context_start_read(&data->ctx, sequence);\n    if (ret) {\n        data->read_pending = false;\n        return ret;\n    }\n\n    return adc_context_wait_for_completion(&data->ctx);\n}\n", "CodeBleu_score": 52.88026599332502}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = ctx->data;\n\n\t/* Get the ADC device from the context */\n\tconst struct device *dev = adc_context_get_device(ctx);\n\n\t/* Get the channels to be sampled from the context */\n\tconst struct adc_sequence *sequence = adc_context_get_sequence(ctx);\n\n\t/* Get the repeat buffer from the context */\n\tuint8_t *repeat_buffer = adc_context_get_buffer(ctx);\n\n\t/* Get the number of channels to be sampled from the context */\n\tsize_t channel_count = adc_context_get_channel_count(ctx);\n\n\t/* Get the resolution from the context */\n\tuint8_t resolution = adc_context_get_resolution(ctx);\n\n\t/* Get the oversampling ratio from the context */\n\tuint8_t oversampling_ratio = adc_context_get_oversampling_ratio(ctx);\n\n\t/* Get the oversampling shift from the context */\n\tuint8_t oversampling_shift = adc_context_get_oversampling_shift(ctx);\n\n\t/* Get the gain from the context */\n\tuint8_t gain = adc_context_get_gain(ctx);\n\n\t/* Get the reference from the context */\n\tuint8_t reference = adc_context_get_reference(ctx);\n\n\t/* Get the trigger from the context */\n\tuint8_t trigger = adc_context_get_trigger(ctx);\n\n\t/* Get the channel sequence from the context */\n\tuint8_t *channel_sequence = adc_context_get_channel_sequence(ctx);\n\n\t/* Get the channel sequence length from the context */\n\tsize_t channel_sequence_len = adc_context_get_channel_sequence_len(ctx);\n\n\t/* Get the buffer length from the context */\n\tsize_t buffer_length = adc_context_get_buffer_length(ctx);\n\n\t/* Get the repeat buffer length from the context */\n\tsize_t repeat_buffer_length = adc_context_get_repeat_buffer_length", "CodeBleu_score": 13.699483381243638}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = ctx->data;\n\tuint8_t i;\n\n\t/* Get the ADC device from the context */\n\tstruct device *dev = data->dev;\n\n\t/* Set the channels to be sampled */\n\tadc_context_set_channels(ctx, data->channels, data->channel_count);\n\n\t/* Initialize the repeat buffer with the data buffer */\n\tfor (i = 0U; i < data->buffer_size; i++) {\n\t\tdata->buffer[i] = data->repeat_buffer[i];\n\t}\n\n\t/* Release the semaphore to start sampling */\n\tk_sem_give(&data->sem);\n\n\tLOG_DBG(\"ADC sampling started\");\n}\n", "CodeBleu_score": 49.993136999645074}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = ctx->data;\n\tuint32_t i;\n\n\t/* Get the ADC device structure from the context */\n\tstruct device *adc_dev = ctx->dev;\n\n\t/* Set the channels to be sampled */\n\tadc_context_set_channels(ctx, data->buffer, data->num_channels);\n\n\t/* Initialize the repeat buffer with the data buffer */\n\tfor (i = 0; i < data->num_channels; i++) {\n\t\tdata->repeat_buffer[i] = data->buffer[i];\n\t}\n\n\t/* Release the semaphore to signal the start of sampling */\n\tk_sem_give(&data->sem);\n\n\tLOG_DBG(\"ADC sampling started\");\n}\n", "CodeBleu_score": 50.06646591736732}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->buf = ctx->repeat_buf;\n\t} else {\n\t\tctx->buf = ctx->data;\n\t}\n}\n", "CodeBleu_score": 47.78602948970896}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tstruct adc_data_container *adc_data = adc_get_data_container(ctx);\n\tif (repeat_sampling) {\n\t\tctx->buffer = adc_data->repeat_buffer;\n\t} else {\n\t\tctx->buffer = adc_data->buffer;\n\t}\n}\n", "CodeBleu_score": 29.625597466535282}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer = ctx->data_container->buffer;\n\t}\n}\n", "CodeBleu_score": 50.35353254668243}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tstruct device *dev = data->dev;\n\tstruct adc_ad559x_channel_data *channel_data;\n\tint ret;\n\tu32_t channel;\n\tu32_t i;\n\tu32_t j;\n\tu32_t k;\n\tu32_t channel_count;\n\tu32_t channel_mask;\n\tu32_t channel_mask_size;\n\tu32_t channel_mask_index;\n\tu32_t channel_mask_index_max;\n\tu32_t channel_mask_index_min;\n\tu32_t channel_mask_index_max_index;\n\tu32_t channel_mask_index_min_index;\n\tu32_t channel_mask_index_max_index_index;\n\tu32_t channel_mask_index_min_index_index;\n\tu32_t channel_mask_index_max_index_index_index;\n\tu32_t channel_mask_index_min_index_index_index;\n\tu32_t channel_mask_index_max_index_index_index_index;\n\tu32_t channel_mask_index_min_index_index_index_index;\n\tu32_t channel_mask_index_max_index_index_index_index_index;\n\tu32_t channel_mask_index_min_index_index_index_index_index;\n\tu32_t channel_mask_index_max_index_index_index_index_index_index;\n\tu32_t channel_mask_index_min_index_index_index_index_index_index;\n\tu32_t channel_mask_index_max_index_index_index_index_index_index_index;\n\tu32_t channel_mask_index_min_index_index_index_index_index_index_index;\n\tu32_t channel_mask_index_max_index_index_index_index_index_index_index_index;\n\tu32_t channel_mask", "CodeBleu_score": 9.697266557466364}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tint ret;\n\tint i;\n\tint j;\n\tint k;\n\tint n;\n\tint m;\n\tint ch;\n\tint ch_idx;\n\tint ch_mask;\n\tint ch_num;\n\tint ch_num_tmp;\n\tint ch_num_tmp_mask;\n\tint ch_num_tmp_mask_tmp;\n\tint ch_num_tmp_mask_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint ch_num_tmp_mask_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp", "CodeBleu_score": 4.133392942520721}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tint ret;\n\tuint32_t chan;\n\tuint32_t num_channels;\n\tuint32_t num_active_channels;\n\tuint32_t num_read_channels;\n\tuint32_t num_read_samples;\n\tuint32_t num_read_samples_total;\n\tuint32_t num_read_samples_remaining;\n\tuint32_t num_read_samples_to_read;\n\tuint32_t num_read_samples_to_read_total;\n\tuint32_t num_read_samples_to_read_remaining;\n\tuint32_t num_read_samples_to_read_total_remaining;\n\tuint32_t num_read_samples_to_read_remaining_remaining;\n\tuint32_t num_read_samples_to_read_total_remaining_remaining;\n\tuint32_t num_read_samples_to_read_remaining_remaining_remaining;\n\tuint32_t num_read_samples_to_read_total_remaining_remaining_remaining;\n\tuint32_t num_read_samples_to_read_remaining_remaining_remaining_remaining;\n\tuint32_t num_read_samples_to_read_remaining_remaining_remaining_remaining_remaining;\n\tuint32_t num_read_samples_to_read_remaining_remaining_remaining_remaining_remaining_remaining;\n\tuint32_t num_read_samples_to_read_remaining_remaining_remaining_remaining_remaining_remaining_remaining;\n\tuint32_t num_read_samples_to_read_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining;\n\tuint32_t num_read_samples_to_read_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining;\n\tuint32_t num_read_samples_to_", "CodeBleu_score": 5.083925595303236}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev)    int ret;\n    uint8_t reg_config;\n    struct ads1112_data *data = dev->data;\n\n    /* Check if the device is ready to read data. */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_config);\n    if (ret != 0) {\n        return ret;\n    }\n    /* If the device is ready, return 0. */\n    if (reg_config & ADS1112_CONFIG_DRDY_MASK) {\n        return 0;\n    }\n\n    /* If the device is not ready, wait for the ready time. */\n    k_sleep(K_USEC(data->ready_time));\n\n    /* Check if the device is ready to read data. */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_config);\n    if (ret != 0) {\n        return ret;\n    }\n    /* If the device is ready, return 0. */\n    if (reg_config & ADS1112_CONFIG_DRDY_MASK) {\n        return 0;\n    }\n\n    /* If the device is not ready, repeatedly sleep for 100 microseconds and check the status. */\n    while (!(reg_config & ADS1112_CONFIG_DRDY_MASK)) {\n        k_sleep(K_USEC(100));\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_config);\n        if (ret != 0) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 62.00561513201394}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    struct ads1112_data *data = dev->data;\n    int ret;\n    uint8_t config;\n\n    /* Wait for the device to be ready for data reading */\n    k_sleep(K_USEC(data->device_ready_time));\n\n    /* Read the configuration register to check the status */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n    if (ret) {\n        return ret;\n    }\n\n    /* Check the status */\n    if (config & ADS1112_REG_CONFIG_OS_MASK) {\n        return 0;\n    } else {\n        return -EIO;\n    }\n}\n", "CodeBleu_score": 38.817021967798055}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    struct ads1112_data *data = dev->data;\n    struct ads1112_config *cfg = dev->config;\n    uint8_t config_reg;\n    int ret;\n\n    /* Sleep for the device's ready time */\n    k_sleep(K_USEC(cfg->ready_time));\n\n    /* Read the configuration register */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n    if (ret != 0) {\n        LOG_ERR(\"ADS1112: Error reading configuration register\");\n        return ret;\n    }\n\n    /* If the device is not ready, sleep and check again */\n    while (!(config_reg & ADS1112_CONFIG_DRDY)) {\n        /* Sleep for 100 microseconds */\n        k_sleep(K_USEC(100));\n\n        /* Read the configuration register */\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n        if (ret != 0) {\n            LOG_ERR(\"ADS1112: Error reading configuration register\");\n            return ret;\n        }\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 57.726846939108015}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tint32_t buffer_size = sequence->options.extra_samplings * sequence->channels;\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size (%d) is too small for the number of samplings (%d) and extra samplings (%d)\",\n\t\t\tsequence->buffer_size, sequence->options.num_samplings, sequence->options.extra_samplings);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 33.50772083447602}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tint required_buffer_size = 0;\n\tint num_samplings = 0;\n\tint num_extra_samplings = 0;\n\n\t/* Check if the buffer size is sufficient */\n\tnum_samplings = sequence->channels * sequence->buffer_size;\n\tnum_extra_samplings = sequence->options.extra_samplings;\n\trequired_buffer_size = num_samplings + num_extra_samplings;\n\n\tif (required_buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is not sufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 46.09037651971719}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tint n_samples = sequence->options.extra_samplings + 1;\n\tint req_size = n_samples * sizeof(struct adc_sample);\n\tif (sequence->buffer_size < req_size) {\n\t\tLOG_ERR(\"Buffer size %d is insufficient for %d samples\", sequence->buffer_size, n_samples);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 42.046702309831716}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tconst struct ads1112_config *cfg = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (!sequence->buffer) {\n\t\tLOG_ERR(\"NULL buffer\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\tLOG_ERR(\"Unsupported channels\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channel_id != 0) {\n\t\tLOG_ERR(\"Unsupported channel\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Unsupported resolution\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Unsupported oversampling\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Unsupported calibration\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate_channel != 0) {\n\t\tLOG_ERR(\"Unsupported calibration channel\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate_result != NULL) {\n\t\tLOG_ERR(\"Unsupported calibration result\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate_type != ADC_CALIBRATION_NONE) {\n\t\tLOG_ERR(\"Unsupported calibration type\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Buffer size error\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tdata->buffer_size = sequence->buffer_", "CodeBleu_score": 39.44147031622249}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tconst struct ads1112_config *cfg = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tstruct adc_context *ctx = &data->ctx;\n\tint ret;\n\n\t/* Get hardware channel number */\n\tuint8_t channel = sequence->channels->channel_id;\n\n\t/* Check if the channel is valid */\n\tif (channel > ADS1112_CHANNEL_MAX) {\n\t\tLOG_ERR(\"Invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the gain is valid */\n\tif (sequence->channels->gain != ADS1112_GAIN_1 &&\n\t    sequence->channels->gain != ADS1112_GAIN_2 &&\n\t    sequence->channels->gain != ADS1112_GAIN_4 &&\n\t    sequence->channels->gain != ADS1112_GAIN_8 &&\n\t    sequence->channels->gain != ADS1112_GAIN_16) {\n\t\tLOG_ERR(\"Invalid gain\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the sampling frequency is valid */\n\tif (sequence->sampling_frequency != ADS1112_SAMPLING_FREQ_128 &&\n\t    sequence->sampling_frequency != ADS1112_SAMPLING_FREQ_250 &&\n\t    sequence->sampling_frequency != ADS1112_SAMPLING_FREQ_490 &&\n\t    sequence->sampling_frequency != ADS1112_SAMPLING_FREQ_920 &&\n\t    sequence->sampling_frequency != ADS1112_SAMPLING_FREQ_1600 &&\n\t    sequence->sampling_frequency != ADS1112_SAMPLING_FREQ_2400 &&\n\t    sequence->sampling_frequency != ADS1112_SAMPLING_F", "CodeBleu_score": 37.685781629996626}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tstruct adc_context *ctx = &data->ctx;\n\tuint8_t reg_config = 0;\n\tint ret = 0;\n\n\tif (!sequence->buffer || !sequence->length) {\n\t\tLOG_ERR(\"Invalid buffer or length\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels != 1) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Invalid options\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Invalid oversampling\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Setup the configuration register */\n\tswitch (sequence->channels) {\n\tcase 1:\n\t\treg_config |= ADS1112_REG_CONFIG_MUX_AIN0;\n\t\tbreak;\n\tcase 2:\n\t\treg_config |= ADS1112_REG_CONFIG_MUX_AIN1;\n\t\tbreak;\n\tcase 3:\n\t\treg_config |= ADS1112_REG_CONFIG_MUX_AIN2;\n\t\tbreak;\n\tcase 4:\n\t\treg_config |= ADS1112_REG_CONFIG_MUX_AIN3;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (sequence->resolution) {\n\tcase 12:\n\t\treg_config |= ADS1112_REG_CONFIG_PGA_12;\n\t\tbreak;\n\tcase 16:\n\t\treg_config |= ADS1112_REG_CONFIG_PGA", "CodeBleu_score": 42.64105905884576}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tstruct device *dev;\n\tstruct audio_codec_dev_cfg cfg = {0};\n\tstruct audio_codec_dev_data data = {0};\n\tchar *device_name = argv[1];\n\n\tdev = device_get_binding(device_name);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", device_name);\n\t\treturn -ENODEV;\n\t}\n\n\tcfg.codec = argv[2];\n\tcfg.type = argv[3];\n\tcfg.format = argv[4];\n\tcfg.rate = argv[5];\n\tcfg.channels = argv[6];\n\n\tret = audio_codec_dev_configure(dev, &cfg);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to configure device %s\", device_name);\n\t\treturn ret;\n\t}\n\n\tret = audio_codec_dev_init(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to init device %s\", device_name);\n\t\treturn ret;\n\t}\n\n\tret = audio_codec_dev_start(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to start device %s\", device_name);\n\t\treturn ret;\n\t}\n\n\tret = audio_codec_dev_stop(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to stop device %s\", device_name);\n\t\treturn ret;\n\t}\n\n\tret = audio_codec_dev_uninit(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to uninit device %s\", device_name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 48.803671593154505}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tstruct device *dev;\n\tstruct audio_codec_properties props;\n\tstruct audio_codec_dev_config config;\n\tstruct device_config dev_config;\n\tstruct device_config *dev_config_ptr;\n\tconst char *dev_name;\n\tstruct device_config *dev_config_ptr_temp;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev_name = argv[1];\n\n\tif (argc == 4) {\n\t\tprops.gain = atoi(argv[2]);\n\t\tprops.mic_vol = atoi(argv[3]);\n\t} else if (argc == 5) {\n\t\tprops.gain = atoi(argv[2]);\n\t\tprops.mic_vol = atoi(argv[3]);\n\t\tprops.mic_mute = atoi(argv[4]);\n\t} else if (argc == 6) {\n\t\tprops.gain = atoi(argv[2]);\n\t\tprops.mic_vol = atoi(argv[3]);\n\t\tprops.mic_mute = atoi(argv[4]);\n\t\tprops.spk_vol = atoi(argv[5]);\n\t} else if (argc == 7) {\n\t\tprops.gain = atoi(argv[2]);\n\t\tprops.mic_vol = atoi(argv[3]);\n\t\tprops.mic_mute = atoi(argv[4]);\n\t\tprops.spk_vol = atoi(argv[5]);\n\t\tprops.spk_mute = atoi(argv[6]);\n\t} else {\n\t\tshell_error(sh, \"Too many arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(dev_name);\n\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev_config_ptr = device_config_get(dev, &", "CodeBleu_score": 51.96540719824895}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint err;\n\tstruct device *dev;\n\tstruct device_config *config;\n\tchar *device_name;\n\tchar *property_name;\n\tchar *property_value;\n\tchar *property_type;\n\n\tif (argc < 4) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_name = argv[1];\n\tproperty_name = argv[2];\n\tproperty_value = argv[3];\n\tproperty_type = argv[4];\n\n\tdev = device_get_binding(device_name);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", device_name);\n\t\treturn -ENODEV;\n\t}\n\n\tconfig = device_get_config(dev);\n\tif (!config) {\n\t\tshell_error(sh, \"Device %s not found\", device_name);\n\t\treturn -ENODEV;\n\t}\n\n\tif (strcmp(property_type, \"int\") == 0) {\n\t\terr = device_config_set_int(config, property_name, atoi(property_value));\n\t} else if (strcmp(property_type, \"string\") == 0) {\n\t\terr = device_config_set_string(config, property_name, property_value);\n\t} else {\n\t\tshell_error(sh, \"Unknown property type %s\", property_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (err) {\n\t\tshell_error(sh, \"Failed to apply property %s to device %s\", property_name, device_name);\n\t\treturn err;\n\t}\n\n\tshell_print(sh, \"Property %s applied to device %s\", property_name, device_name);\n\n\treturn 0;\n}\n", "CodeBleu_score": 50.18056342875576}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tconst struct mpxxdtyy_i2s_dev_config *config = dev->config;\n\tstruct mpxxdtyy_i2s_dev_data *data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\t/* If the device is already in the active state, then there's nothing to do. */\n\t\tif (data->state == DMIC_ACTIVE) {\n\t\t\tLOG_WRN(\"DMIC already active\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* If the device is in the configured state, then we need to set the I2S command and transition to active. */\n\t\tif (data->state == DMIC_CONFIGURED) {\n\t\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, config->i2s_cmd);\n\t\t\tif (ret != 0) {\n\t\t\t\tLOG_ERR(\"I2S trigger failed with error %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdata->state = DMIC_ACTIVE;\n\t\t}\n\n\t\t/* If the device is in the idle state, then we need to set the I2S command and transition to configured. */\n\t\tif (data->state == DMIC_IDLE) {\n\t\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, config->i2s_cmd);\n\t\t\tif (ret != 0) {\n\t\t\t\tLOG_ERR(\"I2S trigger failed with error %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdata->state = DMIC_CONFIGURED;\n\t\t}\n\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\t/* If the device is already in the idle state, then there's nothing to do. */\n\t\tif (data->state == DMIC_IDLE) {\n\t\t\tLOG_WRN(\"DMIC already idle\");\n\t\t\t", "CodeBleu_score": 59.669743557175536}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tint err;\n\tstruct dmic_data *data = dev->data;\n\tstruct dmic_cfg *cfg = dev->config;\n\tuint32_t i2s_cmd;\n\tuint32_t i2s_state;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC already active\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\ti2s_cmd = I2S_CMD_START;\n\t\t\ti2s_state = I2S_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_ERR(\"DMIC not configured\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"DMIC not active\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\ti2s_cmd = I2S_CMD_STOP;\n\t\t\ti2s_state = I2S_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"DMIC not active\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"DMIC trigger command not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = i2s_trigger(cfg->i2s_dev, i2s_cmd);\n\tif (err) {\n\t\tLOG_ERR(\"DMIC I2S trigger failed\");\n\t\treturn err;\n\t}\n\n\tdata->state = i2s_state;\n\n\treturn 0;\n}\n", "CodeBleu_score": 60.74795217011024}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\n\t/*\n\t * The I2S command is sent only if the device is in the configured state.\n\t */\n\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\tswitch (cmd) {\n\t\tcase DMIC_TRIGGER_START:\n\t\t\t/*\n\t\t\t * The I2S command is sent only if the device is in the configured state.\n\t\t\t */\n\t\t\tret = i2s_trigger(config->i2s_dev, I2S_DIR_RX, &data->i2s_dev_cfg);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Failed to start I2S device %s: %d\", config->i2s_dev->name, ret);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMIC_TRIGGER_STOP:\n\t\t\t/*\n\t\t\t * The I2S command is sent only if the device is in the active state.\n\t\t\t */\n\t\t\tret = i2s_trigger(config->i2s_dev, I2S_DIR_RX, NULL);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Failed to stop I2S device %s: %d\", config->i2s_dev->name, ret);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"Invalid DMIC trigger command %d\", cmd);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Invalid DMIC state %d\", data->state);\n\t\tret = -EINVAL;\n\t}\n\n", "CodeBleu_score": 53.393006482639485}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0;\n\n\t/* Retrieve the configuration and data */\n\tcommand |= (data->display_mode.cursor_blink ? HD44780_DISPLAY_MODE_BLINK_CURSOR : 0);\n\tcommand |= (data->display_mode.cursor_on ? HD44780_DISPLAY_MODE_CURSOR_ON : 0);\n\tcommand |= (data->display_mode.display_on ? HD44780_DISPLAY_MODE_DISPLAY_ON : 0);\n\n\t/* Modify the command based on the current cursor and position blink settings */\n\tcommand |= (data->cursor_position.blink ? HD44780_DISPLAY_MODE_BLINK_POSITION : 0);\n\tcommand |= (data->cursor_position.position == HD44780_CURSOR_POSITION_LEFT ? HD44780_DISPLAY_MODE_CURSOR_POSITION_LEFT : 0);\n\tcommand |= (data->cursor_position.position == HD44780_CURSOR_POSITION_RIGHT ? HD44780_DISPLAY_MODE_CURSOR_POSITION_RIGHT : 0);\n\n\t/* If the display is enabled, set the corresponding flag */\n\tdata->display_mode.display_on = enabled;\n\n\t/* Send the command to the device to update the display mode */\n\ti2c_reg_write_byte(config->i2c_dev, config->i2c_address, command, HD44780_REGISTER_DISPLAY_MODE);\n}\n", "CodeBleu_score": 41.850490533740405}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)    struct aux_display_hd44780_data *data = dev->data;\n    uint8_t cmd[2];\n\n    /* Retrieve the configuration from the device */\n    aux_display_hd44780_get_config(dev, &data->config);\n\n    /* Initialize the display mode command */\n    cmd[0] = AUX_DISPLAY_HD44780_DISPLAY_MODE_CMD;\n    cmd[1] = (data->config.cursor_blink ? AUX_DISPLAY_HD44780_DISPLAY_MODE_BLINK_ON : 0x00) |\n             (data->config.cursor_enabled ? AUX_DISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON : 0x00) |\n             (data->config.cursor_position ? AUX_DISPLAY_HD44780_DISPLAY_MODE_CURSOR_POS : 0x00) |\n             (enabled ? AUX_DISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON : 0x00);\n\n    /* Send the command to the device */\n    aux_display_hd44780_send_command(dev, cmd, sizeof(cmd));\n}\n", "CodeBleu_score": 40.88236110193885}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct aux_display_hd44780_data *data = dev->data;\n\tuint8_t cmd;\n\n\t/* Retrieve the configuration and data from the device */\n\tif (i2c_reg_read_byte(data->i2c, data->i2c_addr, HD44780_CMD_DISPLAY_MODE, &cmd) < 0) {\n\t\tLOG_ERR(\"Could not read display mode command\");\n\t\treturn;\n\t}\n\n\t/* Configure the display mode command */\n\tcmd &= ~(HD44780_DISPLAY_MODE_DISPLAY_ON | HD44780_DISPLAY_MODE_CURSOR_ON | HD44780_DISPLAY_MODE_BLINK_ON);\n\tif (enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->cursor_on) {\n\t\tcmd |= HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\tif (data->blink_on) {\n\t\tcmd |= HD44780_DISPLAY_MODE_BLINK_ON;\n\t}\n\n\t/* Send the command to the device */\n\tif (i2c_reg_write_byte(data->i2c, data->i2c_addr, HD44780_CMD_DISPLAY_MODE, cmd) < 0) {\n\t\tLOG_ERR(\"Could not write display mode command\");\n\t\treturn;\n\t}\n\n\t/* Update the display mode flag */\n\tdata->display_mode_enabled = enabled;\n}\n", "CodeBleu_score": 58.24353550512515}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (config->busy_gpio_name == NULL) {\n\t\tLOG_ERR(\"The busy GPIO port is not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_gpio_dev, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get the status of the busy GPIO pin (err = %d)\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->busy = ret;\n\n\treturn ret;\n}\n", "CodeBleu_score": 56.558685893346095}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\tgpio_pin_t pin;\n\tuint8_t val;\n\n\tif (data->busy_port == NULL) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tpin = data->busy_pin;\n\n\tret = gpio_pin_get_raw(data->busy_port, pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO pin\");\n\t\treturn ret;\n\t}\n\n\tval = ret;\n\n\treturn val;\n}\n", "CodeBleu_score": 48.149608640146184}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tstruct auxdisplay_itron_data *data = dev->data;\n\tuint32_t gpio_pin_status;\n\tint ret;\n\n\t/* Check if the busy GPIO port is defined */\n\tif (!data->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Get the status of the busy GPIO pin */\n\tret = gpio_pin_get_raw(data->busy_gpio_port, data->busy_gpio_pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Cannot get status of busy GPIO pin %d\",\n\t\t\tdata->busy_gpio_pin);\n\t\treturn ret;\n\t}\n\n\t/* Check if the GPIO pin is high */\n\tif (ret) {\n\t\treturn 0;\n\t}\n\n\t/* Check if the GPIO pin is low */\n\tif (!ret) {\n\t\treturn 1;\n\t}\n\n\t/* Check if the GPIO pin is high or low */\n\tif (ret != 0) {\n\t\tLOG_ERR(\"Invalid status of busy GPIO pin %d\",\n\t\t\tdata->busy_gpio_pin);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 47.30555118555362}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint rc;\n\n\tbuffer[0] = data->special_command_prefix;\n\tbuffer[1] = command;\n\n\trc = i2c_write(data->i2c, buffer, sizeof(buffer), data->i2c_address);\n\n\tif (rc != 0) {\n\t\tLOG_ERR(\"Failed to write to I2C device %s: %d\",\n\t\t\tdata->i2c_dev->name, rc);\n\t\treturn rc;\n\t}\n\n\tif (data->delay_after_special_command != 0) {\n\t\tk_sleep(data->delay_after_special_command);\n\t}\n\n\treturn rc;\n}\n", "CodeBleu_score": 49.50707575151144}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tint ret;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = (uint8_t) command;\n\n\tret = i2c_write(data->i2c, buffer, 2, data->i2c_address);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Error %d on writing special command %d to device %s\",\n\t\t\tret, command, data->i2c_dev->name);\n\t\treturn ret;\n\t}\n\n\tif (data->special_command_delay_ms > 0) {\n\t\tk_sleep(K_MSEC(data->special_command_delay_ms));\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 49.276280835124055}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint rc;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\trc = i2c_write(data->i2c_dev, buffer, sizeof(buffer), config->i2c_address);\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Failed to write to I2C device %s: %d\", config->i2c_dev->name, rc);\n\t\treturn rc;\n\t}\n\n\tk_busy_wait(config->delay_after_special_command_us);\n\n\treturn rc;\n}\n", "CodeBleu_score": 57.814497402008854}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_dev_config *config = dev->config;\n\tstruct bbram_emul_dev_data *data_ptr = dev->data;\n\tsize_t i;\n\n\t/* Check if the requested read size is valid */\n\tif (size > config->size) {\n\t\tLOG_ERR(\"Invalid read size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested read operation does not exceed the memory bounds */\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Invalid read offset\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested read operation does not involve invalid memory */\n\tif (offset < config->start_addr) {\n\t\tLOG_ERR(\"Invalid read offset\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tfor (i = 0; i < size; i++) {\n\t\tdata[i] = data_ptr->memory[offset + i];\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 50.30915777465923}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_dev_cfg * const cfg = dev->config;\n\tstruct bbram_emul_dev_data * const dev_data = dev->data;\n\n\tif (size > cfg->size) {\n\t\tLOG_ERR(\"Read size (%zu) is larger than the device's size (%zu)\",\n\t\t\tsize, cfg->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\tLOG_ERR(\"Read size (%zu) exceeds the device's size (%zu)\",\n\t\t\tsize, cfg->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\tLOG_ERR(\"Read size (%zu) exceeds the device's size (%zu)\",\n\t\t\tsize, dev_data->size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &dev_data->mem[offset], size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 52.21072729819083}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tstruct bbram_emul_data *dev_data = DEV_DATA(dev);\n\n\tif (size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->data + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 64.87452195888368}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_dev_data_t *dev_data = DEV_DATA(dev);\n\tint ret = 0;\n\tuint32_t i;\n\n\t/* Check if the write size is valid */\n\tif (size > BBRAM_SIZE) {\n\t\tLOG_ERR(\"Invalid write size %d\", size);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif (offset + size > BBRAM_SIZE) {\n\t\tLOG_ERR(\"Write operation is out of bounds\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (dev_data->state == BBRAM_STATE_INVALID) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tfor (i = 0; i < size; i++) {\n\t\tdev_data->mem[offset + i] = data[i];\n\t}\n\n\t/* Update the device's state */\n\tdev_data->state = BBRAM_STATE_VALID;\n", "CodeBleu_score": 46.29115382679723}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *emul = dev->data;\n\tsize_t i;\n\n\t/* Check if the write size is valid */\n\tif (size > emul->size) {\n\t\tLOG_ERR(\"Invalid write size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif (offset + size > emul->size) {\n\t\tLOG_ERR(\"Write operation exceeds BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (emul->state != BBRAM_EMUL_STATE_READY) {\n\t\tLOG_ERR(\"BBRAM is not ready\");\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tfor (i = 0; i < size; i++) {\n\t\temul->data[offset + i] = data[i];\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 45.9042773733461}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *dev_data = dev->data;\n\tint rc = 0;\n\n\tif (offset + size > dev_data->size) {\n\t\tLOG_ERR(\"Invalid write size\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (offset < dev_data->offset) {\n\t\tLOG_ERR(\"Invalid write offset\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (dev_data->state == BBRAM_STATE_INVALID) {\n\t\tLOG_ERR(\"Invalid BBRAM state\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(dev_data->mem + offset, data, size);\n", "CodeBleu_score": 50.847292584717295}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tconst struct device *dev;\n\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_bind(dev, bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Unable to bind to device\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 61.52998669924514}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tconst struct device *dev;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name.\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found.\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_bind(dev, bbram_dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to bind to device %s.\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 66.03185901997226}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device argument missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}\n", "CodeBleu_score": 66.51294214659083}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev)\tstruct h4_data *data = dev->data;\n\tuint8_t *buf = data->hdr_buf;\n\tuint16_t *hdr_cnt = &data->hdr_cnt;\n\tuint16_t *hdr_len = &data->hdr_len;\n\tuint16_t *hdr_rem = &data->hdr_rem;\n\tuint16_t *hdr_off = &data->hdr_off;\n\tuint8_t *hdr_ptr = &data->hdr_ptr;\n\tuint16_t bytes_read;\n\n\t/* Read the number of bytes already read */\n\tbytes_read = *hdr_cnt;\n\n\t/* Attempt to read the remaining bytes from the UART FIFO */\n\tif (uart_fifo_read(dev, buf + bytes_read, *hdr_rem) != *hdr_rem) {\n\t\tLOG_ERR(\"Failed to read %d bytes from UART FIFO\", *hdr_rem);\n\t\treturn;\n\t}\n\n\t/* Update the number of bytes read */\n\t*hdr_cnt = *hdr_cnt + *hdr_rem;\n\n\t/* Update the number of bytes remaining */\n\t*hdr_rem = *hdr_len - *hdr_cnt;\n\n\t/* Update the pointer to the next byte in the header buffer */\n\t*hdr_ptr = *hdr_ptr + *hdr_rem;\n\n\t/* Update the offset into the header buffer */\n\t*hdr_off = *hdr_off + *hdr_rem;\n\n\t/* If the header has been read in full, process it */\n\tif (*hdr_cnt == *hdr_len) {\n\t\th4_process_hdr(dev);\n\t}\n}\n", "CodeBleu_score": 38.86988893549964}, {"code": "static void h4_read_hdr(const struct device *dev)\tuint32_t bytes_read = 0;\n\tuint32_t bytes_remaining = 0;\n\tuint32_t bytes_to_read = 0;\n\tuint32_t bytes_read_from_fifo = 0;\n\tuint32_t bytes_read_from_fifo_total = 0;\n\tuint32_t bytes_read_total = 0;\n\tuint32_t bytes_read_total_max = 0;\n\tuint32_t bytes_read_total_min = 0;\n\tuint32_t bytes_read_total_avg = 0;\n\tuint32_t bytes_read_total_sum = 0;\n\tuint32_t bytes_read_total_count = 0;\n\tuint32_t bytes_read_total_count_max = 0;\n\tuint32_t bytes_read_total_count_min = 0;\n\tuint32_t bytes_read_total_count_avg = 0;\n\tuint32_t bytes_read_total_count_sum = 0;\n\tuint32_t bytes_read_total_count_avg_sum = 0;\n\tuint32_t bytes_read_total_count_avg_count = 0;\n\tuint32_t bytes_read_total_count_avg_sum_count = 0;\n\tuint32_t bytes_read_total_count_avg_sum_count_max = 0;\n\tuint32_t bytes_read_total_count_avg_sum_count_min = 0;\n\tuint32_t bytes_read_total_count_avg_sum_count_avg = 0;\n\tuint32_t bytes_read_total_count_avg_sum_count_avg_sum = 0;\n\tuint32_t bytes_read_total_count_avg_sum_count_avg_count = 0;\n\tuint32_t bytes_read_total_count_avg_sum_count_avg_sum_", "CodeBleu_score": 7.301653784211356}, {"code": "static void h4_read_hdr(const struct device *dev)\tstruct h4_data *h4 = dev->data;\n\tstruct net_buf *buf = h4->hdr_buf;\n\tuint8_t *data = buf->data;\n\tsize_t len = buf->len;\n\tsize_t n;\n\n\tif (h4->hdr_cnt == 0) {\n\t\t/* First header byte */\n\t\tn = uart_fifo_read(dev, data, 1);\n\t\tif (n != 1) {\n\t\t\tLOG_ERR(\"Failed to read header byte\");\n\t\t\treturn;\n\t\t}\n\t\th4->hdr_cnt = 1;\n\t\th4->hdr_idx = 0;\n\t} else {\n\t\t/* Read remaining header bytes */\n\t\tn = uart_fifo_read(dev, data + h4->hdr_idx, len - h4->hdr_idx);\n\t\tif (n == 0) {\n\t\t\tLOG_ERR(\"Failed to read header bytes\");\n\t\t\treturn;\n\t\t}\n\t\th4->hdr_idx += n;\n\t}\n\n\tif (h4->hdr_idx < len) {\n\t\t/* More data to read */\n\t\treturn;\n\t}\n\n\t/* Header fully read */\n\th4->hdr_cnt = 0;\n\n\t/* Check if header is valid */\n\tif (data[0] != H4_HDR_MAGIC) {\n\t\tLOG_ERR(\"Invalid header\");\n\t\treturn;\n\t}\n\n\t/* Header is valid */\n\th4->hdr_idx = 0;\n\th4->hdr_len = data[1];\n\tif (h4->hdr_len > len) {\n\t\tLOG_ERR(\"Header length exceeds buffer size\");\n\t\treturn;\n\t}\n\n\t/* Read remaining header bytes */\n\tn = uart_fifo_read(dev, data + h4->hdr_idx, h4->hdr_len - h4->hdr_idx);\n\tif (n == 0) {\n\t\tLOG_ERR(\"Failed to", "CodeBleu_score": 44.79798364093956}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t rd;\n\n\trd = h4_read(uart, buf, sizeof(buf));\n\tif (rd > len) {\n\t\trd = len;\n\t}\n\n\treturn rd;\n}\n", "CodeBleu_score": 40.617958700941884}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t ret = 0;\n\twhile (len > 0) {\n\t\tsize_t to_read = len;\n\t\tif (to_read > sizeof(buf)) {\n\t\t\tto_read = sizeof(buf);\n\t\t}\n\t\tif (uart_fifo_read(uart, buf, to_read) != to_read) {\n\t\t\tLOG_ERR(\"Failed to discard %zu bytes from UART\", len);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= to_read;\n\t\tret += to_read;\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 35.59112780369659}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tsize_t read_len = 0;\n\tsize_t i;\n\tuint8_t buffer[33];\n\tfor(i=0; i<len; i+=32) {\n\t\tread_len = uart_fifo_read(uart, buffer, (len-i > 32) ? 32 : (len-i));\n\t\tif(read_len != (len-i)) {\n\t\t\tLOG_ERR(\"Failed to read %d bytes from UART FIFO buffer\", len-i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn len;\n}\n", "CodeBleu_score": 33.328675665310556}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tstruct zbus_observer *observer;\n\tuint32_t priority = 0;\n\t\n\tchan_lock(chan);\n\t\n\tobserver = chan->observers;\n\twhile (observer != NULL) {\n\t\tif (observer->enabled) {\n\t\t\tif (observer->priority > priority) {\n\t\t\t\tpriority = observer->priority;\n\t\t\t}\n\t\t}\n\t\tobserver = observer->next;\n\t}\n\t\n\tchan->highest_observer_priority = priority;\n\t\n\tchan_unlock(chan);\n}\n", "CodeBleu_score": 23.193177449504923}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tstruct zbus_observer *observer;\n\tint prio;\n\tint i;\n\n\t/* Lock the channel data */\n\tchan_lock(chan);\n\n\t/* Iterate through the observers */\n\tfor (i = 0; i < chan->observer_count; i++) {\n\t\tobserver = chan->observers[i];\n\n\t\t/* Check the observer's priority and whether it is enabled */\n\t\tif (observer->priority > prio && observer->enabled) {\n\t\t\tprio = observer->priority;\n\t\t}\n\t}\n\n\t/* Set the channel's highest observer priority to the determined value */\n\tchan->highest_observer_priority = prio;\n\n\t/* Unlock the channel data */\n\tchan_unlock(chan);\n}\n", "CodeBleu_score": 22.984199938983934}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    unsigned int prio = 0;\n    bool enabled = false;\n    unsigned int i;\n    for (i = 0; i < chan->observer_count; i++) {\n        if (chan->observers[i].enabled) {\n            enabled = true;\n            if (chan->observers[i].priority > prio) {\n                prio = chan->observers[i].priority;\n            }\n        }\n    }\n    chan->highest_observer_priority = prio;\n    chan->highest_observer_enabled = enabled;\n}\n", "CodeBleu_score": 26.63782683805601}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tstruct zbus_channel_obs *obs_ch;\n\tstruct zbus_channel *ch;\n\n\tfor (obs_ch = obs->channels; obs_ch; obs_ch = obs_ch->next) {\n\t\tch = obs_ch->ch;\n\t\tif (obs_ch->obs == obs)\n\t\t\tupdate_channel(ch);\n\t}\n}\n", "CodeBleu_score": 17.42471260312773}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tstruct zbus_channel *chan;\n\tfor (chan = zbus_channels; chan != NULL; chan = chan->next) {\n\t\tif (obs == chan->obs) {\n\t\t\tupdate_channel(chan);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 22.00605626222772}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct zbus_channel *channel;\n    struct zbus_channel_obs *obs_channel;\n    struct zbus_channel_obs *tmp;\n    LIST_FOREACH_SAFE(obs_channel, &obs->channels, entries, tmp) {\n        channel = obs_channel->channel;\n        if (obs == channel->obs) {\n            zbus_update_channel(channel);\n        }\n    }\n}\n", "CodeBleu_score": 19.250186527998107}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    assert(obs != NULL);\n    assert(obs->thread != NULL);\n    assert(!in_isr());\n    spin_lock(&obs->lock);\n    obs->thread = get_current_thread();\n    obs->priority = obs->thread->priority;\n    zbus_obs_update_channels(obs);\n    spin_unlock(&obs->lock);\n    return 0;\n}\n", "CodeBleu_score": 45.15675310268719}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tassert(!in_isr());\n\tassert(obs);\n\tint ret = spin_lock_irqsave(&obs->lock);\n\tif (ret)\n\t\treturn ret;\n\tobs->priority = THREAD_PRIORITY_MIN;\n\tzbus_obs_update_all_channels(obs);\n\tspin_unlock_irqrestore(&obs->lock, ret);\n\treturn 0;\n}\n", "CodeBleu_score": 45.854310442131386}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tassert(!in_isr());\n\tassert(obs != NULL);\n\t\n\tspin_lock(&obs->lock);\n\tobs->priority = ZBUS_THREAD_PRIORITY_MIN;\n\tzbus_obs_update_channels(obs);\n\tspin_unlock(&obs->lock);\n\t\n\treturn 0;\n}\n", "CodeBleu_score": 45.6547595405902}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint err;\n\tk_spinlock_key_t key;\n\tstruct z_wait_q_node node;\n\tk_timeout_t t;\n\n\tZ_OOPS(Z_SYSCALL_DRIVER_ZBUS(chan, notify));\n\tkey = k_spin_lock(&chan->lock);\n\tif (chan->flags & Z_ZBUS_CHAN_FLAGS_IS_LOCKED) {\n\t\tt = K_NO_WAIT;\n\t} else {\n\t\tt = timeout;\n\t}\n\tz_waitq_add(&chan->wait_q, &node, t);\n\tchan->flags |= Z_ZBUS_CHAN_FLAGS_IS_LOCKED;\n\tchan->flags &= ~Z_ZBUS_CHAN_FLAGS_IS_EMPTY;\n\tk_spin_unlock(&chan->lock, key);\n\n\terr = z_impl_zbus_chan_notify((struct zbus_channel *)chan, timeout);\n\n\tkey = k_spin_lock(&chan->lock);\n\tif (k_waitq_active(&chan->wait_q)) {\n\t\tk_waitq_remove(&chan->wait_q, &node);\n\t}\n\tchan->flags &= ~Z_ZBUS_CHAN_FLAGS_IS_LOCKED;\n\tk_spin_unlock(&chan->lock, key);\n\n\treturn err;\n}\n", "CodeBleu_score": 36.127626027521856}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint err;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tk_timeout_t end_time;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tstruct k_poll_signal *signal;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tstruct k_poll_event *event;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tstruct k_poll_event *events;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint i;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num_events;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num_signals;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num_signals_alloc;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num_signals_used;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num_events_alloc;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num_events_used;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num_events_to_use;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num_events_to_use_alloc;\n\t/* The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout. */\n\tint num", "CodeBleu_score": 7.823717486454576}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\tstruct k_poll_event *ev = &chan->ev;\n\tstruct k_poll_event *ev_end = &chan->ev_end;\n\tint err = 0;\n\tk_timeout_t timeout_end = timeout;\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\tif (k_poll_signal_check(&chan->poll_signal, &chan->lock)) {\n\t\tgoto unlock;\n\t}\n\tif (k_poll_signal_check(&chan->poll_signal_end, &chan->lock)) {\n\t\tgoto unlock;\n\t}\n\tif (k_poll_event_init(ev, K_POLL_TYPE_SEM_AVAILABLE, K_POLL_MODE_NOTIFY_ONLY, &chan->sem)) {\n\t\tgoto unlock;\n\t}\n\tif (k_poll_event_init(ev_end, K_POLL_TYPE_SEM_AVAILABLE, K_POLL_MODE_NOTIFY_ONLY, &chan->sem_end)) {\n\t\tgoto unlock;\n\t}\n\tif (k_poll_event_push(&chan->poll_signal, ev)) {\n\t\tgoto unlock;\n\t}\n\tif (k_poll_event_push(&chan->poll_signal_end, ev_end)) {\n\t\tgoto unlock;\n\t}\n\tif (k_poll_signal_raise(&chan->poll_signal, &chan->lock)) {\n\t\tgoto unlock;\n\t}\n\tif (k_poll_signal_raise(&chan->poll_signal_end, &chan->lock)) {\n\t\tgoto unlock;\n\t}\n\tif (k_sem_take(&chan->sem, timeout)) {\n\t\terr = -ETIME;\n\t\tgoto unlock;\n\t}\n\tif (", "CodeBleu_score": 36.20314110531429}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)  uint32_t interrupt_enable_bit = 0;\n  uint32_t interrupt_enable_bit_pos = 0;\n\n  if (enable != FALSE) {\n    /* Enable the interrupt */\n    if (Int == ETH_IT_PTP) {\n      /* PTP interrupt */\n      interrupt_enable_bit = ETH_DMACIER_PTPIE;\n    } else if (Int == ETH_IT_MMC) {\n      /* MMC interrupt */\n      interrupt_enable_bit = ETH_DMACIER_MMCIE;\n    } else if (Int == ETH_IT_MMCRX) {\n      /* MMC RX interrupt */\n      interrupt_enable_bit = ETH_DMACIER_MMCRXIE;\n    } else if (Int == ETH_IT_MMCTX) {\n      /* MMC TX interrupt */\n      interrupt_enable_bit = ETH_DMACIER_MMCTXIE;\n    } else if (Int == ETH_IT_EBERR) {\n      /* Ethernet bus error interrupt */\n      interrupt_enable_bit = ETH_DMACIER_EBIE;\n    } else if (Int == ETH_IT_LC) {\n      /* Late collision interrupt */\n      interrupt_enable_bit = ETH_DMACIER_LCIE;\n    } else if (Int == ETH_IT_EINT) {\n      /* Early receive interrupt */\n      interrupt_enable_bit = ETH_DMACIER_ERIE;\n    } else if (Int == ETH_IT_FBE) {\n      /* Fatal bus error interrupt */\n      interrupt_enable_bit = ETH_DMACIER_FBEIE;\n    } else if (Int == ETH_IT_ERI) {\n      /* Early transmit interrupt */\n      interrupt_enable_bit = ETH_DMACIER_ETIE;\n    } else if (Int == ETH_IT_RWT) {\n      /* Retry transmit interrupt */\n      interrupt_enable_bit = ETH_DMACIER_RWTIE;\n    } else if (Int == ETH_IT_", "CodeBleu_score": 26.11309154602999}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)  if (enable) {\n    /* Enable the selected Ethernet interrupt */\n    ETH->DMAIER |= Int;\n  } else {\n    /* Disable the selected Ethernet interrupt */\n    ETH->DMAIER &= ~Int;\n  }\n}\n", "CodeBleu_score": 28.529815467439356}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tif (Int > ETH_INT_ALL)\n\t\treturn;\n\tif (enable) {\n\t\tETH_INTEnable(Int);\n\t} else {\n\t\tETH_INTDisable(Int);\n\t}\n}\n", "CodeBleu_score": 23.04250241402379}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tuint32_t i = 0;\n\tETH_TX_DESC *ptxdesc = (ETH_TX_DESC *)(ETH_TX_DESC_BASE_ADDR + (ETH_TX_DESC_SIZE * ETH_TX_DESC_INDEX));\n\n\tfor (i = 0; i < ETH_TX_DESC_NUM; i++) {\n\t\tif ((ptxdesc->Status & ETH_TX_DESC_STATUS_OWN) == (uint32_t)RESET) {\n\t\t\treturn ptxdesc;\n\t\t}\n\n\t\tif (++ETH_TX_DESC_INDEX >= ETH_TX_DESC_NUM) {\n\t\t\tETH_TX_DESC_INDEX = 0;\n\t\t}\n\n\t\tptxdesc = (ETH_TX_DESC *)(ETH_TX_DESC_BASE_ADDR + (ETH_TX_DESC_SIZE * ETH_TX_DESC_INDEX));\n\t}\n\n\treturn (ETH_TX_DESC *)0;\n}\n", "CodeBleu_score": 30.029544761019167}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\t/* Get the current Tx descriptor address */\n\tpTxDesc = &(ETH_TX_DESC_TABLE[u32CurTxDescIdx]);\n\n\t/* Check if the descriptor is owned by the device */\n\tif ((pTxDesc->Status & ETH_TX_DESC_STATUS_OWN) == 0) {\n\t\t/* The descriptor is free, return it */\n\t\treturn pTxDesc;\n\t}\n\n\t/* The descriptor is owned by the device, get the next one */\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\t/* Get the next descriptor address */\n\t\tpTxDesc = &(ETH_TX_DESC_TABLE[(u32CurTxDescIdx + 1) % ETH_TX_DESC_CNT]);\n\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif ((pTxDesc->Status & ETH_TX_DESC_STATUS_OWN) == 0) {\n\t\t\t/* The descriptor is free, return it */\n\t\t\treturn pTxDesc;\n\t\t}\n\t}\n\n\t/* No free descriptor found */\n\treturn 0;\n}\n", "CodeBleu_score": 38.69023249082401}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)  ETH_TX_DESC *pTxDesc = pTxDescStart;\n\n  while (1) {\n    if (pTxDesc->status & ETH_TX_DESC_OWN) {\n      pTxDesc = (ETH_TX_DESC *)(pTxDesc->next);\n      if (pTxDesc == pTxDescStart) {\n        return 0;\n      }\n    } else {\n      return pTxDesc;\n    }\n  }\n}\n", "CodeBleu_score": 33.66322748337775}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    CY_ASSERT_L3(device != RT_NULL);\n    CY_ASSERT_L3(value != RT_NULL);\n\n    struct cyp_dac_device *dac_device = (struct cyp_dac_device *)device;\n\n    if (dac_device->dac_channel == CY_CSD_ADC_CHANNEL_INVALID) {\n        rt_kprintf(\"DAC device %s has no valid channel\\n\", dac_device->parent.parent.name);\n        return -RT_ERROR;\n    }\n\n    rt_uint32_t result = Cy_CSD_ADC_OutputEnable(dac_device->dac_channel, *value);\n    if (result != CY_CSD_SUCCESS) {\n        rt_kprintf(\"DAC device %s failed to enable output\\n\", dac_device->parent.parent.name);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 51.593940617497644}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\tRT_ASSERT(device != RT_NULL);\n\tRT_ASSERT(value != RT_NULL);\n\tstruct rt_cyp_adc *cyp_adc = (struct rt_cyp_adc *)device->parent.user_data;\n\tRT_ASSERT(cyp_adc != RT_NULL);\n\trt_uint32_t ret;\n\trt_uint32_t dac_channel;\n\trt_uint32_t dac_value;\n\n\tif (cyp_adc->cyp_adc_config.channel_num > 1) {\n\t\tif (channel >= cyp_adc->cyp_adc_config.channel_num) {\n\t\t\trt_kprintf(\"channel error\\n\");\n\t\t\treturn -RT_EINVAL;\n\t\t}\n\t\tdac_channel = channel;\n\t} else {\n\t\tdac_channel = 0;\n\t}\n\n\tdac_value = *value;\n\tret = Cy_CSDIDAC_OutputEnable(cyp_adc->cyp_adc_config.base, dac_channel, dac_value);\n\tif (ret == CY_CSDIDAC_SUCCESS) {\n\t\treturn RT_EOK;\n\t} else {\n\t\treturn -RT_ERROR;\n\t}\n}\n", "CodeBleu_score": 48.89476737177378}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\trt_err_t result = RT_EOK;\n\trt_uint32_t cyp_dac_channel = 0;\n\trt_uint32_t cyp_dac_value = 0;\n\trt_uint32_t cyp_dac_voltage = 0;\n\trt_uint32_t cyp_dac_voltage_max = 0;\n\trt_uint32_t cyp_dac_voltage_min = 0;\n\trt_uint32_t cyp_dac_voltage_step = 0;\n\trt_uint32_t cyp_dac_voltage_range = 0;\n\trt_uint32_t cyp_dac_voltage_max_raw = 0;\n\trt_uint32_t cyp_dac_voltage_min_raw = 0;\n\trt_uint32_t cyp_dac_voltage_step_raw = 0;\n\trt_uint32_t cyp_dac_voltage_range_raw = 0;\n\trt_uint32_t cyp_dac_voltage_raw = 0;\n\trt_uint32_t cyp_dac_voltage_raw_max = 0;\n\trt_uint32_t cyp_dac_voltage_raw_min = 0;\n\trt_uint32_t cyp_dac_voltage_raw_step = 0;\n\trt_uint32_t cyp_dac_voltage_raw_range = 0;\n\trt_uint32_t cyp_dac_voltage_raw_max_raw = 0;\n\trt_uint32_t cyp_dac_voltage_raw_min_raw = 0;\n\trt_uint32_t cyp_dac_voltage_raw_step_raw = 0;\n\trt_uint32_t cyp_dac_voltage_raw_range_raw", "CodeBleu_score": 8.28535985302301}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)    int i;\n    if ((addr + size) > IFX_FLASH_32K_END_ADDR) {\n        LOG_E(\"flash read out of range, addr: 0x%08x, size: 0x%08x\", addr, size);\n        return -RT_EINVAL;\n    }\n    for (i = 0; i < size; i++) {\n        *(buf + i) = *(rt_uint8_t *)(addr + i);\n    }\n    return size;\n}\n", "CodeBleu_score": 62.40868356470802}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\n\tint i;\n\n\tif (addr + size > IFX_FLASH_32K_END) {\n\t\trt_kprintf(\"ifx_flash_read_32k: Invalid address\\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 46.94761958411778}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)    int i;\n    int ret;\n    int read_size;\n    int read_count = 0;\n    int read_offset = 0;\n\n    if ((addr + size) > IFX_FLASH_32K_END_ADDR) {\n        LOG_E(\"ifx_flash_read_32k: read address exceeds flash memory's end address\");\n        return -RT_EINVAL;\n    }\n\n    while (size > 0) {\n        read_size = (size > IFX_FLASH_32K_READ_SIZE) ? IFX_FLASH_32K_READ_SIZE : size;\n        ret = ifx_flash_read_32k_internal(addr, buf + read_count, read_size);\n        if (ret < 0) {\n            return ret;\n        }\n        read_count += ret;\n        size -= read_size;\n        addr += read_size;\n        read_offset += read_size;\n    }\n\n    return read_offset;\n}\n", "CodeBleu_score": 41.534604437877384}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *cy_timer = (cyhal_timer_t *)timer->parent.user_data;\n    RT_ASSERT(cy_timer != RT_NULL);\n\n    return cyhal_timer_read(cy_timer);\n}\n", "CodeBleu_score": 34.058706848548084}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    RT_ASSERT(timer != RT_NULL);\n    struct cyhal_timer *timer_obj = (struct cyhal_timer *) timer->parent.user_data;\n    RT_ASSERT(timer_obj != RT_NULL);\n\n    return cyhal_timer_read(timer_obj);\n}\n", "CodeBleu_score": 56.319125468204504}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    RT_ASSERT(timer != RT_NULL);\n    struct cyhal_timer *timer_obj = (struct cyhal_timer *)timer->parent.user_data;\n    RT_ASSERT(timer_obj != RT_NULL);\n\n    return cyhal_timer_read(timer_obj);\n}\n", "CodeBleu_score": 56.43170773598008}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void)  int i;\n  int ret;\n  for (i = 0; i < 100; i++) {\n    ret = pthread_mutex_lock(&g_dfs_lock);\n    if (ret != 0) {\n      if (ret == EBUSY) {\n        continue;\n      }\n      assert(0);\n    }\n    break;\n  }\n  if (i == 100) {\n    assert(0);\n  }\n}\n", "CodeBleu_score": 35.8200322444639}, {"code": "void dfs_lock(void)\tint err;\n\n\twhile ((err = pthread_mutex_lock(&dfs_lock_mutex)) != 0) {\n\t\tif (err != EBUSY) {\n\t\t\tassert(0);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.699020320936405}, {"code": "void dfs_lock(void)\tint ret;\n\n\twhile (1) {\n\t\tret = pthread_mutex_trylock(&dfs_lock_mutex);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tassert(ret == EBUSY);\n\t}\n}\n", "CodeBleu_score": 25.41712460827862}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int i;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    if (fdt->maxfd == fdt->size) {\n        int new_size = fdt->size + FD_TABLE_SIZE_INCREMENT;\n        struct dfs_fd *new_fdtable;\n\n        new_fdtable = aos_realloc(fdt->fd, new_size * sizeof(struct dfs_fd *));\n        if (new_fdtable == NULL) {\n            return -1;\n        }\n\n        fdt->fd = new_fdtable;\n        fdt->size = new_size;\n    }\n\n    fdt->fd[fdt->maxfd] = NULL;\n    return fdt->maxfd++;\n}\n", "CodeBleu_score": 39.45734498943105}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int i;\n    for (i = startfd; i < fdt->fd_table_size; i++) {\n        if (fdt->fd_table[i] == NULL) {\n            return i;\n        }\n    }\n    return -1;\n}\n", "CodeBleu_score": 29.628818231231364}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int i;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fds[i].fd_inuse == 0) {\n            fdt->fds[i].fd_inuse = 1;\n            return i;\n        }\n    }\n\n    /* No empty slot found. Try to expand the fd table. */\n    return fd_table_expand(fdt);\n}\n", "CodeBleu_score": 32.80289092885509}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error)    if (error < 0) error = -error;\n    switch (error) {\n        case RT_EOK: return \"RT_EOK\";\n        case RT_ERROR: return \"RT_ERROR\";\n        case RT_ETIMEOUT: return \"RT_ETIMEOUT\";\n        case RT_EFULL: return \"RT_EFULL\";\n        case RT_EEMPTY: return \"RT_EEMPTY\";\n        case RT_ENOMEM: return \"RT_ENOMEM\";\n        case RT_ENOSYS: return \"RT_ENOSYS\";\n        case RT_EBUSY: return \"RT_EBUSY\";\n        case RT_EIO: return \"RT_EIO\";\n        case RT_EINTR: return \"RT_EINTR\";\n        case RT_EINVAL: return \"RT_EINVAL\";\n        case RT_EEMPTY: return \"RT_EEMPTY\";\n        case RT_ENODEV: return \"RT_ENODEV\";\n        case RT_ENOENT: return \"RT_ENOENT\";\n        case RT_EISCONN: return \"RT_EISCONN\";\n        case RT_EISDIR: return \"RT_EISDIR\";\n        case RT_EINPROGRESS: return \"RT_EINPROGRESS\";\n        case RT_ENOTDIR: return \"RT_ENOTDIR\";\n        case RT_EINVAL: return \"RT_EINVAL\";\n        case RT_EILSEQ: return \"RT_EILSEQ\";\n        case RT_ENOTBLK: return \"RT_ENOTBLK\";\n        case RT_EBADF: return \"RT_EBADF\";\n        case RT_EAGAIN: return \"RT_EAGAIN\";\n        case RT_EFAULT: return \"RT_EFAULT\";\n        case RT_EBADMSG: return \"RT_EBADMSG\";\n        case RT_EFBIG: return \"RT_EFBIG\";\n        case RT_ENOSPC: return \"RT_ENOSPC\";", "CodeBleu_score": 32.02364162824232}, {"code": "const char *rt_strerror(rt_err_t error)    if (error < 0) {\n        error = -error;\n    }\n    switch (error) {\n        case RT_EOK:\n            return \"RT_EOK\";\n        case RT_ERROR:\n            return \"RT_ERROR\";\n        case RT_ENOMEM:\n            return \"RT_ENOMEM\";\n        case RT_EFULL:\n            return \"RT_EFULL\";\n        case RT_EEMPTY:\n            return \"RT_EEMPTY\";\n        case RT_ENOENT:\n            return \"RT_ENOENT\";\n        case RT_EINTR:\n            return \"RT_EINTR\";\n        case RT_EIO:\n            return \"RT_EIO\";\n        case RT_EAGAIN:\n            return \"RT_EAGAIN\";\n        case RT_EBUSY:\n            return \"RT_EBUSY\";\n        case RT_EEXIST:\n            return \"RT_EEXIST\";\n        case RT_ENODEV:\n            return \"RT_ENODEV\";\n        case RT_EINVAL:\n            return \"RT_EINVAL\";\n        case RT_ENOSYS:\n            return \"RT_ENOSYS\";\n        case RT_EFAULT:\n            return \"RT_EFAULT\";\n        case RT_ENOTBLK:\n            return \"RT_ENOTBLK\";\n        case RT_EBADBLK:\n            return \"RT_EBADBLK\";\n        case RT_ENOSPC:\n            return \"RT_ENOSPC\";\n        case RT_EOVERFLOW:\n            return \"RT_EOVERFLOW\";\n        case RT_ENOSUPPORT:\n            return \"RT_ENOSUPPORT\";\n        case RT_EPROTONOSUPPORT:\n            return \"RT_EPROTONOSUPPORT\";\n        case RT_ENOPROTOOPT:\n            return \"RT_ENOPROTOOPT\";\n        case RT_EOPNOTSUPP:\n            return \"RT_EOPNOTSUPP\";\n        case R", "CodeBleu_score": 31.297158286557636}, {"code": "const char *rt_strerror(rt_err_t error)\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tswitch (error) {\n\tcase RT_EOK:\n\t\treturn \"RT_EOK\";\n\tcase RT_ERROR:\n\t\treturn \"RT_ERROR\";\n\tcase RT_ENOSYS:\n\t\treturn \"RT_ENOSYS\";\n\tcase RT_EBUSY:\n\t\treturn \"RT_EBUSY\";\n\tcase RT_EINVAL:\n\t\treturn \"RT_EINVAL\";\n\tcase RT_ENOMEM:\n\t\treturn \"RT_ENOMEM\";\n\tcase RT_EIO:\n\t\treturn \"RT_EIO\";\n\tcase RT_EINTR:\n\t\treturn \"RT_EINTR\";\n\tcase RT_EAGAIN:\n\t\treturn \"RT_EAGAIN\";\n\tcase RT_EINPROGRESS:\n\t\treturn \"RT_EINPROGRESS\";\n\tcase RT_EALREADY:\n\t\treturn \"RT_EALREADY\";\n\tcase RT_ENOTCONN:\n\t\treturn \"RT_ENOTCONN\";\n\tcase RT_EISCONN:\n\t\treturn \"RT_EISCONN\";\n\tcase RT_ECONNABORTED:\n\t\treturn \"RT_ECONNABORTED\";\n\tcase RT_ECONNRESET:\n\t\treturn \"RT_ECONNRESET\";\n\tcase RT_ENOBUFS:\n\t\treturn \"RT_ENOBUFS\";\n\tcase RT_ETIMEDOUT:\n\t\treturn \"RT_ETIMEDOUT\";\n\tcase RT_EHOSTUNREACH:\n\t\treturn \"RT_EHOSTUNREACH\";\n\tcase RT_ENETDOWN:\n\t\treturn \"RT_ENETDOWN\";\n\tcase RT_ENETUNREACH:\n\t\treturn \"RT_ENETUNREACH\";\n\tcase RT_EADDRINUSE:\n\t\treturn \"RT_EADDRINUSE\";\n\tcase RT_", "CodeBleu_score": 30.72458397792934}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\tint i;\n\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\tif (hook == RT_NULL) {\n\t\treturn -RT_EINVAL;\n\t}\n\n\tlevel = rt_hw_interrupt_disable();\n\tfor (i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == RT_NULL) {\n\t\t\tidle_hook_list[i] = hook;\n\t\t\tbreak;\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n\n\tif (i == RT_THREAD_IDLE_HOOK_LIST_SIZE) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 55.818872235210804}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_err_t result;\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n    if (idle_hook_list[idle_hook_index] == RT_NULL) {\n        idle_hook_list[idle_hook_index] = hook;\n        result = RT_EOK;\n    } else {\n        result = -RT_EFULL;\n    }\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}\n", "CodeBleu_score": 34.1928549433932}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_err_t ret;\n\trt_base_t level;\n\trt_thread_idle_sethook_t *p_hook;\n\trt_thread_idle_sethook_t *p_hook_end;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tlevel = rt_hw_interrupt_disable();\n\tp_hook = &_rt_idle_hook_list[0];\n\tp_hook_end = &_rt_idle_hook_list[RT_IDLE_HOOK_LIST_SIZE];\n\twhile (p_hook < p_hook_end) {\n\t\tif (p_hook->hook == RT_NULL) {\n\t\t\tp_hook->hook = hook;\n\t\t\tret = RT_EOK;\n\t\t\tgoto __exit;\n\t\t}\n\t\tp_hook ++;\n\t}\n\tret = -RT_EFULL;", "CodeBleu_score": 43.773919141271826}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_base_t level;\n    rt_thread_t tid;\n    rt_list_t *l;\n    rt_thread_idle_hook_t *idle_hook;\n    RT_ASSERT(hook != RT_NULL);\n    level = rt_hw_interrupt_disable();\n    tid = rt_thread_self();\n    for (l = &tid->idle_hook; l != &tid->idle_hook; l = l->next) {\n        idle_hook = rt_list_entry(l, struct rt_thread_idle_hook, list);\n        if (idle_hook->hook == hook) {\n            rt_list_remove(l);\n            rt_hw_interrupt_enable(level);\n            return RT_EOK;\n        }\n    }\n    rt_hw_interrupt_enable(level);\n    return -RT_ERROR;\n}\n", "CodeBleu_score": 38.53290489601803}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_list_t *node;\n    rt_thread_t thread;\n    rt_err_t ret;\n    rt_spinlock_t lock;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n    RT_ASSERT(hook != RT_NULL);\n\n    /* disable interrupt */\n    lock = rt_hw_spin_lock_irqsave();\n\n    /* find hook in idle hook list */\n    for (node = &_idle_hook; node->next != RT_NULL; node = node->next)\n    {\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n        if (thread->hook == hook)\n        {\n            /* found hook */\n            thread->hook = RT_NULL;\n\n            /* disable interrupt */\n            rt_hw_spin_unlock_irqrestore(lock);\n\n            return RT_EOK;\n        }\n    }\n\n    /* disable interrupt */\n    rt_hw_spin_unlock_irqrestore(lock);\n\n    /* hook is not found */\n    return -RT_ERROR;\n}\n", "CodeBleu_score": 41.80608915637971}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_base_t lock;\n\trt_thread_idle_hook_t *hook_item;\n\trt_thread_idle_hook_t *prev_item;\n\trt_thread_idle_hook_t *next_item;\n\trt_thread_idle_hook_t *idle_hook_list;\n\trt_thread_idle_hook_t *idle_hook_list_end;\n\trt_thread_idle_hook_t *idle_hook_list_temp;\n\trt_thread_idle_hook_t *idle_hook_list_temp_end;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_end;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_end;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_temp;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_temp_end;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_temp_temp;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_temp_temp_end;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_temp_temp_temp;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_temp_temp_temp_end;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_temp_temp_temp_temp;\n\trt_thread_idle_hook_t *idle_hook_list_temp_temp_temp_temp_temp_temp_temp_end;\n\trt_thread", "CodeBleu_score": 7.636968229178455}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_thread_t thread;\n    rt_list_t *node;\n    rt_list_t *next;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* ensure the scheduler is unlocked */\n    rt_enter_critical();\n\n    /* dequeue and wake up all threads in the suspension list */\n    for (node = susp_list->next; node != susp_list; node = next) {\n        /* get next node */\n        next = node->next;\n\n        /* get thread */\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /* dequeue thread from suspension list */\n        rt_list_remove(node);\n\n        /* wake up thread */\n        rt_thread_resume(thread, thread_error);\n    }\n\n    rt_exit_critical();\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 34.33436876959527}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\trt_thread_t thread;\n\trt_list_t *node;\n\trt_list_t *next;\n\trt_list_t *list = susp_list;\n\trt_scheduler_unlock();\n\tfor (node = list->next; node != list; node = next) {\n\t\tnext = node->next;\n\t\tthread = rt_list_entry(node, struct rt_thread, tlist);\n\t\trt_list_remove(node);\n\t\tthread->error = thread_error;\n\t\trt_thread_resume(thread);\n\t}\n\treturn RT_EOK;\n}\n", "CodeBleu_score": 30.631768033040117}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_thread_t thread;\n    rt_list_t *node;\n    rt_list_t *next;\n\n    if (susp_list == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    /* ensure the scheduler is unlocked */\n    rt_enter_critical();\n    /* dequeue and wake up each suspended thread from the list */\n    for (node = susp_list->next; node != susp_list; node = next) {\n        next = node->next;\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n        rt_thread_resume(thread, thread_error);\n    }\n    /* clear the suspension list */\n    rt_list_init(susp_list);\n    rt_exit_critical();\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 35.65372407852784}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t old_console, new_console;\n\n    old_console = rt_console_get_device();\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return old_console;\n    }\n\n    if (old_console == new_console) {\n        return old_console;\n    }\n\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return old_console;\n    }\n\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 53.28554884449736}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t old_console, new_console;\n\n    old_console = rt_console_get_device();\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return old_console;\n    }\n\n    if (old_console == new_console) {\n        return old_console;\n    }\n\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return old_console;\n    }\n\n    rt_console_set_device(new_console);\n\n    return old_console;\n}\n", "CodeBleu_score": 53.28554884449736}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t old_console, new_console;\n\n    RT_ASSERT(name != RT_NULL);\n\n    old_console = rt_console_get_device();\n    if (old_console != RT_NULL)\n    {\n        rt_device_close(old_console);\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console != RT_NULL)\n    {\n        if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK)\n        {\n            rt_console_set_device(new_console);\n        }\n    }\n\n    return old_console;\n}", "CodeBleu_score": 50.104429634310186}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type)\tint count = 0;\n\tstruct rt_object_information *object_info;\n\tstruct rt_object_information *next;\n\tstruct rt_object *object;\n\n\tobject_info = &rt_object_set[type];\n\tspin_lock_irqsave(&object_info->lock, NULL);\n\tlist_for_each_entry_safe(object, next, &object_info->object_list, list) {\n\t\tcount++;\n\t}\n\tspin_unlock_irqrestore(&object_info->lock, NULL);\n\n\treturn count;\n}\n", "CodeBleu_score": 37.10667656222844}, {"code": "int rt_object_get_length(enum rt_object_class_type type)    int count = 0;\n    struct rt_object_information *object_info;\n    rt_spinlock_t lock;\n\n    /* get the object information */\n    object_info = &__object_info_table[type];\n    if (object_info->object_size == 0) {\n        return 0;\n    }\n\n    /* lock the spinlock */\n    lock = object_info->lock;\n    rt_spin_lock(lock);\n\n    /* get the count of objects */\n    count = object_info->object_number;\n\n    /* unlock the spinlock */\n    rt_spin_unlock(lock);\n\n    return count;\n}", "CodeBleu_score": 37.77918356441518}, {"code": "int rt_object_get_length(enum rt_object_class_type type)    int i;\n    int length = 0;\n    struct rt_object_information *object_info;\n\n    if (type >= RT_Object_Class_End) {\n        return 0;\n    }\n\n    object_info = &__object_info_table[type];\n    if (object_info->object_size == 0) {\n        return 0;\n    }\n\n    for (i = 0; i < RT_Object_Number_Max; i++) {\n        if (object_info->object_list[i].object != RT_NULL) {\n            length++;\n        }\n    }\n\n    return length;\n}\n", "CodeBleu_score": 37.1662519862764}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object)    rt_object_info_t object_info;\n\n    if (object == RT_NULL) return;\n\n    object_info = &(object->object_info);\n\n    /* check object type */\n    RT_ASSERT(object->type > RT_Object_Class_Static);\n\n    /* call object detach hook function */\n    if (object_info->ops != RT_NULL) {\n        object_info->ops->detach_hook(object);\n    }\n\n    /* lock object */\n    rt_object_lock(object);\n\n    /* remove object from object list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object */\n    rt_object_unlock(object);\n\n    /* set object type to zero */\n    object->type = RT_Object_Class_Static;\n}\n", "CodeBleu_score": 48.56235977400211}, {"code": "void rt_object_detach(rt_object_t object)    struct rt_object_information *information;\n    struct rt_object_type *type;\n    rt_list_t *list;\n    rt_size_t index;\n\n    if (object == RT_NULL) return;\n\n    /* get object information */\n    information = object->parent.object_information;\n    if (information == RT_NULL) return;\n\n    /* get object type */\n    type = object->parent.type;\n    if (type == RT_NULL) return;\n\n    /* detach object */\n    if (type->detach != RT_NULL)\n        type->detach(object);\n\n    /* get object list */\n    list = &(type->object_list);\n\n    /* lock object list */\n    rt_enter_critical();\n\n    /* remove object from list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object list */\n    rt_exit_critical();\n\n    /* detach object */\n    object->parent.type = RT_NULL;\n\n    /* object is not initialized */\n    object->parent.flag = RT_Object_Flag_Static;\n\n    /* get object index */\n    index = object->parent.number;\n\n    /* set object number to zero */\n    object->parent.number = 0;\n\n    /* get object information */\n    information = object->parent.object_information;\n    if (information == RT_NULL) return;\n\n    /* decrease the number of objects */\n    information->number --;\n\n    /* check object number */\n    if (information->number == 0)\n    {\n        /* get object list */\n        list = &(information->object_list);\n\n        /* lock object list */\n        rt_enter_critical();\n\n        /* remove object from list */\n        rt_list_remove(&(information->list));\n\n        /* unlock object list */\n        rt_exit_critical();\n\n        /* get object type */\n        type = information->object_type;\n        if (type == RT_NULL) return;\n\n        /* detach object information */\n       ", "CodeBleu_score": 45.74595547974558}, {"code": "void rt_object_detach(rt_object_t object)    struct rt_object_information *information;\n    rt_list_t *list;\n    rt_object_t _object;\n\n    if (object == RT_NULL) {\n        return;\n    }\n\n    /* get object information */\n    information = &_object_info[object->type];\n\n    /* lock object list */\n    rt_enter_critical();\n\n    /* find the object in object list */\n    list = &(information->object_list);\n    if (rt_list_isempty(list)) {\n        /* no object in this list */\n        rt_exit_critical();\n\n        return;\n    }\n\n    /* find the object */\n    rt_list_for_each(list, list) {\n        _object = rt_list_entry(list, struct rt_object, list);\n        if (_object == object) {\n            /* found */\n            rt_list_remove(&(object->list));\n            break;\n        }\n    }\n\n    /* unlock object list */\n    rt_exit_critical();\n\n    /* invoke detach hook function */\n    if (information->detach_hook != RT_NULL) {\n        information->detach_hook(object);\n    }\n\n    /* set object type to zero */\n    object->type = 0;\n\n    return;\n}\n", "CodeBleu_score": 49.78236103191625}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t err = RT_EOK;\n    rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n\n    if (custom_obj == RT_NULL) {\n        return RT_NULL_POINTER;\n    }\n\n    if (custom_obj->type != RT_Object_Class_Custom) {\n        return RT_ERROR;\n    }\n\n    if (custom_obj->destroy != RT_NULL) {\n        err = custom_obj->destroy(custom_obj);\n    }\n\n    rt_object_delete(obj);\n\n    return err;\n}\n", "CodeBleu_score": 48.620272718150744}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t ret = RT_EOK;\n    rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(custom_obj->type == RT_Object_Class_Custom);\n    if (custom_obj->destroy != RT_NULL) {\n        ret = custom_obj->destroy(custom_obj);\n    }\n    rt_object_delete(obj);\n    return ret;\n}\n", "CodeBleu_score": 51.41813118687677}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_err_t result = RT_ERR_NONE;\n\trt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n\n\tRT_ASSERT(custom_obj != RT_NULL);\n\n\tif (custom_obj->type != RT_Object_Class_Custom) {\n\t\tresult = RT_ERR_INVALID_ARG;\n\t\tgoto __exit;\n\t}\n\n\tif (custom_obj->destroy != RT_NULL) {\n\t\tresult = custom_obj->destroy(custom_obj);\n\t}\n\n\trt_object_delete(custom_obj);\n", "CodeBleu_score": 43.68274026837642}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void)\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tstruct thread *current = _current_thread();\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack = NULL;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_size = 0;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_pointer = NULL;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_base = NULL;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_guard = NULL;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_magic = 0;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_canary = 0;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_guard_size = 0;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_canary_size = 0;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_flags = 0;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_flags_mask = 0;\n\t/*\n\t * The thread's stack is now corrupted.\n\t * Do not use it anymore.\n\t */\n\tcurrent->stack_flags_value = 0;", "CodeBleu_score": 36.6369669103824}, {"code": "static void _thread_exit(void)\tstruct thread *cur;\n\tcur = _thread_current();\n\tcur->state = THREAD_STATE_TERMINATED;\n\tcur->retval = _thread_current()->retval;\n\t_thread_current()->retval = 0;\n\t_thread_current()->state = THREAD_STATE_READY;\n\t_thread_current()->priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_priority = 0;\n\t_thread_current()->sched_", "CodeBleu_score": 38.49469234068026}, {"code": "static void _thread_exit(void)\t_thread_t *current_thread;\n\n\t/* Get the current thread */\n\tcurrent_thread = _scheduler_get_current_thread();\n\n\t/* Enter critical section */\n\t_scheduler_enter_critical_section();\n\n\t/* Close the thread */\n\t_thread_close(current_thread);\n\n\t/* Add the thread to the defunct thread list */\n\t_scheduler_add_defunct_thread(current_thread);\n\n\t/* Exit critical section */\n\t_scheduler_exit_critical_section();\n\n\t/* Trigger a context switch */\n\t_scheduler_trigger_context_switch();\n}\n", "CodeBleu_score": 57.00200204219392}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter)\tstruct _thread *thread;\n\tif (parameter == NULL) {\n\t\t_thread_set_error_number(_THREAD_ERR_NULL_PARAMETER);\n\t\treturn;\n\t}\n\tthread = parameter;\n\tif (thread->state != _THREAD_STATE_SUSPENDED) {\n\t\t_thread_set_error_number(_THREAD_ERR_NOT_SUSPENDED);\n\t\treturn;\n\t}\n\t_scheduler_lock();\n\tthread->error = _THREAD_ERR_TIMEOUT;\n\t_scheduler_remove_suspend_list(thread);\n\t_scheduler_insert_ready_list(thread);\n\t_scheduler_unlock();\n}\n", "CodeBleu_score": 35.20173478387729}, {"code": "static void _thread_timeout(void *parameter)\t/*\n\t * The function \"_thread_timeout\" handles thread timeout events.\\nIt takes a thread as a parameter and performs parameter checks to ensure validity.\\nIt locks the scheduler, verifies the thread is suspended, sets the thread's error number to a timeout value, removes the thread from the suspend list, inserts it into the ready list, and then unlocks the scheduler to reschedule.\n\t */\n\t_thread_t *thread;\n\t/*\n\t * The function \"_thread_timeout\" handles thread timeout events.\\nIt takes a thread as a parameter and performs parameter checks to ensure validity.\\nIt locks the scheduler, verifies the thread is suspended, sets the thread's error number to a timeout value, removes the thread from the suspend list, inserts it into the ready list, and then unlocks the scheduler to reschedule.\n\t */\n\t_scheduler_lock();\n\t/*\n\t * The function \"_thread_timeout\" handles thread timeout events.\\nIt takes a thread as a parameter and performs parameter checks to ensure validity.\\nIt locks the scheduler, verifies the thread is suspended, sets the thread's error number to a timeout value, removes the thread from the suspend list, inserts it into the ready list, and then unlocks the scheduler to reschedule.\n\t */\n\tif (parameter == NULL) {\n\t\t/*\n\t\t * The function \"_thread_timeout\" handles thread timeout events.\\nIt takes a thread as a parameter and performs parameter checks to ensure validity.\\nIt locks the scheduler, verifies the thread is suspended, sets the thread's error number to a timeout value, removes the thread from the suspend list, inserts it into the ready list, and then unlocks the scheduler to reschedule.\n\t\t */\n\t\t_scheduler_unlock();\n\t\t/*\n\t\t * The function \"_thread_timeout\" handles thread timeout events.\\nIt takes a thread as a parameter and performs parameter checks to ensure validity.\\nIt locks the scheduler, verifies the thread is suspended, sets the thread's error number to a timeout value, removes the thread from the suspend list, inserts it into the ready list, and then unlocks the scheduler", "CodeBleu_score": 28.841442416815756}, {"code": "static void _thread_timeout(void *parameter)  _thread_t *thread;\n  _scheduler_lock();\n  thread = parameter;\n  if (thread->state != _THREAD_SUSPENDED) {\n    _scheduler_unlock();\n    return;\n  }\n  thread->state = _THREAD_READY;\n  thread->error = _THREAD_TIMEOUT;\n  _scheduler_remove_from_suspend_list(thread);\n  _scheduler_insert_into_ready_list(thread);\n  _scheduler_unlock();\n}\n", "CodeBleu_score": 34.82441612147746}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_mutex_t mutex;\n\trt_thread_t mutex_thread;\n\trt_list_t *node;\n\n\trt_spin_lock(&thread->lock);\n\tif (thread->state == RT_THREAD_STATE_MUTEX_WAITING) {\n\t\tmutex = thread->wait_object;\n\t\tmutex_thread = mutex->owner;\n\t\tnode = rt_list_find(&mutex->waiting_list, &thread->tlist);\n\t\trt_list_remove(node);\n\t\tmutex->owner = NULL;\n\t\tthread->wait_object = NULL;\n\t\tthread->state = RT_THREAD_STATE_READY;\n\t\tmutex_thread->state = RT_THREAD_STATE_READY;\n\t\trt_spin_unlock(&thread->lock);\n\t\trt_spin_lock(&mutex_thread->lock);\n\t\trt_list_remove(&mutex_thread->tlist);\n\t\tmutex->pending_object = NULL;\n\t\trt_spin_unlock(&mutex_thread->lock);\n\t\trt_schedule();\n\t} else {\n\t\trt_spin_unlock(&thread->lock);\n\t}\n}\n", "CodeBleu_score": 43.44663821643767}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_mutex_t mutex;\n\trt_list_t *list_node;\n\trt_thread_t waiting_thread;\n\trt_thread_t taking_thread;\n\trt_bool_t thread_is_waiting;\n\trt_bool_t thread_is_taking;\n\trt_spinlock_ctx_t sc;\n\trt_spinlock_ctx_t tc;\n\trt_spinlock_ctx_t mc;\n\trt_spinlock_ctx_t wc;\n\n\t/*\n\t * Lock the thread's spinlock.\n\t */\n\trt_spinlock_lock(&(thread->lock), &sc);\n\n\t/*\n\t * Check if the thread is waiting on a mutex.\n\t */\n\tthread_is_waiting = (thread->waiting_mutex != NULL);\n\tthread_is_taking = (thread->taking_mutex != NULL);\n\n\t/*\n\t * If the thread is waiting on a mutex, remove it from the mutex's waiting list and clear the pending object.\n\t */\n\tif (thread_is_waiting) {\n\t\tmutex = thread->waiting_mutex;\n\t\tlist_node = rt_list_find(&(mutex->waiting_list), &(thread->waiting_node));\n\t\trt_list_remove(list_node);\n\t\tthread->waiting_mutex = NULL;\n\t\tthread->waiting_node.next = NULL;\n\t\tthread->waiting_node.prev = NULL;\n\t\tthread->pending_object = NULL;\n\t}\n\n\t/*\n\t * If the thread is taking a mutex, remove it from the mutex's taking list and clear the pending object.\n\t */\n\tif (thread_is_taking) {\n\t\tmutex = thread->taking_mutex;\n\t\tlist_node = rt_list_find(&(mutex->taking_list), &(thread->taking_node));\n\t\trt_list_remove(list_node);\n\t\tthread->taking_mutex = NULL;\n\t\tthread->taking", "CodeBleu_score": 42.329069217582315}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_mutex_t mutex;\n\trt_list_t *iterator, *iterator2;\n\trt_spinlock_ctx_t ctx;\n\trt_spinlock_ctx_t ctx2;\n\n\t/* Lock the thread's spinlock */\n\trt_spin_lock_irqsave(&thread->lock, &ctx);\n\n\t/* Check if the thread is waiting on a mutex */\n\tif (thread->state == RT_THREAD_STATE_MUTEX_WAITING) {\n\t\t/* Iterate through the mutex's waiting list */\n\t\trt_list_for_each_safe(iterator, iterator2, &mutex->waiting_list) {\n\t\t\t/* Check if the thread is in the waiting list */\n\t\t\tif (iterator->next == &thread->mutex_list) {\n\t\t\t\t/* Remove the thread from the mutex's waiting list */\n\t\t\t\trt_list_remove(iterator);\n\n\t\t\t\t/* Clear the pending object */\n\t\t\t\tthread->pending_object = NULL;\n\n\t\t\t\t/* Set the thread's state to ready */\n\t\t\t\tthread->state = RT_THREAD_STATE_READY;\n\n\t\t\t\t/* Unlock the mutex's spinlock */\n\t\t\t\trt_spin_lock_irqsave(&mutex->lock, &ctx2);\n\n\t\t\t\t/* Check if the mutex is priority inherited */\n\t\t\t\tif (mutex->flags & RT_MUTEX_FLAG_PRIO_INHERIT) {\n\t\t\t\t\t/* Check if the mutex is priority protected */\n\t\t\t\t\tif (mutex->flags & RT_MUTEX_FLAG_PRIO_PROTECT) {\n\t\t\t\t\t\t/* Check if the mutex is priority ceiling */\n\t\t\t\t\t\tif (mutex->flags & RT_MUTEX_FLAG_PRIO_CEILING) {\n\t\t\t\t\t\t\t/* Check if the thread is in the mutex's priority ceiling list */\n\t\t\t\t\t\t\tif (iterator->", "CodeBleu_score": 39.975394462600164}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread)\tregister rt_ubase_t level;\n\trt_err_t result;\n\trt_thread_t current_thread;\n\trt_uint8_t priority;\n\trt_uint8_t priority_max;\n\trt_uint8_t priority_min;\n\trt_uint8_t priority_level;\n\trt_uint8_t priority_preempt;\n\trt_uint8_t priority_sub;\n\trt_uint8_t priority_bit;\n\trt_uint8_t priority_ready;\n\trt_uint8_t priority_suspend;\n\trt_uint8_t priority_timeout;\n\trt_uint8_t priority_low;\n\trt_uint8_t priority_high;\n\trt_uint8_t priority_invalid;\n\trt_uint8_t priority_error;\n\trt_uint8_t priority_idle;\n\trt_uint8_t priority_robot;\n\trt_uint8_t priority_sensor;\n\trt_uint8_t priority_control;\n\trt_uint8_t priority_debug;\n\trt_uint8_t priority_system;\n\trt_uint8_t priority_user;\n\trt_uint8_t priority_max_level;\n\trt_uint8_t priority_min_level;\n\trt_uint8_t priority_max_preempt;\n\trt_uint8_t priority_min_preempt;\n\trt_uint8_t priority_max_sub;\n\trt_uint8_t priority_min_sub;\n\trt_uint8_t priority_max_bit;\n\trt_uint8_t priority_min_bit;\n\trt_uint8_t priority_max_ready;\n\trt_uint8_t priority_min_ready;\n\trt_uint8_t priority_max_suspend;\n\trt_uint8_t priority_min_suspend;\n\trt_uint8_t priority_max_timeout;\n\trt_uint8_t priority_min_timeout;\n\trt_uint8_t priority_max_low;\n\trt_uint8_t priority", "CodeBleu_score": 2.882846767171949}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    rt_err_t result;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_THREAD_CUSTOM);\n\n    /* thread stack is not empty */\n    RT_ASSERT(thread->stack_addr != RT_NULL);\n\n    /* set thread priority */\n    thread->current_priority = thread->init_priority;\n    thread->number           = thread->init_number;\n    thread->time_slice       = thread->init_time_slice;\n\n    /* reset thread object and activate it */\n    rt_list_remove(&(thread->tlist));\n    rt_list_insert_before(&(thread->tlist), &(thread->tlist_hash));\n    thread->stat = RT_THREAD_READY;\n\n    /* set error code */\n    result = RT_EOK;\n\n    /* resume thread */\n    if (thread->stat == RT_THREAD_READY) {\n        rt_thread_resume(thread);\n    }\n\n    /* invoke scheduler if it's enabled */\n    if (rt_thread_scheduler_enabled()) {\n        rt_schedule();\n    }\n\n    return result;\n}\n", "CodeBleu_score": 44.73571469138919}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    rt_ubase_t level;\n    rt_err_t result;\n    struct rt_thread *cur_thread;\n    rt_uint8_t status;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_THREAD_CUSTOM);\n\n    /* thread stack overflow checking */", "CodeBleu_score": 23.2067814446022}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_tick_t timeout_tick_tmp;\n    rt_timer_t timer;\n    int i;\n\n    for (i = RT_TIMER_SKIPLIST_LEVEL - 1; i >= 0; i--) {\n        timer = rt_list_entry(timer_list[i].next, struct rt_timer, row[i]);\n        if (timer->timeout < *timeout_tick) {\n            *timeout_tick = timer->timeout;\n        }\n    }\n\n    /* if the timer list is empty, return error */\n    if (*timeout_tick == RT_TICK_MAX) {\n        return -RT_ETIMEOUT;\n    }\n\n    /* get the next timeout tick */\n    timeout_tick_tmp = *timeout_tick;\n    for (i = RT_TIMER_SKIPLIST_LEVEL - 1; i >= 0; i--) {\n        timer = rt_list_entry(timer_list[i].next, struct rt_timer, row[i]);\n        if (timer->timeout > timeout_tick_tmp) {\n            *timeout_tick = timer->timeout;\n        }\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 39.30584600490935}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_timer_entry_t timer_entry;\n\n    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ERROR;\n    }\n\n    timer_entry = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer_entry, skip_list[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n    *timeout_tick = timer_entry->timeout_tick;\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 66.58928501821}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_timer_entry_t timer_entry;\n\n    /* check if the timer list is empty */\n    if (rt_list_isempty(timer_list)) {\n        return -RT_ERROR;\n    }\n\n    /* get the first timer entry */\n    timer_entry = rt_list_entry(timer_list->next, struct rt_timer_entry, list);\n\n    /* set timeout tick */\n    *timeout_tick = timer_entry->timeout_tick;\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 45.46720717681384}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)    rt_timer_t timer;\n\n    if ((timeout == RT_NULL) || (time == 0)) {\n        return RT_NULL;\n    }\n\n    if (time < RT_TICK_PER_SECOND / RT_TIMER_TICK_PER_SECOND) {\n        return RT_NULL;\n    }\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* initialize timer object */\n    timer->parent.type = RT_Object_Class_Timer;\n    timer->parent.flag = flag;\n    timer->timeout     = timeout;\n    timer->parameter   = parameter;\n    timer->init_tick   = time;\n    timer->timeout_tick = time;\n    timer->parent.ref_count = 0;\n    timer->parent.name = name;\n\n    rt_list_init(&(timer->row));\n\n    return timer;\n}", "CodeBleu_score": 52.07907205307241}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)    rt_timer_t timer;\n    register rt_ubase_t level;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* allocate memory */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL) {\n        rt_kprintf(\"rt_timer_create: no memory\\n\");\n        return RT_NULL;\n    }\n\n    /* initialize object */\n    timer->parent.type = RT_Object_Class_Timer;\n    timer->parent.identifier = 0;\n    timer->parent.name = name;\n    timer->timeout_func = timeout;\n    timer->parameter = parameter;\n    timer->init_tick = time;\n    timer->timeout_tick = time;\n    timer->flag = flag;\n\n    /* initialize suspend list and activated list */\n    rt_list_init(&(timer->suspend_node));\n    rt_list_init(&(timer->activated_node));\n\n    /* initialize timer */\n    timer->timeout_flag = RT_FALSE;\n    timer->timeout_suspend_flag = RT_FALSE;\n    timer->timeout_suspend_ticks = 0;\n    timer->timeout_suspend_time = 0;\n\n    /* initialize timer control block */\n    timer->parent.control_block = RT_NULL;\n\n    /* initialize object statistics */\n    timer->parent.ref_count = 0;\n    timer->parent.user_data = RT_NULL;\n    timer->parent.recursive_level = 0;\n\n    /* initialize object information */\n    timer->parent.information = RT_NULL;\n\n    /* initialize timer semaphore */\n    rt_sem_init(&(timer->timer_sem),\n                \"tm_sem\",\n                0,\n                RT_IPC_FLAG_FIFO);\n\n    /* initialize timer event */\n    rt_event_init(&(timer->timer_event),\n                  timer->parent.name,\n                  RT_IPC_FLAG_FIFO);\n\n   ", "CodeBleu_score": 41.057666213811444}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    timer->timeout_func = timeout;\n    timer->parameter    = parameter;\n    timer->init_tick    = time;\n    timer->timeout_tick = time;\n    timer->flag         = flag;\n\n    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n    return timer;\n}", "CodeBleu_score": 56.83775316493058}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Create a response recorder to capture the response.\n\trec := httptest.NewRecorder()\n\n\t// Create a new context of API and pass it to the next handler.\n\tctx := context.WithValue(req.Context(), apiKey, a)\n\treq = req.WithContext(ctx)\n\n\t// Create a new request to serve.\n\tnewReq := req.WithContext(ctx)\n\n\t// Create a handler to handle the request.\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ta.router.ServeHTTP(w, r)\n\t})\n\n\t// Serve the request using the handler.\n\th.ServeHTTP(rec, newReq)\n\n\t// Copy the headers from the recorder's response to the original response.\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Write the response body to the original response.\n\tres.Write(rec.Body.Bytes())\n}\n", "CodeBleu_score": 43.40998747298418}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Initialize the response writer\n\trw := NewResponseWriter(res)\n\n\t// Set the request context\n\tctx := req.Context()\n\tctx = context.WithValue(ctx, ContextKeyResponseWriter, rw)\n\tctx = context.WithValue(ctx, ContextKeyRequest, req)\n\tctx = context.WithValue(ctx, ContextKeyAPI, a)\n\treq = req.WithContext(ctx)\n\n\t// Set the request ID\n\treqID := uuid.NewV4()\n\tctx = context.WithValue(ctx, ContextKeyRequestID, reqID)\n\treq = req.WithContext(ctx)\n\n\t// Set the request logger\n\tlogger := a.logger.WithFields(logrus.Fields{\n\t\t\"request_id\": reqID,\n\t\t\"method\":     req.Method,\n\t\t\"path\":       req.URL.Path,\n\t\t\"query\":      req.URL.RawQuery,\n\t\t\"remote_ip\":  req.RemoteAddr,\n\t})\n\tctx = context.WithValue(ctx, ContextKeyLogger, logger)\n\treq = req.WithContext(ctx)\n\n\t// Set the request metrics\n\tmetrics := a.metrics.WithFields(logrus.Fields{\n\t\t\"request_id\": reqID,\n\t\t\"method\":     req.Method,\n\t\t\"path\":       req.URL.Path,\n\t\t\"query\":      req.URL.RawQuery,\n\t\t\"remote_ip\":  req.RemoteAddr,\n\t})\n\tctx = context.WithValue(ctx, ContextKeyMetrics, metrics)\n\treq = req.WithContext(ctx)\n\n\t// Set the request timer\n\ttimer := prometheus.NewTimer(metrics.Timer(\"request\"))\n\tdefer timer.ObserveDuration()\n\n\t// Set the request logger\n\tlogger = logger.WithField(\"request_id\", reqID)\n\tctx = context.WithValue(ctx, ContextKeyLogger, logger)\n\treq = req.WithContext(ctx)\n\n\t// Set the request metrics\n\tmetrics = metrics.WithField(\"request_id\", reqID)\n\tctx = context.WithValue(ctx", "CodeBleu_score": 26.99989289849264}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t// Create a response recorder\n\trec := httptest.NewRecorder()\n\t// Create a new request with the same method, url, and headers as the original request\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/\", a.GetAll).Methods(\"GET\")\n\tr.HandleFunc(\"/{id:[0-9]+}\", a.GetOne).Methods(\"GET\")\n\tr.HandleFunc(\"/\", a.Create).Methods(\"POST\")\n\tr.HandleFunc(\"/{id:[0-9]+}\", a.Update).Methods(\"PUT\")\n\tr.HandleFunc(\"/{id:[0-9]+}\", a.Delete).Methods(\"DELETE\")\n\tr.ServeHTTP(rec, req)\n\t// Copy the recorder's result to the original response\n\tcopyHeader(res.Header(), rec.Header())\n\tres.WriteHeader(rec.Code)\n\tres.Write(rec.Body.Bytes())\n}\n", "CodeBleu_score": 29.529356453364507}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// Get the path from the request URL.\n\tpath := req.URL.Path\n\n\t// Remove the leading slash.\n\tif len(path) > 0 && path[0] == '/' {\n\t\tpath = path[1:]\n\t}\n\n\t// Get the file extension.\n\text := filepath.Ext(path)\n\n\t// Get the asset content.\n\tcontent, err := a.getAsset(path)\n\n\t// If an error occurred, return a 404 error.\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the Content-Type header.\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response.\n\tres.Write(content)\n}\n", "CodeBleu_score": 51.24441267526121}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// We need to get the requested asset from the URL path.\n\t// The path is the part of the URL after the domain name.\n\t// For example, if the URL is https://example.com/foo/bar/baz.css,\n\t// the path is /foo/bar/baz.css.\n\t// We need to get the path from the request object.\n\tpath := req.URL.Path\n\n\t// We need to get the file extension from the path.\n\t// The extension is the part of the path after the last period.\n\t// For example, if the path is /foo/bar/baz.css, the extension is .css.\n\t// We need to get the extension from the path.\n\text := filepath.Ext(path)\n\n\t// We need to get the directory path from the path.\n\t// The directory path is the part of the path before the last slash.\n\t// For example, if the path is /foo/bar/baz.css, the directory path is /foo/bar/.\n\t// We need to get the directory path from the path.\n\tdir := filepath.Dir(path)\n\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension.\n\t// We need to get the asset from the directory path and the extension", "CodeBleu_score": 15.693217307995019}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// Get the requested asset name from the URL path.\n\tassetName := strings.Trim(req.URL.Path, \"/\")\n\tif assetName == \"\" {\n\t\thttp.Error(res, \"Not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the asset content from the file system.\n\tassetContent, err := a.fs.ReadFile(assetName)\n\tif err != nil {\n\t\thttp.Error(res, \"Not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the Content-Type header based on the file extension.\n\tcontentType := mime.TypeByExtension(path.Ext(assetName))\n\tif contentType == \"\" {\n\t\tcontentType = \"application/octet-stream\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the asset content to the response.\n\t_, err = res.Write(assetContent)\n\tif err != nil {\n\t\thttp.Error(res, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 52.20542737207155}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\tif robotName == \"\" {\n\t\ta.sendError(res, req, \"robot name is required\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\ta.sendError(res, req, fmt.Sprintf(\"no robot with name %s found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\ta.sendError(res, req, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}\n", "CodeBleu_score": 37.15435354463112}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Find the robot with the specified name\n\trobot, ok := a.master.Robot(name)\n\tif !ok {\n\t\thttp.Error(res, \"No robot found with name \"+name, http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the robot's connections\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}\n", "CodeBleu_score": 33.640274651984164}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Find the robot in the master instance\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\tlog.Printf(\"Error: %v\\n\", err)\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the connections of the robot\n\tconnections, err := robot.Connections()\n\tif err != nil {\n\t\tlog.Printf(\"Error: %v\\n\", err)\n\t\thttp.Error(res, \"Error getting connections\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Convert the connections to JSON\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\tlog.Printf(\"Error: %v\\n\", err)\n\t\thttp.Error(res, \"Error converting connections to JSON\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}\n", "CodeBleu_score": 35.95000801531634}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif user != username || pass != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 49.858167782154275}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 51.55326323959021}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If everything checks out, call the next handler\n\t\tr.Header.Del(\"Authorization\")\n\t\tr.Header.Del(\"WWW-Authenticate\")\n\t\tr.Header.Del(\"Cookie\")\n\t\tr.Header.Del(\"Set-Cookie\")\n\t\tr.Header.Del(\"X-Forwarded-For\")\n\t\tr.Header.Del(\"X-Forwarded-Host\")\n\t\tr.Header.Del(\"X-Forwarded-Proto\")\n\t\tr.Header.Del(\"X-Forwarded-Server\")\n\t\tr.Header.Del(\"X-Forwarded-Port\")\n\t\tr.Header.Del(\"X-Forwarded-Prefix\")\n\t\tr.Header.Del(\"X-Original-URI\")\n\t\tr.Header.Del(\"X-Scheme\")\n\t\tr.Header.Del(\"X-HTTPS\")\n\t\tr.Header.Del(\"X-Forwarded-Ssl\")\n\t\tr.Header.Del(\"X-Forwarded-Ssl-Cert\")\n\t\tr.Header.Del(\"X-Forwarded-Ssl-Cipher\")\n\t\tr.Header.Del(\"X-Forwarded-Ssl-Cipher-Bits\")\n\t\tr.Header.Del(\"X-Forwarded-Ssl-Cipher-Algo\")\n\t\tr.Header.Del(\"X-Forwarded-Ssl-Version\")\n\t\tr.Header.Del(\"X-Forwarded-Client-Cert\")\n\t\tr.Header.", "CodeBleu_score": 45.334757045964714}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - (slope * float64(fromMin))\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 55.114247312753115}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \t// Calculate the slope and intercept for the scaling transformation.\n\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * float64(fromMin)\n\t// Return a function that performs the scaling.\n\treturn func(input float64) (value int) {\n\t\t// Perform the scaling.\n\t\tvalue = int(slope * input + intercept)\n\t\t// Clamp the output.\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 52.8920378824039}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \t// Calculate the slope and intercept for the scaling transformation.\n\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*float64(fromMin)\n\n\t// Create the function that performs the scaling.\n\treturn func(input float64) (value int) {\n\t\t// Calculate the scaled value.\n\t\tscaled := slope*input + intercept\n\n\t\t// Clamp the value to the target range.\n\t\tif scaled < float64(toMin) {\n\t\t\treturn toMin\n\t\t} else if scaled > float64(toMax) {\n\t\t\treturn toMax\n\t\t}\n\n\t\t// Return the scaled value.\n\t\treturn int(scaled)\n\t}\n}\n", "CodeBleu_score": 61.484018871393964}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"invalid connection\")\n\t}\n\tif !a.connection.IsAnalogSupported() {\n\t\treturn 0, 0, errors.New(\"analog not supported\")\n\t}\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scaleFunc(raw)\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 51.90010182762319}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the mutex to ensure thread safety\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Verify that the connection is valid\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is invalid\")\n\t}\n\n\t// Verify that the connection supports analog reading\n\tif !a.connection.IsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\t// Read the raw value from the specified pin\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"unable to read raw value from pin %d: %v\", a.pin, err)\n\t}\n\n\t// Update the last raw and scaled values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = float64(rawValue) / float64(a.scaleFactor)\n\n\t// Return the raw value, the scaled value, and any error encountered during the read operation\n\treturn rawValue, a.lastScaledValue, nil\n}\n", "CodeBleu_score": 52.21888621920721}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: connection is nil\")\n\t}\n\tif !a.connection.IsAnalogReadSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: connection does not support analog reading\")\n\t}\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: %v\", err)\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 47.10884671899072}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tif fromMin == fromMax {\n\t\tfromMax++\n\t}\n\tif toMin == toMax {\n\t\ttoMax++\n\t}\n\n\tslope := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tintercept := toMin - (slope * float64(fromMin))\n\n\treturn func(value int) float64 {\n\t\treturn (slope * float64(value)) + intercept\n\t}\n}\n", "CodeBleu_score": 42.664507385706116}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \treturn func(value int) float64 {\n\t\treturn (toMax - toMin) * (float64(value) - float64(fromMin)) / float64(fromMax-fromMin) + toMin\n\t}\n}\n", "CodeBleu_score": 33.0780905074209}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \t// Calculate the slope (m) and intercept (n) for the linear transformation.\n\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\n\t// Return a function that linearly scales the input value from the provided input range to the output range.\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}\n", "CodeBleu_score": 52.21257379953674}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\t// Initialize the driver with the given analog reader, pin, and options.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: *NewAnalogSensorDriver(a, pin, opts...),\n\t\tvibrationThreshold: 1000,\n\t}\n\n\t// Set a default name for the driver.\n\td.SetName(DefaultGrovePiezoVibrationSensorDriverName)\n\n\t// Add a vibration event.\n\td.AddEvent(VibrationEvent)\n\n\t// Set up an event listener for data events that publishes a vibration event if the data exceeds a threshold value of 1000.\n\t// If an error occurs while setting up the event listener, it panics.\n\td.On(\n\t\tDataEvent,\n\t\tfunc(e Event) {\n\t\t\tdata := e.Data().(float64)\n\t\t\tif data >= d.vibrationThreshold {\n\t\t\t\td.Publish(VibrationEvent, data)\n\t\t\t}\n\t\t},\n\t)\n\n\treturn d\n}\n", "CodeBleu_score": 40.379608690627954}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\toptions := parseOptions(opts...)\n\tif options.name == \"\" {\n\t\toptions.name = defaultGrovePiezoVibrationSensorDriverName\n\t}\n\tif options.threshold == 0 {\n\t\toptions.threshold = defaultGrovePiezoVibrationSensorDriverThreshold\n\t}\n\tif options.interval == 0 {\n\t\toptions.interval = defaultGrovePiezoVibrationSensorDriverInterval\n\t}\n\tif options.decay == 0 {\n\t\toptions.decay = defaultGrovePiezoVibrationSensorDriverDecay\n\t}\n\tif options.noise == 0 {\n\t\toptions.noise = defaultGrovePiezoVibrationSensorDriverNoise\n\t}\n\tif options.offset == 0 {\n\t\toptions.offset = defaultGrovePiezoVibrationSensorDriverOffset\n\t}\n\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:     options.name,\n\t\tthreshold: options.threshold,\n\t\tinterval:  options.interval,\n\t\tdecay:     options.decay,\n\t\tnoise:     options.noise,\n\t\toffset:    options.offset,\n\t}\n\n\td.sensor = NewAnalogSensorDriver(a, pin, WithAnalogSensorDriverName(options.name))\n\n\td.sensor.AddListener(d)\n\n\tif err := d.sensor.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}\n", "CodeBleu_score": 34.766554687574235}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\tif a == nil {\n\t\tpanic(\"analog reader is nil\")\n\t}\n\tif pin == \"\" {\n\t\tpanic(\"pin is empty\")\n\t}\n\tp := &GrovePiezoVibrationSensorDriver{\n\t\tname: DefaultName,\n\t\tasd: AnalogSensorDriver{\n\t\t\tas: NewAnalogSensor(a, pin, opts...),\n\t\t},\n\t}\n\tp.asd.AddListener(p)\n\treturn p\n}\n", "CodeBleu_score": 31.28381654217095}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif d.isClosed {\n\t\treturn errors.New(\"buzzer is closed\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"frequency must be greater than 0\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"duration must be greater than or equal to 0\")\n\t}\n\tif d.pin.Mode() != gpio.Output {\n\t\treturn errors.New(\"buzzer pin must be configured as output\")\n\t}\n\tperiod := float64(time.Second) / (hz * d.tempo)\n\tif period < 1 {\n\t\treturn errors.New(\"frequency is too high for the specified tempo\")\n\t}\n\td.tone = true\n\td.toneHZ = hz\n\td.toneDuration = duration\n\td.tonePeriod = period\n\td.toneTime = time.Now()\n\treturn nil\n}\n", "CodeBleu_score": 25.988669469399984}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif d.IsConnected() {\n\t\tif d.buzzer.IsConnected() {\n\t\t\t// Calculate the tone period\n\t\t\tperiod := 1000000 / hz\n\t\t\t// Calculate the tempo\n\t\t\ttempo := d.buzzer.BeatsPerMinute()\n\t\t\t// Calculate the number of beats\n\t\t\tbeats := int(duration * tempo)\n\t\t\t// Calculate the total time\n\t\t\ttime := beats * period\n\t\t\t// Calculate the number of periods\n\t\t\tperiods := int(time / period)\n\t\t\t// Calculate the time left\n\t\t\ttimeLeft := time % period\n\t\t\t// Calculate the time between each beat\n\t\t\ttimeBetween := period / periods\n\t\t\t// Calculate the time before each beat\n\t\t\ttimeBefore := timeBetween / 2\n\t\t\t// Toggle the buzzer on and off\n\t\t\tfor i := 0; i < periods; i++ {\n\t\t\t\t// Toggle the buzzer on\n\t\t\t\td.buzzer.On()\n\t\t\t\t// Wait for the time before the beat\n\t\t\t\ttime.Sleep(time.Duration(timeBefore) * time.Microsecond)\n\t\t\t\t// Toggle the buzzer off\n\t\t\t\td.buzzer.Off()\n\t\t\t\t// Wait for the time between beats\n\t\t\t\ttime.Sleep(time.Duration(timeBetween) * time.Microsecond)\n\t\t\t}\n\t\t\t// Toggle the buzzer on\n\t\t\td.buzzer.On()\n\t\t\t// Wait for the time before the last beat\n\t\t\ttime.Sleep(time.Duration(timeBefore) * time.Microsecond)\n\t\t\t// Toggle the buzzer off\n\t\t\td.buzzer.Off()\n\t\t\t// Wait for the time left\n\t\t\ttime.Sleep(time.Duration(timeLeft) * time.Microsecond)\n\t\t} else {\n\t\t\treturn errors.", "CodeBleu_score": 35.23770035425291}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif !d.IsConnected() {\n\t\treturn fmt.Errorf(\"Not connected\")\n\t}\n\n\tif hz < 0 {\n\t\treturn fmt.Errorf(\"Invalid frequency\")\n\t}\n\n\tif duration < 0 {\n\t\treturn fmt.Errorf(\"Invalid duration\")\n\t}\n\n\tperiod := 1000.0 / hz\n\tbpm := d.bpm\n\tif bpm <= 0 {\n\t\tbpm = 120\n\t}\n\ttoneDuration := period * duration * 1000 / 1000\n\ttonePeriod := period * 1000 / 1000\n\ttoneDuration = math.Round(toneDuration)\n\ttonePeriod = math.Round(tonePeriod)\n\ttoneDuration = int(toneDuration)\n\ttonePeriod = int(tonePeriod)\n\n\tif toneDuration <= 0 {\n\t\treturn fmt.Errorf(\"Invalid duration\")\n\t}\n\n\tif tonePeriod <= 0 {\n\t\treturn fmt.Errorf(\"Invalid frequency\")\n\t}\n\n\tif tonePeriod > 1000 {\n\t\treturn fmt.Errorf(\"Invalid frequency\")\n\t}\n\n\td.tonePeriod = tonePeriod\n\td.toneDuration = toneDuration\n\n\td.toneStart = time.Now()\n\td.toneEnd = d.toneStart.Add(time.Duration(d.toneDuration) * time.Millisecond)\n\n\tfor {\n\t\tif time.Now().After(d.toneEnd) {\n\t\t\tbreak\n\t\t}\n\t\tif err := d.Set(true); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(d.tonePeriod) * time.Millisecond)\n\t\tif err := d.Set(false); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(d.tonePeriod) * time.Millisecond)\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 35.25169730569667}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"EasyDriver: sleep pin is not configured\")\n\t}\n\n\tif d.sleepPin.Get() == 0 {\n\t\treturn errors.New(\"EasyDriver: sleep pin is not set\")\n\t}\n\n\td.sleepPin.Set(0)\n\td.sleepPin.WaitForEdge()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 37.548852961673816}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\tif d.sleepPin.IsSet() {\n\t\treturn errors.New(\"sleep pin is already set\")\n\t}\n\td.stop()\n\td.sleepPin.Set()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 36.87371577588008}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\t// Check if the sleep pin is set\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\n\t// Stop any ongoing operations\n\td.stop()\n\n\t// Set the sleep pin to low\n\td.sleepPin.Low()\n\n\t// Mark the driver as sleeping\n\td.sleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 32.12789586069545}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"analog pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.analogPinPath(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := NewAnalogPin(a.adaptor, path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 52.02639100256788}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.initializeAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 46.07340543240556}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"analog pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, err := a.analogPinPath(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := a.newAnalogPin(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 50.20570968930138}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.GetDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}\n", "CodeBleu_score": 63.05072167256442}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif pin.mode != OUTPUT {\n\t\treturn errors.New(\"pin is not configured for output\")\n\t}\n\n\treturn pin.write(val)\n}\n", "CodeBleu_score": 66.21249512225363}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif pin.direction != OUT {\n\t\treturn errors.New(\"pin \" + id + \" is not configured as an output\")\n\t}\n\n\tpin.value = val\n\n\tif err = a.writePin(pin); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 64.1286021738822}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif a.connected {\n\t\treturn a.GetDigitalPin(id)\n\t}\n\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n}\n", "CodeBleu_score": 9.816587385857645}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif len(a.Pins) == 0 {\n\t\treturn nil, errors.New(\"No pins configured for DigitalPinsAdaptor\")\n\t}\n\tif pin, ok := a.Pins[id]; ok {\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\tpin := a.newDigitalPin(id)\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\ta.Pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 30.033544150631464}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"No pins configured for DigitalPinsAdaptor\")\n\t}\n\n\t// Apply options to existing pin if it exists.\n\tif p, ok := a.pins[id]; ok {\n\t\tfor _, opt := range opts {\n\t\t\topt(p)\n\t\t}\n\t\treturn p, nil\n\t}\n\n\t// Translate the pin ID to obtain chip and line information.\n\tchip, line, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new digital pin.\n\tp := NewDigitalPin(chip, line)\n\tfor _, opt := range opts {\n\t\topt(p)\n\t}\n\n\t// Initialize the digital pin.\n\tif err := p.Init(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Store the new digital pin.\n\ta.pins[id] = p\n\n\treturn p, nil\n}\n", "CodeBleu_score": 47.73975322162277}]}
