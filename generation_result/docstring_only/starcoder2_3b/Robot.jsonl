{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> requiredFiles;\n\tfor (const auto &file : m_fileManager.GetFiles(folder)) {\n\t\tif (download &&!m_fileManager.FileExists(file)) {\n\t\t\tm_fileManager.RequestFile(file);\n\t\t\tm_logger.Log(LogLevel::Info, \"Downloading file: \" + file);\n\t\t} else {\n\t\t\tm_logger.Log(LogLevel::Info, \"File found in cache: \" + file);\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\treturn requiredFiles;\n}\n", "CodeBleu_score": 50.16012883314822}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> files;\n\tstd::string path = folder + \"/\";\n\tstd::string file;\n\tstd::ifstream in(path + \"files.txt\");\n\tif (!in.is_open()) {\n\t\treturn files;\n\t}\n\twhile (std::getline(in, file)) {\n\t\tif (file.empty()) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (download) {\n\t\t\tif (file_exists(path + file)) {\n\t\t\t\tlogger->Log(LogLevel::INFO, \"File found in cache: \" + file);\n\t\t\t} else {\n\t\t\t\tlogger->Log(LogLevel::INFO, \"File not found in cache: \" + file);\n\t\t\t\tfiles.push_back(file);\n\t\t\t}\n\t\t} else {\n\t\t\tfiles.push_back(file);\n\t\t}\n\t}\n\tin.close();\n\treturn files;\n}\n", "CodeBleu_score": 42.67561260957078}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> required_files;\n\tfor (const auto &file : fs::directory_iterator(folder)) {\n\t\tstd::string file_name = file.path().filename().string();\n\t\tif (file_name.find(\".txt\")!= std::string::npos) {\n\t\t\trequired_files.push_back(file_name);\n\t\t}\n\t}\n\treturn required_files;\n}\n", "CodeBleu_score": 35.132284050123644}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)\trpc::Actor actor;\n\trpc::SpawnActorWithParent(description, transform, parent, attachment_type, socket_name, actor);\n\treturn actor;\n}\n", "CodeBleu_score": 25.656455409742424}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)\trpc::ActorId actor_id = SpawnActor(description, transform);\n\n\tif (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n\t\t// If the attachment type is SpringArm or SpringArmGhost, it checks the validity of the transformation to avoid ill-formed transformations when the translation is only in the 'z' axis and issues a warning if necessary.\n\t\tif (transform.translation.z == 0.0f && transform.rotation.w == 1.0f) {\n\t\t\tLOG(WARNING) << \"The transformation of the actor with ID \" << actor_id << \" is ill-formed and will be ignored.\";\n\t\t}\n\t\telse {\n\t\t\t// If the attachment type is SpringArm or SpringArmGhost, it calls an internal function to complete the actor spawning process and returns the spawned actor.\n\t\t\tCompleteActorSpawnWithParent(actor_id, parent, attachment_type, socket_name);\n\t\t}\n\t}\n\telse {\n\t\t// If the attachment type is not SpringArm or SpringArmGhost, it calls an internal function to complete the actor spawning process and returns the spawned actor.\n\t\tCompleteActorSpawnWithParent(actor_id, parent, attachment_type, socket_name);\n\t}\n\n\treturn actor_id;\n}\n", "CodeBleu_score": 46.17756038027703}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)\trpc::Actor actor;\n\tif (description.actor_type() == rpc::ActorType::kSpringArm) {\n\t\tif (transform.translation().z()!= 0) {\n\t\t\tLOG_WARNING(\"SpawnActorWithParent: The translation of a SpringArm should not be in the 'z' axis, but is %f\", transform.translation().z());\n\t\t}\n\t} else if (description.actor_type() == rpc::ActorType::kSpringArmGhost) {\n\t\tif (transform.translation().z()!= 0) {\n\t\t\tLOG_WARNING(\"SpawnActorWithParent: The translation of a SpringArmGhost should not be in the 'z' axis, but is %f\", transform.translation().z());\n\t\t}\n\t}\n\tactor = SpawnActorInternal(description, transform, parent, attachment_type, socket_name);\n\treturn actor;\n}\n", "CodeBleu_score": 39.97463337748092}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\tauto it = gbuffer_subscriptions_.find(ActorId);\n\tif (it == gbuffer_subscriptions_.end()) {\n\t\tgbuffer_subscriptions_.insert(std::make_pair(ActorId, std::make_pair(std::vector<uint32_t>(), std::vector<std::function<void(Buffer)>>())));\n\t\tit = gbuffer_subscriptions_.find(ActorId);\n\t}\n\tauto& gbuffer_subscription = it->second;\n\tauto it2 = std::find(gbuffer_subscription.first.begin(), gbuffer_subscription.first.end(), GBufferId);\n\tif (it2 == gbuffer_subscription.first.end()) {\n\t\tgbuffer_subscription.first.push_back(GBufferId);\n\t\tgbuffer_subscription.second.push_back(callback);\n\t\tSubscribeToGBuffer(ActorId, GBufferId, callback);\n\t}\n}\n", "CodeBleu_score": 41.323936911964005}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\tauto& actor = GetActor(ActorId);\n\tauto& gbuffer = actor.GetGBuffer(GBufferId);\n\tauto token = gbuffer.GetStreamingToken();\n\tauto tokenData = token.GetData();\n\n\tauto streamingClient = StreamingClient::Create(tokenData, callback);\n\tstreamingClient->Start();\n}\n", "CodeBleu_score": 41.63205825171663}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)#if!defined(NDEBUG)\n  std::cout << \"Client::SubscribeToGBuffer() - ActorId: \" << ActorId << \", GBufferId: \" << GBufferId << std::endl;", "CodeBleu_score": 17.80105434357324}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (m_navigation == nullptr) {\n\t\tm_navigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn m_navigation;\n}\n", "CodeBleu_score": 23.95281496222858}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (this->walkerNavigation == nullptr) {\n\t\tthis->walkerNavigation = std::make_shared<WalkerNavigation>(this->walker);\n\t}\n\treturn this->walkerNavigation;\n}\n", "CodeBleu_score": 17.02927748823802}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn navigation;\n}\n", "CodeBleu_score": 23.58572265903463}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tconst time_duration interval = std::chrono::milliseconds(100);\n\ttime_duration elapsed = std::chrono::milliseconds(0);\n\twhile (elapsed < timeout) {\n\t\tif (episode.Frame() < frame) {\n\t\t\tepisode.TriggerTick();\n\t\t\treturn true;\n\t\t}\n\t\tstd::this_thread::sleep_for(interval);\n\t\telapsed += interval;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 34.36687422291315}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\t//TODO: Implement SynchronizeFrame\n\treturn false;\n}\n", "CodeBleu_score": 2.7370644134949518}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tauto start = std::chrono::high_resolution_clock::now();\n\twhile (episode.frame < frame) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tauto now = std::chrono::high_resolution_clock::now();\n\t\tif (std::chrono::duration_cast<time_duration>(now - start).count() > timeout.count()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tTrafficManager::Instance().Tick();\n\treturn true;\n}\n", "CodeBleu_score": 41.546395239152965}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tEpisodeProxy episode;\n\tint attempts = 0;\n\twhile (attempts < MAX_LOAD_ATTEMPTS) {\n\t\ttry {\n\t\t\tepisode = LoadEpisode(map_name, reset_settings, map_layers, MAX_LOAD_TIMEOUT);\n\t\t\treturn episode;\n\t\t} catch (const std::runtime_error& e) {\n\t\t\tstd::cout << \"Failed to load episode: \" << e.what() << std::endl;\n\t\t\tstd::cout << \"Retrying...\" << std::endl;\n\t\t\tattempts++;\n\t\t}\n\t}\n\tthrow std::runtime_error(\"Failed to load episode after \" + std::to_string(attempts) + \" attempts.\");\n}\n", "CodeBleu_score": 39.43320290986942}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\trpc::Episode episode;\n\trpc::Episode episode_copy;\n\trpc::Episode episode_copy_2;\n\trpc::Episode episode_copy_3;\n\trpc::Episode episode_copy_4;\n\trpc::Episode episode_copy_5;\n\trpc::Episode episode_copy_6;\n\trpc::Episode episode_copy_7;\n\trpc::Episode episode_copy_8;\n\trpc::Episode episode_copy_9;\n\trpc::Episode episode_copy_10;\n\trpc::Episode episode_copy_11;\n\trpc::Episode episode_copy_12;\n\trpc::Episode episode_copy_13;\n\trpc::Episode episode_copy_14;\n\trpc::Episode episode_copy_15;\n\trpc::Episode episode_copy_16;\n\trpc::Episode episode_copy_17;\n\trpc::Episode episode_copy_18;\n\trpc::Episode episode_copy_19;\n\trpc::Episode episode_copy_20;\n\trpc::Episode episode_copy_21;\n\trpc::Episode episode_copy_22;\n\trpc::Episode episode_copy_23;\n\trpc::Episode episode_copy_24;\n\trpc::Episode episode_copy_25;\n\trpc::Episode episode_copy_26;\n\trpc::Episode episode_copy_27;\n\trpc::Episode episode_copy_28;\n\trpc::Episode episode_copy_29;\n\trpc::Episode episode_copy_30;\n\trpc::Episode episode_copy_31;\n\trpc::Episode episode_copy_32;\n\trpc::Episode episode_copy_33;\n\trpc::Episode episode_copy_34;\n\trpc::Episode episode_copy_35;\n\trpc::Episode episode_copy_36;\n\trpc::Episode episode_copy_37;\n\trpc::Episode episode_copy_38;\n\trpc::Episode episode_copy_39;\n\trpc::Episode episode_copy_40;\n\trpc::Episode episode_copy_41;\n\trpc::Episode episode_copy_42;\n\trpc::Episode episode_copy_43;\n", "CodeBleu_score": 4.988454846645399}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tEpisodeProxy ep = EpisodeProxy(this);\n\tep.LoadEpisode(map_name, reset_settings, map_layers);\n\treturn ep;\n}\n", "CodeBleu_score": 16.383994206074743}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tassert(episode!= nullptr);\n\tif (episode->navigation == nullptr) {\n\t\tepisode->navigation = std::make_unique<Navigation>();\n\t}\n\tepisode->navigation->RegisterWalker(controller.id, controller.walker);\n}\n", "CodeBleu_score": 34.011824645487046}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tassert(episode!= nullptr);\n\tWalker *walker = episode->GetWalker(controller.GetWalkerID());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\tif (walker->GetNavigation() == nullptr) {\n\t\twalker->SetNavigation(new Navigation(walker));\n\t}\n\twalker->GetNavigation()->RegisterAIController(controller);\n}\n", "CodeBleu_score": 52.90154729257834}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tWalker *walker = GetWalker(controller.ID);\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\tif (walker->Episode == nullptr) {\n\t\twalker->Episode = new Episode();\n\t}\n\twalker->Episode->RegisterAIController(controller);\n}\n", "CodeBleu_score": 41.772553372373956}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)\treturn SpawnActor(blueprint, transform, parent, attachment_type, socket_name, gc);\n}\n", "CodeBleu_score": 18.095194416212994}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)#ifndef UE_SERVER\n  UE_LOG(LogTemp, Warning, TEXT(\"SpawnActor() is not implemented in this build.\"));\n  return nullptr;", "CodeBleu_score": 9.174816621020595}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)\t// TODO: Implement this function.\n\t// This function is called by the engine when an actor is spawned in the simulation.\n\t// It spawns an actor using the specified blueprint and transform.\n\t// If a parent actor is provided, it spawns the new actor as a child of the parent with a specified attachment type and socket name.\n\t// Otherwise, it spawns the actor independently.\n\t// The function registers the new actor in the current episode, applies the appropriate garbage collection policy, and logs the creation details.\n\t// Finally, it returns a shared pointer to the newly created actor.\n\n\t// TODO: Implement this function.\n\t// This function is called by the engine when an actor is spawned in the simulation.\n\t// It spawns an actor using the specified blueprint and transform.\n\t// If a parent actor is provided, it spawns the new actor as a child of the parent with a specified attachment type and socket name.\n\t// Otherwise, it spawns the actor independently.\n\t// The function registers the new actor in the current episode, applies the appropriate garbage collection policy, and logs the creation details.\n\t// Finally, it returns a shared pointer to the newly created actor.\n\t// TODO: Implement this function.\n\t// This function is called by the engine when an actor is spawned in the simulation.\n\t// It spawns an actor using the specified blueprint and transform.\n\t// If a parent actor is provided, it spawns the new actor as a child of the parent with a specified attachment type and socket name.\n\t// Otherwise, it spawns the actor independently.\n\t// The function registers the new actor in the current episode, applies the appropriate garbage collection policy, and logs the creation details.\n\t// Finally, it returns a shared pointer to the newly created actor.\n\t// TODO: Implement this function.\n\t// This function is called by the engine when an actor is spawned in the simulation.\n\t// It spawns an actor using the specified blueprint and transform.\n\t// If a parent actor is provided, it spawns the new actor as a child of the parent with a specified attachment type and socket name.\n\t// Otherwise, it spawns the actor independently.\n\t// The function registers the new actor in the current episode, applies the appropriate garbage collection policy, and logs the creation details.\n\t// Finally, it returns a shared", "CodeBleu_score": 7.339108429695014}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)\tif (episode == nullptr) {\n\t\tthrow std::runtime_error(\"Episode not initialized\");\n\t}\n\tsensor_data_subscriber_map.emplace(sensor.id, std::move(callback));\n\tclient->SubscribeToStream(sensor.id);\n}\n", "CodeBleu_score": 25.27645088774979}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)\t// TODO: Implement this function.\n\t// You will need to use the provided Sensor class to access the sensor's data stream.\n\t// You will also need to use the provided SensorData class to deserialize the incoming sensor data.\n\t// You will need to use the provided Episode class to associate the sensor data with the current episode.\n\t// You will also need to use the provided Callback class to invoke the provided callback with the sensor data.\n\t// You will need to use the provided Simulator class to subscribe to the sensor's data stream.\n\t// You will need to use the provided Simulator::GetEpisode method to get the current episode.\n\t// You will need to use the provided Simulator::GetClient method to get the client.\n\t// You will need to use the provided Simulator::GetSensorData method to deserialize the incoming sensor data.\n\t// You will need to use the provided Simulator::AssociateSensorDataWithEpisode method to associate the sensor data with the current episode.\n\t// You will need to use the provided Simulator::InvokeCallback method to invoke the provided callback with the sensor data.\n\t// You will need to use the provided Simulator::SubscribeToStream method to subscribe to the sensor's data stream.\n\t// You will need to use the provided Simulator::SetCallback method to set the callback for the sensor's data stream.\n\t// You will need to use the provided Simulator::GetSensorData method to get the sensor data.\n\t// You will need to use the provided Simulator::GetClient method to get the client.\n\t// You will need to use the provided Simulator::GetEpisode method to get the current episode.\n\t// You will need to use the provided Simulator::GetSensorData method to deserialize the incoming sensor data.\n\t// You will need to use the provided Simulator::AssociateSensorDataWithEpisode method to associate the sensor data with the current episode.\n\t// You will need to use the provided Simulator::InvokeCallback method to invoke the provided callback with the sensor data.\n\t// You will need to use the provided Simulator::SubscribeToStream method to subscribe to the sensor's data stream.\n\t// You will need to use the provided Simulator::SetCallback method to set the callback for the sensor's data stream.\n\t// You will need to use the provided Simulator::GetSensorData method to get the sensor data.\n\t// You will need to use the provided Simulator::GetClient method to", "CodeBleu_score": 10.656427823380834}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)\tif (!IsEpisodeValid()) {\n\t\tthrow std::runtime_error(\"Episode is not valid\");\n\t}\n\tif (sensor.GetSensorType() == SensorType::CAMERA) {\n\t\tauto camera = std::static_pointer_cast<const CameraSensor>(sensor);\n\t\tauto cameraSensorData = std::make_shared<CameraSensorData>(camera->GetCameraId());\n\t\tcameraSensorData->SetCamera(camera);\n\t\tcameraSensorData->SetEpisode(GetEpisode());\n\t\tSubscribeToStream(camera->GetCameraId(), [cameraSensorData, callback](const std::string& data) {\n\t\t\tcameraSensorData->Deserialize(data);\n\t\t\tcallback(cameraSensorData);\n\t\t});\n\t} else if (sensor.GetSensorType() == SensorType::DEPTH) {\n\t\tauto depth = std::static_pointer_cast<const DepthSensor>(sensor);\n\t\tauto depthSensorData = std::make_shared<DepthSensorData>(depth->GetDepthId());\n\t\tdepthSensorData->SetDepth(depth);\n\t\tdepthSensorData->SetEpisode(GetEpisode());\n\t\tSubscribeToStream(depth->GetDepthId(), [depthSensorData, callback](const std::string& data) {\n\t\t\tdepthSensorData->Deserialize(data);\n\t\t\tcallback(depthSensorData);\n\t\t});\n\t} else if (sensor.GetSensorType() == SensorType::OBJECT_TRACKING) {\n\t\tauto objectTracking = std::static_pointer_cast<const ObjectTrackingSensor>(sensor);\n\t\tauto objectTrackingSensorData = std::make_shared<ObjectTrackingSensorData>(objectTracking->GetObjectId());\n\t\tobjectTrackingSensorData->SetObjectTracking(objectTracking);\n\t\tobjectTrackingSensorData->SetEpisode(GetEpisode());\n\t\tSubscribeToStream(objectTracking->GetObjectId(), [objectTrackingSensorData, callback](const std::string& data) {\n\t\t\tobjectTrackingSensorData->Deserialize(data);\n\t\t\tcallback(objectTrackingSensorData);\n\t\t});\n\t} else if (sensor.GetSensorType() == SensorType::RGB) {\n\t\tauto rgb = std::static_pointer_cast<const RgbSensor>(sensor);\n\t\tauto rgbSensorData = std::make_shared<RgbSensorData>(rgb->GetRgbId());\n\t\trgbSensorData->SetRgb(rgb);\n\t\trgbSensorData->", "CodeBleu_score": 41.20567972342995}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// Load current walkers\n\tauto walkers = episode->GetWalkers();\n\n\t// Check if walkers are empty\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get current state of episode\n\tauto state = episode->GetState();\n\tauto crowd = episode->GetCrowd();\n\n\t// Remove any walkers that no longer exist\n\tfor (auto it = walkers.begin(); it!= walkers.end();) {\n\t\tif (!state->GetWalker(it->first)) {\n\t\t\tit = walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update vehicles in crowd and crowd itself\n\tcrowd->Update();\n\n\t// Apply walker states to simulator\n\tfor (auto walker : walkers) {\n\t\tauto transform = walker.second->GetTransform();\n\t\tauto speed = walker.second->GetSpeed();\n\t\tauto agent = walker.second->GetAgent();\n\n\t\t// Apply transform and speed to simulator\n\t\tsimulator->SetTransform(walker.first, transform);\n\t\tsimulator->SetSpeed(walker.first, speed);\n\n\t\t// Apply agent to simulator\n\t\tif (agent) {\n\t\t\tsimulator->SetAgent(walker.first, agent);\n\t\t}\n\t}\n\n\t// Check if any walkers have been killed\n\tauto killed = simulator->CheckKilled();\n\tfor (auto walker : killed) {\n\t\tauto agent = walker->GetAgent();\n\n\t\t// Remove walker from episode\n\t\tepisode->RemoveWalker(walker->GetId());\n\n\t\t// Remove walker from crowd\n\t\tcrowd->RemoveWalker(walker->GetId());\n\n\t\t// Destroy walker controller\n\t\tif (agent) {\n\t\t\tagent->Destroy();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.91007698907697}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\tstd::vector<std::shared_ptr<Walker>> walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the episode\n\tstd::shared_ptr<EpisodeState> episodeState = episode->GetEpisodeState();\n\n\t// Remove any walkers that no longer exist\n\tstd::vector<std::shared_ptr<Walker>> removedWalkers;\n\tfor (auto walker : walkers) {\n\t\tif (!walker->GetIsAlive()) {\n\t\t\tremovedWalkers.push_back(walker);\n\t\t}\n\t}\n\tfor (auto walker : removedWalkers) {\n\t\twalkers.erase(std::remove(walkers.begin(), walkers.end(), walker), walkers.end());\n\t}\n\n\t// Update the vehicles in the crowd and the crowd itself\n\tstd::vector<std::shared_ptr<Vehicle>> vehicles = episodeState->GetVehicles();\n\tfor (auto vehicle : vehicles) {\n\t\tvehicle->Update();\n\t}\n\tepisodeState->SetVehicles(vehicles);\n\n\t// For each walker, get their transform and speed, then apply these states in a batch to the simulator\n\tfor (auto walker : walkers) {\n\t\tstd::shared_ptr<Transform> walkerTransform = walker->GetTransform();\n\t\tfloat walkerSpeed = walker->GetSpeed();\n\n\t\tstd::vector<float> walkerState = { walkerTransform->GetPosition().x, walkerTransform->GetPosition().y, walkerTransform->GetPosition().z, walkerSpeed };\n\t\tstd::vector<std::vector<float>> walkerStates = { walkerState };\n\t\tstd::vector<std::vector<float>> walkerStatesBatch = { walkerStates };\n\n\t\t// Apply the walker state in a batch to the simulator\n\t\tsimulator->SetWalkerStates(walkerStatesBatch);\n\n\t\t// Check if any walker has been killed\n\t\tif (!walker->GetIsAlive()) {\n\t\t\t// Remove the walker from the crowd and destroy their controller\n\t\t\tstd::shared_ptr<Crowd> crowd = episodeState->GetCrowd();\n\t\t\tcrowd->RemoveWalker(walker);\n\t\t\twalker->DestroyController();\n\t\t}", "CodeBleu_score": 38.107826510707056}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// Load the current walkers\n\tauto walkers = episode->GetWalkers();\n\n\t// If the walkers list is empty, return\n\tif (walkers.size() == 0)\n\t\treturn;\n\n\t// Get the current state of the episode\n\tauto state = episode->GetState();\n\n\t// Remove any walkers that no longer exist\n\tfor (auto walker : walkers) {\n\t\tif (walker->IsDead()) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tauto crowd = episode->GetCrowd();\n\t\t\tcrowd->RemoveWalker(walker);\n\n\t\t\t// Destroy the walker's controller\n\t\t\tauto controller = walker->GetController();\n\t\t\tcontroller->Destroy();\n\n\t\t\t// Remove the walker from the episode\n\t\t\tepisode->RemoveWalker(walker);\n\t\t}\n\t}\n\n\t// Update the vehicles in the crowd and the crowd itself\n\tauto crowd = episode->GetCrowd();\n\tcrowd->Update(state);\n\n\t// For each walker, get their transform and speed, then apply these states in a batch to the simulator\n\tfor (auto walker : walkers) {\n\t\tauto transform = walker->GetTransform();\n\t\tauto speed = walker->GetSpeed();\n\n\t\tauto batch = std::make_shared<Batch>();\n\t\tbatch->Add(walker);\n\t\tbatch->SetTransform(transform);\n\t\tbatch->SetSpeed(speed);\n\n\t\tauto simulator = episode->GetSimulator();\n\t\tsimulator->ApplyBatch(batch);\n\t}\n\n\t// Check if any walker has been killed\n\tfor (auto walker : walkers) {\n\t\tif (walker->IsDead()) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tcrowd->RemoveWalker(walker);\n\n\t\t\t// Destroy the walker's controller\n\t\t\tauto controller = walker->GetController();\n\t\t\tcontroller->Destroy();\n\n\t\t\t// Remove the walker from the episode\n\t\t\tepisode->RemoveWalker(walker);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 39.93442644967706}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription desc;\n\tdesc.set_uid(UID);\n\tdesc.set_id(ID);\n\tfor (auto& attr : Attributes) {\n\t\tdesc.add_attributes()->CopyFrom(attr);\n\t}\n\treturn desc;\n}\n", "CodeBleu_score": 43.1266573532807}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription desc;\n\tdesc.set_uid(GetUID());\n\tdesc.set_id(GetID());\n\tfor (auto& attr : attributes) {\n\t\tdesc.add_attributes(attr.second);\n\t}\n\treturn desc;\n}\n", "CodeBleu_score": 42.25920929429605}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.set_uid(UID);\n\tdescription.set_id(ID);\n\n\tfor (auto& attribute : Attributes) {\n\t\trpc::Attribute* attribute_rpc = description.add_attributes();\n\t\tattribute_rpc->set_name(attribute.Name);\n\t\tattribute_rpc->set_value(attribute.Value);\n\t}\n\n\treturn description;\n}\n", "CodeBleu_score": 52.10730688855133}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto& blueprint : blueprints) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tif (blueprint->GetAttribute(name) == value) {\n\t\t\t\tresult->Add(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 29.783247240297563}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\t// Create new BlueprintLibrary\n\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n\t// Iterate through blueprints\n\tfor (auto blueprint : blueprints) {\n\t\t// Check if attribute exists\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\t// Check if attribute value matches\n\t\t\tif (blueprint->GetAttribute(name).AsString() == value) {\n\t\t\t\tresult->AddBlueprint(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 31.60401997075078}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\tfor (auto& blueprint : blueprints) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tif (blueprint->GetAttribute(name) == value) {\n\t\t\t\tresult->blueprints.push_back(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 32.571376262883696}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullPath = GetFilePath(path);\n\n\tif (fullPath.empty()) {\n\t\treturn false;\n\t}\n\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::out | std::ios::trunc);\n\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\tfile.close();\n\n\treturn true;\n}\n", "CodeBleu_score": 41.5579662800495}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\t// Construct the full file path using the base folder and version information.\n\tstd::string fullPath = baseFolder + \"/\" + version + \"/\" + path;\n\n\t// Validate the file path.\n\tif (!ValidatePath(fullPath)) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents.\n\tstd::ofstream file(fullPath, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\t// Write the content to the file.\n\tfile.write((char*)content.data(), content.size());\n\n\t// Close the file.\n\tfile.close();\n\n\treturn true;\n}\n", "CodeBleu_score": 40.286981475539896}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullPath = baseFolder + \"/\" + path;\n\tif (ValidatePath(fullPath)) {\n\t\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\t\tif (file.is_open()) {\n\t\t\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 43.113302147493584}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\t// Calculate the location of the bounding box by adding the parent's bounding box location to the transform's location.\n\tconst auto location = parent_bounding_box_.location + transform.location;\n\n\t// Compute the four corners of the bounding box by rotating the extents based on the yaw angle.\n\tconst auto yaw_angle = transform.rotation.yaw();\n\tconst auto x_extent = parent_bounding_box_.extent.x() * std::cos(yaw_angle) - parent_bounding_box_.extent.y() * std::sin(yaw_angle);\n\tconst auto y_extent = parent_bounding_box_.extent.x() * std::sin(yaw_angle) + parent_bounding_box_.extent.y() * std::cos(yaw_angle);\n\n\t// Create a Bounds object containing the frame number and the calculated corners.\n\treturn std::make_shared<Bounds>(frame, location, x_extent, y_extent);\n}\n", "CodeBleu_score": 44.077941410656614}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\t// Get the parent's bounding box\n\tconst auto parentBounds = parent->GetBounds();\n\n\t// Get the parent's bounding box location\n\tconst auto parentLocation = parentBounds->GetLocation();\n\n\t// Calculate the location by adding the parent's bounding box location to the transform's location\n\tconst auto location = parentLocation + transform.GetLocation();\n\n\t// Compute the four corners of the bounding box by rotating the extents based on the yaw angle\n\tconst auto yaw = transform.GetYaw();\n\tconst auto extent = parentBounds->GetExtent();\n\tconst auto corner1 = location + geom::Vector(extent.GetX(), extent.GetY(), extent.GetZ());\n\tconst auto corner2 = location + geom::Vector(-extent.GetX(), extent.GetY(), extent.GetZ());\n\tconst auto corner3 = location + geom::Vector(-extent.GetX(), -extent.GetY(), extent.GetZ());\n\tconst auto corner4 = location + geom::Vector(extent.GetX(), -extent.GetY(), extent.GetZ());\n\n\t// Return a shared pointer to a Bounds object containing the frame number and the calculated corners\n\treturn std::make_shared<Bounds>(frame, corner1, corner2, corner3, corner4);\n}\n", "CodeBleu_score": 40.10710443603923}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\t// Get the parent's bounds.\n\tauto parentBounds = parent->GetBounds();\n\tif (!parentBounds) {\n\t\tthrow std::runtime_error(\"The parent does not have a bounds.\");\n\t}\n\n\t// Calculate the location by adding the parent's bounding box location to the transform's location.\n\tauto location = transform.Location() + parentBounds->Location();\n\n\t// Compute the four corners of the bounding box by rotating the extents based on the yaw angle.\n\tauto yaw = transform.Yaw();\n\tauto extents = parentBounds->Extents();\n\tauto corners = std::array<Vector3, 4>{{\n\t\tlocation + Vector3(-extents.x, -extents.y, -extents.z),\n\t\tlocation + Vector3(-extents.x, -extents.y, extents.z),\n\t\tlocation + Vector3(-extents.x, extents.y, -extents.z),\n\t\tlocation + Vector3(-extents.x, extents.y, extents.z)\n\t}};\n\n\t// Rotate the corners by the yaw angle.\n\tfor (auto &corner : corners) {\n\t\tcorner = Vector3::Rotate(corner, yaw);\n\t}\n\n\t// Return a shared pointer to a Bounds object containing the frame number and the calculated corners.\n\treturn std::make_shared<const Bounds>(frame, corners);\n}\n", "CodeBleu_score": 37.812640171349436}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()\t// Lock the mutex\n\tpthread_mutex_lock(&mutex);\n\n\t// Create a new LightState object to store the light states from the server\n\tLightState* lightState = new LightState();\n\n\t// Send a request to the server to get the light states\n\tif (!lightState->GetLightStatesFromServer()) {\n\t\t// If the request fails, print an error message and exit\n\t\tstd::cerr << \"Error: Failed to get light states from server.\" << std::endl;\n\t\texit(1);\n\t}\n\n\t// Unlock the mutex\n\tpthread_mutex_unlock(&mutex);\n\n\t// Update the local light states with the server's light states\n\tUpdateLightStates(lightState);\n\n\t// Delete the LightState object\n\tdelete lightState;\n}\n", "CodeBleu_score": 16.175816441605633}, {"code": "void LightManager::QueryLightsStateToServer()\tstd::lock_guard<std::mutex> lock(this->_mutex);\n\n\t// Retrieve the light states from the server.\n\tstd::vector<LightState> lightStates = this->_server->QueryLightsState();\n\n\t// Update the local light states.\n\tfor (LightState lightState : lightStates) {\n\t\tthis->_lights[lightState.id] = lightState;\n\t}\n\n\t// Create new light objects if they do not already exist in the _lights map.\n\tfor (LightState lightState : lightStates) {\n\t\tif (this->_lights.find(lightState.id) == this->_lights.end()) {\n\t\t\tthis->_lights[lightState.id] = lightState;\n\t\t\tthis->_lights[lightState.id].CreateLight();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 25.52325949300474}, {"code": "void LightManager::QueryLightsStateToServer()\tstd::lock_guard<std::mutex> lock(_mutex);\n\tstd::string request = \"lights\";\n\tstd::string response = _socket->SendAndReceive(request);\n\tif (response.empty()) {\n\t\tstd::cout << \"ERROR: Could not query lights state from server\" << std::endl;\n\t\treturn;\n\t}\n\t_lights.clear();\n\tstd::vector<std::string> lines = Utils::Split(response, '\\n');\n\tfor (std::string line : lines) {\n\t\tstd::vector<std::string> parts = Utils::Split(line,'');\n\t\tif (parts.size()!= 4) {\n\t\t\tstd::cout << \"ERROR: Could not parse light state from server\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\t\tstd::string id = parts[0];\n\t\tstd::string name = parts[1];\n\t\tstd::string state = parts[2];\n\t\tbool on = state == \"ON\";\n\t\tstd::string color = parts[3];\n\t\tColor colorObj = Color::FromString(color);\n\t\tLight* light = new Light(id, name, on, colorObj);\n\t\t_lights[id] = light;\n\t}\n}\n", "CodeBleu_score": 32.764037983805714}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (dirty_) {\n\t\tstd::string message = \"\";\n\t\tfor (int i = 0; i < lights_.size(); i++) {\n\t\t\tmessage += lights_[i]->GetServerMessage();\n\t\t}\n\t\tif (message!= \"\") {\n\t\t\tif (discard_client) {\n\t\t\t\tmessage = \"L\" + message;\n\t\t\t} else {\n\t\t\t\tmessage = \"l\" + message;\n\t\t\t}\n\t\t\t// send to server\n\t\t\tserver_->SendMessage(message);\n\t\t}\n\t\tdirty_ = false;\n\t\tchanges_.clear();\n\t}\n}\n", "CodeBleu_score": 29.282793024032294}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tif (dirty) {\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\t\tif (dirty) {\n\t\t\tif (discard_client) {\n\t\t\t\tfor (auto &light : lights) {\n\t\t\t\t\tlight.second->UpdateServerState();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (auto &light : lights) {\n\t\t\t\t\tlight.second->UpdateClientState();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdirty = false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.52926888454803}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Check if there are changes to be sent\n\tif (dirty) {\n\t\t// Create a message containing the updated light states\n\t\tstd::string message = \"lights\";\n\t\tfor (int i = 0; i < lights.size(); i++) {\n\t\t\tmessage += lights[i].Serialize();\n\t\t}\n\t\t// Send the message to the server\n\t\tserver->Send(message);\n\t\t// Clear the changes and reset the dirty flag\n\t\tchanges.clear();\n\t\tdirty = false;\n\t}\n\t// Discard the client if requested\n\tif (discard_client) {\n\t\t// Discard the client\n\t\tserver->DiscardClient();\n\t}\n}\n", "CodeBleu_score": 31.955610878909557}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)\tif (id!= \"sensor.other.v2x_custom\") {\n\t\tLOG(WARNING) << \"Sensor \" << id << \" is not of type sensor.other.v2x_custom. Cannot send message.\";\n\t\treturn;\n\t}\n\tLOG(DEBUG) << \"Sending message \" << message << \" to episode \" << context->GetEpisode()->GetId();\n\tcontext->GetEpisode()->Send(message);\n}\n", "CodeBleu_score": 46.00895220321478}, {"code": "void ServerSideSensor::Send(std::string message)\tif (this->sensorID!= \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"Warning: Attempted to send message to sensor of type \" << this->sensorID << \" from episode \" << this->episodeID << \" but this sensor is not of type sensor.other.v2x_custom\" << std::endl;\n\t\treturn;\n\t}\n\tthis->context->Send(message);\n}\n", "CodeBleu_score": 42.58619150528244}, {"code": "void ServerSideSensor::Send(std::string message)\tif (this->sensor_id!= \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"WARNING: Sensor ID is not'sensor.other.v2x_custom'.\" << std::endl;\n\t\treturn;\n\t}\n\n\tstd::cout << \"DEBUG: ServerSideSensor::Send() called.\" << std::endl;\n\n\tthis->context.Send(message);\n}\n", "CodeBleu_score": 41.39975183858227}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\t// Register the vehicle with the traffic manager\n\t\ttm_register_vehicle(tm_port, this);\n\t} else {\n\t\t// Unregister the vehicle from the traffic manager\n\t\ttm_unregister_vehicle(tm_port, this);\n\t}\n}\n", "CodeBleu_score": 34.56325360895362}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\tif (tm_port == 0) {\n\t\t\t// No port specified, use default\n\t\t\ttm_port = 10000;\n\t\t}\n\t\t// Register vehicle with traffic manager\n\t\tif (tm_port!= 0) {\n\t\t\tstd::cout << \"Registering vehicle with traffic manager on port \" << tm_port << std::endl;\n\t\t\tif (tm_port == 10000) {\n\t\t\t\t// Use default port\n\t\t\t\ttm_port = 10000;\n\t\t\t}\n\t\t\t// Register vehicle with traffic manager\n\t\t\tif (tm_port!= 0) {\n\t\t\t\tif (tm_port == 10000) {\n\t\t\t\t\t// Use default port\n\t\t\t\t\ttm_port = 10000;\n\t\t\t\t}\n\t\t\t\t// Register vehicle with traffic manager\n\t\t\t\tif (tm_port!= 0) {\n\t\t\t\t\tif (tm_port == 10000) {\n\t\t\t\t\t\t// Use default port\n\t\t\t\t\t\ttm_port = 10000;\n\t\t\t\t\t}\n\t\t\t\t\t// Register vehicle with traffic manager\n\t\t\t\t\tif (tm_port!= 0) {\n\t\t\t\t\t\tif (tm_port == 10000) {\n\t\t\t\t\t\t\t// Use default port\n\t\t\t\t\t\t\ttm_port = 10000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Register vehicle with traffic manager\n\t\t\t\t\t\tif (tm_port!= 0) {\n\t\t\t\t\t\t\tif (tm_port == 10000) {\n\t\t\t\t\t\t\t\t// Use default port\n\t\t\t\t\t\t\t\ttm_port = 10000;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Register vehicle with traffic manager\n\t\t\t\t\t\t\tif (tm_port!= 0) {\n\t\t\t\t\t\t\t\tif (tm_port == 10000) {\n\t\t\t\t\t\t\t\t\t// Use default port\n\t\t\t\t\t\t\t\t\ttm_port = 10000;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Register vehicle with traffic manager\n\t\t\t\t\t\t\t\tif (tm_port!= 0) {\n\t\t\t\t\t\t\t\t\tif (tm_port == 10000) {\n\t\t\t\t\t\t\t\t\t\t// Use default port\n\t\t\t\t\t\t\t\t\t\ttm_port = 10000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Register vehicle with traffic manager\n\t\t\t\t\t\t\t\t\tif (tm_port!= 0) {\n\t\t\t\t\t\t\t\t\t\tif (tm_port == 10000) {\n\t\t\t\t\t\t\t\t\t\t\t", "CodeBleu_score": 15.26295005350404}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\tif (tm_port == 0) {\n\t\t\ttm_port = 2000;\n\t\t}\n\t\t// Register the vehicle with the traffic manager\n\t\tif (tm_port!= 0) {\n\t\t\t// Set the vehicle's port number\n\t\t\tvehicle_port = tm_port;\n\t\t\t// Register the vehicle with the traffic manager\n\t\t\tRegisterVehicle();\n\t\t}\n\t} else {\n\t\t// Unregister the vehicle from the traffic manager\n\t\tif (tm_port!= 0) {\n\t\t\t// Set the vehicle's port number\n\t\t\tvehicle_port = tm_port;\n\t\t\t// Unregister the vehicle from the traffic manager\n\t\t\tUnregisterVehicle();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.411246308360106}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::Start()\"));\n\tSuper::Start();\n\n\t// Retrieve the walker actor from the episode\n\tWalkerActor = Cast<AWalkerActor>(Episode->GetWalkerActor());\n\tif (WalkerActor) {\n\t\t// Add walker actor to navigation system\n\t\tUNavigationSystemV1::RegisterActorWithNavigationSystem(WalkerActor);\n\n\t\t// Disable physics simulation and collisions for walker actor\n\t\tWalkerActor->SetActorEnableCollision(false);\n\t\tWalkerActor->SetActorTickEnabled(false);\n\t}\n}\n", "CodeBleu_score": 28.885665339804934}, {"code": "void WalkerAIController::Start()\tSuper::Start();\n\n\tif (WalkerActor) {\n\t\t//Add the walker to the navigation system\n\t\tUNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(this);\n\t\tif (NavSys) {\n\t\t\tNavSys->AddActorToNavigation(WalkerActor);\n\t\t}\n\n\t\t//Disable physics and collisions for the walker\n\t\tWalkerActor->SetActorEnableCollision(false);\n\t\tWalkerActor->SetActorTickEnabled(false);\n\t}\n}\n", "CodeBleu_score": 30.071485704294897}, {"code": "void WalkerAIController::Start()\tSuper::Start();\n\t// Retrieve the walker actor from the episode.\n\tWalkerActor* walkerActor = Cast<WalkerActor>(GetPawn());\n\tif (walkerActor) {\n\t\t// Add the walker actor to the navigation system.\n\t\tUNavigationSystemV1* navSystem = UNavigationSystemV1::GetCurrent(this);\n\t\tFNavLocation walkerLocation;\n\t\twalkerActor->GetActorLocation().ToNavLocation(walkerLocation);\n\t\tnavSystem->AddActorToNavigation(walkerActor, walkerLocation);\n\t\t// Disable the physics simulation and collisions for the walker actor.\n\t\twalkerActor->SetSimulatePhysics(false);\n\t\twalkerActor->SetActorEnableCollision(false);\n\t}\n}\n", "CodeBleu_score": 37.87286589558872}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\t// Get the navigation instance from the current episode\n\tauto navigation_instance = GetEpisode()->GetNavigationInstance();\n\n\t// Check if the navigation instance is valid\n\tif (navigation_instance.IsValid()) {\n\t\t// Get the parent walker from the navigation instance\n\t\tauto walker = navigation_instance->GetParentWalker();\n\n\t\t// Check if the walker is valid\n\t\tif (walker.IsValid()) {\n\t\t\t// Attempt to set the maximum speed of the walker\n\t\t\tif (!walker->SetMaxSpeed(max_speed)) {\n\t\t\t\t// Log an error message if the speed could not be set\n\t\t\t\tLOG_ERROR(\"Failed to set the maximum speed of the walker!\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Log an error message if the walker could not be found\n\t\t\tLOG_ERROR(\"Failed to find the walker!\");\n\t\t}\n\t}\n\telse {\n\t\t// Log an error message if the navigation instance could not be found\n\t\tLOG_ERROR(\"Failed to find the navigation instance!\");\n\t}\n}\n", "CodeBleu_score": 51.12131722333017}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\t// Retrieve the navigation instance from the current episode.\n\tUAIPerceptionComponent* navigation_component = GetEpisode()->GetNavigationComponent();\n\tif (navigation_component == nullptr) {\n\t\tUE_LOG(LogAI, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation component not found in current episode.\"));\n\t\treturn;\n\t}\n\n\t// Retrieve the parent walker.\n\tAWalker* walker = Cast<AWalker>(GetPawn());\n\tif (walker == nullptr) {\n\t\tUE_LOG(LogAI, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Walker not found.\"));\n\t\treturn;\n\t}\n\n\t// Attempt to set the maximum speed.\n\tif (!navigation_component->SetMaxSpeed(walker, max_speed)) {\n\t\tUE_LOG(LogAI, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set max speed for walker %s.\"), *walker->GetName());\n\t}\n}\n", "CodeBleu_score": 46.967363312633296}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tif (auto navigation = GetEpisode()->GetNavigation()) {\n\t\tif (auto walker = GetWalker()) {\n\t\t\tif (walker->SetMaxSpeed(navigation, max_speed)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tUE_LOG(LogWalkerAI, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set maximum speed for walker '%s'.\"), *GetNameSafe(this));\n}\n", "CodeBleu_score": 43.06251756961734}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\treturn map_->GetPrevious(this, distance);\n}\n", "CodeBleu_score": 18.243646007240077}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<Waypoint> previous = this->map->GetPrevious(this->id, distance);\n\tfor (auto& waypoint : previous) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 50.511068243805504}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> previous = this->parent_map->GetPrevious(this, distance);\n\tfor (auto it = previous.begin(); it!= previous.end(); ++it) {\n\t\tresult.push_back(SharedPtr<Waypoint>(*it));\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 53.603961274000646}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Landmark>> landmarks;\n\tauto signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tauto landmark = signal->GetLandmark();\n\t\tif (landmark) {\n\t\t\tlandmarks.push_back(landmark);\n\t\t}\n\t}\n\treturn landmarks;\n}\n", "CodeBleu_score": 31.647376469754796}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tif (signal->GetSignalType() == SignalType::Intersection) {\n\t\t\tfor (auto landmark : signal->GetLandmarks()) {\n\t\t\t\tif (landmark->GetLandmarkType() == LandmarkType::Road) {\n\t\t\t\t\tresult.push_back(landmark);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult.push_back(signal->GetLandmarks()[0]);\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 39.00167768120895}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Landmark>> result;\n\n\t// Get all signals within the specified distance\n\tauto signals = GetSignalsInDistance(distance);\n\n\t// Iterate over the signals\n\tfor (auto signal : signals) {\n\t\t// Get the signal's landmark\n\t\tauto landmark = signal->GetLandmark();\n\n\t\t// Check if the landmark has already been added to the result\n\t\tif (std::find(result.begin(), result.end(), landmark) == result.end()) {\n\t\t\t// Add the landmark to the result\n\t\t\tresult.push_back(landmark);\n\t\t}\n\t}\n\n\t// Return the result\n\treturn result;\n}\n", "CodeBleu_score": 32.8548207169336}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\tif (settings.has_fixed_delta_time()) {\n\t\t// Verify the delta time accuracy\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tauto delta_time = GetDeltaTime();\n\t\t\tif (delta_time == settings.fixed_delta_time()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == 9) {\n\t\t\t\tLOG_WARNING(\"Unable to verify the fixed delta time setting of \" << settings.fixed_delta_time() << \"s. The setting may not have been applied correctly.\");\n\t\t\t}\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t}\n\t}\n\n\t// Set the timeout\n\tif (timeout == time_duration::zero()) {\n\t\ttimeout = settings.networking_timeout();\n\t}\n\ttimeout += std::chrono::seconds(1);\n\n\t// Apply the settings\n\tstd::unique_lock<std::mutex> lock(m_mutex);\n\tm_settings = settings;\n\tm_timeout = std::chrono::steady_clock::now() + timeout;\n\n\t// Return the identifier\n\treturn m_settings.episode_id();\n}\n", "CodeBleu_score": 32.16118598639154}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\tif (settings.has_timeout()) {\n\t\ttimeout = settings.timeout();\n\t}\n\n\t// Set the timeout\n\tif (timeout > 0) {\n\t\tm_timeout = timeout;\n\t}\n\n\t// Set the fixed delta time\n\tif (settings.has_fixeddeltatime()) {\n\t\tm_fixedDeltaTime = settings.fixeddeltatime();\n\t}\n\n\t// Apply the settings\n\tm_settings = settings;\n\n\t// Verify the settings\n\tif (m_fixedDeltaTime > 0) {\n\t\tconst auto ticks = 100;\n\t\tconst auto startTime = std::chrono::steady_clock::now();\n\t\tfor (auto i = 0; i < ticks; ++i) {\n\t\t\tif (!m_fixedDeltaTime.apply(this)) {\n\t\t\t\tLOG_WARNING(\"Unable to apply fixed delta time: {}\", m_fixedDeltaTime.toString());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_fixedDeltaTime.tick();\n\t\t}\n\t\tconst auto endTime = std::chrono::steady_clock::now();\n\t\tconst auto deltaTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);\n\t\tconst auto averageDeltaTime = deltaTime / ticks;\n\t\tconst auto minDeltaTime = std::chrono::milliseconds(1000) / m_settings.maxfps();\n\t\tconst auto maxDeltaTime = std::chrono::milliseconds(1000) / m_settings.minfps();\n\t\tif (averageDeltaTime > maxDeltaTime || averageDeltaTime < minDeltaTime) {\n\t\t\tLOG_WARNING(\"Fixed delta time is not accurate: {} (min: {}, max: {})\", averageDeltaTime.count(), minDeltaTime.count(), maxDeltaTime.count());\n\t\t}\n\t}\n\n\t// Return the identifier\n\treturn m_settings.id();\n}\n", "CodeBleu_score": 45.11015809725679}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\tif (settings.has_fixed_delta_time()) {\n\t\tif (settings.fixed_delta_time() > 0.0f) {\n\t\t\tfloat error = 0.0f;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfloat dt = settings.fixed_delta_time();\n\t\t\t\tfloat dt_error = dt - (float)m_world->GetDeltaTime();\n\t\t\t\terror += dt_error * dt_error;\n\t\t\t\tm_world->SetDeltaTime(dt);\n\t\t\t\tm_world->Update(dt);\n\t\t\t}\n\t\t\tfloat mean_error = error / 10.0f;\n\t\t\tfloat stddev_error = std::sqrt(mean_error);\n\t\t\tif (stddev_error > 0.001f) {\n\t\t\t\tLOG_WARNING(\"Fixed delta time of \" << settings.fixed_delta_time() << \" does not match the actual delta time of \" << m_world->GetDeltaTime() << \" by \" << stddev_error << \" seconds.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (settings.has_timeout()) {\n\t\ttimeout = std::min(timeout, settings.timeout());\n\t}\n\n\treturn m_world->ApplySettings(settings, timeout);\n}\n", "CodeBleu_score": 40.87829954285937}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tstatic auto _ = RegisterFunction(\"Math::DistanceSegmentToPoint\", {\n\t\tRegisterParameter(\"point\", &Math::DistanceSegmentToPoint::point),\n\t\tRegisterParameter(\"segment\", &Math::DistanceSegmentToPoint::segment),\n\t}, {\n\t\tRegisterReturn(\"distance\", &Math::DistanceSegmentToPoint::distance),\n\t\tRegisterReturn(\"projection\", &Math::DistanceSegmentToPoint::projection),\n\t});\n\n\treturn std::make_pair(distance, projection);\n}\n", "CodeBleu_score": 19.833537725985224}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\t[](const float& x1, const float& y1, const float& x2, const float& y2, const float& x3, const float& y3) -> std::pair<float, float> {\n\t\tconst float a = x2 - x1;\n\t\tconst float b = y2 - y1;\n\t\tconst float c = x3 - x1;\n\t\tconst float d = y3 - y1;\n\t\tconst float dot = a * c + b * d;\n\t\tconst float len_sq = a * a + b * b;\n\t\tconst float param = dot / len_sq;\n\t\tconst float xx = x1 + param * a;\n\t\tconst float yy = y1 + param * b;\n\t\tconst float dist_sq = (xx - x3) * (xx - x3) + (yy - y3) * (yy - y3);\n\t\tif (len_sq < 1e-6) {\n\t\t\treturn { dist_sq, std::abs(x3 - xx) };\n\t\t}\n\t\tconst float clamped = std::max(0.0f, std::min(1.0f, param));\n\t\tconst float dist = std::sqrt(dist_sq);\n\t\tconst float dist_to_projection = std::sqrt(clamped * clamped * len_sq - dot * dot);\n\t\treturn { dist, dist_to_projection };\n\t}\n};\n", "CodeBleu_score": 38.23133445032848}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tstatic_cast<float>(std::sqrt(Math::DistanceSegmentToPoint(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f))),\n\tstatic_cast<float>(std::sqrt(Math::DistanceSegmentToPoint(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f)))\n};\n", "CodeBleu_score": 10.748166169207602}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tindex_type initial_index = m_vertices.size();\n\tfor (index_type i = 0; i < vertices.size(); ++i) {\n\t\tm_vertices.push_back(vertices[i]);\n\t}\n\tfor (index_type i = 0; i < vertices.size() - 2; ++i) {\n\t\tm_indices.push_back(initial_index);\n\t\tm_indices.push_back(initial_index + i + 1);\n\t\tm_indices.push_back(initial_index + i + 2);\n\t}\n}\n", "CodeBleu_score": 45.79172425037752}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tunsigned int index = vertices.size();\n\tfor (unsigned int i = 0; i < vertices.size() - 2; i++) {\n\t\tindices.push_back(index);\n\t\tindices.push_back(index + i + 1);\n\t\tindices.push_back(index + i + 2);\n\t}\n}\n", "CodeBleu_score": 39.60688777491734}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tindex_type initial_index = num_vertices;\n\tfor (size_t i = 0; i < vertices.size() - 2; i++) {\n\t\tAddTriangle(vertices[0], vertices[i + 1], vertices[i + 2]);\n\t}\n\tindex_type final_index = num_vertices;\n\tfor (size_t i = 0; i < vertices.size(); i++) {\n\t\tindices.push_back(initial_index);\n\t\tindices.push_back(i + 1);\n\t\tindices.push_back(final_index);\n\t}\n}\n", "CodeBleu_score": 45.230014203198444}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (!message) {\n\t\tthrow std::runtime_error(\"Message is null\");\n\t}\n\tif (!message->IsValid()) {\n\t\tthrow std::runtime_error(\"Message is not valid\");\n\t}\n\tstrand.post([this, message] {\n\t\tif (socket.is_open()) {\n\t\t\tsocket.set_option(boost::asio::ip::tcp::no_delay(true));\n\t\t\tsocket.expires_from_now(boost::posix_time::seconds(timeout));\n\t\t\tboost::asio::async_write(socket, boost::asio::buffer(message->Data(), message->Size()),\n\t\t\t\t[this, message](const boost::system::error_code& error, std::size_t) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tstd::cout << \"Write error: \" << error.message() << std::endl;\n\t\t\t\t\t\tif (error == boost::asio::error::eof) {\n\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandle_sent(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t} else {\n\t\t\tstd::cout << \"Write error: socket is closed\" << std::endl;\n\t\t}\n\t});\n}\n", "CodeBleu_score": 36.73698566346528}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (message) {\n\t\tif (message->IsValid()) {\n\t\t\tauto strand = std::make_shared<asio::strand<asio::io_context::executor_type>>(io_context_);\n\t\t\tstrand->post([this, message, strand]() {\n\t\t\t\tif (socket_.is_open()) {\n\t\t\t\t\tauto timeout = std::chrono::seconds(10);\n\t\t\t\t\tsocket_.expires_after(timeout);\n\t\t\t\t\tasio::async_write(socket_, asio::buffer(message->Data(), message->Size()), strand->wrap(\n\t\t\t\t\t\t[this, strand, message](const asio::error_code& error, std::size_t bytes_transferred) {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\tstd::cerr << \"Error while writing message: \" << error.message() << std::endl;\n\t\t\t\t\t\t\t\tsocket_.close();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstd::cout << \"Message written: \" << bytes_transferred << \" bytes\" << std::endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstrand->post([this, strand]() {\n\t\t\t\t\t\t\t\thandle_sent(strand);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t));\n\t\t\t\t} else {\n\t\t\t\t\tstd::cerr << \"Socket is not open\" << std::endl;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tstd::cerr << \"Message is invalid\" << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cerr << \"Message is null\" << std::endl;\n\t}\n}\n", "CodeBleu_score": 38.74390446068023}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (!message ||!message->IsValid()) {\n\t\treturn;\n\t}\n\tauto strand = _strand.get();\n\tstrand->post([this, message] {\n\t\tif (_socket.is_open()) {\n\t\t\t_socket.set_option(boost::asio::ip::tcp::no_delay(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::receive_buffer_size(4096));\n\t\t\t_socket.set_option(boost::asio::socket_base::send_buffer_size(4096));\n\t\t\t_socket.set_option(boost::asio::socket_base::linger(true, 0));\n\t\t\t_socket.set_option(boost::asio::socket_base::keep_alive(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::reuse_address(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::keep_alive_time(std::chrono::seconds(10)));\n\t\t\t_socket.set_option(boost::asio::socket_base::keep_alive_interval(std::chrono::seconds(10)));\n\t\t\t_socket.set_option(boost::asio::socket_base::enable_connection_aborted(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::enable_continuation(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::enable_broadcast(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::enable_multicast(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::keep_alive_time(std::chrono::seconds(10)));\n\t\t\t_socket.set_option(boost::asio::socket_base::keep_alive_interval(std::chrono::seconds(10)));\n\t\t\t_socket.set_option(boost::asio::socket_base::enable_connection_aborted(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::enable_continuation(true));\n\t\t\t_socket.set_option(boost::asio::socket_base::enable_broadcast(true));\n\t\t\t_socket.set_option(boost::asio::", "CodeBleu_score": 32.73034379029765}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (ec) {\n\t\tLOG_ERROR(\"Failed to close connection: \" << ec.message());\n\t} else {\n\t\tLOG_INFO(\"Closing connection...\");\n\t}\n\tDeadlineTimer::Cancel();\n\tif (socket_.is_open()) {\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\tsocket_.close();\n\t}\n\tOnClosed(ec);\n}\n", "CodeBleu_score": 44.179178997450386}, {"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (ec) {\n\t\tLOG_ERROR << \"Error closing socket: \" << ec.message();\n\t}\n\tif (socket_.is_open()) {\n\t\tboost::system::error_code ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\tsocket_.close(ec);\n\t\tif (ec) {\n\t\t\tLOG_ERROR << \"Error closing socket: \" << ec.message();\n\t\t}\n\t}\n\tif (on_closed_) {\n\t\ton_closed_(ec);\n\t}\n\tLOG_INFO << \"Session closed\";\n}\n", "CodeBleu_score": 47.00676133474989}, {"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (ec) {\n\t\tLOG_ERROR(ec.message());\n\t}\n\n\tif (m_socket.is_open()) {\n\t\tm_deadline.cancel();\n\t\tm_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\tm_socket.close();\n\t}\n\n\tif (m_on_closed) {\n\t\tm_on_closed(this, ec);\n\t}\n\n\tLOG_INFO(\"Session closed\");\n}\n", "CodeBleu_score": 53.20937608608492}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()\tchar buffer[100];\n\tsprintf(buffer, \"Are you alive?\");\n\tlog_info(primary_logger, \"Sending: %s\", buffer);\n\twrite(next_router_socket, buffer, strlen(buffer) + 1);\n\tchar response[100];\n\tread(next_router_socket, response, 100);\n\tlog_info(primary_logger, \"Received: %s\", response);\n}\n", "CodeBleu_score": 38.91654495502206}, {"code": "void PrimaryCommands::SendIsAlive()\t// Create buffer\n\tchar *buffer = new char[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\t// Log sending\n\tstd::cout << \"Sending: \" << buffer << std::endl;\n\t// Write to next router\n\tthis->nextRouter->Write(buffer, YOU_ALIVE);\n\t// Wait for response\n\tthis->WaitForResponse();\n}\n", "CodeBleu_score": 18.23575906701963}, {"code": "void PrimaryCommands::SendIsAlive()\tchar buffer[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\tlog_info(logger, \"Sending message: %s\", buffer);\n\twrite(nextRouter, buffer, sizeof(buffer));\n\tchar response[100];\n\tread(nextRouter, response, sizeof(response));\n\tlog_info(logger, \"Received message: %s\", response);\n}\n", "CodeBleu_score": 38.656857899755984}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router.\n\tuint8_t buffer[2];\n\tbuffer[0] = ENABLE_ROS;\n\tbuffer[1] = sensor_id;\n\trouter->Send(buffer, 2);\n\n\t// Wait for and process the server's response.\n\trouter->WaitForResponse();\n\tif (router->GetLastResponse() == ENABLE_ROS) {\n\t\t// Sensor found.\n\t\t// Log the sensor ID and the server's response.\n\t\tROS_INFO(\"Sensor %d enabled on server %d.\", sensor_id, router->GetLastServer());\n\t} else {\n\t\t// Sensor not found.\n\t\t// Log an error message.\n\t\tROS_ERROR(\"Sensor %d not found on server %d.\", sensor_id, router->GetLastServer());\n\t}\n}\n", "CodeBleu_score": 36.41193296750702}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\tstd::vector<std::string> secondary_servers;\n\tstd::vector<std::string> secondary_server_ips;\n\tstd::vector<std::string> secondary_server_ports;\n\tstd::vector<std::string> secondary_server_names;\n\tstd::vector<std::string> secondary_server_types;\n\tstd::vector<std::string> secondary_server_types_names;\n\tstd::vector<std::string> secondary_server_types_ids;\n\tstd::vector<std::string> secondary_server_types_ids_names;\n\tstd::vector<std::string> secondary_server_types_ids_names_ids;\n\n\t// Get the secondary servers\n\tfor (auto it = secondary_servers_list.begin(); it!= secondary_servers_list.end(); it++) {\n\t\tsecondary_servers.push_back(it->first);\n\t\tsecondary_server_ips.push_back(it->second.ip);\n\t\tsecondary_server_ports.push_back(it->second.port);\n\t\tsecondary_server_names.push_back(it->second.name);\n\t\tsecondary_server_types.push_back(it->second.type);\n\t\tsecondary_server_types_names.push_back(it->second.type_name);\n\t\tsecondary_server_types_ids.push_back(it->second.type_id);\n\t\tsecondary_server_types_ids_names.push_back(it->second.type_id_name);\n\t\tsecondary_server_types_ids_names_ids.push_back(it->second.type_id_name_id);\n\t}\n\n\t// Check if the sensor is on any of the secondary servers\n\tbool sensor_found = false;\n\tfor (int i = 0; i < secondary_servers.size(); i++) {\n\t\tstd::string secondary_server = secondary_servers[i];\n\t\tstd::string secondary_server_ip = secondary_server_ips[i];\n\t\tstd::string secondary_server_port = secondary_server_ports[i];\n\t\tstd::string secondary_server_name = secondary_server_names[i];\n\t\tstd::string secondary_server_type = secondary_server_types[", "CodeBleu_score": 36.79190168446971}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Create a buffer with the sensor ID\n\tchar buffer[100];\n\tsprintf(buffer, \"%d\", sensor_id);\n\n\t// Send an ENABLE_ROS command to the server using the router\n\tSendCommand(buffer, ENABLE_ROS, 1);\n\n\t// Wait for and process the server's response\n\tWaitForResponse();\n\tProcessResponse();\n}\n", "CodeBleu_score": 14.811584157381375}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\ttoken_type token;\n\tbool sensor_is_activated = false;\n\tstring sensor_name = \"\";\n\tfor (auto const &sensor : sensors) {\n\t\tif (sensor.first == sensor_id) {\n\t\t\tsensor_is_activated = true;\n\t\t\tsensor_name = sensor.second.name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sensor_is_activated) {\n\t\ttoken = sensors[sensor_id].token;\n\t\tlog_info(sensor_name + \" is already activated. Returning existing token.\");\n\t} else {\n\t\tlog_info(sensor_name + \" is not activated. Activating sensor on secondary server.\");\n\t\ttoken = GetTokenFromSecondaryServer(sensor_id);\n\t\tlog_info(\"New token received from secondary server: \" + token);\n\t\tsensors[sensor_id].token = token;\n\t\tsensors[sensor_id].is_activated = true;\n\t\tsensors[sensor_id].name = sensor_name;\n\t\tlog_info(sensor_name + \" is now activated.\");\n\t}\n\treturn token;\n}\n", "CodeBleu_score": 45.30773558419646}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\t// Check if the sensor is already activated\n\tif (sensor_map.find(sensor_id) == sensor_map.end()) {\n\t\t// Sensor is not activated\n\t\t// Enable the sensor on a secondary server\n\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t// Secondary server is not enabled\n\t\t\t// Enable the sensor on a secondary server\n\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t// Secondary server is not enabled\n\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t\t// Secondary server is not enabled\n\t\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t\t\t// Secondary server is not enabled\n\t\t\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t\t\t\t// Secondary server is not enabled\n\t\t\t\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t\t\t\t\t// Secondary server is not enabled\n\t\t\t\t\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\t\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t\t\t\t\t\t// Secondary server is not enabled\n\t\t\t\t\t\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\t\t\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t\t\t\t\t\t\t// Secondary server is not enabled\n\t\t\t\t\t\t\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\t\t\t\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t\t\t\t\t\t\t\t// Secondary server is not enabled\n\t\t\t\t\t\t\t\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\t\t\t\t\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end()) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Secondary server is not enabled\n\t\t\t\t\t\t\t\t\t\t\t\t// Enable the sensor on a secondary server\n\t\t\t\t\t\t\t\t\t\t\t\tif (secondary_server_map.find(sensor_id) == secondary_server_map.end", "CodeBleu_score": 24.700044912913278}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\tif (sensor_id >= sensors.size()) {\n\t\treturn token_type();\n\t}\n\tif (sensors[sensor_id].enabled) {\n\t\treturn sensors[sensor_id].token;\n\t}\n\t// If the sensor is not enabled, enable it on a secondary server\n\tint server_id = rand() % servers.size();\n\ttoken_type token = servers[server_id].EnableSensor(sensor_id);\n\tif (token.empty()) {\n\t\treturn token_type();\n\t}\n\tsensors[sensor_id].token = token;\n\tsensors[sensor_id].enabled = true;\n\tsensors[sensor_id].server_id = server_id;\n\treturn token;\n}\n", "CodeBleu_score": 46.45535947694695}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file;\n\tfile.open(filename, std::ios::in | std::ios::binary);\n\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\tstd::vector<char> fileData;\n\tfileData.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());\n\tfile.close();\n\n\treturn Load(fileData);\n}\n", "CodeBleu_score": 58.66813233694814}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(buffer);\n}\n", "CodeBleu_score": 54.92838558648769}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(content);\n}\n", "CodeBleu_score": 56.3351821785548}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!isReady) {\n\t\treturn false;\n\t}\n\tif (crowd == NULL) {\n\t\treturn false;\n\t}\n\tif (id == NULL) {\n\t\treturn false;\n\t}\n\t// Enter critical section\n\tcrowd->EnterCriticalSection();\n\t// Remove agent from walker\n\tif (walker.find(id)!= walker.end()) {\n\t\twalker.erase(id);\n\t}\n\t// Remove agent from vehicle manager\n\tif (vehicleManager.find(id)!= vehicleManager.end()) {\n\t\tvehicleManager.erase(id);\n\t}\n\t// Remove agent from mappings\n\twalkerMapping.erase(id);\n\tvehicleMapping.erase(id);\n\t// Leave critical section\n\tcrowd->LeaveCriticalSection();\n\treturn true;\n}\n", "CodeBleu_score": 33.27387623571242}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!isReady()) {\n\t\treturn false;\n\t}\n\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\tstd::lock_guard<std::mutex> lock(mutex);\n\tauto walker = crowd->GetWalkerManager();\n\tauto vehicle = crowd->GetVehicleManager();\n\n\tif (walker == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (vehicle == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (walker->RemoveAgent(id)) {\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->RemoveAgent(id);\n\t\twalker->UpdateAgent(id);\n\t\twalker->Remove", "CodeBleu_score": 36.10074965891636}, {"code": "bool Navigation::RemoveAgent(ActorId id)\t// Check if the system is ready\n\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\t// Check if the crowd object is null\n\tif (m_crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Enter critical section\n\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\t// Search for the agent id in the walker and vehicle mappings\n\tauto walkerIt = m_walkerMappings.find(id);\n\tauto vehicleIt = m_vehicleMappings.find(id);\n\n\t// If found, remove the agent from the crowd\n\tif (walkerIt!= m_walkerMappings.end()) {\n\t\tm_crowd->RemoveAgent(walkerIt->second);\n\t\tm_walkerMappings.erase(walkerIt);\n\t}\n\telse if (vehicleIt!= m_vehicleMappings.end()) {\n\t\tm_crowd->RemoveAgent(vehicleIt->second);\n\t\tm_vehicleMappings.erase(vehicleIt);\n\t}\n\telse {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 52.93976222018743}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\t// Get the current list of vehicles\n\tstd::set<int> currentVehicles;\n\tfor (auto& vehicle : vehicles) {\n\t\tcurrentVehicles.insert(vehicle.id);\n\t}\n\n\t// Add or update the vehicles\n\tfor (auto& vehicle : vehicles) {\n\t\t// If the vehicle is not mapped, add it\n\t\tif (vehicle.id >= vehicles_.size()) {\n\t\t\tvehicles_.resize(vehicle.id + 1);\n\t\t}\n\t\tvehicles_[vehicle.id] = vehicle;\n\n\t\t// Mark the vehicle as updated\n\t\tvehicle.updated = true;\n\t}\n\n\t// Remove vehicles that are no longer in the current list\n\tfor (auto& vehicle : vehicles_) {\n\t\tif (!vehicle.updated && vehicle.id >= 0 && currentVehicles.find(vehicle.id) == currentVehicles.end()) {\n\t\t\tvehicles_[vehicle.id] = VehicleCollisionInfo();\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 49.696789136998376}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> current_vehicles;\n\tfor (VehicleCollisionInfo vehicle : vehicles) {\n\t\tcurrent_vehicles.insert(vehicle.id);\n\t}\n\n\tfor (auto& vehicle : vehicles_) {\n\t\tif (current_vehicles.count(vehicle.first) == 0) {\n\t\t\tvehicles_.erase(vehicle.first);\n\t\t} else {\n\t\t\tvehicle.second.updated = true;\n\t\t}\n\t}\n\n\tfor (VehicleCollisionInfo vehicle : vehicles) {\n\t\tif (vehicles_.count(vehicle.id) == 0) {\n\t\t\tvehicles_.insert(std::make_pair(vehicle.id, vehicle));\n\t\t} else {\n\t\t\tvehicles_[vehicle.id].updated = true;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 47.069406938516025}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\t// Create a set of the currently mapped vehicle IDs\n\tstd::set<int> current_vehicle_ids;\n\tfor (const auto& vehicle : vehicles) {\n\t\tcurrent_vehicle_ids.insert(vehicle.id);\n\t}\n\n\t// Add or update vehicles from the provided list, marking them as updated\n\tfor (const auto& vehicle : vehicles) {\n\t\tif (current_vehicle_ids.find(vehicle.id)!= current_vehicle_ids.end()) {\n\t\t\tvehicles_map[vehicle.id].updated = true;\n\t\t} else {\n\t\t\tvehicles_map[vehicle.id] = vehicle;\n\t\t}\n\t}\n\n\t// Remove vehicles not marked as updated, indicating they do not exist in the current frame\n\tfor (const auto& vehicle : vehicles_map) {\n\t\tif (!vehicle.second.updated) {\n\t\t\tvehicles_map.erase(vehicle.first);\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 49.591069149336455}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tif (!id) {\n\t\treturn false;\n\t}\n\n\tauto walker = _walkers.find(id);\n\tauto vehicle = _vehicles.find(id);\n\tif (walker!= _walkers.end() || vehicle!= _vehicles.end()) {\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\tconst auto& location = walker!= _walkers.end()? walker->second.location : vehicle->second.location;\n\t\tconst auto& heading = walker!= _walkers.end()? walker->second.heading : vehicle->second.heading;\n\t\tconst auto& distance_squared = distance * distance;\n\t\tconst auto& heading_squared = heading.LengthSquared();\n\t\tconst auto& distance_heading_squared = distance_squared * heading_squared;\n\t\tconst auto& heading_dot_direction = heading.Dot(direction);\n\t\tconst auto& heading_dot_direction_squared = heading_dot_direction * heading_dot_direction;\n\t\tconst auto& distance_heading_dot_direction_squared = distance_heading_squared * heading_dot_direction_squared;\n\t\tconst auto& distance_heading_dot_direction_squared_plus_distance_squared = distance_heading_dot_direction_squared + distance_squared;\n\t\tconst auto& distance_heading_dot_direction_squared_plus_distance_squared_plus_heading_squared = distance_heading_dot_direction_squared_plus_distance_squared + heading_squared;\n\t\tconst auto& distance_heading_dot_direction_squared_plus_distance_squared_plus_heading_squared_plus_distance_heading_squared = distance_heading_dot_direction_squared_plus_distance_squared_plus_heading_squared + distance_heading_squared;\n\t\tconst auto& distance_heading_dot_direction_squared_plus_distance_squared_plus_heading_squared_plus_distance_heading_squared_plus_heading_squared = distance_heading_dot_direction_squared_plus_distance_squared_plus_heading_squared_plus_distance_heading_squared + heading_squared;\n\t\tconst auto& distance_heading_dot_direction_squared_plus_distance_squared_plus_heading_squared_plus_distance_heading_squared_plus_heading", "CodeBleu_score": 45.12781394009061}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tstd::lock_guard<std::mutex> lock(mutex);\n\tauto it = vehicles.find(id);\n\tif (it!= vehicles.end()) {\n\t\tfloat squared_distance = distance * distance;\n\t\tfor (auto vehicle : it->second) {\n\t\t\tif (vehicle->HasActorNear(squared_distance, direction)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tauto it2 = walkers.find(id);\n\tif (it2!= walkers.end()) {\n\t\tfloat squared_distance = distance * distance;\n\t\tfor (auto walker : it2->second) {\n\t\t\tif (walker->HasActorNear(squared_distance, direction)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 51.51309860485331}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\t// TODO: Implement this function.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO: Remember to use the crowd system to determine if a vehicle is nearby.\n\t// TODO", "CodeBleu_score": 3.5730105063347506}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tWalkerEventVisitor visitor(info, delta);\n\tauto it = m_walkers.find(id);\n\tif (it!= m_walkers.end()) {\n\t\tauto &walker = it->second;\n\t\tauto &route = walker.route;\n\t\tauto &route_point = route[walker.route_point];\n\t\tauto &event = route_point.event;\n\t\tif (event.type!= Event::Type::NONE) {\n\t\t\tboost::variant2::visit(visitor, event);\n\t\t}\n\t}\n\treturn visitor.result;\n}\n", "CodeBleu_score": 46.82722796871881}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tWalkerInfo::WalkerEventVisitor visitor(info, delta);\n\tauto event = info.currentEvent;\n\tauto result = boost::variant2::visit(visitor, event);\n\treturn result;\n}\n", "CodeBleu_score": 47.473645191100104}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tWalkerEventVisitor visitor(info.context, delta);\n\treturn boost::apply_visitor(visitor, info.event);\n}\n", "CodeBleu_score": 37.7547057759399}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\tfor (auto road_node : xml.select_nodes(\"Map/Road\")) {\n\t\t// Get the road id\n\t\tstd::string road_id = road_node.node().attribute(\"id\").value();\n\t\t// Parse the lanes\n\t\tParseLanes(road_node.node(), map_builder, road_id);\n\t}\n}\n", "CodeBleu_score": 19.917089803038767}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\t// Iterate through each road node in the XML document.\n\tfor (auto road_node : xml.select_nodes(\"Map/Roads/Road\")) {\n\t\t// Get the road ID from the road node.\n\t\tauto road_id = road_node.node().attribute(\"id\").as_uint();\n\n\t\t// Get the lanes node from the road node.\n\t\tauto lanes_node = road_node.node().child(\"Lanes\");\n\n\t\t// Parse the lanes node.\n\t\tParseLanes(lanes_node, map_builder, road_id);\n\t}\n}\n", "CodeBleu_score": 22.98739997263847}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\t// Iterate through all road nodes\n\tfor (auto road_node : xml.select_nodes(\"map/road\")) {\n\t\t// Get the road ID\n\t\tstd::string road_id = road_node.node().attribute(\"id\").as_string();\n\n\t\t// Iterate through all lane nodes\n\t\tfor (auto lane_node : road_node.node().select_nodes(\"lanes/lane\")) {\n\t\t\t// Get the lane ID\n\t\t\tstd::string lane_id = lane_node.node().attribute(\"id\").as_string();\n\n\t\t\t// Parse the lane\n\t\t\tParseLanes(lane_node.node(), map_builder, road_id, lane_id);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.107987750555694}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.matched_count_ == 0) {\n\t\t// we are no longer matched to the publisher\n\t\tif (info.status_ == efd::PublicationMatchedStatus::UNMATCHED) {\n\t\t\t// we are no longer matched to the publisher\n\t\t\t// we are no longer matched to the publisher\n\t\t\tif (info.status_ == efd::PublicationMatchedStatus::UNMATCHED) {\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are no longer matched to the publisher\n\t\t\t\t// we are", "CodeBleu_score": 35.24604982821258}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.get_status() == efd::PublicationMatchedStatus::MATCHED) {\n\t\tif (info.get_matched_count() == 1) {\n\t\t\tm_first_connection = true;\n\t\t}\n\t\tm_matched_count = info.get_matched_count();\n\t}\n\telse if (info.get_status() == efd::PublicationMatchedStatus::UNMATCHED) {\n\t\tm_matched_count = info.get_matched_count();\n\t}\n\telse {\n\t\tLOG_ERROR(\"Publication matched status is invalid: %d\", info.get_status());\n\t}\n}\n", "CodeBleu_score": 49.14049758552545}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.get_status() == efd::PublicationMatchedStatus::MATCHED) {\n\t\t// Check if the writer matches the listener's topic.\n\t\tif (info.get_publication_name() == m_topic) {\n\t\t\t// Check if the writer is the first one to match.\n\t\t\tif (m_matched_count == 0) {\n\t\t\t\tm_matched_count = 1;\n\t\t\t\tm_first_connection = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm_matched_count++;\n\t\t\t}\n\t\t}\n\t}\n\telse if (info.get_status() == efd::PublicationMatchedStatus::UNMATCHED) {\n\t\t// Check if the writer matches the listener's topic.\n\t\tif (info.get_publication_name() == m_topic) {\n\t\t\t// Check if the writer is the last one to match.\n\t\t\tif (m_matched_count == 1) {\n\t\t\t\tm_matched_count = 0;\n\t\t\t\tm_first_connection = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm_matched_count--;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// This should never happen.\n\t\tLOGERROR(\"Invalid status change on publication matching for topic: \" << info.get_publication_name());\n\t}\n}\n", "CodeBleu_score": 47.80990636565255}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\t// Get the subscriber's topic name.\n\tstd::string topic_name = reader->get_topic()->get_topic_name();\n\n\t// Get the subscriber's status.\n\tefd::SubscriberStatus status = reader->get_status();\n\n\t// Get the subscriber's matched count.\n\tuint32_t matched_count = status.get_matched_count();\n\n\t// Get the subscriber's change count.\n\tuint32_t change_count = status.get_change_count();\n\n\t// Get the subscriber's first connected flag.\n\tbool first_connected = status.get_first_connected();\n\n\t// Log the subscription status.\n\tlog(INFO) << \"Subscription status for topic '\" << topic_name << \"':\" << std::endl;\n\tlog(INFO) << \"  Matched count: \" << matched_count << std::endl;\n\tlog(INFO) << \"  Change count: \" << change_count << std::endl;\n\tlog(INFO) << \"  First connected: \" << first_connected << std::endl;\n\n\t// If the change count is invalid, log an error message.\n\tif (change_count == efd::INVALID_COUNT) {\n\t\tlog(ERROR) << \"Invalid change count for topic '\" << topic_name << \"'.\" << std::endl;\n\t}\n\n\t// If a new subscription is matched, update the matched count and set the first connected flag.\n\tif (change_count == efd::NEW_MATCH) {\n\t\t// If the matched count is 1, set the first connected flag to true.\n\t\tif (matched_count == 1) {\n\t\t\tfirst_connected_ = true;\n\t\t}\n\n\t\t// Increment the matched count.\n\t\tmatched_count_++;\n\t}\n\n\t// If a subscription is unmatched, update the matched count and destroy the subscriber if there are no remaining matches.\n\tif (change_count == efd::UNMATCHED_MATCH) {\n\t\t// If the matched count is 0, destroy the subscriber.\n\t\tif (matched_count == 0) {\n\t\t\tdestroy_subscriber(reader);\n\t\t}\n\n\t\t// Decrement the matched count.\n\t\tmatched_count_--;\n\t}\n}\n", "CodeBleu_score": 40.32704667207682}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\tif (info.is_new_subscription()) {\n\t\t// New subscription\n\t\t++matched_count_;\n\t\tfirst_connected_ = true;\n\t} else if (info.is_old_subscription()) {\n\t\t// Unmatched subscription\n\t\t--matched_count_;\n\t\tif (matched_count_ == 0) {\n\t\t\t// No more subscriptions matched\n\t\t\tif (subscriber_!= NULL) {\n\t\t\t\tsubscriber_->destroy();\n\t\t\t\tsubscriber_ = NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Invalid change count\n\t\tlog(EFD_LOG_LEVEL_ERROR, \"Invalid subscription change count\");\n\t}\n}\n", "CodeBleu_score": 42.312112361396316}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\tif (info.get_status() == efd::SubscriptionMatchedStatus::MATCHED) {\n\t\t++matched_count;\n\t\tif (first_connected) {\n\t\t\tfirst_connected = false;\n\t\t\tsubscriber = new CarlaSubscriber(reader, this);\n\t\t}\n\t} else if (info.get_status() == efd::SubscriptionMatchedStatus::UNMATCHED) {\n\t\t--matched_count;\n\t\tif (matched_count == 0) {\n\t\t\tdelete subscriber;\n\t\t\tsubscriber = NULL;\n\t\t}\n\t} else {\n\t\tLOG_ERROR(\"Invalid subscription status: \" << info.get_status());\n\t}\n}\n", "CodeBleu_score": 37.98032042566305}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\tCarlaCollisionEvent* ptr = reinterpret_cast<CarlaCollisionEvent*>(data);\n\tif (!key_defined_) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent key;\n\tkey.id = ptr->id;\n\tkey.time = ptr->time;\n\tkey.object1 = ptr->object1;\n\tkey.object2 = ptr->object2;\n\tkey.distance = ptr->distance;\n\tkey.normal = ptr->normal;\n\tkey.position = ptr->position;\n\tkey.impulse = ptr->impulse;\n\tkey.speed = ptr->speed;\n\tkey.object1_type = ptr->object1_type;\n\tkey.object2_type = ptr->object2_type;\n\tkey.object1_id = ptr->object1_id;\n\tkey.object2_id = ptr->object2_id;\n\tkey.object1_name = ptr->object1_name;\n\tkey.object2_name = ptr->object2_name;\n\tkey.object1_mass = ptr->object1_mass;\n\tkey.object2_mass = ptr->object2_mass;\n\tkey.object1_velocity = ptr->object1_velocity;\n\tkey.object2_velocity = ptr->object2_velocity;\n\tkey.object1_position = ptr->object1_position;\n\tkey.object2_position = ptr->object2_position;\n\tkey.object1_angular_velocity = ptr->object1_angular_velocity;\n\tkey.object2_angular_velocity = ptr->object2_angular_velocity;\n\tkey.object1_angular_position = ptr->object1_angular_position;\n\tkey.object2_angular_position = ptr->object2_angular_position;\n\tkey.object1_linear_velocity = ptr->object1_linear_velocity;\n\tkey.object2_linear_velocity = ptr->object2_linear_velocity;\n\tkey.object1_angular_velocity = ptr->object1_angular_velocity;\n\tkey.object2_angular_velocity = ptr->object2_angular_velocity;\n\tkey.object1_angular_position = ptr->object1_angular_position;", "CodeBleu_score": 17.691639716802076}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\tif (key_defined) {\n\t\treturn false;\n\t} else {\n\t\tCarlaCollisionEvent* p_type_data = (CarlaCollisionEvent*)data;\n\t\tstd::string m_key;\n\t\tif (force_md5) {\n\t\t\tm_key = p_type_data->m_id;\n\t\t} else {\n\t\t\tchar* m_key_serialized = NULL;\n\t\t\tsize_t m_key_serialized_size = 0;\n\t\t\tm_key_serialized_size = getSerializedSize(KEY_HASH_LENGTH, p_type_data);\n\t\t\tm_key_serialized = new char[m_key_serialized_size];\n\t\t\tif (!serializeKey(KEY_HASH_LENGTH, p_type_data, m_key_serialized, m_key_serialized_size)) {\n\t\t\t\tdelete[] m_key_serialized;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tm_key = std::string(m_key_serialized, m_key_serialized_size);\n\t\t\tdelete[] m_key_serialized;\n\t\t}\n\t\tstd::string m_id = p_type_data->m_id;\n\t\tsize_t m_id_size = m_id.size();\n\t\tsize_t m_key_size = m_key.size();\n\t\tsize_t m_handle_size = 0;\n\t\tif (m_id_size > 0 && m_key_size > 0) {\n\t\t\tm_handle_size = m_id_size + m_key_size + 1;\n\t\t}\n\t\tif (m_handle_size > 0) {\n\t\t\thandle->value = new char[m_handle_size];\n\t\t\tchar* handle_value = handle->value;\n\t\t\tif (m_id_size > 0) {\n\t\t\t\tmemcpy(handle_value, m_id.c_str(), m_id_size);\n\t\t\t\thandle_value += m_id_size;\n\t\t\t}\n\t\t\tif (m_key_size > 0) {\n\t\t\t\tmemcpy(handle_value, m_key.c_str(), m_key_size);\n\t\t\t\thandle_value += m_key_size;\n\t\t\t}\n\t\t\tif (m_id_size > 0", "CodeBleu_score": 35.20632856402486}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\nCarlaCollisionEvent* ptr = reinterpret_cast<CarlaCollisionEvent*>(data);\n", "CodeBleu_score": 6.094268543247485}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)CarlaEgoVehicleControl* p_type = reinterpret_cast<CarlaEgoVehicleControl*>(data);\n\n    // Call the serialize function of the Cdr class\n    return Cdr::serialize(p_type, payload);\n}\n", "CodeBleu_score": 16.51044038307372}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    FastBuffer fastbuffer(payload->buffer, payload->max_size);\n    // Object that serializes the data.\n    ObjectSerializer ser(fastbuffer, Cdr::BIG_ENDIANNESS);\n\n    // Serialize the data.\n    ser.serialize(p_type->steering_angle);\n    ser.serialize(p_type->throttle);\n    ser.serialize(p_type->brake);\n    ser.serialize(p_type->hand_brake);\n    ser.serialize(p_type->reverse);\n    ser.serialize(p_type->manual_gear_shift);\n    ser.serialize(p_type->gear_target);\n    ser.serialize(p_type->manual_steering_control);\n    ser.serialize(p_type->manual_throttle_control);\n    ser.serialize(p_type->manual_brake_control);\n    ser.serialize(p_type->manual_hand_brake_control);\n    ser.serialize(p_type->manual_reverse_control);\n    ser.serialize(p_type->manual_gear_shift_control);\n    ser.serialize(p_type->manual_gear_target_control);\n\n    // Finally return the serialized buffer.\n    payload->length = fastbuffer.length();\n\n    return true;\n}\n", "CodeBleu_score": 45.15640014439709}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n\n    // Call the serialize function of the Cdr class\n    CarlaEgoVehicleControlCdr ser_cdr;\n    ser_cdr.serialize(p_type);\n\n    // Get the size of the Cdr buffer\n    size_t size = ser_cdr.getSerializedDataLength();\n\n    // Create a buffer to store the serialized data\n    uint8_t* buffer = (uint8_t*)malloc(size);\n    if (buffer == nullptr) {\n        return false;\n    }\n\n    // Serialize the data into the buffer\n    ser_cdr.getSerializedData(buffer);\n\n    // Set the payload encapsulation\n    payload->encapsulation = ser_cdr.getEncapsulation();\n    payload->length = size;\n\n    // Set the payload buffer\n    payload->buffer = buffer;\n\n    return true;\n}\n", "CodeBleu_score": 42.97880128774193}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\t// Check if the target has been set\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Check if the message is a position or air pressure message\n\tif (msg.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT || msg.msgid == MAVLINK_MSG_ID_SCALED_PRESSURE) {\n\n\t\t// Check if the target system ID is set\n\t\tif (msg.sysid == 0) {\n\t\t\t// Set the target system ID\n\t\t\ttarget_sysid = msg.sysid;\n\n\t\t\t// Request position and air pressure data streams from the target\n\t\t\tmavlink_request_data_stream(MAVLINK_COMM_0, target_sysid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t\tmavlink_request_data_stream(MAVLINK_COMM_0, target_sysid, MAV_DATA_STREAM_SCALED_PRESSURE, 1, 1);\n\t\t}\n\n\t\t// Set the target set flag\n\t\ttarget_set = true;\n\t}\n}\n", "CodeBleu_score": 34.768108586208804}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\t// Check if the target has been set\n\tif (mavlink_target_sysid!= 0) {\n\t\treturn;\n\t}\n\n\t// Check the message type\n\tif (msg.msgid!= MAVLINK_MSG_ID_ATTITUDE && msg.msgid!= MAVLINK_MSG_ID_GLOBAL_POSITION_INT && msg.msgid!= MAVLINK_MSG_ID_VFR_HUD) {\n\t\treturn;\n\t}\n\n\t// Check if the target system ID is set\n\tif (msg.sysid == 0) {\n\t\tmavlink_target_sysid = msg.sysid;\n\t\tmavlink_target_compid = msg.compid;\n\t\tmavlink_send_request_data_stream(MAV_DATA_STREAM_POSITION, 10, 1);\n\t\tmavlink_send_request_data_stream(MAV_DATA_STREAM_PRESSURE, 10, 1);\n\t\tmavlink_send_request_data_stream(MAV_DATA_STREAM_RAW_SENSORS, 10, 1);\n\t\tmavlink_send_request_data_stream(MAV_DATA_STREAM_RC_CHANNELS, 10, 1);\n\t\tmavlink_target_sysid_set = true;\n\t}\n\n\t// Set the target system ID\n\tmavlink_target_sysid = msg.sysid;\n\tmavlink_target_compid = msg.compid;\n\n\t// Flag that the target has been set\n\tmavlink_target_set = true;\n}\n", "CodeBleu_score": 37.99364001132716}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\ttarget_sysid = msg.sysid;\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED:\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT:\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_V2:\n\t\t// Check if the target system ID is set\n\t\tif (target_sysid == 0) {\n\t\t\t// Set the target system ID to the target system ID in the message\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\t// Request position and air pressure data streams from the target\n\t\t\tmavlink_request_data_stream_send(target_sysid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\tmavlink_request_data_stream_send(target_sysid, MAV_DATA_STREAM_PRESSURE, 10, 1);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t// Exit if the message type is not one that should be tracked\n\t\treturn;\n\t}\n\n\t// Flag that the target has been set\n\ttarget_set = true;\n}\n", "CodeBleu_score": 32.943900551226044}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\treturn _base_class_tracker->_handle_command_preflight_calibration_baro(msg);\n}\n", "CodeBleu_score": 28.40285167333899}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\t// Call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_base(msg, _baro_calibration_needed, _baro_calibration_result);\n\n\t// If the result is accepted, set the flag that indicates that we need to do altitude calibration on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 53.16757955278384}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\treturn _handle_command_preflight_calibration(msg, _baro_calibration_needed, _baro_calibration_in_progress);\n}\n", "CodeBleu_score": 21.658444530172986}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tif (packet.param1 == 1.0) {\n\t\t// arm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\t// disarm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 42.38533149735561}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tswitch (packet.param1) {\n\tcase 1.0:\n\t\treturn MAV_RESULT_ACCEPTED;\n\tcase 0.0:\n\t\treturn MAV_RESULT_ACCEPTED;\n\tdefault:\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 35.373631730525666}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tif (packet.param1 == 1.0) {\n\t\t// arm\n\t\tif (mavlink_command_arm_disarm_t::MAV_CMD_COMPONENT_ARM_DISARM == packet.command) {\n\t\t\t// arm\n\t\t\tmavlink_command_arm_disarm_t::mavlink_command_arm_disarm_send_struct(MAVLINK_COMM_0, packet.target_system, packet.target_component, 1, 1, 1);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\t// arm all\n\t\t\tmavlink_command_arm_disarm_t::mavlink_command_arm_disarm_send_struct(MAVLINK_COMM_0, packet.target_system, packet.target_component, 1, 1, 0);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t} else if (packet.param1 == 0.0) {\n\t\t// disarm\n\t\tif (mavlink_command_arm_disarm_t::MAV_CMD_COMPONENT_ARM_DISARM == packet.command) {\n\t\t\t// disarm\n\t\t\tmavlink_command_arm_disarm_t::mavlink_command_arm_disarm_send_struct(MAVLINK_COMM_0, packet.target_system, packet.target_component, 1, 0, 1);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\t// disarm all\n\t\t\tmavlink_command_arm_disarm_t::mavlink_command_arm_disarm_send_struct(MAVLINK_COMM_0, packet.target_system, packet.target_component, 1, 0, 0);\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 42.652108387723345}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\tfor (int i = 0; i < GCS_TRACKER_NUM_CHANNELS; i++) {\n\t\tif (gcs_channels[i].available_payload_space() > 0) {\n\t\t\tgcs_channels[i].request_datastream_position(sysid, compid, GCS_TRACKER_POSITION_DATASTREAM_RATE);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 31.578250617376902}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\t// Iterate over all channels\n\tfor (int i = 0; i < GCS_CHANNEL_COUNT; i++) {\n\t\t// If the channel is available\n\t\tif (gcs_channels[i].available) {\n\t\t\t// If the channel is not already streaming position data\n\t\t\tif (!gcs_channels[i].position_data_stream_active) {\n\t\t\t\t// Request the data stream on the channel\n\t\t\t\tgcs_channels[i].request_datastream_position(sysid, compid);\n\t\t\t\t// Set the channel to streaming position data\n\t\t\t\tgcs_channels[i].position_data_stream_active = true;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.85681164563229}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\t// Check if the system and component ID are valid\n\tif (sysid > 255 || compid > 255) {\n\t\treturn;\n\t}\n\n\t// Iterate over the available channels and check for available payload space\n\tfor (uint8_t chan = 0; chan < GCS_NUM_CHANNELS; chan++) {\n\t\tif (gcs_channels[chan].get_payload_space() >= sizeof(mavlink_position_target_global_int_t)) {\n\t\t\t// Send the request to start the data stream on the corresponding channel\n\t\t\tmavlink_msg_request_data_stream_send(gcs_channels[chan].get_mavlink_channel(), sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 47.45012273590548}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\t// Retrieve the AHRS instance\n\tAHRS* ahrs = AHRS::getInstance();\n\n\t// Check for a zero pitch cosine\n\tif (cos(pitch)!= 0) {\n\t\t// Calculate the earth frame pitch and yaw\n\t\tef_pitch = asin(ahrs->getPitch() * cos(pitch) + ahrs->getYaw() * sin(pitch));\n\t\tef_yaw = ahrs->getYaw() - atan2(ahrs->getRoll() * sin(pitch), cos(pitch));\n\n\t\t// Return true\n\t\treturn true;\n\t}\n\n\t// Return false\n\treturn false;\n}\n", "CodeBleu_score": 44.51274991160101}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\t// Get the AHRS instance\n\tahrs_ = ahrs_manager_->get_ahrs();\n\n\t// Check for a zero pitch cosine\n\tif (cos(pitch)!= 0) {\n\t\t// Calculate the earth frame pitch and yaw\n\t\tef_pitch = asin(sin(pitch) * ahrs_->get_pitch_cos());\n\t\tef_yaw = ahrs_->get_yaw() + yaw;\n\n\t\t// Return true\n\t\treturn true;\n\t}\n\n\t// Return false\n\treturn false;\n}\n", "CodeBleu_score": 43.797543398935964}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\tAHRS* ahrs = AHRS::get_instance();\n\tif (ahrs->get_pitch_cosine()!= 0.0f) {\n\t\tef_pitch = ahrs->get_pitch_sine() * pitch + ahrs->get_yaw_sine() * yaw;\n\t\tef_yaw = ahrs->get_yaw_cosine() * yaw - ahrs->get_pitch_cosine() * pitch;\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 55.37921531855926}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)\t// Calculate the current yaw and pitch in centidegrees\n\tint yaw = (int) (yaw_servo_position * 100);\n\tint pitch = (int) (pitch_servo_position * 100);\n\n\t// Check if the direction is reversed\n\tbool reversed = (yaw_servo_position < 0.0);\n\n\t// Calculate the angle error\n\tint error_yaw = yaw_target - yaw;\n\tint error_pitch = pitch_target - pitch;\n\n\t// Convert the errors from earth frame to body frame\n\tif (reversed) {\n\t\terror_yaw = -error_yaw;\n\t\terror_pitch = -error_pitch;\n\t}\n\n\t// Check if the target distance is valid\n\tif (distance_target > 0) {\n\t\t// Check if the target distance is valid\n\t\tif (distance_target < distance_min) {\n\t\t\t// Update the pitch and yaw servos\n\t\t\tpitch_servo_position = pitch_servo_position - (float) error_pitch / 1000.0;\n\t\t\tyaw_servo_position = yaw_servo_position - (float) error_yaw / 1000.0;\n\t\t}\n\t} else {\n\t\t// Update the pitch and yaw servos\n\t\tpitch_servo_position = pitch_servo_position - (float) error_pitch / 1000.0;\n\t\tyaw_servo_position = yaw_servo_position - (float) error_yaw / 1000.0;\n\t}\n\n\t// Check if the target pitch is valid\n\tif (pitch_target > 0) {\n\t\t// Check if the target pitch is valid\n\t\tif (pitch_target < pitch_min) {\n\t\t\t// Update the pitch servo\n\t\t\tpitch_servo_position = pitch_servo_position - (float) error_pitch / 1000.0;\n\t\t}\n\t} else {\n\t\t// Update the pitch servo\n\t\tpitch_servo_position = pitch_servo_position - (float) error_pitch / 1000.0;\n\t}\n\n\t// Check if the target yaw is valid\n\tif (yaw_target > 0) {\n\t\t// Check if the target yaw is valid\n\t\tif (yaw", "CodeBleu_score": 26.22331048445882}, {"code": "void Mode::update_auto(void)\t// calculate target yaw and pitch\n\tint16_t target_yaw = 0;\n\tint16_t target_pitch = 0;\n\n\t// calculate target yaw\n\tif (navigation_status == NAVIGATION_STATUS_NAVIGATING) {\n\t\t// calculate target yaw\n\t\tif (navigation_parameters.target_yaw_mode == NAVIGATION_PARAMETERS_TARGET_YAW_MODE_RELATIVE) {\n\t\t\ttarget_yaw = navigation_parameters.target_yaw + navigation_parameters.yaw;\n\t\t} else {\n\t\t\ttarget_yaw = navigation_parameters.target_yaw;\n\t\t}\n\t} else if (navigation_status == NAVIGATION_STATUS_LANDING) {\n\t\t// calculate target yaw\n\t\tif (navigation_parameters.target_yaw_mode == NAVIGATION_PARAMETERS_TARGET_YAW_MODE_RELATIVE) {\n\t\t\ttarget_yaw = navigation_parameters.target_yaw + navigation_parameters.yaw;\n\t\t} else {\n\t\t\ttarget_yaw = navigation_parameters.target_yaw;\n\t\t}\n\t} else if (navigation_status == NAVIGATION_STATUS_TAKEOFF) {\n\t\t// calculate target yaw\n\t\tif (navigation_parameters.target_yaw_mode == NAVIGATION_PARAMETERS_TARGET_YAW_MODE_RELATIVE) {\n\t\t\ttarget_yaw = navigation_parameters.target_yaw + navigation_parameters.yaw;\n\t\t} else {\n\t\t\ttarget_yaw = navigation_parameters.target_yaw;\n\t\t}\n\t} else {\n\t\t// calculate target yaw\n\t\tif (navigation_parameters.target_yaw_mode == NAVIGATION_PARAMETERS_TARGET_YAW_MODE_RELATIVE) {\n\t\t\ttarget_yaw = navigation_parameters.target_yaw + navigation_parameters.yaw;\n\t\t} else {\n\t\t\ttarget_yaw = navigation_parameters.target_yaw;\n\t\t}\n\t}\n\n\t// calculate target pitch\n\tif (navigation_status == NAVIGATION_STATUS_NAVIGATING) {\n\t\t// calculate target pitch\n\t\tif (navigation_parameters.target_pitch_mode == NAVIGATION_PARAMETERS_TARGET_PITCH_MODE_RELATIVE) {\n\t\t\ttarget_pitch = navigation_parameters.target_pitch + navigation_parameters.pitch;\n\t\t} else {", "CodeBleu_score": 26.531049005916497}, {"code": "void Mode::update_auto(void)\t//Get the current distance and heading\n\tfloat distance = tracker.get_distance();\n\tfloat heading = tracker.get_heading();\n\t//If the distance is invalid, don't do anything\n\tif (distance < 0) {\n\t\treturn;\n\t}\n\t//If the distance is valid, but the minimum distance is set, check if the distance is below the minimum\n\tif (distance < min_distance) {\n\t\treturn;\n\t}\n\t//Get the target distance and heading\n\tfloat target_distance = get_target_distance();\n\tfloat target_heading = get_target_heading();\n\t//If the target distance is invalid, don't do anything\n\tif (target_distance < 0) {\n\t\treturn;\n\t}\n\t//Get the current time\n\tfloat time = get_time();\n\t//If the time is invalid, don't do anything\n\tif (time < 0) {\n\t\treturn;\n\t}\n\t//Get the current velocity\n\tfloat velocity = get_velocity();\n\t//If the velocity is invalid, don't do anything\n\tif (velocity < 0) {\n\t\treturn;\n\t}\n\t//Get the current angular velocity\n\tfloat angular_velocity = get_angular_velocity();\n\t//If the angular velocity is invalid, don't do anything\n\tif (angular_velocity < 0) {\n\t\treturn;\n\t}\n\t//Get the current acceleration\n\tfloat acceleration = get_acceleration();\n\t//If the acceleration is invalid, don't do anything\n\tif (acceleration < 0) {\n\t\treturn;\n\t}\n\t//Get the current angular acceleration\n\tfloat angular_acceleration = get_angular_acceleration();\n\t//If the angular acceleration is invalid, don't do anything\n\tif (angular_acceleration < 0) {\n\t\treturn;\n\t}\n\t//Get the current yaw\n\tfloat yaw = get_yaw();\n\t//If the yaw is invalid, don't do anything\n\tif (yaw < 0) {\n\t\treturn;\n\t}\n\t//Get the current pitch\n\tfloat pitch = get_pitch();\n\t//If the pitch is invalid, don't do anything\n\tif (pitch < 0) {\n\t\treturn;\n\t}\n\t//Get", "CodeBleu_score": 28.705358045931668}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)\t//Update the GPS\n\tGPS.update();\n\n\t//Check if the last message time has changed\n\tif (GPS.lastMsgTime!= lastMsgTime) {\n\t\tlastMsgTime = GPS.lastMsgTime;\n\t\t//If the GPS status is at least 3D fix, start the countdown\n\t\tif (GPS.status == 3) {\n\t\t\tgroundStartCountdown = 10;\n\t\t}\n\t}\n\n\t//Check if the GPS status is at least 3D fix\n\tif (GPS.status == 3) {\n\t\t//Check if the countdown is active\n\t\tif (groundStartCountdown > 0) {\n\t\t\t//Decrement the countdown\n\t\t\tgroundStartCountdown--;\n\t\t\t//If the countdown reaches zero, set the home location\n\t\t\tif (groundStartCountdown == 0) {\n\t\t\t\thomeLocation = GPS.location;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t//If the GPS status is not at least 3D fix, reset the countdown\n\t\tgroundStartCountdown = 0;\n\t}\n}\n", "CodeBleu_score": 38.58435981512876}, {"code": "void Tracker::update_GPS(void)\t// update the GPS data\n\tif (GPS.newNMEAreceived()) {\n\t\tGPS.parse(GPS.lastNMEA());\n\t}\n\t// check if the last message time has changed\n\tif (GPS.lastNMEA()!= last_message) {\n\t\tlast_message = GPS.lastNMEA();\n\t\t// check if the GPS status is at least 3D fix\n\t\tif (GPS.fix) {\n\t\t\t// check if the countdown has reached one\n\t\t\tif (countdown == 1) {\n\t\t\t\t// set the home location if the current location is valid\n\t\t\t\tif (GPS.location.isValid()) {\n\t\t\t\t\thome_location = GPS.location;\n\t\t\t\t\thome_location_valid = true;\n\t\t\t\t\thome_location_valid_time = millis();\n\t\t\t\t\t// reset the countdown\n\t\t\t\t\tcountdown = 0;\n\t\t\t\t}\n\t\t\t\t// reset the countdown\n\t\t\t\telse {\n\t\t\t\t\tcountdown = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// increment the countdown\n\t\t\telse {\n\t\t\t\tcountdown++;\n\t\t\t}\n\t\t}\n\t\t// reset the countdown\n\t\telse {\n\t\t\tcountdown = 0;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.358603874165844}, {"code": "void Tracker::update_GPS(void)\tif (gps_status == 0) {\n\t\tgps_status = gps_data.satellites_used;\n\t}\n\tif (gps_status < 3) {\n\t\tif (gps_status == 0) {\n\t\t\tgps_status = gps_data.satellites_used;\n\t\t}\n\t\treturn;\n\t}\n\tif (gps_status == 3) {\n\t\tif (gps_data.fix_type < 3) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps_status == 4) {\n\t\tif (gps_data.fix_type < 4) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps_status == 5) {\n\t\tif (gps_data.fix_type < 5) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps_status == 6) {\n\t\tif (gps_data.fix_type < 6) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps_status == 7) {\n\t\tif (gps_data.fix_type < 7) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps_status == 8) {\n\t\tif (gps_data.fix_type < 8) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps_status == 9) {\n\t\tif (gps_data.fix_type < 9) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps_status == 10) {\n\t\tif (gps_data.fix_type < 10) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps_status == 11) {\n\t\tif (gps_data.fix_type < 11) {\n\t\t\tgps_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (gps", "CodeBleu_score": 23.176344088542635}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch > 0) {\n\t\tif (pitch_onoff_servo_on) {\n\t\t\treturn;\n\t\t}\n\t\tpitch_onoff_servo_on = true;\n\t\t// set the pitch onoff servo to 1\n\t\tset_pitch_onoff_servo(1);\n\t} else {\n\t\tif (!pitch_onoff_servo_on) {\n\t\t\treturn;\n\t\t}\n\t\tpitch_onoff_servo_on = false;\n\t\t// set the pitch onoff servo to 0\n\t\tset_pitch_onoff_servo(0);\n\t}\n}\n", "CodeBleu_score": 15.552337925076825}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch > 0) {\n\t\tif (pitch > 1.0f) {\n\t\t\tpitch = 1.0f;\n\t\t}\n\t\tif (pitch < 0.0f) {\n\t\t\tpitch = 0.0f;\n\t\t}\n\t\tpitch_onoff_servo.set_position(pitch);\n\t}\n}\n", "CodeBleu_score": 12.572067395711967}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\t// if the pitch is within the range of the servo, set it\n\tif (pitch >= -90 && pitch <= 90) {\n\t\t// set the pitch to the servo\n\t\tservo_pitch.write(pitch);\n\t}\n}\n", "CodeBleu_score": 12.17192113905764}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\t// call base class function\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tif (AP_Arming::arming_check_baro) {\n\t\t// check barometer altitude\n\t\tif (fabsf(get_baro_altitude_difference()) > AP_ARMED_BARO_ALT_DIFF_MAX) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::console->printf(\"Barometer altitude difference exceeds limit\\n\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 24.887825641269963}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\tbool barometer_checks_result = AP_Arming::barometer_checks(display_failure);\n\n\tif (barometer_checks_result) {\n\t\tif (AP_HAL::get_hal().get_param_float(PARAM_BARO_REF)!= 0.0f) {\n\t\t\tif (fabsf(get_baro_reference() - get_baro_alt()) > AP_ARMED_BARO_ALT_DISPARITY) {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\tAP_HAL::get_hal().console->println_P(PSTR(\"Barometer altitude disparity too large\"));\n\t\t\t\t}\n\t\t\t\tbarometer_checks_result = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn barometer_checks_result;\n}\n", "CodeBleu_score": 32.17455409087868}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (AP_Arming::armed &&!AP_Arming::baro_check_passed) {\n\t\t// check barometer altitude against inertial nav altitude\n\t\tif (AP_Arming::baro_altitude - AP_Arming::inertial_nav_altitude > AP_Arming::BARO_ALT_TOL) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_RED, 1);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_GREEN, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_BLUE, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_ORANGE, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_WHITE, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_YELLOW, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_BLACK, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_AMBER, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_CYAN, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_MAGENTA, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_TEAL, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_PINK, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_PURPLE, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_AQUA, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_WHITE, 1);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_RED, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_GREEN, 0);\n\t\t\t\tAP_HAL::led_set(AP_HAL::LED_BLUE, 0);\n\t\t\t\tAP_HAL::led_", "CodeBleu_score": 36.13801779605264}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (_terrain_source == TerrainSource::Rangefinder) {\n\t\treturn false;\n\t}\n\n\tif (_terrain_source == TerrainSource::TerrainDatabase && _rtl_altitude_type == RTLAltitudeType::Terrain) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 51.40083357810465}, {"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (terrain_source == TerrainSource::Rangefinder) {\n\t\treturn false;\n\t}\n\n\tif (terrain_source == TerrainSource::TerrainDatabase && altitude_type == AltitudeType::Terrain) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 50.75973247048473}, {"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (_terrain_source == TerrainSource::Rangefinder) {\n\t\treturn false;\n\t}\n\n\tif (_terrain_source == TerrainSource::TerrainDatabase && _terrain_type == TerrainType::Terrain) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 50.70510684080723}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()\t// set loop time for low-level rate controllers\n\tattitude_controller.set_loop_time(scheduler.get_loop_time());\n\tposition_controller.set_loop_time(scheduler.get_loop_time());\n\tmotor_controller.set_loop_time(scheduler.get_loop_time());\n\n\t// run low-level rate controllers\n\tattitude_controller.run();\n\tposition_controller.run();\n\tmotor_controller.run();\n}\n", "CodeBleu_score": 37.443469799619656}, {"code": "void Copter::run_rate_controller()\t// Run the attitude controller\n\tattitude_controller_run();\n\t// Run the position controller\n\tposition_controller_run();\n\t// Run the motor controller\n\tmotor_controller_run();\n}\n", "CodeBleu_score": 8.63385823388317}, {"code": "void Copter::run_rate_controller()\t// Set the loop time for the rate controllers\n\t_att_control.set_loop_time(_loop_time);\n\t_pos_control.set_loop_time(_loop_time);\n\t_motor_control.set_loop_time(_loop_time);\n\n\t// Run the rate controllers\n\t_att_control.run(_att_sp, _att_sp_body, _att_sp_body_sp, _att_sp_body_rate, _att_sp_body_rate_sp, _att_sp_body_rate_rate, _att_sp_body_rate_rate_sp, _att_sp_body_rate_rate_rate, _att_sp_body_rate_rate_rate_sp, _att_sp_body_rate_rate_rate_rate, _att_sp_body_rate_rate_rate_rate_sp, _att_sp_body_rate_rate_rate_rate_rate, _att_sp_body_rate_rate_rate_rate_rate_sp, _att_sp_body_rate_rate_rate_rate_rate_rate, _att_sp_body_rate_rate_rate_rate_rate_rate_sp, _att_sp_body_rate_rate_rate_rate_rate_rate_rate, _att_sp_body_rate_rate_rate_rate_rate_rate_rate_sp, _att_sp_body_rate_rate_rate_rate_rate_rate_rate_rate, _att_sp_body_rate_rate_rate_rate_rate_rate_rate_rate_sp, _att_sp_body_rate_rate_rate_rate_rate_rate_rate_rate_rate, _att_sp_body_rate_rate_rate_rate_rate_rate_rate_rate_rate_sp, _att_sp_body_rate_rate_rate_rate_rate_rate_rate_rate_rate_rate, _att_sp_body_rate_rate_rate_rate_rate_rate_rate_rate_rate_rate_sp, _att_sp_body_rate_rate_rate_rate_rate_rate_rate_rate_rate_rate_rate, _att_sp_body", "CodeBleu_score": 33.847418935740414}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.get_lat() == new_loc.get_lat() && old_loc.get_lon() == new_loc.get_lon() && old_loc.get_alt() == new_loc.get_alt()) {\n\t\treturn false;\n\t}\n\telse {\n\t\ttarget_location = new_loc;\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 46.253342730165734}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.get_latitude() == new_loc.get_latitude() && old_loc.get_longitude() == new_loc.get_longitude() && old_loc.get_altitude_frame() == new_loc.get_altitude_frame()) {\n\t\treturn false;\n\t}\n\telse {\n\t\ttarget_location = new_loc;\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 47.481903694229175}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.lat == new_loc.lat && old_loc.lon == new_loc.lon && old_loc.alt == new_loc.alt) {\n\t\treturn false;\n\t}\n\telse {\n\t\ttarget_location = new_loc;\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 39.99190509933119}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (set_mode(mode)) {\n\t\t\t// mode set successfully\n\t\t\t_mode = mode;\n\t\t}\n\t} else {\n\t\tif (_mode == mode) {\n\t\t\t// reset mode switch\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 52.713724840548814}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (rc().set_mode(mode)) {\n\t\t\t// mode was set, so reset the switch to LOW\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t} else if (mode == current_mode) {\n\t\t// reset the switch to LOW\n\t\trc().reset_mode_switch();\n\t}\n}\n", "CodeBleu_score": 49.59580603465608}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (set_mode(mode)) {\n\t\t\t_mode_switch_pos = ch_flag;\n\t\t}\n\t} else if (ch_flag == AuxSwitchPos::LOW) {\n\t\tif (_mode_switch_pos == AuxSwitchPos::HIGH && _mode == mode) {\n\t\t\t_mode_switch_pos = AuxSwitchPos::LOW;\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.44932068730237}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()\t// Get the trim values from the control inputs\n\tfloat trim_roll = (float)get_channel_data(ROLL_CHANNEL) / 1000.0f;\n\tfloat trim_pitch = (float)get_channel_data(PITCH_CHANNEL) / 1000.0f;\n\n\t// Convert the trim values from the control inputs to radians\n\tfloat trim_roll_rad = trim_roll * (M_PI / 180.0f);\n\tfloat trim_pitch_rad = trim_pitch * (M_PI / 180.0f);\n\n\t// Add the trim values to the AHRS trim\n\tahrs->add_trim(trim_roll_rad, trim_pitch_rad);\n\n\t// Log the event\n\tlog_event(LOG_LEVEL_INFO, \"Trim saved\");\n\n\t// Send a confirmation message with MAV_SEVERITY_INFO\n\tmavlink_log_info(mavlink_fd, \"Trim saved\");\n}\n", "CodeBleu_score": 45.216244534011985}, {"code": "void Copter::save_trim()\t// Calculate trim values from control input\n\tfloat roll_trim_rad = (float)rc_channels.channels[ROLL] / 1000.0f * M_PI / 2.0f;\n\tfloat pitch_trim_rad = (float)rc_channels.channels[PITCH] / 1000.0f * M_PI / 2.0f;\n\n\t// Add trim values to AHRS\n\tahrs.add_trim(roll_trim_rad, pitch_trim_rad);\n\n\t// Log trim event\n\tmavlink_log_info(0, \"Trim saved: %f, %f\", roll_trim_rad, pitch_trim_rad);\n\n\t// Send confirmation message\n\tmavlink_log_info(0, \"Trim saved: %f, %f\", roll_trim_rad, pitch_trim_rad);\n}\n", "CodeBleu_score": 42.98407289679071}, {"code": "void Copter::save_trim()\ttrim_roll = (float)roll_input / 1000.0f;\n\ttrim_pitch = (float)pitch_input / 1000.0f;\n\n\ttrim_roll = constrain(trim_roll, -1.0f, 1.0f);\n\ttrim_pitch = constrain(trim_pitch, -1.0f, 1.0f);\n\n\tahrs.set_roll_trim(trim_roll);\n\tahrs.set_pitch_trim(trim_pitch);\n\n\t//Log the event\n\tlog_event(LOG_EVENT_TRIM, 0);\n\n\t//Send the confirmation message\n\tmavlink_log_info(0, \"Trim saved\");\n}\n", "CodeBleu_score": 42.54802984049266}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()\t// Get the copter's velocity\n\tVector3f velocity = copter.velocity();\n\t// Calculate the speed squared\n\tfloat speed_squared = velocity.x() * velocity.x() + velocity.y() * velocity.y() + velocity.z() * velocity.z();\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (copter.is_position_valid() && speed_squared > MIN_SPEED_SQUARED) {\n\t\t// Calculate the look-ahead yaw angle\n\t\tfloat look_ahead_yaw = atan2(velocity.y(), velocity.x());\n\t\t// Update the look-ahead yaw angle\n\t\tlook_ahead_yaw_angle = look_ahead_yaw;\n\t}\n\t// Return the look-ahead yaw angle\n\treturn look_ahead_yaw_angle;\n}\n", "CodeBleu_score": 43.119580822625245}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\tfloat speed_squared = (float) (pow(copter.velocity.x, 2) + pow(copter.velocity.y, 2));\n\tif (copter.position.valid() && speed_squared >= MIN_SPEED_SQUARED) {\n\t\tfloat theta = atan2(copter.velocity.y, copter.velocity.x);\n\t\tfloat yaw_angle = copter.yaw + theta;\n\t\treturn yaw_angle;\n\t}\n\treturn copter.yaw;\n}\n", "CodeBleu_score": 39.42695916371872}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\t// Get the copter's velocity\n\tfloat velocity = get_velocity();\n\t// Calculate the speed squared\n\tfloat speed_squared = velocity * velocity;\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (valid_position && speed_squared >= MIN_SPEED_SQUARED) {\n\t\t// Calculate the look-ahead yaw angle\n\t\tlook_ahead_yaw = atan2f(velocity * sin(look_ahead_yaw_angle), velocity * cos(look_ahead_yaw_angle));\n\t}\n\t// Return the computed look-ahead yaw angle\n\treturn look_ahead_yaw;\n}\n", "CodeBleu_score": 35.69896892629759}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (method == AP_Arming::Method::RUDDER) {\n\t\t// RUDDER method\n\t\tif (rudder_disable || (throttle_in_range && throttle_in_range_last)) {\n\t\t\t// rudder arming disabled or throttle not zero, so don't arm\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 32.200885378158105}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\t// If arming checks are disabled, or the watchdog was armed, return true\n\tif (AP_Arming::is_disabled() || AP_Arming::was_armed()) {\n\t\treturn true;\n\t}\n\n\t// If the throttle is zero, return false\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (AP_Arming::get_throttle_zero()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Call parent class's arm_checks method\n\treturn AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 38.09677415702477}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (method == AP_Arming::RUDDER) {\n\t\t// rudder arming is disabled or throttle not zero\n\t\tif (rudder_armed ||!throttle_zero) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 27.91932604070761}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\t// check if we are already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are in manual mode\n\tif (is_manual()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in failsafe mode\n\tif (is_failsafe()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in transition mode\n\tif (is_transition()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in manual_input mode\n\tif (is_manual_input()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in acro mode\n\tif (is_acro()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in stabilize mode\n\tif (is_stabilize()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in altitude mode\n\tif (is_altitude()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in auto mode\n\tif (is_auto()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in guided mode\n\tif (is_guided()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in loiter mode\n\tif (is_loiter()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in circle mode\n\tif (is_circle()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in position mode\n\tif (is_position()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in land mode\n\tif (is_land()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in disarmed\n\tif (is_disarmed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in manual_input mode\n\tif (is_manual_input()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in manual_input mode\n\tif (is_manual_input()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in manual_input mode\n\tif (is_manual_input()) {\n\t\treturn", "CodeBleu_score": 23.34517215613241}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\tbool success = false;\n\n\t// check if we are already armed\n\tif (_state == AP_Arming::ARMED) {\n\t\treturn true;\n\t}\n\n\t// check if we are arming\n\tif (_state == AP_Arming::ARMING) {\n\t\treturn false;\n\t}\n\n\t// check if we are disarmed\n\tif (_state == AP_Arming::DISARMED) {\n\t\t// try to arm\n\t\tif (do_arming_checks) {\n\t\t\tif (check_arming_checks(method)) {\n\t\t\t\tsuccess = true;\n\t\t\t}\n\t\t} else {\n\t\t\tsuccess = true;\n\t\t}\n\n\t\tif (success) {\n\t\t\t// set the arming state\n\t\t\t_state = AP_Arming::ARMING;\n\n\t\t\t// set the arming delay flag\n\t\t\t_armed_delay_flag = true;\n\n\t\t\t// send a status text indicating that the throttle is armed\n\t\t\t_status_text.set_text(PSTR(\"Throttle armed\"));\n\n\t\t\t// update the home location\n\t\t\tupdate_home_location();\n\n\t\t\t// update the current location\n\t\t\tupdate_current_location();\n\n\t\t\t// set the arming state\n\t\t\t_state = AP_Arming::ARMED;\n\t\t}\n\t}\n\n\treturn success;\n}\n", "CodeBleu_score": 53.74525222653879}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\t// check if we are already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already in the process of arming\n\tif (arming_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of disarming\n\tif (disarming_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are already in the process of rebooting\n\tif (rebooting_in_progress) {\n\t\treturn false;\n\t}\n\n\t// check if we are", "CodeBleu_score": 21.049688286728703}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\tif (Armed) {\n\t\treturn true;\n\t}\n\n\t// if disarm button is configured, check it\n\tif (disarm_button_configured) {\n\t\tif (disarm_button.is_pressed()) {\n\t\t\tif (display_failure) {\n\t\t\t\tPX4_ERR(\"Disarming not allowed\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// call standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 60.43832712019578}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\tif (Arming.isArmed()) {\n\t\treturn true;\n\t}\n\n\t// check if we have a disarm button\n\tif (Arming.get_disarm_button()!= -1) {\n\t\t// if we have a disarm button, then we need to check that it is not being pressed\n\t\tif (Arming.get_disarm_button() == _disarm_button) {\n\t\t\t// if it is, display a failure message and return false\n\t\t\tif (display_failure) {\n\t\t\t\t_warn_disarm_button_pressed = true;\n\t\t\t\t_warn_disarm_button_timer.set(5000);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if we get here, then we don't have a disarm button, or the disarm button is not being pressed\n\t// so we can call the standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 56.239563083541924}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\t// Check if already armed\n\tif (armed()) {\n\t\treturn true;\n\t}\n\n\t// Check if disarm button is configured\n\tif (disarm_button_configured()) {\n\t\t// Check if disarm button is pressed\n\t\tif (disarm_button_pressed()) {\n\t\t\t// Disarm button is pressed, so disarm the vehicle\n\t\t\tdisarm();\n\n\t\t\t// Disarming is done, so return true\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Check if we need to display a failure message\n\tif (display_failure) {\n\t\t// Display a failure message\n\t\tif (disarm_button_configured()) {\n\t\t\t// Display a failure message\n\t\t\tif (disarm_button_pressed()) {\n\t\t\t\t// Disarm button is pressed, so display a failure message\n\t\t\t\tif (Arming_failure_message.len() > 0) {\n\t\t\t\t\t// Display the failure message\n\t\t\t\t\tArming_failure_message.display();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Call the standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 54.59605602775399}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat yaw = this->ahrs->getYaw();\n\tfloat cos_yaw = cos(yaw);\n\tfloat sin_yaw = sin(yaw);\n\tfloat ne_x = x * cos_yaw + y * sin_yaw;\n\tfloat ne_y = -x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 55.342559459906745}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat yaw = ahrs.get_yaw();\n\tfloat cos_yaw = cos(yaw);\n\tfloat sin_yaw = sin(yaw);\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 61.851763923013245}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat yaw = ahrs->getYaw();\n\tfloat cos_yaw = cos(yaw);\n\tfloat sin_yaw = sin(yaw);\n\tfloat ne_x = cos_yaw * x - sin_yaw * y;\n\tfloat ne_y = sin_yaw * x + cos_yaw * y;\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 61.283679310574435}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// Check if the yaw angle and param4 values are within acceptable ranges\n\tif (packet.param1 >= -180 && packet.param1 <= 180 && packet.param4 >= -180 && packet.param4 <= 180) {\n\t\t// Set the yaw heading\n\t\tset_yaw_heading(packet.param1);\n\n\t\t// Return MAV_RESULT_ACCEPTED\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\t// Return MAV_RESULT_DENIED\n\treturn MAV_RESULT_DENIED;\n}\n", "CodeBleu_score": 48.323357187346225}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// Check if the yaw angle and param4 values are within acceptable ranges.\n\tif (packet.param1 < 0.0 || packet.param1 > 360.0 || packet.param4 < 0.0 || packet.param4 > 1.0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading.\n\t_yaw_heading = packet.param1;\n\n\t// Return MAV_RESULT_ACCEPTED.\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 42.68553555857555}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// Check if yaw angle is within acceptable range\n\tif (packet.param1 < -180.0 || packet.param1 > 180.0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if yaw speed is within acceptable range\n\tif (packet.param2 < -1.0 || packet.param2 > 1.0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if param4 is within acceptable range\n\tif (packet.param4 < 0.0 || packet.param4 > 1.0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set yaw heading\n\tset_yaw_heading(packet.param1);\n\n\t// Set yaw speed\n\tset_yaw_speed(packet.param2);\n\n\t// Set yaw direction\n\tset_yaw_direction(packet.param4);\n\n\t// Return accepted\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 53.551180883874984}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn (uint8_t) (high_latency_tgt_heading_f / 2.0f);\n}\n", "CodeBleu_score": 6.27244761992602}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn _high_latency_tgt_heading;\n}\n", "CodeBleu_score": 5.801350011259761}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn (uint8_t) (high_latency_tgt_heading_raw() / 2);\n}\n", "CodeBleu_score": 7.245376144305984}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (loggingEnabled) {\n\t\tLogPacket packet;\n\t\tpacket.type = LogPacketType::DATA;\n\t\tpacket.time = Sub::Get_Time();\n\t\tpacket.id = id;\n\t\tpacket.data = value;\n\t\tLogger::Log_Write(packet);\n\t}\n}\n", "CodeBleu_score": 36.26319417750544}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (Sub::loggingEnabled) {\n\t\tLog_Write_Data_Critical(id, value);\n\t}\n}\n", "CodeBleu_score": 17.799246750927374}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tLog_Write_Data_Critical(id, value);\n}\n", "CodeBleu_score": 17.105373476699757}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()\t// If the home is already set, exit\n\tif (home_set) {\n\t\treturn;\n\t}\n\n\t// If the motors are armed, set the home to the current location in-flight\n\tif (motors_armed) {\n\t\thome_set = true;\n\t\thome_location = current_location;\n\t}\n\t// If the motors are not armed, attempt to set the home to the current EKF location\n\telse {\n\t\t// Try to set the home to the current EKF location\n\t\tif (ekf_set_home()) {\n\t\t\t// If the home was set successfully, set the home_set flag\n\t\t\thome_set = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 29.92724796399472}, {"code": "void Sub::update_home_from_EKF()\tif (home_set) return;\n\tif (motors.armed()) {\n\t\thome_set = true;\n\t\thome_ekf = home_ekf_current;\n\t\thome_ekf_current = {0,0,0};\n\t\treturn;\n\t}\n\tif (home_ekf_current.x!= 0 || home_ekf_current.y!= 0 || home_ekf_current.z!= 0) {\n\t\thome_set = true;\n\t\thome_ekf = home_ekf_current;\n\t\thome_ekf_current = {0,0,0};\n\t}\n}\n", "CodeBleu_score": 17.967404368684548}, {"code": "void Sub::update_home_from_EKF()\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (armed) {\n\t\thome_set = true;\n\t\thome_x = EKF_x;\n\t\thome_y = EKF_y;\n\t\thome_z = EKF_z;\n\t\thome_vx = EKF_vx;\n\t\thome_vy = EKF_vy;\n\t\thome_vz = EKF_vz;\n\t\thome_roll = EKF_roll;\n\t\thome_pitch = EKF_pitch;\n\t\thome_yaw = EKF_yaw;\n\t\thome_ax = EKF_ax;\n\t\thome_ay = EKF_ay;\n\t\thome_az = EKF_az;\n\t\thome_lat = EKF_lat;\n\t\thome_lon = EKF_lon;\n\t\thome_alt = EKF_alt;\n\t\thome_climb_rate = EKF_climb_rate;\n\t\thome_ground_speed = EKF_ground_speed;\n\t\thome_heading = EKF_heading;\n\t\thome_mag_x = EKF_mag_x;\n\t\thome_mag_y = EKF_mag_y;\n\t\thome_mag_z = EKF_mag_z;\n\t\thome_baro_alt = EKF_baro_alt;\n\t\thome_gps_alt = EKF_gps_alt;\n\t\thome_gps_fix_type = EKF_gps_fix_type;\n\t\thome_gps_num_sats = EKF_gps_num_sats;\n\t\thome_gps_hdop = EKF_gps_hdop;\n\t\thome_gps_vdop = EKF_gps_vdop;\n\t\thome_gps_tdop = EKF_gps_tdop;\n\t\thome_gps_nsats = EKF_gps_nsats;\n\t\thome_gps_eph = EKF_gps_eph;\n\t\thome_gps_epv = EKF_gps_epv;\n\t\thome_gps_vel_ned_x = EKF_gps_vel_ned_x;\n\t\thome_gps_vel_ned_y = EKF_gps_vel_ned_y;\n\t\thome_gps_vel_", "CodeBleu_score": 9.212218755949584}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()\tif (!isArmed()) {\n\t\tsetThrottle(0);\n\t\tsetSpoolState(SpoolState::UNLIMITED_THROTTLE);\n\t\trelaxAttitudeControllers();\n\t\texit();\n\t}\n\n\tsetThrottle(1);\n\tsetSpoolState(SpoolState::UNLIMITED_THROTTLE);\n\trelaxAttitudeControllers();\n\n\tfloat pitch = getPitch();\n\tfloat roll = getRoll();\n\tfloat yaw = getYaw();\n\n\tfloat pitchRate = getPitchRate();\n\tfloat rollRate = getRollRate();\n\tfloat yawRate = getYawRate();\n\n\tfloat pitchRateLimit = getPitchRateLimit();\n\tfloat rollRateLimit = getRollRateLimit();\n\tfloat yawRateLimit = getYawRateLimit();\n\n\tfloat pitchRateLimited = std::min(std::max(pitchRate, -pitchRateLimit), pitchRateLimit);\n\tfloat rollRateLimited = std::min(std::max(rollRate, -rollRateLimit), rollRateLimit);\n\tfloat yawRateLimited = std::min(std::max(yawRate, -yawRateLimit), yawRateLimit);\n\n\tfloat pitchRateLimitedScaled = pitchRateLimited / pitchRateLimit;\n\tfloat rollRateLimitedScaled = rollRateLimited / rollRateLimit;\n\tfloat yawRateLimitedScaled = yawRateLimited / yawRateLimit;\n\n\tfloat pitchRateLimitedScaledScaled = pitchRateLimitedScaled * pitchRateLimitedScaled;\n\tfloat rollRateLimitedScaledScaled = rollRateLimitedScaled * rollRateLimitedScaled;\n\tfloat yawRateLimitedScaledScaled = yawRateLimitedScaled * yawRateLimitedScaled;\n\n\tfloat pitchRateLimitedScaledScaledScaled = pitchRateLimitedScaledScaled * pitchRateLimitedScaledScaled;\n\tfloat rollRateLimitedScaledScaledScaled = rollRateLimitedScaledScaled * rollRateLimitedScaledScaled;\n\tfloat yawRateLimitedScaledScaledScaled = yawRateLimitedScaledScaled * yawRateLimitedScaledScaled;\n\n\tfloat pitchRateLimitedScaledScaledScaledScaled = pitchRateLimitedScaledScaledScaled * pitchRateLimitedScaledScaledScaled;\n\tfloat rollRateLimitedScaledScaledScaledScaled = rollRateLimitedScaledScaledScaled * rollRateLimitedScaledScaledScaled;\n", "CodeBleu_score": 22.467348084927234}, {"code": "void ModeAcro::run()\tif (!isArmed()) {\n\t\tsetThrottle(0.0);\n\t\tsetSpoolState(SpoolState::UnlimitedThrottle);\n\t\trelaxAttitude();\n\t\texit();\n\t\treturn;\n\t}\n\tsetSpoolState(SpoolState::UnlimitedThrottle);\n\t// convert pilot inputs to desired body frame rates\n\tdouble rollRate = pilot.rollRate();\n\tdouble pitchRate = pilot.pitchRate();\n\tdouble yawRate = pilot.yawRate();\n\t// run the attitude controller with these rates\n\tattitudeController.run(rollRate, pitchRate, yawRate);\n\t// output the pilot's throttle input without angle boost\n\tsetThrottle(pilot.throttle());\n\t// set the forward and lateral motor inputs based on pilot controls\n\tsetMotorInput(MotorInput::Forward, pilot.forward());\n\tsetMotorInput(MotorInput::Lateral, pilot.lateral());\n}\n", "CodeBleu_score": 36.28476260380825}, {"code": "void ModeAcro::run()\t// If the motors are not armed, exit\n\tif (!armed) {\n\t\t// Set throttle to zero\n\t\tthrottle = 0;\n\t\t// Adjust spool state\n\t\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\t\t// Relax attitude controllers\n\t\trelaxAttitudeController();\n\t\t// Exit\n\t\treturn;\n\t}\n\t// Set spool state to unlimited throttle\n\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\t// Convert pilot inputs to desired body frame rates\n\t// TODO: Check that this is correct\n\tdouble rollRate = pilot.rollRate * (1 + (pilot.rollRate > 0? 0.01 : -0.01));\n\tdouble pitchRate = pilot.pitchRate * (1 + (pilot.pitchRate > 0? 0.01 : -0.01));\n\tdouble yawRate = pilot.yawRate * (1 + (pilot.yawRate > 0? 0.01 : -0.01));\n\t// Run attitude controller\n\tattitudeController.run(rollRate, pitchRate, yawRate);\n\t// Set throttle input\n\tthrottle = pilot.throttle;\n\t// Set forward and lateral motor inputs\n\tdouble forwardMotorInput = throttle + attitudeController.getForwardMotorInput();\n\tdouble lateralMotorInput = throttle + attitudeController.getLateralMotorInput();\n\t// Set motor inputs\n\tmotor1.setMotorInput(forwardMotorInput);\n\tmotor2.setMotorInput(lateralMotorInput);\n}\n", "CodeBleu_score": 42.36921412997282}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()\t// Set the mode to position control\n\tmav_mode_t mode;\n\tmode.custom_mode = MAV_MODE_GUIDED_ARMED;\n\tmode.flag_custom_mode = 0;\n\tmode.flag_system_level = 0;\n\tmode.flag_base_mode = 0;\n\tmavlink_msg_set_mode_send(mavlink_channel, &mode);\n\n\t// Set the waypoint destination to the stopping point\n\tmavlink_msg_command_long_send(mavlink_channel, &vehicle.system_id, &vehicle.comp_id, MAV_CMD_NAV_WAYPOINT, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n\t// Set the yaw to default auto yaw mode\n\tmavlink_msg_command_long_send(mavlink_channel, &vehicle.system_id, &vehicle.comp_id, MAV_CMD_CONDITION_YAW, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n}\n", "CodeBleu_score": 35.694374500090554}, {"code": "void ModeGuided::guided_pos_control_start()\t// Set the mode to position control mode\n\tmavros_msgs::SetMode set_mode;\n\tset_mode.request.custom_mode = \"POSCTL\";\n\tif (set_mode_client.call(set_mode) && set_mode.response.mode_sent) {\n\t\tROS_INFO(\"Set mode to POSCTL\");\n\t} else {\n\t\tROS_ERROR(\"Failed to set mode to POSCTL\");\n\t}\n\n\t// Get the stopping point\n\tmavros_msgs::CommandBool arm_cmd;\n\tarm_cmd.request.value = true;\n\tif (arming_client.call(arm_cmd) && arm_cmd.response.success) {\n\t\tROS_INFO(\"Armed\");\n\t} else {\n\t\tROS_ERROR(\"Failed to arm\");\n\t}\n\n\t// Set the waypoint destination\n\tmavros_msgs::CommandTOL takeoff_cmd;\n\ttakeoff_cmd.request.altitude = 5.0;\n\ttakeoff_cmd.request.latitude = 0.0;\n\ttakeoff_cmd.request.longitude = 0.0;\n\ttakeoff_cmd.request.min_pitch = 0.0;\n\ttakeoff_cmd.request.yaw = 0.0;\n\ttakeoff_cmd.request.frame = 3;\n\ttakeoff_cmd.request.type = 0;\n\ttakeoff_cmd.request.current_alt = 0.0;\n\ttakeoff_cmd.request.min_distance = 0.0;\n\tif (takeoff_client.call(takeoff_cmd) && takeoff_cmd.response.success) {\n\t\tROS_INFO(\"Takeoff\");\n\t} else {\n\t\tROS_ERROR(\"Failed to takeoff\");\n\t}\n\n\t// Initialize the waypoint controller\n\tif (waypoint_controller_init()) {\n\t\tROS_INFO(\"Waypoint controller initialized\");\n\t} else {\n\t\tROS_ERROR(\"Failed to initialize waypoint controller\");\n\t}\n\n\t// Set the yaw to default auto yaw mode\n\tmavros_msgs::CommandBool set_yaw_mode;\n\tset_yaw_mode.request.value = false;\n\tif (set_yaw_client.call(set_", "CodeBleu_score": 35.940681726496145}, {"code": "void ModeGuided::guided_pos_control_start()\t// Set the mode to position control mode.\n\tmavros_set_mode_pos_control();\n\n\t// Set the waypoint destination to the stopping point.\n\tmavros_set_waypoint_destination();\n\n\t// Set the yaw to the default auto yaw mode.\n\tmavros_set_yaw_auto();\n}\n", "CodeBleu_score": 6.138360137892597}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()\t// Set the guided mode to velocity controller\n\tset_guided_mode(VELOCITY_CONTROL);\n\n\t// Initialize the vertical maximum speeds and acceleration\n\t// TODO: Make these pilot-defined\n\tvertical_max_speed = 1.0;\n\tvertical_accel = 0.5;\n\n\t// Initialize the vertical and horizontal velocity controllers\n\tvertical_controller.init(vertical_max_speed, vertical_accel);\n\thorizontal_controller.init(horizontal_max_speed, horizontal_accel);\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\tset_yaw_control_mode(AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 29.86694547017659}, {"code": "void ModeGuided::guided_vel_control_start()\t// Initialize vertical maximum speeds and acceleration\n\t_v_max_speed = _params.v_max_speed;\n\t_v_max_accel = _params.v_max_accel;\n\n\t// Initialize vertical and horizontal velocity controllers\n\t_v_controller.init(_v_max_speed, _v_max_accel, _params.v_kp, _params.v_ki, _params.v_kd, _params.v_i_limit, _params.v_i_limit_min, _params.v_i_limit_max, _params.v_i_limit_min_throttle, _params.v_i_limit_max_throttle);\n\t_h_controller.init(_params.h_kp, _params.h_ki, _params.h_kd, _params.h_i_limit, _params.h_i_limit_min, _params.h_i_limit_max, _params.h_i_limit_min_throttle, _params.h_i_limit_max_throttle);\n\n\t// Set yaw control mode\n\t_yaw_controller.set_mode(YawController::YAW_MODE_AUTO_HOLD);\n}\n", "CodeBleu_score": 34.1570846576286}, {"code": "void ModeGuided::guided_vel_control_start()\t// Set the vertical maximum speeds and acceleration\n\tset_vertical_max_speeds(v_max_speed_m_s, v_max_accel_m_s2);\n\t// Initialize the vertical velocity controller\n\tv_vel_control.init(v_max_speed_m_s, v_max_accel_m_s2);\n\t// Initialize the horizontal velocity controller\n\th_vel_control.init(h_max_speed_m_s, h_max_accel_m_s2);\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\tset_yaw_control_mode(AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 28.65467262154564}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()\t// Check if the timeout has been exceeded\n\tif (timeout_check()) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is below the minimum altitude threshold\n\tif (current_alt < alt_min) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is above the maximum altitude threshold\n\tif (current_alt > alt_max) {\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the specified limit\n\tif (horizontal_distance_moved() > guided_distance_limit) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 17.965970393407595}, {"code": "bool ModeGuided::guided_limit_check()\tif (timeout_check()) {\n\t\treturn true;\n\t}\n\tif (alt_check()) {\n\t\treturn true;\n\t}\n\tif (dist_check()) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 10.513172969174994}, {"code": "bool ModeGuided::guided_limit_check()\t// Check if we've exceeded the timeout\n\tif (ros::Time::now() - last_guided_time > ros::Duration(guided_timeout)) {\n\t\tROS_INFO(\"Guided mode timeout exceeded, aborting\");\n\t\treturn true;\n\t}\n\n\t// Check if we're below the minimum altitude\n\tif (current_altitude < guided_min_altitude) {\n\t\tROS_INFO(\"Current altitude below minimum, aborting\");\n\t\treturn true;\n\t}\n\n\t// Check if we're above the maximum altitude\n\tif (current_altitude > guided_max_altitude) {\n\t\tROS_INFO(\"Current altitude above maximum, aborting\");\n\t\treturn true;\n\t}\n\n\t// Check if we've moved too far\n\tif (current_distance > guided_max_distance) {\n\t\tROS_INFO(\"Current distance moved above maximum, aborting\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 25.220284575752522}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()\t// Check if the motor test is enabled\n\tif (!motor_test_enabled)\n\t\treturn true;\n\n\t// Check if the motor test has been started\n\tif (!motor_test_started) {\n\t\t// Check if the motor test has been requested\n\t\tif (motor_test_requested) {\n\t\t\t// Check if the motor test has been requested for more than 10 seconds\n\t\t\tif (ros::Time::now() - motor_test_request_time > ros::Duration(10.0)) {\n\t\t\t\t// If the motor test has been requested for more than 10 seconds, send a timeout message\n\t\t\t\tROS_WARN(\"Motor test timeout.\");\n\t\t\t\t// Set the pass flag to false\n\t\t\t\tpass = false;\n\t\t\t\t// Disable the motor test\n\t\t\t\tmotor_test_enabled = false;\n\t\t\t\t// Disarm the system\n\t\t\t\tdisarm();\n\t\t\t\t// Record the failure time\n\t\t\t\tfailure_time = ros::Time::now();\n\t\t\t\t// Return false\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Check if the motor test has been requested\n\tif (motor_test_requested) {\n\t\t// Check if the motor test has been requested for more than 10 seconds\n\t\tif (ros::Time::now() - motor_test_request_time > ros::Duration(10.0)) {\n\t\t\t// If the motor test has been requested for more than 10 seconds, send a timeout message\n\t\t\tROS_WARN(\"Motor test timeout.\");\n\t\t\t// Set the pass flag to false\n\t\t\tpass = false;\n\t\t\t// Disable the motor test\n\t\t\tmotor_test_enabled = false;\n\t\t\t// Disarm the system\n\t\t\tdisarm();\n\t\t\t// Record the failure time\n\t\t\tfailure_time = ros::Time::now();\n\t\t\t// Return false\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Check if the motor test has timed out\n\tif (ros::Time::now() - motor_test_start_time > ros::Duration(10.0)) {\n\t\t// If the motor test has timed out, send a timeout message\n\t\tROS_WARN(\"Motor test timeout.\");\n\t\t// Set the pass flag to false\n\t\tpass = false;\n\t\t// Disable the motor test\n\t\tmotor_test_enabled = false;\n\t", "CodeBleu_score": 44.705799001050956}, {"code": "bool Sub::verify_motor_test()\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\n\t// Check if the motor test is enabled\n\tif (!motor_test_enabled)", "CodeBleu_score": 26.317091011542853}, {"code": "bool Sub::verify_motor_test()\t// Check if the motor test is enabled.\n\tif (!motor_test_enabled) {\n\t\t// If not, return false.\n\t\treturn false;\n\t}\n\n\t// Get the current time.\n\tdouble current_time = ros::Time::now().toSec();\n\n\t// Check if the motor test has timed out.\n\tif (current_time - motor_test_start_time > motor_test_timeout) {\n\t\t// If so, send a timeout message.\n\t\tROS_WARN(\"Motor test timed out.\");\n\t\t// Set the pass flag to false.\n\t\tmotor_test_pass = false;\n\t\t// Disable the motor test.\n\t\tmotor_test_enabled = false;\n\t\t// Disarm the system.\n\t\tdisarm();\n\t\t// Record the failure time.\n\t\tmotor_test_failure_time = current_time;\n\t\t// Return false.\n\t\treturn false;\n\t}\n\n\t// Check if the motor test has passed.\n\tif (motor_test_pass) {\n\t\t// If so, return true.\n\t\treturn true;\n\t}\n\n\t// Check if the motor test has timed out.\n\tif (current_time - motor_test_start_time > motor_test_timeout) {\n\t\t// If so, send a timeout message.\n\t\tROS_WARN(\"Motor test timed out.\");\n\t\t// Set the pass flag to false.\n\t\tmotor_test_pass = false;\n\t\t// Disable the motor test.\n\t\tmotor_test_enabled = false;\n\t\t// Disarm the system.\n\t\tdisarm();\n\t\t// Record the failure time.\n\t\tmotor_test_failure_time = current_time;\n\t\t// Return false.\n\t\treturn false;\n\t}\n\n\t// Check if the motor test requests are received.\n\tif (motor_test_requests.size() > 0) {\n\t\t// If so, check if the motor test has timed out.\n\t\tif (current_time - motor_test_start_time > motor_test_timeout) {\n\t\t\t// If so, send a timeout message.\n\t\t\tROS_WARN(\"Motor test timed out.\");\n\t\t\t// Set the pass flag to false.\n\t\t\tmotor_test_pass = false;\n\t\t\t// Disable the motor test.\n\t\t\tmotor_test_", "CodeBleu_score": 43.08240996049159}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target, pitch_target;\n\tfloat roll_angle, pitch_angle;\n\tfloat roll_angle_norm, pitch_angle_norm;\n\tfloat roll_angle_max, pitch_angle_max;\n\tfloat roll_angle_min, pitch_angle_min;\n\tfloat roll_angle_min_norm, pitch_angle_min_norm;\n\tfloat roll_angle_max_norm, pitch_angle_max_norm;\n\tfloat roll_angle_range, pitch_angle_range;\n\tfloat roll_angle_range_norm, pitch_angle_range_norm;\n\tfloat roll_angle_range_norm_max, pitch_angle_range_norm_max;\n\tfloat roll_angle_range_norm_min, pitch_angle_range_norm_min;\n\tfloat roll_angle_range_norm_min_norm, pitch_angle_range_norm_min_norm;\n\tfloat roll_angle_range_norm_max_norm, pitch_angle_range_norm_max_norm;\n\tfloat roll_angle_norm_max, pitch_angle_norm_max;\n\tfloat roll_angle_norm_min, pitch_angle_norm_min;\n\tfloat roll_angle_norm_min_norm, pitch_angle_norm_min_norm;\n\tfloat roll_angle_norm_max_norm, pitch_angle_norm_max_norm;\n\tfloat roll_angle_norm_range, pitch_angle_norm_range;\n\tfloat roll_angle_norm_range_norm, pitch_angle_norm_range_norm;\n\tfloat roll_angle_norm_range_norm_max, pitch_angle_norm_range_norm_max;\n\tfloat roll_angle_norm_range_norm_min, pitch_angle_norm_range_norm_min;\n\tfloat roll_angle_norm_range_norm_min_norm, pitch_angle_norm_range_norm_min_norm;\n\tfloat roll_angle_norm_range_norm_max_norm, pitch_angle_norm_range_norm_max_norm;\n\tfloat roll_angle_norm_range_norm_max_norm_max, pitch_angle_norm_range_norm_max_norm", "CodeBleu_score": 7.6898833007333245}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target, pitch_target;\n\t// Get roll and pitch targets from wp_nav in centidegrees\n\troll_target = wp_nav.roll_target * 100;\n\tpitch_target = wp_nav.pitch_target * 100;\n\t// Constrain roll and pitch targets within a specified maximum angle range\n\tif (roll_target > 2000) {\n\t\troll_target = 2000;\n\t}\n\tif (roll_target < -2000) {\n\t\troll_target = -2000;\n\t}\n\tif (pitch_target > 2000) {\n\t\tpitch_target = 2000;\n\t}\n\tif (pitch_target < -2000) {\n\t\tpitch_target = -2000;\n\t}\n\t// Normalize roll and pitch targets\n\troll_target = roll_target / 2000;\n\tpitch_target = pitch_target / 2000;\n\t// Assign normalized values to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}\n", "CodeBleu_score": 26.184540146470113}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target = wp_nav.roll;\n\tfloat pitch_target = wp_nav.pitch;\n\n\t// Constrain roll and pitch targets to the specified maximum angle range\n\tif (roll_target > max_roll_target) roll_target = max_roll_target;\n\telse if (roll_target < -max_roll_target) roll_target = -max_roll_target;\n\tif (pitch_target > max_pitch_target) pitch_target = max_pitch_target;\n\telse if (pitch_target < -max_pitch_target) pitch_target = -max_pitch_target;\n\n\t// Normalize roll and pitch targets to [-1, 1]\n\troll_target = roll_target / max_roll_target;\n\tpitch_target = pitch_target / max_pitch_target;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}\n", "CodeBleu_score": 36.63327506949362}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()\tif (barometer_present) {\n\t\tif (barometer->update()) {\n\t\t\tbarometer_altitude = barometer->getAltitude();\n\t\t\tif (barometer_altitude > 0) {\n\t\t\t\tbarometer_calibration = true;\n\t\t\t}\n\t\t\tif (depth_sensor_present) {\n\t\t\t\tdepth_sensor_health = barometer->getHealth();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 45.626543064896005}, {"code": "void Sub::read_barometer()\t// Read barometer data\n\tbarometer.update();\n\n\t// Update barometer calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer_calibration = barometer.get_altitude();\n\t}\n\n\t// Update sensor health status\n\tif (depth_sensor.is_healthy()) {\n\t\tsensor_health = 0;\n\t} else {\n\t\tsensor_health = 1;\n\t}\n}\n", "CodeBleu_score": 51.98799735521157}, {"code": "void Sub::read_barometer()\t// Read the barometer\n\tbarometer.update();\n\t// Read the depth sensor\n\tif (depth_sensor.is_present()) {\n\t\tdepth_sensor.update();\n\t}\n\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.set_calibration(barometer.get_altitude());\n\t}\n\t// Update the sensor health status based on the barometer's health\n\tif (barometer.is_healthy()) {\n\t\tdepth_sensor.set_health_status(SensorHealthStatus::Healthy);\n\t}\n\telse {\n\t\tdepth_sensor.set_health_status(SensorHealthStatus::Unhealthy);\n\t}\n}\n", "CodeBleu_score": 53.0656922872563}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()\tif (!inertial_navigation_ok()) return false;\n\tif (motors_disarmed()) return true;\n\tif (ekf_in_position_mode()) return false;\n\tif (!ekf_absolute_position_ok()) return false;\n\treturn true;\n}\n", "CodeBleu_score": 8.664580719685775}, {"code": "bool Sub::ekf_position_ok()\tif (!inertial_navigation_ok()) {\n\t\treturn false;\n\t}\n\n\tif (!motors_armed()) {\n\t\treturn true;\n\t}\n\n\tif (ekf_ok()) {\n\t\treturn true;\n\t}\n\n\tif (ekf_status.flags.in_air) {\n\t\treturn false;\n\t}\n\n\tif (ekf_status.flags.hpos_valid) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 31.789236347606796}, {"code": "bool Sub::ekf_position_ok()\tif (!inertial_nav_enabled) {\n\t\treturn false;\n\t}\n\n\tif (!motors_armed) {\n\t\treturn true;\n\t}\n\n\tif (ekf_ok_to_arm) {\n\t\treturn true;\n\t}\n\n\tif (ekf_in_position_mode) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 12.35135376541703}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\t// check if we are armed\n\tif (!armed()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a position control mode\n\tif (control_mode_flags.pos_control) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a velocity control mode\n\tif (control_mode_flags.vel_control) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a manual mode\n\tif (control_mode_flags.manual) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.stabilized) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.acro) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.alt_control) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.acro_pos) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.acro_vel) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.acro_alt) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.acro_pos_vel) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.acro_pos_alt) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.acro_vel_alt) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_flags.acro_pos_vel_alt) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a stabilized mode\n\tif (control_mode_", "CodeBleu_score": 20.537364905024518}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tif (get_control_mode()!= AP_ARMED_MODE_POS_VEL_ALT_HOLD) {\n\t\treturn true;\n\t}\n\n\tif (parent->gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!parent->ahrs->is_ready()) {\n\t\tif (display_failure) {\n\t\t\tparent->console->printf_P(PSTR(\"GPS: AHRS not ready\\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (parent->ekf_failsafe_active()) {\n\t\tif (display_failure) {\n\t\t\tparent->console->printf_P(PSTR(\"GPS: EKF failsafe active\\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!parent->ekf->position_valid()) {\n\t\tif (display_failure) {\n\t\t\tparent->console->printf_P(PSTR(\"GPS: EKF position invalid\\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 44.31022270433189}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\t// check if we are armed and have a GPS lock\n\tif (vehicle_status.armed && vehicle_status.gps_lock) {\n\t\t// check if we have a valid position estimate\n\t\tif (vehicle_status.position_valid) {\n\t\t\t// check if we have a valid velocity estimate\n\t\t\tif (vehicle_status.velocity_valid) {\n\t\t\t\t// check if we have a valid heading estimate\n\t\t\t\tif (vehicle_status.heading_valid) {\n\t\t\t\t\t// check if the AHRS system is ready\n\t\t\t\t\tif (vehicle_status.ahrs_ready) {\n\t\t\t\t\t\t// check if the EKF failsafe is active\n\t\t\t\t\t\tif (!vehicle_status.ekf_failsafe) {\n\t\t\t\t\t\t\t// all checks passed\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// EKF failsafe active\n\t\t\t\t\t\t\tif (display_failure) {\n\t\t\t\t\t\t\t\t// display failure message\n\t\t\t\t\t\t\t\tprintf(\"EKF failsafe active\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// return false\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// AHRS not ready\n\t\t\t\t\t\tif (display_failure) {\n\t\t\t\t\t\t\t// display failure message\n\t\t\t\t\t\t\tprintf(\"AHRS not ready\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// return false\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// heading estimate invalid\n\t\t\t\t\tif (display_failure) {\n\t\t\t\t\t\t// display failure message\n\t\t\t\t\t\tprintf(\"heading invalid\\n\");\n\t\t\t\t\t}\n\t\t\t\t\t// return false\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// velocity estimate invalid\n\t\t\t\tif (display_failure) {\n\t\t\t\t\t// display failure message\n\t\t\t\t\tprintf(\"velocity invalid\\n\");\n\t\t\t\t}\n\t\t\t\t// return false\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t// position estimate invalid\n\t\t\tif (display_failure) {\n\t\t\t\t// display failure message\n\t\t\t\tprintf(\"position invalid\\n\");\n\t\t\t}\n\t\t\t// return false\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// not armed or no GPS lock\n\t\tif (display_failure) {\n\t\t\t// display failure message\n\t\t\tprintf(\"not armed or no GPS lock\\n\");\n\t\t}\n\t\t// return false\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 30.586894775369256}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\t// check if we are already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we have a valid home position\n\tif (home_pos.is_valid() == false) {\n\t\t// no home position, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in manual mode\n\tif (is_manual()) {\n\t\t// we are in manual mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in RTL mode\n\tif (is_rtl()) {\n\t\t// we are in RTL mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in guided mode\n\tif (is_guided()) {\n\t\t// we are in guided mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in stabilized mode\n\tif (is_stabilized()) {\n\t\t// we are in stabilized mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in altitude mode\n\tif (is_altitude()) {\n\t\t// we are in altitude mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in mission mode\n\tif (is_mission()) {\n\t\t// we are in mission mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in acro mode\n\tif (is_acro()) {\n\t\t// we are in acro mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in auto mode\n\tif (is_auto()) {\n\t\t// we are in auto mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in sport mode\n\tif (is_sport()) {\n\t\t// we are in sport mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in loiter mode\n\tif (is_loiter()) {\n\t\t// we are in loiter mode, can't arm\n\t\treturn false;\n\t}\n\n\t// check if we are in circle mode\n\tif (is_circle()) {\n\t\t// we are in circle mode, can't arm\n\t\t", "CodeBleu_score": 16.87557252648}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\tif (do_arming_checks) {\n\t\t// check for arming failure\n\t\tif (check_arming_failure()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// arm the rover\n\tswitch (method) {\n\tcase AP_Arming::Method::MANUAL:\n\t\tmanual_arm();\n\t\tbreak;\n\tcase AP_Arming::Method::AUTO:\n\t\tauto_arm();\n\t\tbreak;\n\tcase AP_Arming::Method::AUTO_SIMPLE:\n\t\tauto_simple_arm();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t// set the home location\n\tif (vehicle.home_position.is_valid()) {\n\t\tvehicle.home_position.set_position(vehicle.home_position.lat, vehicle.home_position.lng, vehicle.home_position.alt);\n\t}\n\n\t// set the heading for simple mode\n\tif (vehicle.simple_mode_heading.is_valid()) {\n\t\tvehicle.simple_mode_heading.set_heading(vehicle.simple_mode_heading.heading);\n\t}\n\n\t// update the soft armed status\n\tvehicle.soft_armed = true;\n\n\t// send an arm/disarm status text\n\tvehicle.send_arm_status_text();\n\n\treturn true;\n}\n", "CodeBleu_score": 32.86349003386177}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\tif (do_arming_checks) {\n\t\t// check if we are already armed\n\t\tif (is_armed()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are already in manual mode\n\t\tif (is_manual()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a safe mode\n\t\tif (is_safe()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a failsafe mode\n\t\tif (is_failsafe()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a pre-arm mode\n\t\tif (is_prearm()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarming()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarmed()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarming_failed()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarmed_failed()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarming_prearm()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarmed_prearm()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarming_failed_prearm()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarmed_failed_prearm()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarming_failed_prearm_disarmed()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a disarming mode\n\t\tif (is_disarmed_failed_prearm_disarmed()) {\n\t\t\treturn true;\n\t", "CodeBleu_score": 13.274912944842995}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_enabled_time = millis();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = millis();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.929515511106207}, {"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_enabled_time = millis();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_enabled_time = millis();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 28.781403350466906}, {"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_enabled_time = millis();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = millis();\n\t\t} else {\n\t\t\tif (millis() - charging_disabled_time > charging_retry_delay) {\n\t\t\t\tcharging_retry_delay = charging_retry_delay * 2;\n\t\t\t\tif (charging_retry_delay > max_charging_retry_delay) {\n\t\t\t\t\tcharging_retry_delay = max_charging_retry_delay;\n\t\t\t\t}\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_enabled_time = millis();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 51.09652133303106}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)\tif (ros::master::check()) {\n\t\tif (size >= 4) {\n\t\t\tuint8_t crc = crc8(message, size - 1);\n\t\t\tmemcpy(((uint8_t*) message) + size - 1, &crc, 1);\n\t\t\tpacketSerial.send(message, size);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.88744733213034}, {"code": "void sendMessage(void *message, size_t size)\tif (ros::ok()) {\n\t\tif (size >= 4) {\n\t\t\tuint8_t crc = crc8(message, size - 1);\n\t\t\tuint8_t *msg = (uint8_t *) malloc(size + 1);\n\t\t\tmemcpy(msg, message, size);\n\t\t\tmsg[size] = crc;\n\t\t\tpacketSerial.send(msg, size + 1);\n\t\t\tfree(msg);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.67080825417557}, {"code": "void sendMessage(void *message, size_t size)\tif (ros::master::check() && size >= 4) {\n\t\tuint8_t *msg = (uint8_t *) message;\n\t\tuint32_t crc = crc32(0, msg, size);\n\t\tmsg[size] = (uint8_t) (crc >> 24);\n\t\tmsg[size + 1] = (uint8_t) (crc >> 16);\n\t\tmsg[size + 2] = (uint8_t) (crc >> 8);\n\t\tmsg[size + 3] = (uint8_t) (crc);\n\t\tpacketSerial.send(msg, size + 4);\n\t}\n}\n", "CodeBleu_score": 49.15769860223027}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()\tif (Serial1.begin(9600)) {\n\t\tSerial1.write(0x7E);\n\t\tSerial1.write(0xFF);\n\t\tSerial1.write(0x06);\n\t\tSerial1.write(0x03);\n\t\tSerial1.write(0x00);\n\t\tSerial1.write(0x00);\n\t\tSerial1.write(0x00);\n\t\tSerial1.write(0x00);\n\t\tSerial1.write(0xEF);\n\t\tdelay(100);\n\t\tif (Serial1.available() >= 6) {\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t\tSerial1.read();\n\t\t", "CodeBleu_score": 32.6488664164147}, {"code": "bool MP3Sound::begin()\tif (serial) {\n\t\tserial->begin(9600);\n\t\tserial->write(\"Q\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"S\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"I\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"T\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"L\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"V\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"P\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"M\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"R\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"U\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"C\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"F\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"A\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"E\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"Q\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"S\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"I\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"T\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t\tserial->write(\"L\\r\\n\");\n\t\tserial->flush();\n\t\tdelay(100);\n\t", "CodeBleu_score": 38.878602430422205}, {"code": "bool MP3Sound::begin()\tSerial.begin(9600);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x09);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x09);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x09);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x09);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(100);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x09);\n\tSerial.", "CodeBleu_score": 33.314467239425}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()\tint n = 0;\n\tif (this->mp3Playing) {\n\t\tn = this->activeSounds.size();\n\t}\n\telse {\n\t\tif (this->activeSounds.size() > 0) {\n\t\t\tn = this->activeSounds.size();\n\t\t\tthis->mp3Playing = true;\n\t\t\tthis->mp3->play(this->activeSounds.front().first);\n\t\t\tthis->activeSounds.pop_front();\n\t\t}\n\t}\n\treturn n;\n}\n", "CodeBleu_score": 22.590654588746407}, {"code": "int MP3Sound::processSounds()\tif (mp3.isPlaying()) {\n\t\treturn mp3.getSoundCount();\n\t}\n\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tmp3.play(activeSounds.back());\n\tactiveSounds.pop_back();\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 40.5413544224041}, {"code": "int MP3Sound::processSounds()\tif (this->sounds.size() == 0) {\n\t\treturn this->sounds.size();\n\t}\n\tif (this->mp3 == NULL) {\n\t\tif (this->sounds.size() > 0) {\n\t\t\tthis->mp3 = this->sounds.front();\n\t\t\tthis->sounds.pop_front();\n\t\t\tthis->mp3->play();\n\t\t}\n\t\treturn this->sounds.size();\n\t}\n\treturn this->sounds.size();\n}\n", "CodeBleu_score": 12.413376923770802}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)#ifdef _WIN32\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    WbMemoryMappedFile *mmf = reinterpret_cast<WbMemoryMappedFile *>(r->data);\n    if (mmf) {\n      if (d->m_memory_mapped_file)\n        delete d->m_memory_mapped_file;\n      d->m_memory_mapped_file = new WbMemoryMappedFile(mmf->m_filename.c_str(), mmf->m_size);\n      delete mmf;\n    }\n    return true;\n  }", "CodeBleu_score": 29.86015177659562}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)\tWbAbstractCamera *camera = static_cast<WbAbstractCamera *>(d);\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE: {\n\t\t\tif (camera->memory_mapped_file)\n\t\t\t\tdelete camera->memory_mapped_file;\n\n\t\t\tif (r->has_data()) {\n\t\t\t\tcamera->memory_mapped_file = new WbMemoryMappedFile(r->data(), r->data_size());\n\t\t\t\tcamera->command_handled = true;\n\t\t\t} else\n\t\t\t\tcamera->command_handled = false;\n\n\t\t\treturn true;\n\t\t}\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 39.14501769500024}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)\tWbAbstractCamera *c = (WbAbstractCamera *)d;\n\tif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\t\tif (c->memory_mapped_file)\n\t\t\twb_abstract_camera_delete_memory_mapped_file(c);\n\n\t\tconst char *filename = wb_request_get_string(r, \"filename\");\n\t\tif (filename) {\n\t\t\tc->memory_mapped_file = wb_abstract_camera_create_memory_mapped_file(c, filename);\n\t\t\tif (!c->memory_mapped_file)\n\t\t\t\twb_request_set_error(r, \"Could not open memory-mapped file %s\", filename);\n\t\t} else\n\t\t\twb_request_set_error(r, \"Missing filename argument\");\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 25.73535737745678}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)#ifdef WB_WINDOWS\n  return d->camera->height;", "CodeBleu_score": 4.88799764037756}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)#ifdef _WIN32\n  WbDevice *w = (WbDevice *)d;\n  if (w->type == WB_DEVICE_CAMERA) {\n    if (w->camera_data)\n      return w->camera_data->height;\n  }", "CodeBleu_score": 36.986536851451305}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)#ifdef _WIN32\n  return d->data->height;", "CodeBleu_score": 4.548490070986673}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tint sampling_period;\n\tWbMutexLocker locker(&mutex);\n\tWbAccelerometer *accelerometer = get_accelerometer(tag);\n\tif (accelerometer) {\n\t\tsampling_period = accelerometer->sampling_period;\n\t} else {\n\t\tprintf(\"Error: The accelerometer with tag %d does not exist.\\n\", tag);\n\t\tsampling_period = 0;\n\t}\n\tlocker.unlock();\n\treturn sampling_period;\n}\n", "CodeBleu_score": 39.339716750637706}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tint sampling_period = 0;\n\tWbMutexLocker locker(mutex);\n\tWbAccelerometer *accelerometer = get_accelerometer(tag);\n\tif (accelerometer) {\n\t\tsampling_period = accelerometer->sampling_period;\n\t} else {\n\t\tprintf(\"Error: accelerometer with tag %d does not exist.\\n\", tag);\n\t}\n\treturn sampling_period;\n}\n", "CodeBleu_score": 40.84531784396655}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tint sampling_period;\n\tWbMutex *mutex;\n\tWbAccelerometer *accelerometer;\n\n\tmutex = wb_mutex_lock_timeout(wb_accelerometer_mutex, 1000);\n\tif (mutex == NULL) {\n\t\twb_robot_error(\n\t\t\t\"wb_accelerometer_get_sampling_period: \"\n\t\t\t\"failed to lock mutex\");\n\t\treturn 0;\n\t}\n\n\taccelerometer = wb_accelerometer_get_struct_from_tag(tag);\n\tif (accelerometer == NULL) {\n\t\twb_robot_error(\n\t\t\t\"wb_accelerometer_get_sampling_period: \"\n\t\t\t\"invalid device tag\");\n\t\twb_mutex_unlock(mutex);\n\t\treturn 0;\n\t}\n\n\tsampling_period = accelerometer->sampling_period;\n\n\twb_mutex_unlock(mutex);\n\treturn sampling_period;\n}\n", "CodeBleu_score": 42.31802024864194}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}\n", "CodeBleu_score": 38.78044514384802}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring s = string(dms);\n\tfree(dms);\n\treturn s;\n}\n", "CodeBleu_score": 42.53048222836237}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tstring result;\n\tchar *temp = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tresult = temp;\n\tfree(temp);\n\treturn result;\n}\n", "CodeBleu_score": 42.29903946375912}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdGeomBoxData *data;\n\tdReal dx, dy, dz, d;\n\n\tdGeomSetPosition(g, x, y, z);\n\td = dGeomBoxGetPosition(g);\n\tdata = (dGeomBoxData *) dGeomGetData(g);\n\n\tdx = d - data->x;\n\tdy = d - data->y;\n\tdz = d - data->z;\n\n\tif (dx < data->dx) {\n\t\tplane[0] = -1;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t\tplane[3] = data->x - x;\n\t} else if (dx > data->dx) {\n\t\tplane[0] = 1;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t\tplane[3] = data->x + data->dx - x;\n\t} else {\n\t\tplane[0] = 0;\n\t\tplane[1] = -1;\n\t\tplane[2] = 0;\n\t\tplane[3] = data->y - y;\n\t}\n\n\tif (dy < data->dy) {\n\t\tplane[0] = plane[0] * data->dy;\n\t\tplane[1] = plane[1] * data->dy;\n\t\tplane[2] = plane[2] * data->dy;\n\t\tplane[3] = plane[3] * data->dy;\n\t} else if (dy > data->dy) {\n\t\tplane[0] = plane[0] * data->dy;\n\t\tplane[1] = plane[1] * data->dy;\n\t\tplane[2] = plane[2] * data->dy;\n\t\tplane[3] = plane[3] * data->dy;\n\t} else {\n\t\tplane[0] = plane[0] * data->dz;\n\t\tplane[1] = plane[1] * data->dz;\n\t\tplane[2] = plane[2] * data->dz;\n\t\tplane[3] = plane[3] * data->dz;\n\t}\n\n\tif (dz < data->dz) {\n\t\tplane[0] = plane[0] * data->dz;\n\t\tplane", "CodeBleu_score": 27.263586837603114}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdGeomBoxData *box;\n\n\tif (!dGeomIsBox (g)) {\n\t\tdGeomSetPlane (g, 0, 0, 0, 0);\n\t\treturn;\n\t}\n\n\tbox = (dGeomBoxData *) dGeomGetData (g);\n\n\tif (x < box->pos[0]) {\n\t\tplane[0] = -1;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t\tplane[3] = box->pos[0] - x;\n\t\treturn;\n\t}\n\tif (x > box->pos[0] + box->size[0]) {\n\t\tplane[0] = 1;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t\tplane[3] = x - (box->pos[0] + box->size[0]);\n\t\treturn;\n\t}\n\tif (y < box->pos[1]) {\n\t\tplane[0] = 0;\n\t\tplane[1] = -1;\n\t\tplane[2] = 0;\n\t\tplane[3] = box->pos[1] - y;\n\t\treturn;\n\t}\n\tif (y > box->pos[1] + box->size[1]) {\n\t\tplane[0] = 0;\n\t\tplane[1] = 1;\n\t\tplane[2] = 0;\n\t\tplane[3] = y - (box->pos[1] + box->size[1]);\n\t\treturn;\n\t}\n\tif (z < box->pos[2]) {\n\t\tplane[0] = 0;\n\t\tplane[1] = 0;\n\t\tplane[2] = -1;\n\t\tplane[3] = box->pos[2] - z;\n\t\treturn;\n\t}\n\tif (z > box->pos[2] + box->size[2]) {\n\t\tplane[0] = 0;\n\t\tplane[1] = 0;\n\t\tplane[2] = 1;\n\t\tplane[3] = z - (box->pos[2] + box->size[2]);\n\t\treturn;\n\t}\n\n\tplane[0] = 0;", "CodeBleu_score": 21.339999073365206}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdGeomBoxData *box = (dGeomBoxData *)dGeomGetData (g);\n\tdVector3 pos;\n\tdReal dist;\n\tdReal min, max, size;\n\tint i;\n\n\tif (dGeomGetClass (g)!= dBoxClass) {\n\t\tdGeomGetPosition (g, pos);\n\t\tdVector3Subtract (pos, &x, &y, &z, pos);\n\t\tdGeomBoxGetTangentPlane (g, pos[0], pos[1], pos[2], plane);\n\t\treturn;\n\t}\n\n\tdVector3Copy (box->pos, pos);\n\tdVector3Subtract (pos, &x, &y, &z, pos);\n\tdVector3Subtract (box->pos, pos, pos);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (pos[i] < 0) {\n\t\t\tmin = pos[i];\n\t\t\tmax = box->size[i];\n\t\t} else {\n\t\t\tmin = -box->size[i];\n\t\t\tmax = pos[i];\n\t\t}\n\t\tif (min > max) {\n\t\t\tsize = min;\n\t\t\tmin = max;\n\t\t\tmax = size;\n\t\t}\n\t\tif (min > 0) {\n\t\t\tplane[i] = 0;\n\t\t\tplane[3] = -min;\n\t\t} else {\n\t\t\tplane[i] = 1;\n\t\t\tplane[3] = -max;\n\t\t}\n\t}\n\tplane[3] = -dDOT (plane, pos);\n}\n", "CodeBleu_score": 35.04158272313066}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tdImmersionGeom *imm;\n\n\tassert(box!= NULL);\n\tassert(fluidPlane!= NULL);\n\tassert(flags!= 0);\n\tassert(immersion!= NULL);\n\n\timm = immersion;\n\timm->box = box;\n\timm->fluidPlane = fluidPlane;\n\timm->flags = flags;\n\n\treturn dImmerseBox2 (imm);\n}\n", "CodeBleu_score": 42.27857792240314}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)#ifdef _DEBUG\n  assert(box!= NULL);\n  assert(fluidPlane!= NULL);\n  assert(immersion!= NULL);\n  assert(box->body!= NULL);\n  assert(box->body->flags & dBodyActive);\n  assert(box->body->flags & dBodyImmersion);\n  assert(box->body->flags & dBodyFluid);\n  assert(box->body->flags & dBodyFluidImmersion);\n  assert(box->body->flags & dBodyFluidImmersionBox);\n  assert(box->body->flags & dBodyFluidImmersionBoxBox);\n  assert(box->body->flags & dBodyFluidImmersionBoxBoxBox);\n  assert(box->body->flags & dBodyFluidImmersionBoxBoxBoxBox);\n  assert(box->body->flags & dBodyFluidImmersionBoxBoxBoxBoxBox);", "CodeBleu_score": 37.79157989658022}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tdReal *p;\n\tdReal *q;\n\tdReal *r;\n\tdReal *s;\n\tdReal *t;\n\tdReal *u;\n\tdReal *v;\n\tdReal *w;\n\tdReal *x;\n\tdReal *y;\n\tdReal *z;\n\tdReal *p1;\n\tdReal *p2;\n\tdReal *p3;\n\tdReal *p4;\n\tdReal *p5;\n\tdReal *p6;\n\tdReal *p7;\n\tdReal *p8;\n\tdReal *p9;\n\tdReal *p10;\n\tdReal *p11;\n\tdReal *p12;\n\tdReal *p13;\n\tdReal *p14;\n\tdReal *p15;\n\tdReal *p16;\n\tdReal *p17;\n\tdReal *p18;\n\tdReal *p19;\n\tdReal *p20;\n\tdReal *p21;\n\tdReal *p22;\n\tdReal *p23;\n\tdReal *p24;\n\tdReal *p25;\n\tdReal *p26;\n\tdReal *p27;\n\tdReal *p28;\n\tdReal *p29;\n\tdReal *p30;\n\tdReal *p31;\n\tdReal *p32;\n\tdReal *p33;\n\tdReal *p34;\n\tdReal *p35;\n\tdReal *p36;\n\tdReal *p37;\n\tdReal *p38;\n\tdReal *p39;\n\tdReal *p40;\n\tdReal *p41;\n\tdReal *p42;\n\tdReal *p43;\n\tdReal *p44;\n\tdReal *p45;\n\tdReal *p46;\n\tdReal *p47;\n\tdReal *p48;\n\tdReal *p49;\n\tdReal", "CodeBleu_score": 7.189302257177428}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdVector3 pos1, pos2;\n\tdVector3 dir1, dir2;\n\tdVector3 normal;\n\tdReal radius, length;\n\tdReal dist;\n\tdReal a, b, c, d, e, f, g, h, i, j, k, l;\n\tdReal x, y, z;\n\tdReal nx, ny, nz;\n\tdReal nx2, ny2, nz2;\n\tdReal nx3, ny3, nz3;\n\tdReal nx4, ny4, nz4;\n\tdReal nx5, ny5, nz5;\n\tdReal nx6, ny6, nz6;\n\tdReal nx7, ny7, nz7;\n\tdReal nx8, ny8, nz8;\n\tdReal nx9, ny9, nz9;\n\tdReal nx10, ny10, nz10;\n\tdReal nx11, ny11, nz11;\n\tdReal nx12, ny12, nz12;\n\tdReal nx13, ny13, nz13;\n\tdReal nx14, ny14, nz14;\n\tdReal nx15, ny15, nz15;\n\tdReal nx16, ny16, nz16;\n\tdReal nx17, ny17, nz17;\n\tdReal nx18, ny18, nz18;\n\tdReal nx19, ny19, nz19;\n\tdReal nx20, ny20, nz20;\n\tdReal nx21, ny21, nz21;\n\tdReal nx22, ny22, nz22;\n\tdReal nx23, ny23, nz23;\n\tdReal nx24, ny24, nz24;\n\tdReal nx25, ny25, nz25;\n\tdReal nx26, ny26, nz26;\n\tdReal nx27, ny27, nz27;\n\tdReal nx28, ny28, nz28;\n\tdReal nx29, ny29, nz2", "CodeBleu_score": 6.944831552942535}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdGeomID g1, g2;\n\tdVector3 pos1, pos2;\n\tdVector3 R1, R2;\n\tdVector3 pos1_old, pos2_old;\n\tdVector3 R1_old, R2_old;\n\tdVector3 box_size;\n\tdVector3 box_pos;\n\tdVector3 box_pos_old;\n\tdVector3 box_R;\n\tdVector3 box_R_old;\n\tdVector3 box_vel;\n\tdVector3 box_vel_old;\n\tdVector3 box_vel_rel;\n\tdVector3 box_vel_rel_old;\n\tdVector3 box_vel_rel_old_old;\n\tdVector3 box_vel_rel_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old_old_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\tdVector3 box_vel_rel_old_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\tdVector3 box", "CodeBleu_score": 4.879241487420984}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdVector3 pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8;\n\tdVector3 normal;\n\tdReal length;\n\tdReal depth;\n\tdReal s, t;\n\tdReal smin, smax, tmin, tmax;\n\tdReal r1, r2;\n\tdReal r12;\n\tdReal r122;\n\tdReal r1222;\n\tdReal r12222;\n\tdReal r122222;\n\tdReal r1222222;\n\tdReal r12222222;\n\tdReal r122222222;\n\tdReal r1222222222;\n\tdReal r12222222222;\n\tdReal r122222222222;\n\tdReal r1222222222222;\n\tdReal r12222222222222;\n\tdReal r122222222222222;\n\tdReal r1222222222222222;\n\tdReal r12222222222222222;\n\tdReal r122222222222222222;\n\tdReal r1222222222222222222;\n\tdReal r12222222222222222222;\n\tdReal r122222222222222222222;\n\tdReal r1222222222222222222222;\n\tdReal r12222222222222222222222;\n\tdReal r1222222222222222222", "CodeBleu_score": 6.696652262468386}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal z = zIOverR;\n\tdReal z2 = z * z;\n\tdReal z3 = z2 * z;\n\tdReal z4 = z3 * z;\n\tdReal z5 = z4 * z;\n\tdReal z6 = z5 * z;\n\tdReal z7 = z6 * z;\n\tdReal z8 = z7 * z;\n\tdReal z9 = z8 * z;\n\tdReal z10 = z9 * z;\n\tdReal z11 = z10 * z;\n\tdReal z12 = z11 * z;\n\tdReal z13 = z12 * z;\n\tdReal z14 = z13 * z;\n\tdReal z15 = z14 * z;\n\tdReal z16 = z15 * z;\n\tdReal z17 = z16 * z;\n\tdReal z18 = z17 * z;\n\tdReal z19 = z18 * z;\n\tdReal z20 = z19 * z;\n\tdReal z21 = z20 * z;\n\tdReal z22 = z21 * z;\n\tdReal z23 = z22 * z;\n\tdReal z24 = z23 * z;\n\tdReal z25 = z24 * z;\n\tdReal z26 = z25 * z;\n\tdReal z27 = z26 * z;\n\tdReal z28 = z27 * z;\n\tdReal z29 = z28 * z;\n\tdReal z30 = z29 * z;\n\tdReal z31 = z30 * z;\n\tdReal z32 = z31 * z;\n\tdReal z33 = z32 * z;\n\tdReal z34 = z33 * z;\n\tdReal z35 = z34 * z;\n\tdReal z36 = z35 * z;\n\tdReal z37 = z36 * z;\n\tdReal z38 = z37 * z;\n\t", "CodeBleu_score": 29.47941123974065}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal zI = zIOverR * r;\n\tdReal zO = zI + r;\n\tdReal zI2 = zI * zI;\n\tdReal zO2 = zO * zO;\n\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal zI2OverR2 = zI2 / zIOverR2;\n\tdReal zO2OverR2 = zO2 / zIOverR2;\n\tdReal zI2OverR3 = zI2OverR2 * zIOverR;\n\tdReal zO2OverR3 = zO2OverR2 * zIOverR;\n\tdReal zI2OverR4 = zI2OverR3 * zIOverR2;\n\tdReal zO2OverR4 = zO2OverR3 * zIOverR2;\n\tdReal zI2OverR5 = zI2OverR4 * zIOverR3;\n\tdReal zO2OverR5 = zO2OverR4 * zIOverR3;\n\tdReal zI2OverR6 = zI2OverR5 * zIOverR4;\n\tdReal zO2OverR6 = zO2OverR5 * zIOverR4;\n\tdReal zI2OverR7 = zI2OverR6 * zIOverR5;\n\tdReal zO2OverR7 = zO2OverR6 * zIOverR5;\n\tdReal zI2OverR8 = zI2OverR7 * zIOverR6;\n\tdReal zO2OverR8 = zO2OverR7 * zIOverR6;\n\tdReal zI2OverR9 = zI2OverR8 * zIOverR7;\n\tdReal zO2OverR9 = zO2OverR8 * zIOverR7;\n\tdReal zI2OverR10 = zI2OverR9 * zIOverR8;\n\tdReal zO2OverR10 = zO2OverR9 * zIOverR8;\n\tdReal zI2OverR11 = z", "CodeBleu_score": 31.505927222290133}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal volume = 0.0;\n\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal zIOverR3 = zIOverR2 * zIOverR;\n\tdReal zIOverR4 = zIOverR3 * zIOverR;\n\tdReal zIOverR5 = zIOverR4 * zIOverR;\n\tdReal zIOverR6 = zIOverR5 * zIOverR;\n\tdReal zIOverR7 = zIOverR6 * zIOverR;\n\tdReal zIOverR8 = zIOverR7 * zIOverR;\n\tdReal zIOverR9 = zIOverR8 * zIOverR;\n\tdReal zIOverR10 = zIOverR9 * zIOverR;\n\tdReal zIOverR11 = zIOverR10 * zIOverR;\n\tdReal zIOverR12 = zIOverR11 * zIOverR;\n\tdReal zIOverR13 = zIOverR12 * zIOverR;\n\tdReal zIOverR14 = zIOverR13 * zIOverR;\n\tdReal zIOverR15 = zIOverR14 * zIOverR;\n\tdReal zIOverR16 = zIOverR15 * zIOverR;\n\tdReal zIOverR17 = zIOverR16 * zIOverR;\n\tdReal zIOverR18 = zIOverR17 * zIOverR;\n\tdReal zIOverR19 = zIOverR18 * zIOverR;\n\tdReal zIOverR20 = zIOverR19 * zIOverR;\n\tdReal zIOverR21 = zIOverR20 * zIOverR;\n\tdReal zIOverR22 = zIOverR21 * zIOverR;\n\tdReal zIOverR23 = zIOverR22 * zIOverR;\n\tdReal zIOverR24 = zIOver", "CodeBleu_score": 31.37226916209167}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal xBuoyancyCenter = 0;\n\tdReal zBuoyancyCenter = 0;\n\tdReal zBuoyancyCenter2 = 0;\n\tdReal zBuoyancyCenter3 = 0;\n\tdReal zBuoyancyCenter4 = 0;\n\tdReal zBuoyancyCenter5 = 0;\n\tdReal zBuoyancyCenter6 = 0;\n\tdReal zBuoyancyCenter7 = 0;\n\tdReal zBuoyancyCenter8 = 0;\n\tdReal zBuoyancyCenter9 = 0;\n\tdReal zBuoyancyCenter10 = 0;\n\tdReal zBuoyancyCenter11 = 0;\n\tdReal zBuoyancyCenter12 = 0;\n\tdReal zBuoyancyCenter13 = 0;\n\tdReal zBuoyancyCenter14 = 0;\n\tdReal zBuoyancyCenter15 = 0;\n\tdReal zBuoyancyCenter16 = 0;\n\tdReal zBuoyancyCenter17 = 0;\n\tdReal zBuoyancyCenter18 = 0;\n\tdReal zBuoyancyCenter19 = 0;\n\tdReal zBuoyancyCenter20 = 0;\n\tdReal zBuoyancyCenter21 = 0;\n\tdReal zBuoyancyCenter22 = 0;\n\tdReal zBuoyancyCenter23 = 0;\n\tdReal zBuoyancyCenter24 = 0;\n\tdReal zBuoyancyCenter25 = 0;\n\tdReal zBuoyancyCenter26 = 0;\n\tdReal zBuoyancyCenter27 = 0;\n\tdReal zBuoyancyCenter28 = 0;\n\tdReal zBuoyancyCenter29 = 0;\n\tdReal zBuoyancyCenter30 = 0;\n\tdReal zBuoyancyCenter31 = 0;\n\tdReal zBuoyancyCenter32 = 0;\n\tdReal zBuoyancyCenter33 = 0;\n\tdReal zBuoyancyCenter34 = 0;", "CodeBleu_score": 9.907121868802536}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\t// Define the variables\n\tdReal xCenter = 0.0;\n\tdReal zCenter = 0.0;\n\tdReal xCenterOld = 0.0;\n\tdReal zCenterOld = 0.0;\n\tdReal xCenterNew = 0.0;\n\tdReal zCenterNew = 0.0;\n\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal tanTheta02 = tanTheta0 * tanTheta0;\n\tdReal sinTheta12 = sinTheta1 * sinTheta1;\n\tdReal zIOverR4 = zIOverR2 * zIOverR2;\n\tdReal tanTheta04 = tanTheta02 * tanTheta02;\n\tdReal sinTheta14 = sinTheta12 * sinTheta12;\n\tdReal zIOverR6 = zIOverR4 * zIOverR2;\n\tdReal tanTheta06 = tanTheta04 * tanTheta02;\n\tdReal sinTheta16 = sinTheta14 * sinTheta12;\n\tdReal zIOverR8 = zIOverR6 * zIOverR2;\n\tdReal tanTheta08 = tanTheta06 * tanTheta02;\n\tdReal sinTheta18 = sinTheta16 * sinTheta12;\n\tdReal zIOverR10 = zIOverR8 * zIOverR2;\n\tdReal tanTheta10 = tanTheta08 * tanTheta02;\n\tdReal sinTheta110 = sinTheta18 * sinTheta12;\n\tdReal zIOverR12 = zIOverR10 * zIOverR2;\n\tdReal tanTheta12 = tanTheta10 * tanTheta02;\n\tdReal sinTheta112 = sinTheta110 * sinTheta12;\n\tdReal zIOverR14 = zIOverR12 * zIOverR2;\n\tdReal tanTheta14 = tanTheta12 * tanTheta02;\n\tdReal sinTheta114 = sinTheta112 * sinTheta12;\n\tdReal zIOver", "CodeBleu_score": 35.84258707092402}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal xBuoyancyCenter = 0.0;\n\tdReal xBuoyancyCenterIntegral = 0.0;\n\tdReal xBuoyancyCenterIntegral_0 = 0.0;\n\tdReal xBuoyancyCenterIntegral_1 = 0.0;\n\tdReal xBuoyancyCenterIntegral_2 = 0.0;\n\tdReal xBuoyancyCenterIntegral_3 = 0.0;\n\tdReal xBuoyancyCenterIntegral_4 = 0.0;\n\tdReal xBuoyancyCenterIntegral_5 = 0.0;\n\tdReal xBuoyancyCenterIntegral_6 = 0.0;\n\tdReal xBuoyancyCenterIntegral_7 = 0.0;\n\tdReal xBuoyancyCenterIntegral_8 = 0.0;\n\tdReal xBuoyancyCenterIntegral_9 = 0.0;\n\tdReal xBuoyancyCenterIntegral_10 = 0.0;\n\tdReal xBuoyancyCenterIntegral_11 = 0.0;\n\tdReal xBuoyancyCenterIntegral_12 = 0.0;\n\tdReal xBuoyancyCenterIntegral_13 = 0.0;\n\tdReal xBuoyancyCenterIntegral_14 = 0.0;\n\tdReal xBuoyancyCenterIntegral_15 = 0.0;\n\tdReal xBuoyancyCenterIntegral_16 = 0.0;\n\tdReal xBuoyancyCenterIntegral_17 = 0.0;\n\tdReal xBuoyancyCenterIntegral_18 = 0.0;\n\tdReal xBuoyancyCenterIntegral_19 = 0.0;\n\tdReal xBuoyancyCenterIntegral_20 = 0.0;\n\tdReal xBuoyancyCenterIntegral_21 = 0.0;\n\tdReal xBuoyancyCenterIntegral_22 = 0.0;\n\tdReal xBuoyancyCenterIntegral_23 = 0.0;\n\tdReal xBuoyancyCenterIntegral_24 = 0.0;\n\tdReal xBuoyancyCenterIntegral_25 = 0.", "CodeBleu_score": 10.413616430592402}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdCapsuleImmersionData *capsuleImmersionData = immersion->capsuleImmersionData;\n\tdTrimeshImmersionData *trimeshImmersionData = immersion->trimeshImmersionData;\n\n\t// Calculate the buoyancy center of the capsule.\n\tdVector3 buoyancyCenter;\n\tdCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(capsuleImmersionData, buoyancyCenter);\n\n\t// Calculate the buoyancy center of the trimesh.\n\tdVector3 trimeshBuoyancyCenter;\n\tdTrimeshImmersionData::immersedHemisphereXBuoyancyCenter(trimeshImmersionData, trimeshBuoyancyCenter);\n\n\t// Calculate the x-coordinate of the buoyancy center.\n\tdouble x = (buoyancyCenter[0] + trimeshBuoyancyCenter[0]) / 2;\n\n\t// Return the x-coordinate of the buoyancy center scaled by the radius and adjusted by the volume.\n\treturn (int) (x * trimeshImmersionData->radius * trimeshImmersionData->volume);\n}\n", "CodeBleu_score": 31.67133840887808}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdCapsuleImmersionData *capsuleImmersion = (dCapsuleImmersionData*) immersion;\n\tdCapsuleData *capsule = (dCapsuleData*) o1;\n\tdTrimeshData *trimesh = (dTrimeshData*) o2;\n\tdVector3 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99, v100, v101, v102, v103, v104, v105, v106, v107, v108, v109, v110, v11", "CodeBleu_score": 17.579333224955423}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdCapsuleData *capsule = (dCapsuleData *) o1->data;\n\tdTrimeshData *trimesh = (dTrimeshData *) o2->data;\n\tdImmersionData *immersed = (dImmersionData *) immersion->data;\n\tdVector3 buoyancyCenter;\n\tdVector3 normal;\n\tdVector3 point;\n\tdReal x;\n\tdReal y;\n\tdReal z;\n\tdReal volume;\n\tdReal radius;\n\tdReal depthRatio;\n\tdReal tangent;\n\tdReal sine;\n\tdReal cosine;\n\tdReal distance;\n\tdReal distanceSquared;\n\tdReal distanceCubed;\n\tdReal distanceToBuoyancyCenter;\n\tdReal distanceToBuoyancyCenterSquared;\n\tdReal distanceToBuoyancyCenterCubed;\n\tdReal distanceToBuoyancyCenterToTheFourth;\n\tdReal distanceToBuoyancyCenterToTheEighth;\n\tdReal distanceToBuoyancyCenterToTheSixteenth;\n\tdReal distanceToBuoyancyCenterToTheThirtySecond;\n\tdReal distanceToBuoyancyCenterToTheSixtyFourth;\n\tdReal distanceToBuoyancyCenterToTheOneTwentyEighth;\n\tdReal distanceToBuoyancyCenterToTheTwoFiftySixth;\n\tdReal distanceToBuoyancyCenterToTheFiveHundredTwentyEighth;\n\tdReal distanceToBuoyancyCenterToTheOneHundredTwentyEighth;\n\tdReal distanceToBuoyancyCenterToTheTwoHundredFiftySixth;\n\tdReal distanceToBuoyancyCenterToTheFourHundredNinetySixth;\n\tdReal distanceToBuoyancyCenterToTheOneThousandTwentyEighth;\n\tdReal distanceToBuoyancyCenterToTheTwoThousandFiftySixth;\n\tdReal distanceToBuoyancyCenterToTheFourThousandNinetySixth;\n\tdReal distanceToBuoyancyCenterToTheOneThousandTwentyEighth;\n\tdReal distanceToBuoyancyCenterToTheTwoThousandFiftySixth;\n\tdReal distanceToBuoyancyCenterTo", "CodeBleu_score": 20.259170627312663}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()\tif (this->duration_ == 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\tthis->status_ = NodeStatus::RUNNING;\n\tthis->timer_waiting_ = true;\n\tthis->timer_.expires_from_now(std::chrono::milliseconds(this->duration_));\n\tthis->timer_.async_wait([this](const boost::system::error_code& ec) {\n\t\tif (!ec) {\n\t\t\tthis->timer_waiting_ = false;\n\t\t\tthis->status_ = NodeStatus::SUCCESS;\n\t\t\tthis->emitWakeUpSignal();\n\t\t} else {\n\t\t\tthis->timer_waiting_ = false;\n\t\t}\n\t});\n\treturn NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 34.919549848197676}, {"code": "NodeStatus SleepNode::onStart()\tif (this->getDuration() <= 0) {\n\t\tthis->setStatus(NodeStatus::SUCCESS);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\tthis->setStatus(NodeStatus::RUNNING);\n\tthis->timer_waiting_ = false;\n\tthis->timer_ = this->getDuration();\n\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration();\n\tthis->timer_ = this->getDuration", "CodeBleu_score": 11.675027004106049}, {"code": "NodeStatus SleepNode::onStart()\t// Get sleep duration from input\n\tdouble sleep_duration;\n\tif (!getParam(\"sleep_duration\", sleep_duration)) {\n\t\treturn SUCCESS;\n\t}\n\t// Check if duration is positive\n\tif (sleep_duration <= 0) {\n\t\treturn SUCCESS;\n\t}\n\t// Set node status to running\n\tsetStatus(RUNNING);\n\t// Start timer\n\ttimer_.start(sleep_duration * 1000000);\n\t// Set callback\n\ttimer_.setCallback(boost::bind(&SleepNode::onTimer, this));\n\treturn SUCCESS;\n}\n", "CodeBleu_score": 33.89848898308302}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()\tif (!m_entry) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tstd::unique_lock<std::mutex> lock(m_entry->m_mutex);\n\tif (m_entry->m_sequenceID!= m_lastSequenceID) {\n\t\tm_lastSequenceID = m_entry->m_sequenceID;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\treturn NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 33.33915094161321}, {"code": "NodeStatus EntryUpdatedAction::tick()\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (blackboard->getEntry(entryName)!= nullptr) {\n\t\tif (blackboard->getEntry(entryName)->getSequenceId()!= sequenceId) {\n\t\t\tsequenceId = blackboard->getEntry(entryName)->getSequenceId();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\treturn NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 33.14320074797805}, {"code": "NodeStatus EntryUpdatedAction::tick()\tif (m_blackboard->getEntry(m_entryName) == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tstd::lock_guard<std::mutex> lock(m_blackboard->getEntry(m_entryName)->mutex);\n\tif (m_blackboard->getEntry(m_entryName)->sequenceID == m_sequenceID) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tm_sequenceID = m_blackboard->getEntry(m_entryName)->sequenceID;\n\treturn NodeStatus::SUCCESS;\n}\n", "CodeBleu_score": 40.960118413338165}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const\tif (m_successThreshold < 0) {\n\t\treturn static_cast<size_t>(-m_successThreshold * m_children.size());\n\t} else {\n\t\treturn static_cast<size_t>(m_successThreshold);\n\t}\n}\n", "CodeBleu_score": 54.18257908975721}, {"code": "size_t ParallelNode::successThreshold() const\tif (successThreshold_ < 0) {\n\t\treturn (size_t) (successThreshold_ + (size_t) childNodes_.size());\n\t}\n\treturn (size_t) successThreshold_;\n}\n", "CodeBleu_score": 50.024894989361336}, {"code": "size_t ParallelNode::successThreshold() const\tif (successThreshold_ < 0) {\n\t\treturn static_cast<size_t>(-successThreshold_ / static_cast<double>(children_.size()));\n\t}\n\treturn static_cast<size_t>(successThreshold_);\n}\n", "CodeBleu_score": 52.604093278273645}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// Check if the heartbeat status has changed\n\t\tif (heartbeatStatus!= lastHeartbeatStatus) {\n\t\t\t// If the heartbeat status has changed, update the lastHeartbeatStatus variable\n\t\t\tlastHeartbeatStatus = heartbeatStatus;\n\n\t\t\t// Enable or disable all breakpoints based on the heartbeat status\n\t\t\tif (heartbeatStatus) {\n\t\t\t\tenableAllBreakpoints();\n\t\t\t} else {\n\t\t\t\tdisableAllBreakpoints();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.38717499690845}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\tif (this->heartbeatStatus!= this->heartbeatStatusLast) {\n\t\t\tthis->heartbeatStatusLast = this->heartbeatStatus;\n\n\t\t\tif (this->heartbeatStatus) {\n\t\t\t\tthis->enableAllBreakpoints();\n\t\t\t} else {\n\t\t\t\tthis->disableAllBreakpoints();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 17.30608663322209}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\t// Sleep for 10 milliseconds\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// Get the current time\n\t\tauto now = std::chrono::system_clock::now();\n\n\t\t// Check if the heartbeat has expired\n\t\tif (std::chrono::duration_cast<std::chrono::seconds>(now - lastHeartbeatTime).count() > heartbeatTimeout) {\n\t\t\t// Heartbeat has expired\n\t\t\t// Disable all breakpoints\n\t\t\tenableBreakpoints(false);\n\n\t\t\t// Update the last heartbeat time\n\t\t\tlastHeartbeatTime = now;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.339294729513384}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> bb_dump;\n\tstd::vector<std::string> bb_names = split(bb_list, ',');\n\n\tfor (auto& bb_name : bb_names) {\n\t\tif (bb_name.empty()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tauto subtree = m_blackboard->getSubtree(bb_name);\n\t\tif (subtree) {\n\t\t\tbb_dump.insert(bb_dump.end(), subtree->lock().begin(), subtree->lock().end());\n\t\t}\n\t}\n\n\treturn bb_dump;\n}\n", "CodeBleu_score": 40.21996244684314}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> result;\n\tstd::vector<std::string> bb_names = split(bb_list, ',');\n\tfor (const auto& bb_name : bb_names) {\n\t\tif (bb_name.empty()) {\n\t\t\tcontinue;\n\t\t}\n\t\tstd::string bb_name_lower = bb_name;\n\t\tstd::transform(bb_name_lower.begin(), bb_name_lower.end(), bb_name_lower.begin(), ::tolower);\n\t\tif (bb_name_lower == \"all\") {\n\t\t\tfor (const auto& blackboard : blackboards) {\n\t\t\t\tif (blackboard.second->isValid()) {\n\t\t\t\t\tstd::string bb_json = blackboard.second->exportJSON();\n\t\t\t\t\tresult.insert(result.end(), (uint8_t*)bb_json.c_str(), (uint8_t*)(bb_json.c_str() + bb_json.size()));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (blackboards.count(bb_name_lower)) {\n\t\t\tif (blackboards[bb_name_lower]->isValid()) {\n\t\t\t\tstd::string bb_json = blackboards[bb_name_lower]->exportJSON();\n\t\t\t\tresult.insert(result.end(), (uint8_t*)bb_json.c_str(), (uint8_t*)(bb_json.c_str() + bb_json.size()));\n\t\t\t}\n\t\t} else {\n\t\t\tstd::cerr << \"Blackboard \" << bb_name << \" not found\" << std::endl;\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 44.89544008838111}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> msgpack_data;\n\tstd::vector<std::string> blackboards;\n\tstd::string bb_list_copy = bb_list;\n\tstd::string bb_name;\n\tstd::string::size_type pos = 0;\n\twhile ((pos = bb_list_copy.find(\",\"))!= std::string::npos) {\n\t\tbb_name = bb_list_copy.substr(0, pos);\n\t\tbb_list_copy.erase(0, pos + 1);\n\t\tblackboards.push_back(bb_name);\n\t}\n\tblackboards.push_back(bb_list_copy);\n\tfor (const auto& bb_name : blackboards) {\n\t\tauto bb_tree = blackboard_manager_->getBlackboardTree(bb_name);\n\t\tif (bb_tree) {\n\t\t\tstd::lock_guard<std::mutex> lock(bb_tree->getMutex());\n\t\t\tif (bb_tree->isValid()) {\n\t\t\t\tstd::string json_str;\n\t\t\t\tbb_tree->exportToJSON(json_str);\n\t\t\t\tmsgpack::sbuffer sbuf;\n\t\t\t\tmsgpack::pack(sbuf, json_str);\n\t\t\t\tmsgpack_data.insert(msgpack_data.end(), sbuf.data(), sbuf.data() + sbuf.size());\n\t\t\t}\n\t\t}\n\t}\n\treturn msgpack_data;\n}\n", "CodeBleu_score": 42.702971462723994}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_nodes.find(node_uid) == m_nodes.end()) {\n\t\treturn false;\n\t}\n\tNode* node = m_nodes[node_uid];\n\tif (node->getStatus()!= NodeStatus::READY) {\n\t\treturn false;\n\t}\n\tif (node->getHook() == nullptr) {\n\t\treturn false;\n\t}\n\tHook* hook = node->getHook();\n\tif (hook->getMode()!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->setStatus(result);\n\thook->setRemove(remove);\n\thook->setReady(true);\n\thook->notifyAll();\n\treturn true;\n}\n", "CodeBleu_score": 39.20210017192196}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Check if the node exists and is valid\n\tif (!groot2_node_exists(pos, node_uid)) {\n\t\treturn false;\n\t}\n\n\t// Retrieve the hook\n\tHook *hook = groot2_get_hook(pos, node_uid);\n\n\t// Lock the mutex\n\tpthread_mutex_lock(&hook->mutex);\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (hook->mode!= HOOK_MODE_BREAKPOINT) {\n\t\t// Unlock the mutex\n\t\tpthread_mutex_unlock(&hook->mutex);\n\n\t\treturn false;\n\t}\n\n\t// Set the desired status and removal flag\n\thook->status = result;\n\thook->remove = remove;\n\n\t// Mark the hook as ready\n\thook->ready = true;\n\n\t// Notify all waiting threads\n\tpthread_cond_broadcast(&hook->cond);\n\n\t// Unlock the mutex\n\tpthread_mutex_unlock(&hook->mutex);\n\n\treturn true;\n}\n", "CodeBleu_score": 37.042567891676306}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Get the node by its UID\n\tNode* node = getNodeByUID(node_uid);\n\n\t// Check if the node exists and is valid\n\tif (!node ||!node->isValid()) {\n\t\treturn false;\n\t}\n\n\t// Get the associated hook\n\tHook* hook = node->getHook();\n\n\t// Lock the hook mutex\n\tstd::unique_lock<std::mutex> lock(hook->getMutex());\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (hook->getMode()!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// Set the desired status and removal flag\n\thook->setDesiredStatus(result);\n\thook->setRemoveFlag(remove);\n\n\t// Mark the hook as ready\n\thook->setReady(true);\n\n\t// Notify all waiting threads\n\thook->getCondVar().notify_all();\n\n\treturn true;\n}\n", "CodeBleu_score": 36.08791200657969}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tthread_ = std::thread(&ThreadedAction::tick, this);\n\t}\n\n\tif (!halt_requested_) {\n\t\tstatus_ = NodeStatus::SUCCESS;\n\t} else {\n\t\tstatus_ = NodeStatus::IDLE;\n\t}\n\n\tif (exception_) {\n\t\tthrow *exception_;\n\t}\n\n\treturn status_;\n}\n", "CodeBleu_score": 21.67247701271099}, {"code": "NodeStatus BT::ThreadedAction::executeTick()\tNodeStatus status = NodeStatus::IDLE;\n\ttry {\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\t\tstatus_ = NodeStatus::RUNNING;\n\t\t\thalt_requested_ = false;\n\t\t\tstd::thread thread(&ThreadedAction::executeTickThread, this);\n\t\t\tthread.detach();\n\t\t} else if (status_ == NodeStatus::RUNNING) {\n\t\t\tif (halt_requested_) {\n\t\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t\t\thalt_requested_ = false;\n\t\t\t} else {\n\t\t\t\tstatus_ = NodeStatus::SUCCESS;\n\t\t\t}\n\t\t}\n\t} catch (std::exception& e) {\n\t\tstatus_ = NodeStatus::IDLE;\n\t\thalt_requested_ = false;\n\t\tif (stored_exception_) {\n\t\t\tstored_exception_->rethrow();\n\t\t}\n\t\tstored_exception_ = std::make_unique<std::exception>(e);\n\t\tthrow std::exception(e);\n\t}\n\treturn status_;\n}\n", "CodeBleu_score": 38.27153534468397}, {"code": "NodeStatus BT::ThreadedAction::executeTick()\tNodeStatus status = NodeStatus::IDLE;\n\ttry {\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\t\tstatus_ = NodeStatus::RUNNING;\n\t\t\thalt_requested_ = false;\n\t\t\tthread_ = std::thread(&ThreadedAction::tick, this);\n\t\t}\n\t\tif (!halt_requested_) {\n\t\t\tstatus = status_;\n\t\t}\n\t\tif (stored_exception_) {\n\t\t\tthrow *stored_exception_;\n\t\t}\n\t} catch (std::exception& e) {\n\t\tstatus_ = NodeStatus::IDLE;\n\t\tROS_ERROR_STREAM(\"Exception caught in ThreadedAction::executeTick: \" << e.what());\n\t\tstored_exception_ = new std::exception(e);\n\t}\n\treturn status;\n}\n", "CodeBleu_score": 33.721448282360534}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tstream << \"-----------------------------------------------------\" << std::endl;\n\tstream << root_node->getName() << std::endl;\n\tstream << \"-----------------------------------------------------\" << std::endl;\n\tprintTreeRecursively(root_node->getChild(), stream);\n\tprintTreeRecursively(root_node->getDecorator(), stream);\n}\n", "CodeBleu_score": 24.059329547842655}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\n\tauto lambda = [&stream](const TreeNode* node, int depth) {\n\t\tstream << std::string(depth * 2,'') << node->getName() << std::endl;\n\t\tif (node->getType() == TreeNode::Type::Control) {\n\t\t\tfor (const auto& child : dynamic_cast<const ControlNode*>(node)->getChildren()) {\n\t\t\t\tlambda(child, depth + 1);\n\t\t\t}\n\t\t} else {\n\t\t\tauto child = dynamic_cast<const DecoratorNode*>(node)->getChild();\n\t\t\tlambda(child, depth + 1);\n\t\t}\n\t};\n\n\tstream << \"Tree Structure\" << std::endl;\n\tlambda(root_node, 0);\n\tstream << \"End of Tree Structure\" << std::endl;\n}\n", "CodeBleu_score": 37.18323595822412}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tauto printNode = [stream](const TreeNode* node) {\n\t\tfor (int i = 0; i < node->getDepth(); i++) {\n\t\t\tstream << \"    \";\n\t\t}\n\t\tstream << node->getName() << std::endl;\n\t\tfor (auto child : node->getChildren()) {\n\t\t\tprintNode(child);\n\t\t}\n\t};\n\tstream << \"----------------------------------------\" << std::endl;\n\tprintNode(root_node);\n\tstream << \"----------------------------------------\" << std::endl;\n}\n", "CodeBleu_score": 36.75556918081727}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow LogicError(\"The node is null.\");\n\t}\n\tvisitor(node);\n\tif (node->isControlNode()) {\n\t\tfor (const auto& child : node->getChildren()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t}\n\telse if (node->isDecoratorNode()) {\n\t\tapplyRecursiveVisitor(node->getChild(), visitor);\n\t}\n}\n", "CodeBleu_score": 44.293430933540954}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow LogicError(\"Cannot apply visitor to null node.\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->isControlNode()) {\n\t\tfor (const auto& child : node->getChildren()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->isDecoratorNode()) {\n\t\tapplyRecursiveVisitor(node->getChild(), visitor);\n\t}\n}\n", "CodeBleu_score": 44.65999049723553}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow LogicError(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (node->isControlNode()) {\n\t\tfor (const auto& child : node->getChildren()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->isDecoratorNode()) {\n\t\tapplyRecursiveVisitor(node->getChild(), visitor);\n\t}\n}\n", "CodeBleu_score": 44.72121483371739}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tif (builders_.find(manifest.registrationID)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"Builder for \" + manifest.registrationID + \" already registered\");\n\t}\n\tbuilders_.insert(std::make_pair(manifest.registrationID, builder));\n\tmanifests_.insert(std::make_pair(manifest.registrationID, manifest));\n}\n", "CodeBleu_score": 50.66056039816813}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tif (builders.count(manifest.registrationId)) {\n\t\tthrow BehaviorTreeException(\"The registration ID '\" + manifest.registrationId + \"' is already registered.\");\n\t}\n\tbuilders[manifest.registrationId] = builder;\n\tmanifests[manifest.registrationId] = manifest;\n}\n", "CodeBleu_score": 42.66249965350336}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tif (builders.find(manifest.registrationId)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"The registration ID '\" + manifest.registrationId + \"' is already registered.\");\n\t}\n\n\tbuilders[manifest.registrationId] = builder;\n\tbuilderManifests[manifest.registrationId] = manifest;\n}\n", "CodeBleu_score": 44.78551835310718}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)#ifdef BT_ENABLE_SERIALIZATION\n  registerBuilder(\n      ID,\n      [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, tick_functor, ports, config);\n      },\n      TreeNodeType::SimpleAction);", "CodeBleu_score": 52.332102571630834}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)#ifdef BEHAVIORTREE_USE_CPP17\n  auto builder = [tick_functor, ports](const std::string& name, const std::string& description) {\n    return std::make_unique<SimpleActionNode>(name, description, tick_functor, ports);\n  };", "CodeBleu_score": 41.09385748003755}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)#ifndef __clang__\n  static_assert(std::is_same<SimpleActionNode::PortsList, PortsList>::value,\n                \"PortsList type of SimpleActionNode is not the same as the PortsList type of BehaviorTreeFactory\");", "CodeBleu_score": 16.08273211334521}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.size());\n\tfor (const auto& subtree : tree) {\n\t\tbackups.emplace_back(subtree->CreateBlackboard());\n\t\t*backups.back() = *subtree->GetBlackboard();\n\t}\n\treturn backups;\n}\n", "CodeBleu_score": 55.78286129940319}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> blackboard_backups;\n\tblackboard_backups.reserve(tree.size());\n\tfor (const auto& subtree : tree) {\n\t\tBlackboard::Ptr blackboard_backup = std::make_shared<Blackboard>(subtree->blackboard);\n\t\tblackboard_backups.push_back(blackboard_backup);\n\t}\n\treturn blackboard_backups;\n}\n", "CodeBleu_score": 49.47294154241805}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.Subtrees().size());\n\n\tfor (const auto& subtree : tree.Subtrees()) {\n\t\tauto backup = Blackboard::Create();\n\t\tbackup->Clone(subtree->Blackboard());\n\t\tbackups.push_back(backup);\n\t}\n\n\treturn backups;\n}\n", "CodeBleu_score": 52.67861474303351}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(env, script);\n\tif (executor) {\n\t\treturn executor->Execute(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}\n", "CodeBleu_score": 71.99656716540674}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (executor.has_value()) {\n\t\treturn executor.value()->Execute(env);\n\t} else {\n\t\treturn std::unexpected(executor.error());\n\t}\n}\n", "CodeBleu_score": 69.7045375022859}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto result = ParseScript(env, script);\n\tif (!result) {\n\t\treturn nonstd::make_unexpected(result.error());\n\t}\n\treturn result.value().Execute(env);\n}\n", "CodeBleu_score": 55.07135457178167}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded = true;\n\tthis->path = path;\n}\n", "CodeBleu_score": 51.10201770945492}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\tif (m_path!= \"\") {\n\t\tthrow RuntimeError(\"SharedLibrary::load: A library is already loaded.\");\n\t}\n\n\tm_path = path;\n\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\tif (handle == nullptr) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: Failed to load library: \" + std::string(dlerror()));\n\t}\n}\n", "CodeBleu_score": 51.37320289067766}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_library) {\n\t\tthrow RuntimeError(\"SharedLibrary already loaded\");\n\t}\n\tm_library = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!m_library) {\n\t\tthrow RuntimeError(\"Failed to load shared library: \" + std::string(dlerror()));\n\t}\n\tm_path = path;\n}\n", "CodeBleu_score": 49.46329953181804}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.front()!= '{' || stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer!= nullptr) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 24.84855879141393}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.length() < 3 || stripped.front()!= '{' || stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.length() - 2);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 23.88160226298573}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped[0]!= '{') {\n\t\treturn false;\n\t}\n\tif (stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer!= nullptr) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 26.248670049975548}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\t// initialize the line cost\n\tdouble line_cost = 0.0;\n\n\t// initialize the line iterator\n\tLineIterator it(this, x0, y0, x1, y1);\n\n\t// iterate through the points on the line\n\tfor (int i = 0; i < it.count; ++i, ++it) {\n\t\t// get the point cost\n\t\tdouble point_cost = pointCost(it.x, it.y);\n\n\t\t// if the point cost is negative, return immediately\n\t\tif (point_cost < 0.0)\n\t\t\treturn point_cost;\n\n\t\t// update the line cost if the point cost is higher\n\t\tif (point_cost > line_cost)\n\t\t\tline_cost = point_cost;\n\t}\n\n\t// return the total line cost\n\treturn line_cost;\n}\n", "CodeBleu_score": 45.413985662539105}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble total_cost = 0.0;\n\tLineIterator it(this, x0, y0, x1, y1);\n\tfor (int i = 0; i < it.count; ++i, ++it) {\n\t\tdouble cost = pointCost(it.pos.x, it.pos.y);\n\t\tif (cost < 0.0) {\n\t\t\treturn cost;\n\t\t} else {\n\t\t\ttotal_cost += cost;\n\t\t}\n\t}\n\treturn total_cost;\n}\n", "CodeBleu_score": 30.608236174934945}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble total_cost = 0;\n\tLineIterator it(this, x0, y0, x1, y1);\n\tfor (int i = 0; i < it.count; ++i, ++it) {\n\t\ttotal_cost += pointCost(it.pos.x, it.pos.y);\n\t\tif (total_cost < 0)\n\t\t\treturn total_cost;\n\t}\n\treturn total_cost;\n}\n", "CodeBleu_score": 28.70946787801777}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.empty()) {\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path message and initialize its header with the frame_id and timestamp from the first pose in the path\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\n\t// Copy each pose from the input path to the path message\n\tfor (const geometry_msgs::PoseStamped& pose : path) {\n\t\tpath_msg.poses.push_back(pose.pose);\n\t}\n\n\t// Publish the path message using the provided ROS publisher\n\tpub.publish(path_msg);\n}\n", "CodeBleu_score": 50.76859434318528}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (!path.empty()) {\n\t\tnav_msgs::Path path_msg;\n\t\tpath_msg.header.frame_id = path[0].header.frame_id;\n\t\tpath_msg.header.stamp = path[0].header.stamp;\n\t\tfor (const auto& pose : path) {\n\t\t\tpath_msg.poses.push_back(pose);\n\t\t}\n\t\tpub.publish(path_msg);\n\t}\n}\n", "CodeBleu_score": 47.72579818478435}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif(path.empty())\n\t\treturn;\n\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path[0].header.frame_id;\n\tmsg.header.stamp = path[0].header.stamp;\n\n\tfor(auto pose : path)\n\t\tmsg.poses.push_back(pose.pose);\n\n\tpub.publish(msg);\n}\n", "CodeBleu_score": 49.72265722863469}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\n\tif (rot_vel <= rot_stopped_velocity && trans_vel <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 51.41852467570711}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\t// Check if the robot has stopped\n\tbool stopped = false;\n\t// Get the current velocity\n\tdouble current_rot_vel = base_odom.twist.twist.angular.z;\n\tdouble current_trans_vel = base_odom.twist.twist.linear.x;\n\t// Check if the robot has stopped\n\tif (fabs(current_rot_vel) <= rot_stopped_velocity && fabs(current_trans_vel) <= trans_stopped_velocity) {\n\t\tstopped = true;\n\t}\n\t// Return the result\n\treturn stopped;\n}\n", "CodeBleu_score": 50.63757542906542}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\tif(rot_vel <= rot_stopped_velocity && trans_vel <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 52.288555226185466}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tROS_INFO(\"LocalPlannerUtil::reconfigureCB\");\n\n\t// If the setup flag is true and restore_defaults is requested, reset the configuration to default limits.\n\tif (setup && restore_defaults) {\n\t\tconfig.setup = false;\n\t\tconfig.restore_defaults = false;\n\t\tconfig.max_vel_x = 1.0;\n\t\tconfig.max_vel_y = 1.0;\n\t\tconfig.max_vel_theta = 1.0;\n\t\tconfig.min_vel_x = 0.0;\n\t\tconfig.min_vel_y = 0.0;\n\t\tconfig.min_vel_theta = 0.0;\n\t\tconfig.max_acc_x = 1.0;\n\t\tconfig.max_acc_y = 1.0;\n\t\tconfig.max_acc_theta = 1.0;\n\t\tconfig.min_acc_x = 0.0;\n\t\tconfig.min_acc_y = 0.0;\n\t\tconfig.min_acc_theta = 0.0;\n\t\tconfig.max_jerk_x = 1.0;\n\t\tconfig.max_jerk_y = 1.0;\n\t\tconfig.max_jerk_theta = 1.0;\n\t\tconfig.min_jerk_x = 0.0;\n\t\tconfig.min_jerk_y = 0.0;\n\t\tconfig.min_jerk_theta = 0.0;\n\t\tconfig.max_vel_x_backwards = 1.0;\n\t\tconfig.max_vel_y_backwards = 1.0;\n\t\tconfig.max_vel_theta_backwards = 1.0;\n\t\tconfig.min_vel_x_backwards = 0.0;\n\t\tconfig.min_vel_y_backwards = 0.0;\n\t\tconfig.min_vel_theta_backwards = 0.0;\n\t\tconfig.max_acc_x_backwards = 1.0;\n\t\tconfig.max_acc_y_backwards = 1.0;\n\t\tconfig.max_acc_theta_backwards = 1.0;\n\t\tconfig.min_acc_x", "CodeBleu_score": 27.868307600900216}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (restore_defaults) {\n\t\tconfig.setup = false;\n\t\tconfig.restore_defaults = false;\n\t\tconfig.global_planner_limits.max_vel_x = 0.0;\n\t\tconfig.global_planner_limits.max_vel_y = 0.0;\n\t\tconfig.global_planner_limits.max_vel_theta = 0.0;\n\t\tconfig.global_planner_limits.min_vel_x = 0.0;\n\t\tconfig.global_planner_limits.min_vel_y = 0.0;\n\t\tconfig.global_planner_limits.min_vel_theta = 0.0;\n\t\tconfig.global_planner_limits.acc_lim_x = 0.0;\n\t\tconfig.global_planner_limits.acc_lim_y = 0.0;\n\t\tconfig.global_planner_limits.acc_lim_theta = 0.0;\n\t\tconfig.global_planner_limits.max_rot_vel = 0.0;\n\t\tconfig.global_planner_limits.min_rot_vel = 0.0;\n\t\tconfig.global_planner_limits.min_in_place_rot_vel = 0.0;\n\t\tconfig.global_planner_limits.max_rot1 = 0.0;\n\t\tconfig.global_planner_limits.min_rot1 = 0.0;\n\t\tconfig.global_planner_limits.max_rot2 = 0.0;\n\t\tconfig.global_planner_limits.min_rot2 = 0.0;\n\t\tconfig.local_planner_limits.max_vel_x = 0.0;\n\t\tconfig.local_planner_limits.max_vel_y = 0.0;\n\t\tconfig.local_planner_limits.max_vel_theta = 0.0;\n\t\tconfig.local_planner_limits.min_vel_x = 0.0;\n\t\tconfig.local_planner_limits.min_vel_y = 0.0;\n\t\tconfig.local_planner_limits.min_vel_theta = 0.0;\n\t\tconfig.local_planner_limits.acc_lim_x = 0.0;\n\t\tconfig", "CodeBleu_score": 22.05220874895324}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (restore_defaults) {\n\t\tconfig.setup = false;\n\t\tconfig.restore_defaults = false;\n\t\tconfig.max_vel_x = 0.2;\n\t\tconfig.max_vel_y = 0.2;\n\t\tconfig.max_vel_theta = 0.5;\n\t\tconfig.min_vel_x = 0.0;\n\t\tconfig.min_vel_y = 0.0;\n\t\tconfig.min_vel_theta = 0.0;\n\t\tconfig.min_in_place_vel = 0.0;\n\t\tconfig.max_vel_x_backwards = 0.0;\n\t\tconfig.max_vel_y_backwards = 0.0;\n\t\tconfig.max_vel_theta_backwards = 0.0;\n\t\tconfig.min_vel_x_backwards = 0.0;\n\t\tconfig.min_vel_y_backwards = 0.0;\n\t\tconfig.min_vel_theta_backwards = 0.0;\n\t\tconfig.min_in_place_vel_backwards = 0.0;\n\t\tconfig.max_vel_x_turn_left = 0.0;\n\t\tconfig.max_vel_y_turn_left = 0.0;\n\t\tconfig.max_vel_theta_turn_left = 0.0;\n\t\tconfig.min_vel_x_turn_left = 0.0;\n\t\tconfig.min_vel_y_turn_left = 0.0;\n\t\tconfig.min_vel_theta_turn_left = 0.0;\n\t\tconfig.min_in_place_vel_turn_left = 0.0;\n\t\tconfig.max_vel_x_turn_right = 0.0;\n\t\tconfig.max_vel_y_turn_right = 0.0;\n\t\tconfig.max_vel_theta_turn_right = 0.0;\n\t\tconfig.min_vel_x_turn_right = 0.0;\n\t\tconfig.min_vel_y_turn_right = 0.0;\n\t\tconfig.min_vel_theta_turn_right = 0.0;\n\t\t", "CodeBleu_score": 21.808539994054314}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\tif (check_cell->isObstacle()) {\n\t\tcurrent_cell->setTargetDistance(costmap.getCost(check_cell->getPoint())\n\t\t\t\t+ costmap.getCost(current_cell->getPoint()));\n\t\treturn false;\n\t}\n\tdouble new_cost = costmap.getCost(check_cell->getPoint())\n\t\t\t+ costmap.getCost(current_cell->getPoint());\n\tif (new_cost < current_cell->getTargetDistance()) {\n\t\tcurrent_cell->setTargetDistance(new_cost);\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 38.00111204468399}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\t// Check if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\t// Set the cell's target distance to the maximum obstacle cost\n\t\tcurrent_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n\t\t// Return false\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance\n\tdouble new_target_distance = current_cell->target_distance + check_cell->cost;\n\n\t// Update the cell's target distance if the new distance is shorter\n\tif (new_target_distance < current_cell->target_distance) {\n\t\tcurrent_cell->target_distance = new_target_distance;\n\t}\n\n\t// Return true\n\treturn true;\n}\n", "CodeBleu_score": 50.56178978629401}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\tif (check_cell->isObstacle()) {\n\t\tcurrent_cell->setTargetDistance(costmap.getCost(check_cell->getGridX(), check_cell->getGridY())\n\t\t\t\t+ 1);\n\t\treturn false;\n\t} else {\n\t\tint cost = costmap.getCost(check_cell->getGridX(), check_cell->getGridY());\n\t\tif (cost == costmap.getCostmapResolution()) {\n\t\t\tcurrent_cell->setTargetDistance(costmap.getCost(check_cell->getGridX(), check_cell->getGridY())\n\t\t\t\t\t+ 1);\n\t\t} else if (cost < current_cell->getTargetDistance()) {\n\t\t\tcurrent_cell->setTargetDistance(cost);\n\t\t}\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 46.174615759449864}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"footprint specification is empty\");\n\t\treturn -9.0;\n\t}\n\n\t// Initialize the cost and scaling factor based on the trajectory and speed parameters\n\tcost = cost_factor_ * traj.getCost();\n\tscaling_factor = scaling_factor_ * traj.getScalingFactor();\n\n\t// For each point in the trajectory, calculate the footprint cost\n\tfor (int i = 0; i < traj.getPoints().size(); i++) {\n\t\tdouble footprint_cost = 0.0;\n\t\tfootprint_cost = calculateFootprintCost(traj.getPoints()[i]);\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn -9.0;\n\t\t} else if (sum_scores_) {\n\t\t\tcost += scaling_factor * footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, scaling_factor * footprint_cost);\n\t\t}\n\t}\n\n\t// Return the total cost\n\treturn cost;\n}\n", "CodeBleu_score": 42.532001575228485}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tdouble cost = 0;\n\tdouble scaling_factor = 1.0;\n\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty!\");\n\t\treturn -9;\n\t}\n\n\tfor (size_t i = 0; i < traj.getPoints().size(); i++) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoints()[i]);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn -9;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cost;\n}\n", "CodeBleu_score": 40.4835516625318}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\t// Initialize cost and scaling factor\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\t// Check if footprint is empty\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty!\");\n\t\treturn -9.0;\n\t}\n\n\t// For each point in the trajectory\n\tfor (size_t i = 0; i < traj.getPoints().size(); ++i) {\n\t\t// Calculate footprint cost\n\t\tdouble footprint_cost = calculateFootprintCost(traj.getPoints()[i]);\n\n\t\t// If footprint cost is negative, return immediately\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn -9.0;\n\t\t}\n\n\t\t// Sum scores or take maximum score\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\t// Return total cost\n\treturn cost;\n}\n", "CodeBleu_score": 40.72067236177395}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\t//std::cout << \"ObstacleCostFunction::footprintCost\" << std::endl;\n    // Check if the position is on the map\n    if (!costmap->worldToMap(x, y, mx, my)) {\n        //std::cout << \"ObstacleCostFunction::footprintCost: Position is off the map\" << std::endl;\n        return -7.0;\n    }\n    // Scale the footprint points\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        geometry_msgs::Point scaled_point;\n        scaled_point.x = footprint_spec[i].x * scale;\n        scaled_point.y = footprint_spec[i].y * scale;\n        scaled_footprint.push_back(scaled_point);\n    }\n    // Check if the footprint is in the map\n    if (!world_model->isPositionValid(mx, my, scaled_footprint, th)) {\n        //std::cout << \"ObstacleCostFunction::footprintCost: Footprint is off the map\" << std::endl;\n        return -7.0;\n    }\n    // Get the footprint cost\n    double footprint_cost = world_model->footprintCost(mx, my, scaled_footprint, th, costmap);\n    // Get the cell cost\n    double cell_cost = costmap->getCost(mx, my);\n    // Return the maximum cost\n    if (footprint_cost < cell_cost) {\n        //std::cout << \"ObstacleCostFunction::footprintCost: Footprint cost is less than cell cost\" << std::endl;\n        return footprint_cost;\n    } else {\n        //std::cout << \"ObstacleCostFunction::footprintCost: Cell cost is less than footprint cost\" << std::endl;\n        return cell_cost;\n    }\n}\n", "CodeBleu_score": 62.95666653493037}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\t//ROS_INFO(\"x: %f, y: %f, th: %f\", x, y, th);\n\t//ROS_INFO(\"scale: %f\", scale);\n\t//ROS_INFO(\"footprint_spec: %f, %f, %f, %f, %f, %f, %f, %f\", footprint_spec[0].x, footprint_spec[0].y, footprint_spec[1].x, footprint_spec[1].y, footprint_spec[2].x, footprint_spec[2].y, footprint_spec[3].x, footprint_spec[3].y);\n\t//ROS_INFO(\"costmap: %f, %f\", costmap->getSizeInCellsX(), costmap->getSizeInCellsY());\n\n\t//ROS_INFO(\"scale: %f\", scale);\n\t//ROS_INFO(\"footprint_spec: %f, %f, %f, %f, %f, %f, %f, %f\", footprint_spec[0].x, footprint_spec[0].y, footprint_spec[1].x, footprint_spec[1].y, footprint_spec[2].x, footprint_spec[2].y, footprint_spec[3].x, footprint_spec[3].y);\n\t//ROS_INFO(\"costmap: %f, %f\", costmap->getSizeInCellsX(), costmap->getSizeInCellsY());\n\n\t//ROS_INFO(\"x: %f, y: %f, th: %f\", x, y, th);\n\t//ROS_INFO(\"scale: %f\", scale);\n\t//ROS_INFO(\"footprint_spec: %f, %f, %f, %f, %f, %f, %f, %f\", footprint_spec[0].x, footprint_spec[0].y, footprint_spec[1].x, footprint_spec[1].y, footprint_spec[2].x, footprint_spec[2].y, footprint_spec[3].x, footprint_spec[3].y);\n\t//ROS_INFO(\"costmap: %f, %f\", costmap->getSizeInCellsX(), costmap->", "CodeBleu_score": 8.470056457860881}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\t// check if the position is off the map\n\tif (!costmap->worldToMap(x, y, mx, my)) {\n\t\tROS_DEBUG_NAMED(\"footprint_cost\", \"Footprint cost: off the map\");\n\t\treturn -7.0;\n\t}\n\n\t// scale the footprint points\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tscaled_footprint.resize(footprint_spec.size());\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tscaled_footprint[i].x = footprint_spec[i].x * scale;\n\t\tscaled_footprint[i].y = footprint_spec[i].y * scale;\n\t}\n\n\t// compute the footprint cost\n\tdouble footprint_cost = costmap->getCost(mx, my);\n\tif (footprint_cost < 0) {\n\t\tROS_DEBUG_NAMED(\"footprint_cost\", \"Footprint cost: negative\");\n\t\treturn -6.0;\n\t}\n\n\t// compute the footprint cost using the world model\n\tdouble scaled_footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n\tif (scaled_footprint_cost < 0) {\n\t\tROS_DEBUG_NAMED(\"footprint_cost\", \"Footprint cost: negative\");\n\t\treturn -6.0;\n\t}\n\n\t// return the maximum cost between the footprint cost and the cell cost at the given position\n\treturn std::max(footprint_cost, scaled_footprint_cost);\n}\n", "CodeBleu_score": 59.63744931341951}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic!= _odom_topic) {\n\t\tif (odom_topic.empty()) {\n\t\t\t_odom_sub.shutdown();\n\t\t} else {\n\t\t\t_odom_sub = _nh.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t\t_odom_topic = odom_topic;\n\t}\n}\n", "CodeBleu_score": 37.31335251055542}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\t// Shut down the existing subscription\n\todom_sub_.shutdown();\n\n\t// Update the topic\n\todom_topic_ = odom_topic;\n\n\t// Subscribe to the new topic\n\tif (!odom_topic_.empty()) {\n\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t}\n}\n", "CodeBleu_score": 30.881485340775207}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic.empty()) {\n\t\tif (odom_sub_!= NULL) {\n\t\t\todom_sub_->shutdown();\n\t\t\todom_sub_ = NULL;\n\t\t}\n\t} else {\n\t\tif (odom_sub_!= NULL) {\n\t\t\todom_sub_->shutdown();\n\t\t}\n\t\todom_sub_ = new message_filters::Subscriber<nav_msgs::Odometry>(nh_, odom_topic, 1);\n\t\todom_sub_->registerCallback(boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n\t}\n}\n", "CodeBleu_score": 31.84581124639979}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tfloat squaredDistance = (pos - prev).squaredNorm();\n\tfloat angularDifference = fabs(pos.angle(prev));\n\n\tif (squaredDistance > OSCILLATION_DISTANCE_THRESHOLD || angularDifference > OSCILLATION_ANGLE_THRESHOLD) {\n\t\t// Reset flags\n\t\tm_oscillationFlags.reset();\n\t}\n}\n", "CodeBleu_score": 26.13773995511458}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tfloat sqrDist = (pos - prev).squaredNorm();\n\tfloat angle = std::abs(pos.cross(prev).norm() / (pos.norm() * prev.norm()));\n\tif (sqrDist > OSCILLATION_THRESHOLD || angle > OSCILLATION_ANGLE) {\n\t\tm_isOscillating = false;\n\t\tm_oscillationCounter = 0;\n\t}\n}\n", "CodeBleu_score": 29.37424852956323}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\t// Calculate the squared distance\n\tfloat squaredDistance = (pos - prev).squaredNorm();\n\n\t// Calculate the angular difference\n\tfloat angularDifference = std::abs(angleBetween(pos, prev));\n\n\t// If the squared distance is greater than the threshold or the angular difference is greater than the set angle, reset the oscillation flags\n\tif (squaredDistance > squaredDistanceThreshold || angularDifference > angularDifferenceThreshold) {\n\t\toscillationFlags = false;\n\t}\n}\n", "CodeBleu_score": 26.908460676590007}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\tif (pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_) {\n\t\treturn;\n\t}\n\tif (pt.z < min_z_ || pt.z > max_z_) {\n\t\treturn;\n\t}\n\tif (pt.x < min_x_ + grid_x_ * 0.5 || pt.x > max_x_ - grid_x_ * 0.5 || pt.y < min_y_ + grid_y_ * 0.5 || pt.y > max_y_ - grid_y_ * 0.5) {\n\t\treturn;\n\t}\n\tif (pt.z < min_z_ + grid_z_ * 0.5 || pt.z > max_z_ - grid_z_ * 0.5) {\n\t\treturn;\n\t}\n\tint index = getIndex(pt);\n\tif (index < 0) {\n\t\treturn;\n\t}\n\tcells_[index].points_.push_back(pt);\n}\n", "CodeBleu_score": 36.540363845235035}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\tif (pt.x < xmin || pt.x > xmax || pt.y < ymin || pt.y > ymax || pt.z < zmin || pt.z > zmax) {\n\t\treturn;\n\t}\n\tint x_idx = (int) ((pt.x - xmin) / dx);\n\tint y_idx = (int) ((pt.y - ymin) / dy);\n\tint z_idx = (int) ((pt.z - zmin) / dz);\n\tint idx = z_idx * grid_size_x_ * grid_size_y_ + y_idx * grid_size_x_ + x_idx;\n\tif (idx < 0 || idx >= grid_size_) {\n\t\treturn;\n\t}\n\tgrid_[idx].push_back(pt);\n}\n", "CodeBleu_score": 37.16831980763459}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// Calculate the grid coordinates of the point.\n\tdouble x = pt.x;\n\tdouble y = pt.y;\n\tdouble z = pt.z;\n\tint i = (int) (x - x_min) / x_res;\n\tint j = (int) (y - y_min) / y_res;\n\tint k = (int) (z - z_min) / z_res;\n\n\t// If the point is outside the grid bounds or too close to its nearest neighbor, return.\n\tif (i < 0 || i >= nx || j < 0 || j >= ny || k < 0 || k >= nz || (i == i_nearest && j == j_nearest && k == k_nearest))\n\t\treturn;\n\n\t// Calculate the grid index.\n\tint idx = i + nx * (j + ny * k);\n\n\t// Insert the point into the corresponding cell.\n\tcells[idx].push_back(pt);\n}\n", "CodeBleu_score": 41.23388478944094}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else if (sample_target_vel[i] < vel[i]) {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 74.77036406754829}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n\t\t} else if (sample_target_vel[i] < vel[i]) {\n\t\t\tnew_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 74.40598619271994}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tif ((sample_target_vel[i] - vel[i]) < acclimits[i] * dt) {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t} else {\n\t\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t\t}\n\t\t} else if (sample_target_vel[i] < vel[i]) {\n\t\t\tif ((vel[i] - sample_target_vel[i]) < acclimits[i] * dt) {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t} else {\n\t\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t\t}\n\t\t} else {\n\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 69.09588551807595}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\t// Get the current cell\n\tint current_cell_x = round(x / resolution);\n\tint current_cell_y = round(y / resolution);\n\n\t// Get the goal cell\n\tint goal_cell_x = round(cell_x / resolution);\n\tint goal_cell_y = round(cell_y / resolution);\n\n\t// Get the goal position\n\tdouble goal_x = goal_cell_x * resolution + resolution / 2.0;\n\tdouble goal_y = goal_cell_y * resolution + resolution / 2.0;\n\n\t// Get the goal heading\n\tdouble goal_heading = atan2(goal_y - y, goal_x - x);\n\n\t// Get the difference in heading\n\tdouble diff = fabs(normalizeAngle(goal_heading - heading));\n\n\t// Get the global plan\n\tvector<geometry_msgs::PoseStamped> global_plan;\n\tglobal_plan = costmap_->getGlobalPath();\n\n\t// Iterate through the global plan in reverse\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\t// Get the cell coordinates of the current point\n\t\tint cell_x = round(global_plan[i].pose.position.x / resolution);\n\t\tint cell_y = round(global_plan[i].pose.position.y / resolution);\n\n\t\t// Get the position of the current point\n\t\tdouble x = cell_x * resolution + resolution / 2.0;\n\t\tdouble y = cell_y * resolution + resolution / 2.0;\n\n\t\t// Get the heading of the current point\n\t\tdouble heading = atan2(y - global_plan[i].pose.position.y, x - global_plan[i].pose.position.x);\n\n\t\t// Get the distance between the current point and the goal point\n\t\tdouble distance = sqrt(pow(goal_x - x, 2) + pow(goal_y - y, 2));\n\n\t\t// Check if the current point is clear of obstacles\n\t\tif (costmap_->isClear(cell_x, cell_y) && distance < 1.5 * resolution) {\n\t\t\t// Get the difference in heading\n\t\t\tdiff = fabs(normalizeAngle(goal_heading - heading));\n\t\t\tbreak", "CodeBleu_score": 45.13875018840901}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble angle_to_goal = 0.0;\n\tint cell_x_start = cell_x;\n\tint cell_y_start = cell_y;\n\tint cell_x_end = 0;\n\tint cell_y_end = 0;\n\n\t// Check if the goal is in the same cell as the robot\n\tif (cell_x == x && cell_y == y) {\n\t\treturn 0.0;\n\t}\n\n\t// Find the farthest point in the global plan with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\tcell_x_end = global_plan[i].x;\n\t\tcell_y_end = global_plan[i].y;\n\n\t\tif (cell_x_end == cell_x && cell_y_end == cell_y) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (world_model->isClear(cell_x_end, cell_y_end, cell_x, cell_y)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Convert the goal cell coordinates to world coordinates\n\tdouble goal_x = cell_x_end * world_model->getCellSize() + world_model->getCellSize() / 2.0;\n\tdouble goal_y = cell_y_end * world_model->getCellSize() + world_model->getCellSize() / 2.0;\n\n\t// Calculate the difference in heading between the robot's current position and the goal point\n\tangle_to_goal = atan2(goal_y - y, goal_x - x) - heading;\n\tangle_to_goal = atan2(sin(angle_to_goal), cos(angle_to_goal));\n\n\treturn fabs(angle_to_goal);\n}\n", "CodeBleu_score": 48.29033568755716}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble min_angle = 0.0;\n\tdouble max_angle = 0.0;\n\tdouble angle = 0.0;\n\tdouble angle_diff = 0.0;\n\tdouble angle_to_point = 0.0;\n\tdouble angle_to_point_diff = 0.0;\n\tdouble angle_to_point_diff_abs = 0.0;\n\tdouble angle_to_point_diff_abs_min = 0.0;\n\tdouble angle_to_point_diff_abs_max = 0.0;\n\tdouble angle_to_point_diff_abs_min_angle = 0.0;\n\tdouble angle_to_point_diff_abs_max_angle = 0.0;\n\tdouble angle_to_point_diff_abs_min_angle_diff = 0.0;\n\tdouble angle_to_point_diff_abs_max_angle_diff = 0.0;\n\tdouble angle_to_point_diff_abs_min_angle_diff_abs = 0.0;\n\tdouble angle_to_point_diff_abs_max_angle_diff_abs = 0.0;\n\tdouble angle_to_point_diff_abs_min_angle_diff_abs_min = 0.0;\n\tdouble angle_to_point_diff_abs_max_angle_diff_abs_max = 0.0;\n\tdouble angle_to_point_diff_abs_min_angle_diff_abs_min_angle = 0.0;\n\tdouble angle_to_point_diff_abs_max_angle_diff_abs_max_angle = 0.0;\n\tdouble angle_to_point_diff_abs_min_angle_diff_abs_min_angle_diff = 0.0;\n\tdouble angle_to_point_diff_abs_max_angle_diff_abs_max_angle_diff = 0.0;\n\tdouble angle_to_point_diff_abs_min_angle_diff_abs_min_angle_diff_abs = 0.0;\n\tdouble angle_to_point_diff_abs_max_angle_diff_abs_", "CodeBleu_score": 4.750466924058508}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN(\"Trajectory rejected: x=%f, y=%f, theta=%f, vx=%f, vy=%f, vtheta=%f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f, cost=%f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 73.59578671358146}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\tdouble cost;\n\tcost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost < 0.0) {\n\t\tROS_WARN(\"Trajectory cost is negative. vx: %f, vy: %f, vtheta: %f\", vx_samp, vy_samp, vtheta_samp);\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 70.53296219185559}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\tdouble cost;\n\tbool ret;\n\tcost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tret = (cost >= 0);\n\tif (!ret) {\n\t\tROS_WARN(\"Trajectory cost is negative: %f\", cost);\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 58.188765653803095}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()\tros::WallTime start = ros::WallTime::now();\n\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"ClearCostmapRecovery::runBehavior: This object must be initialized before use.\");\n\t\treturn;\n\t}\n\tif (costmap_ == NULL || global_costmap_ == NULL) {\n\t\tROS_ERROR(\n\t\t\t\t\"ClearCostmapRecovery::runBehavior: This object must have a costmap and a global costmap before use.\");\n\t\treturn;\n\t}\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\n\t\t\t\t\"ClearCostmapRecovery::runBehavior: Clearing inside the specified area. This may result in unexpected behavior.\");\n\t}\n\tif (affected_maps_ == \"global\") {\n\t\tROS_INFO(\n\t\t\t\t\"ClearCostmapRecovery::runBehavior: Clearing global costmap.\");\n\t\tif (global_costmap_->getCostmap()->isFresh()) {\n\t\t\tglobal_costmap_->getCostmap()->clear();\n\t\t} else {\n\t\t\tglobal_costmap_->getCostmap()->updateMap();\n\t\t}\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->getCostmap()->publishCostmap();\n\t\t}\n\t} else if (affected_maps_ == \"local\") {\n\t\tROS_INFO(\n\t\t\t\t\"ClearCostmapRecovery::runBehavior: Clearing local costmap.\");\n\t\tif (costmap_->getCostmap()->isFresh()) {\n\t\t\tcostmap_->getCostmap()->clear();\n\t\t} else {\n\t\t\tcostmap_->getCostmap()->updateMap();\n\t\t}\n\t\tif (force_update_) {\n\t\t\tcostmap_->getCostmap()->publishCostmap();\n\t\t}\n\t} else {\n\t\tROS_ERROR(\n\t\t\t\t\"ClearCostmapRecovery::runBehavior: Affected maps must be either 'global' or 'local'.\");\n\t}\n\tros::WallTime end = ros::WallTime::now();\n\tROS_INFO(\n\t\t\t\"ClearCostmapRecovery::runBehavior: Clearing costmaps took %f seconds.\",\n\t\t\t(end - start).toSec());\n}\n", "CodeBleu_score": 45.44069359281331}, {"code": "void ClearCostmapRecovery::runBehavior()\tros::NodeHandle n;\n\tros::NodeHandle private_nh(\"~\");\n\tros::Publisher clear_costmap_pub = n.advertise<std_msgs::Bool>(\"clear_costmap\", 1);\n\tros::Publisher clear_global_costmap_pub = n.advertise<std_msgs::Bool>(\"clear_global_costmap\", 1);\n\tros::Publisher clear_local_costmap_pub = n.advertise<std_msgs::Bool>(\"clear_local_costmap\", 1);\n\tros::Publisher clear_both_costmaps_pub = n.advertise<std_msgs::Bool>(\"clear_both_costmaps\", 1);\n\tros::Publisher clear_costmap_time_pub = n.advertise<std_msgs::Float32>(\"clear_costmap_time\", 1);\n\tros::Publisher clear_global_costmap_time_pub = n.advertise<std_msgs::Float32>(\"clear_global_costmap_time\", 1);\n\tros::Publisher clear_local_costmap_time_pub = n.advertise<std_msgs::Float32>(\"clear_local_costmap_time\", 1);\n\tros::Publisher clear_both_costmaps_time_pub = n.advertise<std_msgs::Float32>(\"clear_both_costmaps_time\", 1);\n\tros::Publisher clear_costmap_force_update_pub = n.advertise<std_msgs::Bool>(\"clear_costmap_force_update\", 1);\n\tros::Publisher clear_global_costmap_force_update_pub = n.advertise<std_msgs::Bool>(\"clear_global_costmap_force_update\", 1);\n\tros::Publisher clear_local_costmap_force_update_pub = n.advertise<std_msgs::Bool>(\"clear_local_costmap_force_update\", 1);\n\tros::Publisher clear_both_costmaps_force_update_pub = n.advertise<std_msgs::Bool>(\"clear_both_costmaps_force_update\", 1);\n\tros::Publisher clear_costmap_area_pub = n.advertise<geometry_msgs::PolygonStamped>(\"clear_", "CodeBleu_score": 13.977837004233626}, {"code": "void ClearCostmapRecovery::runBehavior()\tif (initialized_) {\n\t\tif (global_costmap_!= NULL && local_costmap_!= NULL) {\n\t\t\tif (invert_area_to_clear_) {\n\t\t\t\tROS_WARN(\"Clearing costmap inside specified area\");\n\t\t\t}\n\t\t\tros::Time start = ros::Time::now();\n\t\t\tif (affected_maps_ == \"global\") {\n\t\t\t\tglobal_costmap_->clearCostmap();\n\t\t\t} else if (affected_maps_ == \"local\") {\n\t\t\t\tlocal_costmap_->clearCostmap();\n\t\t\t} else if (affected_maps_ == \"global_and_local\") {\n\t\t\t\tglobal_costmap_->clearCostmap();\n\t\t\t\tlocal_costmap_->clearCostmap();\n\t\t\t} else {\n\t\t\t\tROS_ERROR(\"Unknown affected_maps_ value: %s\", affected_maps_.c_str());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tros::Duration d = ros::Time::now() - start;\n\t\t\tROS_INFO(\"Clearing costmap took %f seconds\", d.toSec());\n\t\t} else {\n\t\t\tROS_ERROR(\"Costmaps are NULL\");\n\t\t}\n\t} else {\n\t\tROS_ERROR(\"ClearCostmapRecovery is not initialized\");\n\t}\n}\n", "CodeBleu_score": 37.105279623897204}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tPolygonOutlineCells polygon_outline_cells;\n\tpolygonOutlineCells(polygon, polygon_outline_cells);\n\tpolygon_cells = polygon_outline_cells.cells;\n}\n", "CodeBleu_score": 16.000131464082084}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tif (polygon.size() == 0) {\n\t\treturn;\n\t}\n\tpolygon_cells.clear();\n\tPolygonOutlineCells outline_cells;\n\toutline_cells.clear();\n\tMapLocation last_point = polygon[polygon.size() - 1];\n\tfor (size_t i = 0; i < polygon.size(); ++i) {\n\t\tMapLocation point = polygon[i];\n\t\tif (i == 0) {\n\t\t\toutline_cells.push_back(point);\n\t\t}\n\t\toutline_cells.push_back(point);\n\t\tif (i!= polygon.size() - 1) {\n\t\t\toutline_cells.push_back(last_point);\n\t\t}\n\t\tlast_point = point;\n\t}\n\tfor (size_t i = 0; i < outline_cells.size(); ++i) {\n\t\tMapLocation point = outline_cells[i];\n\t\tMapLocation next_point = outline_cells[(i + 1) % outline_cells.size()];\n\t\traytraceLine(point, next_point, outline_cells);\n\t}\n\tpolygon_cells = outline_cells;\n}\n", "CodeBleu_score": 40.07911432046954}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tif (polygon.empty()) {\n\t\tROS_ERROR(\"Polygon is empty!\");\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outline;\n\toutline.polygon = polygon;\n\toutline.cells.reserve(polygon.size());\n\n\t// iterate through the polygon vertices\n\tfor (size_t i = 0; i < polygon.size(); i++) {\n\t\tMapLocation start = polygon[i];\n\t\tMapLocation end = polygon[(i + 1) % polygon.size()];\n\n\t\t// add cells between start and end\n\t\traytraceLine(start, end, &outline);\n\t}\n\n\t// close the polygon by connecting the last point to the first\n\traytraceLine(polygon.back(), polygon.front(), &outline);\n\n\t// copy the cells to the output\n\tpolygon_cells = outline.cells;\n}\n", "CodeBleu_score": 47.69758722624925}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t// We need to make a copy of the grid because we are going to modify it\n\t// and we don't want to mess with the original.\n\t// TODO: This is not thread-safe.\n\tif (grid_) {\n\t\tGrid2D grid = *grid_;\n\t\tprepareGrid(grid);\n\t\tpub.publish(grid);\n\t}\n}\n", "CodeBleu_score": 48.570067109742695}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t// Prepare grid data\n\tprepareGrid();\n\n\t// Publish prepared grid\n\tpub.publish(grid);\n}\n", "CodeBleu_score": 61.685511907286816}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t// Get the new publisher\n\tros::Publisher newPub = pub.getPublisher();\n\t// Get the new publisher's topic name\n\tstd::string newTopic = pub.getTopic();\n\t// Get the new publisher's queue size\n\tint newQueueSize = pub.getQueueSize();\n\n\t// Prepare the grid\n\tprepareGrid(newTopic, newQueueSize);\n\n\t// Publish the grid\n\tnewPub.publish(grid_);\n}\n", "CodeBleu_score": 48.65088380888389}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()\t//lock the mutex\n\tmutex_.lock();\n\t//retrieve the resolution\n\tdouble resolution = costmap_->getResolution();\n\t//set the grid's header\n\theader_.frame_id = costmap_->getGlobalFrameID();\n\t//set the grid's resolution\n\theader_.info.resolution = resolution;\n\t//set the grid's width\n\theader_.info.width = costmap_->getSizeInCellsX();\n\t//set the grid's height\n\theader_.info.height = costmap_->getSizeInCellsY();\n\t//set the origin's position and orientation\n\theader_.info.origin.position.x = costmap_->getOriginX();\n\theader_.info.origin.position.y = costmap_->getOriginY();\n\theader_.info.origin.position.z = 0.0;\n\theader_.info.origin.orientation.x = 0.0;\n\theader_.info.origin.orientation.y = 0.0;\n\theader_.info.origin.orientation.z = 0.0;\n\theader_.info.origin.orientation.w = 1.0;\n\t//save the origin coordinates\n\torigin_x_ = costmap_->getOriginX();\n\torigin_y_ = costmap_->getOriginY();\n\t//resize the grid data vector\n\tdata_.resize(costmap_->getSizeInCellsX() * costmap_->getSizeInCellsY());\n\t//unlock the mutex\n\tmutex_.unlock();\n}\n", "CodeBleu_score": 41.12289712482603}, {"code": "void Costmap2DPublisher::prepareGrid()\t// Lock the mutex\n\tmutex.lock();\n\n\t// Get the resolution\n\tdouble resolution = costmap->getResolution();\n\n\t// Set the grid's header\n\theader.frame_id = frame_id;\n\theader.stamp = ros::Time::now();\n\n\t// Set the grid's resolution\n\tgrid.info.resolution = resolution;\n\n\t// Set the grid's width and height\n\tgrid.info.width = costmap->getSizeInCellsX();\n\tgrid.info.height = costmap->getSizeInCellsY();\n\n\t// Set the grid's origin\n\tgrid.info.origin.position.x = costmap->getOriginX();\n\tgrid.info.origin.position.y = costmap->getOriginY();\n\tgrid.info.origin.position.z = 0.0;\n\tgrid.info.origin.orientation.x = 0.0;\n\tgrid.info.origin.orientation.y = 0.0;\n\tgrid.info.origin.orientation.z = 0.0;\n\tgrid.info.origin.orientation.w = 1.0;\n\n\t// Resize the grid data vector\n\tgrid.data.resize(grid.info.width * grid.info.height);\n\n\t// Unlock the mutex\n\tmutex.unlock();\n}\n", "CodeBleu_score": 37.45057227466014}, {"code": "void Costmap2DPublisher::prepareGrid()\t// Lock the costmap mutex.\n\tcostmap_mutex_.lock();\n\n\t// Retrieve the resolution.\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header.\n\tgrid_msg_.header.frame_id = frame_id_;\n\tgrid_msg_.header.stamp = ros::Time::now();\n\n\t// Set the grid's resolution, width, and height.\n\tgrid_msg_.info.resolution = resolution;\n\tgrid_msg_.info.width = costmap_->getSizeInCellsX();\n\tgrid_msg_.info.height = costmap_->getSizeInCellsY();\n\n\t// Set the grid's origin.\n\t// Convert the map coordinates to world coordinates for the origin.\n\tdouble origin_x = costmap_->getOriginX() * resolution;\n\tdouble origin_y = costmap_->getOriginY() * resolution;\n\t// Set the origin's position and orientation.\n\tgrid_msg_.info.origin.position.x = origin_x;\n\tgrid_msg_.info.origin.position.y = origin_y;\n\tgrid_msg_.info.origin.position.z = 0.0;\n\tgrid_msg_.info.origin.orientation.x = 0.0;\n\tgrid_msg_.info.origin.orientation.y = 0.0;\n\tgrid_msg_.info.origin.orientation.z = 0.0;\n\tgrid_msg_.info.origin.orientation.w = 1.0;\n\n\t// Resize the grid data vector.\n\tgrid_msg_.data.resize(grid_msg_.info.width * grid_msg_.info.height);\n\n\t// Unlock the costmap mutex.\n\tcostmap_mutex_.unlock();\n}\n", "CodeBleu_score": 44.762673360323625}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\tif (new_config.footprint == old_config.footprint && new_config.footprint_radius == old_config.footprint_radius) {\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.size() > 0) {\n\t\tif (!footprint_.setFromString(new_config.footprint)) {\n\t\t\tROS_ERROR(\"Invalid footprint string given in configuration.\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tfootprint_.setLengthAndWidth(new_config.footprint_radius, new_config.footprint_radius);\n\t}\n\n\tfootprint_ = footprint_.toPolygon();\n\tfootprint_radius_ = new_config.footprint_radius;\n\tfootprint_clearing_ = new_config.footprint_clearing;\n\tfootprint_padding_ = new_config.footprint_padding;\n}\n", "CodeBleu_score": 55.3022728193121}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\tif (new_config.robot_radius == old_config.robot_radius && new_config.footprint == old_config.footprint)\n\t\treturn;\n\n\tif (new_config.footprint!= \"\") {\n\t\tif (!costmap_2d::parseFootprint(new_config.footprint, footprint_)) {\n\t\t\tROS_ERROR(\"Invalid robot footprint received from parameter server. Footprint will not be used.\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tfootprint_.clear();\n\t\tdouble radius = new_config.robot_radius;\n\t\tif (radius <= 0) {\n\t\t\tROS_WARN(\"Invalid robot radius received from parameter server.  Footprint will not be used.\");\n\t\t\treturn;\n\t\t}\n\t\tfootprint_.push_back(Eigen::Vector2d(-radius, -radius));\n\t\tfootprint_.push_back(Eigen::Vector2d(-radius, radius));\n\t\tfootprint_.push_back(Eigen::Vector2d(radius, radius));\n\t\tfootprint_.push_back(Eigen::Vector2d(radius, -radius));\n\t}\n\n\tfootprint_spec_ = new_config.footprint;\n\tfootprint_padding_ = new_config.footprint_padding;\n\tfootprint_clearing_ = new_config.clear_footprint;\n\tfootprint_cost_ = new_config.footprint_cost;\n\tfootprint_resolution_ = new_config.footprint_resolution;\n\tfootprint_min_dist_ = new_config.footprint_min_dist;\n\n\tROS_INFO(\"Footprint set to: %s\", footprint_spec_.c_str());\n}\n", "CodeBleu_score": 48.83914136396717}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.robot_radius == old_config.robot_radius && new_config.footprint == old_config.footprint) {\n\t\treturn;\n\t}\n\n\t// If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n\tif (new_config.footprint!= \"\") {\n\t\ttry {\n\t\t\tfootprint_spec_ = boost::assign::list_of(new_config.footprint);\n\t\t\tfootprint_ = footprint_spec_.toPolygon();\n\t\t} catch (const std::exception &e) {\n\t\t\tROS_ERROR(\"Failed to parse footprint string '%s' as footprint: %s\", new_config.footprint.c_str(), e.what());\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t// If the footprint string is invalid, it logs an error.\n\t\tif (new_config.footprint!= \"\") {\n\t\t\tROS_ERROR(\"Invalid footprint string '%s'\", new_config.footprint.c_str());\n\t\t}\n\t\t// If no valid footprint string is provided, it sets the footprint based on the robot radius.\n\t\tfootprint_spec_ = boost::assign::list_of(std::to_string(new_config.robot_radius));\n\t\tfootprint_ = footprint_spec_.toPolygon();\n\t}\n\n\t// Sets the robot radius to the new robot radius.\n\trobot_radius_ = new_config.robot_radius;\n\t// Sets the robot footprint to the new footprint.\n\tfootprint_ = footprint_spec_.toPolygon();\n\t// Sets the robot footprint to the new footprint.\n\tfootprint_ = footprint_spec_.toPolygon();\n\t// Sets the robot footprint to the new footprint.\n\tfootprint_ = footprint_spec_.toPolygon();\n\t// Sets the robot footprint to the new footprint.\n\tfootprint_ = footprint_spec_.toPolygon();\n\t// Sets the robot footprint to the new footprint.\n\tfootprint_ = footprint_spec_.toPolygon();\n\t// Sets the robot footprint to the new", "CodeBleu_score": 52.11989794028721}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\tros::NodeHandle n;\n\tros::NodeHandle private_nh(\"~\");\n\tros::Publisher costmap_publisher;\n\tros::Subscriber sub;\n\tros::Subscriber sub_pose;\n\tros::Subscriber sub_scan;\n\tros::Subscriber sub_odom;\n\tros::Subscriber sub_move_base_goal;\n\tros::Subscriber sub_move_base_cancel;\n\tros::Subscriber sub_move_base_status;\n\tros::Subscriber sub_move_base_feedback;\n\tros::Subscriber sub_move_base_result;\n\tros::Subscriber sub_move_base_action;\n\tros::Subscriber sub_move_base_plan;\n\tros::Subscriber sub_move_base_clear_costmap;\n\tros::Subscriber sub_move_base_global_plan;\n\tros::Subscriber sub_move_base_local_plan;\n\tros::Subscriber sub_move_base_update_map;\n\tros::Subscriber sub_move_base_update_map_cost;\n\tros::Subscriber sub_move_base_update_map_meta;\n\tros::Subscriber sub_move_base_update_map_meta_cost;\n\tros::Subscriber sub_move_base_update_map_meta_cost_clear;\n\tros::Subscriber sub_move_base_update_map_meta_cost_clear_cost;\n\tros::Subscriber sub_move_base_update_map_meta_cost_clear_cost_clear;\n\tros::Subscriber sub_move_base_update_map_meta_cost_clear_cost_clear_cost;\n\tros::Subscriber sub_move_base_update_map_meta_cost_clear_cost_clear_cost_clear;\n\tros::Subscriber sub_move_base_update_map_meta_cost_clear_cost_clear_cost_clear_cost;\n\tros::Subscriber sub_move_base_update_map_meta_cost_clear_cost_clear_cost_clear_cost_clear;\n\tros::Subscriber sub_move_base_update_map_meta_cost_clear_cost_clear_cost_clear_cost_clear_cost;\n\tros::Subscriber sub_move_base_update_map_meta_cost_", "CodeBleu_score": 11.902174601396245}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\tgeometry_msgs::PoseStamped new_pose;\n\ttry {\n\t\tnew_pose = tf_.transformPose(global_frame_, robot_pose_);\n\t} catch (tf::TransformException &ex) {\n\t\tROS_WARN(\"Failed to compute transform between %s and %s: %s\", global_frame_.c_str(),\n\t\t\t\trobot_frame_.c_str(), ex.what());\n\t\treturn;\n\t}\n\tdouble x_diff = new_pose.pose.position.x - robot_pose_.pose.position.x;\n\tdouble y_diff = new_pose.pose.position.y - robot_pose_.pose.position.y;\n\tdouble theta_diff = tf::getYaw(new_pose.pose.orientation) - tf::getYaw(robot_pose_.pose.orientation);\n\tdouble dist = sqrt(x_diff * x_diff + y_diff * y_diff);\n\tdouble theta = atan2(y_diff, x_diff);\n\tdouble delta_x = dist * cos(theta + theta_diff / 2);\n\tdouble delta_y = dist * sin(theta + theta_diff / 2);\n\tdouble delta_theta = theta_diff;\n\tdouble delta_dist = dist;\n\tdouble delta_theta_diff = theta_diff;\n\tif (dist > 0.0) {\n\t\tif (theta_diff > M_PI)\n\t\t\ttheta_diff -= 2 * M_PI;\n\t\telse if (theta_diff < -M_PI)\n\t\t\ttheta_diff += 2 * M_PI;\n\t}\n\tdouble delta_x_diff = delta_x * delta_theta_diff / dist;\n\tdouble delta_y_diff = delta_y * delta_theta_diff / dist;\n\tdouble delta_dist_diff = delta_dist * delta_theta_diff / dist;\n\tdouble delta_theta_diff_diff = delta_theta_diff * delta_theta_diff / dist;\n\tdouble delta_x_diff_diff = delta_x_diff * delta_theta_diff_diff / dist;\n\tdouble delta_y_diff_diff = delta_y_diff * delta_theta_diff_diff / dist;\n\tdouble delta_dist", "CodeBleu_score": 38.89913328265256}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\tros::NodeHandle private_nh(\"~\");\n\n\t// Get the robot's current pose\n\tgeometry_msgs::PoseStamped new_pose;\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\t// If the robot has moved, reconfigure the costmap\n\tif (new_pose.pose.position.x!= last_pose.pose.position.x || new_pose.pose.position.y!= last_pose.pose.position.y) {\n\t\tROS_INFO(\"Reconfiguring costmap\");\n\t\treconfigure();\n\t}\n}\n", "CodeBleu_score": 61.69408714860197}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()\tif (stopped_) {\n\t\t// If the costmap is stopped, we need to reactivate the plugins\n\t\t// and set the stopped flag to false\n\t\tfor (unsigned int i = 0; i < plugins_.size(); ++i) {\n\t\t\tplugins_[i]->activate();\n\t\t}\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\t}\n\n\t// Wait for the costmap to be initialized\n\twhile (!is_initialized_) {\n\t\tros::spinOnce();\n\t\tros::Duration(0.01).sleep();\n\t}\n\n\t// Wait for the map update thread to be active\n\twhile (!map_update_thread_.isActive()) {\n\t\tros::spinOnce();\n\t\tros::Duration(0.01).sleep();\n\t}\n}\n", "CodeBleu_score": 44.191836160669276}, {"code": "void Costmap2DROS::start()\t// get the list of plugins\n\tvector<string> plugins = getPlugins();\n\n\t// check if the costmap was stopped\n\tif (stopped_) {\n\t\t// re-subscribe to topics\n\t\tfor (unsigned int i = 0; i < plugins.size(); ++i) {\n\t\t\tif (plugins[i] == \"static_layer\") {\n\t\t\t\tstatic_layer_->subscribe();\n\t\t\t} else if (plugins[i] == \"obstacle_layer\") {\n\t\t\t\tobstacle_layer_->subscribe();\n\t\t\t} else if (plugins[i] == \"inflation_layer\") {\n\t\t\t\tinflation_layer_->subscribe();\n\t\t\t} else if (plugins[i] == \"raytrace_layer\") {\n\t\t\t\traytrace_layer_->subscribe();\n\t\t\t} else if (plugins[i] == \"voxel_layer\") {\n\t\t\t\tvoxel_layer_->subscribe();\n\t\t\t}\n\t\t}\n\n\t\t// set stopped flag to false\n\t\tstopped_ = false;\n\t}\n\n\t// set stop_updates to false\n\tstop_updates_ = false;\n\n\t// wait for ROS to be initialized\n\tros::Rate r(10);\n\twhile (!ros::isInitialized()) {\n\t\tROS_WARN_THROTTLE(1, \"Waiting for ROS to be initialized\");\n\t\tr.sleep();\n\t}\n\n\t// wait for the costmap to be initialized\n\twhile (!is_initialized_) {\n\t\tROS_WARN_THROTTLE(1, \"Waiting for costmap to be initialized\");\n\t\tr.sleep();\n\t}\n\n\t// wait for the map update thread to be active\n\twhile (!map_update_thread_->isActive()) {\n\t\tROS_WARN_THROTTLE(1, \"Waiting for map update thread to be active\");\n\t\tr.sleep();\n\t}\n}\n", "CodeBleu_score": 52.245615300581605}, {"code": "void Costmap2DROS::start()\t// Get the list of plugins and check if the costmap was stopped\n\tstd::vector<std::string> plugins = getPlugins();\n\tbool stopped = isStopped();\n\n\t// If stopped, re-subscribe to topics by activating each plugin and set stopped flag to false\n\tif (stopped) {\n\t\tfor (std::vector<std::string>::const_iterator plugin = plugins.begin(); plugin!= plugins.end(); ++plugin) {\n\t\t\tactivatePlugin(*plugin);\n\t\t}\n\t\tsetStopped(false);\n\t}\n\n\t// Set stop_updates_ to false\n\tsetStopUpdates(false);\n\n\t// Wait for ROS to be running, the costmap to be initialized, and the map update thread to be active\n\twhile (!ros::isInitialized()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\tros::start();\n\tros::Time::init();\n\twhile (!isCurrent()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\twhile (!isMapUpdated()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\twhile (!isMapThreadActive()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// Publish the costmap\n\tpublishCostmap();\n}\n", "CodeBleu_score": 36.81236833633571}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\tobservation_list_.clear();\n\t} else {\n\t\twhile (observation_list_.size() > 0) {\n\t\t\tObservation *obs = observation_list_.back();\n\t\t\tif (obs->time_since_last_observation() < observation_keep_time_) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tobservation_list_.pop_back();\n\t\t\tdelete obs;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 26.52138464974783}, {"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\tobservations_.clear();\n\t\treturn;\n\t}\n\n\t// Remove all observations that are older than the specified keep time\n\tfor (auto it = observations_.begin(); it!= observations_.end();) {\n\t\tif (it->time_received_ + observation_keep_time_ < ros::Time::now()) {\n\t\t\tit = observations_.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 27.780342058954393}, {"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\tobservations_.clear();\n\t} else {\n\t\twhile (!observations_.empty() && observations_.back().time < ros::Time::now() - observation_keep_time_) {\n\t\t\tobservations_.pop_back();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 20.523458292549147}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\tdouble start_yaw = path[start_index].pose.orientation.z;\n\tdouble end_yaw = path[end_index].pose.orientation.z;\n\tdouble yaw_diff = end_yaw - start_yaw;\n\tdouble yaw_diff_abs = fabs(yaw_diff);\n\n\t// If yaw difference is more than 180 degrees, subtract 360 degrees from yaw difference\n\tif (yaw_diff_abs > M_PI) {\n\t\tyaw_diff = yaw_diff - 2 * M_PI;\n\t}\n\n\t// If yaw difference is less than -180 degrees, add 360 degrees to yaw difference\n\tif (yaw_diff_abs < -M_PI) {\n\t\tyaw_diff = yaw_diff + 2 * M_PI;\n\t}\n\n\t// If yaw difference is greater than 180 degrees, set yaw difference to 360 - yaw difference\n\tif (yaw_diff > M_PI) {\n\t\tyaw_diff = 2 * M_PI - yaw_diff;\n\t}\n\n\t// If yaw difference is less than -180 degrees, set yaw difference to -360 + yaw difference\n\tif (yaw_diff < -M_PI) {\n\t\tyaw_diff = -2 * M_PI - yaw_diff;\n\t}\n\n\t// Calculate incremental change in yaw for each pose in the specified range\n\tdouble yaw_increment = yaw_diff / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble yaw = start_yaw + yaw_increment * (i - start_index);\n\t\tpath[i].pose.orientation.z = yaw;\n\t}\n}\n", "CodeBleu_score": 48.58370202166481}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\t// TODO: Implement this function.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.\n\t// HINT: Use the yaw_angle_difference function to compute the change in yaw angle between the start and end indices.", "CodeBleu_score": 7.614014111362326}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\tdouble start_yaw = path[start_index].pose.orientation.z;\n\tdouble end_yaw = path[end_index].pose.orientation.z;\n\tdouble yaw_diff = end_yaw - start_yaw;\n\tdouble yaw_diff_abs = abs(yaw_diff);\n\tdouble yaw_diff_sign = yaw_diff / yaw_diff_abs;\n\tdouble yaw_diff_sign_abs = abs(yaw_diff_sign);\n\tdouble yaw_diff_sign_abs_half = yaw_diff_sign_abs / 2.0;\n\tdouble yaw_diff_sign_abs_half_abs = abs(yaw_diff_sign_abs_half);\n\tdouble yaw_diff_sign_abs_half_abs_half = yaw_diff_sign_abs_half_abs / 2.0;\n\tdouble yaw_diff_sign_abs_half_abs_half_abs = abs(yaw_diff_sign_abs_half_abs_half);\n\tdouble yaw_diff_sign_abs_half_abs_half_abs_half = yaw_diff_sign_abs_half_abs_half_abs / 2.0;\n\tdouble yaw_diff_sign_abs_half_abs_half_abs_half_abs = abs(yaw_diff_sign_abs_half_abs_half_abs_half);\n\tdouble yaw_diff_sign_abs_half_abs_half_abs_half_abs_half = yaw_diff_sign_abs_half_abs_half_abs_half_abs / 2.0;\n\tdouble yaw_diff_sign_abs_half_abs_half_abs_half_abs_half_abs = abs(yaw_diff_sign_abs_half_abs_half_abs_half_abs_half);\n\tdouble yaw_diff_sign_abs_half_abs_half_abs_half_abs_half_abs_half = yaw_diff_sign_abs_half_abs_half_abs_half_abs_half_abs / 2.0;\n\tdouble yaw_diff_sign_abs_half_abs_half_abs_half_abs_half_abs_half_abs = abs(yaw_diff_sign_abs_", "CodeBleu_score": 33.95354847696561}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tROS_INFO(\"PlannerWithCostmap::makePlanService\");\n\n\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tmakePlan(req.start, req.goal, resp.plan);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tif (!resp.plan.empty()) {\n\t\tresp.success = true;\n\t} else {\n\t\tROS_WARN(\"PlannerWithCostmap::makePlanService: Failed to find a plan\");\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 47.91990261898549}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Generate a path using makePlan\n\tnav_msgs::Path path;\n\tbool found_path = makePlan(req.start, req.goal, path);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tresp.success = found_path;\n\tif (found_path) {\n\t\tresp.plan.poses.resize(path.poses.size());\n\t\tfor (int i = 0; i < path.poses.size(); i++) {\n\t\t\tresp.plan.poses[i] = path.poses[i];\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 67.26226498562244}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tROS_INFO(\"Received a plan request for the following start and goal\");\n\tROS_INFO(\"Start: (%.2f, %.2f)\", req.start.pose.position.x, req.start.pose.position.y);\n\tROS_INFO(\"Goal: (%.2f, %.2f)\", req.goal.pose.position.x, req.goal.pose.position.y);\n\n\t// Set frame_id to map\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call the planner to find a path\n\tnavfn::MakeNavPlan::Response res;\n\tif (makePlan(req.start, req.goal, res.plan)) {\n\t\tROS_INFO(\"Found a plan\");\n\t\tresp = res;\n\t\treturn true;\n\t} else {\n\t\tROS_INFO(\"Failed to find a plan\");\n\t\tresp.plan.poses.clear();\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 53.382387044546384}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\t// TODO Auto-generated constructor stub\n\tros::NodeHandle private_nh(\"~/\" + name);\n\tprivate_nh.param(\"max_planning_retries\", max_planning_retries_, 1);\n\tprivate_nh.param(\"planning_retries_before_out\", planning_retries_before_out_, 0);\n\tprivate_nh.param(\"planning_retries_before_switch\", planning_retries_before_switch_, 0);\n\tprivate_nh.param(\"planner_frequency\", planner_frequency_, 0.0);\n\tprivate_nh.param(\"oscillation_timeout\", oscillation_timeout_, 0.0);\n\tprivate_nh.param(\"oscillation_distance\", oscillation_distance_, 0.0);\n\tprivate_nh.param(\"expand_discretization\", expand_discretization_, 0.0);\n\tprivate_nh.param(\"expand_joint_resolution\", expand_joint_resolution_, 0.0);\n\tprivate_nh.param(\"goal_distance_bias\", goal_distance_bias_, 0.0);\n\tprivate_nh.param(\"publish_voxel_grid\", publish_voxel_grid_, false);\n\tprivate_nh.param(\"publish_cost_grid\", publish_cost_grid_, false);\n\tprivate_nh.param(\"publish_plan\", publish_plan_, false);\n\tprivate_nh.param(\"publish_potential_function\", publish_potential_function_, false);\n\tprivate_nh.param(\"publish_potential_function_voxel_grid\", publish_potential_function_voxel_grid_, false);\n\tprivate_nh.param(\"publish_potential_function_cost_grid\", publish_potential_function_cost_grid_, false);\n\tprivate_nh.param(\"publish_potential_function_voxel_grid_cost_grid\", publish_potential_function_voxel_grid_cost_grid_, false);\n\tprivate_nh.param(\"publish_potential_function_voxel_grid_cost_grid_potential_function\", publish_potential_function_voxel_grid_cost_grid_potential_function_, false);\n\tprivate_nh.param(\"publish_potential_function_voxel_grid_potential_function\", publish_potential_function_voxel_grid_potential_function_, false", "CodeBleu_score": 31.932264454639192}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\t// Initialize private node handle\n\tros::NodeHandle private_nh(\"~/\" + name);\n\n\t// Advertise service for making a plan\n\tmake_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\n\n\t// Subscribe to goal topic\n\tgoal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}\n", "CodeBleu_score": 53.13984943474757}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\tros::NodeHandle private_nh(\"~/\" + name);\n\tprivate_nh.param(\"planner_frequency\", planner_frequency, 0.0);\n\tprivate_nh.param(\"planner_patience\", planner_patience, 0.0);\n\tprivate_nh.param(\"planner_wait_time\", planner_wait_time, 0.0);\n\tprivate_nh.param(\"planner_num_planning_attempts\", planner_num_planning_attempts, 0);\n\tprivate_nh.param(\"planner_max_planning_attempts\", planner_max_planning_attempts, 0);\n\tprivate_nh.param(\"planner_min_dist_to_goal\", planner_min_dist_to_goal, 0.0);\n\tprivate_nh.param(\"planner_min_dist_to_robot\", planner_min_dist_to_robot, 0.0);\n\tprivate_nh.param(\"planner_max_dist_to_robot\", planner_max_dist_to_robot, 0.0);\n\tprivate_nh.param(\"planner_use_dijkstra\", planner_use_dijkstra, false);\n\tprivate_nh.param(\"planner_use_astar\", planner_use_astar, false);\n\tprivate_nh.param(\"planner_use_dwa\", planner_use_dwa, false);\n\tprivate_nh.param(\"planner_use_lattice\", planner_use_lattice, false);\n\tprivate_nh.param(\"planner_use_lattice_dwa\", planner_use_lattice_dwa, false);\n\tprivate_nh.param(\"planner_use_lattice_dwa_local\", planner_use_lattice_dwa_local, false);\n\tprivate_nh.param(\"planner_use_lattice_dwa_global\", planner_use_lattice_dwa_global, false);\n\tprivate_nh.param(\"planner_use_lattice_dwa_global_local\", planner_use_lattice_dwa_global_local, false);\n\tprivate_nh.param(\"planner_use_lattice_dwa_global_local_odom\", pl", "CodeBleu_score": 32.175606864675096}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\t// Check if the world coordinates are within the bounds of the costmap's origin.\n\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\n\t// Calculate the map coordinates using the costmap's resolution and an offset.\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\t// Check if the map coordinates are within the costmap's size limits.\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 44.15650011347656}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_WARN(\"The point (%f, %f) is not in the costmap.\", wx, wy);\n\t\treturn false;\n\t}\n\n\t// Calculate the map coordinates using the costmap's resolution and an offset\n\tdouble resolution = costmap_->getResolution();\n\tmx = (wx - costmap_->getOriginX()) / resolution;\n\tmy = (wy - costmap_->getOriginY()) / resolution;\n\n\t// Check if the map coordinates are within the costmap's size limits\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\tROS_WARN(\"The point (%f, %f) is not in the costmap.\", wx, wy);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 50.48070853071631}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\t// Check if the world coordinates are within the bounds of the costmap's origin.\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n\t\treturn false;\n\t}\n\n\t// Calculate the map coordinates using the costmap's resolution and an offset.\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\t// Check if the map coordinates are within the costmap's size limits.\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 47.66095261016683}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif(!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = global_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor(unsigned int i=0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 77.1764511897963}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = global_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (std::size_t i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 77.08293683057185}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif(!initialized_) {\n\t\tROS_ERROR(\"You called publishPlan, but the global planner has not been initialized, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t// create a Path message and copy the poses into it\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tfor(unsigned int i=0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tgui_path.header.frame_id = global_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// publish the path\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 77.37848349537148}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG_NAMED(\"move_base\", \"In move_base goal callback\");\n\n\t// Copy the goal\n\tgeometry_msgs::PoseStamped goal_copy = *goal;\n\n\t// We don't want the update time to be the current time\n\tgoal_copy.header.stamp = ros::Time();\n\n\t// Next we'll publish the goal here\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = goal_copy;\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 66.86826908270693}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG(\"Received a goal.\");\n\t// Wrap the goal in an action message.\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal.goal.target_pose.header.frame_id = \"map\";\n\taction_goal.goal.target_pose.header.stamp = ros::Time::now();\n\tROS_DEBUG(\"Publishing action goal.\");\n\t// Publish the action goal.\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 60.102264936762005}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG(\"Received a goal of type PoseStamped\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 68.67706411725216}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tif(std::sqrt(std::pow(current_distance.x - last_distance.x, 2) + std::pow(current_distance.y - last_distance.y, 2)) > std::pow(limited_distance, 2)) {\n\t\tROS_INFO(\"Robot has moved far enough, stopping distance check timer and clearing speed limit.\");\n\t\tros::Timer::CancelOption cancel;\n\t\tdistance_check_timer.stop(cancel);\n\t\tif(remove_limit_thread.joinable()) {\n\t\t\tremove_limit_thread.join();\n\t\t}\n\t\tremove_limit_thread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\t\tdistance_check_timer.start();\n\t}\n}\n", "CodeBleu_score": 43.95484399342294}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tif (distanceSquared > limitedDistanceSquared) {\n\t\tROS_INFO(\"Robot has moved %f meters. Distance limit is now %f meters.\", sqrt(distanceSquared), sqrt(limitedDistanceSquared));\n\t\tif (removeLimitThread) {\n\t\t\tremoveLimitThread->join();\n\t\t\tdelete removeLimitThread;\n\t\t\tremoveLimitThread = nullptr;\n\t\t}\n\t\tremoveLimitThread = new std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistanceTimer.stop();\n\t}\n}\n", "CodeBleu_score": 44.45824778501597}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tif (distance_squared > limited_distance_squared) {\n\t\tROS_INFO(\"Robot has moved a sufficient distance\");\n\t\tdistance_squared = 0;\n\t\tdistance_check_timer.stop();\n\t\tif (remove_limit_thread!= NULL) {\n\t\t\tremove_limit_thread->join();\n\t\t\tdelete remove_limit_thread;\n\t\t\tremove_limit_thread = NULL;\n\t\t}\n\t\tremove_limit_thread = new boost::thread(&MoveSlowAndClear::removeLimit, this);\n\t}\n}\n", "CodeBleu_score": 57.411267933756605}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\t//ROS_INFO(\"Pose callback\");\n\tif (initialized_) {\n\t\tif (goal->header.frame_id == costmap_ros_->getGlobalFrameID()) {\n\t\t\t//ROS_INFO(\"Pose callback: goal is in global frame\");\n\t\t\t//ROS_INFO(\"Pose callback: goal is in global frame\");\n\t\t\tif (makePlan(goal->pose, global_plan_)) {\n\t\t\t\tROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"Plan found\");\n\t\t\t\t//ROS_INFO(\"", "CodeBleu_score": 23.515882576881832}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\t// Get the current pose of the robot\n\tPoseStamped robot_pose;\n\tgetRobotPose(robot_pose);\n\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<PoseStamped> path;\n\tmakePlan(robot_pose, *goal, path);\n\n\t// Publish the path\n\tpublishPath(path);\n}\n", "CodeBleu_score": 56.50600907225204}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\t// TODO: Implement this function\n\t// Get the current robot pose\n\tPoseStamped robot_pose;\n\tgetRobotPose(robot_pose);\n\n\t// Generate a path from the current pose to the goal pose\n\tvector<PoseStamped> path;\n\tmakePlan(robot_pose, goal->pose, path);\n\n\t// Publish the path\n\tpublishPath(path);\n}\n", "CodeBleu_score": 54.218583790904106}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tstruct ParamSet param_set_request;\n\tparam_set_request.id = param_set.id;\n\tparam_set_request.value = param_set.value;\n\tparam_set_client_.call(param_set_request);\n}\n", "CodeBleu_score": 49.19721510585481}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tstruct ParamSet param_set_req;\n\tparam_set_req.id = param_set.id;\n\tparam_set_req.value = param_set.value;\n\tparam_set_client_.call(param_set_req);\n}\n", "CodeBleu_score": 47.728317922225266}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\t// Create a new service request\n\tstruct ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\t// Call the param_set_client_ to send the request\n\tparam_set_client_.call(srv);\n}\n", "CodeBleu_score": 63.23232860942184}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()\tint sockfd, newsockfd, portno;\n\tsocklen_t clilen;\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tchar buffer[256];\n\tint n;\n\n\t// Create a socket\n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tROS_ERROR(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\n\t// Set the port number\n\tportno = 5001;\n\n\t// Set the server address\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(portno);\n\n\t// Bind the socket to the server address\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tROS_ERROR(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\n\t// Listen for incoming connections\n\tlisten(sockfd, 5);\n\tclilen = sizeof(cli_addr);\n\n\t// Accept incoming connections\n\twhile (1) {\n\t\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\t\tif (newsockfd < 0) {\n\t\t\tROS_ERROR(\"ERROR on accept\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Receive data from the client\n\t\tbzero(buffer, 256);\n\t\tn = read(newsockfd, buffer, 255);\n\t\tif (n < 0) {\n\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Decode the received message\n\t\tstd::string message = buffer;\n\t\tstd::vector<std::string> message_parts = split(message, ',');\n\t\tif (message_parts.size() == 3) {\n\t\t\t// Publish the message\n\t\t\tstd_msgs::String msg;\n\t\t\tmsg.data = message;\n\t\t\tpub_msg.publish(msg);\n\t\t} else {\n\t\t\tROS_ERROR(\"ERROR", "CodeBleu_score": 41.99265263782208}, {"code": "void CommunicationBridge::serverFun()\t// Create a socket\n\tint serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverSocket < 0) {\n\t\tROS_ERROR(\"Failed to create socket\");\n\t\treturn;\n\t}\n\n\t// Bind the socket to a port\n\tstruct sockaddr_in serverAddress;\n\tserverAddress.sin_family = AF_INET;\n\tserverAddress.sin_addr.s_addr = INADDR_ANY;\n\tserverAddress.sin_port = htons(port);\n\tif (bind(serverSocket, (struct sockaddr*) &serverAddress, sizeof(serverAddress)) < 0) {\n\t\tROS_ERROR(\"Failed to bind socket to port %d\", port);\n\t\treturn;\n\t}\n\n\t// Listen for incoming connections\n\tif (listen(serverSocket, 1) < 0) {\n\t\tROS_ERROR(\"Failed to listen for incoming connections\");\n\t\treturn;\n\t}\n\n\t// Accept incoming connections\n\tstruct sockaddr_in clientAddress;\n\tsocklen_t clientAddressLength = sizeof(clientAddress);\n\tint clientSocket = accept(serverSocket, (struct sockaddr*) &clientAddress, &clientAddressLength);\n\tif (clientSocket < 0) {\n\t\tROS_ERROR(\"Failed to accept incoming connection\");\n\t\treturn;\n\t}\n\n\t// Receive and process data\n\twhile (ros::ok()) {\n\t\t// Receive data\n\t\tchar buffer[256];\n\t\tint received = recv(clientSocket, buffer, sizeof(buffer), 0);\n\t\tif (received <= 0) {\n\t\t\tROS_ERROR(\"Failed to receive data\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// Decode the message\n\t\tstd::string message(buffer, received);\n\t\tstd::string decodedMessage = decodeMessage(message);\n\n\t\t// Publish the message\n\t\tif (decodedMessage.length() > 0) {\n\t\t\tstd::istringstream iss(decodedMessage);\n\t\t\tstd::string topic;\n\t\t\tstd::string message;\n\t\t\tstd::getline(iss, topic, ':');\n\t\t\tstd::getline(iss, message);\n\t\t\tif (topic == \"imu\") {\n\t\t\t\tsensor_msgs::Imu imu;\n\t\t\t\timu.header.frame_id = \"imu_link\";\n\t\t\t\timu.header.", "CodeBleu_score": 39.2850108373115}, {"code": "void CommunicationBridge::serverFun()\t// Create a TCP socket\n\tint serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverSocket < 0) {\n\t\tROS_ERROR(\"Error creating socket\");\n\t\treturn;\n\t}\n\n\t// Bind the socket to the specified port\n\tstruct sockaddr_in serverAddr;\n\tserverAddr.sin_family = AF_INET;\n\tserverAddr.sin_addr.s_addr = INADDR_ANY;\n\tserverAddr.sin_port = htons(port);\n\tif (bind(serverSocket, (struct sockaddr *) &serverAddr, sizeof(serverAddr)) < 0) {\n\t\tROS_ERROR(\"Error binding socket\");\n\t\treturn;\n\t}\n\n\t// Listen for incoming connections\n\tif (listen(serverSocket, 1) < 0) {\n\t\tROS_ERROR(\"Error listening for connections\");\n\t\treturn;\n\t}\n\n\t// Accept incoming connections\n\twhile (ros::ok()) {\n\t\t// Accept the incoming connection\n\t\tstruct sockaddr_in clientAddr;\n\t\tsocklen_t clientAddrSize = sizeof(clientAddr);\n\t\tint clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddr, &clientAddrSize);\n\t\tif (clientSocket < 0) {\n\t\t\tROS_ERROR(\"Error accepting connection\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Receive data from the client\n\t\tchar buffer[256];\n\t\tint bytesReceived = recv(clientSocket, buffer, sizeof(buffer), 0);\n\t\tif (bytesReceived <= 0) {\n\t\t\tROS_ERROR(\"Error receiving data\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Decode the received data\n\t\tuint8_t data[bytesReceived];\n\t\tfor (int i = 0; i < bytesReceived; i++) {\n\t\t\tdata[i] = buffer[i];\n\t\t}\n\n\t\t// Publish the decoded data\n\t\tsensor_msgs::NavSatFix msg;\n\t\tif (decodeNavSatFix(data, bytesReceived, msg)) {\n\t\t\tnavSatFixPub.publish(msg);\n\t\t}\n\n\t\t// Close the socket\n\t\tclose(clientSocket);\n\t}\n}\n", "CodeBleu_score": 42.52857520318332}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id < swarm_control_simulation_.size()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (uav_cmd.uav_id >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif", "CodeBleu_score": 31.664552870341872}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\t// Check if in simulation mode\n\tif (sim_mode) {\n\t\t// Find the corresponding UAV in the swarm\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].id == uav_cmd.id) {\n\t\t\t\t// Publish the command to the UAV\n\t\t\t\tswarm_control_simulation_[i].uav_basic_pub.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Publish the command to the UAV\n\t\tuav_basic_pub.publish(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 38.04029372878342}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\t// Check if this is a simulation command\n\tif (simulation_mode_) {\n\t\t// Find the UAV with the matching ID\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].id == uav_cmd.id) {\n\t\t\t\t// Publish the command to the UAV\n\t\t\t\tswarm_control_simulation_[i].uav_basic.publish(uav_cmd);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Publish the command to the UAV\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 38.42590427636337}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\t// If we are in REBOOTNX mode, we need to execute REBOOTNX command\n\tif (mode_selection.mode == REBOOTNX) {\n\t\texecuteCommand(\"REBOOTNX\");\n\t}\n\n\t// If we are in EXITNX mode, we need to execute EXITNX command\n\tif (mode_selection.mode == EXITNX) {\n\t\texecuteCommand(\"EXITNX\");\n\t}\n\n\t// If we are in a normal mode, we need to create or delete the mode\n\tif (mode_selection.mode!= REBOOTNX && mode_selection.mode!= EXITNX) {\n\t\tif (mode_selection.use_mode) {\n\t\t\tcreateMode(mode_selection.mode);\n\t\t} else {\n\t\t\tdeleteMode(mode_selection.mode);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 47.793167506225345}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"sudo reboot\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"sudo poweroff\");\n\t} else {\n\t\tif (mode_selection.use_mode == CREATE_MODE) {\n\t\t\tcreateMode(mode_selection.mode_name);\n\t\t} else if (mode_selection.use_mode == DELETE_MODE) {\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 49.51460830827217}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\t//If the mode_selection is not valid, return\n\tif (mode_selection.mode_id < 0 || mode_selection.mode_id >= mode_count) {\n\t\treturn;\n\t}\n\n\t//If the mode_selection is for REBOOTNX, execute REBOOTNX command\n\tif (mode_selection.use_mode == REBOOTNX) {\n\t\texecuteCommand(REBOOTNX);\n\t}\n\t//If the mode_selection is for EXITNX, execute EXITNX command\n\telse if (mode_selection.use_mode == EXITNX) {\n\t\texecuteCommand(EXITNX);\n\t}\n\t//If the mode_selection is for create mode, execute createMode function\n\telse if (mode_selection.use_mode == CREATE_MODE) {\n\t\tcreateMode(mode_selection);\n\t}\n\t//If the mode_selection is for delete mode, execute deleteMode function\n\telse if (mode_selection.use_mode == DELETE_MODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n\t//If the mode_selection is for update mode, execute updateMode function\n\telse if (mode_selection.use_mode == UPDATE_MODE) {\n\t\tupdateMode(mode_selection);\n\t}\n}\n", "CodeBleu_score": 63.314628464230125}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\t// check heartbeat status\n\tif (heartbeat_status_ == HeartbeatStatus::HEARTBEAT_OK) {\n\t\theartbeat_count_ = 0;\n\t} else if (heartbeat_status_ == HeartbeatStatus::HEARTBEAT_LOST) {\n\t\t// heartbeat lost\n\t\tif (heartbeat_count_ < max_heartbeat_count_) {\n\t\t\t// heartbeat lost, but not yet reached max count\n\t\t\t++heartbeat_count_;\n\t\t} else {\n\t\t\t// heartbeat lost, and reached max count\n\t\t\t// print error message\n\t\t\tif (vehicle_type_ == VehicleType::SWARM) {\n\t\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting all UAVs.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t} else if (vehicle_type_ == VehicleType::UAV) {\n\t\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting UAV.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t} else if (vehicle_type_ == VehicleType::UGV) {\n\t\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting UGV.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t}\n\t\t\t// reset heartbeat count\n\t\t\theartbeat_count_ = 0;\n\t\t}\n\t} else if (heartbeat_status_ == HeartbeatStatus::HEARTBEAT_LOST_NO_RECONNECT) {\n\t\t// heartbeat lost, but no reconnect\n\t\tif (heartbeat_count_ < max_heartbeat_count_) {\n\t\t\t// heartbeat lost, but not yet reached max count\n\t\t\t++heartbeat_count_;\n\t\t} else {\n\t\t\t// heartbeat lost, and reached max count\n\t\t\t// print error message\n\t\t\tif (vehicle_type_ == VehicleType::SWARM) {\n\t\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting all UAVs.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t} else if (vehicle_type_ == VehicleType::UAV) {\n\t\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting UAV.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t} else if (vehicle_type_ == VehicleType::UGV) {\n\t\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting UGV.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t}\n\t\t\t// reset heartbeat count\n\t\t\theartbeat_count_ = 0;\n\t\t}\n\t} else {\n\t\t", "CodeBleu_score": 33.03091480466039}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\tros::Time time_now = ros::Time::now();\n\tif (heartbeat_flag == true) {\n\t\tif (time_now > (last_heartbeat_time + ros::Duration(heartbeat_timeout))) {\n\t\t\tROS_ERROR_STREAM(\"Heartbeat timeout!\");\n\t\t\tif (vehicle_type == \"swarm\") {\n\t\t\t\t//TODO: add swarm specific code here\n\t\t\t} else if (vehicle_type == \"UAV\") {\n\t\t\t\t//TODO: add UAV specific code here\n\t\t\t} else if (vehicle_type == \"UGV\") {\n\t\t\t\t//TODO: add UGV specific code here\n\t\t\t}\n\t\t\tdisconnect_flag = true;\n\t\t} else {\n\t\t\theartbeat_counter++;\n\t\t}\n\t}\n\tlast_heartbeat_time = time_now;\n}\n", "CodeBleu_score": 32.253423247606186}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\tstatic int heartbeat_counter = 0;\n\tstatic int heartbeat_counter_swarm = 0;\n\tstatic int heartbeat_counter_uav = 0;\n\tstatic int heartbeat_counter_ugv = 0;\n\tstatic int heartbeat_counter_swarm_uav = 0;\n\tstatic int heartbeat_counter_ugv_uav = 0;\n\tstatic int heartbeat_counter_ugv_swarm = 0;\n\tstatic int heartbeat_counter_uav_ugv = 0;\n\n\tif (vehicle_type == \"swarm\") {\n\t\tif (heartbeat_counter_swarm < heartbeat_counter_threshold) {\n\t\t\theartbeat_counter_swarm++;\n\t\t} else {\n\t\t\tROS_ERROR_STREAM(\"Heartbeat lost for swarm vehicle. Count: \" << heartbeat_counter_swarm);\n\t\t\tif (disconnect_flag_swarm == false) {\n\t\t\t\tROS_ERROR_STREAM(\"Disconnecting swarm vehicle.\");\n\t\t\t\tdisconnect_flag_swarm = true;\n\t\t\t} else {\n\t\t\t\tROS_ERROR_STREAM(\"Swarm vehicle still disconnected.\");\n\t\t\t}\n\t\t}\n\t} else if (vehicle_type == \"uav\") {\n\t\tif (heartbeat_counter_uav < heartbeat_counter_threshold) {\n\t\t\theartbeat_counter_uav++;\n\t\t} else {\n\t\t\tROS_ERROR_STREAM(\"Heartbeat lost for UAV vehicle. Count: \" << heartbeat_counter_uav);\n\t\t\tif (disconnect_flag_uav == false) {\n\t\t\t\tROS_ERROR_STREAM(\"Disconnecting UAV vehicle.\");\n\t\t\t\tdisconnect_flag_uav = true;\n\t\t\t} else {\n\t\t\t\tROS_ERROR_STREAM(\"UAV vehicle still disconnected.\");\n\t\t\t}\n\t\t}\n\t} else if (vehicle_type == \"ugv\") {\n\t\tif (heartbeat_counter_ugv < heartbeat_counter_threshold) {\n\t\t\theartbeat_counter_ugv++;\n\t\t} else {\n\t\t\tROS_ERROR_STREAM(\"Heartbeat lost for UGV vehicle. Count: \" << heartbeat_counter_ugv);\n\t\t\tif (disconnect_flag_ugv == false) {\n\t\t\t\tROS_ERROR_STREAM(\"Disconnecting UGV vehicle.\");\n\t\t\t\tdisconnect_flag_ugv = true;\n\t\t\t} else {\n\t\t\t\tROS_ERROR_STREAM(\"UGV vehicle still", "CodeBleu_score": 37.81889676038795}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\tROS_INFO(\"Received MultiBsplines message\");\n\t// For each trajectory, initialize a Bspline struct, set its attributes, and populate its knots, position points, and yaw points\n\tfor (int i = 0; i < msg->trajectories.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.id = msg->trajectories[i].id;\n\t\tbspline.knots = msg->trajectories[i].knots;\n\t\tbspline.points = msg->trajectories[i].points;\n\t\tbspline.yaw_points = msg->trajectories[i].yaw_points;\n\t\tbspline.num_points = msg->trajectories[i].num_points;\n\t\tbspline.num_knots = msg->trajectories[i].num_knots;\n\t\tbspline.num_yaw_points = msg->trajectories[i].num_yaw_points;\n\t\t// Encode the MultiBsplines data and send it via TCP using the communication module\n\t\tcomm.encode_and_send_bspline(bspline);\n\t}\n}\n", "CodeBleu_score": 30.780438563960615}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb\");\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list.size() = %d\", msg->trajectory_list.size());\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list[0].trajectory_id = %d\", msg->trajectory_list[0].trajectory_id);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list[0].trajectory_points.size() = %d\", msg->trajectory_list[0].trajectory_points.size());\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list[0].trajectory_points[0].position.x = %f\", msg->trajectory_list[0].trajectory_points[0].position.x);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list[0].trajectory_points[0].position.y = %f\", msg->trajectory_list[0].trajectory_points[0].position.y);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list[0].trajectory_points[0].position.z = %f\", msg->trajectory_list[0].trajectory_points[0].position.z);\n\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list[0].trajectory_points[0].yaw = %f\", msg->trajectory_list[0].trajectory_points[0].yaw);\n\n\tfor (int i = 0; i < msg->trajectory_list.size(); i++) {\n\t\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list[%d].trajectory_id = %d\", i, msg->trajectory_list[i].trajectory_id);\n\t\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg->trajectory_list[%d].trajectory_points.size() = %d\", i,", "CodeBleu_score": 12.239764233984317}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\tROS_INFO(\"Received a MultiBsplines message!\");\n\n\t// Initialize a Bspline struct for each trajectory\n\tfor (int i = 0; i < msg->trajectory.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.droneId = msg->trajectory[i].drone_id;\n\t\tbspline.trajId = msg->trajectory[i].traj_id;\n\t\tbspline.numPoints = msg->trajectory[i].num_points;\n\t\tbspline.numKnots = msg->trajectory[i].num_knots;\n\t\tbspline.knots = new double[bspline.numKnots];\n\t\tbspline.pos = new double[bspline.numPoints * 3];\n\t\tbspline.yaw = new double[bspline.numPoints];\n\n\t\t// Copy the knots from the message\n\t\tfor (int j = 0; j < bspline.numKnots; j++) {\n\t\t\tbspline.knots[j] = msg->trajectory[i].knots[j];\n\t\t}\n\n\t\t// Copy the position points from the message\n\t\tfor (int j = 0; j < bspline.numPoints * 3; j++) {\n\t\t\tbspline.pos[j] = msg->trajectory[i].pos[j];\n\t\t}\n\n\t\t// Copy the yaw points from the message\n\t\tfor (int j = 0; j < bspline.numPoints; j++) {\n\t\t\tbspline.yaw[j] = msg->trajectory[i].yaw[j];\n\t\t}\n\n\t\t// Add the Bspline struct to the list of Bsplines\n\t\tbsplines.push_back(bspline);\n\t}\n\n\t// Encode the Bsplines and send them via TCP\n\tencodeBsplines();\n}\n", "CodeBleu_score": 48.96185317747624}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Convert to PCL PointCloud\n\tpcl::PCLPointCloud2 pcl_pc2;\n\tpcl_conversions::toPCL(msg, pcl_pc2);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromPCLPointCloud2(pcl_pc2, *cloud);\n\n\t// Compress the PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.005f);\n\toctree.setInputCloud(cloud);\n\toctree.addPointsFromInputCloud();\n\toctree.compressPointCloud(*compressed_cloud);\n\n\t// Convert back to PCL PointCloud2\n\tpcl::PCLPointCloud2 pcl_pc2_compressed;\n\tpcl::toPCLPointCloud2(*compressed_cloud, pcl_pc2_compressed);\n\n\t// Convert back to ROS PointCloud2\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tpcl_conversions::fromPCL(pcl_pc2_compressed, compressed_msg);\n\n\treturn compressed_msg;\n}\n", "CodeBleu_score": 39.39724458799958}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Convert the input message to a pcl::PointCloud.\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Create a pcl::PointCloud<pcl::PointXYZ> object for the compressed point cloud.\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\n\t// Create a pcl::octree::OctreePointCloudCompression object to compress the point cloud.\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\n\t// Set the octree resolution (voxel size) to 0.01 m.\n\toctree_compression.setResolution(0.01);\n\n\t// Set the octree compression mode to LEVEL_OF_DETAIL.\n\toctree_compression.setPointCloudCompressionMode(pcl::octree::OctreePointCloudCompression<pcl::PointXYZ>::LODC);\n\n\t// Compress the point cloud using the octree compression technique.\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.addPointsFromInputCloud();\n\toctree_compression.filter(*compressed_cloud);\n\n\t// Create a new PointCloud2 message to store the compressed data.\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Convert the compressed point cloud to a PointCloud2 message.\n\tpcl::toROSMsg(*compressed_cloud, compressed_msg);\n\n\t// Set the header of the compressed message to match the original message.\n\tcompressed_msg.header = msg.header;\n\n\t// Set the frame ID of the compressed message to match the original message.\n\tcompressed_msg.header.frame_id = msg.header.frame_id;\n\n\t// Return the compressed message.\n\treturn compressed_msg;\n}\n", "CodeBleu_score": 40.45855164508223}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// create a pcl::PointCloud from the input message\n\tpcl::PCLPointCloud2 pcl_pc2;\n\tpcl_conversions::toPCL(msg, pcl_pc2);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromPCLPointCloud2(pcl_pc2, *pcl_cloud);\n\n\t// create a pcl::PointCloud2 message for the compressed point cloud\n\tpcl::PCLPointCloud2 pcl_pc2_compressed;\n\n\t// compress the point cloud\n\tpcl::io::compression::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.setInputCloud(pcl_cloud);\n\toctree_compression.setResolution(resolution);\n\toctree_compression.setPointType(pcl::io::compression::OctreePointCloudCompression<pcl::PointXYZ>::POINT_XYZ);\n\toctree_compression.compressPointCloud(pcl_pc2_compressed);\n\n\t// create a new point cloud message from the compressed point cloud\n\tsensor_msgs::PointCloud2 msg_compressed;\n\tpcl_conversions::fromPCL(pcl_pc2_compressed, msg_compressed);\n\n\t// return the compressed point cloud message\n\treturn msg_compressed;\n}\n", "CodeBleu_score": 35.814444625913545}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 52.70485476797218}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 52.70485476797218}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 57.5763087166318}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\t// Initialize the MultiUGVState message\n\tMultiUGVState msg;\n\tmsg.ugv_count = 0;\n\n\t// Iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t// Initialize the UGVState message\n\t\tUGVState ugv_state;\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\n\t\t// Add the UGVState message to the MultiUGVState message\n\t\tmsg.ugv_state.push_back(ugv_state);\n\t\tmsg.ugv_count++;\n\t}\n\n\t// Publish the MultiUGVState message\n\tugv_state_pub.publish(msg);\n}\n", "CodeBleu_score": 46.53859343590078}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\t// Initialize the MultiUGVState message\n\tMultiUGVState ugv_state_msg;\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t// Initialize the UGVState message\n\t\tUGVState ugv_state_msg;\n\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state_msg.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state_msg.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state_msg.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\n\t\t// Add the UGVState message to the MultiUGVState message\n\t\tugv_state_msg.ugv_state.push_back(ugv_state_msg", "CodeBleu_score": 36.69188073971335}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\t//Initialize the MultiUGVState message\n\tMultiUGVState all_ugv_state_msg;\n\n\t//Iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t//Initialize the UGVState message\n\t\tUGVState ugv_state_msg;\n\n\t\t//Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position = m_multi_ugv_state.ugv_state[i].position;\n\t\tugv_state_msg.velocity = m_multi_ugv_state.ugv_state[i].velocity;\n\t\tugv_state_msg.attitude = m_multi_ugv_state.ugv_state[i].attitude;\n\n\t\t//Add the UGVState message to the MultiUGVState message\n\t\tall_ugv_state_msg.ugv_state.push_back(ugv_state_msg);\n\t}\n\n\t//Publish the MultiUGVState message\n\tall_ugv_state_pub.publish(all_ugv_state_msg);\n}\n", "CodeBleu_score": 35.03225562905825}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\tfor (int i = 0; i < movingObjects.size(); i++) {\n\t\tEigen::VectorXd predictedPosition = movingObjects[i]->getPredictedPosition(q);\n\t\tfor (int j = 0; j < q.rows(); j++) {\n\t\t\tdouble distance = (predictedPosition.block(j, 0, 1, 3) - q.block(j, 0, 1, 3)).norm();\n\t\t\tif (distance < movingObjects[i]->getClearance()) {\n\t\t\t\tcost += (distance - movingObjects[i]->getClearance()) * (distance - movingObjects[i]->getClearance());\n\t\t\t\tgradient.block(j, 0, 1, 3) += 2.0 * (predictedPosition.block(j, 0, 1, 3) - q.block(j, 0, 1, 3)) / movingObjects[i]->getClearance();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 30.21642372545229}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// Initialize cost and gradient\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through control points\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute predicted position of moving object\n\t\tEigen::Vector3d pred_pos = this->moving_obj_model->predict(q.row(i));\n\n\t\t// Compute distance between control point and moving object\n\t\tdouble dist = (q.row(i) - pred_pos).norm();\n\n\t\t// Update cost and gradient based on distance\n\t\tif (dist < this->clearance) {\n\t\t\tcost += (dist - this->clearance) * (dist - this->clearance);\n\t\t\tgradient.row(i) += 2 * (dist - this->clearance) * (q.row(i) - pred_pos);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 24.824335744778224}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// calculate predicted positions of moving objects\n\tEigen::MatrixXd pred_obj_pos = calcMovingObjPos(q);\n\n\t// calculate distance between control points and moving objects\n\tEigen::VectorXd dist = (pred_obj_pos.colwise() - q.colwise()).rowwise().norm();\n\n\t// update cost and gradient based on distance error\n\tcost = 0;\n\tgradient.setZero();\n\tfor (int i = 0; i < dist.size(); i++) {\n\t\tif (dist(i) < clearance) {\n\t\t\tcost += (clearance - dist(i)) * (clearance - dist(i));\n\t\t\tgradient(i) = 2 * (clearance - dist(i));\n\t\t}\n\t}\n}\n", "CodeBleu_score": 25.92269492072316}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tcost = 0.0;\n\tgradient.setZero();\n\tEigen::MatrixXd ref_points = getReferencePoints();\n\tEigen::MatrixXd ref_points_dot = getReferencePointsDot();\n\tEigen::MatrixXd ref_points_ddot = getReferencePointsDDot();\n\tEigen::MatrixXd ref_points_dddot = getReferencePointsDDDot();\n\tEigen::MatrixXd ref_points_dddotdot = getReferencePointsDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdot = getReferencePointsDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdot = getReferencePointsDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdot = getReferencePointsDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdot = getReferencePointsDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDDDDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDDDDDDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdotdotdotdotdotdotdotdot = getReferencePointsDDDDDDDDDDDDDDDDDDDDDDDDDDot();\n\tEigen::MatrixXd ref_points_dddotdotdotdotdotdotdotdot", "CodeBleu_score": 9.578081056541839}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tcost = 0.0;\n\tgradient.setZero();\n\n\t// Compute the positional error and velocity vectors for each point.\n\tEigen::MatrixXd posError(3, q.rows());\n\tEigen::MatrixXd velVector(3, q.rows());\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\tposError.col(i) = q.col(i) - refPoints_.col(i);\n\t\tvelVector.col(i) = (q.col(i + 1) - q.col(i)) / dt_;\n\t}\n\n\t// Compute the cost and gradient for each point.\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\tdouble a = posError.col(i).dot(velVector.col(i));\n\t\tdouble b = posError.col(i).cross(velVector.col(i)).norm();\n\t\tcost += a * a / a2_ + b * b / b2_;\n\n\t\t// Compute the gradient for the point.\n\t\tgradient.col(i) = (2 * a / a2_ * posError.col(i) + 2 * b / b2_ * velVector.col(i).cross(posError.col(i))) / dt_;\n\t}\n}\n", "CodeBleu_score": 30.96403619813113}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\tfor (int i = 0; i < q.cols(); ++i) {\n\t\tEigen::Vector3d qi = q.col(i);\n\t\tEigen::Vector3d qi_ref = q_ref.col(i);\n\t\tEigen::Vector3d qi_dot = q_dot.col(i);\n\t\tEigen::Vector3d qi_dot_ref = q_dot_ref.col(i);\n\t\tEigen::Vector3d qi_dot_dot = q_dot_dot.col(i);\n\t\tEigen::Vector3d qi_dot_dot_ref = q_dot_dot_ref.col(i);\n\t\tEigen::Vector3d qi_dot_dot_dot = q_dot_dot_dot.col(i);\n\t\tEigen::Vector3d qi_dot_dot_dot_ref = q_dot_dot_dot_ref.col(i);\n\n\t\tEigen::Vector3d qi_dot_dot_dot_dot = q_dot_dot_dot_dot.col(i);\n\t\tEigen::Vector3d qi_dot_dot_dot_dot_ref = q_dot_dot_dot_dot_ref.col(i);\n\n\t\tEigen::Vector3d qi_dot_dot_dot_dot_dot = q_dot_dot_dot_dot_dot.col(i);\n\t\tEigen::Vector3d qi_dot_dot_dot_dot_dot_ref = q_dot_dot_dot_dot_dot_ref.col(i);\n\n\t\tEigen::Vector3d qi_dot_dot_dot_dot_dot_dot = q_dot_dot_dot_dot_dot_dot.col(i);\n\t\tEigen::Vector3d qi_dot_dot_dot_dot_dot_dot_ref = q_dot_dot_dot_dot_dot_dot_ref.col(i);\n\n\t\tEigen::Vector3d qi_dot_dot_dot_dot_dot_dot_dot = q_dot_dot_dot_dot_dot_dot_dot.col(i);\n\t\tEigen", "CodeBleu_score": 16.998944262050706}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()\t// Get the knot times and control points of the jerk trajectory\n\tdouble *knots = this->getKnots();\n\tdouble *jerk = this->getJerkTrajectory();\n\tdouble *controlPoints = this->getControlPoints();\n\tint numDimensions = this->getNumDimensions();\n\tint numControlPoints = this->getNumControlPoints();\n\tint numKnots = this->getNumKnots();\n\n\t// Initialize the jerk value\n\tdouble jerkValue = 0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < numControlPoints; i++) {\n\t\tfor (int j = 0; j < numDimensions; j++) {\n\t\t\t// Calculate the squared control point value\n\t\t\tdouble controlPointValue = controlPoints[i * numDimensions + j] * controlPoints[i * numDimensions + j];\n\n\t\t\t// Calculate the difference in knot times\n\t\t\tdouble knotTimeDiff = knots[i + 1] - knots[i];\n\n\t\t\t// Add the squared control point value multiplied by the difference in knot times to the jerk value\n\t\t\tjerkValue += controlPointValue * knotTimeDiff;\n\t\t}\n\t}\n\n\t// Return the jerk value\n\treturn jerkValue;\n}\n", "CodeBleu_score": 39.79893730418198}, {"code": "double UniformBspline::getJerk()\t// Get the knot times\n\tdouble* knotTimes = getKnotTimes();\n\t// Get the control points\n\tdouble** controlPoints = getControlPoints();\n\t// Get the number of dimensions\n\tint dimensions = getDimensions();\n\t// Get the number of control points\n\tint numControlPoints = getNumControlPoints();\n\t// Get the number of knots\n\tint numKnots = getNumKnots();\n\t// Get the knots\n\tdouble* knots = getKnots();\n\t// Get the number of knots\n\tint numKnotsMinusOne = numKnots - 1;\n\t// Get the number of knots minus two\n\tint numKnotsMinusTwo = numKnots - 2;\n\t// Get the number of knots minus three\n\tint numKnotsMinusThree = numKnots - 3;\n\t// Get the number of knots minus four\n\tint numKnotsMinusFour = numKnots - 4;\n\t// Get the number of knots minus five\n\tint numKnotsMinusFive = numKnots - 5;\n\t// Get the number of knots minus six\n\tint numKnotsMinusSix = numKnots - 6;\n\t// Get the number of knots minus seven\n\tint numKnotsMinusSeven = numKnots - 7;\n\t// Get the number of knots minus eight\n\tint numKnotsMinusEight = numKnots - 8;\n\t// Get the number of knots minus nine\n\tint numKnotsMinusNine = numKnots - 9;\n\t// Get the number of knots minus ten\n\tint numKnotsMinusTen = numKnots - 10;\n\t// Get the number of knots minus eleven\n\tint numKnotsMinusEleven = numKnots - 11;\n\t// Get the number of knots minus twelve\n\tint numKnotsMinusTwelve = numKnots - 12;\n\t// Get the number of knots minus thirteen\n\tint numKnotsMinusTh", "CodeBleu_score": 10.808082246817193}, {"code": "double UniformBspline::getJerk()\tdouble jerk = 0.0;\n\tdouble jerk_knot_time;\n\tdouble jerk_control_point;\n\tdouble jerk_control_point_squared;\n\tdouble jerk_control_point_difference;\n\tdouble jerk_control_point_difference_squared;\n\n\tfor (int i = 0; i < getDimension(); i++) {\n\t\tjerk_knot_time = 0.0;\n\t\tjerk_control_point = 0.0;\n\t\tjerk_control_point_squared = 0.0;\n\t\tjerk_control_point_difference = 0.0;\n\t\tjerk_control_point_difference_squared = 0.0;\n\n\t\tfor (int j = 0; j < getKnotCount(); j++) {\n\t\t\tjerk_knot_time += getKnotTime(j);\n\t\t\tjerk_control_point += getControlPoint(i, j);\n\t\t\tjerk_control_point_squared += pow(getControlPoint(i, j), 2);\n\t\t}\n\n\t\tjerk_control_point_difference = jerk_knot_time - getKnotTime(0);\n\t\tjerk_control_point_difference_squared = pow(jerk_control_point_difference, 2);\n\n\t\tjerk += jerk_control_point_squared * jerk_control_point_difference_squared;\n\t}\n\n\treturn jerk;\n}\n", "CodeBleu_score": 46.035386633846024}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}\n", "CodeBleu_score": 73.22526008508646}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tEigen::Vector4d pos;\n\tpos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1.0;\n\treturn pos;\n}\n", "CodeBleu_score": 38.053206660726005}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tEigen::Vector4d pos;\n\tpos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1.0;\n\treturn pos;\n}\n", "CodeBleu_score": 38.053206660726005}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneIDFromChildFrameID(odom.child_frame_id));\n\t} catch (std::runtime_error& e) {\n\t\tROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n\t}\n}\n", "CodeBleu_score": 35.6543236310558}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneID(odom.child_frame_id));\n\t} catch (std::runtime_error& e) {\n\t\tROS_ERROR_STREAM(\"Error extracting drone ID from odometry message: \" << e.what());\n\t}\n}\n", "CodeBleu_score": 36.18925165676641}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\t// Extract the drone ID from the child_frame_id field of the odometry message\n\tint droneID = -1;\n\ttry {\n\t\tdroneID = extractDroneID(odom.child_frame_id);\n\t} catch (std::exception& e) {\n\t\tROS_WARN_STREAM(\"Failed to extract drone ID from odometry message: \" << e.what());\n\t}\n\t// Call rcvDroneOdomCallbackBase with the odometry data and drone ID\n\trcvDroneOdomCallbackBase(odom, droneID);\n}\n", "CodeBleu_score": 43.337349643759026}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// Get the drone's pose in the camera frame\n\tEigen::Vector3d drone_pose = _camera_pose.inverse() * _drone_poses[drone_id];\n\n\t// Get the drone's pose in the world frame\n\tEigen::Vector3d world_drone_pose = _world_pose * drone_pose;\n\n\t// Get the true pose of the drone in the world frame\n\tEigen::Vector3d true_drone_pose = _world_pose * _drone_poses[drone_id];\n\n\t// Compute the pose error\n\tEigen::Vector3d error = world_drone_pose - true_drone_pose;\n\n\t// Update the debug result\n\t_debug_result.drone_id = drone_id;\n\t_debug_result.true_pixel = true_pixel;\n\t_debug_result.world_drone_pose = world_drone_pose;\n\t_debug_result.error = error;\n\n\t// Publish the pose error\n\t_pose_error_pub.publish(_debug_result);\n\n\t// Check if the drone is found\n\tif (drone_pose(2) > 0.0) {\n\t\t// Update the debug result\n\t\t_debug_result.found = true;\n\n\t\t// Publish the debug result\n\t\t_debug_result_pub.publish(_debug_result);\n\t} else {\n\t\t// Update the debug result\n\t\t_debug_result.found = false;\n\n\t\t// Publish the debug result\n\t\t_debug_result_pub.publish(_debug_result);\n\t}\n}\n", "CodeBleu_score": 38.602401659222416}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// 1. Calculate the true pose of the drone in the camera frame.\n\tEigen::Vector3d true_position = camera_model_.pixel2camera(true_pixel);\n\n\t// 2. Check if the drone is present in the camera frame.\n\tbool found = drone_id_map_.find(drone_id)!= drone_id_map_.end();\n\n\t// 3. If found, compute the pose error between the camera and world coordinates.\n\tif (found) {\n\t\tEigen::Vector3d drone_position = drone_id_map_[drone_id].pose.position();\n\t\tEigen::Vector3d pose_error = true_position - drone_position;\n\t\tEigen::Vector3d camera_position = drone_id_map_[drone_id].pose.position();\n\t\tEigen::Vector3d world_position = camera_model_.camera2world(camera_position);\n\t\tEigen::Vector3d world_error = true_position - world_position;\n\t\tEigen::Vector3d world_error_world = true_position - world_position;\n\t\tEigen::Vector3d world_error_camera = true_position - camera_position;\n\t\tEigen::Vector3d drone_error = true_position - drone_position;\n\t\tEigen::Vector3d drone_error_world = true_position - world_position;\n\t\tEigen::Vector3d drone_error_camera = true_position - camera_position;\n\n\t\t// 4. Update the debug result.\n\t\tdebug_result_.pose_error_world = pose_error;\n\t\tdebug_result_.pose_error_camera = drone_error;\n\t\tdebug_result_.pose_error_drone = drone_error;\n\t\tdebug_result_.pose_error_world_world = world_error_world;\n\t\tdebug_result_.pose_error_world_camera = world_error_camera;\n\t\tdebug_result_.pose_error_drone_world = drone_error_world;\n\t\tdebug_result_.pose_error_drone_camera = drone_error_camera;\n\n\t\t// 5. Publish the pose error.\n\t\tpose_error_pub_.publish(pose_error);\n\t\tworld_error_pub_.", "CodeBleu_score": 33.66652390599499}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// Calculate the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = drone_id_to_pose_map_[drone_id] * true_pixel;\n\n\t// Check if the drone is present\n\tif (drone_map_.find(drone_id)!= drone_map_.end()) {\n\t\t// Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d error = drone_map_[drone_id].pose - true_pose;\n\n\t\t// Update the debug result\n\t\tdebug_result_.pose_error = error.norm();\n\t\tdebug_result_.is_detected = true;\n\n\t\t// Publish the pose error\n\t\tpose_error_pub_.publish(error);\n\t} else {\n\t\t// Update the debug result to indicate failure\n\t\tdebug_result_.pose_error = 0.0;\n\t\tdebug_result_.is_detected = false;\n\t}\n\n\t// Publish the debug result\n\tdebug_pub_.publish(debug_result_);\n}\n", "CodeBleu_score": 33.255343816185984}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 77.13028052492308}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\tGridNodePtr previous = cameFrom[current];\n\twhile (previous!= nullptr) {\n\t\tpath.push_back(previous);\n\t\tprevious = cameFrom[previous];\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n", "CodeBleu_score": 50.07878531342244}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n", "CodeBleu_score": 77.65916948328659}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert start point to grid indices\n\tif (ConvertToIndex(start_pt, start_idx) == false) {\n\t\t// If the start point is inside an obstacle, adjust it to be outside the obstacle\n\t\twhile (IsObstacle(start_idx) == true) {\n\t\t\t// Move the point away from the obstacle\n\t\t\tstart_pt = start_pt + (start_pt - end_pt) * 0.1;\n\t\t\t// Convert the adjusted point to grid indices\n\t\t\tif (ConvertToIndex(start_pt, start_idx) == false) {\n\t\t\t\t// If the adjusted point is still inside an obstacle, the conversion failed\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t// Convert end point to grid indices\n\tif (ConvertToIndex(end_pt, end_idx) == false) {\n\t\t// If the end point is inside an obstacle, adjust it to be outside the obstacle\n\t\twhile (IsObstacle(end_idx) == true) {\n\t\t\t// Move the point away from the obstacle\n\t\t\tend_pt = end_pt + (end_pt - start_pt) * 0.1;\n\t\t\t// Convert the adjusted point to grid indices\n\t\t\tif (ConvertToIndex(end_pt, end_idx) == false) {\n\t\t\t\t// If the adjusted point is still inside an obstacle, the conversion failed\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 42.08973921096998}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert start and end points to grid indices\n\tstart_idx = ConvertToIndex(start_pt);\n\tend_idx = ConvertToIndex(end_pt);\n\n\t// Check if start or end points are inside obstacles\n\tif (IsInsideObstacle(start_idx) || IsInsideObstacle(end_idx)) {\n\t\t// Adjust start and end points until they are no longer inside obstacles\n\t\tif (!AdjustStartEndPoints(start_idx, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 26.615573624238102}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\tstart_idx = ConvertToIndex(start_pt);\n\tend_idx = ConvertToIndex(end_pt);\n\tif (start_idx.x == -1 || start_idx.y == -1 || start_idx.z == -1 || end_idx.x == -1 || end_idx.y == -1 || end_idx.z == -1) {\n\t\treturn false;\n\t}\n\tif (obstacle_grid[start_idx.x][start_idx.y][start_idx.z] == 1) {\n\t\tVector3d adjusted_start_pt = AdjustPoint(start_pt, end_pt);\n\t\tstart_idx = ConvertToIndex(adjusted_start_pt);\n\t\tif (start_idx.x == -1 || start_idx.y == -1 || start_idx.z == -1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (obstacle_grid[end_idx.x][end_idx.y][end_idx.z] == 1) {\n\t\tVector3d adjusted_end_pt = AdjustPoint(end_pt, start_pt);\n\t\tend_idx = ConvertToIndex(adjusted_end_pt);\n\t\tif (end_idx.x == -1 || end_idx.y == -1 || end_idx.z == -1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 39.08465060085603}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\tEigen::Vector3d min_id = worldToMap(min_pos);\n\tEigen::Vector3d max_id = worldToMap(max_pos);\n\tEigen::Vector3d min_id_floor = min_id.array().floor();\n\tEigen::Vector3d max_id_ceil = max_id.array().ceil();\n\tEigen::Vector3d min_id_ceil = min_id.array().ceil();\n\tEigen::Vector3d max_id_floor = max_id.array().floor();\n\tEigen::Vector3d min_id_ceil_diff = min_id_ceil - min_id;\n\tEigen::Vector3d max_id_floor_diff = max_id_floor - max_id;\n\tEigen::Vector3d min_id_floor_diff = min_id_floor - min_id;\n\tEigen::Vector3d max_id_ceil_diff = max_id_ceil - max_id;\n\tEigen::Vector3d min_id_diff = min_id_floor - min_id;\n\tEigen::Vector3d max_id_diff = max_id_ceil - max_id;\n\tEigen::Vector3d min_id_diff_floor = min_id_floor - min_id;\n\tEigen::Vector3d max_id_diff_floor = max_id_floor - max_id;\n\tEigen::Vector3d min_id_diff_ceil = min_id_ceil - min_id;\n\tEigen::Vector3d max_id_diff_ceil = max_id_ceil - max_id;\n\tEigen::Vector3d min_id_diff_ceil_diff = min_id_ceil - min_id;\n\tEigen::Vector3d max_id_diff_ceil_diff = max_id_ceil - max_id;\n\tEigen::Vector3d min_id_diff_floor_diff = min_id_floor - min_id;\n\tEigen::Vector3d max_id_diff_floor_diff = max_id_floor - max_id;\n\tEigen::Vector3d min_id_diff_floor_diff_floor = min_id_floor - min_id;\n\tEigen::Vector3d max_id", "CodeBleu_score": 24.368752440209725}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\tEigen::Vector3i min_id = worldToMap(min_pos);\n\tEigen::Vector3i max_id = worldToMap(max_pos);\n\tfor (int i = min_id[0]; i <= max_id[0]; i++) {\n\t\tfor (int j = min_id[1]; j <= max_id[1]; j++) {\n\t\t\tfor (int k = min_id[2]; k <= max_id[2]; k++) {\n\t\t\t\toccupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.088337320785385}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\tEigen::Vector3i min_id = this->getGridId(min_pos);\n\tEigen::Vector3i max_id = this->getGridId(max_pos);\n\tfor (int i = min_id(0); i <= max_id(0); i++) {\n\t\tfor (int j = min_id(1); j <= max_id(1); j++) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); k++) {\n\t\t\t\tthis->occupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 53.83373989694583}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_translation;\n\tEigen::Vector3d max_translation;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tmin_translation(i) = -1.0 * (pt(i) - map_limits_.min_bound(i));\n\t\tmax_translation(i) = map_limits_.max_bound(i) - pt(i);\n\t}\n\tEigen::Vector3d min_scale = diff / min_translation;\n\tEigen::Vector3d max_scale = diff / max_translation;\n\tEigen::Vector3d min_max_scale = min_scale.cwiseMin(max_scale);\n\tEigen::Vector3d result = pt - diff * min_max_scale.cwiseMax(Eigen::Vector3d::Ones());\n\treturn result;\n}\n", "CodeBleu_score": 38.740159796000334}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt = pt;\n\tEigen::Vector3d max_pt = pt;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff[i] > 0) {\n\t\t\tmin_pt[i] = std::max(min_pt[i], pt[i] - (diff[i] / diff.norm()) * (max_x[i] - pt[i]));\n\t\t} else {\n\t\t\tmax_pt[i] = std::min(max_pt[i], pt[i] - (diff[i] / diff.norm()) * (pt[i] - min_x[i]));\n\t\t}\n\t}\n\treturn max_pt;\n}\n", "CodeBleu_score": 37.574734002835676}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt;\n\tEigen::Vector3d max_pt;\n\tmin_pt << std::min(diff(0), 0.0), std::min(diff(1), 0.0), std::min(diff(2), 0.0);\n\tmax_pt << std::max(diff(0), 0.0), std::max(diff(1), 0.0), std::max(diff(2), 0.0);\n\tEigen::Vector3d new_pt;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (max_pt(i) > 0.0) {\n\t\t\tnew_pt(i) = min_pt(i) + max_pt(i);\n\t\t} else {\n\t\t\tnew_pt(i) = min_pt(i);\n\t\t}\n\t}\n\treturn new_pt;\n}\n", "CodeBleu_score": 40.0409774799123}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// update last occupancy update time\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// update local map\n\tif (localMapUpdated) {\n\t\tclearLocalMap();\n\t\tinflateLocalMap();\n\t\tlocalMapUpdated = false;\n\t}\n\n\t// update odometry\n\tif (odometryUpdated) {\n\t\tupdateOdometry();\n\t\todometryUpdated = false;\n\t}\n\n\t// update depth data\n\tif (depthDataUpdated) {\n\t\tupdateDepthData();\n\t\tdepthDataUpdated = false;\n\t}\n\n\t// update time\n\tupdateTime();\n}\n", "CodeBleu_score": 25.399306765672762}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// Update the last occupancy update time.\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// Check if the depth image is available.\n\tif (!depthImageAvailable) {\n\t\t// Depth image is not available.\n\t\tROS_WARN_STREAM(\"Depth image is not available.\");\n\t\treturn;\n\t}\n\n\t// Check if the odometry is available.\n\tif (!odometryAvailable) {\n\t\t// Odometry is not available.\n\t\tROS_WARN_STREAM(\"Odometry is not available.\");\n\t\treturn;\n\t}\n\n\t// Check if the local map is available.\n\tif (!localMapAvailable) {\n\t\t// Local map is not available.\n\t\tROS_WARN_STREAM(\"Local map is not available.\");\n\t\treturn;\n\t}\n\n\t// Check if the local map is updated.\n\tif (!localMapUpdated) {\n\t\t// Local map is not updated.\n\t\tROS_WARN_STREAM(\"Local map is not updated.\");\n\t\treturn;\n\t}\n\n\t// Check if the depth image is outdated.\n\tif (depthImageUpdateTimeout > 0.0 && depthImageUpdateTimeout < (ros::Time::now() - lastDepthImageUpdateTime).toSec()) {\n\t\t// Depth image is outdated.\n\t\tROS_WARN_STREAM(\"Depth image is outdated.\");\n\t\treturn;\n\t}\n\n\t// Check if the odometry is outdated.\n\tif (odometryUpdateTimeout > 0.0 && odometryUpdateTimeout < (ros::Time::now() - lastOdometryUpdateTime).toSec()) {\n\t\t// Odometry is outdated.\n\t\tROS_WARN_STREAM(\"Odometry is outdated.\");\n\t\treturn;\n\t}\n\n\t// Check if the local map is outdated.\n\tif (localMapUpdateTimeout > 0.0 && localMapUpdateTimeout < (ros::Time::now() - lastLocalMapUpdateTime).toSec()) {\n\t\t// Local map is outdated.\n\t\tROS_WARN_STREAM(\"Local map is outdated.\");\n\t\treturn;\n\t}\n\n\t// Check if the local map is inflated.\n\tif (!localMapInflated) {\n\t\t// Local map is not inflated.\n\t\tROS_WARN_STREAM(\"Local map is not inflated.\");\n\t\treturn;\n\t}\n\n\t// Check if the local", "CodeBleu_score": 33.564203839009345}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// Update the last update time\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// If the depth image is not available, return\n\tif (!depthImageAvailable) {\n\t\treturn;\n\t}\n\n\t// If the odometry is not available, return\n\tif (!odometryAvailable) {\n\t\treturn;\n\t}\n\n\t// If the local map is not available, return\n\tif (!localMapAvailable) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been updated, return\n\tif (!localMapUpdated) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been inflated, return\n\tif (!localMapInflated) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been cleared, return\n\tif (!localMapCleared) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been processed, return\n\tif (!localMapProcessed) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been updated, return\n\tif (!localMapUpdated) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been inflated, return\n\tif (!localMapInflated) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been cleared, return\n\tif (!localMapCleared) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been processed, return\n\tif (!localMapProcessed) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been updated, return\n\tif (!localMapUpdated) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been inflated, return\n\tif (!localMapInflated) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been cleared, return\n\tif (!localMapCleared) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been processed, return\n\tif (!localMapProcessed) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been updated, return\n\tif (!localMapUpdated) {\n\t\treturn;\n\t}\n\n\t// If the local map has not been inflated, return\n\tif (!local", "CodeBleu_score": 29.680182244802523}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat f_sum = 0.0;\n\tint n_images = image_fns.size();\n\tfor (int i = 0; i < n_images; i++) {\n\t\tMat img = imread(image_fns[i]);\n\t\tMat gt = imread(gt_fns[i]);\n\t\tMat dt = imread(dt_fns[i]);\n\n\t\tvector<Ellipse> gt_ellipses = _ellipse_load_groundtruth(gt, gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses = _ellipse_load_detections(dt);\n\n\t\tfloat f = _ellipse_evaluate(img, gt_ellipses, dt_ellipses);\n\t\tf_sum += f;\n\t}\n\treturn f_sum / n_images;\n}\n", "CodeBleu_score": 52.52485712455838}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat f_measure = 0.0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tvector<Ellipse> gt_ellipses = _ellipse_load_ground_truth(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses = _ellipse_load_detected(dt_fns[i], gt_angle_radians);\n\t\tf_measure += _ellipse_evaluate_image(gt_ellipses, dt_ellipses);\n\t}\n\treturn f_measure / image_fns.size();\n}\n", "CodeBleu_score": 53.487428754803226}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat avg_f = 0.0;\n\tint num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load the ground truth ellipses from the provided file\n\t\tvector<Ellipse> gt_ellipses = _ellipse_load_gt(gt_fns[i], gt_angle_radians);\n\n\t\t// Load the detected ellipses from the provided file\n\t\tvector<Ellipse> dt_ellipses = _ellipse_load_dt(dt_fns[i], gt_angle_radians);\n\n\t\t// Evaluate the detection performance and accumulate the F-measure\n\t\tfloat f = _ellipse_evaluate(gt_ellipses, dt_ellipses);\n\t\tavg_f += f;\n\t}\n\treturn avg_f / num_images;\n}\n", "CodeBleu_score": 50.061239939235605}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat x0 = a * cos(foci[2]);\n\tfloat y0 = b * sin(foci[2]);\n\tfloat x1 = a * cos(foci[3]);\n\tfloat y1 = b * sin(foci[3]);\n\tfloat angle1 = atan2(y - y0, x - x0);\n\tfloat angle2 = atan2(y - y1, x - x1);\n\tfloat angle_diff = angle1 - angle2;\n\tif (angle_diff < -PI) {\n\t\tangle_diff += 2 * PI;\n\t}\n\tif (angle_diff > PI) {\n\t\tangle_diff -= 2 * PI;\n\t}\n\treturn angle_diff;\n}\n", "CodeBleu_score": 38.44679750237857}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tif (foci == NULL) {\n\t\treturn 0.0;\n\t}\n\tfloat dx = foci[0] - x;\n\tfloat dy = foci[1] - y;\n\tfloat angle1 = atan2(dy, dx);\n\tfloat angle2 = atan2(dy, -dx);\n\tfloat angle = angle1 - angle2;\n\tif (angle < 0.0) {\n\t\tangle += 2.0 * M_PI;\n\t}\n\treturn angle;\n}\n", "CodeBleu_score": 32.86052477008901}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat x_dist = x - a;\n\tfloat y_dist = y - b;\n\tfloat angle = atan2(y_dist, x_dist);\n\tfloat angle1 = atan2(y - b, x - a);\n\tfloat angle2 = atan2(y - b, x + a);\n\tfloat angle_diff = angle - angle1;\n\tif (angle_diff < 0) {\n\t\tangle_diff += 2 * M_PI;\n\t}\n\tfloat angle_diff2 = angle - angle2;\n\tif (angle_diff2 < 0) {\n\t\tangle_diff2 += 2 * M_PI;\n\t}\n\tif (angle_diff2 < angle_diff) {\n\t\tangle = angle2;\n\t}\n\treturn angle;\n}\n", "CodeBleu_score": 40.5769631236683}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)\t// Get the minimum and maximum x and y coordinates of the points in the section.\n\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\t// Compute the integral above and below the polygon section.\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i + 1].y - min_y);\n\t\tintegral_below += (vp1[i].x - min_x) * (vp1[i + 1].y - max_y);\n\t}\n\n\t// If the integral above is less than the integral below, the section is convex.\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 39.35953210575956}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tdouble area_above = 0;\n\tdouble area_below = 0;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t\tarea_above += (vp1[i].x * vp1[i - 1].y) - (vp1[i - 1].x * vp1[i].y);\n\t\tarea_below += (vp1[i].x * vp1[i - 1].y) - (vp1[i - 1].x * vp1[i].y);\n\t}\n\tarea_above += (vp1[end].x * vp1[start].y) - (vp1[start].x * vp1[end].y);\n\tarea_below += (vp1[end].x * vp1[start].y) - (vp1[start].x * vp1[end].y);\n\tif (area_above < area_below) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 31.46086339803622}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\tdouble x_min = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 3.27098798522657}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tstatic bool is_detected = false;\n\tstatic int num_lost = 0;\n\tstatic int num_regain = 0;\n\tstatic int num_detections = 0;\n\tstatic int num_detections_prev = 0;\n\tstatic bool is_detected_prev = false;\n\tstatic int num_lost_prev = 0;\n\tstatic int num_regain_prev = 0;\n\tstatic int num_detections_prev_prev = 0;\n\tstatic bool is_detected_prev_prev = false;\n\tstatic int num_lost_prev_prev = 0;\n\tstatic int num_regain_prev_prev = 0;\n\tstatic bool is_detected_prev_prev_prev = false;\n\tstatic int num_lost_prev_prev_prev = 0;\n\tstatic int num_regain_prev_prev_prev = 0;\n\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\tif (msg->detections[i].object_name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t}\n\n\tif (num_lost >= VISION_THRES) {\n\t\tis_detected = false;\n\t} else if (num_regain >= VISION_THRES) {\n\t\tis_detected = true;\n\t}\n\n\tif (is_detected!= is_detected_prev) {\n\t\tnum_detections++;\n\t\tnum_detections_prev = num_detections;\n\t\tnum_detections_prev_prev = num_detections_prev;\n\t\tnum_detections_prev_prev_prev = num_detections_prev_prev;\n\t}\n\n\tif (num_lost_prev >= VISION_THRES) {\n\t\tnum_lost_prev = 0;\n\t\tnum_lost_prev_prev = num_lost_prev;\n\t\tnum_lost_prev_prev_prev = num_lost_prev_prev;\n\t}\n\n\tif (num_regain_prev >= VISION_THRES) {\n\t\tnum", "CodeBleu_score": 52.27215197678581}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\t// initialize ellipse_det\n\tif (!ellipse_det.is_detected) {\n\t\tellipse_det.is_detected = false;\n\t\tellipse_det.num_lost = 0;\n\t\tellipse_det.num_regain = 0;\n\t\tellipse_det.sight_angle_left = 0;\n\t\tellipse_det.sight_angle_right = 0;\n\t}\n\n\t// iterate through detection info\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\tif (msg->detections[i].name == \"T\") {\n\t\t\tellipse_det.num_regain = 0;\n\t\t\tellipse_det.num_lost++;\n\t\t\tellipse_det.is_detected = false;\n\t\t} else {\n\t\t\tellipse_det.num_lost = 0;\n\t\t\tellipse_det.num_regain++;\n\t\t\tellipse_det.is_detected = true;\n\t\t}\n\t\tif (ellipse_det.num_lost > VISION_THRES) {\n\t\t\tellipse_det.is_detected = false;\n\t\t}\n\t\tif (ellipse_det.num_regain > VISION_THRES) {\n\t\t\tellipse_det.is_detected = true;\n\t\t}\n\t\tif (ellipse_det.is_detected) {\n\t\t\tellipse_det.sight_angle_left = msg->detections[i].sight_angle_left;\n\t\t\tellipse_det.sight_angle_right = msg->detections[i].sight_angle_right;\n\t\t}\n\t}\n\n\t// swap sight_angle_left and sight_angle_right\n\tdouble temp = ellipse_det.sight_angle_left;\n\tellipse_det.sight_angle_left = ellipse_det.sight_angle_right;\n\tellipse_det.sight_angle_right = temp;\n}\n", "CodeBleu_score": 35.290366289733555}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tbool is_detected = false;\n\tint num_regain = 0;\n\tint num_lost = 0;\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\tif (msg->detections[i].name == \"T\") {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost = 0;\n\t\t\tis_detected = true;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tif (is_detected) {\n\t\tellipse_det.sight_angle = msg->detections[0].sight_angle;\n\t\tellipse_det.sight_angle_rate = msg->detections[0].sight_angle_rate;\n\t\tellipse_det.confidence = msg->detections[0].confidence;\n\t\tellipse_det.confidence_rate = msg->detections[0].confidence_rate;\n\t\tellipse_det.x = msg->detections[0].x;\n\t\tellipse_det.y = msg->detections[0].y;\n\t\tellipse_det.z = msg->detections[0].z;\n\t\tellipse_det.width = msg->detections[0].width;\n\t\tellipse_det.height = msg->detections[0].height;\n\t\tellipse_det.depth = msg->detections[0].depth;\n\t\tellipse_det.orientation.x = msg->detections[0].orientation.x;\n\t\tellipse_det.orientation.y = msg->detections[0].orientation.y;\n\t\tellipse_det.orientation.z = msg->detections[0].orientation.z;\n\t\tellipse_det.orientation.w = msg->detections[0].orientation.w;\n\t} else {\n\t\tellipse_det.sight_angle = 0;\n\t\tellipse_det.sight_angle_rate = 0;\n\t\tellipse_det.confidence = 0;\n\t\tellipse_det.confidence_rate = 0;\n\t\tellipse", "CodeBleu_score": 52.733908279203234}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\tbool safe = false;\n\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\tsafe = true;\n\t}\n\treturn safe;\n}\n", "CodeBleu_score": 58.24992304461436}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 46.53705657073741}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\tdouble x_val = cur_pos(0);\n\tdouble y_val = cur_pos(1);\n\tdouble z_val = cur_pos(2);\n\tEigen::Vector3d pos(x_val, y_val, z_val);\n\tdouble safety_distance_sqr = safe_distance * safe_distance;\n\tdouble safety_distance_sqr_2 = 2 * safety_distance_sqr;\n\tdouble safety_distance_sqr_3 = 3 * safety_distance_sqr;\n\tdouble safety_distance_sqr_4 = 4 * safety_distance_sqr;\n\tdouble safety_distance_sqr_5 = 5 * safety_distance_sqr;\n\tdouble safety_distance_sqr_6 = 6 * safety_distance_sqr;\n\tdouble safety_distance_sqr_7 = 7 * safety_distance_sqr;\n\tdouble safety_distance_sqr_8 = 8 * safety_distance_sqr;\n\tdouble safety_distance_sqr_9 = 9 * safety_distance_sqr;\n\tdouble safety_distance_sqr_10 = 10 * safety_distance_sqr;\n\tdouble safety_distance_sqr_11 = 11 * safety_distance_sqr;\n\tdouble safety_distance_sqr_12 = 12 * safety_distance_sqr;\n\tdouble safety_distance_sqr_13 = 13 * safety_distance_sqr;\n\tdouble safety_distance_sqr_14 = 14 * safety_distance_sqr;\n\tdouble safety_distance_sqr_15 = 15 * safety_distance_sqr;\n\tdouble safety_distance_sqr_16 = 16 * safety_distance_sqr;\n\tdouble safety_distance_sqr_17 = 17 * safety_distance_sqr;\n\tdouble safety_distance_sqr_18 = 18 * safety_distance_sqr;\n\tdouble safety_distance_sqr_19 = 19 * safety_distance_sqr;\n\tdouble safety_distance_sqr_20 = 20 * safety_distance_sqr;\n\tdouble safety_distance_sqr_21 = 21 * safety_distance_sqr;\n\tdouble safety_distance_sqr_22 =", "CodeBleu_score": 28.303101508401873}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)\tNodePtr node = end_node;\n\tpath_nodes_.push_back(node);\n\twhile (node->parent!= nullptr) {\n\t\tnode = node->parent;\n\t\tpath_nodes_.push_back(node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 60.2853357868533}, {"code": "void Astar::retrievePath(NodePtr end_node)\tNodePtr curr_node = end_node;\n\twhile (curr_node!= nullptr) {\n\t\tpath_nodes_.push_front(curr_node);\n\t\tcurr_node = curr_node->parent;\n\t}\n\tpath_nodes_.reverse();\n}\n", "CodeBleu_score": 45.42882328469088}, {"code": "void Astar::retrievePath(NodePtr end_node)\tNodePtr current_node = end_node;\n\twhile (current_node->parent!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tpath_nodes_.push_back(current_node);\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 63.89673742185439}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \t//ROS_INFO(\"nei_odom_cb\");\n\tif (id == 0) {\n\t\tstate_nei[0].x = odom->pose.pose.position.x;\n\t\tstate_nei[0].y = odom->pose.pose.position.y;\n\t\tstate_nei[0].z = odom->pose.pose.position.z;\n\t}\n\telse if (id == 1) {\n\t\tstate_nei[1].x = odom->pose.pose.position.x;\n\t\tstate_nei[1].y = odom->pose.pose.position.y;\n\t\tstate_nei[1].z = odom->pose.pose.position.z;\n\t}\n\telse if (id == 2) {\n\t\tstate_nei[2].x = odom->pose.pose.position.x;\n\t\tstate_nei[2].y = odom->pose.pose.position.y;\n\t\tstate_nei[2].z = odom->pose.pose.position.z;\n\t}\n\telse if (id == 3) {\n\t\tstate_nei[3].x = odom->pose.pose.position.x;\n\t\tstate_nei[3].y = odom->pose.pose.position.y;\n\t\tstate_nei[3].z = odom->pose.pose.position.z;\n\t}\n\telse if (id == 4) {\n\t\tstate_nei[4].x = odom->pose.pose.position.x;\n\t\tstate_nei[4].y = odom->pose.pose.position.y;\n\t\tstate_nei[4].z = odom->pose.pose.position.z;\n\t}\n\telse if (id == 5) {\n\t\tstate_nei[5].x = odom->pose.pose.position.x;\n\t\tstate_nei[5].y = odom->pose.pose.position.y;\n\t\tstate_nei[5].z = odom->pose.pose.position.z;\n\t}\n\telse if (id == 6) {\n\t\tstate_nei[6", "CodeBleu_score": 30.842410358790417}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"nei_odom_cb: %d\", id);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.w);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->twist.twist.linear.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->twist.twist.linear.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->twist.twist.linear.z);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->twist.twist.angular.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->twist.twist.angular.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->twist.twist.angular.z);\n\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.z);\n\n\t", "CodeBleu_score": 3.3807799665142713}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"odom: x: %f, y: %f, z: %f\", odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\t//ROS_INFO(\"odom: x: %f, y: %f, z: %f\", odom->twist.twist.linear.x, odom->twist.twist.linear.y, odom->twist.twist.linear.z);\n\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\n\tif(sim_mode) {\n\t\tif(sqrt(pow(state_nei[id].x - start_x, 2) + pow(state_nei[id].y - start_y, 2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n}\n", "CodeBleu_score": 50.05608922354254}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", msg->width * msg->height);\n\tif (sensor_ready) {\n\t\t//ROS_INFO(\"Gpointcloud_cb: sensor_ready\");\n\t\tif (update_counter == 0) {\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: sensor_ready\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t\t//ROS_INFO(\"Gpointcloud_cb: update_counter == 0\");\n\t\t", "CodeBleu_score": 8.097781128594415}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (!odometry_ready) {\n\t\treturn;\n\t}\n\tif (sensor_ready) {\n\t\tif (update_counter == 5) {\n\t\t\tROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating map with new point cloud data.\");\n\t\t\tupdate_counter = 0;\n\t\t\tupdate_map(msg);\n\t\t}\n\t\tupdate_counter++;\n\t}\n\tsensor_ready = true;\n}\n", "CodeBleu_score": 45.33704131018048}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (!odometry_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter < 5) {\n\t\treturn;\n\t}\n\tupdate_counter = 0;\n\t//ROS_INFO(\"Received point cloud\");\n\tpcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n\tpcl::fromROSMsg(*msg, pcl_cloud);\n\tpcl_cloud.header.frame_id = \"odom\";\n\tpcl_cloud.header.stamp = ros::Time::now();\n\tpcl::toROSMsg(pcl_cloud, pcl_cloud_ros);\n\tpcl_cloud_ros.header.frame_id = \"odom\";\n\tpcl_cloud_ros.header.stamp = ros::Time::now();\n\tpcl_cloud_ros.header.seq = msg->header.seq;\n\tpcl_cloud_ros.header.stamp = msg->header.stamp;\n\tpcl_cloud_ros.header.frame_id = \"odom\";\n\tpcl_cloud_ros.header.seq = msg->header.seq;\n\tpcl_cloud_ros.header.stamp = msg->header.stamp;\n\tpcl_cloud_ros.width = pcl_cloud.width;\n\tpcl_cloud_ros.height = pcl_cloud.height;\n\tpcl_cloud_ros.points.resize(pcl_cloud.points.size());\n\tpcl_cloud_ros.is_dense = pcl_cloud.is_dense;\n\tpcl_cloud_ros.is_bigendian = pcl_cloud.is_bigendian;\n\tpcl_cloud_ros.point_step = pcl_cloud.point_step;\n\tpcl_cloud_ros.row_step = pcl_cloud.row_step;\n\tpcl_cloud_ros.data = pcl_cloud.data;\n\tpcl_cloud_ros.fields = pcl_cloud.fields;\n\tpcl_cloud_ros.is_bigendian = pcl_cloud.is_bigendian;\n\tpcl_cloud_ros.point_step = pcl_cloud.point_step;\n\tpcl_cloud_ros.row_step = pcl_cloud.", "CodeBleu_score": 45.83809256117767}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl == true) {\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t\t//std::cout << \"global point cloud has been updated\" << std::endl;\n\t", "CodeBleu_score": 10.399245704084297}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tglobal_point_cloud = global_point;\n\t\t// Convert the sensor message to a point cloud\n\t\tpcl::fromROSMsg(*global_point_cloud, global_point_cloud_pcl);\n\t\t// Inflate the point cloud\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_point_cloud_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled;\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated", "CodeBleu_score": 42.43446687969312}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl) {\n\t\treturn;\n\t}\n\tget_gpcl = true;\n\tsensor_msgs::PointCloud2 point;\n\tsensor_msgs::PointCloud2 point_inflated;\n\tsensor_msgs::PointCloud2 point_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> point_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> point_inflated_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> point_filtered_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> point_filtered_pcl_filtered;\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr point_filtered_pcl_filtered_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr point_inflated_pcl_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr point_pcl_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\tpoint_inflated_pcl_ptr->header.frame_id = \"map\";\n\tpoint_pcl_ptr->header.frame_id = \"map\";\n\tpoint_filtered_pcl_filtered_ptr->header.frame_id = \"map\";\n\tpoint_filtered_pcl_filtered_ptr->header.stamp = ros::Time::now();\n\tpoint_filtered_pcl_filtered_ptr->width = 1;\n\tpoint_filtered_pcl_filtered_ptr->height = 1;\n\tpoint_filtered_pcl_filtered_ptr->is_dense = false;\n\tpoint_filtered_pcl_filtered_ptr->points.resize(1);\n\tpoint_filtered_pcl_filtered_ptr->points[0].x = 0;\n\tpoint_filtered_pcl_filtered_ptr->points[0].y = 0;\n\tpoint_filtered_pcl_filtered_ptr->points[0].z = 0;\n\tpoint_filtered_pcl.header.frame_id = \"map\";\n\tpoint_filtered_pcl.header.stamp = ros::Time::now();\n\tpoint_filtered_pcl.width = 1;\n\tpoint_filtered_pcl.height = 1;\n\tpoint_filtered_pcl.is_dense", "CodeBleu_score": 47.38897929335032}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// Get the pose of the robot\n\ttf::StampedTransform transform;\n\ttry {\n\t\tlistener.lookupTransform(\"/map\", \"/base_link\", ros::Time(0), transform);\n\t} catch (tf::TransformException ex) {\n\t\tROS_ERROR(\"%s\", ex.what());\n\t\tros::Duration(1.0).sleep();\n\t}\n\n\t// Convert the laser scan to a PointCloud2\n\tsensor_msgs::PointCloud2 laser_cloud;\n\tsensor_msgs::convertLaserScanToPointCloud(\"/map\", *local_point, laser_cloud, listener);\n\n\t// Convert the PointCloud2 to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(laser_cloud, *laser_cloud_pcl);\n\n\t// Get the robot's pose\n\tEigen::Affine3d robot_pose;\n\trobot_pose.translation() << transform.getOrigin().x(), transform.getOrigin().y(), transform.getOrigin().z();\n\trobot_pose.linear() << transform.getRotation().getRotationMatrix();\n\n\t// Get the robot's pose in the map frame\n\tEigen::Affine3d robot_pose_map = robot_pose * map_to_robot_tf;\n\n\t// Project the laser scan into the map frame\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_map(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::transformPointCloud(*laser_cloud_pcl, *laser_cloud_map, robot_pose_map);\n\n\t// Update the map\n\tmap_update(laser_cloud_map);\n\n\t// Merge the local map with the global map\n\tif (!simulation) {\n\t\t// Get the robot's pose in the global frame\n\t\tEigen::Affine3d robot_pose_global = map_to_global_tf * robot_pose_map;\n\n\t\t// Get the robot's pose in the global frame\n\t\tEigen::Affine3d robot_pose_global = map_to_global_tf * robot_pose_map;\n\n\t\t// Update the global map\n\t\tmap_update(laser_cloud_map, robot_pose_global);\n\t}", "CodeBleu_score": 44.54309646290924}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\tif (!local_point) {\n\t\tROS_ERROR(\"No laser scan data received\");\n\t\treturn;\n\t}\n\n\t// Convert the laser scan to a PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_point(new pcl::PointCloud<pcl::PointXYZ>);\n\tlaser_point->header.frame_id = \"base_link\";\n\tlaser_point->header.stamp = ros::Time::now();\n\tsensor_msgs::PointCloud2 laser_point_msg;\n\tsensor_msgs::convertPointCloudToPointCloud2(*local_point, laser_point_msg);\n\tpcl::fromROSMsg(laser_point_msg, *laser_point);\n\n\t// If not in simulation mode, merge the local map with the odometry data\n\tif (!sim_mode) {\n\t\t// Convert the odometry data to a PointCloud2 format\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr odom_point(new pcl::PointCloud<pcl::PointXYZ>);\n\t\todom_point->header.frame_id = \"base_link\";\n\t\todom_point->header.stamp = ros::Time::now();\n\t\tsensor_msgs::PointCloud2 odom_point_msg;\n\t\tsensor_msgs::convertPointCloudToPointCloud2(odom, odom_point_msg);\n\t\tpcl::fromROSMsg(odom_point_msg, *odom_point);\n\n\t\t// Merge the local map with the odometry data\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr merged_point(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t*merged_point = *laser_point + *odom_point;\n\n\t\t// Update the local map\n\t\t*local_map = *merged_point;\n\t}\n\n\t// Update the local map\n\t*local_map = *laser_point;\n}\n", "CodeBleu_score": 43.04775044341863}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// convert the laser scan into a PointCloud2\n\tsensor_msgs::PointCloud2 laser_cloud;\n\tsensor_msgs::convertLaserScanToPointCloud(*local_point, laser_cloud, \"base_link\", sensor_msgs::image_encodings::TYPE_32FC1);\n\t// convert the PointCloud2 to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(laser_cloud, *laser_cloud_pcl);\n\t// merge the local map with the odometry information\n\tif (!sim_mode) {\n\t\t// convert the odometry information into a pcl::PointCloud\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr odom_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\t\todom_cloud_pcl->push_back(pcl::PointXYZ(odom.pose.pose.position.x, odom.pose.pose.position.y, 0));\n\t\t// merge the local map with the odometry information\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr merged_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::transformPointCloud(*laser_cloud_pcl, *merged_cloud_pcl, odom_cloud_pcl->at(0));\n\t\tlaser_cloud_pcl = merged_cloud_pcl;\n\t}\n\t// update the occupancy map\n\tmap_update(laser_cloud_pcl);\n\t// update the local map\n\tif (!sim_mode) {\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tlocal_cloud_pcl->push_back(pcl::PointXYZ(odom.pose.pose.position.x, odom.pose.pose.position.y, 0));\n\t\tpcl::transformPointCloud(*laser_cloud_pcl, *local_cloud_pcl, local_cloud_pcl->at(0));\n\t\tlaser_cloud_pcl = local_cloud_pcl;\n\t}\n\tlocal_map = *laser_cloud_pcl;\n}\n", "CodeBleu_score": 45.15249695651157}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Get the global point cloud\n\tpcl::PointCloud<pcl::PointXYZI> global_pcl;\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl.header.stamp = current_time;\n\tglobal_pcl.height = 1;\n\tglobal_pcl.width = map_ptr->map.size();\n\tglobal_pcl.is_dense = false;\n\tglobal_pcl.points.resize(global_pcl.width * global_pcl.height);\n\n\t// Get the inflated point cloud\n\tpcl::PointCloud<pcl::PointXYZI> inflate_pcl;\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl.header.stamp = current_time;\n\tinflate_pcl.height = 1;\n\tinflate_pcl.width = map_ptr->map.size();\n\tinflate_pcl.is_dense = false;\n\tinflate_pcl.points.resize(inflate_pcl.width * inflate_pcl.height);\n\n\t// Fill the point cloud\n\tfor (size_t i = 0; i < global_pcl.points.size(); i++) {\n\t\tglobal_pcl.points[i].x = map_ptr->map[i].x;\n\t\tglobal_pcl.points[i].y = map_ptr->map[i].y;\n\t\tglobal_pcl.points[i].z = map_ptr->map[i].z;\n\t\tglobal_pcl.points[i].intensity = map_ptr->map[i].occ;\n\n\t\tinflate_pcl.points[i].x = map_ptr->map[i].x;\n\t\tinflate_pcl.points[i].y = map_ptr->map[i].y;\n\t\tinflate_pcl.points[i].z = map_ptr->map[i].z;\n\t\tinflate_pcl.points[i].intensity = map_ptr->map[i].occ;\n\t}\n\n\t// Publish the point cloud\n\tglobal_pcl_pub.publish(global_pcl);\n\tinflate_pcl_pub.publish(inflate_pcl);\n}\n", "CodeBleu_score": 46.34559696783408}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t// Convert the global point cloud map to a ROS message.\n\tpcl::PointCloud<pcl::PointXYZ> pcl_msg;\n\tpcl_msg.header.frame_id = \"world\";\n\tpcl_msg.header.stamp = ros::Time::now();\n\tpcl_msg.width = map_width;\n\tpcl_msg.height = map_height;\n\tpcl_msg.points.resize(map_width * map_height);\n\tfor (int i = 0; i < map_height; i++) {\n\t\tfor (int j = 0; j < map_width; j++) {\n\t\t\tpcl_msg.points[i * map_width + j].x = j;\n\t\t\tpcl_msg.points[i * map_width + j].y = i;\n\t\t\tpcl_msg.points[i * map_width + j].z = map[i][j];\n\t\t}\n\t}\n\t// Publish the global point cloud map.\n\tglobal_pcl_pub.publish(pcl_msg);\n\n\t// Convert the inflated point cloud map to a ROS message.\n\tpcl::PointCloud<pcl::PointXYZ> pcl_msg_inflate;\n\tpcl_msg_inflate.header.frame_id = \"world\";\n\tpcl_msg_inflate.header.stamp = ros::Time::now();\n\tpcl_msg_inflate.width = map_width;\n\tpcl_msg_inflate.height = map_height;\n\tpcl_msg_inflate.points.resize(map_width * map_height);\n\tfor (int i = 0; i < map_height; i++) {\n\t\tfor (int j = 0; j < map_width; j++) {\n\t\t\tpcl_msg_inflate.points[i * map_width + j].x = j;\n\t\t\tpcl_msg_inflate.points[i * map_width + j].y = i;\n\t\t\tpcl_msg_inflate.points[i * map_width + j].z = inflate_map[i][j];\n\t\t}\n\t}\n\t// Publish the inflated point cloud map.\n\tinflate_pcl_pub.publish(pcl_msg_inflate);\n}\n", "CodeBleu_score": 49.45770617681841}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t// Publish the global point cloud\n\tsensor_msgs::PointCloud2 cloud_msg;\n\tpcl::toROSMsg(*global_cloud, cloud_msg);\n\tcloud_msg.header.stamp = ros::Time::now();\n\tcloud_msg.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(cloud_msg);\n\n\t// Publish the inflated point cloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud_inflate;\n\tfor (int i = 0; i < global_cloud->points.size(); i++) {\n\t\tif (global_cloud->points[i].z < 0.2) {\n\t\t\tcloud_inflate.push_back(global_cloud->points[i]);\n\t\t}\n\t}\n\tsensor_msgs::PointCloud2 cloud_msg_inflate;\n\tpcl::toROSMsg(cloud_inflate, cloud_msg_inflate);\n\tcloud_msg_inflate.header.stamp = ros::Time::now();\n\tcloud_msg_inflate.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(cloud_msg_inflate);\n}\n", "CodeBleu_score": 60.24564987717724}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tROS_INFO(\"Sensor ready!\");\n\t}\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"msg->width: %d\", msg->width);\n\t//ROS_INFO(\"msg->height: %d\", msg->height);\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\", msg->data.size());\n\t//ROS_INFO(\"msg->data.size(): %d\",", "CodeBleu_score": 15.2225272514257}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t}\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\tif (sensor_ready) {\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready: %d\", sensor_ready);\n\t\t//", "CodeBleu_score": 40.126465499657805}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (odometry_ready) {\n\t\tsensor_ready = true;\n\t\t//ROS_INFO(\"Sensor ready\");\n\t}\n}\n", "CodeBleu_score": 13.816689583091128}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get the current time\n\tros::Time now = ros::Time::now();\n\n\t// Get the current pose\n\tgeometry_msgs::PoseStamped current_pose;\n\tcurrent_pose_sub_.subscribe(current_pose_pub_);\n\tcurrent_pose_sub_.read(current_pose);\n\n\t// Get the current velocity\n\tgeometry_msgs::TwistStamped current_velocity;\n\tcurrent_velocity_sub_.subscribe(current_velocity_pub_);\n\tcurrent_velocity_sub_.read(current_velocity);\n\n\t// Get the current joint positions\n\tstd::vector<double> current_joint_positions;\n\tcurrent_joint_positions_sub_.subscribe(current_joint_positions_pub_);\n\tcurrent_joint_positions_sub_.read(current_joint_positions);\n\n\t// Get the current joint velocities\n\tstd::vector<double> current_joint_velocities;\n\tcurrent_joint_velocities_sub_.subscribe(current_joint_velocities_pub_);\n\tcurrent_joint_velocities_sub_.read(current_joint_velocities);\n\n\t// Get the current foot contact information\n\tstd::vector<bool> current_foot_contact;\n\tcurrent_foot_contact_sub_.subscribe(current_foot_contact_pub_);\n\tcurrent_foot_contact_sub_.read(current_foot_contact);\n\n\t// Get the current leg positions\n\tstd::vector<geometry_msgs::Pose> current_leg_positions;\n\tcurrent_leg_positions_sub_.subscribe(current_leg_positions_pub_);\n\tcurrent_leg_positions_sub_.read(current_leg_positions);\n\n\t// Get the current leg velocities\n\tstd::vector<geometry_msgs::Twist> current_leg_velocities;\n\tcurrent_leg_velocities_sub_.subscribe(current_leg_velocities_pub_);\n\tcurrent_leg_velocities_sub_.read(current_leg_velocities);\n\n\t// Get the current leg joint positions\n\tstd::vector<std::vector<double> > current_leg_joint_positions;\n\tcurrent_leg_joint_positions_sub_.subscribe(current_leg_joint_positions_pub_);\n\tcurrent_leg_joint_positions_sub_.read(current_", "CodeBleu_score": 31.54467904325971}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\tros::Time t_now = ros::Time::now();\n\n\t// Get the latest pose estimate from the body controller\n\tgeometry_msgs::PoseStamped pose;\n\tpose_sub_.subscribe(pose);\n\tpose_sub_.waitForMessage();\n\tpose = pose_sub_.getMessage();\n\n\t// Get the latest desired pose from the user\n\tgeometry_msgs::PoseStamped desired_pose;\n\tdesired_pose_sub_.subscribe(desired_pose);\n\tdesired_pose_sub_.waitForMessage();\n\tdesired_pose = desired_pose_sub_.getMessage();\n\n\t// Get the latest desired twist from the user\n\tgeometry_msgs::TwistStamped desired_twist;\n\tdesired_twist_sub_.subscribe(desired_twist);\n\tdesired_twist_sub_.waitForMessage();\n\tdesired_twist = desired_twist_sub_.getMessage();\n\n\t// Get the latest desired joint velocities from the user\n\tsensor_msgs::JointState desired_joint_velocities;\n\tdesired_joint_velocities_sub_.subscribe(desired_joint_velocities);\n\tdesired_joint_velocities_sub_.waitForMessage();\n\tdesired_joint_velocities = desired_joint_velocities_sub_.getMessage();\n\n\t// Get the latest desired foot positions from the user\n\tstd::vector<geometry_msgs::PoseStamped> desired_foot_poses;\n\tdesired_foot_poses_sub_.subscribe(desired_foot_poses);\n\tdesired_foot_poses_sub_.waitForMessage();\n\tdesired_foot_poses = desired_foot_poses_sub_.getMessage();\n\n\t// Get the latest desired foot velocities from the user\n\tstd::vector<geometry_msgs::TwistStamped> desired_foot_velocities;\n\tdesired_foot_velocities_sub_.subscribe(desired_foot_velocities);\n\tdesired_foot_velocities_sub_.waitForMessage();\n\tdesired_foot_velocities = desired_foot_velocities_sub_.getMessage();\n\n\t// Get the latest desired joint positions from the user\n\tsensor_msgs::JointState desired_joint_positions;\n\tdesired_joint_positions_sub_.subscribe(desired_joint_positions);\n\tdesired_joint_positions_sub_.waitForMessage();\n\tdesired", "CodeBleu_score": 36.171762228306136}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get the current time\n\tros::Time t = ros::Time::now();\n\n\t// Get the current state\n\tconst auto& state = state_.get();\n\n\t// Calculate target foot positions\n\tconst auto target_foot_positions = body_controller_.calculateTargetFootPositions(state.pose, state.velocity, t);\n\n\t// Compute velocity commands for the legs\n\tconst auto target_leg_velocities = leg_controller_.computeLegVelocities(state.pose, target_foot_positions, t);\n\n\t// Compute target joint positions\n\tconst auto target_joint_positions = leg_controller_.computeLegJointPositions(state.pose, target_leg_velocities, t);\n\n\t// Publish foot contact information\n\tpublishFootContactInformation(target_foot_positions, t);\n\n\t// Publish joint positions\n\tpublishJointPositions(target_joint_positions, t);\n}\n", "CodeBleu_score": 49.292267501981435}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\t// Only publish foot contact states if foot contact publishing is enabled and the robot is not in Gazebo\n\tif (foot_contact_publishing_enabled_ &&!gazebo_simulation_) {\n\t\t// Create a ContactsStamped message\n\t\tgeometry_msgs::msg::ContactsStamped contacts_stamped;\n\t\tcontacts_stamped.header.stamp = rclcpp::Time(0);\n\t\tcontacts_stamped.header.frame_id = \"base_footprint\";\n\n\t\t// Populate the message with the current gait phase of each leg\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tgeometry_msgs::msg::ContactPoint contact_point;\n\t\t\tcontact_point.header.stamp = rclcpp::Time(0);\n\t\t\tcontact_point.header.frame_id = \"base_footprint\";\n\t\t\tcontact_point.contact_normal.x = 0.0;\n\t\t\tcontact_point.contact_normal.y = 0.0;\n\t\t\tcontact_point.contact_normal.z = 0.0;\n\t\t\tcontact_point.contact_point.x = 0.0;\n\t\t\tcontact_point.contact_point.y = 0.0;\n\t\t\tcontact_point.contact_point.z = 0.0;\n\t\t\tcontact_point.wrench.force.x = 0.0;\n\t\t\tcontact_point.wrench.force.y = 0.0;\n\t\t\tcontact_point.wrench.force.z = 0.0;\n\t\t\tcontact_point.wrench.torque.x = 0.0;\n\t\t\tcontact_point.wrench.torque.y = 0.0;\n\t\t\tcontact_point.wrench.torque.z = 0.0;\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\tcontact_point.contact_state = geometry_msgs::msg::ContactState::CONTACT;\n\t\t\t} else {\n\t\t\t\tcontact_point.contact_state = geometry_msgs::msg::ContactState::NO_CONTACT;\n\t\t\t}\n\t\t\tcontacts_stamped.contacts.push_back(contact_point);\n\t\t}\n\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_->publish(contacts_stamped);\n\t}\n}\n", "CodeBleu_score": 44.767168154992014}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\tgeometry_msgs::Wrench wrench;\n\t\twrench.force.x = 0;\n\t\twrench.force.y = 0;\n\t\twrench.force.z = 0;\n\t\twrench.torque.x = 0;\n\t\twrench.torque.y = 0;\n\t\twrench.torque.z = 0;\n\n\t\tgeometry_msgs::WrenchStamped wrench_stamped;\n\t\twrench_stamped.header.stamp = ros::Time::now();\n\t\twrench_stamped.header.frame_id = \"world\";\n\t\twrench_stamped.wrench = wrench;\n\n\t\tgeometry_msgs::Contacts contacts;\n\t\tcontacts.header.stamp = ros::Time::now();\n\t\tcontacts.header.frame_id = \"world\";\n\n\t\tgeometry_msgs::Contact contact;\n\t\tcontact.contact_point.x = 0;\n\t\tcontact.contact_point.y = 0;\n\t\tcontact.contact_point.z = 0;\n\t\tcontact.wrench.force.x = 0;\n\t\tcontact.wrench.force.y = 0;\n\t\tcontact.wrench.force.z = 0;\n\t\tcontact.wrench.torque.x = 0;\n\t\tcontact.wrench.torque.y = 0;\n\t\tcontact.wrench.torque.z = 0;\n\n\t\tgeometry_msgs::ContactStamped contact_stamped;\n\t\tcontact_stamped.header.stamp = ros::Time::now();\n\t\tcontact_stamped.header.frame_id = \"world\";\n\t\tcontact_stamped.contact = contact;\n\n\t\tif (foot_contacts[0]) {\n\t\t\tcontact.contact_normal.x = 1;\n\t\t\tcontact.contact_normal.y = 0;\n\t\t\tcontact.contact_normal.z = 0;\n\t\t\tcontact.header.stamp = ros::Time::now();\n\t\t\tcontact.header.frame_id = \"left_leg_link\";\n\t\t\tcontact_stamped.header.stamp = ros::Time::now();\n\t\t\tcontact_stamped.header.frame_id = \"left_", "CodeBleu_score": 32.432021425745965}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\t// Create a message\n\t\tgeometry_msgs::Contacts contacts;\n\t\tgeometry_msgs::Contact contact;\n\t\t// Populate the message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\tcontact.contact_point.x = 0.0;\n\t\t\t\tcontact.contact_point.y = 0.0;\n\t\t\t\tcontact.contact_normal.x = 0.0;\n\t\t\t\tcontact.contact_normal.y = 0.0;\n\t\t\t\tcontact.header.frame_id = \"base_footprint\";\n\t\t\t\tcontact.header.stamp = ros::Time::now();\n\t\t\t\tcontact.wrench.force.x = 0.0;\n\t\t\t\tcontact.wrench.force.y = 0.0;\n\t\t\t\tcontact.wrench.force.z = 0.0;\n\t\t\t\tcontact.wrench.torque.x = 0.0;\n\t\t\t\tcontact.wrench.torque.y = 0.0;\n\t\t\t\tcontact.wrench.torque.z = 0.0;\n\t\t\t\tcontacts.contacts.push_back(contact);\n\t\t\t}\n\t\t}\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_.publish(contacts);\n\t}\n}\n", "CodeBleu_score": 40.35809011461837}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)\t# Create a minimal joints message with the first 12 joint positions\n\tmsg = JointState()\n\tmsg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n\tmsg.position = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n\tmsg.velocity = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\tmsg.effort = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\tself.joints_pub.publish(msg)\n\n\t# Construct a joint trajectory message with the same positions and a specified duration\n\tmsg = JointTrajectory()\n\tmsg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n\tmsg.points = [JointTrajectoryPoint(positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[1", "CodeBleu_score": 29.489744897731775}, {"code": "def joints_cmd_callback(self, joints)\t# Create a minimal joints message with the first 12 joint positions\n\tmsg = JointState()\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.name = ['shoulder_pan_joint','shoulder_lift_joint', 'elbow_joint', 'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint', 'base_1_joint', 'base_2_joint', 'base_3_joint', 'base_4_joint', 'base_5_joint', 'base_6_joint']\n\tmsg.position = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n\tself.joints_pub.publish(msg)\n\n\t# Construct a joint trajectory message with the same positions and a specified duration\n\ttraj = JointTrajectory()\n\ttraj.header.stamp = rospy.Time.now()\n\ttraj.joint_names = ['shoulder_pan_joint','shoulder_lift_joint', 'elbow_joint', 'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint', 'base_1_joint', 'base_2_joint', 'base_3_joint', 'base_4_joint', 'base_5_joint', 'base_6_joint']\n\ttraj.points = [JointTrajectoryPoint(positions=[joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]], time_from_start=rospy.Duration(0.5))]\n\tself.joints_traj_pub.publish(traj)\n}\n", "CodeBleu_score": 38.56075895896196}, {"code": "def joints_cmd_callback(self, joints)\tself.joints = joints\n\tself.joint_msg = JointTrajectory()\n\tself.joint_msg.header.stamp = rospy.Time.now()\n\tself.joint_msg.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6', 'joint7', 'joint8', 'joint9', 'joint10', 'joint11', 'joint12']\n\tself.joint_msg.points = []\n\tself.joint_msg.points.append(JointTrajectoryPoint())\n\tself.joint_msg.points[0].positions = [self.joints[0], self.joints[1], self.joints[2], self.joints[3], self.joints[4], self.joints[5], self.joints[6], self.joints[7], self.joints[8], self.joints[9], self.joints[10], self.joints[11]]\n\tself.joint_msg.points[0].velocities = [0.0] * 12\n\tself.joint_msg.points[0].accelerations = [0.0] * 12\n\tself.joint_msg.points[0].time_from_start = rospy.Duration(1.0)\n\tself.joint_pub.publish(self.joint_msg)\n\tself.traj_msg = JointTrajectory()\n\tself.traj_msg.header.stamp = rospy.Time.now()\n\tself.traj_msg.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6', 'joint7', 'joint8', 'joint9', 'joint10', 'joint11', 'joint12']\n\tself.traj_msg.points = []\n\tself.traj_msg.points.append(JointTrajectoryPoint())\n\tself.traj_msg.points[0].positions = [self.joints[0], self.joints[1], self.joints[2], self.joints[3], self.joints[4], self.joints[5], self.joints[6], self.joints[7], self.joints[8], self.joints[9], self.joints[10], self.joints[1", "CodeBleu_score": 33.67197698774059}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)\t// Initialize foot contact states to false\n\tfootContactLeft_ = false;\n\tfootContactRight_ = false;\n\n\t// Iterate through contact messages\n\tfor (unsigned int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Get contact message\n\t\tconst Contact &_contact = _msg->contact(i);\n\n\t\t// Get collision link\n\t\tstd::string _link = _contact.collision1().link_name();\n\t\t//std::cout << \"link: \" << _link << std::endl;\n\n\t\t// Check if contact is with left foot\n\t\tif (_link.find(\"left_foot\")!= std::string::npos) {\n\t\t\tfootContactLeft_ = true;\n\t\t}\n\n\t\t// Check if contact is with right foot\n\t\tif (_link.find(\"right_foot\")!= std::string::npos) {\n\t\t\tfootContactRight_ = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.37619546897617}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\t//initialize foot contact states to false\n\tleftFootContact_ = false;\n\trightFootContact_ = false;\n\t//for each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t//split the collision string to identify the contact link\n\t\tstd::string contactLink = _msg->contact(i).collision1().c_str();\n\t\tstd::string::size_type pos = contactLink.find(\"::\");\n\t\tif (pos!= std::string::npos) {\n\t\t\tcontactLink = contactLink.substr(pos + 2);\n\t\t}\n\t\t//if the contact link matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (contactLink.compare(leftFootLink_) == 0) {\n\t\t\tleftFootContact_ = true;\n\t\t} else if (contactLink.compare(rightFootLink_) == 0) {\n\t\t\trightFootContact_ = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.74544820702984}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string link = _msg->contact(i).collision1().substr(10);\n\t\tif (link == \"left_foot_link\" || link == \"right_foot_link\") {\n\t\t\tif (link == \"left_foot_link\")\n\t\t\t\tleftFootContact = true;\n\t\t\telse\n\t\t\t\trightFootContact = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 30.230175348850242}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Ensure the input is valid\n\tif (rotor_velocities == nullptr) {\n\t\tthrow std::invalid_argument(\"rotor_velocities cannot be null.\");\n\t}\n\n\t// Ensure the vehicle is active\n\tif (!this->active_) {\n\t\t// Set all rotor velocities to zero\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Compute the desired acceleration\n\tEigen::Vector3d desired_acceleration = this->ComputeDesiredAcceleration();\n\n\t// Compute the desired angular acceleration\n\tEigen::Vector3d desired_angular_acceleration = this->ComputeDesiredAngularAcceleration();\n\n\t// Compute the thrust\n\tdouble thrust = this->ComputeThrust(desired_acceleration);\n\n\t// Compute the body z-axis acceleration\n\tEigen::Vector3d body_z_acceleration = this->ComputeBodyZAcceleration(desired_acceleration, desired_angular_acceleration);\n\n\t// Compute the body z-axis angular acceleration\n\tEigen::Vector3d body_z_angular_acceleration = this->ComputeBodyZAngularAcceleration(desired_angular_acceleration);\n\n\t// Compute the body z-axis thrust\n\tdouble body_z_thrust = this->ComputeBodyZThrust(body_z_acceleration, body_z_angular_acceleration);\n\n\t// Compute the body z-axis rotor velocities\n\tEigen::Vector3d body_z_rotor_velocities = this->ComputeBodyZRotorVelocities(body_z_acceleration, body_z_angular_acceleration, body_z_thrust);\n\n\t// Compute the body x-axis rotor velocities\n\tEigen::Vector3d body_x_rotor_velocities = this->ComputeBodyXRotorVelocities(body_z_rotor_velocities);\n\n\t// Compute the body y-axis rotor velocities\n\tEigen::Vector3d body_y_rotor_velocities = this->ComputeBodyYRotorVelocities(body_z_rotor_velocities);\n\n\t// Compute the body z-axis rotor velocities\n\tEigen::Vector3d body_z_rotor_velocities = this->ComputeBodyZRotorVelocities(body_z_rotor_velocities);\n\n\t// Compute the rotor velocities\n\trotor_velocities->setZero", "CodeBleu_score": 35.996506222749815}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\tif (!active_) {\n\t\t*rotor_velocities = Eigen::VectorXd::Zero(num_rotors_);\n\t\treturn;\n\t}\n\n\tEigen::Vector3d desired_acceleration = CalculateDesiredAcceleration();\n\tEigen::Vector3d angular_acceleration = CalculateAngularAcceleration();\n\tEigen::Vector3d thrust = CalculateThrust();\n\n\t// Project thrust onto body z-axis\n\tthrust = thrust.cross(angular_acceleration.cross(body_to_world_.linear()));\n\n\t// Combine angular acceleration and thrust\n\tEigen::Vector3d rotor_acceleration = angular_acceleration + thrust;\n\n\t// Multiply by predefined matrix\n\trotor_acceleration = rotor_acceleration * rotor_acceleration_matrix_;\n\n\t// Take square root\n\trotor_acceleration = rotor_acceleration.cwiseSqrt();\n\n\t// Ensure non-negative values\n\trotor_acceleration = rotor_acceleration.cwiseMax(Eigen::Vector3d::Zero());\n\n\t// Set rotor velocities\n\t*rotor_velocities = rotor_acceleration.cwiseProduct(rotor_velocities_);\n}\n", "CodeBleu_score": 35.6743722534436}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Check if the controller is active\n\tif (!active_) {\n\t\t// If not, set all rotor velocities to zero\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t(*rotor_velocities)[i] = 0.0;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Check if the input is valid\n\tif (rotor_velocities == nullptr) {\n\t\tstd::cerr << \"Invalid input.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Check if the parameters are valid\n\tif (rotor_velocities_max_ == nullptr || rotor_velocities_min_ == nullptr || rotor_velocities_max_->size()!= 4 || rotor_velocities_min_->size()!= 4) {\n\t\tstd::cerr << \"Invalid parameters.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Check if the parameters are valid\n\tif (rotor_velocities_max_->minCoeff() < 0.0 || rotor_velocities_min_->maxCoeff() > 0.0) {\n\t\tstd::cerr << \"Invalid parameters.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Compute the desired acceleration\n\tEigen::Vector3d desired_acceleration = ComputeDesiredAcceleration();\n\n\t// Compute the angular acceleration\n\tEigen::Vector3d angular_acceleration = ComputeAngularAcceleration();\n\n\t// Compute the thrust\n\tEigen::Vector3d thrust = ComputeThrust();\n\n\t// Compute the projected thrust\n\tEigen::Vector3d projected_thrust = thrust.dot(Eigen::Vector3d::UnitZ()) * Eigen::Vector3d::UnitZ();\n\n\t// Compute the rotor velocities\n\tEigen::Vector3d rotor_velocities_temp = angular_acceleration + projected_thrust;\n\trotor_velocities_temp.array() = rotor_velocities_temp.array().max(0.0);\n\trotor_velocities_temp.array() = rotor_velocities_temp.array().min(rotor_velocities_max_->array());\n\t(*rotor_velocities) = rotor_velocities_temp.array().sqrt();\n}\n", "CodeBleu_score": 41.0606407084088}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// TODO: Implement this function\n\tEigen::Vector3d world_velocity;\n\tEigen::Vector3d world_position;\n\tEigen::Vector3d world_acceleration;\n\tEigen::Vector3d world_acceleration_commanded;\n\tEigen::Vector3d world_acceleration_desired;\n\n\t// Compute the world velocity and position\n\tworld_velocity = (odometry_data.velocity * odometry_data.R_w_i).cast<double>();\n\tworld_position = (odometry_data.position * odometry_data.R_w_i).cast<double>();\n\n\t// Compute the world acceleration\n\tworld_acceleration = (odometry_data.acceleration * odometry_data.R_w_i).cast<double>();\n\n\t// Compute the world acceleration commanded\n\tworld_acceleration_commanded = (acceleration_commanded * odometry_data.R_w_i).cast<double>();\n\n\t// Compute the world acceleration desired\n\tworld_acceleration_desired = world_acceleration_commanded - world_acceleration;\n\n\t// Compute the desired acceleration\n\tacceleration->x() = (world_acceleration_desired.x() - (world_velocity.x() * world_velocity.x()) / (2 * mass)) / (1 / sampling_time);\n\tacceleration->y() = (world_acceleration_desired.y() - (world_velocity.y() * world_velocity.y()) / (2 * mass)) / (1 / sampling_time);\n\tacceleration->z() = (world_acceleration_desired.z() - (world_velocity.z() * world_velocity.z()) / (2 * mass)) / (1 / sampling_time);\n}\n", "CodeBleu_score": 42.57137746360363}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\tEigen::Vector3d acceleration_world;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_world;\n\tEigen::Vector3d velocity_command;\n\n\t// Transform the vehicle's velocity to the world frame\n\tvelocity_world = this->vehicle_pose.GetRotationMatrix() * this->vehicle_velocity;\n\n\t// Compute the velocity error\n\tvelocity_error = this->vehicle_velocity - this->velocity_command;\n\n\t// Compute the position error\n\tposition_error = this->vehicle_pose.GetPosition() - this->position_command;\n\n\t// Compute the desired acceleration\n\tacceleration_world = (this->position_gain * position_error) + (this->velocity_gain * velocity_error);\n\n\t// Transform the desired acceleration back to the vehicle frame\n\t*acceleration = this->vehicle_pose.GetRotationMatrix().transpose() * acceleration_world;\n}\n", "CodeBleu_score": 34.98691731522889}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\tEigen::Vector3d commanded_acceleration = *acceleration;\n\n\t// Calculate the position error\n\tEigen::Vector3d position_error = commanded_trajectory_.GetPosition() - current_odometry_.GetPosition();\n\n\t// Calculate the velocity error\n\tEigen::Vector3d velocity_error = commanded_trajectory_.GetVelocity() - current_odometry_.GetVelocity();\n\n\t// Transform the velocity error to the world frame\n\tEigen::Vector3d velocity_error_world = world_frame_.GetTransform().GetInverse().Rotate(velocity_error);\n\n\t// Calculate the desired acceleration\n\tEigen::Vector3d desired_acceleration = position_error * position_gains_.GetX() + velocity_error_world * velocity_gains_.GetX() + commanded_acceleration;\n\n\t// Add gravity to the desired acceleration\n\tdesired_acceleration += gravity_;\n\n\t// Add mass to the desired acceleration\n\tdesired_acceleration += (1.0 / mass_) * Eigen::Vector3d(0, 0, -gravity_constant_);\n\n\t// Set the desired acceleration\n\t*acceleration = desired_acceleration;\n}\n", "CodeBleu_score": 42.36685289087446}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Check if the input is valid\n\tif (rotor_velocities == nullptr) {\n\t\tthrow std::invalid_argument(\"The rotor velocities vector is null\");\n\t}\n\n\t// Resize the rotor velocities vector\n\trotor_velocities->resize(rotor_velocities_->size());\n\n\t// Calculate the desired angular acceleration\n\tEigen::Vector3d desired_angular_acceleration = thrust_reference_ / mass_ + (inertia_ * angular_acceleration_reference_);\n\n\t// Combine the desired angular acceleration with the thrust reference\n\tEigen::Vector3d rotor_velocities_vector = desired_angular_acceleration + thrust_reference_;\n\n\t// Ensure the rotor velocities are at least one\n\trotor_velocities_vector = rotor_velocities_vector.cwiseMax(Eigen::Vector3d::Ones());\n\n\t// Take the square root of the rotor velocities\n\trotor_velocities_vector = rotor_velocities_vector.cwiseSqrt();\n\n\t// Assign the rotor velocities to the output vector\n\t*rotor_velocities = rotor_velocities_vector;\n}\n", "CodeBleu_score": 41.85087470775773}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Check if the input is valid.\n\tif (rotor_velocities == nullptr) {\n\t\tthrow std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: The rotor velocities pointer is null.\");\n\t}\n\n\t// Resize the rotor velocities vector to match the number of rotors.\n\trotor_velocities->resize(rotor_velocities->size());\n\n\t// Calculate the desired angular acceleration.\n\tEigen::Vector3d desired_angular_acceleration = thrust_reference_ / mass_;\n\n\t// Combine the desired angular acceleration with the thrust reference.\n\tEigen::Vector3d rotor_velocities_vector = desired_angular_acceleration + thrust_reference_;\n\n\t// Ensure the rotor velocities are at least one.\n\trotor_velocities_vector.array() = rotor_velocities_vector.array().max(1.0);\n\n\t// Take the square root of the rotor velocities vector.\n\trotor_velocities_vector = rotor_velocities_vector.array().sqrt();\n\n\t// Assign the rotor velocities vector to the rotor velocities pointer.\n\t*rotor_velocities = rotor_velocities_vector;\n}\n", "CodeBleu_score": 42.26236157177684}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Check that the input is valid\n\tif (rotor_velocities == nullptr) {\n\t\tthrow std::invalid_argument(\"Input rotor velocities cannot be nullptr.\");\n\t}\n\n\t// Resize the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(rotor_velocities_->size());\n\n\t// Calculate the desired angular acceleration\n\tEigen::Vector3d desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\n\t// Combine the desired angular acceleration and thrust reference into a single vector\n\tEigen::Vector3d desired_rotor_velocities = desired_angular_acceleration + thrust_reference_;\n\n\t// Ensure the rotor velocities are at least one\n\tfor (size_t i = 0; i < rotor_velocities_->size(); i++) {\n\t\tif (desired_rotor_velocities(i) < 1.0) {\n\t\t\tdesired_rotor_velocities(i) = 1.0;\n\t\t}\n\t}\n\n\t// Take the square root of each component of the desired rotor velocities\n\tfor (size_t i = 0; i < rotor_velocities_->size(); i++) {\n\t\trotor_velocities->operator()(i) = std::sqrt(desired_rotor_velocities(i));\n\t}\n}\n", "CodeBleu_score": 39.70536679692929}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    copy = self.copy()\n    copy.data = copy.data[start_index:end_index]\n    copy.time = copy.time[start_index:end_index]\n    copy.date = copy.date[start_index:end_index]\n    copy.time_index = copy.time_index[start_index:end_index]\n    copy.date_index = copy.date_index[start_index:end_index]\n    copy.data_index = copy.data_index[start_index:end_index]\n    return copy\n", "CodeBleu_score": 20.477416724023733}, {"code": "def slice(self, start_time, end_time)\n    if start_time > end_time:\n        raise ValueError(\"start_time must be less than end_time\")\n    if end_time > self.time[-1]:\n        raise ValueError(\"end_time must be less than the last time value\")\n    if start_time < self.time[0]:\n        raise ValueError(\"start_time must be greater than the first time value\")\n    start_index = np.where(self.time == start_time)[0][0]\n    end_index = np.where(self.time == end_time)[0][0]\n    copy = copy.deepcopy(self)\n    copy.time = self.time[start_index:end_index]\n    copy.data = self.data[start_index:end_index]\n    return copy\n", "CodeBleu_score": 40.355647444457645}, {"code": "def slice(self, start_time, end_time)\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    copy = self.copy()\n    copy.time = copy.time[start_index:end_index]\n    copy.position = copy.position[start_index:end_index]\n    copy.velocity = copy.velocity[start_index:end_index]\n    copy.acceleration = copy.acceleration[start_index:end_index]\n    return copy\n", "CodeBleu_score": 22.97388211467879}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    if self.current_waypoint_msg is not None:\n      # Check if the current waypoint is different from the last one\n      if not self.is_waypoint_same(waypoint_msg):\n        # Extract position and rotation\n        position = waypoint_msg.pose.pose.position\n        orientation = waypoint_msg.pose.pose.orientation\n        # Convert rotation to Euler angles\n        roll, pitch, yaw = tf.transformations.euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n        # Create a Point object\n        point = Point(position.x, position.y, position.z, yaw)\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n        # Update the current waypoint message\n        self.current_waypoint_msg = waypoint_msg\n\n  def is_waypoint_same(self, waypoint_msg):\n    \"\"\"This function, is_waypoint_same, checks if the current waypoint is different from the last one by comparing position and yaw values.\\nIf the waypoint is different, it returns True.\\nIf the waypoint is the same, it returns False.\"\"\"\n    # Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    orientation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    roll, pitch, yaw = tf.transformations.euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    # Check if the current waypoint is different from the last one\n    if position.x!= self.current_position.x or position.y!= self.current_position.y or position.z!= self.current_position.z or yaw!= self.current_yaw:\n      return True\n    return False\n\n  def get_waypoint_data(self):\n    \"\"\"This function, get_waypoint_data, returns the points, yaws, and times arrays.\"\"\"\n    return self.points, self.yaws, self.times, self.bag_times\n\n  def get_current_waypoint(self):\n    \"\"\"This function, get_current_waypoint, returns the current waypoint message", "CodeBleu_score": 30.310288575308764}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    if self.num_waypoints == 0:\n      self.waypoints.append(waypoint_msg.pose.position)\n      self.yaw.append(self.euler_from_quaternion(waypoint_msg.pose.orientation))\n      self.time.append(msg_time)\n      self.bag_time.append(bag_time)\n      self.num_waypoints += 1\n    elif self.num_waypoints > 0:\n      if waypoint_msg.pose.position.x!= self.waypoints[self.num_waypoints - 1].x or waypoint_msg.pose.position.y!= self.waypoints[self.num_waypoints - 1].y or waypoint_msg.pose.position.z!= self.waypoints[self.num_waypoints - 1].z or self.yaw[self.num_waypoints - 1]!= self.euler_from_quaternion(waypoint_msg.pose.orientation):\n        self.waypoints.append(waypoint_msg.pose.position)\n        self.yaw.append(self.euler_from_quaternion(waypoint_msg.pose.orientation))\n        self.time.append(msg_time)\n        self.bag_time.append(bag_time)\n        self.num_waypoints += 1\n\n  def euler_from_quaternion(self, quaternion):\n    \"\"\"This function, euler_from_quaternion, takes a quaternion and converts it to Euler angles.\\nIt uses the tf.transformations.euler_from_quaternion function to convert the quaternion to Euler angles.\"\"\"\n    euler = tf.transformations.euler_from_quaternion([quaternion.x, quaternion.y, quaternion.z, quaternion.w])\n    return euler\n\n  def save_waypoints(self, waypoints_file, waypoints):\n    \"\"\"This function, save_waypoints, saves the waypoints to a text file.\\nIt takes the name of the text file and the waypoints as arguments.\\nIt opens the text file in write mode.\\nIt writes the waypoints to the text file in the format x, y, z, yaw.\"\"\"\n    with open(waypoints_file, 'w') as file:\n      for i in range(len(waypoints)):\n        file.write(str(waypoints[i].x", "CodeBleu_score": 28.177337347086457}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    if self.last_waypoint_position is None:\n      self.last_waypoint_position = waypoint_msg.pose.pose.position\n      self.last_waypoint_yaw = self.quaternion_to_euler(waypoint_msg.pose.pose.orientation)\n      self.waypoint_position_array.append(self.last_waypoint_position)\n      self.waypoint_yaw_array.append(self.last_waypoint_yaw)\n      self.waypoint_time_array.append(msg_time)\n    else:\n      new_waypoint_position = waypoint_msg.pose.pose.position\n      new_waypoint_yaw = self.quaternion_to_euler(waypoint_msg.pose.pose.orientation)\n      if self.last_waypoint_position!= new_waypoint_position or self.last_waypoint_yaw!= new_waypoint_yaw:\n        self.waypoint_position_array.append(new_waypoint_position)\n        self.waypoint_yaw_array.append(new_waypoint_yaw)\n        self.waypoint_time_array.append(msg_time)\n      self.last_waypoint_position = new_waypoint_position\n      self.last_waypoint_yaw = new_waypoint_yaw\n\n  def quaternion_to_euler(self, quaternion):\n    \"\"\"This function, quaternion_to_euler, converts a quaternion to Euler angles.\\nIt uses the tf.transformations library to convert a quaternion to a rotation matrix, which is then converted to Euler angles.\"\"\"\n    rotation_matrix = tf.transformations.quaternion_matrix([quaternion.x, quaternion.y, quaternion.z, quaternion.w])\n    euler_angles = tf.transformations.euler_from_matrix(rotation_matrix)\n    return euler_angles\n\n  def get_waypoint_index(self, msg_time):\n    \"\"\"This function, get_waypoint_index, gets the index of the waypoint that is closest to the current time.\\nIt iterates through the waypoint times and finds the waypoint that is closest to the current time.\\nIt returns the index of the waypoint closest to the current time.\"\"\"\n    closest_waypoint_index = 0\n    for i in range(len(self.waypoint_time_array)):\n      if abs(self.waypoint_time_array[i] - msg_time) < abs(self.waypoint_time_", "CodeBleu_score": 28.75868518269163}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == self.imu_topic:\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time.append(msg.header.stamp.to_sec())\n        self.bag_time.append(bag_time)\n\n    def extract_imu_topics_mag(self, topic, msg, bag_time):\n        \"\"\"This function, extract_imu_topics, appends IMU topic message content to magnetic attributes.\\nIt converts the message timestamp to seconds.\\nFor each IMU topic, if the topic matches, it appends the magnetic field data to the corresponding x, y, and z attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n        if topic == self.imu_topic:\n            self.magnetic_x.append(msg.magnetic_field.x)\n            self.magnetic_y.append(msg.magnetic_field.y)\n            self.magnetic_z.append(msg.magnetic_field.z)\n            self.time.append(msg.header.stamp.to_sec())\n            self.bag_time.append(bag_time)\n\n    def extract_imu_topics_gyro(self, topic, msg, bag_time):\n        \"\"\"This function, extract_imu_topics, appends IMU topic message content to gyroscope attributes.\\nIt converts the message timestamp to seconds.\\nFor each IMU topic, if the topic matches, it appends the angular velocity data to the corresponding x, y, and z attributes.\\nIt also appends the message time and bag time to the time attributes.\"\"\"\n        if topic == self.imu_topic:\n            self.gyro_x.append(msg.angular_velocity.x)\n            self.gyro_y.append(msg.angular_velocity.y)\n            self.gyro_z.append(msg.angular_velocity.z)\n            self.time.append(msg.header.stamp.to_sec())\n            self.bag_time.append(bag_time)\n\n    def extract_imu_topics_orientation(self, topic, msg, bag_time):\n        \"\"\"This function, extract_imu_topics, appends IMU topic message content", "CodeBleu_score": 28.177773866947188}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == '/imu/data':\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_x.append(msg.linear_acceleration.x)\n        self.imu_y.append(msg.linear_acceleration.y)\n        self.imu_z.append(msg.linear_acceleration.z)\n\n    # This function is used to get the IMU topic data from the bag file.\n    def get_imu_topics(self, bag_file):\n        \"\"\"This function, get_imu_topics, extracts the IMU topic data from the bag file.\"\"\"\n        bag = rosbag.Bag(bag_file)\n        for topic, msg, t in bag.read_messages(topics=['/imu/data']):\n            self.extract_imu_topics(topic, msg, t)\n        bag.close()\n\n    # This function is used to get the IMU topic data from the bag file.\n    def get_imu_topics_from_bag(self, bag_file):\n        \"\"\"This function, get_imu_topics, extracts the IMU topic data from the bag file.\"\"\"\n        bag = rosbag.Bag(bag_file)\n        for topic, msg, t in bag.read_messages(topics=['/imu/data']):\n            self.extract_imu_topics(topic, msg, t)\n        bag.close()\n\n    # This function is used to get the IMU topic data from the bag file.\n    def get_imu_topics_from_bag_to_csv(self, bag_file, csv_file):\n        \"\"\"This function, get_imu_topics, extracts the IMU topic data from the bag file.\"\"\"\n        bag = rosbag.Bag(bag_file)\n        for topic, msg, t in bag.read_messages(topics=['/imu/data']):\n            self.extract_imu_topics(topic, msg, t)\n        bag.close()\n        with open(csv_file, 'w') as csvfile:\n            writer = csv.writer(csvfile, delimiter=',')\n            writer.writerow(['Time', 'Bag Time', 'X', 'Y', 'Z'])\n            for i in range(len(self.imu_time)):\n                writer.writerow([self.imu_time[", "CodeBleu_score": 33.59753652414858}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    #TODO: Implement this function\n    #TODO: Return the time attributes\n    #TODO: Return the acceleration attributes\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO: Return the message time attribute\n    #TODO: Return the topic attribute\n    #TODO: Return the message attribute\n    #TODO: Return the bag time attribute\n    #TODO:", "CodeBleu_score": 3.103277060575968}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n    # Create a figure with a title and a subplot for acceleration data\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=100)\n    ax.set_title('Acceleration Data')\n\n    # Plot the x, y, and z components of acceleration data over time with different colors and labels\n    ax.plot(self.timestamp, self.acceleration_x, label='x', color='red')\n    ax.plot(self.timestamp, self.acceleration_y, label='y', color='green')\n    ax.plot(self.timestamp, self.acceleration_z, label='z', color='blue')\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = self.prefix + '_accelerations'\n        if plot_suffix:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        fig.savefig(filename)\n\n    # Show the plot\n    plt.show()\n", "CodeBleu_score": 35.93808625253182}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    if self.accelerations is not None:\n      fig, ax = plt.subplots()\n      fig.suptitle(\"Accelerations\")\n      ax.set_xlabel(\"Time (s)\")\n      ax.set_ylabel(\"Acceleration (m/s^2)\")\n      for i in range(len(self.accelerations)):\n        ax.plot(self.times, self.accelerations[i, :, 0], color=\"red\", label=\"x\")\n        ax.plot(self.times, self.accelerations[i, :, 1], color=\"green\", label=\"y\")\n        ax.plot(self.times, self.accelerations[i, :, 2], color=\"blue\", label=\"z\")\n      ax.legend(loc=\"upper right\")\n      if self.save_plots:\n        if plot_suffix is not None:\n          filename = self.prefix + \"_accelerations_\" + plot_suffix + \".png\"\n        else:\n          filename = self.prefix + \"_accelerations.png\"\n        plt.savefig(filename, dpi=300)\n      plt.show()\n    else:\n      print(\"No accelerations to plot.\")\n\n  def plot_gyros(self, plot_suffix=None):\n    \"\"\"This function, plot_gyros, generates and saves a plot of gyroscope data.\\nIt creates a figure with a title and a subplot for gyros.\\nFor each gyroscope dataset, it plots the x, y, and z components over time with different colors and labels.\\nIt adds labels for the x and y axes and includes a legend.\\nIf saving plots is enabled, it constructs a filename based on a prefix and optional suffix and saves the plot as a PNG file.\"\"\"\n    if self.gyros is not None:\n      fig, ax = plt.subplots()\n      fig.suptitle(\"Gyros\")\n      ax.set_xlabel(\"Time (s)\")\n      ax.set_ylabel(\"Angular Velocity (rad/s)\")\n      for i in range(len(self.gyros)):\n        ax.plot(self.times, self.gyros[i, :, 0], color=\"red\", label=\"x\")\n        ax.plot(self.times, self.gyros[i, :, 1], color=\"green\", label=\"y\")\n        ax.plot(self.times, self.gyros[i, :,", "CodeBleu_score": 34.588416236608495}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    fig = plt.figure()\n    fig.suptitle(self.name)\n    ax = fig.add_subplot(111)\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    for accel in self.accelerations:\n        x_accel = accel[0]\n        y_accel = accel[1]\n        z_accel = accel[2]\n        ax.plot(x_accel, label='X')\n        ax.plot(y_accel, label='Y')\n        ax.plot(z_accel, label='Z')\n    ax.legend(loc='best')\n    if self.save_plots:\n        if plot_suffix is not None:\n            filename = self.name + '_' + plot_suffix + '.png'\n        else:\n            filename = self.name + '.png'\n        fig.savefig(filename)\n    plt.close()\n", "CodeBleu_score": 35.600460199574734}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    for i in range(len(pose_indeces)-1):\n      for j in range(i+1,len(pose_indeces)):\n        self.compare_two_xyz(pose_indeces[i],pose_indeces[j])\n\n  def compare_two_xyz(self,pose_index_1,pose_index_2):\n    \"\"\"This function, compare_two_xyz, compares two poses based on their indices.\\nIt requires two pose indices to perform comparisons.\\nIt compares the position of the first pose with the position of the second pose and prints the results.\"\"\"\n    if pose_index_1 in self.poses and pose_index_2 in self.poses:\n      pose_1 = self.poses[pose_index_1]\n      pose_2 = self.poses[pose_index_2]\n      print(\"Comparing poses %d and %d\" % (pose_index_1,pose_index_2))\n      print(\"Pose 1: %s\" % pose_1)\n      print(\"Pose 2: %s\" % pose_2)\n      print(\"Distance between poses: %f\" % self.get_distance_between_poses(pose_1,pose_2))\n    else:\n      print(\"Error: One or more of the provided pose indices do not exist.\")\n\n  def get_distance_between_poses(self,pose_1,pose_2):\n    \"\"\"This function, get_distance_between_poses, calculates the distance between two poses.\\nIt requires two poses to perform the calculation.\"\"\"\n    distance = math.sqrt(math.pow(pose_1.position.x-pose_2.position.x,2)+math.pow(pose_1.position.y-pose_2.position.y,2)+math.pow(pose_1.position.z-pose_2.position.z,2))\n    return distance\n\n  def get_distance_between_pose_and_origin(self,pose):\n    \"\"\"This function, get_distance_between_pose_and_origin, calculates the distance between a pose and the origin (0,0,0).\\nIt requires a pose to perform the calculation.\"\"\"\n    distance = math.sqrt(math.pow(pose.position.x,2)+math.pow(pose.position.y,2)+math.pow", "CodeBleu_score": 33.63974710534687}, {"code": "def compare_positions(self, pose_indeces)\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 25.750053436824683}, {"code": "def compare_positions(self, pose_indeces)\n    #Check if the pose indeces are valid\n    if len(pose_indeces) < 2:\n        raise Exception(\"At least two pose indeces must be provided to compare positions.\")\n    for pose_index in pose_indeces:\n        if pose_index not in self.pose_indeces:\n            raise Exception(\"Pose index %d is not valid.\" % pose_index)\n    #Compare the positions of each pose index with all subsequent pose indices\n    for pose_index in pose_indeces:\n        for pose_index2 in pose_indeces[pose_index+1:]:\n            self.compare_two_xyz(pose_index, pose_index2)\n", "CodeBleu_score": 40.56442867705612}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision", "CodeBleu_score": 35.050288826395146}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    if start_time == None:\n        start_time = 0\n    if end_time == None:\n        end_time = self.wrench[0].time\n    for i in self.wrench:\n        if i.time >= start_time and i.time <= end_time:\n            collision_times.append(i.time)\n    return collision_times\n\n", "CodeBleu_score": 38.81102794295379}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n      if time >= start_time and time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collisions_with_index(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collisions_with_index, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for index, time in enumerate(self.wrench):\n      if time >= start_time and time <= end_time:\n        collision_times.append((time, index))\n    return collision_times\n\n  def get_collision_times_at_time(self, time):\n    \"\"\"This function, get_collision_times_at_time, retrieves collision times at a specified time.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is equal to the specified time, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for time_ in self.wrench:\n      if time_ == time:\n        collision_times.append(time_)\n    return collision_times\n\n  def get_collision_times_at_index(self, index):\n    \"\"\"This function, get_collision_times_at_index, retrieves collision times at a specified index.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the index is equal to the specified index, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for index_, time_ in enumerate(self.wrench):\n      if index_ == index:\n        collision_times.append(time_)\n    return collision_times\n\n  def get_collision_times_at_index_and_time(self, index, time):\n    \"\"\"This function, get_collision_times_at", "CodeBleu_score": 36.78203122769378}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 28.605689571937422}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    settling_time_seconds = settling_time / 1000.0\n    start_time_seconds = start_time / 1000.0\n    end_time_seconds = end_time / 1000.0\n    start_time_seconds += settling_time_seconds\n    end_time_seconds += settling_time_seconds\n    analyze_bag.plot_angular_velocities(start_time_seconds, end_time_seconds,\n                                       settling_time_seconds, x_range,\n                                       plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 34.451564995764606}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    # Calculate the absolute settling time\n    settling_time = start_time + settling_time\n\n    # Plot angular velocities\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range,\n                                       plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 33.35316521715437}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (data == nullptr) {\n\t\treturn;\n\t}\n\n\t// Calculate multiplier based on camera parameters\n\tconst float multiplier = 1.0f / (static_cast<float>(width) * static_cast<float>(height));\n\n\t// Map to Eigen vector\n\tEigen::Map<Eigen::VectorXf> depth(data, width * height);\n\n\t// Calculate RMS noise\n\tconst float rmsNoise = GetNoise(width, height);\n\n\t// Calculate noise values\n\tconst float noise = rmsNoise * multiplier;\n\n\t// Add noise\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tif (depth(i) > 0) {\n\t\t\tdepth(i) += noise * static_cast<float>(rand()) / static_cast<float>(RAND_MAX);\n\t\t} else {\n\t\t\tdepth(i) = std::numeric_limits<float>::quiet_NaN();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.7435809698996}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (data == nullptr) {\n\t\treturn;\n\t}\n\n\tconst float multiplier = (float) (1.0 / (sqrt(2.0) * (float) noise_sigma));\n\tEigen::VectorXf vector(width * height);\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tvector(i) = (float) data[i];\n\t}\n\tvector = multiplier * vector;\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tfloat noise = (float) (rand() / (RAND_MAX + 1.0));\n\t\tif (vector(i) < (float) noise_min || vector(i) > (float) noise_max) {\n\t\t\tvector(i) = (float) noise_bad_point;\n\t\t} else {\n\t\t\tvector(i) += noise;\n\t\t}\n\t}\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tdata[i] = (float) (vector(i) * (1.0 / multiplier));\n\t}\n}\n", "CodeBleu_score": 45.80260162650849}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (data == nullptr) {\n\t\treturn;\n\t}\n\t// Calculate multiplier based on camera parameters\n\tdouble multiplier = 1.0;\n\tif (width > 0 && height > 0) {\n\t\tmultiplier = (double) (width * height) / (double) (this->width * this->height);\n\t}\n\t// Map data to Eigen vector\n\tEigen::Map<Eigen::VectorXf> eigenData(data, width * height);\n\t// Compute RMS noise\n\tdouble rmsNoise = sqrt(this->noiseVariance / multiplier);\n\t// Compute noise values\n\tEigen::VectorXf noiseValues = rmsNoise * Eigen::VectorXf::Random(width * height);\n\t// Add noise to data\n\teigenData = eigenData.array() + noiseValues.array();\n\t// Set bad points\n\teigenData = eigenData.array().max(this->badPointValue).min(this->goodPointValue);\n}\n", "CodeBleu_score": 40.17872225022513}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\t// Get the current simulation time\n\tdouble sim_time = world->GetSimTime().Double();\n\t// Convert the simulation time to ROS time\n\tros::Time ros_time = ros::Time::now() + ros::Duration(sim_time);\n\t// Write the trajectory message to the bag file\n\tbag.write(trajectory_topic, ros_time, *trajectory_msg);\n}\n", "CodeBleu_score": 44.66986041878577}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\t// Get current time\n\tros::Time time = ros::Time::now();\n\t// Convert to ROS time\n\ttime = ros::Time(time.sec, time.nsec);\n\t// Write to bag file\n\tbag.write(waypoint_topic, time, *trajectory_msg);\n}\n", "CodeBleu_score": 44.05533333412147}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\t// Convert trajectory message to ROS time\n\tros::Time ros_time = ros::Time::now();\n\tros_time += ros::Duration(trajectory_msg->header.stamp.sec, trajectory_msg->header.stamp.nanosec);\n\n\t// Write trajectory message to bag file\n\tbag.write(trajectory_msg->joint_names[0] + \"/trajectory\", ros_time, *trajectory_msg);\n}\n", "CodeBleu_score": 39.00878946321893}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\tfor (int i = 0; i < this->motor_joints.size(); i++) {\n\t\tdouble slowed_down_velocity = this->motor_joints[i]->GetVelocity(0) * this->slowdown_factor;\n\t\tthis->actuator_velocities.data[i] = slowed_down_velocity;\n\t}\n\tthis->actuator_velocities.header.stamp = ros_now;\n\tthis->bag_file.write(this->motor_topic, ros_now, this->actuator_velocities);\n}\n", "CodeBleu_score": 35.41994211913656}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\t// Convert simulation time to ROS time\n\tros::Time rosTime = ros::Time::now();\n\trosTime = rosTime + ros::Duration(now.sec, now.nsec);\n\n\t// Prepare message for actuator velocities\n\tgazebo_msgs::JointVelocity msg;\n\tmsg.header.stamp = rosTime;\n\tmsg.joint_names.resize(this->motorJoints.size());\n\tmsg.velocities.resize(this->motorJoints.size());\n\n\t// Iterate through motor joints\n\tfor (unsigned int i = 0; i < this->motorJoints.size(); i++) {\n\t\t// Get motor joint\n\t\tphysics::JointPtr motorJoint = this->motorJoints[i];\n\n\t\t// Get motor velocity\n\t\tdouble motorVelocity = motorJoint->GetVelocity(0);\n\n\t\t// Calculate slowed-down rotational velocity\n\t\tdouble slowedDownMotorVelocity = motorVelocity * this->slowDownRatio;\n\n\t\t// Assign slowed-down rotational velocity to message\n\t\tmsg.velocities[i] = slowedDownMotorVelocity;\n\t}\n\n\t// Write message to bag file\n\tthis->bag.write(this->motorTopic, rosTime, msg);\n}\n", "CodeBleu_score": 44.33715540779228}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\t// Convert the simulation time to ROS time.\n\tros::Time ros_now = ros::Time::now();\n\tros::Duration ros_dt = ros_now - ros_start;\n\tdouble ros_time = ros_dt.toSec();\n\n\t// Prepare the message.\n\tstd_msgs::Float64MultiArray msg;\n\tmsg.data.clear();\n\tmsg.header.stamp = ros::Time(ros_time);\n\n\t// Iterate through the motor joints.\n\tfor (unsigned int i = 0; i < motor_joints.size(); i++) {\n\t\t// Calculate the slowed-down rotational velocity.\n\t\tdouble slowed_down_velocity = motor_joints[i]->GetVelocity(0) * slow_down_factor;\n\n\t\t// Assign the slowed-down rotational velocity to the message.\n\t\tmsg.data.push_back(slowed_down_velocity);\n\t}\n\n\t// Write the data to the bag file.\n\tbag_file.write(motor_topic, ros_now, msg);\n}\n", "CodeBleu_score": 39.601733011925255}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#ifdef DEBUG_PRINTING\n  std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;", "CodeBleu_score": 3.369521781761695}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#ifdef DEBUG_PRINTING\n  ROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() was called\");", "CodeBleu_score": 3.0674060830062806}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#if GAZEBO_FW_DYNAMICS_DEBUG_PRINTING == 1\n  std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback: called.\"\n            << std::endl;", "CodeBleu_score": 4.171700322401259}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#if GAZEBO_MAJOR_VERSION >= 9\n  // Poll for new data\n  if (this->serialPort) {\n    this->serialPort->Poll();\n  }\n\n  // Poll for new data\n  if (this->udpPort) {\n    this->udpPort->Poll();\n  }", "CodeBleu_score": 2.647402408378106}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#if GAZEBO_MAJOR_VERSION >= 8\n  // Poll for messages in a timely manner\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for MAVLink messages\n  fd_set readFds;\n  FD_ZERO(&readFds);\n  FD_SET(_serialFd, &readFds);\n  int ret = select(_serialFd + 1, &readFds, NULL, NULL, &tv);\n  if (ret > 0) {\n    // Read from the serial port\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    int bytesRead = read(_serialFd, buffer, MAVLINK_MAX_PACKET_LEN);\n    if (bytesRead > 0) {\n      // Parse the received data\n      int bytesParsed = 0;\n      while (bytesParsed < bytesRead) {\n        // Parse the next MAVLink message\n        MavlinkParser::mavlink_message_t msg;\n        int result = mavlinkParser.parse(buffer + bytesParsed, bytesRead - bytesParsed, &msg);\n        if (result == MAVLINK_FRAMING_INCOMPLETE) {\n          // The message is not complete, so break out of the loop\n          break;\n        }\n        else if (result == MAVLINK_FRAMING_OK) {\n          // The message is complete, so process it\n          processMAVLinkMessage(msg);\n        }\n        else if (result == MAVLINK_FRAMING_BAD) {\n          // The message is bad, so print an error and break out of the loop\n          gzerr << \"Error parsing MAVLink message\\n\";\n          break;\n        }\n        else {\n          // The message is complete, but there was an error parsing it, so print an error and break out of the loop\n          gzerr << \"Error parsing MAVLink message\\n\";\n          break;\n        }\n        bytesParsed += result;\n      }\n    }\n  }", "CodeBleu_score": 49.24203744669576}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)\t// Convert timeout to timeval structure\n\tstruct timeval timeout;\n\ttimeout.tv_sec = _timeoutMs / 1000;\n\ttimeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n\t// Poll for MAVLink messages\n\tint ret = poll(fds, 2, _timeoutMs);\n\n\t// If data is available, read it and parse MAVLink messages\n\tif (ret > 0) {\n\t\t// Read from serial port\n\t\tssize_t bytesRead = read(serialFd, buffer, BUFFER_SIZE);\n\n\t\t// If data is available, parse MAVLink messages\n\t\tif (bytesRead > 0) {\n\t\t\tmavlink_message_t message;\n\t\t\tmavlink_status_t status;\n\t\t\tuint8_t msgReceived = 0;\n\n\t\t\t// Parse MAVLink messages\n\t\t\tfor (ssize_t i = 0; i < bytesRead; i++) {\n\t\t\t\tif (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &message,\n\t\t\t\t\t\t&status)) {\n\t\t\t\t\tmsgReceived = 1;\n\t\t\t\t\t// Forward message to serial connection\n\t\t\t\t\tif (serialFd!= -1) {\n\t\t\t\t\t\twrite(serialFd, buffer + i, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle message\n\t\t\t\t\tswitch (message.msgid) {\n\t\t\t\t\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\t\t\t\t\t// Handle heartbeat message\n\t\t\t\t\t\thandleHeartbeatMessage(message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAVLINK_MSG_ID_PARAM_REQUEST_LIST:\n\t\t\t\t\t\t// Handle parameter request list message\n\t\t\t\t\t\thandleParameterRequestListMessage(message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAVLINK_MSG_ID_PARAM_REQUEST_READ:\n\t\t\t\t\t\t// Handle parameter request read message\n\t\t\t\t\t\thandleParameterRequestReadMessage(message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAVLINK_MSG_ID_PARAM_SET:\n\t\t\t\t\t\t// Handle parameter set message\n\t\t\t\t\t\thandleParameterSetMessage(message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAVLINK_MSG_ID_MISSION_REQUEST_LIST:\n\t\t\t\t\t\t// Handle mission request list message\n\t\t\t\t\t\thandleMissionRequestListMessage(message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAVLINK_MSG_ID_MISSION_REQUEST:\n\t\t\t\t\t\t", "CodeBleu_score": 43.25423176062767}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() \tstd::lock_guard<std::mutex> lock(mutex);\n\tif (isOpen) {\n\t\tmavlink_interface->stop();\n\t\tmavlink_interface->close();\n\t\tif (mavlink_interface->is_joinable()) {\n\t\t\tmavlink_interface->join();\n\t\t}\n\t\tmavlink_interface->reset();\n\t\tisOpen = false;\n\t}\n}\n", "CodeBleu_score": 48.6255217862157}, {"code": "void GazeboMavlinkInterface::close() \tstd::unique_lock<std::mutex> lock(mutex_);\n\tif(is_open_) {\n\t\tis_open_ = false;\n\t\tio_service_.stop();\n\t\tserial_port_.close();\n\t\tif(io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 55.5185975669124}, {"code": "void GazeboMavlinkInterface::close() \t// lock mutex\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// check if interface is open\n\tif (isOpen) {\n\t\t// stop I/O service\n\t\tio_service.stop();\n\n\t\t// close serial device\n\t\tserial_port.close();\n\n\t\t// if I/O thread is joinable, join it\n\t\tif (io_thread.joinable()) {\n\t\t\tio_thread.join();\n\t\t}\n\n\t\tisOpen = false;\n\t}\n}\n", "CodeBleu_score": 54.90448554087401}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\t(wind_points[1].x - wind_points[0].x) / 2.0,\n\t(wind_points[1].y - wind_points[0].y) / 2.0,\n\t(wind_points[1].z - wind_points[0].z) / 2.0\n};\n", "CodeBleu_score": 27.761379329199787}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\t(this->wind_position_1 - this->wind_position_2) * this->wind_interpolation_factor + this->wind_position_2\n};\n", "CodeBleu_score": 6.617869404796436}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\t(windPoint1.Position() - windPoint2.Position()) * (windPoint1.Position() - position) / (windPoint1.Position() - windPoint2.Position()).LengthSquared() + windPoint2.Position()\n};\n", "CodeBleu_score": 19.28436816028693}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)\tif (_time < 0) {\n\t\t_time = 0;\n\t}\n\tif (_time > _length) {\n\t\t_time = _length;\n\t}\n\tif (_looping) {\n\t\t_time = fmod(_time, _length);\n\t}\n\telse {\n\t\t_time = std::min(_time, _length);\n\t}\n\tif (_time!= _timePosition) {\n\t\t_timePosition = _time;\n\t\t_update = true;\n\t}\n}\n", "CodeBleu_score": 34.721054231243755}, {"code": "void Animation::SetTime(double _time)\tif (time!= _time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\ttime = fmod(time, length);\n\t\t} else {\n\t\t\ttime = fmin(fmax(0.0, time), length);\n\t\t}\n\t\tUpdate();\n\t}\n}\n", "CodeBleu_score": 30.74744854056114}, {"code": "void Animation::SetTime(double _time)\tif (time!= _time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\ttime = fmod(time, length);\n\t\t} else {\n\t\t\ttime = fmin(fmax(0, time), length);\n\t\t}\n\t\tUpdate();\n\t}\n}\n", "CodeBleu_score": 30.694299177561703}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n    print(\"Hovering...\")\n    self.vehicle.mode = VehicleMode(\"STABILIZE\")\n    self.vehicle.armed = True\n    self.vehicle.commands.clear()\n    self.vehicle.commands.add(\n        self.vehicle.commands.next,\n        self.vehicle.location.global_relative_frame,\n        is_relative=True,\n        autocontinue=True,\n        frame=Vehicle.FRAME_GLOBAL_RELATIVE_ALT_INT,\n        type=Vehicle.CMD_DO_CHANGE_SPEED,\n        speed=0,\n        break_alt=0,\n        break_alt_min=0,\n        break_alt_max=0,\n        break_dist=0,\n        break_speed=0,\n        break_speed_min=0,\n        break_speed_max=0,\n        break_time=0,\n        break_time_min=0,\n        break_time_max=0,\n        break_yaw=0,\n        break_yaw_min=0,\n        break_yaw_max=0,\n        break_z=0,\n        break_z_min=0,\n        break_z_max=0,\n        break_xtrack=0,\n        break_xtrack_min=0,\n        break_xtrack_max=0,\n        break_ytrack=0,\n        break_ytrack_min=0,\n        break_ytrack_max=0,\n        break_yaw_rate=0,\n        break_yaw_rate_min=0,\n        break_yaw_rate_max=0,\n        break_z_rate=0,\n        break_z_rate_min=0,\n        break_z_rate_max=0,\n        break_xtrack_rate=0,\n        break_xtrack_rate_min=0,\n        break_xtrack_rate_max=0,\n        break_ytrack_rate=0,\n        break_ytrack_rate_min=0,\n        break_ytrack_rate_max=0,\n        break_z_track=0,\n        break_z_track_min=0,\n        break_z_track_max=0,\n        break_xtrack_track=0,\n        break_xtrack_track_min=0,\n        break_xtrack_track_max=0,\n        break_ytrack_track=0,\n       ", "CodeBleu_score": 17.18552200643001}, {"code": "def hover(self)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"HOLD\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"LOITER\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"HOLD\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"LOITER\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"HOLD\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"LOITER\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"HOLD\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"LOITER\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"HOLD\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"LOITER\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode(\"HOLD\")\n    self.vehicle.armed = False\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.mode", "CodeBleu_score": 17.65199501025259}, {"code": "def hover(self)\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.set_target_motion(self.get_position(), self.get_yaw())\n    print(\"Vehicle type: %s\" % self.get_type())\n    print(\"Vehicle ID: %s\" % self.get_id())\n    print(\"Flight mode: %s\" % self.get_flight_mode())\n", "CodeBleu_score": 21.914884895398007}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n      self.hover_flag = 1\n      self.hover()\n      return True\n    else:\n      try:\n        self.flightModeService(self.flight_mode)\n        return True\n      except:\n        print(\"Mode switch failed.\")\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the vehicle to hover mode.\\nIt is called when the hover flag is set to 1.\\nIt prints a success message if the hover is successful, and a failure message otherwise.\\nThe function returns True if the hover succeeds, and False if it fails.\"\"\"\n    try:\n      self.vehicle.mode = VehicleMode(\"HOVER\")\n      return True\n    except:\n      print(\"Hover failed.\")\n      return False\n\n  def land(self):\n    \"\"\"This function, land, attempts to land the vehicle.\\nIt prints a success message if the land is successful, and a failure message otherwise.\\nThe function returns True if the land succeeds, and False if it fails.\"\"\"\n    try:\n      self.vehicle.mode = VehicleMode(\"LAND\")\n      return True\n    except:\n      print(\"Land failed.\")\n      return False\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, attempts to takeoff the vehicle.\\nIt prints a success message if the takeoff is successful, and a failure message otherwise.\\nThe function returns True if the takeoff succeeds, and False if it fails.\"\"\"\n    try:\n      self.vehicle.mode = VehicleMode(\"GUIDED\")\n      return True\n    except:\n      print(\"Takeoff failed.\")\n      return False\n\n  def arm(self):\n    \"\"\"This function, arm, attempts to arm the vehicle.\\nIt prints a success message if the arm is successful, and a failure message otherwise.\\nThe function returns True if the arm succeeds, and False if it fails.\"\"\"\n    try:\n      self.vehicle.armed = True\n      return True\n    except:\n      print(\"Arm failed.\")\n      return False\n\n  def disarm(self):\n    \"\"\"This function, disarm, attempts to disarm the vehicle.\\nIt prints a success message if the disarm is successful, and a failure message otherwise.\\nThe function returns True if the disarm succeeds, and False if it fails.\"\"\"\n    try:\n      self.vehicle.armed = False\n      return True\n    except:\n      print(\"Disarm failed.\")\n      return False\n\n  def set_heading(self, heading):", "CodeBleu_score": 33.920360789132886}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      try:\n        self.flightModeService(self.flight_mode)\n        return True\n      except:\n        print(\"Mode switch failed\")\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, attempts to hover the vehicle using the hover service.\\nIt prints a success message if the hover succeeds, and a failure message otherwise.\\nThe function returns True if the hover succeeds, and False if it fails.\"\"\"\n    try:\n      self.hoverService()\n      return True\n    except:\n      print(\"Hover failed\")\n      return False\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, attempts to take off the vehicle using the takeoff service.\\nIt prints a success message if the takeoff succeeds, and a failure message otherwise.\\nThe function returns True if the takeoff succeeds, and False if it fails.\"\"\"\n    try:\n      self.takeoffService()\n      return True\n    except:\n      print(\"Takeoff failed\")\n      return False\n\n  def land(self):\n    \"\"\"This function, land, attempts to land the vehicle using the land service.\\nIt prints a success message if the land succeeds, and a failure message otherwise.\\nThe function returns True if the land succeeds, and False if it fails.\"\"\"\n    try:\n      self.landService()\n      return True\n    except:\n      print(\"Land failed\")\n      return False\n\n  def move_to_position(self, x, y, z, yaw=0.0):\n    \"\"\"This function, move_to_position, attempts to move the vehicle to a position using the move_to_position service.\\nIt prints a success message if the move succeeds, and a failure message otherwise.\\nThe function returns True if the move succeeds, and False if it fails.\"\"\"\n    try:\n      self.move_to_position_service(x, y, z, yaw)\n      return True\n    except:\n      print(\"Move failed\")\n      return False\n\n  def stop(self):\n    \"\"\"This function, stop, stops the vehicle using the stop service.\\nIt prints a success message if the stop succeeds, and a failure message otherwise.\\nThe function returns True if the stop succeeds, and False if it fails.\"\"\"\n    try:\n      self.stopService()\n      return True\n    except:\n      print(\"Stop failed\")\n      return False\n\n  def emergency(self):\n    \"\"\"This function", "CodeBleu_score": 38.55241749566003}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n      self.hover_flag = 1\n      self.hover()\n      return True\n    else:\n      try:\n        self.flightModeService(self.flight_mode)\n        print(\"Mode switch successful.\")\n        return True\n      except:\n        print(\"Mode switch failed.\")\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the vehicle's hover flag to 1 and sets the vehicle's flight mode to HOVER.\"\"\"\n    self.hover_flag = 1\n    self.flight_mode = \"HOVER\"\n\n  def land(self):\n    \"\"\"This function, land, sets the vehicle's hover flag to 0 and sets the vehicle's flight mode to LAND.\"\"\"\n    self.hover_flag = 0\n    self.flight_mode = \"LAND\"\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, sets the vehicle's hover flag to 0 and sets the vehicle's flight mode to TAKEOFF.\"\"\"\n    self.hover_flag = 0\n    self.flight_mode = \"TAKEOFF\"\n\n  def get_flight_mode(self):\n    \"\"\"This function, get_flight_mode, returns the vehicle's flight mode.\"\"\"\n    return self.flight_mode\n\n  def get_hover_flag(self):\n    \"\"\"This function, get_hover_flag, returns the vehicle's hover flag.\"\"\"\n    return self.hover_flag\n\n  def get_position(self):\n    \"\"\"This function, get_position, returns the vehicle's current position.\"\"\"\n    return self.vehicle.location.global_relative_frame\n\n  def get_heading(self):\n    \"\"\"This function, get_heading, returns the vehicle's current heading.\"\"\"\n    return self.vehicle.heading\n\n  def get_velocity(self):\n    \"\"\"This function, get_velocity, returns the vehicle's current velocity.\"\"\"\n    return self.vehicle.velocity\n\n  def get_altitude(self):\n    \"\"\"This function, get_altitude, returns the vehicle's current altitude.\"\"\"\n    return self.vehicle.location.global_relative_frame.alt\n\n  def get_speed(self):\n    \"\"\"This function, get_speed, returns the vehicle's current speed.\"\"\"\n    return self.vehicle.groundspeed\n\n  def get_airspeed(self):\n    \"\"\"This function, get_airspeed, returns the vehicle's current airspeed.\"\"\"\n    return self.vehicle.airspeed\n\n  def get", "CodeBleu_score": 34.260464200966666}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.angular.z, 1)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 1)\n    else:\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.angular.z]\n", "CodeBleu_score": 34.834613008435475}, {"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z]\n", "CodeBleu_score": 60.37695104251931}, {"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.angular.z, 1, 'enu')\n    if self.hover_flag == False and self.hold_flag == False:\n      self.hold_state_transition(msg.linear.x, msg.angular.z, 1, 'enu')\n    elif self.hover_flag == True and self.hold_flag == False:\n      self.hold_state_transition(msg.linear.x, msg.angular.z, 1, 'enu')\n    else:\n      self.coordinate_frame = 1\n      self.motion_type = 1\n      self.target_motion = [msg.linear.x, msg.angular.z]\n", "CodeBleu_score": 52.99247794593895}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n        hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n        self.hover_flag = hover_flag\n        self.send_hover_action()\n    elif (hover_flag == 1 and self.flight_mode == \"HOVER\"):\n        hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n        self.hover_flag = hover_flag\n        self.send_hover_action()\n    elif (hover_flag == 0 and self.flight_mode == \"HOVER\"):\n        hover_flag = 1\n        self.flight_mode = \"HOVER\"\n        self.hover_flag = hover_flag\n        self.send_hover_action()\n", "CodeBleu_score": 41.41302531552961}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n        hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n    else:\n        if (hover_flag == 0):\n            hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n", "CodeBleu_score": 42.66671188925897}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.hover_flag == 0:\n      if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n    elif self.hover_flag == 1:\n      if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        self.offboard_mode()\n\n  def hover(self):\n    \"\"\"This function, hover, initiates a hover action.\"\"\"\n    self.arm()\n    self.set_position(0, 0, 0, 0)\n\n  def offboard_mode(self):\n    \"\"\"This function, offboard_mode, sets the drone's flight mode to 'OFFBOARD'.\"\"\"\n    self.arm()\n    self.flight_mode = 'OFFBOARD'\n    self.set_mode(0)\n\n  def offboard_mode_transition(self, x, y, z, w):\n    \"\"\"This function, offboard_mode_transition, transitions the drone's flight mode based on positional and rotational thresholds.\\nIf any of the x, y, z values exceed 0.02 or w exceeds 0.005, it sets offboard_flag to 0 and changes the flight mode to 'OFFBOARD'.\\nIf the flight mode is not \"OFFBOARD\" and the conditions are met, it sets offboard_flag to 1, changes the flight mode to 'HOVER', and initiates the hover action.\"\"\"\n    if self.offboard_flag == 0:\n      if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.offboard_flag = 1\n        self.flight_mode = 'OFFBOARD'\n        self.offboard_mode()\n    elif self.offboard_flag == 1:\n      if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n        self.offboard_flag = ", "CodeBleu_score": 43.7253204724391}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return math.radians(q.yaw)\n    else:\n        return math.radians(Quaternion(q[0], q[1], q[2], q[3]).yaw)\n", "CodeBleu_score": 21.241077231442272}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n", "CodeBleu_score": 19.528210155997467}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n", "CodeBleu_score": 19.528210155997467}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.airspeed = 0\n    self.vehicle.groundspeed = 0\n    self.vehicle.airspeed_mode = AirspeedMode(\"VELOCITY\")\n    self.vehicle.groundspeed_mode = GroundspeedMode(\"VELOCITY\")\n    self.vehicle.target_system = self.vehicle.system_status.system_id\n    self.vehicle.target_component = self.vehicle.system_status.component_id\n    self.vehicle.target_location = LocationGlobalRelative(self.vehicle.location.global_frame.lat, self.vehicle.location.global_frame.lon, self.vehicle.location.global_frame.alt)\n    self.vehicle.target_location.lat_deg = self.vehicle.location.global_frame.lat\n    self.vehicle.target_location.lon_deg = self.vehicle.location.global_frame.lon\n    self.vehicle.target_location.alt = self.vehicle.location.global_frame.alt\n    self.vehicle.target_location.type_mask = 0b0000111111000111\n    self.vehicle.target_location.yaw = self.vehicle.attitude.yaw\n    self.vehicle.target_location.yaw_rate = 0\n    self.vehicle.target_location.vx = 0\n    self.vehicle.target_location.vy = 0\n    self.vehicle.target_location.vz = 0\n    self.vehicle.target_location.vx_valid = 0\n    self.vehicle.target_location.vy_valid = 0\n    self.vehicle.target_location.vz_valid = 0\n    self.vehicle.target_location.valid_flags = 0b0000000000000000\n    self.vehicle.target_location.frame = MAV_FRAME_GLOBAL_RELATIVE_ALT\n    self.vehicle.target_location.type_mask = 0b0000111111000111\n    self.vehicle.target_location.x = self.vehicle.location.global_frame.lat\n    self.vehicle.target_location.y = self.vehicle.location.global_frame.lon\n    self.vehicle", "CodeBleu_score": 27.319512662701012}, {"code": "def hover(self)\n    # Set the vehicle to hover mode\n    self.vehicle.mode = VehicleMode(\"HOLD\")\n    # Set the coordinate frame\n    self.vehicle.parameters[\"FRAME\"] = 0\n    # Set the motion type\n    self.vehicle.parameters[\"MOTION_TYPE\"] = 0\n    # Construct the target motion\n    target_motion = Motion(\n        position=self.vehicle.location.position,\n        yaw=self.vehicle.heading,\n        velocity=np.array([0.0, 0.0, 0.0]),\n        acceleration=np.array([0.0, 0.0, 0.0]),\n        time_from_start=0.0,\n    )\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\n        \"Vehicle type: \"\n        + self.vehicle.type\n        + \", vehicle ID: \"\n        + str(self.vehicle.id)\n        + \", flight mode: \"\n        + self.vehicle.mode.name\n    )\n    # Return the target motion\n    return target_motion\n\n", "CodeBleu_score": 38.14204016668887}, {"code": "def hover(self)\n    print(\"Hovering...\")\n    self.set_attitude(attitude=Vehicle.Attitude(roll=0, pitch=0, yaw=self.yaw, thrust=0.5),\n                       frame=Vehicle.FRAME_BODY,\n                       duration=10)\n    print(\"Vehicle type: %s, ID: %s, Flight mode: %s\" % (self.vehicle_type, self.id, self.mode))\n\n", "CodeBleu_score": 22.428069111035217}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    elif self.flight_mode == 'GUIDED':\n      self.flight_mode = 'STABILIZE'\n      self.vehicle.mode = VehicleMode(\"STABILIZE\")\n      return True\n    elif self.flight_mode == 'STABILIZE':\n      self.flight_mode = 'GUIDED'\n      self.vehicle.mode = VehicleMode(\"GUIDED\")\n      return True\n    else:\n      print(\"Unknown flight mode: \" + self.flight_mode)\n      return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the vehicle to hover mode.\\nIt sets the hover flag to True and sets the altitude to 1000 meters.\\nIt then calls the set_altitude method.\"\"\"\n    self.hover_flag = True\n    self.altitude = 1000\n    self.set_altitude()\n\n  def set_altitude(self):\n    \"\"\"This function, set_altitude, sets the altitude of the vehicle.\\nIt first checks if the hover flag is True.\\nIf it is, it sets the altitude to 1000 meters.\\nOtherwise, it sets the altitude to the value of the altitude attribute.\\nIt then calls the set_position method.\"\"\"\n    if self.hover_flag:\n      self.vehicle.simple_takeoff(1000)\n    else:\n      self.vehicle.simple_takeoff(self.altitude)\n    self.set_position()\n\n  def set_position(self):\n    \"\"\"This function, set_position, sets the position of the vehicle.\\nIt first checks if the hover flag is True.\\nIf it is, it sets the position to the home location of the vehicle.\\nOtherwise, it sets the position to the value of the position attribute.\\nIt then calls the set_velocity method.\"\"\"\n    if self.hover_flag:\n      self.vehicle.simple_goto(self.home_location)\n    else:\n      self.vehicle.simple_goto(self.position)\n    self.set_velocity()\n\n  def set_velocity(self):\n    \"\"\"This function, set_velocity, sets the velocity of the vehicle.\\nIt first checks if the hover flag is True.\\nIf it is, it sets the velocity to 0.\\nOtherwise, it sets the velocity to the", "CodeBleu_score": 38.58660593455398}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover_flag = True\n      self.hover()\n      print('Flight mode set to HOVER')\n      return True\n    else:\n      try:\n        self.flightModeService(self.flight_mode)\n        print('Flight mode set to'+ self.flight_mode)\n        return True\n      except rospy.ServiceException as e:\n        print(\"Service call failed: %s\" % e)\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the hover flag and sets the vehicle's flight mode to HOVER.\\nIf successful, it prints a success message and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    if self.hover_flag:\n      self.hover_flag = False\n      self.flight_mode = 'HOVER'\n      print('Hover flag set to False')\n      return True\n    else:\n      print('Hover flag already set to False')\n      return False\n\n  def get_flight_mode(self):\n    \"\"\"This function, get_flight_mode, returns the current flight mode of the vehicle.\"\"\"\n    return self.flight_mode\n\n  def get_position(self):\n    \"\"\"This function, get_position, returns the current position of the vehicle.\"\"\"\n    return self.position\n\n  def get_velocity(self):\n    \"\"\"This function, get_velocity, returns the current velocity of the vehicle.\"\"\"\n    return self.velocity\n\n  def get_attitude(self):\n    \"\"\"This function, get_attitude, returns the current attitude of the vehicle.\"\"\"\n    return self.attitude\n\n  def get_heading(self):\n    \"\"\"This function, get_heading, returns the current heading of the vehicle.\"\"\"\n    return self.heading\n\n  def get_battery_voltage(self):\n    \"\"\"This function, get_battery_voltage, returns the current battery voltage of the vehicle.\"\"\"\n    return self.battery_voltage\n\n  def get_battery_current(self):\n    \"\"\"This function, get_battery_current, returns the current battery current of the vehicle.\"\"\"\n    return self.battery_current\n\n  def get_battery_state(self):\n    \"\"\"This function, get_battery_state, returns the current battery state of the vehicle.\"\"\"\n    return self.battery_state\n\n  def get_battery_remaining(self):\n    \"\"\"This function, get_battery_remaining, returns the current battery remaining of the vehicle.\"\"\"\n   ", "CodeBleu_score": 30.38771540817997}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover_flag = True\n      self.hover()\n      print('Switched flight mode to HOVER')\n      return True\n    else:\n      self.flightModeService(self.flight_mode)\n      print('Switched flight mode to'+ self.flight_mode)\n      return True\n\n  def hover(self):\n    \"\"\"This function, hover, sets the vehicle to hover mode.\\nIt uses the setPosition method to set the vehicle's position to the current position, and then sets the vehicle's velocity to 0.\\nIt also sets the vehicle's yaw to 0 and sets the vehicle's yaw mode to 'OFF'.\"\"\"\n    self.setPosition(self.current_position)\n    self.setVelocity(0,0,0)\n    self.setYaw(0)\n    self.setYawMode('OFF')\n\n  def set_position(self, position):\n    \"\"\"This function, set_position, sets the vehicle's position to the given position.\\nIt uses the setPosition method to set the vehicle's position to the given position, and then sets the vehicle's velocity to 0.\\nIt also sets the vehicle's yaw to 0 and sets the vehicle's yaw mode to 'OFF'.\"\"\"\n    self.setPosition(position)\n    self.setVelocity(0,0,0)\n    self.setYaw(0)\n    self.setYawMode('OFF')\n\n  def set_velocity(self, velocity):\n    \"\"\"This function, set_velocity, sets the vehicle's velocity to the given velocity.\\nIt uses the setVelocity method to set the vehicle's velocity to the given velocity, and then sets the vehicle's yaw to 0 and sets the vehicle's yaw mode to 'OFF'.\"\"\"\n    self.setVelocity(velocity[0],velocity[1],velocity[2])\n    self.setYaw(0)\n    self.setYawMode('OFF')\n\n  def set_yaw(self, yaw):\n    \"\"\"This function, set_yaw, sets the vehicle's yaw to the given yaw.\\nIt uses the setYaw method to set the vehicle's yaw to the given yaw, and then sets the vehicle's yaw mode to 'OFF'.\"\"\"\n    self.setYaw(yaw)\n    self.setYawMode('OFF')\n\n  def set_yaw_mode(self, yaw_mode):\n    \"\"\"This function,", "CodeBleu_score": 27.753759558650597}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualize:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward by calling the get_reward function for each play in the play list.\"\"\"\n    total_reward = 0\n    for play in self.play:\n      total_reward += self.get_reward(play)\n    return total_reward\n\n  def get_reward(self, play):\n    \"\"\"This function, get_reward, calculates the reward for a given play.\\nIt calls the get_reward_per_play function for the given play.\"\"\"\n    return self.get_reward_per_play(play)\n\n  def get_reward_per_play(self, play):\n    \"\"\"This function, get_reward_per_play, calculates the reward for a given play.\\nIt calls the get_reward_per_assignment function for the given play.\"\"\"\n    return self.get_reward_per_assignment(play)\n\n  def get_reward_per_assignment(self, play):\n    \"\"\"This function, get_reward_per_assignment, calculates the reward for a given play.\\nIt calls the get_reward_per_algorithm function for the given play.\"\"\"\n    return self.get_reward_per_algorithm(play)\n\n  def get_reward_per_algorithm(self, play):\n    \"\"\"This function, get_reward_per_algorithm, calculates the reward for a given play.\\nIt calls the get_reward_per_rond function for the given play.\"\"\"\n    return self.get_reward_per_rond(play)\n\n  def get_reward_per_rond(self, play):\n    \"\"\"This function, get_reward_per_rond, calculates the reward for a given play.\\nIt calls the get_reward_per_play function for the given play.\"\"\"\n    return self.get_reward_per_play(play)\n\n  def get_reward_per_play(self, play):\n    \"\"\"This function, get_reward_per_play, calculates the reward for a given play.\\nIt calls the get_reward_per_assignment function for the given play.\"\"\"\n    return self.get_reward", "CodeBleu_score": 40.20471780225521}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward of the current assignment, algorithm, play, and rond.\"\"\"\n    total_reward = 0\n    for i in range(len(self.assignment)):\n      total_reward += self.assignment[i] * self.play[i]\n    return total_reward\n\n  def visualize(self):\n    \"\"\"This function, visualize, plots the assignment, algorithm, play, and rond.\"\"\"\n    plt.plot(self.rond, self.assignment)\n    plt.plot(self.rond, self.algorithm)\n    plt.plot(self.rond, self.play)\n    plt.legend(['assignment', 'algorithm', 'play'])\n    plt.show()", "CodeBleu_score": 50.07035413098281}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward for the current assignment, algorithm, play, and rond.\\nIt returns the total reward.\"\"\"\n    total_reward = 0\n    for i in range(len(self.assignment)):\n      total_reward += self.assignment[i] * self.play[i] * self.rond[i]\n    return total_reward\n\n  def visualize(self):\n    \"\"\"This function, visualize, plots the current assignment, algorithm, play, and rond.\"\"\"\n    plt.plot(self.rond, self.play, label = \"Play\")\n    plt.plot(self.rond, self.rond, label = \"Rond\")\n    plt.plot(self.rond, self.assignment, label = \"Assignment\")\n    plt.plot(self.rond, self.assignment * self.play * self.rond, label = \"Total Reward\")\n    plt.xlabel(\"Rond\")\n    plt.ylabel(\"Value\")\n    plt.title(\"Assignment, Play, Rond, and Total Reward\")\n    plt.legend()\n    plt.show()\n", "CodeBleu_score": 48.92251584111068}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n    if msg.index == self.uav_id:\n      self.local_pose = msg.pose\n      self.local_pose_updated = True\n      self.local_pose_index = i\n      self.local_pose_time = msg.header.stamp\n      # Update the takeoff_target_pose and hover_target_pose based on the GCS command\n      if self.gcs_command == \"takeoff\":\n        self.takeoff_target_pose = self.local_pose\n      elif self.gcs_command == \"hover\":\n        self.hover_target_pose = self.local_pose\n      # Update the global_pose by applying a bias to the local_pose\n      self.global_pose = self.local_pose\n      self.global_pose.position.x += self.global_pose_bias.x\n      self.global_pose.position.y += self.global_pose_bias.y\n      self.global_pose.position.z += self.global_pose_bias.z\n      self.global_pose_updated = True\n      self.global_pose_index = i\n      self.global_pose_time = msg.header.stamp\n\n  def local_pose_callback_no_bias(self, msg, i):\n    \"\"\"This function, local_pose_callback_no_bias, updates the UAV's local and global pose based on incoming messages.\\nIf the message index matches the UAV ID, it sets the local_pose to the message.\\nDepending on the ground control station (GCS) command, it updates the takeoff_target_pose and hover_target_pose.\\nIt also updates the global_pose for the UAV, without applying a bias to the position coordinates.\"\"\"\n    if msg.index == self.uav_id:\n      self.local_pose = msg.pose\n      self.local_pose_updated = True\n      self.local_pose_index = i\n      self.local_pose_time = msg.header.stamp\n      # Update the takeoff_target_pose and hover_target_pose based on the GCS command\n      if self.gcs_command == \"takeoff\":\n        self.takeoff_target_pose = self.local_pose\n      elif self.gcs_command == \"hover\":\n        self.hover_target_pose = self.local_pose\n      # Update the", "CodeBleu_score": 21.386562330110703}, {"code": "def local_pose_callback(self, msg, i)\n    # If the message index matches the UAV ID, update the local_pose\n    if msg.uav_id == self.uav_id:\n        self.local_pose = msg.pose\n        # Update the takeoff_target_pose and hover_target_pose\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = self.local_pose\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = self.local_pose\n        # Update the global_pose for the UAV\n        self.global_pose = self.local_pose + self.bias\n        # Update the local_pose_pub\n        self.local_pose_pub.publish(self.local_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the takeoff_target_pose_pub\n        self.takeoff_target_pose_pub.publish(self.takeoff_target_pose)\n        # Update the hover_target_pose_pub\n        self.hover_target_pose_pub.publish(self.hover_target_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish(self.global_pose)\n        # Update the global_pose_pub\n        self.global_pose_pub.publish", "CodeBleu_score": 18.028812583698706}, {"code": "def local_pose_callback(self, msg, i)\n    # If the message index matches the UAV ID\n    if msg.header.seq == self.uav_id:\n      # Set the local pose\n      self.local_pose = msg\n      # If the GCS command is to take off\n      if self.gcs_command == \"takeoff\":\n        # Set the takeoff target pose\n        self.takeoff_target_pose = msg\n      # If the GCS command is to hover\n      if self.gcs_command == \"hover\":\n        # Set the hover target pose\n        self.hover_target_pose = msg\n    # If the message index matches the UAV ID\n    if msg.header.seq == self.uav_id:\n      # Set the global pose\n      self.global_pose = msg\n    # If the message index matches the UAV ID\n    if msg.header.seq == self.uav_id:\n      # Set the local pose\n      self.local_pose = msg\n      # If the GCS command is to take off\n      if self.gcs_command == \"takeoff\":\n        # Set the takeoff target pose\n        self.takeoff_target_pose = msg\n      # If the GCS command is to hover\n      if self.gcs_command == \"hover\":\n        # Set the hover target pose\n        self.hover_target_pose = msg\n    # If the message index matches the UAV ID\n    if msg.header.seq == self.uav_id:\n      # Set the global pose\n      self.global_pose = msg\n    # If the message index matches the UAV ID\n    if msg.header.seq == self.uav_id:\n      # Set the local pose\n      self.local_pose = msg\n      # If the GCS command is to take off\n      if self.gcs_command == \"takeoff\":\n        # Set the takeoff target pose\n        self.takeoff_target_pose = msg\n      # If the GCS command is to hover\n      if self.gcs_command == \"hover\":\n        # Set the hover target pose\n        self.hover_target_pose = msg\n    # If the message index matches the UAV ID\n    if msg.header.seq == self.uav_id:\n      # Set the global pose\n      self.global_pose = msg\n    # If the message index matches the UAV ID\n    if msg.header.seq == self.uav_id:", "CodeBleu_score": 19.358647230673387}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == \"armed\":\n      return True\n    else:\n      return False\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, sends the takeoff command to the UAV.\"\"\"\n    self.send_mavlink(msg=self.takeoff_msg)\n\n  def land(self):\n    \"\"\"This function, land, sends the land command to the UAV.\"\"\"\n    self.send_mavlink(msg=self.land_msg)\n\n  def arm(self):\n    \"\"\"This function, arm, sends the arm command to the UAV.\"\"\"\n    self.send_mavlink(msg=self.arm_msg)\n\n  def disarm(self):\n    \"\"\"This function, disarm, sends the disarm command to the UAV.\"\"\"\n    self.send_mavlink(msg=self.disarm_msg)\n\n  def send_mavlink(self, msg):\n    \"\"\"This function, send_mavlink, sends a mavlink message to the UAV.\"\"\"\n    self.mav.mav.send(msg)\n\n  def send_mavlink_msg(self, msg):\n    \"\"\"This function, send_mavlink_msg, sends a mavlink message to the UAV.\"\"\"\n    self.mav.mav.send(msg)\n\n  def send_mavlink_msg_multi(self, msg):\n    \"\"\"This function, send_mavlink_msg_multi, sends multiple mavlink messages to the UAV.\"\"\"\n    for m in msg:\n      self.mav.mav.send(m)\n\n  def send_mavlink_msg_multi_wait(self, msg):\n    \"\"\"This function, send_mavlink_msg_multi_wait, sends multiple mavlink messages to the UAV and waits for the response.\"\"\"\n    for m in msg:\n      self.mav.mav.send(m)\n      self.mav.mav.wait_heartbeat()\n\n  def send_mavlink_msg_multi_wait_result(self, msg):\n    \"\"\"This function, send_mavlink_msg_multi_wait_result, sends multiple mavlink messages to the UAV and waits for the response and returns the result.\"\"\"\n    result = []\n    for m in msg:\n      self.mav.mav.send(m)\n      self.mav.mav.wait_heartbeat()\n      result.append(self.mav.", "CodeBleu_score": 49.48987548311986}, {"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == 'armed':\n      return True\n    else:\n      return False\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, takes the UAV off the ground.\"\"\"\n    self.takeoff_cmd = self.mavros.set_mode(custom_mode=\"AUTO.TAKEOFF\")\n    return self.takeoff_cmd\n\n  def land(self):\n    \"\"\"This function, land, lands the UAV.\"\"\"\n    self.land_cmd = self.mavros.set_mode(custom_mode=\"AUTO.LAND\")\n    return self.land_cmd\n\n  def arming(self):\n    \"\"\"This function, arming, arms the UAV.\"\"\"\n    self.arming_cmd = self.mavros.cmd_arm_disarm(1)\n    return self.arming_cmd\n\n  def disarming(self):\n    \"\"\"This function, disarming, disarms the UAV.\"\"\"\n    self.disarming_cmd = self.mavros.cmd_arm_disarm(0)\n    return self.disarming_cmd\n\n  def takeoff_and_arm(self):\n    \"\"\"This function, takeoff_and_arm, takes the UAV off the ground and arms it.\"\"\"\n    self.takeoff_cmd = self.mavros.set_mode(custom_mode=\"AUTO.TAKEOFF\")\n    self.arming_cmd = self.mavros.cmd_arm_disarm(1)\n    return self.takeoff_cmd, self.arming_cmd\n\n  def land_and_disarm(self):\n    \"\"\"This function, land_and_disarm, lands the UAV and disarms it.\"\"\"\n    self.land_cmd = self.mavros.set_mode(custom_mode=\"AUTO.LAND\")\n    self.disarming_cmd = self.mavros.cmd_arm_disarm(0)\n    return self.land_cmd, self.disarming_cmd\n\n  def takeoff_and_disarm(self):\n    \"\"\"This function, takeoff_and_disarm, takes the UAV off the ground and disarms it.\"\"\"\n    self.takeoff_cmd = self.mavros.set_mode(custom_mode=\"AUTO.TAKEOFF\")\n    self.disarming_cmd = self", "CodeBleu_score": 47.5048402160089}, {"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == \"armed\":\n      return True\n    else:\n      return False\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, takes off the UAV.\"\"\"\n    self.takeoff_cmd = self.mav.command(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_NAV_TAKEOFF, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.mav.send(self.takeoff_cmd)\n\n  def land(self):\n    \"\"\"This function, land, lands the UAV.\"\"\"\n    self.land_cmd = self.mav.command(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_NAV_LAND, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.mav.send(self.land_cmd)\n\n  def move_to_position(self, x, y, z):\n    \"\"\"This function, move_to_position, moves the UAV to a certain position.\\nIt takes three arguments: x, y, and z.\\nThe x and y arguments are the coordinates of the position, and the z argument is the altitude of the position.\\nThe function returns True if the UAV moves to the position successfully.\\nOtherwise, it returns False.\"\"\"\n    self.move_to_position_cmd = self.mav.command(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 0, 0, 0, 0, 0, x, y, z)\n    self.mav.send(self.move_to_position_cmd)\n\n  def move_to_position_relative(self, x, y, z):\n    \"\"\"This function, move_to_position_relative, moves the UAV to a certain position relative to its current position.\\nIt takes three arguments: x, y, and z.\\nThe x and y arguments are the coordinates of the position relative to the current position, and the z argument is the altitude of the position.\\nThe function returns True if the UAV moves to the position", "CodeBleu_score": 47.526635376221094}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    # initialize the distance matrix\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # calculate the distance between the UAVs in the original and changed formations\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i][j] = int(np.linalg.norm(np.array(orig_formation[i]) - np.array(change_formation[j])) - 50)\n    # return the distance matrix\n    return distance_matrix\n\n", "CodeBleu_score": 26.946612500265093}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # Calculate the Euclidean distance between UAVs in the original and changed formations\n    distances = []\n    for i in range(len(orig_formation)):\n        distances.append([])\n        for j in range(len(change_formation)):\n            distance = np.linalg.norm(orig_formation[i] - change_formation[j])\n            distance = int(distance - 50)\n            distances[i].append(distance)\n    # Convert the distance matrix to an array\n    distances = np.array(distances)\n    return distances\n\n", "CodeBleu_score": 28.8628786140658}, {"code": "def build_graph(self, orig_formation, change_formation)\n\n    #Calculate the pairwise distances between UAVs in the original and changed formations\n    dist_mat = pairwise_distances(orig_formation, change_formation, metric='euclidean')\n\n    #Adjust the distances by subtracting them from 50 and converting to integers\n    adj_dist_mat = np.subtract(50, dist_mat).astype(int)\n\n    return adj_dist_mat\n\n", "CodeBleu_score": 6.788311781491381}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    self.visited_left[i] = True\n    for j in range(self.n):\n      if self.visited_right[j] == False and self.adj_matrix[i][j] == True:\n        if self.label[i] + self.label[j] == self.match_weight[j]:\n          self.visited_right[j] = True\n          if self.find_path(j):\n            return True\n        else:\n          self.slack[j] = min(self.slack[j], self.label[i] + self.label[j] - self.match_weight[j])\n          if self.slack[j] == 0:\n            self.visited_right[j] = True\n            if self.find_path(j):\n              return True\n    return False\n\n  def update_label(self):\n    \"\"\"This function, update_label, attempts to find an augmenting path in a bipartite graph for matching purposes.\\nIt iterates through all left vertices and calls find_path.\\nIf a path is found, it updates the label.\\nIf a path is not found, it updates the label.\"\"\"\n    self.label = [0] * self.n\n    for i in range(self.n):\n      if self.visited_left[i] == False:\n        self.find_path(i)\n    for i in range(self.n):\n      if self.visited_left[i] == False:\n        self.label[i] = self.label[i] + self.slack[i]\n\n  def update_match(self):\n    \"\"\"This function, update_match, attempts to find an augmenting path in a bipartite graph for matching purposes.\\nIt iterates through all right vertices and calls find_path.\\nIf a path is found, it updates the match.\\nIf a path is not found, it updates the match.\"\"\"\n    for i in range(self.n):\n      self.visited_right[i] = False\n    for i in range(self.n):\n      if self.visited_left[i] == True:\n        self.find_path(i)\n    for i in range(self.n):\n      if self.visited_left[i] == True:\n        self.match[i] = self.match[i] + self.slack[i]\n\n  def bip", "CodeBleu_score": 31.897733047934924}, {"code": "def find_path(self, i)\n    # Mark the left vertex as visited\n    self.visited[i] = True\n    # Iterate through adjacent right vertices\n    for j in range(self.n):\n      if self.graph[i][j] == 1:\n        # If the right vertex is already visited, continue\n        if self.visited[j] == True:\n          continue\n        # Calculate the gap between labels\n        gap = self.labels[i] + self.labels[j] - self.match[j]\n        # If the gap is zero, update the match and mark the right vertex as visited\n        if gap == 0:\n          self.match[j] = i\n          self.visited[j] = True\n          return True\n        # Otherwise, update the slack value for the right vertex\n        else:\n          self.slack[j] = min(self.slack[j], gap)\n    return False\n\n  def update_labels(self):\n    \"\"\"This function, update_labels, updates the labels of the vertices in the bipartite graph.\\nIt iterates through the vertices and updates the label of the vertex if the slack value is zero.\"\"\"\n    # Iterate through the vertices\n    for i in range(self.n):\n      # If the slack value is zero, update the label\n      if self.slack[i] == 0:\n        self.labels[i] += self.slack[i]\n        self.slack[i] = self.n\n    return\n\n  def find_augmenting_path(self):\n    \"\"\"This function, find_augmenting_path, attempts to find an augmenting path in a bipartite graph for matching purposes.\\nIt iterates through the vertices and calls find_path.\"\"\"\n    # Iterate through the vertices\n    for i in range(self.n):\n      # Call find_path\n      self.find_path(i)\n    return\n\n  def update_match(self):\n    \"\"\"This function, update_match, updates the match of the vertices in the bipartite graph.\\nIt iterates through the vertices and calls update_labels.\"\"\"\n    # Iterate through the vertices\n    for i in range(self.n):\n      # Call update_labels\n      self.update_labels()\n    return\n\n  def max_matching(self):\n    \"\"\"This function, max_matching, attempts to find a maximum matching in a bipartite graph for matching purposes.\\nIt iterates through the vertices and calls find_augmenting", "CodeBleu_score": 37.54963586024817}, {"code": "def find_path(self, i)\n    self.visited_left[i] = True\n    for j in range(self.n_right):\n      if self.visited_right[j] == False:\n        if self.graph[i][j] - self.match[i] - self.slack[j] == 0:\n          self.visited_right[j] = True\n          if self.find_path(self.right_vertex[j]):\n            self.match[i] += 1\n            self.match[self.right_vertex[j]] -= 1\n            return True\n        else:\n          self.slack[j] = min(self.slack[j], self.graph[i][j] - self.match[i] - self.slack[j])\n          if self.slack[j] == 0:\n            self.visited_right[j] = True\n            if self.find_path(self.right_vertex[j]):\n              self.match[i] += 1\n              self.match[self.right_vertex[j]] -= 1\n              return True\n    return False\n\n  def update_labels(self):\n    \"\"\"This function, update_labels, updates the label values for the bipartite graph.\\nIt iterates through the left vertices.\\nIf a left vertex is already visited, it continues.\\nIt iterates through the right vertices.\\nIf a right vertex is already visited, it continues.\\nIf a right vertex is not visited, it updates the label value of the left vertex.\\nThe function returns the maximum label value.\"\"\"\n    for i in range(self.n_left):\n      if self.visited_left[i] == False:\n        for j in range(self.n_right):\n          if self.visited_right[j] == False:\n            self.label[i] = max(self.label[i], self.graph[i][j] - self.match[i] - self.slack[j])\n    return max(self.label)\n\n  def update_slack(self):\n    \"\"\"This function, update_slack, updates the slack values for the right vertices.\\nIt iterates through the right vertices.\\nIf a right vertex is already visited, it continues.\\nIf a right vertex is not visited, it updates the slack value of the right vertex.\\nThe function returns the minimum slack value.\"\"\"\n    for j in range(self.n_", "CodeBleu_score": 33.80515361390313}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n    # Initialize variables\n    # Initialize visit arrays\n    for uav in self.UAVs:\n      uav.visit = [False] * len(self.UAVs)\n    # Initialize slack variables\n    for uav in self.UAVs:\n      uav.slack = [0] * len(self.UAVs)\n    # Initialize label variables\n    for uav in self.UAVs:\n      uav.label = [0] * len(self.UAVs)\n    # Initialize path arrays\n    for uav in self.UAVs:\n      uav.path = [0] * len(self.UAVs)\n    # Iterate over UAVs\n    for uav in self.UAVs:\n      # Iterate over UAVs\n      for uav2 in self.UAVs:\n        # If the UAVs are not connected, set the slack value to infinity\n        if not self.UAVs[uav].connected(uav2):\n          self.UAVs[uav].slack[uav2] = self.UAVs[uav].distance(uav2)\n      # Iterate over UAVs\n      for uav2 in self.UAVs:\n        # If the UAVs are connected, set the slack value to zero\n        if self.UAVs[uav].connected(uav2):\n          self.UAVs[uav].slack[uav2] = 0\n      # Iterate over UAVs\n      for uav2 in self.UAVs:\n        # If the UAVs are not connected, set the label value to infinity\n        if not self.UAVs[uav].connected(uav2):\n          self.UAVs[uav].label[uav2] = self.UAVs[uav].distance(uav2)\n      # Iterate over UAVs\n      for uav2 in self.UAVs:\n        # If the UAVs are connected, set the label value to zero\n        if self.UAVs[uav].connected(uav2):\n          self.UAVs[uav].label[uav2] = 0\n      # Iterate over UAVs\n      for uav2 in self.UAVs:\n        # If the UAVs are not connected, set the path value to infinity\n        if not self", "CodeBleu_score": 22.26333326469674}, {"code": "def KM(self)\n    #Initialize the slack variable\n    slack = np.zeros((self.num_UAVs, self.num_UAVs))\n    #Initialize the visit array\n    visit = np.zeros((self.num_UAVs, self.num_UAVs))\n    #Initialize the match array\n    match = np.zeros((self.num_UAVs, self.num_UAVs))\n    #Initialize the labels\n    self.labels = np.zeros((self.num_UAVs, self.num_UAVs))\n    #Initialize the path\n    path = np.zeros((self.num_UAVs, self.num_UAVs))\n    #Initialize the slack path\n    slack_path = np.zeros((self.num_UAVs, self.num_UAVs))\n    #Initialize the index\n    index = 0\n    #Initialize the counter\n    counter = 0\n    #Initialize the total distance\n    total_distance = 0\n    #Initialize the path distance\n    path_distance = 0\n    #Initialize the path length\n    path_length = 0\n    #Initialize the path index\n    path_index = 0\n    #Initialize the path count\n    path_count = 0\n    #Initialize the path flag\n    path_flag = 0\n    #Initialize the path flag index\n    path_flag_index = 0\n    #Initialize the path flag counter\n    path_flag_counter = 0\n    #Initialize the path flag distance\n    path_flag_distance = 0\n    #Initialize the path flag index\n    path_flag_index = 0\n    #Initialize the path flag counter\n    path_flag_counter = 0\n    #Initialize the path flag distance\n    path_flag_distance = 0\n    #Initialize the path flag index\n    path_flag_index = 0\n    #Initialize the path flag counter\n    path_flag_counter = 0\n    #Initialize the path flag distance\n    path_flag_distance = 0\n    #Initialize the path flag index\n    path_flag_index = 0\n    #Initialize the path flag counter\n    path_flag_counter = 0\n    #Initialize the path flag distance\n    path_flag_distance = 0\n    #Initialize the path flag index\n    path_flag_index = 0\n    #Initialize the path flag counter\n    path_flag_counter = 0\n    #Initialize the path flag distance\n    path_flag_distance =", "CodeBleu_score": 16.086419291962272}, {"code": "def KM(self)\n    for uav in self.UAVs:\n      uav.slack = [0] * len(self.UAVs)\n      uav.visited = [False] * len(self.UAVs)\n      uav.path = [None] * len(self.UAVs)\n    for uav in self.UAVs:\n      uav.path = self.KM_helper(uav)\n    for uav in self.UAVs:\n      if uav.path[uav.path.index(None)] == None:\n        self.adjust_labels()\n        for uav in self.UAVs:\n          uav.path = self.KM_helper(uav)\n        break\n    return self.get_match_results()\n\n  def KM_helper(self, uav):\n    \"\"\"This function, KM_helper, is a helper function for KM. It finds a path for the given UAV.\\nIt iterates over the unvisited UAVs, and for each, it checks if a path can be found.\\nIf a path is found, it returns the path.\\nIf no path is found, it returns None.\"\"\"\n    for v in range(len(self.UAVs)):\n      if uav.visited[v] == False:\n        uav.visited[v] = True\n        if self.UAVs[v].path[v] == None or self.KM_helper(self.UAVs[v]):\n          uav.path[v] = v\n          return uav.path\n    return None\n\n  def adjust_labels(self):\n    \"\"\"This function, adjust_labels, adjusts the labels based on the minimum slack value.\\nIt iterates over the unvisited UAVs, and for each, it checks if a path can be found.\\nIf a path is found, it returns the path.\\nIf no path is found, it returns None.\"\"\"\n    for uav in self.UAVs:\n      if uav.path[uav.path.index(None)] == None:\n        min_slack = min(uav.slack)\n        for v in range(len(uav.slack)):\n          if uav.slack[v] == min_slack:\n            uav.labels[v] += min_slack\n            uav.slack[v] = 0\n            uav.", "CodeBleu_score": 30.718598784185147}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define range of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.array([20, 100, 100])\n    upper = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 37.51478398450005}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription\t(const int id, TagDescriptionContainer& descriptionContainer, bool printWarning) const {\n\t\tif (printWarning) {\n\t\t\tif (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n\t\t\t\tLOG(WARNING) << \"Standalone tag description with ID \" << id << \" not found\";\n\t\t\t}\n\t\t}\n\t\tdescriptionContainer = standalone_tag_descriptions_.at(id);\n\t\treturn standalone_tag_descriptions_.find(id)!= standalone_tag_descriptions_.end();\n\t}\n}\n", "CodeBleu_score": 45.58740420399131}, {"code": "bool TagDetector::findStandaloneTagDescription\tconst std::string &id,\n\tTagDescriptionContainer &descriptionContainer,\n\tbool printWarning = true\n}\n", "CodeBleu_score": 0.9420241621551457}, {"code": "bool TagDetector::findStandaloneTagDescription\tconst int id = description.id;\n\tauto it = standalone_tag_descriptions_.find(id);\n\tif (it == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tLOG(WARNING) << \"Could not find standalone tag description with ID \" << id << \"!\";\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = it->second;\n\treturn true;\n}\n", "CodeBleu_score": 39.348302206401655}]}
