{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> files;\n\tstd::vector<std::string> requiredFiles = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\tfor (const auto &file : requiredFiles) {\n\t\tif (download) {\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\t_pimpl->CallAndWait<void>(\"request_file\", file);\n\t\t\t\tlog_info(\"Download %s\", file.c_str());\n\t\t\t} else {\n\t\t\t\tlog_info(\"Found %s in cache\", file.c_str());\n\t\t\t}\n\t\t}\n\t\tfiles.push_back(file);\n\t}\n\treturn files;\n}", "CodeBleu_score": 56.564863782349285}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = FileTransfer::GetFiles(folder);\n\tfor (auto &file : files) {\n\t\tif (download &&!FileTransfer::FileExists(file)) {\n\t\t\tRequestFile(file);\n\t\t\tlog_info(\"Download file \" << file);\n\t\t} else {\n\t\t\tlog_info(\"File \" << file << \" is found in the cache\");\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\treturn requiredFiles;\n}", "CodeBleu_score": 48.218095949571435}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> files;\n\t// Get the list of files in the folder\n\tauto fileList = FileTransfer::GetFiles(folder);\n\t// Check if each file exists locally\n\tfor (const auto &file : fileList) {\n\t\tif (FileTransfer::FileExists(file)) {\n\t\t\tif (download) {\n\t\t\t\tlog_info(\"File found in cache: %s\", file.c_str());\n\t\t\t}\n\t\t} else {\n\t\t\tlog_info(\"File not found in cache: %s\", file.c_str());\n\t\t\tRequestFile(file);\n\t\t}\n\t\tfiles.push_back(file);\n\t}\n\treturn files;\n}", "CodeBleu_score": 45.77364449167064}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 8.495909444103484}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 8.495909444103484}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#if 0\n  // Check for valid parent ID\n  if (parent == rpc::InvalidActorId) {\n    std::cerr << \"Error: Invalid parent ID.\" << std::endl;\n    return rpc::InvalidActorId;\n  }\n\n  // Check for valid attachment type\n  if (attachment_type!= rpc::AttachmentType::SpringArm &&\n      attachment_type!= rpc::AttachmentType::SpringArmGhost) {\n    std::cerr << \"Error: Invalid attachment type.\" << std::endl;\n    return rpc::InvalidActorId;\n  }\n\n  // Check for valid socket name\n  if (socket_name.empty()) {\n    std::cerr << \"Error: Invalid socket name.\" << std::endl;\n    return rpc::InvalidActorId;\n  }\n\n  // Check for valid transform\n  if (!transform.IsValid()) {\n    std::cerr << \"Error: Invalid transform.\" << std::endl;\n    return rpc::InvalidActorId;\n  }\n\n  // Check for valid translation\n  if (transform.location.translation.z == 0.0f) {\n    std::cerr << \"Warning: Translation is only in the 'z' axis. \"\n              << \"The resulting actor may not be attached to its parent.\"\n              << std::endl;\n  }\n\n  // Spawn actor\n  rpc::Actor actor = _pimpl->CallAndWait<rpc::Actor>(\n      rpc::ActorDescription(description),\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n\n  // Return spawned actor\n  return actor;\n#endif\n}", "CodeBleu_score": 51.42949617701227}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t", "CodeBleu_score": 7.083333333333333}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n}", "CodeBleu_score": 7.390850490544927}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n}", "CodeBleu_score": 7.390850490544927}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\t// create a new WalkerNavigation object if it does not already exist\n\tif (_walker_navigation.load() == nullptr) {\n\t\tstd::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>();\n\t\t// if the navigation object was successfully created, try to set it\n\t\tif (_walker_navigation.compare_exchange_strong(nullptr, new_navigation)) {\n\t\t\treturn new_navigation;\n\t\t}\n\t}\n\treturn _walker_navigation.load();\n}", "CodeBleu_score": 42.35354403441043}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (_walker_navigation == nullptr) {\n\t\tstd::shared_ptr<WalkerNavigation> new_nav = std::make_shared<WalkerNavigation>();\n\t\tif (_walker_navigation.compare_exchange(new_nav)) {\n\t\t\treturn new_nav;\n\t\t}\n\t\treturn _walker_navigation;\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 45.80795373128655}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (_walker_navigation.load() == nullptr) {\n\t\tstd::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>();\n\t\tif (_walker_navigation.compare_exchange_strong(nullptr, new_navigation)) {\n\t\t\treturn new_navigation;\n\t\t}\n\t}\n\treturn _walker_navigation.load();\n}", "CodeBleu_score": 42.35434358393803}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t", "CodeBleu_score": 2.6018891845533507}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetState()->GetFrame() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (std::chrono::system_clock::now() - episode.GetState()->GetTimestamp() > timeout) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 26.13878187657872}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetState()->GetTimestamp() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (std::chrono::system_clock::now() - episode.GetStartTime() > timeout) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 25.850505807335644}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t// TODO: implement this function\n\treturn EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 6.70092071726277}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n//    _client.LoadEpisode(map_name, reset_settings, map_layers);\n//    GetReadyCurrentEpisode();\n//    return EpisodeProxy{shared_from_this()};\n    return EpisodeProxy{shared_from_this()};\n  }", "CodeBleu_score": 6.701092847385307}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t//    _client.LoadEpisode(map_name, reset_settings, map_layers);\n    return EpisodeProxy{shared_from_this()};\n  }", "CodeBleu_score": 6.701092847385307}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tstd::shared_ptr<Walker> walker = _episode->GetWalker(controller.GetWalkerId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found in episode.\");\n\t}\n\tDEBUG_ASSERT(walker!= nullptr);\n\t_episode->CreateNavigationIfMissing(walker->GetId());\n\t_episode->GetNavigation(walker->GetId())->RegisterWalker(walker);\n}", "CodeBleu_score": 50.739755469620405}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Get the walker associated with the controller.\n\tWalker *walker = GetWalker(controller.GetId());\n\tif (walker == nullptr) {\n\t\tthrow_exception(\"Walker not found for AI controller.\");\n\t}\n\n\t// Assert that the episode is not null.\n\tDEBUG_ASSERT(episode!= nullptr);\n\n\t// Create navigation if it is missing.\n\tepisode->CreateNavigationIfMissing();\n\n\t// Register the walker with the controller's ID.\n\tnav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 51.88158658812494}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Get the walker associated with the controller.\n\tWalker *walker = GetWalker(controller.GetId());\n\n\t// Throw an exception if the walker is not found.\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Simulator::RegisterAIController: Walker not found.\");\n\t}\n\n\t// Assert that the episode is not null.\n\tDEBUG_ASSERT(this->_episode!= nullptr);\n\n\t// Create navigation if it is missing.\n\tif (this->_episode->GetNavigation() == nullptr) {\n\t\tthis->_episode->CreateNavigationIfMissing();\n\t}\n\n\t// Register the walker with the controller's ID.\n\tthis->_episode->GetNavigation()->RegisterWalker(controller.GetDisplayId(), walker);\n}", "CodeBleu_score": 45.833549991544395}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\t// Create the actor.\n    auto actor = _actor_factory.MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n    if (!actor) {\n      return nullptr;\n    }\n    // Register the actor in the current episode.\n    _episode->RegisterActor(actor);\n    // Apply the appropriate garbage collection policy.\n    _client.ApplyGarbageCollectionPolicy(actor, gc);\n    // Log the creation details.\n    log_debug(\"Spawned actor %d\", actor->GetId());\n    return actor;\n  }", "CodeBleu_score": 32.258995231297185}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t//    DEBUG_ASSERT(IsValidEpisode());\n    auto sensor_token = sensor.GetActorDescription().GetStreamToken();\n    auto cb = [this, sensor_token, callback](const sensor::SensorData &data) {\n        auto episode_ptr = GetCurrentEpisode();\n        if (episode_ptr) {\n            auto &episode = *episode_ptr;\n            auto sensor_data = SharedPtr<sensor::SensorData>(new sensor::SensorData(data));\n            episode.AssociateSensorData(sensor_token, sensor_data);\n            callback(sensor_data);\n        }\n    };\n    m_client.SubscribeToStream(sensor_token, cb);\n}", "CodeBleu_score": 48.24817747536726}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t//\n// 1. Ensure that the episode is valid.\n//\n  if (episode_ == nullptr) {\n    throw std::runtime_error(\n        \"Attempted to subscribe to sensor \"\n        + sensor.GetActorDescription().GetStreamToken()\n        + \" before starting an episode\");\n  }\n//\n// 2. Subscribe to the sensor's data stream.\n//\n  auto stream_token = sensor.GetActorDescription().GetStreamToken();\n  auto sensor_data_stream = client_.SubscribeToStream(stream_token);\n  auto deserializer = std::make_shared<sensor::Deserializer>(\n      sensor.GetActorDescription().GetStreamToken(),\n      sensor.GetActorDescription().GetSensorType(),\n      sensor.GetActorDescription().GetSensorSubtype());\n//\n// 3. Set up a callback to deserialize the incoming data, associate it with the current episode, and then invoke the provided callback with the sensor data.\n//\n  auto cb = [this, deserializer, callback, stream_token](\n               const std::shared_ptr<sensor::SensorData> &data) {\n    auto sensor_data = deserializer->Deserialize(data);\n    sensor_data->SetEpisode(episode_);\n    callback(sensor_data);\n  };\n  sensor_data_stream->Subscribe(cb);\n}", "CodeBleu_score": 44.654116519747696}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// load the walkers\nstd::vector<WalkerHandle> walkers = Load(episode);\n\n// check if walkers are empty\nif (walkers.empty()) {\n  return;\n}\n\n// get the current state\nstd::shared_ptr<const EpisodeState> state = episode->GetState();\n\n// remove walkers that are not alive\nCheckIfWalkerExist(walkers, *state);\n\n// update vehicles in crowd\nUpdateVehiclesInCrowd(episode, _show_debug);\n\n// update crowd\n_nav.UpdateCrowd();\n\n// get the batch\ncarla::rpc::Batch batch;\n\n// apply the batch\nfor (auto &&walker : walkers) {\n  // get the transform\n  carla::geom::Transform transform = state->GetActorTransform(walker.walker);\n  // get the speed\n  float speed = GetWalkerSpeed(walker.walker);\n  // apply to the batch\n  batch.Apply(walker.controller, transform, speed);\n}\n\n// apply the batch\n_simulator.lock()->ApplyBatchSync(batch);\n\n// check if any walker is dead\nfor (auto &&walker : walkers) {\n  // check if the walker is dead\n  if (state->IsActorDead(walker.walker)) {\n    // remove from the crowd\n    _nav.RemoveAgent(walker.walker);\n    // destroy the controller\n    _simulator.lock()->DestroyActor(walker.controller);\n    // unregister from list\n    UnregisterWalker(walker.walker, walker.controller);\n  }\n}\n\n}", "CodeBleu_score": 47.735402825787624}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// load walkers\n  std::vector<WalkerHandle> walkers = LoadWalkers();\n\n  // check if there are any walkers\n  if (walkers.empty()) return;\n\n  // get current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // remove walkers that no longer exist\n  CheckIfWalkerExist(walkers, *state);\n\n  // update vehicles in crowd\n  UpdateVehiclesInCrowd(episode, _show_debug);\n\n  // get current crowd\n  dtCrowd *crowd = _nav.GetCrowd();\n  if (crowd == nullptr) return;\n\n  // get walker speed\n  float walker_speed = _nav.GetWalkerSpeed();\n\n  // get walker transform\n  std::vector<carla::rpc::Transform> walker_transforms;\n  std::vector<float> walker_speeds;\n  for (auto &&walker : walkers) {\n    // get the transform\n    carla::rpc::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n    // set the speed\n    walker_speeds.emplace_back(walker_speed);\n    // add to the vector\n    walker_transforms.emplace_back(transform);\n  }\n\n  // apply batch sync\n  _simulator.lock()->ApplyBatchSync(walker_transforms, walker_speeds);\n\n  // check if any walker is dead\n  for (auto &&walker : walkers) {\n    // get the snapshot\n    ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n    // check if dead\n    if (snapshot.is_dead) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n}", "CodeBleu_score": 51.08014024033363}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute.MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.80302832375047}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute->MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.73549164712094}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute->MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.73549164712094}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto& blueprint : blueprints) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tauto& attribute = blueprint->GetAttribute(name);\n\t\t\tif (attribute.ContainsAttribute(value)) {\n\t\t\t\tresult->blueprints.emplace_back(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 36.19733395368107}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (const auto& blueprint : blueprints_) {\n\t\tif (blueprint->ContainsAttribute(name)) {\n\t\t\tconst auto& attribute = blueprint->GetAttribute(name);\n\t\t\tif (attribute.ContainsValue(value) || attribute.ContainsRecommendedValue(value)) {\n\t\t\t\tresult->AddBlueprint(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 37.435784287481226}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto &blueprint : blueprints) {\n\t\tif (blueprint.second.ContainsAttribute(name)) {\n\t\t\tif (blueprint.second.GetAttribute(name).GetValue() == value) {\n\t\t\t\tresult->AddBlueprint(blueprint.first);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 31.592783546576726}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = GetFullFilePath(path);\n\tstd::ofstream out(fullPath, std::ios::binary);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write((char*)content.data(), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 33.95843814436537}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = GetFullFilePath(path);\n\tstd::ofstream out(full_path, std::ios::binary);\n\tif (out.is_open()) {\n\t\tout.write((char*)&content[0], content.size());\n\t\tout.close();\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 33.02634127058302}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::ofstream out(path, std::ios::binary);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write((char*)content.data(), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 24.32928619357585}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t//    const auto &location = transform.location;\n    const auto &location = transform.location;\n    const auto &extents = boundingBox.extents;\n    const auto &yaw = transform.rotation.yaw;\n    const float c = std::cos(yaw);\n    const float s = std::sin(yaw);\n    const geom::Location corners[4] = {\n        {\n            c * extents.x - s * extents.y + location.x,\n            s * extents.x + c * extents.y + location.y,\n            location.z},\n        {\n            c * extents.x + s * extents.y + location.x,\n            s * extents.x - c * extents.y + location.y,\n            location.z},\n        {\n            c * -extents.x + s * extents.y + location.x,\n            s * -extents.x - c * extents.y + location.y,\n            location.z},\n        {\n            c * -extents.x - s * extents.y + location.x,\n            s * -extents.x + c * extents.y + location.y,\n            location.z}};\n    return std::make_shared<const Bounds>(frame, corners);\n  }", "CodeBleu_score": 46.0380340822846}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t/*\n * The function takes a frame number and a transform as arguments.\n *\n * The function calculates the location of the bounding box by adding the parent's location to the transform's location.\n *\n * The function then computes the four corners of the bounding box by rotating the extents based on the yaw angle.\n *\n * Finally, the function returns a shared pointer to a Bounds object containing the frame number and the calculated corners.\n */\n    const auto &location = transform.location;\n    const auto &extents = transform.extents;\n    const auto &yaw = transform.yaw;\n\n    const auto rotatedExtents = Rotate(yaw, extents);\n    const auto minX = location.x - rotatedExtents.x;\n    const auto minY = location.y - rotatedExtents.y;\n    const auto maxX = location.x + rotatedExtents.x;\n    const auto maxY = location.y + rotatedExtents.y;\n\n    return std::make_shared<Bounds>(frame, {minX, minY, maxX, maxY});\n  }", "CodeBleu_score": 41.512796991205626}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Create a request to query the light states\n\tLightState::Request request;\n\n\t// Send the request to the server\n\t_episode.Lock()->GetLightManager()->GetClient()->Send(request);\n\n\t// Receive the response from the server\n\tLightState::Response response;\n\t_episode.Lock()->GetLightManager()->GetClient()->Receive(response);\n\n\t// Update the local light states\n\tfor (const auto& light : response.lights()) {\n\t\t// Check if the light already exists in the _lights map\n\t\tauto it = _lights.find(light.id());\n\t\tif (it == _lights.end()) {\n\t\t\t// Create a new light object\n\t\t\tLight* lightObject = new Light(light.id(), light.color());\n\n\t\t\t// Add the light object to the _lights map\n\t\t\t_lights.insert(std::make_pair(light.id(), lightObject));\n\t\t}\n\n\t\t// Update the light state\n\t\t_lights[light.id()]->SetColor(light.color());\n\t}\n}", "CodeBleu_score": 41.22259698943446}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tLock();\n\n\t// Query the server for the current light states.\n\tstd::vector<LightState> lights = _episode.Lock()->QueryLightsStateToServer();\n\n\t// Update the local light states.\n\tfor (std::vector<LightState>::iterator it = lights.begin(); it!= lights.end(); ++it) {\n\t\t// If the light does not already exist, create a new light object.\n\t\tif (_lights.find(it->GetID()) == _lights.end()) {\n\t\t\t_lights[it->GetID()] = new Light(it->GetID());\n\t\t}\n\n\t\t// Update the light state.\n\t\t_lights[it->GetID()]->SetState(*it);\n\t}\n\n\tUnlock();\n}", "CodeBleu_score": 30.488516321297908}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto lights = _episode.Lock()->QueryLightsStateToServer();\n\tfor (auto light : lights) {\n\t\tauto it = _lights.find(light.first);\n\t\tif (it == _lights.end()) {\n\t\t\t_lights.emplace(light.first, Light(light.second));\n\t\t}\n\t\telse {\n\t\t\tit->second.Update(light.second);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.456151190353744}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Check if there are any changes\n\tif (_lights_changes.empty()) {\n\t\t// No changes, nothing to do\n\t\treturn;\n\t}\n\n\t// Create the message\n\tstd::vector<std::string> message;\n\tmessage.push_back(\"lights\");\n\tmessage.push_back(\"update\");\n\n\t// Iterate over the changes\n\tfor (auto& change : _lights_changes) {\n\t\t// Get the light\n\t\tauto it_light = _lights.find(change.first);\n\t\tif (it_light == _lights.end()) {\n\t\t\t// Light not found\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Get the light\n\t\tauto& light = it_light->second;\n\n\t\t// Add the light ID\n\t\tmessage.push_back(std::to_string(light.GetID()));\n\n\t\t// Add the light state\n\t\tmessage.push_back(light.GetState().ToString());\n\n\t\t// Add the light location\n\t\tmessage.push_back(light.GetLocation().ToString());\n\n\t\t// Add the light color\n\t\tmessage.push_back(light.GetColor().ToString());\n\t}\n\n\t// Send the message to the server\n\t_client.Send(message);\n\n\t// Clear the changes\n\t_lights_changes.clear();\n\n\t// Reset the dirty flag\n\t_dirty = false;\n}", "CodeBleu_score": 45.49375312980637}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Check if there are any changes\n\tif (!_lights_changes.empty()) {\n\t\t// Create a message containing the updated light states\n\t\tstd::string message = \"\";\n\t\tfor (auto it = _lights_changes.begin(); it!= _lights_changes.end(); it++) {\n\t\t\tmessage += it->second.GetLocation() + \" \" + it->second.GetColor() + \" \" + std::to_string(it->second.GetBrightness()) + \" \";\n\t\t}\n\n\t\t// Send the message to the server\n\t\t_client->SendMessage(message);\n\n\t\t// Clear the changes and reset the dirty flag\n\t\t_lights_changes.clear();\n\t\t_dirty = false;\n\t}\n}", "CodeBleu_score": 32.76241121449168}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_lights_changes_mutex);\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\tstd::stringstream message;\n\tmessage << \"lights:\";\n\tfor (auto& change : _lights_changes) {\n\t\tmessage << \" \" << change.first << \":\" << change.second.GetLocation();\n\t}\n\t_lights_changes.clear();\n\t_dirty = false;\n\t_server.Send(message.str());\n}", "CodeBleu_score": 28.698920124006328}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetEpisode().Lock()->GetSensorContext(GetSensorId())!= GetContext()) {\n\t\tlog_warning(\"Sensor ID \\\"%s\\\" does not match sensor context \\\"%s\\\".\", GetSensorId().c_str(), GetContext().c_str());\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 46.560876162691706}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"Sensor ID is not \\\"sensor.other.v2x_custom\\\"\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 48.85147067369305}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->GetEpisode() == nullptr) {\n\t\tlog_warning(\"ServerSideSensor::Send: Episode is null\");\n\t\treturn;\n\t}\n\tif (this->GetEpisode()->Lock() == nullptr) {\n\t\tlog_warning(\"ServerSideSensor::Send: Episode is null\");\n\t\treturn;\n\t}\n\tif (this->GetEpisode()->Lock()->GetDisplayId() == nullptr) {\n\t\tlog_warning(\"ServerSideSensor::Send: DisplayId is null\");\n\t\treturn;\n\t}\n\tif (this->GetEpisode()->Lock()->GetDisplayId()->GetDescription() == nullptr) {\n\t\tlog_warning(\"ServerSideSensor::Send: DisplayId Description is null\");\n\t\treturn;\n\t}\n\tif (this->GetEpisode()->Lock()->GetDisplayId()->GetDescription()->GetActorDescription() == nullptr) {\n\t\tlog_warning(\"ServerSideSensor::Send: ActorDescription is null\");\n\t\treturn;\n\t}\n\tif (this->GetEpisode()->Lock()->GetDisplayId()->GetDescription()->GetActorDescription()->GetContext() == nullptr) {\n\t\tlog_warning(\"ServerSideSensor::Send: Context is null\");\n\t\treturn;\n\t}\n\tif (this->GetEpisode()->Lock()->GetDisplayId()->GetDescription()->GetActorDescription()->GetContext()->GetSensor() == nullptr) {\n\t\tlog_warning(\"ServerSideSensor::Send: Sensor is null\");\n\t\treturn;\n\t}\n\tif (this->GetEpisode()->Lock()->GetDisplayId()->GetDescription()->GetActorDescription()->GetContext()->GetSensor()->GetId() == nullptr) {\n\t\tlog_warning(\"ServerSideSensor::Send: Sensor ID is null\");\n\t\treturn;\n\t}\n\tif (this->GetEpisode()->Lock()->GetDisplayId()->GetDescription()->GetActorDescription()->GetContext()->GetSensor()->GetId()->GetValue()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send: Sensor ID is not sensor.other.v2x_custom\");\n\t\treturn;\n\t}\n\tlog_debug(\"ServerSideSensor::Send: Sending message\");\n\tthis->GetEpisode()->Lock()->Send(message);\n}", "CodeBleu_score": 39.99042444231492}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(tm_port);\n\t} else {\n\t\ttm.UnregisterVehicles(tm_port);\n\t}\n}", "CodeBleu_score": 44.320523922585906}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(tm_port, shared_from_this());\n\t} else {\n\t\ttm.UnregisterVehicles(tm_port, shared_from_this());\n\t}\n}", "CodeBleu_score": 53.44625161737993}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\t// TODO: not implemented yet\n}", "CodeBleu_score": 4.055752836348062}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\t// Retrieve the walker actor\n\twalker = GetEpisode().Lock()->GetActor(walkerId);\n\t// Add the walker to the navigation system\n\tGetEpisode().Lock()->GetNavigation()->AddWalker(walker->GetLocation(), walker);\n\t// Disable the physics simulation and collisions for the walker actor\n\twalker->SetActorSimulatePhysics(false);\n\twalker->SetActorEnableCollision(false);\n}", "CodeBleu_score": 34.495426323621494}, {"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor\n\twalker = Cast<AWalker>(GetPawn());\n\n\t// Register the AI controller with the episode\n\tGetEpisode().Lock()->RegisterAIController(this);\n\n\t// Add the walker actor to the navigation system\n\tGetEpisode().Lock()->AddWalker(walker);\n\n\t// Disable the physics simulation and collisions for the walker actor\n\twalker->GetRootComponent()->SetSimulatePhysics(false);\n\twalker->GetRootComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 35.196833677924936}, {"code": "void WalkerAIController::Start(){\n\t\twalker = Cast<AWalker>(GetPawn());\n\tif (walker) {\n\t\tGetEpisode().Lock()->RegisterAIController(this);\n\t\twalker->GetLocation();\n\t\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\t\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n\t}\n}", "CodeBleu_score": 39.704112453428806}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (GetEpisode()!= nullptr) {\n\t\tif (GetEpisode().Lock()->GetNavigation()!= nullptr) {\n\t\t\tWalker* walker = GetParent();\n\t\t\tif (walker!= nullptr) {\n\t\t\t\tif (!GetEpisode().Lock()->GetNavigation()->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\t\t\t\tlog_warning(\"Unable to set walker maximum speed.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog_warning(\"Unable to find walker.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog_warning(\"Unable to find navigation instance.\");\n\t\t}\n\t}\n\telse {\n\t\tlog_warning(\"Unable to find episode.\");\n\t}\n}", "CodeBleu_score": 57.44165645566689}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the current episode\n\tEpisode* episode = GetEpisode();\n\n\t// Check if the episode is valid\n\tif (!episode) {\n\t\t// Log a warning message\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: episode is null\");\n\t\treturn;\n\t}\n\n\t// Get the navigation instance\n\tNavigation* nav = episode->Lock()->GetNavigation();\n\n\t// Check if the navigation instance is valid\n\tif (!nav) {\n\t\t// Log a warning message\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: navigation is null\");\n\t\treturn;\n\t}\n\n\t// Get the parent walker\n\tWalker* walker = GetParent();\n\n\t// Check if the walker is valid\n\tif (!walker) {\n\t\t// Log a warning message\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: walker is null\");\n\t\treturn;\n\t}\n\n\t// Set the maximum speed\n\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t// Log a warning message\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: failed to set maximum speed\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 47.994484816147846}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the navigation instance from the current episode\n\tNavigation* nav = GetEpisode().Lock()->GetNavigation();\n\n\t// Check if the navigation instance is valid\n\tif (nav) {\n\t\t// Get the parent walker\n\t\tWalker* walker = GetParent();\n\n\t\t// Attempt to set the maximum speed using the navigation instance\n\t\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t// Log a warning message if setting the speed fails\n\t\t\tlog_warning(\"Failed to set maximum speed for walker %s.\", walker->GetId());\n\t\t}\n\t} else {\n\t\t// Log a warning message if the navigation instance is invalid\n\t\tlog_warning(\"Failed to set maximum speed for walker %s. No navigation instance found.\", GetParent()->GetId());\n\t}\n}", "CodeBleu_score": 54.935023155994}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(_position, distance).size());\n\tfor (const auto &waypoint : _parent->GetMap().GetPrevious(_position, distance)) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(waypoint, _parent));\n\t}\n\treturn result;\n}", "CodeBleu_score": 59.773906372276286}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(_position, distance).size());\n\tfor (auto &waypoint : _parent->GetMap().GetPrevious(_position, distance)) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 62.00131569620781}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tauto waypoints = _parent->GetMap().GetPrevious(_position, distance);\n\tresult.reserve(waypoints.size());\n\tfor (auto& waypoint : waypoints) {\n\t\tresult.emplace_back(std::move(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 61.65182778590788}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::set<SharedPtr<Signal>> added_signals;\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\nfor (auto signal : signals) {\nif (added_signals.count(signal) == 0) {\nresult.emplace_back(std::make_shared<Landmark>(signal, _parent));\nadded_signals.insert(signal);\n}\n}\nreturn result;\n}", "CodeBleu_score": 38.3124834072362}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::set<std::string> added_landmarks;\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\nfor (auto signal : signals) {\nif (added_landmarks.count(signal->GetId()) == 0) {\nresult.emplace_back(new Landmark(signal, _parent));\nadded_landmarks.insert(signal->GetId());\n}\n}\nreturn result;\n}", "CodeBleu_score": 35.31538892879655}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\nstd::vector<SharedPtr<Landmark>> result;\nstd::set<std::string> added_landmarks;\n\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\nfor (auto signal : signals) {\nif (added_landmarks.count(signal->GetId()) == 0) {\n\n// Create new waypoint and landmark\nSharedPtr<Waypoint> waypoint = GetMap().GetWaypoint(signal->GetId());\nSharedPtr<Landmark> landmark = GetMap().GetLandmark(signal->GetId());\n\nif (waypoint!= nullptr && landmark!= nullptr) {\nresult.emplace_back(landmark);\nadded_landmarks.insert(signal->GetId());\n}\n}\n}\n\nreturn result;\n}", "CodeBleu_score": 46.11001194468003}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t//    _episode.Lock()->SetEpisodeSettings(settings);\n//    time_duration local_timeout = timeout.milliseconds() == 0?\n//        _episode.Lock()->GetNetworkingTimeout() : timeout;\n//    uint64_t settings_id = _episode.Lock()->ApplySettings(local_timeout);\n//    if (settings.fixed_delta_seconds.has_value()) {\n//        float delta_seconds = settings.fixed_delta_seconds.value();\n//        float max_delta_seconds = delta_seconds * 1.05f;\n//        float min_delta_seconds = delta_seconds * 0.95f;\n//        uint64_t attempts = 0;\n//        uint64_t max_attempts = 10;\n//        while (attempts < max_attempts) {\n//            time_duration tick_timeout = time_duration::milliseconds(100);\n//            uint64_t tick = _episode.Lock()->Tick(tick_timeout);\n//            if (tick == 0) {\n//                log_warning(\"Failed to tick the world.\");\n//                break;\n//            }\n//            auto snapshot = _episode.Lock()->GetWorldSnapshot();\n//            if (snapshot.timestamp.has_value()) {\n//                float delta_seconds = snapshot.timestamp.value() -\n//                    _last_timestamp.value();\n//                if (delta_seconds < min_delta_seconds ||\n//                    delta_seconds > max_delta_seconds) {\n//                    log_warning(\"Fixed delta time was not applied correctly.\");\n//                    break;\n//                }\n//            }\n//            attempts++;\n//        }\n//    }\n//    return settings_id;\n  }", "CodeBleu_score": 3.2079205477712285}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t*\n * This function, World::ApplySettings, applies the provided episode settings to the world and returns a unique identifier.\nIt sets a local timeout based on the provided timeout or the episode's networking timeout.\nIf the settings include a fixed delta time, it attempts to verify the accuracy of this setting over a series of ticks.\nIf the setting is not correctly applied after a number of attempts, a warning is logged.\nFinally, it returns the identifier of the applied settings.\n */\n    if (settings.fixed_delta_seconds.has_value()) {\n      // If the fixed delta time is set, we will attempt to verify that the\n      // setting is applied correctly.\n      const auto &new_settings = settings;\n      new_settings.fixed_delta_seconds =\n          std::max(std::numeric_limits<float>::epsilon(),\n                   settings.fixed_delta_seconds.get());\n      // We will try to apply the setting 3 times.\n      for (int i = 0; i < 3; i++) {\n        // We will attempt to apply the setting and get the current snapshot.\n        const auto &curr_snapshot = GetSnapshot();\n        // We will then apply the new settings and get the new snapshot.\n        _episode.Lock()->SetEpisodeSettings(new_settings);\n        const auto &new_snapshot = GetSnapshot();\n        // We will then compare the timestamps of the two snapshots.\n        const auto &diff = new_snapshot.GetTimestamp() - curr_snapshot.GetTimestamp();\n        // If the difference is less than the expected difference, we will\n        // assume that the setting was applied correctly.\n        if (diff < new_settings.fixed_delta_seconds) {\n          // We will log a warning that the setting was applied correctly.\n          log_warning(\n              \"Applied settings with fixed delta time {}. \"\n              \"Difference between timestamps was {}.\",\n              new_settings.fixed_delta_seconds, diff);\n          break;\n        } else {\n          // We will log a warning that the setting was not applied correctly.\n          log_warning(\n              \"Failed to apply settings with fixed delta time {}. \"\n              \"Difference between timestamps was {}.\",\n              new_settings.fixed_delta_seconds, diff);\n        }\n      }\n    }\n    // We will then apply the settings and return the identifier of the\n    // settings.\n    return _episode.Lock()->SetEpisodeSettings(settings);\n  }", "CodeBleu_score": 49.432965899505085}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = segment.x * segment.x + segment.y * segment.y;\n\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\tif (segmentLength == 0) {\n\t\treturn { 0.0f, Clamp(dot, 0.0f, segmentLengthSquared) };\n\t}\n\tfloat dot = Dot2D(point, segment) / segmentLengthSquared;\n\tfloat clampedDot = Clamp(dot, 0.0f, 1.0f);\n\tfloat projection = segment.x * clampedDot + segment.y * clampedDot;\n\tfloat distanceAlongSegment = projection - point.x;\n\tfloat distanceToProjection = std::sqrt(distanceAlongSegment * distanceAlongSegment + (point.y - projection) * (point.y - projection));\n\treturn { distanceToProjection, distanceAlongSegment };\n}", "CodeBleu_score": 38.367807459134234}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst float segmentLengthSquared = segment.DistanceSquared(segment.start);\n\tconst float segmentLength = std::sqrt(segmentLengthSquared);\n\tif (segmentLength == 0.0f) {\n\t\treturn std::make_pair(0.0f, segment.start.Distance(point));\n\t}\n\tconst float t = Clamp(segment.start.Dot(point) - segment.start.Dot(segment.start), 0.0f, segmentLength);\n\tconst Vector2D projection = segment.start + segment.direction * t;\n\treturn std::make_pair(segmentLengthSquared / segmentLength, projection.Distance(point));\n}", "CodeBleu_score": 41.517152222813515}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst float segmentLengthSquared = segment.first.DistanceSquared2D(segment.second);\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, segment.first.Distance2D(point));\n\t}\n\tconst float t = Clamp(point.Dot2D(segment.second - segment.first) / segmentLengthSquared, 0.0f, 1.0f);\n\tconst Vector2D projection = segment.first + t * (segment.second - segment.first);\n\treturn std::make_pair(projection.Distance2D(point), projection.Distance2D(point));\n}", "CodeBleu_score": 38.11049704365575}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\nAddVertices(vertices);\nindex_type initialIndex = GetVerticesNum() - vertices.size();\nfor (size_t i = 0; i < vertices.size() - 2; ++i) {\nAddIndex(initialIndex);\nAddIndex(initialIndex + i + 1);\nAddIndex(initialIndex + i + 2);\n}\n}", "CodeBleu_score": 53.32963993637243}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t//    DEBUG_ASSERT(vertices.size() >= 3, \"Mesh::AddTriangleFan: vertices.size() >= 3\");\n    const index_type initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 50.290421363808925}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t//    DEBUG_ASSERT(vertices.size() >= 3);\n//    const index_type initialIndex = GetVerticesNum();\n//    AddVertices(vertices);\n//    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n//      AddIndex(initialIndex);\n//      AddIndex(initialIndex + i);\n//      AddIndex(initialIndex + i + 1);\n//    }\n  }", "CodeBleu_score": 5.829718325262547}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (message->empty()) {\n\t\tlog_error(\"Message is empty\");\n\t\treturn;\n\t}\n\n\t// Post the lambda to the strand\n\tboost::asio::post(\n\t\tself->_strand,\n\t\t[this, message]() {\n\t\t\tif (!self->_socket.is_open()) {\n\t\t\t\tlog_error(\"Socket is not open\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set a timeout\n\t\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(self->GetTimeout()));\n\n\t\t\t// Initiate an asynchronous write\n\t\t\tboost::asio::async_write(\n\t\t\t\tself->_socket,\n\t\t\t\tmessage->GetBufferSequence(),\n\t\t\t\tboost::asio::bind_executor(\n\t\t\t\t\tself->_strand,\n\t\t\t\t\tstd::bind(&Primary::HandleSent, shared_from_this(), std::placeholders::_1, std::placeholders::_2)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t);\n}", "CodeBleu_score": 30.213064955279368}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\t// Ensure the message is valid.\n\tif (!message->valid()) {\n\t\tlog_error(\"Invalid message, closing connection.\");\n\t\tCloseNow();\n\t\treturn;\n\t}\n\n\t// Post the message to the strand.\n\tboost::asio::post(self->_strand, [self, message = std::move(message)]() mutable {\n\t\t// Check if the socket is open.\n\t\tif (!self->_socket.is_open()) {\n\t\t\tlog_error(\"Socket is not open, closing connection.\");\n\t\t\tself->CloseNow();\n\t\t\treturn;\n\t\t}\n\n\t\t// Set a timeout.\n\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(kWriteTimeoutSeconds));\n\n\t\t// Initiate an asynchronous write.\n\t\tboost::asio::async_write(self->_socket, message->GetBufferSequence(), boost::asio::bind_executor(self->_strand, [self, message](const boost::system::error_code &ec, std::size_t) {\n\t\t\t// Handle the result.\n\t\t\tself->handle_sent(ec, message);\n\t\t}));\n\t});\n}", "CodeBleu_score": 36.59676884506122}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\t// Validate the message\n\tif (message->empty()) {\n\t\tlog_error(\"Attempted to write an empty message\");\n\t\treturn;\n\t}\n\n\t// Post the write to the strand\n\tself->strand.post([message, self = shared_from_this()]() {\n\t\t// Check if the socket is open\n\t\tif (!self->_socket.is_open()) {\n\t\t\tlog_error(\"Attempted to write to a closed socket\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Set a timeout\n\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(self->_timeout));\n\n\t\t// Initiate an asynchronous write\n\t\tboost::asio::async_write(self->_socket, message->GetBufferSequence(),\n\t\t\t[self, message](boost::system::error_code ec, std::size_t bytes_transferred) {\n\t\t\t\tself->handle_sent(ec, bytes_transferred);\n\t\t\t});\n\t});\n}", "CodeBleu_score": 34.89893178244515}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer.\n\t_deadline.cancel();\n\n\t// If the socket is open, shutdown and close it.\n\tif (_socket.is_open()) {\n\t\tif (ec) {\n\t\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t}\n\t\telse {\n\t\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t}\n\t\tif (!ec) {\n\t\t\t_socket.close(ec);\n\t\t}\n\t}\n\n\t// Call the on_closed callback.\n\tif (_on_closed) {\n\t\t_on_closed();\n\t}\n\n\t// Log that the session has been closed.\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 57.64053706738387}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!_socket.is_open()) {\n\t\treturn;\n\t}\n\n\tboost::system::error_code ignored_ec;\n\tif (ec) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t}\n\t_socket.close(ignored_ec);\n\n\t_on_closed();\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 57.17268722584916}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec) {\n\t\tlog_debug(\"Closing socket due to error: %s\", ec.message());\n\t} else {\n\t\tif (_socket.is_open()) {\n\t\t\tif (_deadline.expires_from_now(boost::posix_time::seconds(0)) == _deadline.expires_from_now(boost::posix_time::seconds(0))) {\n\t\t\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\t\t}\n\t\t\t_socket.close();\n\t\t}\n\t}\n\n\t_on_closed();\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 52.845023537005254}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tstd::string msg = \"Are you alive?\";\n\tstd::vector<char> buffer(msg.begin(), msg.end());\n\tbuffer.push_back('\\0');\n\t// Log the sending action\n\tlog_info(\"Sending message: \" + msg);\n\t// Write the buffer to the next router\n\t_router->WriteToNext(buffer);\n\t// Wait for and log the response\n\tstd::future<std::vector<char>> fut = _router->ReadFromNext();\n\tstd::vector<char> response = fut.get();\n\tlog_info(\"Received message: \" + std::string(response.begin(), response.end()));\n}", "CodeBleu_score": 49.54727626504879}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create the buffer\n\tstd::string msg = \"Are you alive?\";\n\tstd::vector<char> buffer(msg.size());\n\tstd::copy(msg.begin(), msg.end(), buffer.begin());\n\n\t// Log the sending action\n\tlog_info(\"Sending Are you alive? to the next router\");\n\n\t// Write the buffer to the next router\n\t_router->WriteToNext(buffer);\n\n\t// Wait for and log the response\n\tstd::future<std::vector<char>> fut = _router->ReadFromNext();\n\tstd::vector<char> response = fut.get();\n\tlog_info(\"Received response from the next router\");\n}", "CodeBleu_score": 51.67305003155671}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create buffer\n\tstd::string msg = \"Are you alive?\";\n\tstd::vector<char> buffer(msg.begin(), msg.end());\n\n\t// Log action\n\tlog_info(\"Sending message: %s\", msg.c_str());\n\n\t// Write to next router\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\n\t// Wait for response\n\tstd::future<std::vector<char>> fut = _router->ReadFromNext();\n\tstd::vector<char> response = fut.get();\n\n\t// Log response\n\tstd::string response_msg(response.begin(), response.end());\n\tlog_info(\"Received message: %s\", response_msg.c_str());\n}", "CodeBleu_score": 48.93822467158764}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor has been activated on any secondary server\n\tif (_servers.find(sensor_id)!= _servers.end()) {\n\t\t// Create a buffer with the sensor ID\n\t\tstd::vector<uint8_t> buffer(1);\n\t\tbuffer[0] = sensor_id;\n\t\t// Send an ENABLE_ROS command to the server using the router\n\t\t_router->Send(buffer, _servers.at(sensor_id));\n\t\t// Wait for and process the server's response\n\t\tauto fut = _router->ReadFromOne();\n\t\tauto response = fut.get();\n\t\tlog_error(response.status);\n\t\t// If the sensor is not found on any server, log an error message\n\t\tif (response.status == Status::NOT_FOUND) {\n\t\t\tstd::cout << \"Sensor \" << static_cast<int>(sensor_id) << \" not found on any server\" << std::endl;\n\t\t}\n\t}\n\t// If the sensor has not been activated on any server, log an error message\n\telse {\n\t\tstd::cout << \"Sensor \" << static_cast<int>(sensor_id) << \" has not been activated on any server\" << std::endl;\n\t}\n}", "CodeBleu_score": 51.157653792848336}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if sensor is activated on any server\n\tif (_servers.find(sensor_id) == _servers.end()) {\n\t\tlog_error(\"Sensor %d is not activated on any server\", sensor_id);\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID\n\tstd::vector<uint8_t> buffer;\n\tbuffer.push_back(sensor_id);\n\n\t// Send an ENABLE_ROS command to the server\n\tauto fut = _router->WriteToOne(buffer, _servers.find(sensor_id)->second);\n\n\t// Wait for and process the server's response\n\tresponse = fut.get();\n\tif (response.status == Router::Status::OK) {\n\t\tlog_info(\"Sensor %d enabled for ROS\", sensor_id);\n\t}\n\telse {\n\t\tlog_error(\"Failed to enable sensor %d for ROS\", sensor_id);\n\t}\n}", "CodeBleu_score": 48.48871763936676}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tif (_servers.find(sensor_id)!= _servers.end()) {\n\t\t// Create the buffer to send to the server\n\t\tstd::vector<uint8_t> buffer;\n\t\tbuffer.push_back(ENABLE_ROS);\n\t\tbuffer.push_back(sensor_id);\n\n\t\t// Send the buffer to the server\n\t\t_router->WriteToOne(buffer, _servers[sensor_id]);\n\n\t\t// Wait for and process the response\n\t\tstd::future<std::vector<uint8_t>> fut = _router->ReadFromOne();\n\t\tstd::vector<uint8_t> response = fut.get();\n\t\tif (response.size() > 0 && response[0] == ENABLE_ROS_RESPONSE) {\n\t\t\t// Enable ROS on the sensor\n\t\t\t_ros_enabled[sensor_id] = true;\n\t\t} else {\n\t\t\t// Log an error message\n\t\t\tlog_error(\"Failed to enable ROS for sensor %d\", sensor_id);\n\t\t}\n\t} else {\n\t\t// Log an error message\n\t\tlog_error(\"Failed to enable ROS for sensor %d: sensor not found\", sensor_id);\n\t}\n}", "CodeBleu_score": 45.4178734279674}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tlog_info(\"asking for a token\");\n\ttoken_type new_token;\n\tif (is_sensor_activated(sensor_id)) {\n\t\tnew_token = _tokens.find(sensor_id)->second;\n\t\tlog_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n\t\treturn new_token;\n\t}\n\n\tauto fut = _router->WriteToNext(MultiGPUCommand::ACTIVATE_SENSOR, std::move(carla::Buffer((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id))));\n\tauto response = fut.get();\n\tnew_token = token_type(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n\tlog_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n\n\t_tokens.insert(std::pair<stream_id, token_type>(sensor_id, new_token));\n\t_ports.insert(std::pair<stream_id, uint16_t>(sensor_id, new_token.get_port()));\n\n\treturn new_token;\n}", "CodeBleu_score": 44.76084327272231}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tlog_debug(\"getting token for sensor id: \", sensor_id);\n\tauto it = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\tlog_debug(\"token already exists for sensor id: \", sensor_id);\n\t\treturn it->second;\n\t}\n\tlog_debug(\"token does not exist for sensor id: \", sensor_id);\n\t// get token from the router\n\tauto token = SendGetToken(sensor_id);\n\t// update the map\n\t_tokens.insert(std::make_pair(sensor_id, token));\n\treturn token;\n}", "CodeBleu_score": 48.14718259676465}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tlog_debug(\"token for sensor_id \", sensor_id);\n\tauto it = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\tlog_debug(\"token already exists\");\n\t\treturn it->second;\n\t}\n\tlog_debug(\"token does not exist, requesting a new one\");\n\ttoken_type new_token = SendGetToken(sensor_id);\n\t_tokens.insert(std::make_pair(sensor_id, new_token));\n\treturn new_token;\n}", "CodeBleu_score": 45.278046299045585}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t  return false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n  }", "CodeBleu_score": 96.88827403348479}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\nstd::istream_iterator<uint8_t> start(f), end;\n\n// read the whole file\nf.open(filename, std::ios::binary);\nif (!f.is_open()) {\n  return false;\n}\nstd::vector<uint8_t> content(start, end);\nf.close();\n\n// parse the content\nreturn Load(std::move(content));\n}", "CodeBleu_score": 96.79306147398819}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady() ||!_crowd) {\n\t\treturn false;\n\t}\n\t// Find the agent in the crowd.\n\tdtCrowdAgent* agent = _crowd->getAgent(id);\n\tif (!agent) {\n\t\treturn false;\n\t}\n\t// Enter the critical section to safely remove the agent.\n\t_mutex.lock();\n\t// Remove the agent from the crowd.\n\t_crowd->removeAgent(agent);\n\t// Find the agent in the walker and vehicle mappings.\n\tauto walker_id = _mapped_walkers_id.find(id);\n\tif (walker_id!= _mapped_walkers_id.end()) {\n\t\t// Remove the agent from the walker manager.\n\t\t_walker_manager.RemoveWalker(walker_id->second);\n\t\t// Remove the agent from the walker mapping.\n\t\t_mapped_walkers_id.erase(walker_id);\n\t}\n\tauto vehicle_id = _mapped_vehicles_id.find(id);\n\tif (vehicle_id!= _mapped_vehicles_id.end()) {\n\t\t// Remove the agent from the vehicle manager.\n\t\t_vehicle_manager.RemoveVehicle(vehicle_id->second);\n\t\t// Remove the agent from the vehicle mapping.\n\t\t_mapped_vehicles_id.erase(vehicle_id);\n\t}\n\t// Remove the agent from the index mapping.\n\t_mapped_by_index.erase(agent->idx);\n\t// Leave the critical section.\n\t_mutex.unlock();\n\treturn true;\n}", "CodeBleu_score": 52.77672590249238}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// Check if the navigation system is ready\n\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\t// Check if the crowd object is null\n\tif (!_crowd) {\n\t\treturn false;\n\t}\n\n\t// Check if the agent id is valid\n\tif (!id.IsValid()) {\n\t\treturn false;\n\t}\n\n\t// Search for the agent id in the walker and vehicle mappings\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\n\t// Check if the agent is found in the mappings\n\tif (walker_it!= _mapped_walkers_id.end() || vehicle_it!= _mapped_vehicles_id.end()) {\n\t\t// Enter a critical section to safely remove the agent from the crowd\n\t\tCriticalSection cs(&_crowd->cs);\n\n\t\t// Remove the agent from the crowd\n\t\tif (walker_it!= _mapped_walkers_id.end()) {\n\t\t\t_crowd->removeAgent(walker_it->second);\n\t\t}\n\t\telse if (vehicle_it!= _mapped_vehicles_id.end()) {\n\t\t\t_crowd->removeAgent(vehicle_it->second);\n\t\t}\n\n\t\t// Update the walker or vehicle manager\n\t\tif (walker_it!= _mapped_walkers_id.end()) {\n\t\t\t_walker_manager.RemoveWalker(walker_it->second);\n\t\t}\n\t\telse if (vehicle_it!= _mapped_vehicles_id.end()) {\n\t\t\t_vehicle_manager.RemoveVehicle(vehicle_it->second);\n\t\t}\n\n\t\t// Remove the agent id from the mappings\n\t\t_mapped_walkers_id.erase(walker_it);\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t\t_mapped_by_index.erase(id.index);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 53.45917273077647}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(_crowd!= nullptr);\n\tif (!_ready)\n\t\treturn false;\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_mapped_walkers_id.find(id)!= _mapped_walkers_id.end()) {\n\t\tint index = _mapped_walkers_id.find(id)->second;\n\t\t_walker_manager.RemoveWalker(index);\n\t\t_mapped_walkers_id.erase(id);\n\t\t_mapped_by_index.erase(index);\n\t\treturn true;\n\t}\n\tif (_mapped_vehicles_id.find(id)!= _mapped_vehicles_id.end()) {\n\t\tint index = _mapped_vehicles_id.find(id)->second;\n\t\t_crowd->removeAgent(index);\n\t\t_mapped_vehicles_id.erase(id);\n\t\t_mapped_by_index.erase(index);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.916572126118986}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tf DEBUG_NAVIGATION\n    logging::log(\"Navigation::UpdateVehicles\");\n#endif\n\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    // get the current list of vehicles\n    std::set<ActorId> current_vehicles;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      for (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\n        current_vehicles.insert(it->first);\n      }\n    }\n\n    // add or update vehicles\n    for (auto &vehicle : vehicles) {\n      // add or update\n      AddOrUpdateVehicle(vehicle);\n      // mark as updated\n      current_vehicles.erase(vehicle.id);\n    }\n\n    // remove vehicles not updated\n    for (auto &id : current_vehicles) {\n      RemoveAgent(id);\n    }\n\n    return true;\n  }", "CodeBleu_score": 53.43200254875573}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\nif (!_ready) {\n  return false;\n}\n\nDEBUG_ASSERT(_crowd!= nullptr);\n\n// get the ids of currently mapped vehicles\nstd::set<ActorId> current_ids;\nfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\n  current_ids.insert(it->first);\n}\n\n// add or update vehicles\nfor (auto &vehicle : vehicles) {\n  // add or update vehicle\n  if (!AddOrUpdateVehicle(vehicle)) {\n    continue;\n  }\n\n  // mark as updated\n  current_ids.erase(vehicle.id);\n}\n\n// remove vehicles\nfor (auto &id : current_ids) {\n  // remove vehicle\n  if (!RemoveAgent(id)) {\n    continue;\n  }\n}\n\nreturn true;\n}", "CodeBleu_score": 47.052077353751244}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Search for the actor in the mapped vehicles and walkers.\n\tauto _mapped_walkers_id = _mapped_walkers.find(id);\n\tauto _mapped_vehicles_id = _mapped_vehicles.find(id);\n\n\t// If the actor is not found in the mapped vehicles or walkers, return false.\n\tif (_mapped_walkers_id == _mapped_walkers.end() && _mapped_vehicles_id == _mapped_vehicles.end()) {\n\t\treturn false;\n\t}\n\n\t// If the actor is found in the mapped vehicles, enter a critical section, compute the squared distance, and use the crowd system to determine if a vehicle is nearby.\n\tif (_mapped_vehicles_id!= _mapped_vehicles.end()) {\n\t\t// Enter a critical section.\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t\t// Compute the squared distance.\n\t\tfloat squared_distance = carla::geom::DistanceSquared2D(direction, _mapped_vehicles_id->second->GetLocation());\n\n\t\t// Use the crowd system to determine if a vehicle is nearby.\n\t\treturn _crowd->hasVehicleNear(_mapped_vehicles_id->second->GetActorId(), distance, squared_distance);\n\t}\n\n\t// If the actor is found in the mapped walkers, enter a critical section, compute the squared distance, and use the crowd system to determine if a vehicle is nearby.\n\tif (_mapped_walkers_id!= _mapped_walkers.end()) {\n\t\t// Enter a critical section.\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t\t// Compute the squared distance.\n\t\tfloat squared_distance = carla::geom::DistanceSquared2D(direction, _mapped_walkers_id->second->GetLocation());\n\n\t\t// Use the crowd system to determine if a vehicle is nearby.\n\t\treturn _crowd->hasVehicleNear(_mapped_walkers_id->second->GetActorId(), distance, squared_distance);\n\t}\n\n\t// If the actor is not found in the mapped vehicles or walkers, return false.\n\treturn false;\n}", "CodeBleu_score": 50.90118431564069}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Check if the actor is a walker or a vehicle\n\tif (_mapped_walkers_id.find(id)!= _mapped_walkers_id.end()) {\n\t\t// The actor is a walker\n\t\treturn false;\n\t} else if (_mapped_vehicles_id.find(id)!= _mapped_vehicles_id.end()) {\n\t\t// The actor is a vehicle\n\t\tstd::lock_guard<std::mutex> guard(_mutex);\n\t\t// Get the position of the actor\n\t\tcarla::geom::Location location = _crowd->getActorPosition(id);\n\t\t// Compute the squared distance\n\t\tfloat squared_distance = (location - direction).SquaredLength();\n\t\t// Check if the distance is within the specified distance\n\t\tif (squared_distance < distance * distance) {\n\t\t\t// Check if the actor is near a vehicle\n\t\t\treturn _crowd->hasVehicleNear(id);\n\t\t} else {\n\t\t\t// The distance is too big\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// The actor is not found\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 51.19893834907603}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Check if the actor is in the mapped vehicles.\n\tauto it = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\t// Enter critical section.\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t// Compute the squared distance.\n\t\tfloat sq_distance = direction.squared_distance(it->second->GetLocation());\n\t\t// Check if there is a vehicle nearby.\n\t\treturn _crowd->hasVehicleNear(it->second->GetLocation(), distance, sq_distance);\n\t}\n\n\t// Check if the actor is in the mapped walkers.\n\tit = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\t// Enter critical section.\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t// Compute the squared distance.\n\t\tfloat sq_distance = direction.squared_distance(it->second->GetLocation());\n\t\t// Check if there is a vehicle nearby.\n\t\treturn _crowd->hasVehicleNear(it->second->GetLocation(), distance, sq_distance);\n\t}\n\n\t// If the actor is not found in the mapped vehicles or walkers, return false.\n\treturn false;\n}", "CodeBleu_score": 58.69160376863576}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &walker = info.walker;\n\tauto &route = info.route;\n\tauto &context = info.context;\n\tauto &current = route.at(info.current);\n\tauto &event = current.event;\n\tauto &next = route.at(info.current + 1);\n\n\tWalkerEventVisitor visitor(context, info, delta);\n\treturn boost::variant2::visit(visitor, event);\n}", "CodeBleu_score": 47.51203048215251}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the current route point\n\tRoutePoint &rp = info.route[info.route_index];\n\n\t// Create a visitor with the current context\n\tWalkerEventVisitor visitor(info, delta);\n\n\t// Execute the event at the current route point\n\tEventResult result = boost::variant2::visit(visitor, rp.event);\n\n\t// Return the result of the event execution\n\treturn result;\n}", "CodeBleu_score": 56.034938759197786}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current route point\n\tRoutePoint &rp = info.route.GetCurrent();\n\n\t// create a visitor to process the event\n\tWalkerEventVisitor visitor(info.context, info.route, delta);\n\n\t// execute the event\n\tEventResult result = boost::variant2::visit(visitor, rp.event);\n\n\t// return the result\n\treturn result;\n}", "CodeBleu_score": 54.96504325042122}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n//    std::cout << \"Parsing Lanes\" << std::endl;\n    for (pugi::xml_node road_node : xml.children(\"road\")) {\n      road::RoadId road_id = road_node.attribute(\"id\").as_int();\n\n      // Call Map Builder for Road\n      map_builder.CreateRoad(road_id);\n\n      // Lanes\n      ParseLanes(road_node, road_id, map_builder);\n    }\n  }", "CodeBleu_score": 25.64906569199932}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.currentCount == 0) {\n\t\tif (info.currentCount < info.previousCount) {\n\t\t\t// Match lost.\n\t\t\tlog_error(\"Match lost for writer with GUID 0x%016\" PRIX64 \"\", writer->getGuid().getHigh());\n\t\t} else {\n\t\t\t// Match invalid.\n\t\t\tlog_error(\"Match invalid for writer with GUID 0x%016\" PRIX64 \"\", writer->getGuid().getHigh());\n\t\t}\n\t} else {\n\t\tif (info.currentCount > info.previousCount) {\n\t\t\t// New match.\n\t\t\tlog_debug(\"New match for writer with GUID 0x%016\" PRIX64 \"\", writer->getGuid().getHigh());\n\t\t\tm_matched = true;\n\t\t} else if (info.currentCount < info.previousCount) {\n\t\t\t// Match lost.\n\t\t\tlog_debug(\"Match lost for writer with GUID 0x%016\" PRIX64 \"\", writer->getGuid().getHigh());\n\t\t} else {\n\t\t\t// Match unchanged.\n\t\t\tlog_debug(\"Match unchanged for writer with GUID 0x%016\" PRIX64 \"\", writer->getGuid().getHigh());\n\t\t}\n\t}\n}", "CodeBleu_score": 48.39213009593645}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.currentCount <= info.totalCount) {\n\t\tif (info.currentCount == 0 && info.totalCount > 0) {\n\t\t\t// Match has been lost, update count\n\t\t\tm_matchedCount = info.totalCount;\n\t\t\tm_isMatched = false;\n\t\t}\n\t\telse if (info.currentCount > 0 && info.totalCount > 0) {\n\t\t\t// Match has been found, update count\n\t\t\tm_matchedCount = info.totalCount;\n\t\t\tm_isMatched = true;\n\t\t}\n\t\telse {\n\t\t\t// Should never happen\n\t\t\tstd::string errorMsg = \"Publication matched callback received invalid current/total count: \" + std::to_string(info.currentCount) + \"/\" + std::to_string(info.totalCount);\n\t\t\tlogError(errorMsg);\n\t\t}\n\t}\n\telse {\n\t\t// Should never happen\n\t\tstd::string errorMsg = \"Publication matched callback received invalid current/total count: \" + std::to_string(info.currentCount) + \"/\" + std::to_string(info.totalCount);\n\t\tlogError(errorMsg);\n\t}\n}", "CodeBleu_score": 51.01200480939754}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tswitch (info.current_count_change) {\n\t\tcase efd::PublicationMatchedStatus::Added:\n\t\t\tm_matched_count = info.current_count;\n\t\t\tm_is_first_connection = true;\n\t\t\tbreak;\n\t\tcase efd::PublicationMatchedStatus::Removed:\n\t\t\tm_matched_count = info.current_count;\n\t\t\tbreak;\n\t\tcase efd::PublicationMatchedStatus::Changed:\n\t\t\tif (info.current_count < m_matched_count) {\n\t\t\t\tm_matched_count = info.current_count;\n\t\t\t}\n\t\t\telse if (info.current_count > m_matched_count) {\n\t\t\t\tm_matched_count = info.current_count;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//TODO: log error\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//TODO: log error\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 49.69941960220675}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 0) {\n\t\tstd::cerr << \"Error: on_subscription_matched: invalid current_count_change\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (info.current_count_change > 0) {\n\t\t// New subscription matched\n\t\tm_matched_count += info.current_count_change;\n\t\tif (!m_first_connected) {\n\t\t\tm_first_connected = true;\n\t\t\tstd::cout << \"Subscriber '\" << m_name << \"' matched\" << std::endl;\n\t\t}\n\t} else {\n\t\t// Subscription lost\n\t\tm_matched_count += info.current_count_change;\n\t\tif (m_matched_count == 0) {\n\t\t\tstd::cout << \"Subscriber '\" << m_name << \"' unmatched\" << std::endl;\n\t\t\tif (m_auto_destroy_subscriber) {\n\t\t\t\tm_subscriber_owner->DestroySubscriber();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 55.76459715239579}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\t// first connection\n\t\t\tfirst_connected = true;\n\t\t}\n\t\tmatched_count += info.current_count_change;\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_count += info.current_count_change;\n\t\tif (matched_count == 0) {\n\t\t\t// no more connections\n\t\t\t// destroy the subscriber\n\t\t\tif (this->carla_owner!= nullptr) {\n\t\t\t\tthis->carla_owner->DestroySubscriber();\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// error\n\t\tstd::stringstream error_msg;\n\t\terror_msg << \"Error: invalid change in matched count: \" << info.current_count_change;\n\t\tthis->carla_owner->LogError(error_msg.str());\n\t}\n}", "CodeBleu_score": 61.800940402641714}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.currentCount == 0 && info.totalCount == 0) {\n\t\tstd::cout << \"Subscriber matched no topics\" << std::endl;\n\t}\n\telse {\n\t\tif (info.currentCount == 0 && info.totalCount > 0) {\n\t\t\tstd::cout << \"Subscriber lost all its matched topics\" << std::endl;\n\t\t}\n\t\telse if (info.currentCount > 0 && info.totalCount == 0) {\n\t\t\tstd::cout << \"Subscriber gained a new matched topic\" << std::endl;\n\t\t}\n\t\telse if (info.currentCount > 0 && info.totalCount > 0) {\n\t\t\tstd::cout << \"Subscriber matched new topics\" << std::endl;\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"Subscriber matched unknown topics\" << std::endl;\n\t\t}\n\t}\n\n\tif (info.currentCount == 0 && info.totalCount == 0) {\n\t\t// If there are no more matched topics, then delete the subscriber\n\t\t// This is done to avoid memory leaks\n\t\tstd::cout << \"Subscriber destroyed\" << std::endl;\n\t\tm_owner->DestroySubscriber();\n\t}\n}", "CodeBleu_score": 47.89389703823388}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (force_md5) {\n\t\t// always calculate MD5, even if key is not defined\n\t\tm_md5.init();\n\t\tm_md5.update(data);\n\t\tm_md5.finalize();\n\t\t// copy MD5 hash into handle\n\t\tfor (unsigned int i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t\treturn true;\n\t} else if (m_keyReturn) {\n\t\t// copy key into handle\n\t\tm_keyReturn(data, handle);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 31.733081661157104}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tpayload->encapsulation = Endianness::LITTLE_ENDIAN;\n\tpayload->parentBuffer = reinterpret_cast<uint8_t*>(data);\n\tpayload->parentBufferLen = getSerializedDataLength();\n\tCdr cdr_serialize;\n\tif (cdrSerialize(data, payload, &cdr_serialize)!= RTI_TRUE) { return false; }\n\treturn true;\n}", "CodeBleu_score": 24.519839757148564}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tpayload->encapsulation = LE_BIG_ENDIAN;\n\tpayload->parentBuffer = reinterpret_cast<char*>(data);\n\tpayload->parentBufferLength = getSerializedDataLength();\n\tpayload->data = payload->parentBuffer;\n\tpayload->length = payload->parentBufferLength;\n\treturn OSPL_SERIALIZE_OK;\n}", "CodeBleu_score": 17.999909012984936}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\treturn serialize(static_cast<CarlaEgoVehicleControl*>(data), payload);\n}", "CodeBleu_score": 13.053805462042966}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (sysid_target!= 0)\n\t\treturn;\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_HEARTBEAT: {\n\t\tmavlink_heartbeat_t hb;\n\t\tmavlink_msg_heartbeat_decode(&msg, &hb);\n\t\tif (hb.system_status == MAV_STATE_ACTIVE) {\n\t\t\tsysid_target = hb.sysid;\n\t\t\trequest_datastream_position();\n\t\t\trequest_datastream_airpressure();\n\t\t\tsysid_target_set = true;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MAVLINK_MSG_ID_SYS_STATUS: {\n\t\tmavlink_sys_status_t sys_status;\n\t\tmavlink_msg_sys_status_decode(&msg, &sys_status);\n\t\tif (sys_status.onboard_control_sensors_present & (1 << MAV_SENSOR_AIRSPEED)) {\n\t\t\trequest_datastream_airspeed();\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 36.485872732214254}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Check if the target is already set\n\tif (sysid_target!= 0)\n\t\treturn;\n\n\t// Decode the MAVLink message\n\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n\t// Check if the message type is one that should be tracked\n\tif (heartbeat.type!= MAV_TYPE_GCS && heartbeat.type!= MAV_TYPE_ONBOARD_CONTROLLER)\n\t\treturn;\n\n\t// Set the sysid to the target\n\tsysid_target = heartbeat.sysid;\n\n\t// Request position and air pressure data streams from the target\n\trequest_datastream_position();\n\trequest_datastream_airpressure();\n\n\t// Flag that the target has been set\n\ttarget_set = true;\n}", "CodeBleu_score": 29.553352971970327}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (sysid_target == msg.sysid) {\n\t\treturn;\n\t}\n\n\tif (msg.msgid == MAVLINK_MSG_ID_HEARTBEAT) {\n\t\tmavlink_heartbeat_t hb;\n\t\tmavlink_msg_heartbeat_decode(&msg, &hb);\n\t\tif (hb.type == MAV_TYPE_GCS) {\n\t\t\tsysid_target = msg.sysid;\n\t\t\trequest_datastream_position(MAV_DATA_STREAM_POSITION);\n\t\t\trequest_datastream_airpressure(MAV_DATA_STREAM_RAW_SENSORS);\n\t\t\ttarget_set = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.60137800668822}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\treturn GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 20.960702083402794}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\treturn GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 20.960702083402794}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\treturn GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 20.960702083402794}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.2721093401741}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.29383879107523}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\tif (packet.param2 == 0.0f) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t}\n\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 33.89534302760045}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tif (num_gcs == 0) {\n\t\treturn;\n\t}\n\n\t// send request to start streaming position data\n\tfor (uint8_t i = 0; i < num_gcs; i++) {\n\t\tif (gcs[i].mavlink_fd!= -1 && gcs[i].payload_space > 100) {\n\t\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, sysid, compid, MAV_DATA_STREAM_POSITION, 20, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.84080754629375}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t#if!defined(MAVLINK_USE_CONVENIENCE_FUNCTIONS)\n    mavlink_message_t msg;\n    mavlink_msg_request_data_stream_pack(sysid, compid, &msg, MAV_DATA_STREAM_POSITION, 10, 0);\n    mavlink_send_uart(MAVLINK_COMM_0, &msg);\n#else\n    mavlink_msg_request_data_stream_send(MAVLINK_COMM_0, sysid, compid, MAV_DATA_STREAM_POSITION, 10);\n#endif\n}", "CodeBleu_score": 33.80068081907331}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < MAVLINK_COMM_NUM_BUFFERS; i++) {\n\t\tif (_mavlink_comm_0_tx_buf[i].len < MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN) {\n\t\t\tmavlink_msg_request_data_stream_send_buf(_mavlink_comm_0_tx_buf + i, sysid, compid, MAV_DATA_STREAM_POSITION, 10, 0);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.19295769198913}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch!= 0.0f) {\n\t\tef_pitch = atan2f(ahrs.sin_pitch, ahrs.cos_pitch);\n\t\tef_yaw = yaw + ahrs.yaw_ef;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 29.339794945748103}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch!= 0.0f) {\n\t\tef_pitch = pitch - ahrs.sin_pitch * yaw;\n\t\tef_yaw = yaw * ahrs.cos_pitch;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 34.38594720621747}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch!= 0.0f) {\n\t\tef_pitch = pitch - ahrs.sin_roll * yaw;\n\t\tef_yaw = yaw * ahrs.cos_pitch + ahrs.sin_roll * pitch;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.488589898798864}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// calculate target yaw and pitch in centidegrees\n\t// note: the yaw is the bearing to the target, the pitch is the distance to the target\n\tstruct Tracker::NavStatus &nav_status = tracker.nav_status;\n\tfloat yaw = nav_status.bearing * 100;\n\tfloat pitch = nav_status.distance * 100;\n\n\t// check if the direction is reversed\n\tbool direction_reversed = get_ef_yaw_direction();\n\n\t// calculate angle error\n\tcalc_angle_error(pitch, yaw, direction_reversed);\n\n\t// convert earth frame to body frame angle error\n\tParameters &g = tracker.g;\n\tfloat bf_pitch_err = g.pidPitch2Srv.get_error();\n\tfloat bf_yaw_err = g.pidYaw2Srv.get_error();\n\n\t// if the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly\n\tif (nav_status.distance > 0 || g.min_dist == 0) {\n\t\ttracker.update_pitch_servo(bf_pitch_err);\n\t\ttracker.update_yaw_servo(bf_yaw_err);\n\t}\n}", "CodeBleu_score": 53.18207903679997}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t\t// if the target is valid or we don't have a minimum distance set, update the pitch and yaw servos\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    if (nav_status.distance_valid || nav_status.distance < tracker.g.min_distance) {\n        // calculate the yaw and pitch angles in centidegrees\n        float pitch = nav_status.pitch * 100;\n        float yaw = nav_status.bearing * 100;\n\n        // check if the direction is reversed\n        bool direction_reversed = get_ef_yaw_direction();\n\n        // calculate the angle error\n        calc_angle_error(pitch, yaw, direction_reversed);\n\n        // update the pitch and yaw servos\n        tracker.update_pitch_servo();\n        tracker.update_yaw_servo();\n    }\n}", "CodeBleu_score": 43.8328853125552}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS data\n\tgps.update();\n\n\t// If the last message time has changed, check if the GPS status is at least 3D fix\n\tif (gps.last_message_time_ms!= last_gps_message_time_ms) {\n\t\tlast_gps_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= GPS::GPS_FIX_3D) {\n\t\t\t// If the GPS status is at least 3D fix, set the home location\n\t\t\tif (home_location_set == false) {\n\t\t\t\tset_home();\n\t\t\t}\n\t\t} else {\n\t\t\t// If the GPS status is less than 3D fix, reset the countdown\n\t\t\tcountdown_to_ground_start = 0;\n\t\t}\n\t}\n\n\t// If the countdown to ground start is not zero, decrement it\n\tif (countdown_to_ground_start > 0) {\n\t\tcountdown_to_ground_start--;\n\t}\n}", "CodeBleu_score": 33.82298194251538}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update GPS\n\tgps.update();\n\n\t// Check if the last message time has changed\n\tif (gps.last_message_time_ms!= last_gps_message_time_ms) {\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (gps.status >= 3) {\n\t\t\t// Check if the countdown is at zero\n\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t// Check if the current location is valid\n\t\t\t\tif (gps.location.is_valid()) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\tset_home(gps.location);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Decrement the countdown\n\t\t\t\tground_start_countdown--;\n\t\t\t}\n\t\t} else {\n\t\t\t// Reset the countdown\n\t\t\tground_start_countdown = 0;\n\t\t}\n\n\t\t// Store the last message time\n\t\tlast_gps_message_time_ms = gps.last_message_time_ms;\n\t}\n}", "CodeBleu_score": 35.08732658430533}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= _last_gps_message_time_ms) {\n\t\t_last_gps_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (_ground_start_countdown > 0) {\n\t\t\t\t_ground_start_countdown--;\n\t\t\t} else {\n\t\t\t\tif (gps.location.is_valid()) {\n\t\t\t\t\tset_home();\n\t\t\t\t} else {\n\t\t\t\t\t_ground_start_countdown = _ground_start_countdown_max;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.75485853624001}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch < 0.0f) {\n\t\tpitch = 0.0f;\n\t} else if (pitch > 1.0f) {\n\t\tpitch = 1.0f;\n\t}\n\n\t// update the pitch\n\t_pitch = pitch;\n\n\t// update the pitch servo\n\t_pitch_servo.set(pitch);\n}", "CodeBleu_score": 12.727001023456285}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\t_pitch_onoff_servo.set_channel_pwm(0, 1000);\n\t} else {\n\t\t_pitch_onoff_servo.set_channel_pwm(0, 2000);\n\t}\n}", "CodeBleu_score": 13.5374502911764}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class barometer_checks\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\t// check barometer altitude\n\tif (ARMING_CHECK_BARO &&!check_baro_alt()) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 16.708803620010166}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool ret = true;\n\n\t// check barometer altitude\n\tif (AP_Param::setup_check_enabled(AP_Param::Param_AP_ARMING_CHECK_BARO)) {\n\t\tfloat baro_alt = copter.inertial_nav.get_position_z_up_cm();\n\t\tif (baro_alt > 0) {\n\t\t\tif (fabsf(baro_alt - copter.inertial_nav.get_altitude_cm()) > AP_Param::setup_get_float(AP_Param::Param_AP_ARMING_CHECK_BARO_MAX_DIFF)) {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\tAP_HAL::console->printf(\"Barometer altitude is too different from inertial navigation altitude\n\");\n\t\t\t\t}\n\t\t\t\tret = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::console->printf(\"Barometer altitude is not valid\n\");\n\t\t\t}\n\t\t\tret = false;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 46.397880438449114}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t", "CodeBleu_score": 2.150221949863861}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\t// If the terrain source is from a rangefinder, it returns false.\n\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::TERRAIN_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\t// If the terrain source is from the terrain database and the RTL altitude type is terrain, it returns true.\n\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::TERRAIN_DATABASE && copter.mode_rtl.get_alt_type() == AP_Mode_RTL::ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\n\t// Otherwise, it defers to the base class implementation of terrain_database_required.\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 73.27412016966609}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_Terrain::SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (copter.wp_nav->get_terrain_source() == AP_Terrain::SOURCE_TERRAIN_DB && copter.mode_rtl.get_alt_type() == AP_Mode_RTL::ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 72.5888878647509}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_Waypoint::TERRAIN_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (copter.wp_nav->get_terrain_source() == AP_Waypoint::TERRAIN_DATABASE && copter.mode_rtl.get_alt_type() == AP_Mode_RTL::ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 72.9630632111978}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time for the rate controllers\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// Run the low-level rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 47.2679269595788}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for the rate controllers\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// run the low-level rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 47.2679269595788}, {"code": "void Copter::run_rate_controller(){\n\t\t// get loop time\n\tconst float dt = AP::scheduler().get_last_loop_time_s();\n\n\t// set dt for rate controllers\n\tattitude_control->set_dt(dt);\n\tpos_control->set_dt(dt);\n\tmotors->set_dt(dt);\n\n\t// run rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 67.80363527922775}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.same_loc_as(new_loc) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\tset_target_location(new_loc);\n\n\treturn true;\n}", "CodeBleu_score": 53.42278453171584}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// get the next waypoint location\n\tLocation wp_loc = flightmode->get_wp();\n\n\t// check if the old location matches the waypoint location and if the altitude frames of the old and new locations are the same\n\tif (!old_loc.same_loc_as(wp_loc) || old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\treturn mode_guided.set_destination(new_loc);\n}", "CodeBleu_score": 66.13812283583881}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if the altitude frames of the old and new locations are not the same\n\tif (!old_loc.same_alt_as(new_loc)) {\n\t\treturn false;\n\t}\n\n\t// exit if the old location is the same as the next waypoint\n\tif (old_loc.same_loc_as(new_loc)) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\treturn set_target_location(new_loc);\n}", "CodeBleu_score": 58.05544021572331}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (copter.flightmode->mode_number!= mode) {\n\t\t\tcopter.set_mode(mode);\n\t\t}\n\t} else if (copter.flightmode->mode_number == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 58.087777650913864}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode!= copter.flightmode->mode_number) {\n\t\t\tcopter.set_mode(mode);\n\t\t}\n\t} else {\n\t\tif (mode == copter.flightmode->mode_number) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 56.09677568949591}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode!= flight_mode) {\n\t\t\tif (copter.set_mode(mode)) {\n\t\t\t\trc().reset_mode_switch();\n\t\t\t}\n\t\t}\n\t} else if (flight_mode == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 57.30329230983522}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// get the trim values from the control inputs\n\tfloat roll_trim = channel_roll->get_control_in() / 100.0f;\n\tfloat pitch_trim = channel_pitch->get_control_in() / 100.0f;\n\n\t// convert the trim values to radians\n\troll_trim = ToRad(roll_trim);\n\tpitch_trim = ToRad(pitch_trim);\n\n\t// add the trim values to the AHRS trim\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(MAV_SEVERITY_INFO, \"Trim saved\");\n\n\t// send a confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 65.41604947956256}, {"code": "void Copter::save_trim(){\n\t\t// get_control_in\n\t// get_control_in\n\t// ToRad\n\t// ToRad\n\t// ahrs.add_trim\n\t// LOGGER_WRITE_EVENT\n\t// gcs().send_text\n}", "CodeBleu_score": 2.7694730809033348}, {"code": "void Copter::save_trim(){\n\t\tfloat roll_trim = (channel_roll->get_control_in() - 1500) * ToRad;\n\tfloat pitch_trim = (channel_pitch->get_control_in() - 1500) * ToRad;\n\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\tmavlink_log_event(MAV_SEVERITY_INFO, LOG_ID_SYSTEM_CALIBRATION, 0, \"Trim saved\");\n}", "CodeBleu_score": 58.49444636100033}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity\n\tconst Vector2f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n\t// Calculate the speed squared\n\tconst float speed_squared = vel.length_squared();\n\n\t// Check if the copter's position is valid and the speed exceeds a minimum threshold\n\tif (copter.position_ok && speed_squared > sq(MIN_SPEED_FOR_LOOK_AHEAD_YAW)) {\n\t\t// Update the look-ahead yaw angle using the arctangent of the velocity components\n\t\t_look_ahead_yaw = atan2f(vel.x(), vel.y());\n\t}\n\n\t// Return the computed look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}", "CodeBleu_score": 56.760381257394435}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Calculate the speed squared\n\tfloat speed_squared = vel.xy().length_squared();\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (copter.position_ok && speed_squared > MIN_SPEED_SQUARED) {\n\t\t// Calculate the look-ahead yaw angle\n\t\tlook_ahead_yaw_rad = atan2f(vel.x, vel.y);\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn look_ahead_yaw_rad;\n}", "CodeBleu_score": 35.668146636161445}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity\n\tconst Vector3f vel = _copter.inertial_nav.get_velocity_neu_cms();\n\n\t// Calculate the speed squared\n\tfloat speed_squared = vel.xy().length_squared();\n\n\t// Check if the copter's position is valid and the speed exceeds a minimum threshold\n\tif (_copter.position_ok() && speed_squared > _min_speed_squared) {\n\t\t// Update the look-ahead yaw angle using the arctangent of the velocity components\n\t\t_look_ahead_yaw = atan2f(vel.x(), vel.y());\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}", "CodeBleu_score": 54.76933766988362}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (gcs().get_rudder_arming_type() == AP_GCS::RUD_ARM_DISABLED || plane.get_throttle_input()!= 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 34.38936452496102}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// If we are using the rudder method, we need to check if rudder arming is disabled or if the throttle is not zero\n\tif (method == AP_Arming::RUDDER) {\n\t\t// If the rudder arming is disabled, return false\n\t\tif (rudder_arming_type == AP_Arming::RUDDER_DISABLED) {\n\t\t\treturn false;\n\t\t}\n\t\t// If the throttle is not zero, return false\n\t\tif (plane.get_throttle_input()!= 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If arming checks are disabled or the watchdog was armed, bypass the checks and return true\n\tif (arming_checks_disabled || hal.util->was_watchdog_armed) {\n\t\treturn true;\n\t}\n\t// Otherwise, call the parent class's arm_checks method and return the result\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 42.66362301662047}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (!gcs().rudder_arming_enabled() || plane.get_throttle_input() > 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 33.205336576502404}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if HAL_QUADPLANE_ENABLED\n    if (plane.quadplane.is_armed()) {\n        return false;\n    }\n#endif\n    if (do_arming_checks) {\n        if (!check_arming_checks()) {\n            return false;\n        }\n    }\n    if (method == AP_Arming::Method::GPS) {\n        if (!arm_gps()) {\n            return false;\n        }\n    } else if (method == AP_Arming::Method::BARO) {\n        if (!arm_baro()) {\n            return false;\n        }\n    } else if (method == AP_Arming::Method::HOME) {\n        if (!arm_home()) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n    plane.update_home();\n    plane.ahrs.set_home();\n    plane.update_current_loc();\n    send_arm_disarm_statustext();\n    plane.set_armed(true);\n    plane.set_delay_arm(true);\n    return true;\n}", "CodeBleu_score": 42.7372691655891}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if HAL_QUADPLANE_ENABLED\n    if (plane.quadplane.get_armed()) {\n        return false;\n    }\n#endif\n\n    if (do_arming_checks) {\n        if (!check_arming_checks()) {\n            return false;\n        }\n    }\n\n    if (method == AP_Arming::Method::ARM_WHEN_DISARMED) {\n        if (plane.get_arm_state()!= AP_Arming::ARM_STATE_DISARMED) {\n            return false;\n        }\n    }\n\n    // arm the plane\n    plane.set_arm_state(AP_Arming::ARM_STATE_ARMED);\n    plane.update_home();\n    plane.ahrs.set_home();\n    plane.update_current_loc();\n    send_arm_disarm_statustext(true);\n\n    // set delay arming flag\n    plane.set_delay_arming(true);\n\n    return true;\n}", "CodeBleu_score": 45.10997536961499}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t", "CodeBleu_score": 4.868891087689006}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\n//    if (AP_InertialSensor::is_armed()) {\n//        if (display_failure) {\n//            sub.display_failure_message(PX4_CUSTOM_MAIN_MESSAGE_ARMING_ALREADY_ARMED);\n//        }\n//        return false;\n//    }\n\n//    if (!has_disarm_function()) {\n//        if (display_failure) {\n//            sub.display_failure_message(PX4_CUSTOM_MAIN_MESSAGE_ARMING_NO_DISARM_FUNCTION);\n//        }\n//        return false;\n//    }\n\n//    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 5.0055234894778735}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t#if!defined(CONFIG_ARCH_BOARD_PX4)\n    // check if the vehicle is already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // check if the vehicle is already disarmed\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            // if the vehicle is already disarmed, display a failure message\n            display_failure_message();\n        }\n        return false;\n    }\n#endif\n\n    // call the base class pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 67.10290954455347}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * ahrs.cos_yaw + y * ahrs.sin_yaw;\n\tfloat ne_y = y * ahrs.cos_yaw - x * ahrs.sin_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 64.76818684010604}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = cos(ahrs.yaw) * x - sin(ahrs.yaw) * y;\n\tfloat ne_y = sin(ahrs.yaw) * x + cos(ahrs.yaw) * y;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 58.23017058706937}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos_yaw + y * sin_yaw;\n\tfloat ne_y = -x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 54.55934643444018}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 3.5541344618719917}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param4 < -180 || packet.param4 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param3 < 0 || packet.param3 > 100) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param1 < 0 || packet.param1 > 100) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param2 < -100 || packet.param2 > 100) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param1 == 0 && packet.param2 == 0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param3 == 0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t_sub.mode_auto.set_auto_yaw_look_at_heading(packet.param4);\n\t_sub.mode_auto.set_auto_yaw_speed(packet.param1);\n\t_sub.mode_auto.set_auto_yaw_look_at_heading_tolerance(packet.param2);\n\t_sub.mode_auto.set_auto_yaw_look_at_heading_tolerance_speed(packet.param3);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 47.116021331508776}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 3.5541344618719917}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tuint8_t out = 0;\n\tuint16_t wp_nav_get_wp_bearing_to_destination_out = 0;\n\twp_nav_get_wp_bearing_to_destination_out = wp_nav.get_wp_bearing_to_destination();\n\tif (wp_nav_get_wp_bearing_to_destination_out > 18000) {\n\t\twp_nav_get_wp_bearing_to_destination_out -= 36000;\n\t}\n\tif (wp_nav_get_wp_bearing_to_destination_out < -18000) {\n\t\twp_nav_get_wp_bearing_to_destination_out += 36000;\n\t}\n\tout = (wp_nav_get_wp_bearing_to_destination_out / 2);\n\treturn out;\n}", "CodeBleu_score": 38.354487138367375}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.150400996515202}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn mavlink_high_latency_tgt_heading(this);\n}", "CodeBleu_score": 6.363067799664818}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tAP_HAL::micros64 time = AP_HAL::micros64();\n\t\tLog_Packet_Header header;\n\t\theader.time = time;\n\t\theader.data_id = id;\n\t\theader.value = value;\n\t\tlogger.WriteCriticalBlock(&header, sizeof(header));\n\t}\n}", "CodeBleu_score": 40.631447022232}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tAP_HAL::micros64 now = AP_HAL::micros64();\n\t\tLogPacketHeader header;\n\t\theader.time = now;\n\t\theader.id = id;\n\t\theader.value = value;\n\t\tlogger.WriteCriticalBlock(header, sizeof(header));\n\t}\n}", "CodeBleu_score": 37.12559175069304}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tLog_Packet_Header header;\n\t\theader.timestamp = AP_HAL::micros64();\n\t\theader.data_id = id;\n\t\theader.value = value;\n\t\tlogger.WriteCriticalBlock(header, sizeof(Log_Packet_Header));\n\t}\n}", "CodeBleu_score": 37.267469701514926}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (!home_is_set) {\n\t\tif (motors.armed) {\n\t\t\tset_home_to_current_location_inflight();\n\t\t} else {\n\t\t\tset_home_to_current_location(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.417915325976477}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (!ahrs.home_is_set()) {\n\t\tif (motors.armed()) {\n\t\t\tset_home_to_current_location_inflight();\n\t\t} else {\n\t\t\tset_home_to_current_location(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.54884154520296}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 35.44929049008199}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!_motors.armed()) {\n\t\t_motors.set_throttle_out(0.0f);\n\t\t_motors.set_desired_spool_state(SpoolState::UnlimitedThrottle);\n\t\t_attitude_control.relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t_motors.set_desired_spool_state(SpoolState::UnlimitedThrottle);\n\t_attitude_control.set_throttle_out(_channel_throttle.norm_input());\n\t_attitude_control.input_rate_bf_roll_pitch_yaw(_channel_roll.get_control_in(), _channel_pitch.get_control_in(), _channel_yaw.get_control_in());\n\t_attitude_control.run();\n\n\t_motors.set_forward(_channel_forward.norm_input());\n\t_motors.set_lateral(_channel_lateral.norm_input());\n}", "CodeBleu_score": 43.397181829591695}, {"code": "void ModeAcro::run(){\n\t\t// If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit\n\tif (!motors.armed()) {\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(SpoolState::UnlimitedThrottle);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t// Set the spool state to unlimited throttle\n\tmotors.set_desired_spool_state(SpoolState::UnlimitedThrottle);\n\n\t// Convert pilot inputs to desired body frame rates\n\tattitude_control->input_rate_bf_roll_pitch_yaw(get_pilot_desired_angle_rates());\n\n\t// Run the attitude controller with these rates\n\tattitude_control->run();\n\n\t// Output the pilot's throttle input without angle boost\n\tmotors.set_throttle(channel_throttle->get_control_in());\n\n\t// Set the forward and lateral motor inputs based on pilot controls\n\tmotors.set_forward(channel_forward->get_control_in());\n\tmotors.set_lateral(channel_lateral->get_control_in());\n}", "CodeBleu_score": 41.29691371252168}, {"code": "void ModeAcro::run(){\n\t\tif (_motors->armed()) {\n\t\t// Set spool state to unlimited throttle\n\t\t_motors->set_desired_spool_state(SpoolState::UnlimitedThrottle);\n\n\t\t// Convert pilot inputs to desired body frame rates\n\t\tget_pilot_desired_angle_rates();\n\n\t\t// Run attitude controller\n\t\tattitude_control->run();\n\n\t\t// Set motor inputs\n\t\tmotors.set_lateral(channel_lateral->get_control_in());\n\t\tmotors.set_forward(channel_forward->get_control_in());\n\t\tmotors.set_desired_spool_state(SpoolState::UnlimitedThrottle);\n\t} else {\n\t\t// Set throttle to zero\n\t\tmotors.set_throttle(0.0f);\n\n\t\t// Set spool state to unlimited throttle\n\t\t_motors->set_desired_spool_state(SpoolState::UnlimitedThrottle);\n\n\t\t// Relax attitude controllers\n\t\tattitude_control->relax_attitude_controllers();\n\n\t\t// Exit\n\t\treturn;\n\t}\n\n\t// Set throttle\n\tmotors.set_throttle(channel_throttle->get_control_in());\n}", "CodeBleu_score": 45.03414268514407}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the mode to position control mode\n\tset_mode(POSITION);\n\n\t// Get the stopping point\n\t// set_wp_destination will initialise the waypoint controller\n\t// and set the default auto yaw mode\n\tset_wp_destination(get_stopping_point());\n}", "CodeBleu_score": 5.524655315811604}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set to position control mode\n\tg.control_mode = GUIDED;\n\t// initialize the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n\t// get the stopping point\n\tsub.wp_nav.get_wp_stopping_point();\n\t// set the waypoint destination to the stopping point\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\t// set the auto yaw mode to the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 48.002288211798344}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set to position control mode\n\tg.pos_mode = POS_MODE_GUIDED;\n\n\t// initialize wpnav\n\tsub.wp_nav.wp_and_spline_init();\n\n\t// get the stopping point\n\tsub.wp_nav.set_wp_stopping_point();\n\n\t// set the waypoint destination to the stopping point\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\n\t// initialize yaw\n\tsub.auto_yaw_mode = get_default_auto_yaw_mode(false);\n\tset_auto_yaw_mode(sub.auto_yaw_mode);\n}", "CodeBleu_score": 45.50898256050615}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set the guided mode to velocity controller\n\tsub.guided_mode = GUIDED_MODE_VEL_CONTROL;\n\n\t// initialize vertical maximum speeds and acceleration using pilot-defined parameters\n\tposition_control->init_max_speed_accel_z();\n\n\t// initialize vertical and horizontal velocity controllers\n\tposition_control->init_xy_controller();\n\n\t// set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 31.020763907389544}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set guided mode to velocity control\n\tsub.guided_mode = GUIDED_MODE_VELOCITY;\n\n\t// set vertical maximum speeds and acceleration using pilot-defined parameters\n\tposition_control->set_max_speed_accel_z(sub.max_climb_rate, sub.max_descend_rate, sub.max_climb_accel, sub.max_descend_accel);\n\n\t// initialize vertical and horizontal velocity controllers\n\tposition_control->init_xy_controller();\n\tposition_control->init_z_controller();\n\n\t// set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 46.26786748565178}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical speeds and accelerations\n\tposition_control->init_z_controller();\n\tposition_control->set_max_speed_accel_z();\n\tposition_control->set_correction_speed_accel_z();\n\n\t// initialize horizontal speeds and accelerations\n\tposition_control->init_xy_controller();\n\tposition_control->set_max_speed_accel_xy();\n\tposition_control->set_correction_speed_accel_xy();\n\n\t// initialize yaw control\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 39.21209876589315}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if the guided mode timeout has been exceeded\n\tif (millis() - guided_start_time > guided_timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is below the minimum threshold\n\tif (curr_pos.alt < guided_limit.min_alt) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is above the maximum threshold\n\tif (curr_pos.alt > guided_limit.max_alt) {\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the limit\n\tfloat horizontal_distance = sqrt(pow(curr_pos.x - guided_limit.start_pos.x, 2) + pow(curr_pos.y - guided_limit.start_pos.y, 2));\n\tif (horizontal_distance > guided_limit.max_horizontal_distance) {\n\t\treturn true;\n\t}\n\n\t// If none of the conditions are met, return false\n\treturn false;\n}", "CodeBleu_score": 44.007374381955934}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// If the current altitude is below the minimum altitude threshold, terminate guided mode and return true.\n\tif (curr_pos.alt < guided_limit.min_alt) {\n\t\treturn true;\n\t}\n\n\t// If the current altitude is above the maximum altitude threshold, terminate guided mode and return true.\n\tif (curr_pos.alt > guided_limit.max_alt) {\n\t\treturn true;\n\t}\n\n\t// If the horizontal distance moved exceeds the horizontal distance limit, terminate guided mode and return true.\n\tif (get_horizontal_distance_cm() > guided_limit.max_dist) {\n\t\treturn true;\n\t}\n\n\t// If the timeout has been exceeded, terminate guided mode and return true.\n\tif (AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false.\n\treturn false;\n}", "CodeBleu_score": 32.02671304825034}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tif (guided_limit.timeout_ms!= 0 && millis() - guided_limit.start_time_ms > guided_limit.timeout_ms) {\n\t\treturn true;\n\t}\n\tif (guided_limit.min_alt_cm!= 0 && curr_pos.alt_cm < guided_limit.min_alt_cm) {\n\t\treturn true;\n\t}\n\tif (guided_limit.max_alt_cm!= 0 && curr_pos.alt_cm > guided_limit.max_alt_cm) {\n\t\treturn true;\n\t}\n\tif (guided_limit.max_horiz_dist_cm!= 0 && guided_limit.start_pos.xy.distance_cm(curr_pos.xy) > guided_limit.max_horiz_dist_cm) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.65646381185363}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}, {"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}, {"code": "bool Sub::verify_motor_test(){\n\t\t// TODO: Implement\n\treturn false;\n}", "CodeBleu_score": 4.877943950406589}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = constrain_int16(wp_nav.get_roll(), -max_angle, max_angle);\n\tfloat pitch_target = constrain_int16(wp_nav.get_pitch(), -max_angle, max_angle);\n\t// normalize and constrain\n\tfloat roll_norm = roll_target / max_angle;\n\tfloat pitch_norm = pitch_target / max_angle;\n\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 36.51686434677681}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_norm = constrain_int16(wp_nav.get_roll(), -10000, 10000);\n\tfloat pitch_norm = constrain_int16(wp_nav.get_pitch(), -10000, 10000);\n\n\t// TODO: constrain roll_norm and pitch_norm to a maximum angle range.\n\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 29.746556852924087}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Retrieve roll and pitch targets from wp_nav in centidegrees.\n\tfloat roll_target = wp_nav.get_roll();\n\tfloat pitch_target = wp_nav.get_pitch();\n\n\t// Constrain roll and pitch targets within a specified maximum angle range.\n\tconstrain_int16(roll_target, -max_angle, max_angle);\n\tconstrain_int16(pitch_target, -max_angle, max_angle);\n\n\t// Normalize roll and pitch targets.\n\tfloat roll_target_normalized = roll_target / max_angle;\n\tfloat pitch_target_normalized = pitch_target / max_angle;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out.\n\tlateral_out = roll_target_normalized;\n\tforward_out = pitch_target_normalized;\n}", "CodeBleu_score": 44.688565690289}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// Get the altitude from the barometer\n\tfloat altitude = _barometer.get_altitude();\n\n\t// If the altitude is above zero, update the barometer calibration\n\tif (altitude > 0) {\n\t\t_barometer.update_calibration();\n\t}\n\n\t// If a depth sensor is present, update the sensor health status based on the barometer's health\n\tif (_depth_sensor!= nullptr) {\n\t\t_depth_sensor->update_health(altitude);\n\t}\n}", "CodeBleu_score": 49.681815117996486}, {"code": "void Sub::read_barometer(){\n\t\tif (altitude > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor.healthy) {\n\t\tbarometer.healthy = barometer.healthy && barometer.get_altitude() < 1000;\n\t}\n}", "CodeBleu_score": 63.35879163666125}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor.healthy()) {\n\t\tbarometer.set_healthy(true);\n\t}\n}", "CodeBleu_score": 55.857080278234605}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\tif (inertial_nav.get_filter_status() == INERTIAL_NAV_FILTER_STATUS_CONSTANT_POSITION) {\n\t\treturn false;\n\t}\n\n\treturn ahrs.get_position_ok();\n}", "CodeBleu_score": 32.91501928477507}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\tif (ahrs.get_filter_status() == AHRS_FILTER_OK) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 30.49715923350321}, {"code": "bool Sub::ekf_position_ok(){\n\t\treturn inertial_nav.get_filter_status() && (motors.armed || (ahrs.have_inertial_nav && ahrs.get_pos_ok()));\n}", "CodeBleu_score": 22.471639968147773}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (!rover.ahrs.system_ok) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"AHRS system not ready\";\n\t\t}\n\t\treturn false;\n\t}\n\tif (rover.ekf_position_ok) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"EKF failsafe active\";\n\t\t}\n\t\treturn false;\n\t}\n\tif (!rover.ahrs.is_valid_position) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"Invalid position estimate\";\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 41.6984138770477}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t}", "CodeBleu_score": 2.0028291728706065}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (rover.control_mode->requires_position || rover.control_mode->requires_velocity) {\n\t\treturn false;\n\t}\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (!ahrs.pre_arm_check(display_failure)) {\n\t\treturn false;\n\t}\n\tif (!rover.ekf_position_ok) {\n\t\tif (display_failure) {\n\t\t\tdisplay.printf_P(PSTR(\"GPS check failed: EKF position estimate not valid\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 37.06923592136945}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\tbool result = false;\n\n\tswitch (method) {\n\tcase AP_Arming::Method::RTL:\n\t\tresult = arm_rtl();\n\t\tbreak;\n\n\tcase AP_Arming::Method::Simple:\n\t\tresult = arm_simple();\n\t\tbreak;\n\n\tcase AP_Arming::Method::Simple_No_Checks:\n\t\tresult = arm_simple_no_checks();\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!result) {\n\t\tset_arming_failed(true);\n\t\treturn false;\n\t}\n\n\tset_arming_failed(false);\n\n\tif (do_arming_checks) {\n\t\tif (!check_armed()) {\n\t\t\tset_arming_failed(true);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tset_arming_failed(false);\n\n\tif (method == AP_Arming::Method::RTL) {\n\t\tset_home();\n\t\tinit_heading();\n\t\trecord_home_heading();\n\t}\n\n\tupdate_soft_armed();\n\tsend_arm_disarm_statustext();\n\n\treturn true;\n}", "CodeBleu_score": 41.466598831520685}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t#ifdef DEBUG\n    Serial.println(\"updateChargingEnabled\");\n#endif\n\n    if (charging_enabled) {\n        if (!charging_allowed) {\n            // Disabling charging\n            charging_enabled = false;\n            charging_disabled_time = millis();\n        } else if (checkShouldCharge()) {\n            // Disabling charging\n            charging_enabled = false;\n            charging_disabled_time = millis();\n        }\n    } else {\n        if (charging_allowed && checkShouldCharge()) {\n            // Enabling charging\n            charging_enabled = true;\n            charging_disabled_time = 0;\n        } else if (!charging_allowed && millis() - charging_disabled_time > charging_retry_delay) {\n            // Retry enabling charging\n            charging_enabled = true;\n            charging_disabled_time = 0;\n        }\n    }\n}", "CodeBleu_score": 56.0996020229683}, {"code": "void updateChargingEnabled(){\n\t#ifdef DEBUG\n    Serial.println(\"updateChargingEnabled\");\n#endif\n\n    if (charging_allowed) {\n        if (status_message.charging_enabled) {\n            if (status_message.charging_current > 1.5 || status_message.v_battery > 29.0 || status_message.v_charge > 30.0) {\n                disableCharging();\n            }\n        } else {\n            if (checkShouldCharge()) {\n                enableCharging();\n            }\n        }\n    } else {\n        if (status_message.charging_enabled) {\n            disableCharging();\n        } else {\n            if (millis() - last_charging_enabled_check > 5000) {\n                last_charging_enabled_check = millis();\n                if (checkShouldCharge()) {\n                    enableCharging();\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 46.59338340076118}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_enabled &&!charging_allowed) {\n\t\tcharging_enabled = false;\n\t\tdigitalWrite(PIN_CHARGE_ENABLE, LOW);\n\t\tcharging_retry_time = millis() + charging_retry_delay;\n\t\tcharging_disabled_time = millis();\n\t} else if (!charging_enabled && charging_allowed) {\n\t\tif (millis() > charging_retry_time) {\n\t\t\tif (checkShouldCharge()) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tdigitalWrite(PIN_CHARGE_ENABLE, HIGH);\n\t\t\t\tcharging_retry_time = 0;\n\t\t\t} else {\n\t\t\t\tcharging_retry_time = millis() + charging_retry_delay;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 53.06539758248906}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok() && size >= 4) {\n\t\tuint8_t *buffer = (uint8_t *) message;\n\t\tuint16_t crc = CRC16.ccitt(buffer, size - 2);\n\t\tbuffer[size - 2] = crc >> 8;\n\t\tbuffer[size - 1] = crc & 0xff;\n\t\tpacketSerial.send(buffer, size);\n\t}\n}", "CodeBleu_score": 53.710278201605874}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok() && size >= 4) {\n\t\tuint8_t *msg = (uint8_t*)message;\n\t\tuint8_t crc[2];\n\t\tCRC16.ccitt(crc, msg, size - 2);\n\t\tpacketSerial.send(msg, size);\n\t}\n}", "CodeBleu_score": 35.177429701592295}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok() && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tuint8_t* crcBytes = (uint8_t*) &crc;\n\t\tpacketSerial.send(message, size + 2);\n\t}\n}", "CodeBleu_score": 30.24157817535552}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\t//Initialize the serial port for the sound module\n\tsoundSerial.begin(9600);\n\t//Clear the serial port\n\tsoundSerial.flush();\n\t//Initialize the sound module\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0xFF);\n\tsoundSerial.write(0x06);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\t//Wait for the sound module to respond\n\twhile (soundSerial.available() < 1) {\n\t}\n\t//Read the response\n\tbyte response = soundSerial.read();\n\t//If the response is 0x79, the initialization was successful\n\tif (response == 0x79) {\n\t\t//Retrieve the number of sound files on the SD card\n\t\tnumSdTracks = getSdTracks();\n\t\t//Return true to indicate successful initialization\n\t\treturn true;\n\t}\n\t//Otherwise, return false to indicate unsuccessful initialization\n\treturn false;\n}", "CodeBleu_score": 48.1407182458129}, {"code": "bool MP3Sound::begin(){\n\t\t// Initialize serial communication with the sound module\n\tsoundSerial.begin(9600);\n\t// Clear any existing data in the buffer\n\tsoundSerial.flush();\n\t// Initialize the sound module\n\tsendCommand(CMD_SEL_DEV, DEV_TF);\n\tsendCommand(CMD_PLAY_W_VOL, 0x1E);\n\tsendCommand(CMD_SET_VOLUME, 0x00);\n\tsendCommand(CMD_SET_PLAY_MODE, 0x00);\n\tsendCommand(CMD_SET_EQ, 0x03);\n\tsendCommand(CMD_SET_DAC, 0x01);\n\tsendCommand(CMD_SET_DAC, 0x00);\n\tsendCommand(CMD_SET_DAC, 0x01);\n\t// Retrieve the number of sound files available on the SD card\n\tsendCommand(CMD_GET_TOTAL_TRACKS);\n\tnumSdTracks = soundSerial.read();\n\t// Return true if there are one or more sound files available\n\treturn numSdTracks > 0;\n}", "CodeBleu_score": 41.11789513009672}, {"code": "bool MP3Sound::begin(){\n\t\t//Initialize the sound module\n\tif (!MP3player.begin()) {\n\t\treturn false;\n\t}\n\t//Clear any existing data in the buffer\n\tsoundSerial.flush();\n\t//Get the number of sound files available on the SD card\n\tnumSdTracks = MP3player.get_num_tracks();\n\treturn numSdTracks > 0;\n}", "CodeBleu_score": 34.18634096808758}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || isPlaying) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tactive_sounds.back().play();\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 37.45031847176728}, {"code": "int MP3Sound::processSounds(){\n\t\t// If there are no sounds, return the number of sounds.\n\tif (active_sounds.size() == 0) {\n\t\treturn active_sounds.size();\n\t}\n\t// If an MP3 is currently playing, return the number of sounds.\n\tif (isPlaying) {\n\t\treturn active_sounds.size();\n\t}\n\t// If there are sounds but no MP3 is playing, play the last sound, remove it from the list, and return the number of sounds.\n\tmyMP3.play(active_sounds.back());\n\tactive_sounds.pop_back();\n\treturn active_sounds.size();\n}", "CodeBleu_score": 40.03187401478349}, {"code": "int MP3Sound::processSounds(){\n\t\tint numActiveSounds = active_sounds.size();\n\tif (numActiveSounds == 0) {\n\t\tif (!myMP3.isPlaying()) {\n\t\t\tmyMP3.play(active_sounds.back());\n\t\t\tactive_sounds.pop_back();\n\t\t\treturn active_sounds.size();\n\t\t}\n\t}\n\treturn numActiveSounds;\n}", "CodeBleu_score": 56.38391411775632}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tbool command_handled = false;\n\tif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\t\twb_abstract_camera_cleanup(d);\n\t\twb_abstract_camera_setup(d, r);\n\t\tcommand_handled = true;\n\t}\n\treturn command_handled;\n}", "CodeBleu_score": 35.90903273528713}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t}", "CodeBleu_score": 6.617871250854342}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t}", "CodeBleu_score": 6.617871250854342}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint result;\n\tif (d == NULL) {\n\t\tfprintf(stderr, \"Error: null device passed to wb_abstract_camera_get_height.\n\");\n\t\treturn -1;\n\t}\n\trobot_mutex_lock(d->mutex);\n\tresult = d->height;\n\trobot_mutex_unlock(d->mutex);\n\treturn result;\n}", "CodeBleu_score": 44.31956094601259}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint result;\n\tif (d == NULL)\n\t\treturn -1;\n\trobot_mutex_lock(&d->mutex);\n\tresult = d->height;\n\trobot_mutex_unlock(&d->mutex);\n\treturn result;\n}", "CodeBleu_score": 46.6426677732744}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height = -1;\n\tif (d) {\n\t\tWbAbstractCamera *camera = wb_device_get_camera(d);\n\t\tif (camera) {\n\t\t\trobot_mutex_lock(&camera->mutex);\n\t\t\theight = camera->height;\n\t\t\trobot_mutex_unlock(&camera->mutex);\n\t\t}\n\t}\n\treturn height;\n}", "CodeBleu_score": 45.12292758048644}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tstruct WbAccelerometer *accelerometer;\n\tint sampling_period;\n\n\trobot_mutex_lock();\n\taccelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer!= NULL)\n\t\tsampling_period = accelerometer->sampling_period;\n\telse {\n\t\tfprintf(stderr, \"Error: wb_accelerometer_get_sampling_period: invalid tag.\n\");\n\t\tsampling_period = -1;\n\t}\n\trobot_mutex_unlock();\n\n\treturn sampling_period;\n}", "CodeBleu_score": 44.470972802953284}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tif (accelerometer_get_struct(tag) == NULL) {\n\t\tfprintf(stderr, \"Invalid accelerometer device tag.\n\");\n\t\treturn -1;\n\t}\n\n\trobot_mutex_lock();\n\tint sampling_period = accelerometer_get_struct(tag)->sampling_period;\n\trobot_mutex_unlock();\n\n\treturn sampling_period;\n}", "CodeBleu_score": 54.258226493448255}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tstruct WbDeviceTag *device_tag = (struct WbDeviceTag *) tag;\n\tint sampling_period;\n\tif (device_tag->type == WB_ACCELEROMETER) {\n\t\trobot_mutex_lock();\n\t\tif (device_tag->data!= NULL) {\n\t\t\tstruct WbAccelerometer *accelerometer = (struct WbAccelerometer *) device_tag->data;\n\t\t\tsampling_period = accelerometer->sampling_period;\n\t\t} else {\n\t\t\tfprintf(stderr, \"wb_accelerometer_get_sampling_period: invalid device tag.\n\");\n\t\t\tsampling_period = -1;\n\t\t}\n\t\trobot_mutex_unlock();\n\t} else {\n\t\tfprintf(stderr, \"wb_accelerometer_get_sampling_period: invalid device tag.\n\");\n\t\tsampling_period = -1;\n\t}\n\treturn sampling_period;\n}", "CodeBleu_score": 46.90621494734533}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tstring dmsString;\n\tchar *dmsStringC = const_cast<char *>(wb_gps_convert_to_degrees_minutes_seconds(decimalDegree));\n\tdmsString = dmsStringC;\n\tfree(dmsStringC);\n\treturn dmsString;\n}", "CodeBleu_score": 52.1277045211038}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\t// Convert the decimal degree value to a degrees, minutes, and seconds (DMS) format string.\n\tstring dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\n\t// Free the allocated memory.\n\tfree(const_cast<char *>(dms.c_str()));\n\n\t// Return the DMS string.\n\treturn dms;\n}", "CodeBleu_score": 41.05645416141951}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tstring result;\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tresult = dms;\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 42.42141351380352}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (dGeomGetClass (g) == dBoxClass, \"dGeomBoxGetTangentPlane: argument is not a box\");\n\tdVector3 r;\n\tdReal d;\n\tdVector3 p;\n\tp[0] = x;\n\tp[1] = y;\n\tp[2] = z;\n\tdGeomBoxGetOffset (g, r);\n\tdVectorSubtract (p, r, r);\n\td = dCalcVectorDot3_41 (r, dGeomBoxGetLengths (g));\n\tif (d > 0) {\n\t\tdVector3 v;\n\t\tdGeomBoxGetLengths (g, v);\n\t\tif (d < v[0]) {\n\t\t\tdVector3Set (plane, 1, 0, 0);\n\t\t\tplane[3] = -v[0];\n\t\t} else if (d < v[1]) {\n\t\t\tdVector3Set (plane, 0, 1, 0);\n\t\t\tplane[3] = -v[1];\n\t\t} else {\n\t\t\tdVector3Set (plane, 0, 0, 1);\n\t\t\tplane[3] = -v[2];\n\t\t}\n\t} else {\n\t\tdVector3 v;\n\t\tdGeomBoxGetLengths (g, v);\n\t\tif (d > -v[0]) {\n\t\t\tdVector3Set (plane, -1, 0, 0);\n\t\t\tplane[3] = v[0];\n\t\t} else if (d > -v[1]) {\n\t\t\tdVector3Set (plane, 0, -1, 0);\n\t\t\tplane[3] = v[1];\n\t\t} else {\n\t\t\tdVector3Set (plane, 0, 0, -1);\n\t\t\tplane[3] = v[2];\n\t\t}\n\t}\n}", "CodeBleu_score": 28.566248317057852}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (0, \"dGeomBoxGetTangentPlane() not implemented\");\n}", "CodeBleu_score": 1.5167872984999617}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (0, \"dGeomBoxGetTangentPlane not implemented\");\n}", "CodeBleu_score": 1.5167563455807604}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdUASSERT (box->body, \"dImmerseBox: box has no body\");\n\tdUASSERT (flags == dIMMERSE_ALL || flags == dIMMERSE_NO_SELF_INTERSECTION || flags == dIMMERSE_NO_SELF_INTERSECTION_OR_INTERSECTION_WITH_CHILD, \"dImmerseBox: invalid flags\");\n\tdUASSERT (fluidPlane, \"dImmerseBox: fluidPlane is NULL\");\n\tdUASSERT (immersion, \"dImmerseBox: immersion is NULL\");\n\tdImmersionGeom data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.immersion = immersion;\n\tdata.flags = flags;\n\tdata.performImmersionChecking = 1;\n\tdIASSERT;\n\treturn 0;\n}", "CodeBleu_score": 45.67885138171408}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box && fluidPlane && immersion, \"NULL argument\");\ndUASSERT (box->body, \"NULL body\");\ndUASSERT (flags >= 0 && flags <= 3, \"Invalid flags\");\nsBoxImmersionData data;\ndata.box = box;\ndata.fluidPlane = fluidPlane;\ndata.immersion = immersion;\ndata.flags = flags;\ndata.performImmersionChecking = dImmerseBoxPerform;\ndata.dUASSERT = dUASSERT;\ndata.dIASSERT = dIASSERT;\nreturn dImmersionCheck (&data);\n}", "CodeBleu_score": 47.36441468421237}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT(box, \"box is NULL\");\ndUASSERT(fluidPlane, \"fluidPlane is NULL\");\ndUASSERT(flags & dIM_ALL_FLAGS, \"flags are not valid\");\ndUASSERT(immersion, \"immersion is NULL\");\ndUASSERT(box->body, \"box has no body\");\ndUASSERT(box->geom, \"box has no geom\");\ndUASSERT(box->geom->type == dBoxClass, \"box is not a dBox\");\nsBoxImmersionData data;\ndata.box = box;\ndata.fluidPlane = fluidPlane;\ndata.flags = flags;\ndata.immersion = immersion;\ndata.performImmersionChecking = dImmerseBox_performImmersionChecking;\ndata.dIASSERT = dIASSERT;\ndata.dUASSERT = dUASSERT;\nreturn dIASSERT(dImmerseBox_performImmersionChecking (&data));\n}", "CodeBleu_score": 44.80191828924857}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT(o1 && o2, \"One of the input geometries is NULL\");\n\tdUASSERT(o1->body && o2->body, \"One of the input geometries has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(o1->type == dBoxClass && o2->type == dCapsuleClass, \"One of the input geometries is not a box or capsule\");\n\n\tdxCapsule *capsule = (dxCapsule*)o2;\n\tdxBox *box = (dxBox*)o1;\n\n\tif (capsule->capsule_radius <= 0) {\n\t\treturn 0;\n\t}\n\n\tdVector3 fluidPlane;\n\tif (!dCollideCapsuleBox(capsule, box, fluidPlane)) {\n\t\treturn 0;\n\t}\n\n\tdImmerseBox(box, fluidPlane, flags, immersion);\n\n\treturn 1;\n}", "CodeBleu_score": 45.17112243114227}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0;\n\t// Handle the singularity at the origin\n\tif (zIOverR < 1) {\n\t\tvolume += sCapsuleImmersionData::normalizedImmersedHemisphereVolume(zIOverR, tanTheta0, 0);\n\t}\n\t// Handle the singularity at the capsule end\n\tif (zIOverR > 1) {\n\t\tvolume += sCapsuleImmersionData::normalizedImmersedHemisphereVolume(zIOverR, tanTheta0, sinTheta1);\n\t}\n\t// Handle the main part of the volume\n\tif (zIOverR > 0) {\n\t\tvolume += sCapsuleImmersionData::normalizedImmersedHemisphereVolume(zIOverR, tanTheta0, sinTheta1);\n\t}\n\treturn volume;\n}", "CodeBleu_score": 30.09542264783418}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\treturn (2.0 * volume * (zIOverR * zIOverR) * (tanTheta0 + sinTheta1) / (3.0 * (1.0 + zIOverR * zIOverR))) / (4.0 * volume);\n}", "CodeBleu_score": 27.1024959756398}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsCapsuleImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 24.77508530630332}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsCapsuleImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 24.77508530630332}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\treturn 0;\n}", "CodeBleu_score": 4.835337050972104}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration from the input\n\tauto duration = getInput<std::chrono::milliseconds>(INPUT_DURATION);\n\t// If the duration is missing or non-positive, return SUCCESS\n\tif (!duration || *duration <= std::chrono::milliseconds::zero()) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\t// Start the timer\n\ttimer_.start();\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_.onTimeout([this]() {\n\t\temitWakeUpSignal();\n\t});\n\t// If the timer is aborted, ensure the timer_waiting_ flag is reset\n\tif (timer_.isAborted()) {\n\t\ttimer_waiting_ = false;\n\t}\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 39.70585265806853}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (!getInput(0).get()) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tauto duration = getInput(0).get().get<std::chrono::milliseconds>();\n\tif (duration <= std::chrono::milliseconds(0)) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_.start(duration, [this] {\n\t\temitWakeUpSignal();\n\t});\n\ttimer_waiting_ = true;\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 40.88568038256701}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration from the input\n\tauto duration = getInput(0);\n\tif (duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start the timer\n\ttimer_.start(duration);\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallback([&]() {\n\t\tsetStatus(NodeStatus::SUCCESS);\n\t\temitWakeUpSignal();\n\t});\n\n\t// Reset the timer_waiting_ flag\n\ttimer_waiting_ = false;\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 41.55452210257558}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tstd::string entry_name;\n\tif (this->get_parameter(\"entry_name\", entry_name)) {\n\t\tboost::shared_ptr<Blackboard::Entry> entry = this->config().blackboard->getEntry(entry_name);\n\t\tif (entry) {\n\t\t\tentry->lock();\n\t\t\tif (entry->getSequenceID()!= this->last_seq_id_) {\n\t\t\t\tthis->last_seq_id_ = entry->getSequenceID();\n\t\t\t\tentry->unlock();\n\t\t\t\treturn NodeStatus::SUCCESS;\n\t\t\t} else {\n\t\t\t\tentry->unlock();\n\t\t\t}\n\t\t}\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 31.267232884689683}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tEntry<std::string> *entry = config().blackboard->getEntry<std::string>(name());\n\tif (entry!= NULL) {\n\t\tentry->lock();\n\t\tif (entry->getSequenceID()!= sequence_id) {\n\t\t\tsequence_id = entry->getSequenceID();\n\t\t\tentry->unlock();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\tentry->unlock();\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 30.497517298541972}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard\n\tboost::shared_ptr<const Entry> entry = config().blackboard->getEntry(config().entry_key);\n\tif (entry == NULL) {\n\t\treturn FAILURE;\n\t}\n\n\t// Lock the entry's mutex\n\tboost::unique_lock<boost::mutex> lock(entry->mutex);\n\n\t// Compare the current sequence ID with the previously stored sequence ID\n\tif (entry->sequence_id!= config().sequence_id) {\n\t\t// Update the stored sequence ID\n\t\tconfig().sequence_id = entry->sequence_id;\n\t\treturn SUCCESS;\n\t}\n\n\treturn FAILURE;\n}", "CodeBleu_score": 39.65024599519619}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\tsuccess_threshold_ = std::max(size_t(1), children_nodes_.size());\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 49.28175245430112}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tsize_t threshold = success_threshold_;\n\tif (threshold < 0) {\n\t\tthreshold = children_nodes_.size();\n\t}\n\treturn threshold;\n}", "CodeBleu_score": 44.97206222554812}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(size_t(1), children_nodes_.size());\n\t} else {\n\t\treturn success_threshold_;\n\t}\n}", "CodeBleu_score": 45.981398528284025}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\t\tif(_p->heartbeat_status!= _p->last_heartbeat_status) {\n\t\t\t_p->last_heartbeat_status = _p->heartbeat_status;\n\t\t\tif(_p->heartbeat_status == HeartbeatStatus::ACTIVE) {\n\t\t\t\tenableAllHooks(true);\n\t\t\t} else {\n\t\t\t\tenableAllHooks(false);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.93831591347358}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\t\tif (_p->heartbeat_active) {\n\t\t\tauto now = std::chrono::system_clock::now();\n\t\t\tauto diff = now - _p->last_heartbeat;\n\t\t\tif (diff.count() > _p->heartbeat_timeout_ms) {\n\t\t\t\t_p->heartbeat_active = false;\n\t\t\t\tenableAllHooks(false);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 50.26375517703167}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t", "CodeBleu_score": 3.384455481167677}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t", "CodeBleu_score": 5.780157160879095}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Parse the input string of blackboard names\n\tstd::vector<std::string> bb_names = BT::splitString(bb_list, \",\");\n\n\t// Create an empty JSON object to store the blackboard dump\n\tnlohmann::json blackboard_dump;\n\n\t// Iterate through the blackboard names\n\tfor (const auto& bb_name : bb_names) {\n\t\t// Find the corresponding subtree\n\t\tauto it = _p->subtrees.find(bb_name);\n\n\t\t// If the subtree is valid, lock it\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tit->second.lock();\n\n\t\t\t// Export the blackboard to JSON\n\t\t\tnlohmann::json bb_json = ExportBlackboardToJSON(bb_name, it->second.get());\n\n\t\t\t// Add the blackboard to the JSON object\n\t\t\tblackboard_dump.push_back({ {\"name\", bb_name}, {\"content\", bb_json} });\n\n\t\t\t// Unlock the subtree\n\t\t\tit->second.unlock();\n\t\t}\n\t}\n\n\t// Convert the JSON object to MessagePack format\n\tstd::vector<uint8_t> msgpack_dump = blackboard_dump.dump();\n\n\treturn msgpack_dump;\n}", "CodeBleu_score": 51.2143016254741}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Create a JSON object to store the blackboards dump\n\tnlohmann::json dump;\n\n\t// Split the input string of blackboard names\n\tstd::vector<std::string> bb_names = BT::splitString(bb_list, \",\");\n\n\t// Iterate through the blackboard names\n\tfor (const std::string& bb_name : bb_names) {\n\t\t// Find the corresponding subtree\n\t\tstd::shared_ptr<BT::Blackboard> subtree = _p->subtrees.find(bb_name);\n\n\t\t// Check if the subtree is valid\n\t\tif (subtree!= nullptr) {\n\t\t\t// Lock the subtree\n\t\t\tsubtree->lock();\n\n\t\t\t// Export the blackboard to JSON\n\t\t\tnlohmann::json bb_json = subtree->to_json();\n\n\t\t\t// Add the blackboard to the JSON object\n\t\t\tdump[bb_name] = bb_json;\n\n\t\t\t// Unlock the subtree\n\t\t\tsubtree->unlock();\n\t\t}\n\t}\n\n\t// Convert the JSON object to MessagePack format\n\tstd::vector<uint8_t> msgpack_dump = dump.dump();\n\n\t// Return the MessagePack dump\n\treturn msgpack_dump;\n}", "CodeBleu_score": 49.221296412143786}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t/  std::cout << \"unlockBreakpoint\" << std::endl;\n  auto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->lock);\n  if(hook->status == NodeStatus::BREAKPOINT)\n  {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 50.95257664645627}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t/  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n//  auto hook = getHook(pos, node_uid);\n//  if (hook) {\n//    std::lock_guard<std::mutex> lk2(hook->lock);\n//    if (hook->status == NodeStatus::BREAKPOINT) {\n//      hook->status = result;\n//      hook->remove = remove;\n//      hook->ready = true;\n//      hook->wakeup.notify_all();\n//      return true;\n//    }\n//  }\n  return false;\n}", "CodeBleu_score": 9.367214893743443}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t/  std::cout << \"Groot2Publisher::unlockBreakpoint\" << std::endl;\n  auto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->lock);\n  if(hook->status!= NodeStatus::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 49.2311251162955}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\todeStatus prev_status = status();\n\nif(prev_status == NodeStatus::IDLE)\n{\n  setStatus(NodeStatus::RUNNING);\n  prev_status = NodeStatus::RUNNING;\n}\n\nNodeStatus status = tick_functor_(*this);\nif(status!= prev_status)\n{\n  setStatus(status);\n}\nreturn status;\n}", "CodeBleu_score": 24.726395075003662}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\todeStatus prev_status = status();\n\nif(prev_status == NodeStatus::IDLE)\n{\n  setStatus(NodeStatus::RUNNING);\n  prev_status = NodeStatus::RUNNING;\n}\n\nNodeStatus status = tick_functor_(*this);\nif(status!= prev_status)\n{\n  setStatus(status);\n}\nreturn status;\n}", "CodeBleu_score": 24.726395075003662}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t/*\n * The executeTick function is responsible for managing the execution of a tick action in a separate thread.\nIf the node status is IDLE, it sets the status to RUNNING, resets halt_requested_, and starts a new asynchronous thread to run the tick function.\nIf the tick function completes without a halt request, it updates the node status.\nIf an exception occurs, it catches the exception, logs an error, and sets the node status to IDLE.\nThe function also checks for any stored exceptions and rethrows them if present.\nFinally, it returns the current status of the node.\n */\n  NodeStatus prev_status = status();\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n    // Reset the halt requested flag\n    halt_requested_.store(false);\n    // Start a new asynchronous thread to run the tick function\n    std::async(std::launch::async, &BT::ThreadedAction::tick, this);\n  } else if (prev_status == NodeStatus::RUNNING) {\n    // If the tick function completes without a halt request, update the node status\n    if (!halt_requested_.load()) {\n      setStatus(NodeStatus::RUNNING);\n    }\n  } else if (prev_status == NodeStatus::HALTED) {\n    // If the node status is HALTED, reset the halt requested flag and return\n    halt_requested_.store(false);\n    return NodeStatus::HALTED;\n  } else if (prev_status == NodeStatus::ERROR) {\n    // If the node status is ERROR, reset the halt requested flag and return\n    halt_requested_.store(false);\n    return NodeStatus::ERROR;\n  } else if (prev_status == NodeStatus::SUCCESS) {\n    // If the node status is SUCCESS, reset the halt requested flag and return\n    halt_requested_.store(false);\n    return NodeStatus::SUCCESS;\n  } else {\n    // If the node status is unknown, reset the halt requested flag and return\n    halt_requested_.store(false);\n    return NodeStatus::IDLE;\n  }\n\n  // Check for any stored exceptions and rethrow them if present\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n\n  return status();\n}", "CodeBleu_score": 46.27708970105879}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// TODO: Implement this function\n}", "CodeBleu_score": 3.8627219268601167}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// TODO: Implement\n}", "CodeBleu_score": 3.8627219268601167}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tauto print_tree = [&stream](const TreeNode* node, int depth) {\n\t\tstd::string indent(depth, '\\t');\n\t\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tstream << indent << \"ControlNode: \" << control->name << std::endl;\n\t\t\tfor (auto& child : control->children) {\n\t\t\t\tprint_tree(child.get(), depth + 1);\n\t\t\t}\n\t\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tstream << indent << \"DecoratorNode: \" << decorator->name << std::endl;\n\t\t\tprint_tree(decorator->child.get(), depth + 1);\n\t\t}\n\t};\n\n\tstream << std::string(80, '-') << std::endl;\n\tprint_tree(root_node, 0);\n\tstream << std::string(80, '-') << std::endl;\n}", "CodeBleu_score": 49.180707248026344}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t", "CodeBleu_score": 7.6574026861868205}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\n}", "CodeBleu_score": 7.736551633910178}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node) {\nthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n}\n\nvisitor(node);\n\nif(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\nfor(const auto& child : control->children()) {\napplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n}\n}\nelse if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\napplyRecursiveVisitor(decorator->child(), visitor);\n}\n}", "CodeBleu_score": 96.08701069890077}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tauto it = _p->builders.find(manifest.registration_id);\n\tif (it!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID \" + manifest.registration_id + \" already registered\");\n\t}\n\t_p->builders.insert(std::make_pair(manifest.registration_id, builder));\n\t_p->manifests.insert(std::make_pair(manifest.registration_id, manifest));\n}", "CodeBleu_score": 64.34853509127429}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.id)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"Builder with ID '\" + manifest.id + \"' already registered.\");\n\t}\n\n\t_p->builders.insert(std::make_pair(manifest.id, builder));\n\t_p->manifests.insert(std::make_pair(manifest.id, manifest));\n}", "CodeBleu_score": 51.38692378337127}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\n}", "CodeBleu_score": 4.889503087170041}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t//  std::unique_ptr<SimpleActionNode> node = std::make_unique<SimpleActionNode>(tick_functor);\n  auto builder = [tick_functor, ports](const TreeNodeManifest& manifest,\n                                       const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = TreeNodeType::SIMPLE_ACTION;\n  manifest.registration_ID = ID;\n  manifest.ports = ports;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 56.9156118678381}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t/  auto builder = [tick_functor, ports](const TreeNodeManifest& manifest) {\n//    return std::make_unique<SimpleActionNode>(tick_functor, ports);\n//  };\n  auto builder = [tick_functor, ports](const TreeNodeManifest& manifest) {\n    return std::make_unique<SimpleActionNode>(tick_functor, ports);\n  };\n  TreeNodeManifest manifest(SimpleActionNode::type(), ID, std::move(ports));\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 49.01933589807342}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t/  auto builder = [tick_functor, ports](const TreeNodeManifest& manifest) {\n//    return std::make_unique<SimpleActionNode>(tick_functor, ports);\n//  };\n//  registerBuilder(TreeNodeManifest(SimpleActionNode::type(), ID, ports), builder);\n}", "CodeBleu_score": 19.62200665565497}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backup;\n\tbb_backup.reserve(tree.subtrees.size());\n\tfor (auto subtree : tree.subtrees) {\n\t\tauto bb = subtree->blackboard->clone();\n\t\tbb_backup.push_back(bb);\n\t}\n\treturn bb_backup;\n}", "CodeBleu_score": 57.534695882997966}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backup;\n\tbb_backup.reserve(tree.subtrees.size());\n\tfor (auto& subtree : tree.subtrees) {\n\t\tBlackboard::Ptr bb_backup_ptr = Blackboard::Ptr(new Blackboard());\n\t\tbb_backup_ptr->cloneInto(subtree.blackboard);\n\t\tbb_backup.push_back(bb_backup_ptr);\n\t}\n\treturn bb_backup;\n}", "CodeBleu_score": 55.146752376997185}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb_backup;\nbb_backup.reserve(tree.subtrees.size());\nfor (const auto& subtree : tree.subtrees) {\nBlackboard::Ptr bb_backup_ptr = Blackboard::Ptr(new Blackboard());\n*bb_backup_ptr = *subtree->blackboard;\nbb_backup.push_back(bb_backup_ptr);\n}\nreturn bb_backup;\n}", "CodeBleu_score": 55.69683193642203}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor) {\n\t\treturn executor(env);\n\t} else {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 81.70302498790282}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor(env);\n}", "CodeBleu_score": 68.74109132460353}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto result = ParseScript(script);\n\tif (result.has_value()) {\n\t\treturn result.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(result.error());\n\t}\n}", "CodeBleu_score": 66.01586524902739}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Shared library already loaded.\");\n\t}\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == nullptr) {\n\t\tstd::string error = dlerror();\n\t\tthrow RuntimeError(\"Error loading shared library: \" + error);\n\t}\n\tloaded = true;\n\tthis->path = path;\n}", "CodeBleu_score": 55.494736807468655}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\t// Acquire a unique lock on a mutex to ensure thread safety.\n\tstd::unique_lock<std::mutex> lock(mutex);\n\t// If a library is already loaded, it throws a RuntimeError.\n\tif (loaded) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: library already loaded\");\n\t}\n\t// Attempt to load the library using dlopen with RTLD_NOW and RTLD_GLOBAL flags.\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\t// If the load fails, it retrieves the error message and throws a RuntimeError.\n\tif (!handle) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: \" + std::string(dlerror()));\n\t}\n\t// If successful, it stores the path of the loaded library.\n\tthis->path = path;\n\t// Mark the library as loaded.\n\tloaded = true;\n}", "CodeBleu_score": 52.93020595518827}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library is already loaded\");\n\t}\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == nullptr) {\n\t\tstd::string msg = dlerror();\n\t\tthrow RuntimeError(msg);\n\t}\n\tloaded = true;\n\tthis->path = path;\n}", "CodeBleu_score": 51.613523791413094}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3)\n\t\treturn false;\n\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3)\n\t\treturn false;\n\n\tif (stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}')\n\t\treturn false;\n\n\tif (stripped_pointer)\n\t\t*stripped_pointer = stripped.substring(1, stripped.size() - 1);\n\n\treturn true;\n}", "CodeBleu_score": 22.12752713976395}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\t// Check if the string is at least 3 characters long\n\tif (str.size() < 3)\n\t\treturn false;\n\n\t// Strip leading and trailing spaces\n\tstr.strip();\n\n\t// Check if the string starts with '{' and ends with '}'\n\tif (str.front()!= '{' || str.back()!= '}')\n\t\treturn false;\n\n\t// If a stripped_pointer is provided, assign the inner content to it\n\tif (stripped_pointer)\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\n\t// Return whether the string is a valid blackboard pointer\n\treturn true;\n}", "CodeBleu_score": 17.23287925167538}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.trim();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.front()!= '{' || stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 24.730430674911442}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t//initialize the line cost to the point cost at the start point\n\tdouble line_cost = pointCost(x0, y0);\n\t//if the line cost is negative, return the line cost immediately\n\tif(line_cost < 0)\n\t\treturn line_cost;\n\n\t//create a line iterator\n\tnav_core::LineIterator line_it(costmap_, x0, y0, x1, y1);\n\t//iterate through the line\n\tfor(int i = 0; i < line_it.getSize(); ++i) {\n\t\t//get the point from the iterator\n\t\tint x = line_it.getX();\n\t\tint y = line_it.getY();\n\t\t//calculate the point cost\n\t\tdouble point_cost = pointCost(x, y);\n\t\t//if the point cost is negative, return the point cost immediately\n\t\tif(point_cost < 0)\n\t\t\treturn point_cost;\n\t\t//if the point cost is higher than the line cost, update the line cost\n\t\tif(point_cost > line_cost)\n\t\t\tline_cost = point_cost;\n\t\t//advance the iterator\n\t\tline_it.advance();\n\t}\n\t//return the line cost\n\treturn line_cost;\n}", "CodeBleu_score": 55.501058062496156}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\n\t//create a line iterator\n\tLineIterator line_it(costmap_, Point(x0, y0), Point(x1, y1));\n\n\t//iterate through the line\n\tfor(int i = 0; i < line_it.count; i++, ++line_it) {\n\t\tdouble point_cost = pointCost(line_it.x, line_it.y);\n\n\t\t//if the point cost is negative, return the point cost immediately\n\t\tif(point_cost < 0)\n\t\t\treturn point_cost;\n\n\t\t//update the line cost if the point cost is higher\n\t\tif(point_cost > line_cost)\n\t\t\tline_cost = point_cost;\n\t}\n\n\treturn line_cost;\n}", "CodeBleu_score": 58.60504275516156}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble line_cost = 0.0;\n\n//create a line iterator\nLineIterator line_iterator(costmap_, x0, y0, x1, y1);\n\n//iterate through the line\nfor(int i = 0; i < line_iterator.size(); ++i) {\n  double point_cost = pointCost(line_iterator.x(), line_iterator.y());\n\n  //if the point cost is negative, return immediately\n  if(point_cost < 0)\n    return point_cost;\n\n  //update the line cost if the point cost is higher\n  if(point_cost > line_cost)\n    line_cost = point_cost;\n}\n\nreturn line_cost;\n}", "CodeBleu_score": 64.44471802318623}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Path is empty. Not publishing.\");\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = path[0].header.frame_id;\n\tgui_path.header.stamp = path[0].header.stamp;\n\tgui_path.poses.resize(path.size());\n\tfor (size_t i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 77.09002881705786}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = path[0].header.frame_id;\n\tgui_path.header.stamp = path[0].header.stamp;\n\n\tgui_path.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 81.53490032376973}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = path[0].header.frame_id;\n\tgui_path.header.stamp = path[0].header.stamp;\n\tgui_path.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 81.53490032376973}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif(base_odom.twist.twist.linear.x < trans_stopped_velocity && base_odom.twist.twist.linear.y < trans_stopped_velocity && base_odom.twist.twist.linear.z < trans_stopped_velocity && base_odom.twist.twist.angular.x < rot_stopped_velocity && base_odom.twist.twist.angular.y < rot_stopped_velocity && base_odom.twist.twist.angular.z < rot_stopped_velocity) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 46.19492585061619}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t", "CodeBleu_score": 7.6923076923076925}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif(base_odom.twist.twist.linear.x <= trans_stopped_velocity && base_odom.twist.twist.linear.y <= trans_stopped_velocity && base_odom.twist.twist.linear.z <= trans_stopped_velocity && base_odom.twist.twist.angular.x <= rot_stopped_velocity && base_odom.twist.twist.angular.y <= rot_stopped_velocity && base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.09326150075157}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t//ROS_INFO(\"LocalPlannerUtil::reconfigureCB\");\n\tif (restore_defaults) {\n\t\tconfig.restoreDefaults();\n\t} else {\n\t\tif (!setup) {\n\t\t\tconfig.setup(config);\n\t\t\tsetup = true;\n\t\t} else {\n\t\t\tconfig.update(config);\n\t\t}\n\t}\n\t//ROS_INFO(\"LocalPlannerUtil::reconfigureCB - END\");\n}", "CodeBleu_score": 37.64273110730214}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// Lock the configuration mutex\n\tboost::unique_lock<boost::shared_mutex> lock(configuration_mutex_);\n\n\t// Check if the setup flag is true\n\tif (setup_) {\n\t\t// Check if restore defaults is requested\n\t\tif (restore_defaults) {\n\t\t\t// Reset the configuration to default limits\n\t\t\tconfig.restoreDefaults();\n\t\t}\n\t} else {\n\t\t// Set up the setup flag to true\n\t\tsetup_ = true;\n\n\t\t// Initialize the default limits with the provided configuration\n\t\tdefault_limits_ = config;\n\t}\n\n\t// Unlock the configuration mutex\n\tlock.unlock();\n\n\t// Lock the configuration mutex\n\tlock.lock();\n\n\t// Update the current limits with the new configuration\n\tcurrent_limits_ = config;\n\n\t// Unlock the configuration mutex\n\tlock.unlock();\n}", "CodeBleu_score": 51.956886118206484}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// If the setup flag is not yet done, initialize the default limits with the provided configuration and set up the flag.\n\tif (!setup) {\n\t\tdefault_limits = config;\n\t\tsetup = true;\n\t}\n\n\t// If the setup flag is true and restore_defaults is requested, reset the configuration to default limits.\n\tif (setup && restore_defaults) {\n\t\tconfig = default_limits;\n\t}\n\n\t// Lock the configuration mutex and update the current limits with the new configuration.\n\tboost::mutex::scoped_lock lock(config_mutex);\n\tcurrent_limits = config;\n}", "CodeBleu_score": 65.68080728978418}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false.\n\tif (check_cell->getCost(costmap) >= costmap.getCost(costmap.getCost(current_cell->getX(), current_cell->getY()))) {\n\t\tcheck_cell->setTargetDistance(costmap.getCost(current_cell->getX(), current_cell->getY()));\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance.\n\tdouble new_target_distance = current_cell->getTargetDistance() + costmap.getCost(current_cell->getX(), current_cell->getY());\n\n\t// If the new target distance is shorter, update the cell's target distance.\n\tif (new_target_distance < check_cell->getTargetDistance()) {\n\t\tcheck_cell->setTargetDistance(new_target_distance);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 41.06991737119035}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t//get the cell's cost\n\tunsigned char cell_cost = costmap.getCost(check_cell->x, check_cell->y);\n\n\t//if the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost\n\tif (cell_cost == costmap_2d::NO_INFORMATION || cell_cost >= costmap.getCostmap()->getCharMap().size()) {\n\t\tcheck_cell->target_distance = std::numeric_limits<double>::infinity();\n\t\treturn false;\n\t}\n\n\t//calculate the new target distance\n\tdouble new_target_distance = current_cell->target_distance + check_cell->getDistance(current_cell);\n\n\t//if the new target distance is shorter, update the cell's target distance\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 57.37904375077054}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t//if the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false\n\tif (check_cell->cost < 0) {\n\t\tcurrent_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n\t\treturn false;\n\t}\n\t//calculate a new target distance\n\tint new_target_distance = current_cell->target_distance + 1;\n\t//if the new distance is shorter, update the cell's target distance\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 43.649625216974364}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/  ROS_ERROR(\"scoreTrajectory\");\n  //initialize the cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //if the footprint specification is empty, log an error and return -9\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint specification is empty, cannot score trajectory\");\n    return -9.0;\n  }\n\n  //for each point in the trajectory, calculate the footprint cost\n  for(unsigned int i  = 0; i < traj.getPointsSize(); ++i) {\n    //get the point\n    geometry_msgs::Point pt = traj.getPoint(i);\n    //calculate the footprint cost\n    double footprint_cost = footprintCost(pt.x, pt.y, pt.theta, scale, footprint_spec_, costmap_, world_model_);\n    //if the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    //otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 68.31396656979013}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t// initialize the cost and scaling factor based on the trajectory and speed parameters\n\tdouble cost = 0.0;\n\tdouble scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n\t// if the footprint specification is empty, log an error and return -9\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"Footprint specification is empty. Cannot calculate score.\");\n\t\treturn -9.0;\n\t}\n\n\t// for each point in the trajectory, calculate the footprint cost\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n\t\t// get the point\n\t\tgeometry_msgs::Point pt = traj.getPoint(i);\n\n\t\t// calculate the footprint cost\n\t\tdouble footprint_cost = footprintCost(pt.x, pt.y, traj.th_[i], scale, footprint_spec_, costmap_, world_model_);\n\n\t\t// if the footprint cost is negative, return the cost immediately\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\n\t\t// otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\t// return the total cost\n\treturn cost;\n}", "CodeBleu_score": 63.16329235867775}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/  ROS_ERROR(\"scoreTrajectory\");\n  //initialize the cost and scaling factor based on the trajectory and speed parameters\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  double cost = 0.0;\n\n  //if the footprint specification is empty, log an error and return -9\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint specification is empty. Aborting.\");\n    return -9.0;\n  }\n\n  //for each point in the trajectory, calculate the footprint cost\n  for(unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.getPoint(i).x, traj.getPoint(i).y, traj.getPoint(i).theta, scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    //if the footprint cost is negative, return the cost immediately\n    if (footprint_cost > 0) {\n      if (sum_scores_) {\n        cost += footprint_cost;\n      } else {\n        cost = std::max(cost, footprint_cost);\n      }\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 64.8729376780491}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t//  double scale = 1.0;\n  // scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point p = footprint_spec[i];\n    scaled_footprint.push_back(scaleFootprintPoint(p, scale));\n  }\n\n  // compute footprint cost\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n  if (footprint_cost < 0.0) {\n    return -6.0;\n  }\n\n  // compute cell cost\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n  double cell_cost = costmap->getCost(mx, my);\n  if (cell_cost == costmap_2d::FREE_SPACE) {\n    return -7.0;\n  }\n\n  // return max cost\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 69.24287549304064}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  ROS_INFO(\"footprintCost\");\n  // scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  scaled_footprint.resize(footprint_spec.size());\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    scaled_footprint[i].x = footprint_spec[i].x * scale;\n    scaled_footprint[i].y = footprint_spec[i].y * scale;\n  }\n\n  // compute the footprint cost\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // check if the position is off the map\n  if (!costmap->worldToMap(x, y, x_index, y_index)) {\n    return -7.0;\n  }\n\n  // compute the cell cost\n  unsigned char cell = costmap->getCost(x_index, y_index);\n  if (cell == costmap_2d::NO_INFORMATION) {\n    return -8.0;\n  }\n\n  // return the maximum cost\n  return std::max(footprint_cost, static_cast<double>(cell));\n}", "CodeBleu_score": 69.76870319499089}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_INFO_ONCE(\"odom topic set to %s\", odom_topic.c_str());\n  //we assume that the odometry is published in the frame of the base\n  if (odom_topic!= odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_.empty()) {\n      odom_sub_.shutdown();\n    } else {\n      odom_sub_.subscribe(odom_topic_, 10);\n    }\n  }\n}", "CodeBleu_score": 41.862442609884916}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Setting odometry topic to %s\", odom_topic.c_str());\n  if (odom_topic!= odom_topic_) {\n    //if the new topic is different from the current one, we update the topic\n    odom_topic_ = odom_topic;\n    if (!odom_topic.empty()) {\n      //if the new topic is not empty, we subscribe to the new topic with a callback to odomCallback\n      odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      //if the new topic is empty, we shut down the existing subscription\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 44.50781842703493}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In setOdomTopic with topic '%s'\", odom_topic.c_str());\n\n  if (odom_topic!= odom_topic_) {\n    if (odom_topic.empty()) {\n      //unsubscribe from the old topic\n      if (odom_sub_.getSubscriber().getNumPublishers() == 0) {\n        odom_sub_.shutdown();\n      }\n    } else {\n      //subscribe to the new topic\n      odom_sub_.subscribe(nh_, odom_topic, 1);\n      odom_sub_.registerCallback(&OdometryHelperRos::odomCallback, this);\n    }\n    odom_topic_ = odom_topic;\n  }\n}", "CodeBleu_score": 41.13471571047393}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//  const float sq_distance_threshold = 0.001; // 0.001\n//  const float angle_threshold = 0.05; // 0.05\n  const float sq_distance_threshold = 0.0001; // 0.001\n  const float angle_threshold = 0.005; // 0.05\n  float sq_distance = (pos - prev).squaredNorm();\n  float angle = acos(prev.dot(pos) / (prev.norm() * pos.norm()));\n\n  if (sq_distance > sq_distance_threshold || angle > angle_threshold) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 41.2598350502681}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat dist_sq = (pos - prev).squaredNorm();\n\tfloat angle = acos(prev.dot(pos) / (prev.norm() * pos.norm()));\n\n\tif (dist_sq > dist_sq_thresh_ || angle > angle_thresh_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 32.18819692563208}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//  float dist_sq = (pos - prev).squaredNorm();\n//  float angle = fabs(atan2(pos[1] - prev[1], pos[0] - prev[0]));\n//  if (dist_sq > 0.00000000001f || angle > 0.00000000001f) {\n//    resetOscillationFlags();\n//  }\n}", "CodeBleu_score": 5.404296347119544}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\tif(gx >= width_ || gy >= height_ || gx < 0 || gy < 0)\n\t\treturn;\n\n\t//check if the point is too close to its nearest neighbor\n\tif(nearestNeighborDistance(pt) < sq_min_separation_)\n\t\treturn;\n\n\t//calculate the grid index\n\tunsigned int grid_index = gy * width_ + gx;\n\n\t//insert the point into the cell\n\tcells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 71.43859489772993}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//if the grid coordinates are out of bounds, return\n\tif(gx >= width_ || gy >= height_ || gx < 0 || gy < 0)\n\t\treturn;\n\n\t//check if the point is too close to its nearest neighbor\n\tdouble sq_dist = nearestNeighborDistance(pt);\n\n\tif(sq_dist < sq_min_separation_)\n\t\treturn;\n\n\t//calculate the grid index\n\tunsigned int grid_index = gx + gy * width_;\n\n\t//insert the point into the grid\n\tcells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 64.87315518822952}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tfor (int i = 0; i < 3; i++) {\n\t\tdouble diff = sample_target_vel(i) - vel(i);\n\t\tdouble diff_abs = std::abs(diff);\n\t\tif (diff_abs > acclimits(i)) {\n\t\t\tnew_vel(i) = vel(i) + acclimits(i) * (diff / diff_abs) * dt;\n\t\t} else {\n\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 49.651816686984674}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel;\nnew_vel.setZero();\nfor (int i = 0; i < 3; i++) {\nif (sample_target_vel[i] > vel[i]) {\nnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n} else {\nnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n}\n}\nreturn new_vel;\n}", "CodeBleu_score": 70.02063048750854}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 70.17302977382846}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble dx, dy, heading_diff;\n\tdouble max_dist = DBL_MAX;\n\tdouble min_dist = DBL_MAX;\n\tdouble dist;\n\tdouble min_angle = DBL_MAX;\n\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Convert the global plan cell coordinates to world coordinates\n\t\tdx = global_plan_[i].pose.position.x - x;\n\t\tdy = global_plan_[i].pose.position.y - y;\n\n\t\t// Calculate the distance between the current cell and the goal point\n\t\tdist = sqrt(dx * dx + dy * dy);\n\n\t\t// Check if the distance is less than the maximum distance\n\t\tif (dist < max_dist) {\n\t\t\t// Check if the line of sight is clear from the robot's current cell\n\t\t\tif (lineCost(cell_x, costmap_.worldToMapX(global_plan_[i].pose.position.x), cell_y, costmap_.worldToMapY(global_plan_[i].pose.position.y)) >= 0) {\n\t\t\t\t// Update the maximum distance\n\t\t\t\tmax_dist = dist;\n\n\t\t\t\t// Check if the distance is less than the minimum distance\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\t// Update the minimum distance\n\t\t\t\t\tmin_dist = dist;\n\n\t\t\t\t\t// Calculate the shortest angular distance between the current heading and the direction to the goal point\n\t\t\t\t\theading_diff = angles::shortest_angular_distance(atan2(dy, dx), heading);\n\n\t\t\t\t\t// Check if the angular distance is less than the minimum angle\n\t\t\t\t\tif (fabs(heading_diff) < min_angle) {\n\t\t\t\t\t\t// Update the minimum angle\n\t\t\t\t\t\tmin_angle = fabs(heading_diff);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if the minimum angle is less than the maximum angle\n\tif (min_angle < M_PI) {\n\t\t// Return the minimum angle\n\t\treturn min_angle;\n\t} else {\n\t\t// Return the maximum angle\n\t\treturn M_PI;\n\t}\n}", "CodeBleu_score": 52.68410662690063}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t// Find the farthest point on the global plan with a clear line of sight from the robot's current cell\n\tint i = global_plan_.size() - 1;\n\twhile (i >= 0) {\n\t\t// Convert the goal cell coordinates to world coordinates\n\t\tdouble world_x = x + (cell_x - global_plan_[i].x) * costmap_.getResolution();\n\t\tdouble world_y = y + (cell_y - global_plan_[i].y) * costmap_.getResolution();\n\t\t// Check if the goal point has a clear line of sight from the robot's current cell\n\t\tif (lineCost(cell_x, global_plan_[i].x, cell_y, global_plan_[i].y) >= 0) {\n\t\t\t// Calculate the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n\t\t\treturn fabs(angles::shortest_angular_distance(heading, atan2(world_y - y, world_x - x)));\n\t\t}\n\t\ti--;\n\t}\n\t// If no valid point is found, return DBL_MAX\n\treturn DBL_MAX;\n}", "CodeBleu_score": 50.86211033960193}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t// Get the robot's current position\n\tint cx = cell_x;\n\tint cy = cell_y;\n\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Convert the global plan cell coordinates to world coordinates\n\t\tint gx = global_plan_[i].x;\n\t\tint gy = global_plan_[i].y;\n\t\tdouble gx_world = x + gx * costmap_.getResolution();\n\t\tdouble gy_world = y + gy * costmap_.getResolution();\n\n\t\t// Check if the line of sight from the robot's current cell to the goal point is clear\n\t\tif (lineCost(cx, gx, cy, gy) >= 0) {\n\t\t\t// Convert the goal point coordinates to world coordinates\n\t\t\tdouble gx_world = x + gx * costmap_.getResolution();\n\t\t\tdouble gy_world = y + gy * costmap_.getResolution();\n\n\t\t\t// Calculate the shortest angular distance between the current heading and the direction to the goal point\n\t\t\tdouble heading_diff = angles::shortest_angular_distance(heading, atan2(gy_world - y, gx_world - x));\n\n\t\t\treturn fabs(heading_diff);\n\t\t}\n\t}\n\n\t// If no valid point is found, return DBL_MAX\n\treturn DBL_MAX;\n}", "CodeBleu_score": 56.896928557970796}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t#ifdef DEBUG\n    ROS_WARN(\"TrajectoryPlanner::checkTrajectory: x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n#endif\n\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0) {\n      return true;\n    } else {\n      ROS_WARN(\"TrajectoryPlanner::checkTrajectory: x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f, cost: %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n      return false;\n    }\n  }", "CodeBleu_score": 68.18518446481438}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n//    ROS_WARN(\"checkTrajectory: vx_samp: %f, vy_samp: %f, vtheta_samp: %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp));\n\n    if (scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp) >= 0) {\n      return true;\n    } else {\n      ROS_WARN(\"checkTrajectory: vx_samp: %f, vy_samp: %f, vtheta_samp: %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp));\n      return false;\n    }\n  }", "CodeBleu_score": 66.57129199264398}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//ROS_INFO(\"checkTrajectory\");\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0) {\n      //ROS_INFO(\"checkTrajectory: true\");\n      return true;\n    } else {\n      //ROS_WARN(\"checkTrajectory: false\");\n      return false;\n    }\n  }", "CodeBleu_score": 64.68868298667341}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tf (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior() is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmap passed to the ClearCostmapRecovery object is NULL. Did you initialize the costmap before passing it to the constructor?\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local costmap passed to the ClearCostmapRecovery object is NULL. Did you initialize the costmap before passing it to the constructor?\");\n\t\treturn;\n\t}\n\n\tif (affected_maps_.empty()) {\n\t\tROS_ERROR(\"No costmaps were specified to clear\");\n\t\treturn;\n\t}\n\n\tros::WallTime t0 = ros::WallTime::now();\n\tROS_INFO(\"Clearing costmaps\");\n\tif (affected_maps_.find(\"global\")!= std::string::npos) {\n\t\tROS_INFO(\"Clearing global costmap\");\n\t\tif (invert_area_to_clear_) {\n\t\t\tROS_WARN(\"Clearing outside the area\");\n\t\t}\n\t\tglobal_costmap_->updateMap(true);\n\t}\n\n\tif (affected_maps_.find(\"local\")!= std::string::npos) {\n\t\tROS_INFO(\"Clearing local costmap\");\n\t\tif (invert_area_to_clear_) {\n\t\t\tROS_WARN(\"Clearing outside the area\");\n\t\t}\n\t\tlocal_costmap_->updateMap(true);\n\t}\n\n\tROS_DEBUG(\"Clearing costmaps took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 48.71170951889885}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t/  if(!initialized_) {\n//    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n//    return;\n//  }\n\n  if(!local_costmap_ ||!global_costmap_) {\n    ROS_ERROR(\"One or more costmaps passed to this object are NULL.  This object cannot run.\");\n    return;\n  }\n\n  if(clear_outside_area_ && clear_inside_area_) {\n    ROS_WARN(\"Clearing inside and outside areas at the same time is not supported.  Clearing inside area.\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  // clear the global costmap\n  if(affected_maps_.find(\"global\")!=std::string::npos) {\n    ROS_DEBUG(\"Clearing global costmap\");\n    if(clear_outside_area_) {\n      global_costmap_->clearOutsideArea(clear_radius_, invert_area_to_clear_);\n    } else if(clear_inside_area_) {\n      global_costmap_->clearInsideArea(clear_radius_, invert_area_to_clear_);\n    } else {\n      global_costmap_->clear(invert_area_to_clear_);\n    }\n    if(force_update_) {\n      global_costmap_->updateMap();\n    }\n  }\n\n  // clear the local costmap\n  if(affected_maps_.find(\"local\")!=std::string::npos) {\n    ROS_DEBUG(\"Clearing local costmap\");\n    if(clear_outside_area_) {\n      local_costmap_->clearOutsideArea(clear_radius_, invert_area_to_clear_);\n    } else if(clear_inside_area_) {\n      local_costmap_->clearInsideArea(clear_radius_, invert_area_to_clear_);\n    } else {\n      local_costmap_->clear(invert_area_to_clear_);\n    }\n    if(force_update_) {\n      local_costmap_->updateMap();\n    }\n  }\n\n  ros::WallTime t1 = ros::WallTime::now();\n  ROS_DEBUG(\"Clearing costmaps took %.3f seconds\", (t1 - t0).toSec());\n}", "CodeBleu_score": 46.597113209901394}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t/ Check if object is initialized\n\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\t// Check if costmaps are not NULL\n\tif (!global_costmap_ ||!local_costmap_) {\n\t\tROS_ERROR(\"Global and local costmaps must be set before runBehavior is called\");\n\t\treturn;\n\t}\n\n\t// Log warning if clearing inside or outside a specified area\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing inside specified area\");\n\t} else {\n\t\tROS_WARN(\"Clearing outside specified area\");\n\t}\n\n\t// Clear global and/or local costmap\n\tros::WallTime t0 = ros::WallTime::now();\n\tif (affected_maps_.find(\"global\")!= std::string::npos) {\n\t\tROS_DEBUG(\"Clearing global costmap\");\n\t\tglobal_costmap_->updateMap(x_clear_, y_clear_, invert_area_to_clear_);\n\t}\n\tif (affected_maps_.find(\"local\")!= std::string::npos) {\n\t\tROS_DEBUG(\"Clearing local costmap\");\n\t\tlocal_costmap_->updateMap(x_clear_, y_clear_, invert_area_to_clear_);\n\t}\n\tROS_DEBUG(\"Clearing costmaps took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 46.11341117884209}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// Initialize the PolygonOutlineCells object to collect the cells\n\tPolygonOutlineCells polygon_outline_cells;\n\t// Iterate through the polygon vertices\n\tfor (int i = 0; i < polygon.size() - 1; i++) {\n\t\t// Use raytraceLine to gather cells between each consecutive pair of points\n\t\traytraceLine(polygon[i], polygon[i + 1], polygon_outline_cells);\n\t}\n\t// If the polygon is not empty, close it by connecting the last point to the first\n\tif (!polygon.empty()) {\n\t\traytraceLine(polygon[polygon.size() - 1], polygon[0], polygon_outline_cells);\n\t}\n\t// Get the cells from the PolygonOutlineCells object\n\tpolygon_outline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 51.49383618744605}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\tpolygon_cells.clear();\n\t\treturn;\n\t}\n\tPolygonOutlineCells outline_cells;\n\tMapLocation last_point = polygon.back();\n\tfor (std::vector<MapLocation>::const_iterator point = polygon.begin(); point!= polygon.end(); ++point) {\n\t\tMapLocation current_point = *point;\n\t\traytraceLine(last_point, current_point, outline_cells);\n\t\tlast_point = current_point;\n\t}\n\tif (!outline_cells.empty()) {\n\t\traytraceLine(last_point, polygon.front(), outline_cells);\n\t}\n\toutline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 35.063621934921784}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells polygon_outline_cells;\n\tif (polygon.size() > 0) {\n\t\tMapLocation last_point = polygon[0];\n\t\tfor (unsigned int i = 1; i < polygon.size(); i++) {\n\t\t\tMapLocation current_point = polygon[i];\n\t\t\traytraceLine(last_point, current_point, polygon_outline_cells);\n\t\t\tlast_point = current_point;\n\t\t}\n\t\tif (polygon_outline_cells.size() > 0) {\n\t\t\tMapLocation first_point = polygon[0];\n\t\t\traytraceLine(last_point, first_point, polygon_outline_cells);\n\t\t}\n\t}\n\tpolygon_cells = polygon_outline_cells.getPolygonOutlineCells();\n}", "CodeBleu_score": 45.06723182338349}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tif (!pub.getNumSubscribers()) {\n\t\treturn;\n\t}\n\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 65.70906162299246}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t", "CodeBleu_score": 0.7655082089124154}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// lock the costmap mutex\n\tcostmap_->lock();\n\t// get the resolution\n\tdouble resolution = costmap_->getResolution();\n\t// set the header\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\t// set the resolution\n\tgrid_.info.resolution = resolution;\n\t// set the width and height\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\t// convert the map coordinates to world coordinates for the origin\n\ttf::Stamped<tf::Pose> origin;\n\tcostmap_->mapToWorld(0, 0, origin.getOrigin().x, origin.getOrigin().y);\n\t// set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin.getOrigin().x;\n\tgrid_.info.origin.position.y = origin.getOrigin().y;\n\tgrid_.info.origin.position.z = 0.0;\n\torigin.getBasis().getRotation(grid_.info.origin.orientation);\n\t// save the origin coordinates\n\tdouble origin_x = origin.getOrigin().x;\n\tdouble origin_y = origin.getOrigin().y;\n\t// resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\t// populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < grid_.info.width; i++) {\n\t\tfor (unsigned int j = 0; j < grid_.info.height; j++) {\n\t\t\tunsigned int index = i + j * grid_.info.width;\n\t\t\tunsigned int cost = costmap_->getCharMap()[i][j];\n\t\t\tgrid_.data[index] = COSTMAP_2D_TRANSLATION[cost];\n\t\t}\n\t}\n\t// unlock the costmap mutex\n\tcostmap_->unlock();\n}", "CodeBleu_score": 65.71028163535325}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t", "CodeBleu_score": 0.7655082089124154}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t/*\n * If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n */\n  if (new_config.footprint == old_config.footprint &&\n      new_config.inscribed_radius == old_config.inscribed_radius &&\n      new_config.circumscribed_radius == old_config.circumscribed_radius) {\n    return;\n  }\n/*\n * If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n */\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> footprint;\n    if (makeFootprintFromString(new_config.footprint, footprint)) {\n      setUnpaddedRobotFootprint(footprint);\n    } else {\n      ROS_ERROR(\"The footprint string is invalid. Using the default footprint.\");\n    }\n  } else {\n/*\n * If the footprint string is invalid, it logs an error.\n */\n    ROS_ERROR(\"The footprint string is invalid. Using the default footprint.\");\n/*\n * If no valid footprint string is provided, it sets the footprint based on the robot radius.\n */\n    std::vector<geometry_msgs::Point> footprint;\n    if (makeFootprintFromRadius(new_config.inscribed_radius, new_config.circumscribed_radius, footprint)) {\n      setUnpaddedRobotFootprint(footprint);\n    } else {\n      ROS_ERROR(\"The footprint could not be computed. Using the default footprint.\");\n    }\n  }\n}", "CodeBleu_score": 64.05987740142946}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tstd::vector<geometry_msgs::Point> points;\n\tif (new_config.footprint.size() > 0) {\n\t\tif (new_config.footprint[0].x == old_config.footprint[0].x && new_config.footprint[0].y == old_config.footprint[0].y && new_config.footprint[0].z == old_config.footprint[0].z && new_config.footprint[1].x == old_config.footprint[1].x && new_config.footprint[1].y == old_config.footprint[1].y && new_config.footprint[1].z == old_config.footprint[1].z) {\n\t\t\treturn;\n\t\t}\n\t\tif (makeFootprintFromString(new_config.footprint, points)) {\n\t\t\tsetUnpaddedRobotFootprint(points);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\tif (new_config.robot_radius > 0) {\n\t\tmakeFootprintFromRadius(new_config.robot_radius, points);\n\t\tsetUnpaddedRobotFootprint(points);\n\t} else {\n\t\tROS_ERROR(\"Robot radius must be greater than 0.  Please fix your.yaml file.\");\n\t}\n}", "CodeBleu_score": 58.36965023468198}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t/*\n * If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n */\n  if (new_config.footprint == old_config.footprint && new_config.inflation_radius == old_config.inflation_radius) {\n    return;\n  }\n\n/*\n * If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n */\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    if (!makeFootprintFromString(new_config.footprint, points)) {\n      ROS_ERROR(\"The footprint string '%s' is invalid.  Using default footprint.\", new_config.footprint.c_str());\n    } else {\n      setUnpaddedRobotFootprint(points);\n    }\n  } else {\n/*\n * If the footprint string is invalid, it logs an error.\n */\n    if (new_config.inflation_radius <= 0.0) {\n      ROS_ERROR(\"The inflation radius must be greater than zero.  Using default inflation radius.\");\n      new_config.inflation_radius = old_config.inflation_radius;\n    }\n/*\n * If no valid footprint string is provided, it sets the footprint based on the robot radius.\n */\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.inflation_radius));\n  }\n}", "CodeBleu_score": 66.57707738595649}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get the robot's current pose\n\tgeometry_msgs::PoseStamped new_pose;\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN(\"Failed to get robot pose. Reconfigure canceled.\");\n\t\tcancelReconfiguration();\n\t\treturn;\n\t}\n\n\t// check if the robot's pose has changed\n\tif (new_pose.pose.position.x == last_pose_.pose.position.x && new_pose.pose.position.y == last_pose_.pose.position.y &&\n\t\t\tnew_pose.pose.orientation.x == last_pose_.pose.orientation.x && new_pose.pose.orientation.y == last_pose_.pose.orientation.y &&\n\t\t\tnew_pose.pose.orientation.z == last_pose_.pose.orientation.z && new_pose.pose.orientation.w == last_pose_.pose.orientation.w) {\n\t\treturn;\n\t}\n\n\t// update the last pose\n\tlast_pose_ = new_pose;\n\n\t// check if the robot has moved far enough to warrant reconfiguring the costmap\n\tif (sqrt(pow(last_pose_.pose.position.x - initial_pose_.pose.position.x, 2) + pow(last_pose_.pose.position.y - initial_pose_.pose.position.y, 2)) > reconfigure_distance_) {\n\t\t// reconfigure the costmap\n\t\treconfigureCB(reconfigure_srv_);\n\t}\n}", "CodeBleu_score": 53.673530458309074}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tROS_INFO(\"movementCB\");\n\tgeometry_msgs::PoseStamped new_pose;\n\tif (getRobotPose(new_pose)) {\n\t\tnew_pose.header.stamp = ros::Time::now();\n\t\tnew_pose.header.frame_id = global_frame_;\n\t\tnew_pose.pose.position.z = 0;\n\t\tnew_pose.pose.orientation.w = 1;\n\t\tnew_pose.pose.orientation.x = 0;\n\t\tnew_pose.pose.orientation.y = 0;\n\t\tnew_pose.pose.orientation.z = 0;\n\t\tif (new_pose.pose.position.x!= last_pose_.pose.position.x || new_pose.pose.position.y!= last_pose_.pose.position.y) {\n\t\t\tROS_INFO(\"new_pose.pose.position.x = %f, last_pose_.pose.position.x = %f\", new_pose.pose.position.x, last_pose_.pose.position.x);\n\t\t\tROS_INFO(\"new_pose.pose.position.y = %f, last_pose_.pose.position.y = %f\", new_pose.pose.position.y, last_pose_.pose.position.y);\n\t\t\tlast_pose_ = new_pose;\n\t\t\t// publish the new pose\n\t\t\tnew_pose_pub_.publish(new_pose);\n\t\t}\n\t} else {\n\t\tROS_WARN(\"Failed to get current robot pose, cancelling reconfigure.\");\n\t\tcancel_reconfigure_ = true;\n\t}\n}", "CodeBleu_score": 44.97250437995901}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t//  ROS_DEBUG(\"movementCB\");\n  geometry_msgs::PoseStamped global_pose;\n  if (!getRobotPose(global_pose)) {\n    ROS_WARN(\"Could not get robot pose, cancelling reconfiguration\");\n    reconfigure_timer_.stop();\n    return;\n  }\n\n  // check if the pose has changed\n  if (new_pose_ == global_pose) {\n    return;\n  }\n  new_pose_ = global_pose;\n  // check if the pose has changed\n  if (new_pose_ == global_pose) {\n    return;\n  }\n  new_pose_ = global_pose;\n  reconfigure_timer_.stop();\n  reconfigure_timer_.start();\n}", "CodeBleu_score": 59.40252655746955}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\t// If the costmap is stopped, re-subscribe to topics and re-activate plugins\n\tif (stopped_) {\n\t\t// Get the list of plugins\n\t\tstd::vector<boost::shared_ptr<Layer> > plugins = layered_costmap_->getPlugins();\n\n\t\t// Loop through the plugins and re-subscribe to topics and re-activate them\n\t\tfor (unsigned int i = 0; i < plugins.size(); ++i) {\n\t\t\t// Get the plugin\n\t\t\tboost::shared_ptr<Layer> plugin = plugins[i];\n\n\t\t\t// Activate the plugin\n\t\t\tplugin->activate();\n\n\t\t\t// Subscribe to the topics\n\t\t\tplugin->subscribe();\n\t\t}\n\n\t\t// Set the stopped flag to false\n\t\tstopped_ = false;\n\t}\n\n\t// Wait until ROS is running\n\twhile (!ros::isInitialized()) {\n\t\tROS_ERROR(\"Costmap2DROS::start(): ROS has not been initialized, waiting before starting.\");\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// Wait until the costmap is initialized\n\twhile (!layered_costmap_->isCurrent()) {\n\t\tROS_ERROR(\"Costmap2DROS::start(): Costmap has not been initialized, waiting before starting.\");\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// Wait until the map update thread is active\n\twhile (!map_update_thread_active_) {\n\t\tROS_ERROR(\"Costmap2DROS::start(): Map update thread is not active, waiting before starting.\");\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// Set the stop updates flag to false\n\tstop_updates_ = false;\n}", "CodeBleu_score": 48.89055940328933}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\t// TODO: check if plugins are stopped\n\t\t// TODO: re-subscribe to topics\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\t\t// TODO: wait until ROS is running, the costmap is initialized, and the map update thread is active\n\t}\n}", "CodeBleu_score": 9.46001251655957}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\t// Re-subscribe to topics\n\t\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_->begin(); plugin!= plugins_->end(); ++plugin) {\n\t\t\t(*plugin)->activate();\n\t\t}\n\t\tstopped_ = false;\n\t}\n\t// Wait until ROS is running\n\twhile (!ros::isInitialized()) {\n\t\tROS_INFO(\"Costmap2DROS::start: Waiting for ROS to initialize...\");\n\t\tros::spinOnce();\n\t\tloop_rate_.sleep();\n\t}\n\t// Wait until the costmap is initialized\n\twhile (costmap_ == NULL) {\n\t\tROS_INFO(\"Costmap2DROS::start: Waiting for costmap to initialize...\");\n\t\tros::spinOnce();\n\t\tloop_rate_.sleep();\n\t}\n\t// Wait until the map update thread is active\n\twhile (!map_update_thread_active_) {\n\t\tROS_INFO(\"Costmap2DROS::start: Waiting for map update thread to start...\");\n\t\tros::spinOnce();\n\t\tloop_rate_.sleep();\n\t}\n}", "CodeBleu_score": 53.21164987316087}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// TODO Auto-generated method stub\n\n}", "CodeBleu_score": 1.543726824886217}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the observation_keep_time_ is zero, it keeps only the most recent observation.\n\tif (observation_keep_time_ == 0) {\n\t\t// If the list is empty, return.\n\t\tif (observation_list_.empty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, remove all but the most recent observation.\n\t\t// Note: This is a bit of a hack, but it's the easiest way to do it.\n\t\t// We could make a separate function to remove the oldest observation, but this is good enough for now.\n\t\twhile (observation_list_.size() > 1) {\n\t\t\tobservation_list_.erase(observation_list_.begin());\n\t\t}\n\t} else {\n\t\t// Otherwise, iterate through the list and remove observations that are older than the specified keep time.\n\t\twhile (!observation_list_.empty()) {\n\t\t\t// Get the oldest observation.\n\t\t\tObservation oldest_observation = observation_list_.front();\n\n\t\t\t// Get the current time.\n\t\t\tros::Time current_time = ros::Time::now();\n\n\t\t\t// Get the time since the oldest observation was received.\n\t\t\tros::Duration time_since_oldest = current_time - oldest_observation.header.stamp;\n\n\t\t\t// If the time since the oldest observation is less than the keep time, keep it.\n\t\t\tif (time_since_oldest.toSec() < observation_keep_time_) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Otherwise, remove it.\n\t\t\tobservation_list_.erase(observation_list_.begin());\n\t\t}\n\t}\n}", "CodeBleu_score": 44.329581391145055}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// TODO Auto-generated method stub\n\n}", "CodeBleu_score": 1.543726824886217}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t//  std::cout << \"start_index: \" << start_index << \" end_index: \" << end_index << std::endl;\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n  double delta_yaw = shortest_angular_distance / (end_index - start_index);\n  for (int i = start_index + 1; i < end_index; i++) {\n    double angle = start_yaw + (i - start_index) * delta_yaw;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 70.755195921003}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t/*\n * Calculate the yaw angles at the start and end indices.\n */\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n/*\n * Determine the shortest angular distance between them.\n */\n  double shortest_angle = angles::shortest_angular_distance(start_angle, end_angle);\n/*\n * Compute the incremental change in angle for each pose.\n */\n  double angle_increment = shortest_angle / (end_index - start_index);\n/*\n * Update the orientation of each pose in the specified range accordingly.\n */\n  for (int i = start_index + 1; i < end_index; i++) {\n    double angle = start_angle + (i - start_index) * angle_increment;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 65.86243404775023}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n//    ROS_INFO(\"OrientationFilter::interpolate: start_index: %d, end_index: %d\", start_index, end_index);\n\n    // get the start and end poses\n    geometry_msgs::PoseStamped start = path.at(start_index);\n    geometry_msgs::PoseStamped end = path.at(end_index);\n\n    // get the yaw angles of the start and end poses\n    double start_yaw = tf2::getYaw(start.pose.orientation);\n    double end_yaw = tf2::getYaw(end.pose.orientation);\n\n    // get the shortest angular distance between the start and end yaw angles\n    double shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // compute the incremental change in angle for each pose in the specified range\n    double increment = shortest_angular_distance / (end_index - start_index);\n\n    // update the orientation of each pose in the specified range\n    for (int i = start_index; i < end_index; i++) {\n        geometry_msgs::PoseStamped pose = path.at(i);\n        double angle = start_yaw + increment * (i - start_index);\n        set_angle(&pose, angle);\n        path.at(i) = pose;\n    }\n}", "CodeBleu_score": 58.62506203969122}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\t// Call makePlan to generate a path\n\tif (!makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\tROS_ERROR(\"No plan found\");\n\t\tresp.error_code = resp.error_code.FAILURE;\n\t\treturn true;\n\t}\n\t// Update the response with the success status and the generated path\n\tresp.error_code = resp.error_code.SUCCESS;\n\treturn true;\n}", "CodeBleu_score": 47.68159440581611}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// Set the frame_id of the start and goal to \"map\"\n\tstd::string start_frame = global_frame_;\n\tstd::string goal_frame = global_frame_;\n\n\t// Call makePlan to generate a path\n\tif (makePlan(req.start, req.goal, req.tolerance, resp.plan.poses)) {\n\t\t// Set the response with the success status\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.plan.header.frame_id = start_frame;\n\t\tresp.error_code = resp.error_code.SUCCESS;\n\t\t// Return true to indicate that the service was processed\n\t\treturn true;\n\t} else {\n\t\t// Set the response with the error status\n\t\tresp.error_code = resp.error_code.FAILURE;\n\t\t// Return false to indicate that the service was not processed\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 39.92101021421346}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_DEBUG(\"Received makePlanService request\");\n\tros::Time start_time = ros::Time::now();\n\tstd::vector<geometry_msgs::PoseStamped> global_plan;\n\tbool success = makePlan(req.start, req.goal, global_plan);\n\tresp.plan.poses.clear();\n\tresp.plan.poses.resize(global_plan.size());\n\tfor (unsigned int i = 0; i < global_plan.size(); ++i) {\n\t\tresp.plan.poses[i] = global_plan[i];\n\t}\n\tresp.plan.header.stamp = start_time;\n\tresp.plan.header.frame_id = frame_id_;\n\tresp.cost = cost_;\n\tresp.message = (success)? \"Found a plan\" : \"Could not find a plan\";\n\tresp.error_code = (success)? 0 : 1;\n\tROS_DEBUG(\"makePlanService: done in %.4f seconds\", (ros::Time::now() - start_time).toSec());\n\treturn true;\n}", "CodeBleu_score": 46.80249788915276}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t}", "CodeBleu_score": 18.654488076502528}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tprivate_nh = ros::NodeHandle(\"~/\" + name);\n\tmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 66.96111934519689}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t/*\n * This constructor, PlannerWithCostmap::PlannerWithCostmap, initializes a PlannerWithCostmap object with a given name and Costmap2DROS pointer.\nIt calls the base class constructor with the planner name, costmap, and global frame ID.\nIt sets up a private ROS node handle, advertises a \"make_plan\" service, and subscribes to the \"goal\" topic to receive PoseStamped messages for planning purposes.\n */\n    private_nh = new ros::NodeHandle(name);\n    make_plan_service = private_nh->advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh->subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 64.81188279094914}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn false;\n\t}\n\n\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n\t\twy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_ERROR(\"The world coordinates passed to worldToMap are out of bounds for the costmap.\");\n\t\treturn false;\n\t}\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\treturn true;\n}", "CodeBleu_score": 42.64621836025002}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX()) {\n\t\tROS_WARN(\"The world coordinates supplied to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\t\"World coordinates: (%.2f, %.2f)\", wx, wy);\n\t\treturn false;\n\t}\n\tif (wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_WARN(\"The world coordinates supplied to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\t\"World coordinates: (%.2f, %.2f)\", wx, wy);\n\t\treturn false;\n\t}\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 39.65424603942919}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_DEBUG(\"The world coordinates passed to worldToMap are outside the bounds of the costmap.\");\n\t\treturn false;\n\t}\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\tROS_DEBUG(\"The map coordinates returned from worldToMap are outside the bounds of the costmap.\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 43.13855337873744}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\nROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\nreturn;\n}\n//create a message for the plan\nnav_msgs::Path gui_path;\ngui_path.poses.resize(path.size());\ngui_path.header.frame_id = frame_id_;\ngui_path.header.stamp = ros::Time::now();\n// Extract the plan in world co-ordinates, we assume the path is all in the same frame\nfor (unsigned int i = 0; i < path.size(); ++i) {\ngui_path.poses[i] = path[i];\n}\nplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 91.27969511569752}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path with the plan to publish\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.98158984520875}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 92.89079784387178}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED\nros::Time::now\nROS_DEBUG_NAMED\n\"goal received\"\nactionlib::SimpleActionClient<move_base_msgs::MoveBaseAction> ac(\"move_base\", true);\nROS_DEBUG_NAMED\n\"waiting for move_base action server...\"\nac.waitForServer();\nROS_DEBUG_NAMED\n\"connected to action server\"\n// wrap the PoseStamped in the action message\nmove_base_msgs::MoveBaseGoal goal_msg;\ngoal_msg.target_pose.header.frame_id = \"map\";\ngoal_msg.target_pose.header.stamp = ros::Time::now();\ngoal_msg.target_pose.pose = goal->pose;\n// send the goal\nac.sendGoal(goal_msg);\n}", "CodeBleu_score": 41.11480568989998}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"Received a goal of x: %f, y: %f, theta: %f\", goal->pose.position.x, goal->pose.position.y, tf::getYaw(goal->pose.orientation));\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 68.41719527970595}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t", "CodeBleu_score": 7.204876027809698}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tROS_INFO(\"distance check\");\n  if (getSqDistance() > sq_limited_distance_) {\n    ROS_INFO(\"Robot moved far enough, removing speed limit\");\n    if (remove_limit_thread_!= NULL) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 76.40775971939652}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tROS_INFO(\"Distance check\");\nif (getSqDistance() > limit_sq_distance_) {\nROS_INFO(\"Distance check passed\");\nremove_limit_thread_->join();\ndelete remove_limit_thread_;\nremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\ndistance_check_timer_.stop();\n}\n}", "CodeBleu_score": 58.65417672050487}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tROS_INFO(\"distanceCheck\");\n  if (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"distanceCheck: distance limit reached\");\n    if (remove_limit_thread_!= NULL) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 64.97761040566644}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG(\"Received a goal pose of (%.2f, %.2f)\", goal->pose.position.x, goal->pose.position.y);\n\n\t// Get the current global pose of the robot\n\tgeometry_msgs::PoseStamped global_pose;\n\tif(!getRobotPose(global_pose, goal->header)) {\n\t\tROS_ERROR(\"Failed to get current pose of robot, aborting\");\n\t\treturn;\n\t}\n\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tmakePlan(global_pose, *goal, plan);\n\n\t// Publish the plan\n\tpublishPlan(plan);\n}", "CodeBleu_score": 50.803733238398884}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current robot pose from the costmap\n\tgeometry_msgs::PoseStamped current_position = *costmap_->getRobotPose();\n\t// Generate a path from the current pose to the goal pose\n\tmakePlan(current_position, *goal, plan_);\n\t// If a valid plan was found, publish it\n\tif (plan_.size() > 0) {\n\t\tpub_.publish(plan_);\n\t}\n}", "CodeBleu_score": 50.953369263894785}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current pose of the robot\n\tgeometry_msgs::PoseStamped global_pose = *tf::transformPose(global_frame_, *getRobotPose());\n\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tmakePlan(global_pose, *goal, plan);\n\n\t// If a valid plan was found, publish it to the plan topic\n\tif(!plan.empty()) {\n\t\tpublishPlan(plan);\n\t}\n}", "CodeBleu_score": 50.51786393215486}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a service request\n\tgimbal_autolanding_msgs::srv::ParamSet::Request srv_req;\n\n\t// Assign the parameter ID and value to the service request\n\tsrv_req.id = param_set.id;\n\tsrv_req.value = param_set.value;\n\n\t// Send the service request\n\tthis->param_set_client_.call(srv_req);\n}", "CodeBleu_score": 54.955958490944454}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// TODO: implement\n}", "CodeBleu_score": 5.3681156452403656}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// create the service request\n\t// assign the parameter ID and value to the service request\n\t// call the param_set_client_ to send the request\n}", "CodeBleu_score": 5.3681156452403656}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\t// Wait for a connection from the ground station on a specified port\n\twaitConnectionFromGroundStation();\n\n\t// Enter a loop to accept incoming connections, receive data, and process it\n\twhile (true) {\n\t\t// Accept an incoming connection\n\t\taccept();\n\n\t\t// Receive data\n\t\tpubMsg = recv();\n\n\t\t// Check if data was received successfully\n\t\tif (pubMsg.length() > 0) {\n\t\t\t// Decode the message\n\t\t\tdecodeMsg();\n\t\t}\n\t\t// Log an error and close the socket if the received message length is zero or less\n\t\telse {\n\t\t\tperror(\"recv\");\n\t\t\tROS_ERROR(\"Received zero-length message from ground station.\");\n\t\t\tclose();\n\t\t\texit(1);\n\t\t}\n\t}\n}", "CodeBleu_score": 13.281657083769344}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// Wait for connection from ground station\n\twaitConnectionFromGroundStation();\n\n\t// Accept incoming connections and receive data\n\twhile (true) {\n\t\t// Accept incoming connection\n\t\tint clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, (socklen_t *) &clientAddressLength);\n\n\t\t// Receive data\n\t\tint bytesReceived = recv(clientSocket, buffer, BUFFER_SIZE, 0);\n\n\t\t// Process received data\n\t\tif (bytesReceived > 0) {\n\t\t\t// Decode message\n\t\t\tdecodeMsg();\n\n\t\t\t// Publish message\n\t\t\tpubMsg();\n\t\t} else {\n\t\t\t// Log error\n\t\t\tperror(\"ERROR: Received zero or less bytes\");\n\t\t}\n\n\t\t// Close socket\n\t\tclose(clientSocket);\n\t}\n}", "CodeBleu_score": 23.48687968499057}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// create socket\n\tint server_fd;\n\tif ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n\t\tperror(\"socket\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// set socket options\n\tint opt = 1;\n\tif (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n\t\tperror(\"setsockopt\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// bind socket to port\n\tstruct sockaddr_in address;\n\taddress.sin_family = AF_INET;\n\taddress.sin_addr.s_addr = INADDR_ANY;\n\taddress.sin_port = htons(port);\n\n\tif (bind(server_fd, (struct sockaddr *) &address, sizeof(address)) < 0) {\n\t\tperror(\"bind\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// listen to socket\n\tif (listen(server_fd, 3) < 0) {\n\t\tperror(\"listen\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// wait for connection from ground station\n\tint addrlen = sizeof(address);\n\tint new_socket;\n\tif ((new_socket = accept(server_fd, (struct sockaddr *) &address, (socklen_t *) &addrlen)) < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// accept connection and receive data\n\twhile (true) {\n\t\tint recv_len = recv(new_socket, buffer, 1024, 0);\n\t\tif (recv_len <= 0) {\n\t\t\tROS_ERROR(\"Error receiving data\");\n\t\t\tclose(new_socket);\n\t\t\tbreak;\n\t\t}\n\n\t\t// decode message and publish\n\t\tdecodeMsg(buffer, recv_len);\n\t}\n\n\t// close socket\n\tclose(server_fd);\n}", "CodeBleu_score": 51.41036598429245}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_) {\n\t\t// Find the UAV by ID\n\t\tauto it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\t// Publish the command to the UAV\n\t\t\tit->second->uavCmdPub.publish(uav_cmd);\n\t\t}\n\t} else {\n\t\t// Publish the command to the UAV\n\t\tthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 46.82251431138363}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_) {\n\t\t// Find the UAV in swarm_control_simulation_ by ID\n\t\tauto it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\t// Publish the UAV command to the corresponding UAV\n\t\t\t(*it).second->uavCmdPub.publish(uav_cmd);\n\t\t}\n\t} else {\n\t\t// Publish the UAV command to the corresponding UAV using uav_basic_\n\t\tthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 49.08104978084113}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_) {\n\t\tthis->swarm_control_simulation_[uav_cmd.uav_id]->uavCmdPub.publish(uav_cmd);\n\t} else {\n\t\tthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 24.402623318707047}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif(mode_selection.use_mode == 0) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n\telse if(mode_selection.use_mode == 1) {\n\t\tcreateMode(mode_selection.mode_name);\n\t}\n\telse if(mode_selection.use_mode == 2) {\n\t\tsystem(\"rebootnx\");\n\t}\n\telse if(mode_selection.use_mode == 3) {\n\t\tsystem(\"exitnx\");\n\t}\n}", "CodeBleu_score": 41.783789590227165}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETESTMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 49.30237061978035}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETESTMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 49.30237061978035}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (this->heartbeat_counter < this->max_heartbeat_count) {\n\t\tthis->heartbeat_counter++;\n\t}\n\telse {\n\t\tROS_ERROR(\"Heartbeat lost.\");\n\t\tif (this->vehicle_type == swarm) {\n\t\t\tthis->triggerSwarmControl();\n\t\t}\n\t\telse if (this->vehicle_type == UAV) {\n\t\t\tthis->triggerUAV();\n\t\t}\n\t\telse if (this->vehicle_type == UGV) {\n\t\t\tthis->triggerUGV();\n\t\t}\n\t}\n}", "CodeBleu_score": 8.211191070672895}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check if the heartbeat has been received recently\n\tif (ros::Time::now().toSec() - heartbeat_time.toSec() < 10.0) {\n\t\t// Increment the heartbeat counter\n\t\theartbeat_counter++;\n\t} else {\n\t\t// Reset the heartbeat counter\n\t\theartbeat_counter = 0;\n\t}\n\n\t// If the heartbeat counter exceeds the threshold, print an error message and trigger appropriate actions\n\tif (heartbeat_counter > 10) {\n\t\tif (vehicle_type == \"swarm\") {\n\t\t\tROS_ERROR(\"Swarm Control has lost connection to the UAV. Please check that the UAV is still connected to the swarm.\");\n\t\t\ttriggerSwarmControl();\n\t\t} else if (vehicle_type == \"UAV\") {\n\t\t\tROS_ERROR(\"UAV has lost connection to the swarm. Please check that the swarm is still connected to the UAV.\");\n\t\t\ttriggerUAV();\n\t\t} else if (vehicle_type == \"UGV\") {\n\t\t\tROS_ERROR(\"UGV has lost connection to the swarm. Please check that the swarm is still connected to the UGV.\");\n\t\t\ttriggerUGV();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.91801590412509}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif(heartbeat_counter >= HEARTBEAT_COUNT_THRESHOLD) {\n\t\tif(vehicle_type == \"swarm\") {\n\t\t\tROS_ERROR(\"Swarm Control: No heartbeat from swarm control. Disconnecting from swarm control.\");\n\t\t\tdisconnect_flag = true;\n\t\t} else if(vehicle_type == \"UAV\") {\n\t\t\tROS_ERROR(\"UAV: No heartbeat from UAV. Disconnecting from UAV.\");\n\t\t\tdisconnect_flag = true;\n\t\t} else if(vehicle_type == \"UGV\") {\n\t\t\tROS_ERROR(\"UGV: No heartbeat from UGV. Disconnecting from UGV.\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t}\n\theartbeat_counter++;\n}", "CodeBleu_score": 28.750273698916452}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract the drone ID and trajectory data from the message\n\tint drone_id = msg->drone_id;\n\tstd::vector<prometheus_msgs::Bspline> trajs = msg->traj;\n\n\t// Initialize a MultiBsplines message\n\tprometheus_msgs::MultiBsplines multi_bsplines;\n\tmulti_bsplines.drone_id = drone_id;\n\n\t// For each trajectory, initialize a Bspline struct, set its attributes, and populate its knots, position points, and yaw points\n\tfor (int i = 0; i < trajs.size(); i++) {\n\t\tprometheus_msgs::Bspline bspline;\n\t\tbspline.knots = trajs[i].knots;\n\t\tbspline.pos_pts = trajs[i].pos_pts;\n\t\tbspline.yaw_pts = trajs[i].yaw_pts;\n\t\tbspline.start_time = trajs[i].start_time;\n\t\tbspline.end_time = trajs[i].end_time;\n\t\tbspline.duration = trajs[i].duration;\n\t\tbspline.num_knots = trajs[i].num_knots;\n\t\tbspline.num_pos_pts = trajs[i].num_pos_pts;\n\t\tbspline.num_yaw_pts = trajs[i].num_yaw_pts;\n\t\tmulti_bsplines.traj.push_back(bspline);\n\t}\n\n\t// Encode the MultiBsplines data and send it via TCP using the communication module\n\tthis->communication->encodeMsg(multi_bsplines);\n\tthis->communication->sendMsgByTcp();\n}", "CodeBleu_score": 37.14920657209375}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tstd::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n\t// Extract the drone ID and trajectory data from the message\n\tint drone_id = msg->drone_id;\n\tstd::vector<prometheus_msgs::Bspline> traj = msg->traj;\n\n\t// Initialize a MultiBsplines message\n\tprometheus_msgs::MultiBsplines multi_bsplines_msg;\n\tmulti_bsplines_msg.drone_id = drone_id;\n\n\t// For each trajectory, initialize a Bspline struct, set its attributes, and populate its knots, position points, and yaw points\n\tfor (int i = 0; i < traj.size(); i++) {\n\t\tprometheus_msgs::Bspline bspline;\n\t\tbspline.knots = traj[i].knots;\n\t\tbspline.pos_pts = traj[i].pos_pts;\n\t\tbspline.yaw_pts = traj[i].yaw_pts;\n\t\tbspline.start_time = traj[i].start_time;\n\t\tbspline.end_time = traj[i].end_time;\n\n\t\t// Populate the MultiBsplines message with the Bspline struct\n\t\tmulti_bsplines_msg.traj.push_back(bspline);\n\t}\n\n\t// Encode the MultiBsplines message and send it via TCP using the communication module\n\tthis->communication->encodeMsg(multi_bsplines_msg);\n}", "CodeBleu_score": 32.216566526827414}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert input message to pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Compress point cloud using octree\n\toctree_compression.setInputCloud(cloud.makeShared());\n\tstd::vector<uint8_t> compressed_data;\n\toctree_compression.encodePointCloud(compressed_data);\n\n\t// Create new PointCloud2 message with compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.width = compressed_data.size();\n\tcompressed_msg.height = 1;\n\tcompressed_msg.fields.resize(1);\n\tcompressed_msg.fields[0].name = \"compressed\";\n\tcompressed_msg.fields[0].offset = 0;\n\tcompressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n\tcompressed_msg.fields[0].count = 1;\n\tcompressed_msg.is_bigendian = false;\n\tcompressed_msg.point_step = sizeof(uint8_t);\n\tcompressed_msg.row_step = compressed_msg.width * compressed_msg.point_step;\n\tcompressed_msg.data.resize(compressed_msg.row_step * compressed_msg.height);\n\n\t// Copy compressed data into PointCloud2 message\n\tstd::memcpy(&compressed_msg.data[0], compressed_data.data(), compressed_msg.data.size());\n\n\t// Return compressed message\n\treturn compressed_msg;\n}", "CodeBleu_score": 39.98103139747977}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create an octree compression object\n\toctomap::OcTree tree(0.05);\n\n\t// Add the points to the octree\n\tfor (auto point : cloud) {\n\t\ttree.updateNode(octomap::point3d(point.x, point.y, point.z), true);\n\t}\n\n\t// Create a new PointCloud2 message\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Compress the octree and store the compressed data\n\tstd::string compressed_data;\n\toctomap::OcTreeSerialization::serializeBinary(tree, compressed_data);\n\n\t// Set the compressed data in the PointCloud2 message\n\tcompressed_msg.data = compressed_data;\n\n\t// Return the compressed PointCloud2 message\n\treturn compressed_msg;\n}", "CodeBleu_score": 26.5585096705546}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\t// Compress the point cloud\n\tstd::string compressed_str;\n\toctree_compression.encodePointCloud(cloud, compressed_str);\n\t// Copy the compressed data to the new message\n\tcompressed_msg.data = compressed_str;\n\t// Return the new message\n\treturn compressed_msg;\n}", "CodeBleu_score": 20.870062678052676}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.53973655827699}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size; i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 83.37392897600864}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size; i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 77.17147512665198}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize a MultiUGVState message\n\tmulti_ugv_state.ugv_state_all.clear();\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (auto ugv_state : m_multi_ugv_state.ugv_state_all) {\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state_msg.id = ugv_state.id;\n\t\tugv_state_msg.battery = ugv_state.battery;\n\t\tugv_state_msg.position.x = ugv_state.position.x;\n\t\tugv_state_msg.position.y = ugv_state.position.y;\n\t\tugv_state_msg.position.z = ugv_state.position.z;\n\t\tugv_state_msg.velocity.x = ugv_state.velocity.x;\n\t\tugv_state_msg.velocity.y = ugv_state.velocity.y;\n\t\tugv_state_msg.velocity.z = ugv_state.velocity.z;\n\t\tugv_state_msg.attitude.roll = ugv_state.attitude.roll;\n\t\tugv_state_msg.attitude.pitch = ugv_state.attitude.pitch;\n\t\tugv_state_msg.attitude.yaw = ugv_state.attitude.yaw;\n\t\t// Increment the UGV count and add each UGVState to the MultiUGVState message\n\t\tmulti_ugv_state.ugv_count++;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state_msg);\n\t}\n\t// Publish the assembled MultiUGVState message\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 39.38985415583329}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// calculate the cost and gradient of the B-spline trajectory concerning moving objects\n\t// iterates through control points of the B-spline, computes the predicted positions of moving objects, and evaluates the distance between control points and these objects\n\t// if the distance is less than a specified clearance, it updates the cost and gradient based on the distance error\n\t// initialize the cost and gradient\n\tcost = 0.0;\n\tgradient.resize(q.rows(), q.cols());\n\tgradient.setZero();\n\t// iterate through control points of the B-spline\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// compute the predicted positions of moving objects\n\t\tEigen::Vector3d obj_prid;\n\t\tmoving_objs_->predictObjPos(q.col(i), obj_prid);\n\t\t// evaluate the distance between control points and these objects\n\t\tif ((cps_.points.col(i) - obj_prid).norm() < moving_objs_->getClearance()) {\n\t\t\t// if the distance is less than a specified clearance, update the cost and gradient based on the distance error\n\t\t\t// update the cost\n\t\t\tcost += (cps_.points.col(i) - obj_prid).norm();\n\t\t\t// update the gradient\n\t\t\tgradient.col(i) += (cps_.points.col(i) - obj_prid).normalized();\n\t\t}\n\t}\n}", "CodeBleu_score": 30.329636629481794}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tEigen::Vector3d obj_prid;\n\tdouble dist_error;\n\tdouble dist_error_gradient;\n\n\tcost = 0;\n\tgradient.setZero();\n\n\tfor (int i = 0; i < cps_.points.cols(); i++) {\n\t\tmoving_objs_->evaluateConstVel(cps_.points.col(i), q.cols(i), obj_prid);\n\t\tdist_error = (cps_.points.col(i) - obj_prid).norm();\n\n\t\tif (dist_error < cps_.clearance) {\n\t\t\tcost += pow(dist_error, 2);\n\n\t\t\tdist_error_gradient = 2 * dist_error;\n\t\t\tgradient.col(i) = dist_error_gradient * (cps_.points.col(i) - obj_prid).normalized();\n\t\t}\n\t}\n}", "CodeBleu_score": 37.25265993682073}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost to zero\n\tcost = 0;\n\n\t// Initialize gradient to zero\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through control points\n\tfor (int i = 2; i < q.cols() - 2; i++) {\n\t\t// Calculate positional error\n\t\tEigen::Vector3d x = q.col(i) - ref_pts_[i - 2];\n\n\t\t// Calculate velocity vector\n\t\tEigen::Vector3d v = (ref_pts_[i] - ref_pts_[i - 2]).normalized();\n\n\t\t// Compute squared dot product and cross product\n\t\tdouble xdotv = x.dot(v);\n\t\tEigen::Vector3d xcrossv = x.cross(v);\n\n\t\t// Update cost\n\t\tcost += a2_ * xdotv * xdotv + b2_ * xcrossv.squaredNorm();\n\n\t\t// Update gradient\n\t\tEigen::Vector3d gradient_col = 2 * a2_ * xdotv * v + 2 * b2_ * xcrossv;\n\t\tgradient.col(i - 2) = gradient_col;\n\t\tgradient.col(i - 1) = -gradient_col;\n\t\tgradient.col(i) = gradient_col;\n\t\tgradient.col(i + 1) = -gradient_col;\n\t}\n}", "CodeBleu_score": 45.71723658871483}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost to zero\n\tcost = 0.0;\n\t// Initialize gradient to zero\n\tgradient.setZero();\n\n\t// Iterate through control points\n\tfor (int i = 1; i < q.cols() - 1; i++) {\n\t\t// Compute positional error\n\t\tEigen::Vector3d x = q.col(i) - ref_pts_[i];\n\t\t// Compute velocity vector\n\t\tEigen::Vector3d v = (ref_pts_[i + 1] - ref_pts_[i - 1]) / 2.0;\n\t\t// Compute cross product of positional error and velocity vector\n\t\tEigen::Vector3d xcrossv = x.cross(v);\n\t\t// Compute dot product of positional error and velocity vector\n\t\tdouble xdotv = x.dot(v);\n\t\t// Compute cost function\n\t\tdouble fitness = a2 * xdotv * xdotv + b2 * xcrossv.norm() * xcrossv.norm();\n\t\t// Add to cost\n\t\tcost += fitness;\n\t\t// Compute derivatives\n\t\tEigen::Vector3d xcrossv_norm = xcrossv.normalized();\n\t\tEigen::Vector3d gradient_i = 2.0 * a2 * (xdotv * v + x.dot(v) * v) + 2.0 * b2 * (xcrossv_norm * v.cross(v) + xcrossv.dot(v) * v.cross(v));\n\t\t// Update gradient\n\t\tgradient.col(i) = gradient_i;\n\t}\n}", "CodeBleu_score": 40.62120690497187}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// initialize cost\n\tcost = 0.0;\n\tgradient.setZero(q.rows(), q.cols());\n\n\t// iterate through control points\n\tfor (int i = 2; i < q.cols() - 2; ++i) {\n\t\t// compute positional error\n\t\tEigen::Vector3d err = (q.col(i) - ref_pts_[i]).normalized();\n\n\t\t// compute velocity vector\n\t\tEigen::Vector3d v = (ref_pts_[i + 1] - ref_pts_[i - 1]).normalized();\n\n\t\t// compute dot product and cross product\n\t\tdouble dot = err.dot(v);\n\t\tEigen::Vector3d xcrossv = err.cross(v);\n\n\t\t// update cost\n\t\tcost += a2_ * pow(dot, 2) + b2_ * pow(xcrossv.norm(), 2);\n\n\t\t// update gradient\n\t\tgradient.col(i) += 2 * a2_ * dot * v + 2 * b2_ * xcrossv / xcrossv.norm();\n\t}\n}", "CodeBleu_score": 35.589714386553794}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tUniformBspline jerk_traj = getDerivative().getDerivative();\n\tEigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\tEigen::VectorXd knot = jerk_traj.getKnot();\n\tdouble jerk = 0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\tjerk += pow(ctrl_pts(j, i), 2) * (knot(i + 1) - knot(i));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 62.171602680748464}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd jerk_ctrl_pts = getDerivative().getDerivative().getDerivative().getControlPoints();\n\tdouble total_jerk = 0;\n\tfor (int i = 0; i < jerk_ctrl_pts.rows(); i++) {\n\t\tfor (int j = 0; j < jerk_ctrl_pts.cols(); j++) {\n\t\t\ttotal_jerk += jerk_ctrl_pts(i, j) * jerk_ctrl_pts(i, j) * (u_(i + 1) - u_(i));\n\t\t}\n\t}\n\treturn total_jerk;\n}", "CodeBleu_score": 52.76076265773039}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd jerk_traj = getDerivative().getDerivative().getDerivative();\n\tEigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\tEigen::VectorXd times = jerk_traj.getKnot();\n\tdouble jerk = 0.0;\n\n\tfor (int i = 0; i < ctrl_pts.rows(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.cols(); j++) {\n\t\t\tjerk += pow(ctrl_pts(i, j), 2) * (times(i + 1) - times(i));\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 67.25912521079323}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\tfloat z = depth;\n\tEigen::Vector4d pos_in_camera(x, y, z, 1.0);\n\treturn pos_in_camera;\n}", "CodeBleu_score": 55.14796678361344}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n\treturn pos;\n}", "CodeBleu_score": 47.82676835634672}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_)*depth/fx_;\n\tpos(1) = (v - cy_)*depth/fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 61.20230768794192}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint drone_id = std::stoi(odom.child_frame_id.substr(1));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR_STREAM(\"Failed to extract drone ID from child_frame_id field of odometry message: \" << e.what());\n\t}\n}", "CodeBleu_score": 53.98687943975874}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(1));\n\t\trcvDroneOdomCallbackBase(droneID, odom);\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 50.02042328933213}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\tint droneId;\n\ttry {\n\t\tdroneId = std::stoi(odom.child_frame_id.substr(7));\n\t} catch (std::exception& e) {\n\t\tROS_WARN(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t\treturn;\n\t}\n\trcvDroneOdomCallbackBase(odom, droneId);\n}", "CodeBleu_score": 48.87078840331227}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// TODO: Implement this function\n\t// TODO: Use the drone_id and true_pixel to detect the drone and calculate the pose error\n\t// TODO: Update the debug result to indicate success or failure\n\t// TODO: Publish the pose error\n}", "CodeBleu_score": 3.1919984578694347}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone's true pose in the camera frame\n\tEigen::Vector3d true_pose = drone_poses_[drone_id];\n\n\t// Check if the drone is present\n\tif (true_pose(2)!= 0) {\n\t\t// Calculate the drone's pose in the camera frame\n\t\tEigen::Vector3d pixel_pose = camera_model_.projectPixelTo3dRay(true_pixel);\n\t\tpixel_pose(2) = true_pose(2);\n\n\t\t// Calculate the pose error\n\t\tEigen::Vector3d pose_error = true_pose - pixel_pose;\n\n\t\t// Update the debug result\n\t\tdebug_result_.drone_ids.push_back(drone_id);\n\t\tdebug_result_.true_poses.push_back(true_pose);\n\t\tdebug_result_.pixel_poses.push_back(pixel_pose);\n\t\tdebug_result_.pose_errors.push_back(pose_error);\n\n\t\t// Publish the pose error\n\t\tpose_error_pub_[drone_id].publish(pose_error);\n\t} else {\n\t\t// Update the debug result\n\t\tdebug_result_.drone_ids.push_back(drone_id);\n\t\tdebug_result_.true_poses.push_back(true_pose);\n\t\tdebug_result_.pixel_poses.push_back(Eigen::Vector3d(0, 0, 0));\n\t\tdebug_result_.pose_errors.push_back(Eigen::Vector3d(0, 0, 0));\n\t}\n}", "CodeBleu_score": 42.3168569325724}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (cameFrom.find(current)!= cameFrom.end()) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.04679189896778}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (cameFrom.find(current)!= cameFrom.end()) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.04679189896778}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tGridNodePtr c = current;\n\tpath.push_back(c);\n\twhile (c!= start) {\n\t\tc = cameFrom[c];\n\t\tpath.push_back(c);\n\t}\n\treturn path;\n}", "CodeBleu_score": 49.97380330952754}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: failed to convert start point to index\");\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: failed to convert end point to index\");\n\t\treturn false;\n\t}\n\tif (IsOccupied(start_idx)) {\n\t\tif (!AdjustPointToAvoidObstacle(start_pt, end_pt, start_idx)) {\n\t\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: failed to adjust start point\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsOccupied(end_idx)) {\n\t\tif (!AdjustPointToAvoidObstacle(end_pt, start_pt, end_idx)) {\n\t\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: failed to adjust end point\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 39.69423940471917}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert to grid indices\n\tif (!Coord2Index(start_pt, start_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Start point (%f, %f, %f) is inside an obstacle.\", start_pt.x(), start_pt.y(), start_pt.z());\n\t\treturn false;\n\t}\n\tif (!Coord2Index(end_pt, end_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: End point (%f, %f, %f) is inside an obstacle.\", end_pt.x(), end_pt.y(), end_pt.z());\n\t\treturn false;\n\t}\n\n\t// Adjust start point if it is inside an obstacle\n\tif (checkOccupancy(start_idx)) {\n\t\tVector3d dir = (end_pt - start_pt).normalized();\n\t\tdouble dist = 0.1;\n\t\twhile (checkOccupancy(start_idx)) {\n\t\t\tstart_pt += dir * dist;\n\t\t\tif (!Coord2Index(start_pt, start_idx)) {\n\t\t\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Start point (%f, %f, %f) is inside an obstacle.\", start_pt.x(), start_pt.y(), start_pt.z());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdist += 0.1;\n\t\t}\n\t}\n\n\t// Adjust end point if it is inside an obstacle\n\tif (checkOccupancy(end_idx)) {\n\t\tVector3d dir = (start_pt - end_pt).normalized();\n\t\tdouble dist = 0.1;\n\t\twhile (checkOccupancy(end_idx)) {\n\t\t\tend_pt += dir * dist;\n\t\t\tif (!Coord2Index(end_pt, end_idx)) {\n\t\t\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: End point (%f, %f, %f) is inside an obstacle.\", end_pt.x(), end_pt.y(), end_pt.z());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdist += 0.1;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 52.30681621505726}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start and end points to indices\n\tbool start_converted = ConvertToIndex(start_pt, start_idx);\n\tbool end_converted = ConvertToIndex(end_pt, end_idx);\n\n\t// If either conversion fails, return false\n\tif (!start_converted ||!end_converted) {\n\t\treturn false;\n\t}\n\n\t// If start point is inside an obstacle, adjust it\n\tif (checkOccupancy(start_idx)) {\n\t\t// Find a point on the surface of the obstacle that is not inside the obstacle\n\t\tVector3i start_surface_idx = start_idx;\n\t\twhile (checkOccupancy(start_surface_idx)) {\n\t\t\tstart_surface_idx += (start_idx - end_idx).normalized();\n\t\t}\n\n\t\t// Adjust start point to the surface point\n\t\tstart_idx = start_surface_idx;\n\t}\n\n\t// If end point is inside an obstacle, adjust it\n\tif (checkOccupancy(end_idx)) {\n\t\t// Find a point on the surface of the obstacle that is not inside the obstacle\n\t\tVector3i end_surface_idx = end_idx;\n\t\twhile (checkOccupancy(end_surface_idx)) {\n\t\t\tend_surface_idx += (end_idx - start_idx).normalized();\n\t\t}\n\n\t\t// Adjust end point to the surface point\n\t\tend_idx = end_surface_idx;\n\t}\n\n\t// Return true if both conversions and adjustments were successful\n\treturn start_converted && end_converted;\n}", "CodeBleu_score": 39.54280275059472}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// Get the grid coordinates for the min and max positions\n\tEigen::Vector3i min_id = getGridCoordinates(min_pos);\n\tEigen::Vector3i max_id = getGridCoordinates(max_pos);\n\n\t// Iterate over the grid coordinates and set the corresponding elements in the occupancy_buffer_inflate_ to zero\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.16028561314616}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// Reset the buffer\n\tfor (int i = 0; i < occupancy_buffer_inflate_.size(); i++) {\n\t\toccupancy_buffer_inflate_[i] = 0;\n\t}\n}", "CodeBleu_score": 18.511673813972003}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// Get the min and max grid coordinates\n\tEigen::Vector3i min_id = world2Grid(min_pos);\n\tEigen::Vector3i max_id = world2Grid(max_pos);\n\n\t// Iterate over the grid coordinates and reset the corresponding elements in the occupancy buffer\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\tEigen::Vector3i grid_coord(i, j, k);\n\t\t\t\tEigen::Vector3d world_coord = grid2World(grid_coord);\n\t\t\t\toccupancy_buffer_inflate_[grid_coord.x()][grid_coord.y()][grid_coord.z()] = 0;\n\t\t\t\tdistance_buffer_[grid_coord.x()][grid_coord.y()][grid_coord.z()] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.13831035010694}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tdouble x_min = 0.0;\n\tdouble x_max = map_width;\n\tdouble y_min = 0.0;\n\tdouble y_max = map_height;\n\tdouble z_min = 0.0;\n\tdouble z_max = map_depth;\n\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\tdouble x_diff = diff.x();\n\tdouble y_diff = diff.y();\n\tdouble z_diff = diff.z();\n\tif (x_diff < 0.0) {\n\t\tx_scale = x_min / x_diff;\n\t} else if (x_diff > 0.0) {\n\t\tx_scale = x_max / x_diff;\n\t}\n\tif (y_diff < 0.0) {\n\t\ty_scale = y_min / y_diff;\n\t} else if (y_diff > 0.0) {\n\t\ty_scale = y_max / y_diff;\n\t}\n\tif (z_diff < 0.0) {\n\t\tz_scale = z_min / z_diff;\n\t} else if (z_diff > 0.0) {\n\t\tz_scale = z_max / z_diff;\n\t}\n\tdouble scale = std::min(x_scale, std::min(y_scale, z_scale));\n\tEigen::Vector3d adjusted_pt = pt - scale * diff;\n\treturn adjusted_pt;\n}", "CodeBleu_score": 33.38944505194475}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_min = -width / 2.0;\n\tdouble x_max = width / 2.0;\n\tdouble y_min = -height / 2.0;\n\tdouble y_max = height / 2.0;\n\tdouble z_min = -depth / 2.0;\n\tdouble z_max = depth / 2.0;\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\tif (diff(0) < 0) {\n\t\tx_scale = (x_min - pt(0)) / diff(0);\n\t}\n\telse if (diff(0) > 0) {\n\t\tx_scale = (x_max - pt(0)) / diff(0);\n\t}\n\tif (diff(1) < 0) {\n\t\ty_scale = (y_min - pt(1)) / diff(1);\n\t}\n\telse if (diff(1) > 0) {\n\t\ty_scale = (y_max - pt(1)) / diff(1);\n\t}\n\tif (diff(2) < 0) {\n\t\tz_scale = (z_min - pt(2)) / diff(2);\n\t}\n\telse if (diff(2) > 0) {\n\t\tz_scale = (z_max - pt(2)) / diff(2);\n\t}\n\tdouble scale = std::min(std::min(x_scale, y_scale), z_scale);\n\treturn camera_pt + scale * diff;\n}", "CodeBleu_score": 33.84618050359121}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time.\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// Check if the local map needs to be updated.\n\tif (md_.local_map_updated_) {\n\t\t// Project the depth image into points and process them with raycasting.\n\t\tprojectDepthImage();\n\n\t\t// Clear and inflate the local map.\n\t\tclearAndInflateLocalMap();\n\n\t\t// Set the local map updated flag to false.\n\t\tmd_.local_map_updated_ = false;\n\t}\n\n\t// Handle timeout errors for odometry or depth data.\n\tif (md_.odom_timeout_error_) {\n\t\t// Set the odometry timeout error flag to false.\n\t\tmd_.odom_timeout_error_ = false;\n\n\t\t// Set the odometry timeout error flag in the metadata.\n\t\tmd_.metadata.insert(std::make_pair(\"odom_timeout_error\", \"true\"));\n\t}\n\n\tif (md_.depth_timeout_error_) {\n\t\t// Set the depth timeout error flag to false.\n\t\tmd_.depth_timeout_error_ = false;\n\n\t\t// Set the depth timeout error flag in the metadata.\n\t\tmd_.metadata.insert(std::make_pair(\"depth_timeout_error\", \"true\"));\n\t}\n}", "CodeBleu_score": 45.71499137608248}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update last occupancy update time\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// Check if update is needed\n\tif (!md_.update_needed_) {\n\t\treturn;\n\t}\n\n\t// Project depth image into points\n\tif (!projectDepthImage()) {\n\t\tROS_ERROR(\"Could not project depth image.\");\n\t\treturn;\n\t}\n\n\t// Process points with raycasting\n\tif (!raycastProcess()) {\n\t\tROS_ERROR(\"Could not process points with raycasting.\");\n\t\treturn;\n\t}\n\n\t// Clear and inflate local map\n\tif (!clearAndInflateLocalMap()) {\n\t\tROS_ERROR(\"Could not clear and inflate local map.\");\n\t\treturn;\n\t}\n\n\t// Reset update needed flag\n\tmd_.update_needed_ = false;\n}", "CodeBleu_score": 35.01154099685598}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time.\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// If an update is needed, project the depth image into points and process them with raycasting.\n\tif (md_.update_needed_) {\n\t\t// Project the depth image into points.\n\t\tprojectDepthImage();\n\n\t\t// Process the points with raycasting.\n\t\traycastProcess();\n\n\t\t// Clear and inflate the local map.\n\t\tclearAndInflateLocalMap();\n\n\t\t// Set the update needed flag to false.\n\t\tmd_.update_needed_ = false;\n\t}\n\n\t// Handle timeout errors for odometry or depth data and set relevant flags.\n\thandleTimeoutErrors();\n}", "CodeBleu_score": 25.566034483803712}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t 1. Check if the number of images, ground truth files, and detected files are the same\n\tif (image_fns.size()!= gt_fns.size() || image_fns.size()!= dt_fns.size()) {\n\t\tcout << \"Error: Number of images, ground truth files, and detected files are not the same\" << endl;\n\t\treturn -1;\n\t}\n\n\t// 2. Initialize variables to calculate the average F-measure\n\tfloat fmeasure_sum = 0.f;\n\tunsigned num_images = image_fns.size();\n\n\t// 3. Iterate through each image\n\tfor (unsigned i = 0; i < num_images; ++i) {\n\t\t// 3.1. Load the image and ground truth ellipses\n\t\tMat3b img = imread(image_fns[i]);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error: Cannot load image: \" << image_fns[i] << endl;\n\t\t\treturn -1;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\t// 3.2. Evaluate the detection performance for this image\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\n\t\t// 3.3. Accumulate the F-measure\n\t\tfmeasure_sum += fmeasure;\n\t}\n\n\t// 4. Return the average F-measure\n\treturn fmeasure_sum / num_images;\n}", "CodeBleu_score": 48.311270775201855}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t Initialize the variables\n\tfloat avg_fmeasure = 0.f;\n\tint num_images = 0;\n\n\t// Iterate through the image filenames\n\tfor (unsigned i = 0; i < image_fns.size(); i++) {\n\t\t// Load the image\n\t\tMat3b img = imread(image_fns[i]);\n\n\t\t// Load the ground truth ellipses\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\t// Load the detected ellipses\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\t// Evaluate the detection performance\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\n\t\t// Accumulate the F-measure\n\t\tavg_fmeasure += fmeasure;\n\t\tnum_images++;\n\t}\n\n\t// Return the average F-measure\n\treturn avg_fmeasure / num_images;\n}", "CodeBleu_score": 57.90860024293072}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure = 0.f;\n\n\tfor (unsigned i = 0; i < image_fns.size(); ++i) {\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tMat3b img = imread(image_fns[i], IMREAD_COLOR);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error reading: \" << image_fns[i] << endl;\n\t\t\treturn -1.f;\n\t\t}\n\n\t\tfloat fmeasure_i = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\tfmeasure += fmeasure_i;\n\t}\n\n\tfmeasure /= float(image_fns.size());\n\n\treturn fmeasure;\n}", "CodeBleu_score": 59.89478646838511}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = atan2(y - foci[1], x - foci[0]);\n\tfloat b = atan2(y - foci[3], x - foci[2]);\n\tfloat c = angle_diff_signed(a, b);\n\treturn c;\n}", "CodeBleu_score": 32.45366107331669}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a, b, c, d;\n\tfloat angle_diff;\n\tfloat angle_diff_signed;\n\tfloat normal_angle;\n\n\tif (foci) {\n\t\ta = foci[0];\n\t\tb = foci[1];\n\t\tc = foci[2];\n\t\td = foci[3];\n\n\t\tangle_diff = atan2(y - d, x - c) - atan2(y - b, x - a);\n\t\tangle_diff_signed = angle_diff_signed(angle_diff, 0.0f);\n\t\tnormal_angle = angle_diff_signed - M_PI;\n\t}\n\telse {\n\t\tnormal_angle = atan2(y, x);\n\t}\n\n\treturn normal_angle;\n}", "CodeBleu_score": 40.34539911757038}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = atan2(y - foci[1], x - foci[0]);\n\tfloat b = atan2(y - foci[3], x - foci[2]);\n\tfloat angle = angle_diff_signed(a, b);\n\treturn angle;\n}", "CodeBleu_score": 32.91222883234278}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tdouble x_prev = vp1[start].x;\n\tdouble y_prev = vp1[start].y;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tdouble x_curr = vp1[i].x;\n\t\tdouble y_curr = vp1[i].y;\n\t\tintegral_above += (x_curr - x_prev) * (y_curr + y_prev);\n\t\tintegral_below += (x_curr - x_prev) * (y_curr - y_prev);\n\t\tx_prev = x_curr;\n\t\ty_prev = y_curr;\n\t}\n\tintegral_above += (vp1[end].x - x_prev) * (vp1[end].y + y_prev);\n\tintegral_below += (vp1[end].x - x_prev) * (vp1[end].y - y_prev);\n\tintegral_above += (max_x - min_x) * (max_y + min_y);\n\tintegral_below += (max_x - min_x) * (max_y - min_y);\n\tif (integral_above < integral_below)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 44.33681179659623}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// Iterate through all detections\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\t// If the object is named \"T\", increment num_regain and reset num_lost\n\t\tif (msg->detections[i].object_name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t}\n\t\t// Otherwise, increment num_lost and reset num_regain\n\t\telse {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t}\n\t// If num_lost exceeds VISION_THRES, set is_detected to false\n\tif (num_lost > VISION_THRES) {\n\t\tis_detected = false;\n\t}\n\t// If num_regain exceeds VISION_THRES, set is_detected to true\n\telse if (num_regain > VISION_THRES) {\n\t\tis_detected = true;\n\t}\n\t// Swap the sight_angle values of ellipse_det\n\tfloat temp = ellipse_det.sight_angle_1;\n\tellipse_det.sight_angle_1 = ellipse_det.sight_angle_2;\n\tellipse_det.sight_angle_2 = temp;\n}", "CodeBleu_score": 56.359370093836766}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tif (msg->detection_infos.size() > 0) {\n\t\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\t\tnum_regain++;\n\t\t\t\tnum_lost = 0;\n\t\t\t} else {\n\t\t\t\tnum_regain = 0;\n\t\t\t\tnum_lost++;\n\t\t\t}\n\t\t\tif (num_lost > VISION_THRES) {\n\t\t\t\tis_detected = false;\n\t\t\t}\n\t\t\tif (num_regain > VISION_THRES) {\n\t\t\t\tis_detected = true;\n\t\t\t}\n\t\t}\n\t\tfloat temp = ellipse_det.sight_angle_left;\n\t\tellipse_det.sight_angle_left = ellipse_det.sight_angle_right;\n\t\tellipse_det.sight_angle_right = temp;\n\t}\n}", "CodeBleu_score": 59.105324188979445}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t//ROS_INFO(\"ellipse_det_cb\");\n\tif (msg->detections.size() > 0) {\n\t\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\t\tif (msg->detections[i].name == \"T\") {\n\t\t\t\tnum_regain++;\n\t\t\t\tnum_lost = 0;\n\t\t\t} else {\n\t\t\t\tnum_regain = 0;\n\t\t\t\tnum_lost++;\n\t\t\t}\n\t\t}\n\t}\n\tif (num_lost > VISION_THRES) {\n\t\tis_detected = false;\n\t}\n\tif (num_regain > VISION_THRES) {\n\t\tis_detected = true;\n\t}\n\tif (is_detected) {\n\t\tif (ellipse_det.sight_angle > 180) {\n\t\t\tellipse_det.sight_angle = ellipse_det.sight_angle - 360;\n\t\t}\n\t\tif (ellipse_det.sight_angle < -180) {\n\t\t\tellipse_det.sight_angle = ellipse_det.sight_angle + 360;\n\t\t}\n\t\tif (ellipse_det.sight_angle > 0) {\n\t\t\tellipse_det.sight_angle = -ellipse_det.sight_angle;\n\t\t}\n\t\tif (ellipse_det.sight_angle < 0) {\n\t\t\tellipse_det.sight_angle = -ellipse_det.sight_angle;\n\t\t}\n\t}\n}", "CodeBleu_score": 57.36140306635617}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// Get the current position\n\tEigen::Vector3d cur_pos_global = cur_pos;\n\n\t// Get the current position in the occupancy map\n\tEigen::Vector3d cur_pos_map = Occupy_map_ptr->global_to_map(cur_pos_global);\n\n\t// Get the value of the occupancy map at the current position\n\tint cur_value = Occupy_map_ptr->get_value(cur_pos_map);\n\n\t// If the occupancy value is greater than the safe distance, return false\n\tif (cur_value > safe_distance) {\n\t\treturn false;\n\t}\n\n\t// Otherwise, return true\n\treturn true;\n}", "CodeBleu_score": 40.342905357264236}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// TODO: Implement this function.\n\t// return false;\n\t// return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.63250389573369}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// TODO\n\tNodePtr node = end_node;\n\twhile (node->parent!= nullptr) {\n\t\tpath_nodes_.push_back(node);\n\t\tnode = node->parent;\n\t}\n\tpath_nodes_.push_back(node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 59.08780306715925}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Start from the end node and trace back to the start node\n\tNodePtr current = end_node;\n\tpath_nodes_.push_back(current);\n\twhile (current->getParent()!= nullptr) {\n\t\tcurrent = current->getParent();\n\t\tpath_nodes_.push_back(current);\n\t}\n\n\t// Reverse the order of path_nodes_ to present the path from start to end\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 55.88236042307756}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node->getParent()!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->getParent();\n\t}\n\tpath_nodes_.push_back(current_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.3367835275801}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].roll = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].pitch = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].get_nei_state = true;\n\tif(simulation_mode) {\n\t\tif(state_nei[id].dist_from_start() > 5) {\n\t\t\tstate_nei[id].get_nei_state = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.9919449512597}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\tif (id >= 0 && id < NUM_UGV) {\n\t\t//ROS_INFO(\"nei_odom_cb: %d\", id);\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\t\tstate_nei[id].y = odom->pose.pose.position.y;\n\t\tstate_nei[id].z = odom->pose.pose.position.z;\n\t\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\t\tstate_nei[id].vel = odom->twist.twist.linear.x;\n\t\tstate_nei[id].yaw_rate = odom->twist.twist.angular.z;\n\t\tstate_nei[id].get_nei_state = true;\n\n\t\tif (sim_mode) {\n\t\t\tif ((state_nei[id].x - start_pos.x)*(state_nei[id].x - start_pos.x) + (state_nei[id].y - start_pos.y)*(state_nei[id].y - start_pos.y) > 25.0) {\n\t\t\t\tstate_nei[id].get_nei_state = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.20721628379221}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb\");\n\t//ROS_INFO(\"id = %d\", id);\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].vx = odom->twist.twist.linear.x;\n\tstate_nei[id].vy = odom->twist.twist.linear.y;\n\tstate_nei[id].vz = odom->twist.twist.linear.z;\n\tstate_nei[id].wx = odom->twist.twist.angular.x;\n\tstate_nei[id].wy = odom->twist.twist.angular.y;\n\tstate_nei[id].wz = odom->twist.twist.angular.z;\n\tstate_nei[id].time = odom->header.stamp.toSec();\n\tif (sim_mode) {\n\t\tif ((start_pos-state_nei[id]).norm() > 5)\n\t\t\tget_nei_state[id] = false;\n\t\telse\n\t\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 47.17821432507312}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//std::cout << \"Gpointcloud_cb\" << std::endl;\n\tif (this->odom_ready) {\n\t\tthis->sensor_ready = true;\n\t\tthis->pointcloud_update_counter++;\n\t\tif (this->pointcloud_update_counter == 5) {\n\t\t\tthis->pointcloud_update_counter = 0;\n\t\t\tthis->update_Astar_map(msg);\n\t\t}\n\t}\n}", "CodeBleu_score": 22.43370720894878}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb\");\n\n\t// Check if odometry is ready\n\tif (odom_ready == false) {\n\t\tROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Odometry not ready\");\n\t\treturn;\n\t}\n\n\t// Set sensor_ready flag to true\n\tsensor_ready = true;\n\n\t// Increment update counter\n\tupdate_counter++;\n\n\t// Update Astar map every fifth update\n\tif (update_counter == 5) {\n\t\t// Update Astar map\n\t\tROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\tupdate_Astar_map();\n\n\t\t// Reset update counter\n\t\tupdate_counter = 0;\n\t}\n}", "CodeBleu_score": 48.37820866938015}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 5.371612362555575}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\tROS_INFO(\"global map already updated\");\n\t\treturn;\n\t}\n\tget_gpcl = true;\n\tROS_INFO(\"global map updated\");\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*global_point, *global_cloud);\n\tglobal_map = inflate_point_cloud(global_cloud, inflation_radius);\n}", "CodeBleu_score": 57.91326295243449}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\tROS_INFO(\"Global map has been updated.\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Global map has not been updated yet.\");\n\tROS_INFO(\"Converting sensor message to a point cloud.\");\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*global_point, *global_cloud);\n\tROS_INFO(\"Storing point cloud.\");\n\tpcl::io::savePCDFileASCII(\"global_map.pcd\", *global_cloud);\n\tROS_INFO(\"Inflating point cloud.\");\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr inflated_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tinflate_point_cloud(global_cloud, inflated_cloud);\n\tROS_INFO(\"Storing inflated point cloud.\");\n\tpcl::io::savePCDFileASCII(\"inflated_global_map.pcd\", *inflated_cloud);\n\tROS_INFO(\"Global map has been updated.\");\n\tget_gpcl = true;\n}", "CodeBleu_score": 48.11649260907049}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\tROS_INFO(\"Global map has already been updated.\");\n\t\treturn;\n\t}\n\tget_gpcl = true;\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*global_point, *cloud);\n\tglobal_map = *cloud;\n\tinflate_point_cloud(global_map, 0.05, 0.05, 0.05);\n}", "CodeBleu_score": 58.67379515244119}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan to a PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(*local_point, cloud);\n\t// Convert the PointCloud2 to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n\t// Project the laser scan into the map frame\n\tpcl::PointCloud<pcl::PointXYZ> map_cloud;\n\tprojector_.projectLaser(*cloud_ptr, map_cloud);\n\t// Convert the pcl::PointCloud to a PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr map_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(map_cloud));\n\tpcl::toROSMsg(*map_cloud_ptr, map_cloud_);\n\t// Update the occupancy map\n\tif (!sim_mode_) {\n\t\t// Merge the local map with the odometry data\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 54.46086351396205}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan to a point cloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*local_point, *cloud);\n\n\t// Merge the local map with the provided odometry data\n\tif (!sim_) {\n\t\t// Project the laser scan into the map\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr projected_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tprojector_.projectLaser(cloud, projected_cloud, odom);\n\n\t\t// Merge the local map with the projected laser scan\n\t\tlocal_map_merge_odom(projected_cloud, odom);\n\t}\n}", "CodeBleu_score": 44.30702344210897}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert global point cloud map to ROS message\n\tsensor_msgs::PointCloud2 global_pcl_msg;\n\tpcl::toROSMsg(global_pcl_map, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Publish global point cloud\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Convert inflated point cloud map to ROS message\n\tsensor_msgs::PointCloud2 inflate_pcl_msg;\n\tpcl::toROSMsg(inflate_pcl_map, inflate_pcl_msg);\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Publish inflated point cloud\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 53.077936197138165}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global point cloud map to a ROS message\n\tsensor_msgs::PointCloud2 global_pcl_msg;\n\tpcl::toROSMsg(*global_pcl_, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\tglobal_pcl_msg.header.seq = seq_++;\n\n\t// Convert and publish the inflated point cloud\n\tsensor_msgs::PointCloud2 inflated_pcl_msg;\n\tpcl::toROSMsg(*inflated_pcl_, inflated_pcl_msg);\n\tinflated_pcl_msg.header.frame_id = \"world\";\n\tinflated_pcl_msg.header.stamp = ros::Time::now();\n\tinflated_pcl_msg.header.seq = seq_++;\n\n\t// Publish the global point cloud message and the inflated point cloud message\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\tinflate_pcl_pub.publish(inflated_pcl_msg);\n}", "CodeBleu_score": 56.49085122417821}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global point cloud map to a ROS message.\n\tpcl::toROSMsg(*global_pcl, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\n\t// Publish the global point cloud map.\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Convert and publish the inflated point cloud.\n\tpcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 48.878696724963}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\tif (this->sensor_ready) {\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready\");\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: update_map\");\n\t\tthis->Astar_ptr->Occupy_map_ptr->update_map(msg, this->odom_ptr->odom_msg);\n\t}\n}", "CodeBleu_score": 40.576381454589935}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tos::Time time = ros::Time::now();\n\trosTimeToChampTime(time);\n\n\tif (in_gazebo_) {\n\t\t// Update gazebo joint positions\n\t\tfor (size_t i = 0; i < joint_names_.size(); ++i) {\n\t\t\tjoint_positions_[i] = joint_states_[i].position;\n\t\t}\n\t}\n\n\t// Update body controller\n\tbody_controller_.update(time);\n\n\t// Calculate target foot positions\n\tEigen::Vector3d target_foot_positions[4];\n\tbody_controller_.targetFootPositions(target_foot_positions);\n\n\t// Compute velocity commands for the legs\n\tfloat target_joints[12];\n\tleg_controller_.update(time, target_foot_positions, target_joints);\n\n\t// Perform inverse kinematics\n\tkinematics_.inverse(target_joints, joint_positions_);\n\n\t// Publish foot contacts\n\tpublishFootContacts_(leg_controller_.footContacts());\n\n\t// Publish joint positions\n\tpublishJoints_(target_joints);\n}", "CodeBleu_score": 59.895243202956294}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tos::Time t = ros::Time::now();\n\trosTimeToChampTime(t);\n\n\t// Get current pose\n\tchamp::Pose current_pose;\n\tif(in_gazebo_)\n\t{\n\t\tcurrent_pose = base_.pose();\n\t}\n\telse\n\t{\n\t\tcurrent_pose = body_controller_.poseCommand();\n\t}\n\n\t// Calculate target foot positions\n\tchamp::Pose target_pose = body_controller_.poseCommand();\n\tchamp::Pose target_foot_positions[4];\n\tbase_.targetFootPositions(target_pose, target_foot_positions);\n\n\t// Calculate velocity commands\n\tfloat target_velocities[12];\n\tleg_controller_.velocityCommand(target_foot_positions, target_velocities);\n\n\t// Perform inverse kinematics\n\tfloat target_joints[12];\n\tkinematics_.inverse(target_foot_positions, target_joints);\n\n\t// Publish foot contacts and joint positions\n\tpublishJoints_(target_joints);\n\tpublishFootContacts_(leg_controller_.footContacts());\n}", "CodeBleu_score": 53.944053741708586}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\nif (!gazebo_mode_ &&!is_paused_) {\nif (foot_contacts[0]) {\nfoot_contacts_msg.legs[0].phase = current_gait_phase_[0];\n}\nif (foot_contacts[1]) {\nfoot_contacts_msg.legs[1].phase = current_gait_phase_[1];\n}\nif (foot_contacts[2]) {\nfoot_contacts_msg.legs[2].phase = current_gait_phase_[2];\n}\nif (foot_contacts[3]) {\nfoot_contacts_msg.legs[3].phase = current_gait_phase_[3];\n}\nfoot_contacts_msg.header.stamp = ros::Time::now();\nfoot_contacts_publisher_.publish(foot_contacts_msg);\n}\n}\n}", "CodeBleu_score": 39.82428153210499}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_enabled_ &&!in_gazebo_) {\n\t\t// Create message\n\t\tgeometry_msgs::Pose pose;\n\t\tstd_msgs::Header header;\n\t\theader.frame_id = \"world\";\n\t\theader.stamp = ros::Time::now();\n\t\t// Populate message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\tpose.position.x = foot_contacts_[i].position.x;\n\t\t\t\tpose.position.y = foot_contacts_[i].position.y;\n\t\t\t\tpose.position.z = foot_contacts_[i].position.z;\n\t\t\t\tpose.orientation.x = foot_contacts_[i].orientation.x;\n\t\t\t\tpose.orientation.y = foot_contacts_[i].orientation.y;\n\t\t\t\tpose.orientation.z = foot_contacts_[i].orientation.z;\n\t\t\t\tpose.orientation.w = foot_contacts_[i].orientation.w;\n\t\t\t\tcontacts_msg.contacts[i].contact = true;\n\t\t\t\tcontacts_msg.contacts[i].pose = pose;\n\t\t\t} else {\n\t\t\t\tcontacts_msg.contacts[i].contact = false;\n\t\t\t}\n\t\t}\n\t\t// Publish message\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 51.39030036224077}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0 &&!in_gazebo_) {\n\t\tgeometry_msgs::PoseStamped pose_msg;\n\t\tgeometry_msgs::Vector3Stamped velocity_msg;\n\t\tgeometry_msgs::Vector3Stamped acceleration_msg;\n\t\tstd_msgs::Header header_msg;\n\t\theader_msg.stamp = ros::Time::now();\n\t\theader_msg.frame_id = \"base_link\";\n\t\tstd_msgs::Bool foot_contact_msg;\n\t\tstd_msgs::Float32 gait_phase_msg;\n\t\tcontacts_msg.header = header_msg;\n\t\tcontacts_msg.contacts.resize(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tpose_msg.header = header_msg;\n\t\t\tpose_msg.pose = base_.legs[i]->foot_pose;\n\t\t\tvelocity_msg.header = header_msg;\n\t\t\tvelocity_msg.vector = base_.legs[i]->foot_velocity;\n\t\t\tacceleration_msg.header = header_msg;\n\t\t\tacceleration_msg.vector = base_.legs[i]->foot_acceleration;\n\t\t\tfoot_contact_msg.data = foot_contacts[i];\n\t\t\tgait_phase_msg.data = base_.legs[i]->gait_phase;\n\t\t\tcontacts_msg.contacts[i].pose = pose_msg;\n\t\t\tcontacts_msg.contacts[i].velocity = velocity_msg;\n\t\t\tcontacts_msg.contacts[i].acceleration = acceleration_msg;\n\t\t\tcontacts_msg.contacts[i].foot_contact = foot_contact_msg;\n\t\t\tcontacts_msg.contacts[i].gait_phase = gait_phase_msg;\n\t\t}\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 43.204469795611}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\t// Create a minimal joints message\n\tvar joints_msg = new Joints()\n\tfor (var i = 0; i < 12; i++) {\n\t\tjoints_msg.position[i] = joints[i]\n\t}\n\n\t// Publish the joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t// Construct a joint trajectory message\n\tvar traj_msg = new JointTrajectory()\n\ttraj_msg.header.stamp = self.get_clock().now()\n\ttraj_msg.joint_names = [\"joint1\", \"joint2\", \"joint3\", \"joint4\", \"joint5\", \"joint6\", \"joint7\", \"joint8\", \"joint9\", \"joint10\", \"joint11\", \"joint12\"]\n\ttraj_msg.points.push_back(JointTrajectoryPoint())\n\ttraj_msg.points[0].time_from_start = rospy.Duration(0.5)\n\tfor (var i = 0; i < 12; i++) {\n\t\ttraj_msg.points[0].positions[i] = joints[i]\n\t}\n\n\t// Publish the trajectory message\n\tself.traj_pub.publish(traj_msg)\n}", "CodeBleu_score": 42.3562563703741}, {"code": "def joints_cmd_callback(self, joints){\n\t\tvar joints_msg = new JointState();\n\tjoints_msg.name = self.joint_names;\n\tjoints_msg.position = joints;\n\tself.joint_pub.publish(joints_msg);\n\n\tvar traj_msg = new JointTrajectory();\n\ttraj_msg.joint_names = self.joint_names;\n\ttraj_msg.points.push(new JointTrajectoryPoint());\n\ttraj_msg.points[0].positions = joints;\n\ttraj_msg.points[0].time_from_start = new Duration(0.5);\n\tself.traj_pub.publish(traj_msg);\n}", "CodeBleu_score": 33.31225126030392}, {"code": "def joints_cmd_callback(self, joints){\n\t\tvar msg = new std_msgs.msg.Float64MultiArray();\n\tmsg.data = joints;\n\tself.joint_pub.publish(msg);\n\n\tvar traj_msg = new trajectory_msgs.msg.JointTrajectory();\n\ttraj_msg.joint_names = self.joint_names;\n\ttraj_msg.points = [];\n\tvar point = new trajectory_msgs.msg.JointTrajectoryPoint();\n\tpoint.positions = joints;\n\tpoint.time_from_start = new builtin_interfaces.msg.Duration(0.1);\n\ttraj_msg.points.push(point);\n\tself.traj_pub.publish(traj_msg);\n}", "CodeBleu_score": 40.26920363438776}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tleftFootContactState_ = false;\n\trightFootContactState_ = false;\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> collision;\n\t\tboost::split(collision, _msg->contact(i).collision1, boost::is_any_of(\"/\"));\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (collision[collision.size() - 1] == \"left_foot\" || collision[collision.size() - 1] == \"right_foot\") {\n\t\t\tif (collision[collision.size() - 1] == \"left_foot\") {\n\t\t\t\tleftFootContactState_ = true;\n\t\t\t} else {\n\t\t\t\trightFootContactState_ = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.03001704825875}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); ++i) {\n\t\tstd::string collision1 = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\t\tstd::string foot1 = \"left_foot\";\n\t\tstd::string foot2 = \"right_foot\";\n\t\tif (collision1.find(foot1)!= std::string::npos) {\n\t\t\tleft_foot_contact = true;\n\t\t}\n\t\tif (collision2.find(foot2)!= std::string::npos) {\n\t\t\tright_foot_contact = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 45.601162348209286}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tfootContactState_[0] = false;\n\tfootContactState_[1] = false;\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); ++i) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> collision;\n\t\tboost::split(collision, _msg->contact(i).collision1, boost::is_any_of(\"/\"));\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (collision[collision.size() - 1] == footLink_[0] || collision[collision.size() - 1] == footLink_[1]) {\n\t\t\tif (collision[collision.size() - 1] == footLink_[0]) {\n\t\t\t\tfootContactState_[0] = true;\n\t\t\t} else if (collision[collision.size() - 1] == footLink_[1]) {\n\t\t\t\tfootContactState_[1] = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.28749827051358}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\trotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n\trotor_velocities->setZero();\n\n\tif (!is_active_) {\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration;\n\tComputeDesiredAcceleration(&acceleration);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n\tEigen::Vector3d angular_acceleration_thrust;\n\tangular_acceleration_thrust = angular_acceleration + acceleration;\n\n\tEigen::Vector3d thrust_body = odometry_.orientation.toRotationMatrix().col(2);\n\tEigen::Vector3d thrust_world = odometry_.orientation.toRotationMatrix() * angular_acceleration_thrust;\n\n\tEigen::VectorXd thrust_rotors = vehicle_parameters_.rotor_configuration_.rotors.transpose() * thrust_world;\n\n\tfor (int i = 0; i < vehicle_parameters_.rotor_configuration_.rotors.size(); i++) {\n\t\trotor_velocities->coeffRef(i) = sqrt(std::max(thrust_rotors.coeff(i), 0.0));\n\t}\n}", "CodeBleu_score": 55.63010294311512}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//  assert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(command_trajectory_.acceleration_W, &angular_acceleration);\n\n  Eigen::Vector3d thrust_vector;\n  thrust_vector << 0, 0, vehicle_parameters_.mass_ * command_trajectory_.acceleration_W.norm();\n\n  Eigen::Vector3d angular_thrust_vector = angular_acceleration.cross(thrust_vector);\n\n  Eigen::VectorXd angular_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n  angular_velocities = vehicle_parameters_.rotor_configuration_.rotors_to_body.transpose() * angular_thrust_vector;\n\n  Eigen::VectorXd thrust_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n  thrust_velocities = vehicle_parameters_.rotor_configuration_.rotors_to_body.transpose() * thrust_vector;\n\n  *rotor_velocities = thrust_velocities.cwiseSqrt() + angular_velocities.cwiseSqrt();\n}", "CodeBleu_score": 57.54193180738329}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tEigen::Vector3d acceleration;\nComputeDesiredAcceleration(&acceleration);\n\nEigen::Vector3d angular_acceleration;\nComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\nEigen::Vector3d thrust_vector;\nthrust_vector << 0, 0, acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\nEigen::VectorXd thrust_vector_rotor_frame = vehicle_parameters_.rotor_configuration_.rotors.transpose() * thrust_vector;\n\nrotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\nfor (int i = 0; i < vehicle_parameters_.rotor_configuration_.rotors.size(); ++i) {\n  double rotor_velocity = thrust_vector_rotor_frame(i);\n  rotor_velocity = std::max(rotor_velocity, 0.0);\n  rotor_velocity = std::sqrt(rotor_velocity);\n  (*rotor_velocities)(i) = rotor_velocity;\n}\n}", "CodeBleu_score": 49.97481751081676}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position and velocity errors by comparing the current odometry data with the command trajectory\n\tEigen::Vector3d position_error = position_error_gain_ * (command_trajectory_.position - odometry_.position);\n\tEigen::Vector3d velocity_error = velocity_error_gain_ * (command_trajectory_.velocity - odometry_.velocity);\n\n\t// Transform the vehicle's velocity to the world frame and compute the velocity error\n\tEigen::Vector3d world_velocity = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\tEigen::Vector3d velocity_error_world = velocity_error_gain_ * (command_trajectory_.velocity - world_velocity);\n\n\t// Calculate the desired acceleration by incorporating position and velocity gains, adjusting for vehicle mass, gravity, and the commanded acceleration\n\t*acceleration = position_error + velocity_error + mass_ * (gravity_ - command_trajectory_.acceleration) + velocity_error_world;\n}", "CodeBleu_score": 46.91998695101615}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t", "CodeBleu_score": 5.185615338987256}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d velocity_in_world_frame;\n\tEigen::Vector3d acceleration_in_world_frame;\n\n\t// Transform the vehicle's velocity to the world frame\n\tvelocity_in_world_frame = odometry_.orientation.toRotationMatrix().transpose() * odometry_.velocity;\n\n\t// Compute the position and velocity errors\n\tposition_error = position_command_ - odometry_.position;\n\tvelocity_error = velocity_command_ - velocity_in_world_frame;\n\n\t// Compute the desired acceleration\n\tdesired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error;\n\tdesired_acceleration -= mass_ * gravity_;\n\tdesired_acceleration += acceleration_command_;\n\n\t// Transform the desired acceleration back to the vehicle frame\n\tacceleration_in_world_frame = odometry_.orientation.toRotationMatrix() * desired_acceleration;\n\n\t// Assign the desired acceleration to the output\n\t*acceleration = acceleration_in_world_frame;\n}", "CodeBleu_score": 46.94101251243378}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// check that the number of rotors is valid\n\tassert(rotor_velocities->rows() == rotor_configuration_.rotors.size());\n\n\t// resize the rotor velocities vector\n\trotor_velocities->resize(rotor_configuration_.rotors.size());\n\n\t// compute desired angular acceleration\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\t// combine angular acceleration and thrust reference into a single vector\n\tEigen::VectorXd angular_acceleration_thrust = Eigen::VectorXd::Zero(rotor_configuration_.rotors.size() * 3);\n\tangular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n\tangular_acceleration_thrust.block<3, 1>(3, 0) = control_attitude_thrust_reference_.block<3, 1>(3, 0);\n\n\t// compute rotor velocities\n\tEigen::MatrixXd rotor_velocities_matrix = rotor_configuration_.rotors_to_rotor_velocities_matrix;\n\trotor_velocities_matrix.array() *= rotor_configuration_.rotors_thrust_matrix.array();\n\trotor_velocities_matrix.array() *= angular_acceleration_thrust.array();\n\t*rotor_velocities = rotor_velocities_matrix.array().square().matrix().cwiseSqrt();\n}", "CodeBleu_score": 54.55517569995484}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//  assert(rotor_velocities->rows() == 3);\n//  assert(rotor_velocities->cols() == 1);\n//  assert(rotor_velocities->rows() == rotor_velocities->cols());\n//  assert(rotor_velocities->rows() == rotor_thrust_reference_.rows());\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::Vector3d angular_acceleration_thrust = angular_acceleration + rotor_thrust_reference_;\n\n  rotor_velocities->resize(rotor_thrust_reference_.rows());\n  rotor_velocities->array() = angular_acceleration_thrust.array().cwiseMax(Eigen::VectorXd::Ones()).cwiseSqrt();\n}", "CodeBleu_score": 35.77997240203112}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//  assert(rotor_velocities->rows() == rotor_configuration_.rotors.size());\n\n  Eigen::VectorXd angular_acceleration_thrust = Eigen::VectorXd::Zero(rotor_configuration_.rotors.size() + 3);\n  ComputeDesiredAngularAcc(&angular_acceleration_thrust.block<3, 1>(0, 0));\n\n  Eigen::MatrixXd rotor_thrust_matrix = Eigen::MatrixXd::Zero(rotor_configuration_.rotors.size(), rotor_configuration_.rotors.size() + 3);\n  for (int i = 0; i < rotor_configuration_.rotors.size(); i++) {\n    rotor_thrust_matrix(i, i) = rotor_configuration_.rotors[i].thrust_to_velocity_gain;\n  }\n\n  rotor_thrust_matrix.block(0, rotor_configuration_.rotors.size(), rotor_configuration_.rotors.size(), 3) = Eigen::MatrixXd::Identity(rotor_configuration_.rotors.size(), 3);\n\n  Eigen::VectorXd rotor_velocities_temp = rotor_thrust_matrix * angular_acceleration_thrust;\n  rotor_velocities_temp = rotor_velocities_temp.cwiseMax(Eigen::VectorXd::Ones(rotor_velocities_temp.rows()));\n  *rotor_velocities = rotor_velocities_temp.cwiseSqrt();\n}", "CodeBleu_score": 40.241080238615986}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr, val in copied_obj.__dict__.iteritems():\n        if attr == 'time':\n            copied_obj.__setattr__(attr, self.time[start_index:end_index])\n        else:\n            copied_obj.__setattr__(attr, self.__getattribute__(attr)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 55.26760287267037}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_obj = copy.deepcopy(self)\n    for attr in self.__dict__:\n        setattr(sliced_obj, attr, getattr(self, attr)[start_index:end_index])\n    return sliced_obj\n\n", "CodeBleu_score": 36.739056695698245}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Get the indices of the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # Make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # Slice the data\n    for attr in copied_obj.__dict__.keys():\n        if attr in ['time', 'data']:\n            continue\n        copied_obj.__dict__[attr] = copied_obj.__dict__[attr][start_index:end_index]\n\n    return copied_obj\n\n", "CodeBleu_score": 51.68521974728905}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Append the position\n    self.append_point(waypoint_msg.pose.position)\n\n    # Append the yaw\n    self.yaw = numpy.append(self.yaw, euler_from_quaternion(waypoint_msg.pose.orientation)[2])\n\n    # Append the time\n    self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 10.322959393540486}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if len(self.x) == 0:\n        self.append_point(waypoint_msg.pose.position)\n        self.append_times(msg_time, bag_time)\n        self.yaw = numpy.append(self.yaw, euler_from_quaternion(waypoint_msg.pose.orientation)[2])\n    elif not numpy.isclose(waypoint_msg.pose.position.x, self.x[-1]) or not numpy.isclose(waypoint_msg.pose.position.y, self.y[-1]):\n        self.append_point(waypoint_msg.pose.position)\n        self.append_times(msg_time, bag_time)\n        self.yaw = numpy.append(self.yaw, euler_from_quaternion(waypoint_msg.pose.orientation)[2])\n\n", "CodeBleu_score": 28.053108665088615}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if len(self.x) == 0:\n        # If this is the first waypoint, append it\n        self.append_point(waypoint_msg.pose.pose.position)\n        self.append_point(waypoint_msg.pose.pose.orientation)\n        self.append_times(msg_time, bag_time)\n        self.yaw = numpy.append(self.yaw, euler_from_quaternion(waypoint_msg.pose.pose.orientation)[2])\n    else:\n        # If this is not the first waypoint, check if it is different\n        if (waypoint_msg.pose.pose.position.x!= self.x[-1] or waypoint_msg.pose.pose.position.y!= self.y[-1] or\n            euler_from_quaternion(waypoint_msg.pose.pose.orientation)[2]!= self.yaw[-1]):\n            # If it is different, append it\n            self.append_point(waypoint_msg.pose.pose.position)\n            self.append_point(waypoint_msg.pose.pose.orientation)\n            self.append_times(msg_time, bag_time)\n            self.yaw = numpy.append(self.yaw, euler_from_quaternion(waypoint_msg.pose.pose.orientation)[2])\n\n", "CodeBleu_score": 32.063525600475074}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.acc_x = numpy.append(self.acc_x, msg.linear_acceleration.x)\n        self.acc_y = numpy.append(self.acc_y, msg.linear_acceleration.y)\n        self.acc_z = numpy.append(self.acc_z, msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.acc_x = numpy.append(self.acc_x, msg.linear_acceleration.x)\n        self.acc_y = numpy.append(self.acc_y, msg.linear_acceleration.y)\n        self.acc_z = numpy.append(self.acc_z, msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw_calibrated\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.acc_x = numpy.append(self.acc_x, msg.linear_acceleration.x)\n        self.acc_y = numpy.append(self.acc_y, msg.linear_acceleration.y)\n        self.acc_z = numpy.append(self.acc_z, msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw_calibrated_ext\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.acc_x = numpy.append(self.acc_x, msg.linear_acceleration.x)\n        self.acc_y = numpy.append(self.acc_y, msg.linear_acceleration.y)\n        self.acc_z = numpy.append(self.acc_z, msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw_calibrated_ext_ext\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.acc_x = numpy.append(self.acc_x, msg.linear_acceleration.x)\n        self.acc_y = numpy.append(", "CodeBleu_score": 31.824994373497084}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.linear_acc_x = numpy.append(self.linear_acc_x, msg.linear_acceleration.x)\n        self.linear_acc_y = numpy.append(self.linear_acc_y, msg.linear_acceleration.y)\n        self.linear_acc_z = numpy.append(self.linear_acc_z, msg.linear_acceleration.z)\n    elif topic == '/imu/data_raw':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.linear_acc_x = numpy.append(self.linear_acc_x, msg.linear_acceleration.x)\n        self.linear_acc_y = numpy.append(self.linear_acc_y, msg.linear_acceleration.y)\n        self.linear_acc_z = numpy.append(self.linear_acc_z, msg.linear_acceleration.z)\n    elif topic == '/imu/data_raw_calibrated':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.linear_acc_x = numpy.append(self.linear_acc_x, msg.linear_acceleration.x)\n        self.linear_acc_y = numpy.append(self.linear_acc_y, msg.linear_acceleration.y)\n        self.linear_acc_z = numpy.append(self.linear_acc_z, msg.linear_acceleration.z)\n    elif topic == '/imu/data_raw_calibrated_ext':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.linear_acc_x = numpy.append(self.linear_acc_x, msg.linear_acceleration.x)\n        self.linear_acc_y = numpy.append(self.linear_acc_y, msg.linear_acceleration.y)\n        self.linear_acc_z = numpy.append(self.linear_acc_z, msg.linear_acceleration.z)\n    elif topic == '/imu/data_raw_calibrated_ext_mag':\n        self.append_times(msg.", "CodeBleu_score": 30.789543433394396}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw_calibrated\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.79521298840275}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure(figsize=(10, 8))\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(3, 1, 1)\n    ax.set_title('x')\n    for i, data in enumerate(self.accelerations):\n        ax.plot(data.time, data.x, label=data.name)\n    pyplot.ylabel('x')\n    pyplot.xlabel('Time (s)')\n    ax.legend()\n    ax = fig.add_subplot(3, 1, 2)\n    ax.set_title('y')\n    for i, data in enumerate(self.accelerations):\n        ax.plot(data.time, data.y, label=data.name)\n    pyplot.ylabel('y')\n    pyplot.xlabel('Time (s)')\n    ax.legend()\n    ax = fig.add_subplot(3, 1, 3)\n    ax.set_title('z')\n    for i, data in enumerate(self.accelerations):\n        ax.plot(data.time, data.z, label=data.name)\n    pyplot.ylabel('z')\n    pyplot.xlabel('Time (s)')\n    ax.legend()\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix:\n            filename += '_' + plot_suffix\n        pyplot.savefig(filename + '.png')\n    pyplot.show()\n", "CodeBleu_score": 40.7045332575402}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure(figsize=(12, 4))\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(111)\n    # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels\n    for i, dataset in enumerate(self.accelerations):\n        ax.plot(dataset.time, dataset.x, color=self.colors[i], label='x')\n        ax.plot(dataset.time, dataset.y, color=self.colors[i + 1], label='y')\n        ax.plot(dataset.time, dataset.z, color=self.colors[i + 2], label='z')\n    # Add labels for the x and y axes and include a legend\n    pyplot.ylabel('Acceleration (m/s^2)')\n    pyplot.xlabel('Time (s)')\n    pyplot.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix is not None:\n            filename += '_' + plot_suffix\n        pyplot.savefig(filename + '.png')\n    # Close the figure to prevent memory leaks\n    pyplot.close(fig)\n", "CodeBleu_score": 48.81758176917527}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    pass\n", "CodeBleu_score": 1.1312217194570136}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if collision.time > start_time and collision.time < end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None and end_time is None:\n            if collision.time > start_time:\n                collision_times.append(collision.time)\n        elif start_time is None and end_time is not None:\n            if collision.time < end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n", "CodeBleu_score": 38.42269237312204}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n\n\n\n", "CodeBleu_score": 32.146680046322444}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t", "CodeBleu_score": 2.6906647105137806}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t//  if (data == nullptr) {\n//    return;\n//  }\n\n//  const float multiplier = this->dist / 1000.0;\n//  Eigen::Map<Eigen::MatrixXf> data_vector_map(data, width, height);\n\n//  const float rms_noise = this->rms_noise * multiplier;\n//  const float noise = this->noise * multiplier;\n\n//  for (uint32_t i = 0; i < width; ++i) {\n//    for (uint32_t j = 0; j < height; ++j) {\n//      const float depth = data_vector_map(i, j);\n//      if (this->InRange(depth)) {\n//        const float noise_value = static_cast<float>(\n//            std::normal_distribution<float>(0.0, rms_noise)(this->generator));\n//        data_vector_map(i, j) += noise_value;\n//      } else {\n//        data_vector_map(i, j) = this->bad_point_value;\n//      }\n//    }\n//  }\n}", "CodeBleu_score": 2.7370175023774364}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t//  if (data == nullptr) {\n//    return;\n//  }\n//  const float multiplier =\n//      (this->dist * this->dist) / (this->focal_length * this->focal_length);\n//  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n//  const float rms_noise =\n//      std::sqrt(this->noise * this->noise +\n//                this->dist * this->dist * this->noise * this->noise *\n//                multiplier);\n//  const float noise = std::sqrt(this->noise * this->noise +\n//                                this->dist * this->dist * multiplier);\n//  for (uint32_t i = 0; i < width * height; i++) {\n//    if (this->InRange(data_vector_map[i])) {\n//      data_vector_map[i] +=\n//          (static_cast<float>(rand()) / static_cast<float>(RAND_MAX)) *\n//          noise -\n//          rms_noise / 2.0f;\n//    } else {\n//      data_vector_map[i] = this->bad_point;\n//    }\n//  }\n}", "CodeBleu_score": 2.7370175023774364}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t//  ROS_INFO(\"Received a trajectory message.\");\n//  ROS_INFO(\"Trajectory message: %s\", trajectory_msg->data.c_str());\n  // Get the current simulation time.\n  gazebo::common::Time current_time = this->world_->SimTime();\n  // Convert the simulation time to ROS time.\n  ros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n  // Write the trajectory message to the bag file.\n  this->writeBag(ros_time, trajectory_msg);\n}", "CodeBleu_score": 55.67273267090136}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t", "CodeBleu_score": 8.432682072468962}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t//  ROS_INFO(\"Received trajectory message.\");\n  ros::Time time = ros::Time::now();\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, time, *trajectory_msg);\n}", "CodeBleu_score": 44.895245314752934}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time.\n\tros::Time time = ConvertGazeboTimeToRosTime(now);\n\n\t// Create a message for the motor velocities.\n\tsensor_msgs::JointState rot_velocities_msg;\n\trot_velocities_msg.header.stamp = time;\n\trot_velocities_msg.name.resize(motor_joints_.size());\n\trot_velocities_msg.position.resize(motor_joints_.size());\n\trot_velocities_msg.velocity.resize(motor_joints_.size());\n\trot_velocities_msg.effort.resize(motor_joints_.size());\n\n\t// Iterate through the motor joints and calculate the slowed-down rotational velocities.\n\tfor (std::map<std::string, gazebo::physics::JointPtr>::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); m++) {\n\t\trot_velocities_msg.name[m->second->GetIndex()] = m->second->GetName();\n\t\trot_velocities_msg.position[m->second->GetIndex()] = m->second->GetAngle(0).Radian();\n\t\trot_velocities_msg.velocity[m->second->GetIndex()] = m->second->GetVelocity(0);\n\t\trot_velocities_msg.effort[m->second->GetIndex()] = m->second->GetForce(0);\n\t}\n\n\t// Write the message to a bag file.\n\trot_velocities_bag_.write(motor_topic_, rot_velocities_msg.header.stamp, rot_velocities_msg);\n}", "CodeBleu_score": 46.219659792401465}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert the simulation time to ROS time.\n\tros::Time ros_now = this->ConvertGazeboTime(now);\n\n\t// Create a message for actuator velocities.\n\tsensor_msgs::JointState rot_velocities_msg;\n\trot_velocities_msg.header.stamp = ros_now;\n\trot_velocities_msg.name.resize(motor_joints_.size());\n\trot_velocities_msg.position.resize(motor_joints_.size());\n\trot_velocities_msg.velocity.resize(motor_joints_.size());\n\trot_velocities_msg.effort.resize(motor_joints_.size());\n\n\t// Iterate through the motor joints.\n\tfor (std::map<std::string, boost::shared_ptr<GazeboMotorJoint> >::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); m++) {\n\t\t// Calculate the slowed-down rotational velocities.\n\t\tdouble rot_velocity = m->second->GetVelocity(now);\n\t\trot_velocity *= motor_slowdown_;\n\n\t\t// Assign the velocities to the message.\n\t\trot_velocities_msg.name[m - motor_joints_.begin()] = m->first;\n\t\trot_velocities_msg.velocity[m - motor_joints_.begin()] = rot_velocity;\n\t}\n\n\t// Write the message to the bag file.\n\tthis->WriteBag(ros_now, rot_velocities_msg, motor_topic_, motor_namespace_);\n}", "CodeBleu_score": 52.50634750368541}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert Gazebo time to ROS time\n\tros::Time time = ros::Time(now.sec, now.nsec);\n\t// Prepare message\n\trot_velocities_msg.header.stamp = time;\n\trot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\t// Iterate through joints\n\tfor (std::map<std::string, boost::shared_ptr<gazebo::physics::Joint> >::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); m++) {\n\t\t// Get joint velocity\n\t\tdouble velocity = m->second->GetVelocity(0);\n\t\t// Calculate slowed-down rotational velocity\n\t\tdouble rot_velocity = velocity / motor_joints_.size();\n\t\t// Assign rotational velocity to message\n\t\trot_velocities_msg.angular_velocities[m->second->GetIndex()] = rot_velocity;\n\t}\n\t// Write data to bag file\n\trot_velocities_bag.write(rot_velocities_topic_, time, rot_velocities_msg);\n}", "CodeBleu_score": 52.3971426602609}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT_CALLBACKS\n  std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\"\n            << std::endl;\n#endif\n\n  // Convert normalized input to control surface angles\n  double aileron_angle =\n      NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll());\n  double elevator_angle =\n      NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch());\n  double rudder_angle =\n      NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set throttle value\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust().x;\n\n  // Set control surface angles\n  aileron_angle_ = aileron_angle;\n  elevator_angle_ = elevator_angle;\n  rudder_angle_ = rudder_angle;\n}", "CodeBleu_score": 47.32154603422474}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called\n\";\n#endif\n\n  // Convert normalized input values to angles\n  double aileron_angle = NormalizedInputToAngle(aileron_,\n      roll_pitch_yawrate_thrust_msg->roll());\n  double elevator_angle = NormalizedInputToAngle(elevator_,\n      roll_pitch_yawrate_thrust_msg->pitch());\n  double rudder_angle = NormalizedInputToAngle(rudder_,\n      roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Set the control surface angles\n  aileron_.angle = aileron_angle;\n  elevator_.angle = elevator_angle;\n  rudder_.angle = rudder_angle;\n}", "CodeBleu_score": 46.731597275184065}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT_CALLBACKS\n  printf(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\n\");\n#endif\n\n  // Set control surface angles\n  for (int i = 0; i < n_control_surfaces; i++) {\n    if (control_surfaces[i].type == kAileron) {\n      control_surfaces[i].angle = NormalizedInputToAngle(\n          control_surfaces[i], roll_pitch_yawrate_thrust_msg->roll);\n    } else if (control_surfaces[i].type == kElevator) {\n      control_surfaces[i].angle = NormalizedInputToAngle(\n          control_surfaces[i], roll_pitch_yawrate_thrust_msg->pitch);\n    } else if (control_surfaces[i].type == kRudder) {\n      control_surfaces[i].angle = NormalizedInputToAngle(\n          control_surfaces[i], roll_pitch_yawrate_thrust_msg->yaw_rate);\n    }\n  }\n\n  // Set throttle\n  throttle = roll_pitch_yawrate_thrust_msg->thrust().x;\n}", "CodeBleu_score": 48.22149282764059}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tf GAZEBO_MAJOR_VERSION >= 9\n  // Convert timeout to timeval structure.\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n#endif\n\n  // Perform poll operation.\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(_fd, &read_fds);\n  int nfds = _fd + 1;\n  int ret = select(nfds, &read_fds, NULL, NULL, &tv);\n\n  if (ret == 0) {\n    // Timeout.\n    return;\n  } else if (ret < 0) {\n    // Error.\n    gzerr << \"Error in select() call. \n\";\n    return;\n  }\n\n  // Read data from socket.\n  char buffer[kMaxPacketLen];\n  int bytes_read = recv(_fd, buffer, kMaxPacketLen, 0);\n\n  if (bytes_read <= 0) {\n    // Error.\n    gzerr << \"Error in recv() call. \n\";\n    return;\n  }\n\n  // Parse MAVLink messages from buffer.\n  mavlink_message_t message;\n  mavlink_status_t status;\n  for (int i = 0; i < bytes_read; ++i) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &message, &status)) {\n      handle_message(&message);\n    }\n  }\n}", "CodeBleu_score": 56.12776327414986}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tfdef _WIN32\n  // Windows does not support poll()\n  return;\n#else\n  if (!is_open()) {\n    gzerr << \"Serial port closed! \n\";\n    return;\n  }\n\n  // Create a timeval struct with the specified timeout\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Create a set of file descriptors for the serial port and the socket\n  fd_set set;\n  FD_ZERO(&set);\n  FD_SET(_fd, &set);\n  FD_SET(sock_, &set);\n\n  // Perform the poll operation\n  int ret = select(std::max(_fd, sock_) + 1, &set, nullptr, nullptr, &timeout);\n\n  if (ret > 0) {\n    // If data is available on the serial port, receive and parse the data\n    if (FD_ISSET(_fd, &set)) {\n      do_read();\n    }\n\n    // If data is available on the socket, receive and parse the data\n    if (FD_ISSET(sock_, &set)) {\n      do_recvfrom();\n    }\n  }\n#endif\n}", "CodeBleu_score": 42.857350974520294}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tfdef __linux__\n  if (serial_enabled_) {\n    // Get the timeout value in seconds and microseconds.\n    uint32_t timeoutSec = _timeoutMs / 1000;\n    uint32_t timeoutUsec = (_timeoutMs % 1000) * 1000;\n\n    // Create a timeval structure to specify the timeout value.\n    struct timeval timeout;\n    timeout.tv_sec = timeoutSec;\n    timeout.tv_usec = timeoutUsec;\n\n    // Create a file descriptor set to monitor the serial port.\n    fd_set fds;\n    FD_ZERO(&fds);\n    FD_SET(_fd, &fds);\n\n    // Perform a poll operation on the file descriptors.\n    int result = select(_fd + 1, &fds, NULL, NULL, &timeout);\n\n    // If data is available, read the data and parse MAVLink messages.\n    if (result > 0) {\n      char buffer[MAVLINK_MAX_PACKET_LEN];\n      ssize_t len = read(_fd, buffer, sizeof(buffer));\n\n      if (len > 0) {\n        for (ssize_t i = 0; i < len; i++) {\n          mavlink_message_t msg;\n          mavlink_status_t status;\n          if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n            handle_message(&msg);\n          }\n        }\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 57.72051664389356}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(mutex_);\n\tif (is_open_) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 64.63803972085145}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(mutex_);\n\tif (is_open) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open = false;\n\t}\n}", "CodeBleu_score": 64.79721480559309}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(mutex_);\n\tif (is_open_) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 64.63803972085145}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d position,\n\t\tignition::math::Vector3d point1,\n\t\tignition::math::Vector3d point2,\n\t\tignition::math::Vector3d value1,\n\t\tignition::math::Vector3d value2\n\t}", "CodeBleu_score": 17.081337657394}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tdouble x1, y1, z1, x2, y2, z2, x, y, z;\n\tx1 = _windVector.x();\n\ty1 = _windVector.y();\n\tz1 = _windVector.z();\n\tx2 = _windVector2.x();\n\ty2 = _windVector2.y();\n\tz2 = _windVector2.z();\n\tx = x1 + (x2 - x1) * (pos - _windVector.x()) / (_windVector2.x() - _windVector.x());\n\ty = y1 + (y2 - y1) * (pos - _windVector.x()) / (_windVector2.x() - _windVector.x());\n\tz = z1 + (z2 - z1) * (pos - _windVector.x()) / (_windVector2.x() - _windVector.x());\n\treturn ignition::math::Vector3d(x, y, z);\n}", "CodeBleu_score": 33.37856510327234}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d a, b, c;\n\tdouble t;\n\ta = ignition::math::Vector3d(0, 0, 0);\n\tb = ignition::math::Vector3d(0, 0, 0);\n\tc = ignition::math::Vector3d(0, 0, 0);\n\tt = 0;\n\treturn c;\n}", "CodeBleu_score": 31.920155855535548}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t\n}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t\tif (mTime == _time)\n\t\treturn;\n\n\tmTime = _time;\n\n\tif (mTime < 0.0)\n\t\tmTime = 0.0;\n\telse if (mTime > mLength)\n\t\tmTime = mLength;\n\n\tif (mLooping)\n\t\tmTime = fmod(mTime, mLength);\n\n\t// Update the animation state\n\tUpdate();\n}", "CodeBleu_score": 31.43996243508303}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(self.x, self.y, self.z, 0, 0, 0, 0, 0, 0, self.yaw, 0)\n    self.mav.send_set_position_target_local_ned(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0", "CodeBleu_score": 40.73779365363114}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target()\n    self.set_position_target(target_raw_pose)\n    print", "CodeBleu_score": 35.374905817456714}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.print_vehicle_info()\n    self.print\n    self.set_position_target_local_ned(target_raw_pose, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n\n", "CodeBleu_score": 38.63327722045602}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.set_mode(custom_mode=self.flight_mode)\n            self.flight_mode = self.flightModeService.get_mode().name\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":Flight mode switch failed.\")\n            return False\n", "CodeBleu_score": 48.861709386761476}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    elif self.flightModeService.switchMode(self.flight_mode):\n        self.flight_mode = self.flightModeService.current_mode\n        print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode)\n        return True\n    else:\n        print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" failed\")\n        return False\n", "CodeBleu_score": 58.002736768368464}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.set_mode(self.construct_mode_request(self.flight_mode))\n            self.flight_mode = self.flightModeService.mode.name\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except Exception as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Failed to switch flight mode\")\n            print(e)\n            return False\n", "CodeBleu_score": 45.93757556372068}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if (self.hover_flag == 0):\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if (self.hover_flag == 0 and self.hold_flag == 0):\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 75.49821632086814}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if (self.hover_flag == 0):\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if (self.hover_flag == 0 and self.hold_flag == 0):\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 75.49821632086814}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x, y, z, w)\n    if self.hover_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n\n", "CodeBleu_score": 40.94830829271195}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        if self.flight_mode!= 'OFFBOARD':\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            self.set_mode('OFFBOARD')\n    elif self.hover_flag == 1 and self.flight_mode!= 'HOVER':\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        self.set_mode('HOVER')\n        self.hover()\n    elif self.hover_flag == 0 and self.flight_mode!= 'OFFBOARD':\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        self.set_mode('OFFBOARD')\n\n", "CodeBleu_score": 50.37261868409476}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.set_flight_mode('OFFBOARD')\n    elif self.hover_flag == 1 and self.flight_mode!= 'HOVER':\n        self.hover_flag = 0\n        self.set_flight_mode('HOVER')\n        self.hover()\n\n", "CodeBleu_score": 42.77932444524325}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n    else:\n        self.hover_flag = 1\n\n", "CodeBleu_score": 77.91551057340172}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw", "CodeBleu_score": 24.26411761619382}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 17.485641283375248}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 2\n    target_raw_pose = self.construct_target()\n    self.set_position_target_local_ned(target_raw_pose)\n    self.print", "CodeBleu_score": 26.695302558326805}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = self.frame_id\n    self.motion_type = 0\n    self.construct_target()\n    self.print\n", "CodeBleu_score": 12.642206438521345}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_raw_pose = self.construct_target(self.x, self.y, self.z, 0, 0, 0, 0, 0, 0, self.yaw, 0)\n    self.print", "CodeBleu_score": 35.93317336184388}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService.switch_mode(self.flight_mode).success:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flightModeService.mode.name)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Failed to switch to \" + self.flight_mode)\n            return False\n", "CodeBleu_score": 56.25637916331966}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.set_mode(self.construct_mode(self.flight_mode))\n            self.flight_mode = self.flightModeService.mode.name\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Failed to switch flight mode.\")\n            return False\n\n", "CodeBleu_score": 52.57681716938377}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.set_mode(self.vehicle_type, self.flight_mode)\n            self.flight_mode = self.flightModeService.get_mode(self.vehicle_type).name\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Failed to switch flight mode to \" + self.flight_mode)\n            return False\n", "CodeBleu_score": 54.43715444454769}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.gcs_command == 0:\n            self.takeoff_target_pose = msg\n        elif self.gcs_command == 1:\n            self.hover_target_pose = msg\n        elif self.gcs_command == 2:\n            self.land_target_pose = msg\n        elif self.gcs_command == 3:\n            self.land_target_pose = msg\n        elif self.gcs_command == 4:\n            self.land_target_pose = msg\n        elif self.gcs_command == 5:\n            self.land_target_pose = msg\n        elif self.gcs_command == 6:\n            self.land_target_pose = msg\n        elif self.gcs_command == 7:\n            self.land_target_pose = msg\n        elif self.gcs_command == 8:\n            self.land_target_pose = msg\n        elif self.gcs_command == 9:\n            self.land_target_pose = msg\n        elif self.gcs_command == 10:\n            self.land_target_pose = msg\n        elif self.gcs_command == 11:\n            self.land_target_pose = msg\n        elif self.gcs_command == 12:\n            self.land_target_pose = msg\n        elif self.gcs_command == 13:\n            self.land_target_pose = msg\n        elif self.gcs_command == 14:\n            self.land_target_pose = msg\n        elif self.gcs_command == 15:\n            self.land_target_pose = msg\n        elif self.gcs_command == 16:\n            self.land_target_pose = msg\n        elif self.gcs_command == 17:\n            self.land_target_pose = msg\n        elif self.gcs_command == 18:\n            self.land_target_pose = msg\n        elif self.gcs_command == 19:\n            self.land_target_pose = msg\n        elif self.gcs_command == 20:\n            self.land_target_pose = msg\n        elif self.gcs_command == 21:\n            self.land_target", "CodeBleu_score": 12.460417232440282}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.takeoff_target_pose is not None:\n            self.takeoff_target_pose.header.stamp = rospy.Time.now()\n        if self.hover_target_pose is not None:\n            self.hover_target_pose.header.stamp = rospy.Time.now()\n        self.global_pose.header.stamp = rospy.Time.now()\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.bias_x\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.bias_y\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.bias_z\n        self.global_pose.pose.orientation = self.local_pose.pose.orientation\n        self.global_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.global_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.global_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.global_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n\n", "CodeBleu_score": 22.53995319188643}, {"code": "def local_pose_callback(self, msg, i)\n\t\n\n    # If the message index matches the UAV ID, set the local_pose to the message.\n    if i == self.uav_id:\n        self.local_pose.pose.position.x = msg.pose.position.x\n        self.local_pose.pose.position.y = msg.pose.position.y\n        self.local_pose.pose.position.z = msg.pose.position.z\n        self.local_pose.pose.orientation.x = msg.pose.orientation.x\n        self.local_pose.pose.orientation.y = msg.pose.orientation.y\n        self.local_pose.pose.orientation.z = msg.pose.orientation.z\n        self.local_pose.pose.orientation.w = msg.pose.orientation.w\n        self.local_pose.header.stamp = rospy.Time.now()\n\n    # If the GCS command is takeoff, set the takeoff_target_pose to the local_pose.\n    if self.gcs_command == 1:\n        self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n        self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n        self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z\n        self.takeoff_target_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.takeoff_target_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.takeoff_target_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.takeoff_target_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n        self.takeoff_target_pose.header.stamp = rospy.Time.now()\n\n    # If the GCS command is hover, set the hover_target_pose to the local_pose.\n    if self.gcs_command == 2:\n        self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x\n        self.hover_target_pose.pose.position.y = self", "CodeBleu_score": 21.32370655993346}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == 'active':\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.862379601652705}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == 'active':\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.862379601652705}, {"code": "def takeoff_detection(self)\n\t\n    # TODO: complete this function\n    if self.get_altitude() > 0.2 and self.get_arm_state() == 'active':\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.808182576807155}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize the distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Loop through the rows of the distance matrix\n    for i in range(len(orig_formation)):\n        # Loop through the columns of the distance matrix\n        for j in range(len(change_formation)):\n            # Calculate the Euclidean distance between the UAVs\n            dist = np.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust the distance\n            dist = 50 - dist\n            # Convert the distance to an integer\n            dist = int(dist)\n            # Assign the adjusted distance to the corresponding entry in the distance matrix\n            dist_matrix[i, j] = dist\n    # Return the distance matrix\n    return dist_matrix\n", "CodeBleu_score": 27.141572582083363}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation_array = np.array(orig_formation)\n    change_formation_array = np.array(change_formation)\n    # Calculate the Euclidean distance between the UAVs\n    distance_matrix = np.linalg.norm(orig_formation_array - change_formation_array, axis=1)\n    # Adjust the distance values\n    distance_matrix = 50 - distance_matrix\n    # Convert the distance values to integers\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n", "CodeBleu_score": 17.279842402673175}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create an empty list to store the distances between UAVs\n    distances = []\n    # Create a list of all UAVs in the original formation\n    orig_uavs = orig_formation.uavs\n    # Create a list of all UAVs in the changed formation\n    change_uavs = change_formation.uavs\n    # Loop through all UAVs in the original formation\n    for orig_uav in orig_uavs:\n        # Create an empty list to store the distances between the current UAV and all other UAVs in the changed formation\n        orig_uav_distances = []\n        # Loop through all UAVs in the changed formation\n        for change_uav in change_uavs:\n            # Calculate the distance between the current UAV and the current changed UAV\n            distance = math.sqrt(\n                (orig_uav.x - change_uav.x) ** 2 + (orig_uav.y - change_uav.y) ** 2\n            )\n            # Subtract the distance from 50 and round it to the nearest integer\n            distance = round(50 - distance)\n            # Append the distance to the list of distances\n            orig_uav_distances.append(distance)\n        # Append the list of distances to the list of distances between UAVs\n        distances.append(orig_uav_distances)\n    # Return the distance matrix\n    return distances\n\n", "CodeBleu_score": 19.693881169596505}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.match_right = [-1] * self.n_right\n    self.label_left = [0] * self.n_left\n    self.label_right = [0] * self.n_right\n    self.visit_left = [False] * self.n_left\n    self.visit_right = [False] * self.n_right\n    self.slack_right = [float('inf')] * self.n_right\n    self.slack_right = [float('inf')] * self.n_right\n    for i in range(self.n_left):\n        self.slack_right = [float('inf')] * self.n_right\n        if not self.find_path(i):\n            min_slack = float('inf')\n            for j in range(self.n_right):\n                if self.slack_right[j] < min_slack:\n                    min_slack = self.slack_right[j]\n            for i in range(self.n_left):\n                if self.visit_left[i]:\n                    self.label_left[i] -= min_slack\n            for j in range(self.n_right):\n                if self.visit_right[j]:\n                    self.label_right[j] += min_slack\n    return self.match_right\n\n", "CodeBleu_score": 33.76193796391194}, {"code": "def KM(self)\n\t\n    self.match_right = [-1 for _ in range(len(self.adj_matrix))]\n    self.visit_left = [False for _ in range(len(self.adj_matrix))]\n    self.visit_right = [False for _ in range(len(self.adj_matrix))]\n    self.label_left = [0 for _ in range(len(self.adj_matrix))]\n    self.label_right = [0 for _ in range(len(self.adj_matrix))]\n    self.slack_right = [float('inf') for _ in range(len(self.adj_matrix))]\n    for i in range(len(self.adj_matrix)):\n        self.slack_right = [float('inf') for _ in range(len(self.adj_matrix))]\n        if not self.find_path(i):\n            min_slack = float('inf')\n            for j, slack in enumerate(self.slack_right, start=0):\n                if slack < min_slack:\n                    min_slack = slack\n            for j, label in enumerate(self.label_left, start=0):\n                self.label_left[j] -= min_slack\n            for j, label in enumerate(self.label_right, start=0):\n                self.label_right[j] += min_slack\n    return self.match_right\n\n", "CodeBleu_score": 32.52846007568404}, {"code": "def KM(self)\n\t\n    self.visit_left = [False] * self.n_uavs\n    self.visit_right = [False] * self.n_targets\n    self.match_right = [-1] * self.n_targets\n    self.label_left = [0] * self.n_uavs\n    self.label_right = [0] * self.n_targets\n    self.slack_right = [float('inf')] * self.n_targets\n    for i in range(self.n_uavs):\n        self.slack_right = [float('inf')] * self.n_targets\n        if not self.find_path(i):\n            min_slack = min(self.slack_right)\n            for j in range(self.n_targets):\n                if self.visit_right[j]:\n                    self.label_right[j] -= min_slack\n            for i in range(self.n_uavs):\n                if self.visit_left[i]:\n                    self.label_left[i] += min_slack\n    return self.match_right\n", "CodeBleu_score": 33.05806902046558}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 27.09532694324272}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tif (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tROS_WARN_THROTTLE(1, \"No standalone tag description found for ID %d\", id);\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = standalone_tag_descriptions_[id];\n\treturn true;\n}", "CodeBleu_score": 32.34059223804198}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tstd::map<int, StandaloneTagDescription>::const_iterator it = standalone_tag_descriptions_.find(id);\n\tif (it == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tROS_WARN_THROTTLE(1, \"Could not find standalone tag description for ID %d.\", id);\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = it->second;\n\treturn true;\n}", "CodeBleu_score": 45.52113341450102}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tif(standalone_tag_descriptions_.find(id)!= standalone_tag_descriptions_.end()) {\n\t\tdescriptionContainer = standalone_tag_descriptions_[id];\n\t\treturn true;\n\t}\n\telse if(printWarning) {\n\t\tROS_WARN_THROTTLE(1, \"Could not find standalone tag description with ID %d.\", id);\n\t}\n\treturn false;\n}", "CodeBleu_score": 28.432353607210352}]}
