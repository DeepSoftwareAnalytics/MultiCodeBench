{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\tuint8_t desc_type;\n\n\twhile (desc->bLength) {\n\t\tdesc_len = desc->bLength;\n\t\tdesc_type = desc->bDescriptorType;\n\n\t\tif (desc_type == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc_len);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 42.99056694708702}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\n\tnext_desc = desc;\n\twhile (next_desc->bDescriptorType!= desc_id) {\n\t\tdesc_len = next_desc->bLength;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc\n\t\t\t\t+ desc_len);\n\t\tif (next_desc->bDescriptorType == USB_DT_ENDP) {\n\t\t\tnext_desc = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn next_desc;\n}", "CodeBleu_score": 43.24878032464366}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc;\n\tuint8_t desc_len;\n\tuint8_t desc_type;\n\n\tnext_desc = desc;\n\n\twhile (1) {\n\t\tdesc_len = next_desc->bLength;\n\t\tdesc_type = next_desc->bDescriptorType;\n\n\t\tif (desc_type == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tif (desc_len == 0) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + desc_len);\n\t}\n}", "CodeBleu_score": 46.01439302743518}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\t// Check if there is a valid configuration and the interface number is within bounds\n\tif (udc_config_desc.bNumInterfaces == 0 || iface_num >= udc_config_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tuint8_t *desc = (uint8_t *) udc_config_desc.bLength;\n\twhile (desc < (uint8_t *) udc_config_desc.wTotalLength) {\n\t\t// Check if the current descriptor is an interface descriptor\n\t\tif (desc[0] == USB_DT_INTERFACE) {\n\t\t\t// Check if the current interface descriptor matches the specified interface number and setting number\n\t\t\tif (desc[2] == iface_num && desc[3] == setting_num) {\n\t\t\t\t// Update the interface descriptor\n\t\t\t\tudc_iface_desc = (usb_iface_desc_t *) desc;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Move to the next descriptor\n\t\tdesc += desc[1];\n\t}\n\n\t// If no matching interface descriptor was found, return false\n\treturn false;\n}", "CodeBleu_score": 35.48783206124833}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (usb_conf_desc.bNumInterfaces > 0) {\n\t\tfor (uint8_t i = 0; i < usb_conf_desc.bNumInterfaces; i++) {\n\t\t\tif (usb_iface_desc[i].bInterfaceNumber == iface_num) {\n\t\t\t\tif (usb_iface_desc[i].bAlternateSetting == setting_num) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 22.837404629494436}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udd_ep_status_t)) {\n\t\treturn false;\n\t}\n\n\tudd_ep_status_t ep_status;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tep_status = UDD_EP_STATUS_HALTED;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tudd_set_setup_payload((uint8_t *)&ep_status, sizeof(ep_status));\n\treturn true;\n}", "CodeBleu_score": 50.06431207206907}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udd_ep_status_t)) {\n\t\treturn false;\n\t}\n\tudd_ep_status_t ep_status = UDD_EP_STATUS_HALTED;\n\tif (udd_ep_is_enabled(udd_g_ctrlreq.req.wIndex)) {\n\t\tep_status = UDD_EP_STATUS_ENABLED;\n\t}\n\tudd_set_setup_payload((uint8_t *)&ep_status, sizeof(udd_ep_status_t));\n\treturn true;\n}", "CodeBleu_score": 55.84218134538419}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udd_ep_status_t)) {\n\t\treturn false;\n\t}\n\n\tudd_ep_status_t status;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tstatus = UDD_EP_STATUS_HALTED;\n\t} else {\n\t\tstatus = 0;\n\t}\n\n\tudd_set_setup_payload((uint8_t *)&status, sizeof(udd_ep_status_t));\n\treturn true;\n}", "CodeBleu_score": 55.95399252274351}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (req->wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (false == udc_update_iface_desc(req->wIndex, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (false == udc_update_iface_desc(req->wIndex,\n\t\t\tudc_ptr_iface->bAlternateSetting)) {\n\t\treturn false;\n\t}\n\n\t// Forward the request to the corresponding UDI handler\n\treturn udc_ptr_iface->handler(req);\n}", "CodeBleu_score": 52.44666873275274}, {"code": "static bool udc_req_iface(void){\n\t\tbool ret = false;\n\tuint8_t iface_num = udc_ptr_setup->wIndex & 0xFF;\n\tuint8_t setting_num = udc_ptr_setup->wValue & 0xFF;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to default setting\n\tif (udc_update_iface_desc(iface_num, 0)) {\n\t\t// Update the interface descriptor to current alternate setting\n\t\tif (udc_update_iface_desc(iface_num, setting_num)) {\n\t\t\t// Forward the SETUP request to the corresponding UDI handler\n\t\t\tret = udc_ptr_iface->udi_api->setup(\n\t\t\t\t\tudc_ptr_setup,\n\t\t\t\t\tudc_ptr_iface->udi_desc_ptr);\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 62.916669977254756}, {"code": "static bool udc_req_iface(void){\n\t\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\tif (udc_req_iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\t// Start at the beginning of configuration descriptor\n\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)\n\t\t\tudc_ptr_conf->desc;\n\t// Check the end of configuration descriptor\n\twhile (udc_ptr_iface < udc_get_eof_conf()) {\n\t\tif (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {\n\t\t\t// A interface descriptor is found\n\t\t\t// Check interface number\n\t\t\tif (udc_req_iface_num ==\n\t\t\t\t\tudc_ptr_iface->bInterfaceNumber) {\n\t\t\t\t// Interface found\n\t\t\t\t// Update interface descriptor to default setting\n\t\t\t\tudc_ptr_iface->bAlternateSetting = 0;\n\t\t\t\t// Update interface descriptor to current setting\n\t\t\t\tif (udc_ptr_iface->bAlternateSetting!=\n\t\t\t\t\t\tudc_req_iface_alt_setting) {\n\t\t\t\t\tudc_ptr_iface->bAlternateSetting =\n\t\t\t\t\t\t\tudc_req_iface_alt_setting;\n\t\t\t\t}\n\t\t\t\t// Forward the SETUP request to the UDI handler\n\t\t\t\treturn udc_ptr_iface->udi_api->setup(\n\t\t\t\t\t\tudc_req_iface_num,\n\t\t\t\t\t\tudc_req_iface_alt_setting);\n\t\t\t}\n\t\t}\n\t\t// Go to next descriptor\n\t\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (\n\t\t\t\t(uint8_t *) udc_ptr_iface +\n\t\t\t\tudc_ptr_iface->bLength);\n\t}\n\treturn false; // Interface not found\n}", "CodeBleu_score": 55.53813946434588}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t\n#if UDI_MSC_ENABLE_EXT\n  // Call external enable function\n  if (!UDI_MSC_ENABLE_EXT()) {\n    return false;\n  }\n#endif\n\n  // Enable MSC interface\n  udi_msc_enable_internal();\n\n  // Retrieve the number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n\n  // Check if there are any LUNs available\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_nb_lun; i++) {\n    mem_unload(i);\n  }\n\n  // Start the MSC process by waiting for a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 49.809535546038546}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_EP_IN == UDI_MSC_EP_OUT\n  (void)ep;\n#endif\n  if (UDD_EP_TRANSFER_OK!= status) {\n    // Error in transfer\n    // then STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    return;\n  }\n  // Update sense data\n  udi_msc_sense.bSenseKey = USB_SENSE_NO_SENSE;\n  udi_msc_sense.bAdditionalSenseCode = USB_SENSE_NO_SENSE;\n  udi_msc_sense.bAdditionalSenseCodeQualifier = USB_SENSE_NO_SENSE;\n  udi_msc_sense.bSenseKeySpecific = 0;\n  udi_msc_sense.bValid = 1;\n  // Update CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  udi_msc_csw_process();\n}", "CodeBleu_score": 60.08399709092179}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDI_MSC_EP_IN == 0)\n  (void)ep;\n#endif\n  if (UDD_EP_TRANSFER_OK == status) {\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    if (0 == udi_msc_csw.dCSWDataResidue) {\n      // CSW is fully sent\n      udi_msc_sense_pass();\n      udi_msc_csw_process();\n    } else {\n      // CSW is not fully sent\n      udi_msc_csw_send();\n    }\n  } else {\n    // Data transfer failed\n    udi_msc_sense_fail(USB_SENSE_FAILED_ERR);\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 57.12282125750414}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_EP_IN == UDI_MSC_EP_OUT\n  // The IN and OUT endpoints are the same\n  // then the IN endpoint is the OUT endpoint\n  ep = UDI_MSC_EP_IN;\n#endif\n\n  // Check the status of the transfer\n  if (UDD_EP_TRANSFER_OK!= status) {\n    // The transfer is not successful\n    // then STALL next request from USB host on corresponding endpoint\n    udd_ep_set_halt(ep);\n    // Wait for a MSC setup reset to restart CBW reception\n    return;\n  }\n  // The transfer is successful\n  // then update the sense data\n  udi_msc_update_sense(nb_sent);\n  // Decrease the data residue in the Command Status Wrapper (CSW) by the amount of data sent\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process the updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 68.49790126477824}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t#if UDI_MSC_CBW_DATA_LEN_MAX > 0\n  // If there is a non-zero data residue\n  if (udi_msc_csw.data_residue) {\n    // Stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n    if (udi_msc_cbw.flags & UDI_MSC_CBW_DIRECTION_IN) {\n      // Stall the next request from the USB host on the IN endpoint\n      udd_ep_stall(UDI_MSC_EP_IN);\n    } else {\n      // Stall the next request from the USB host on the OUT endpoint\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    }\n  }\n#endif\n\n  // Prepare the CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.data_residue = cpu_to_le32(udi_msc_cbw.data_len);\n\n  // Send the CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 57.804660062036525}, {"code": "static void udi_msc_csw_process(void){\n\t#if (UDI_MSC_EP_DIR_IN == UDI_MSC_EP_DIR_OUT)\n  // Send CSW on IN endpoint\n  if (!udd_ep_run(UDI_MSC_EP_IN, false,\n          (uint8_t *) & udi_msc_csw,\n          sizeof(udi_msc_csw),\n          udi_msc_csw_sent)) {\n    // Endpoint not available\n    // then restart CSW sent when endpoint IN STALL will be cleared\n    udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_process);\n  }\n#else\n  // Send CSW on OUT endpoint\n  if (!udd_ep_run(UDI_MSC_EP_OUT, false,\n          (uint8_t *) & udi_msc_csw,\n          sizeof(udi_msc_csw),\n          udi_msc_csw_sent)) {\n    // Endpoint not available\n    // then restart CSW sent when endpoint OUT STALL will be cleared\n    udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_csw_process);\n  }\n#endif\n}", "CodeBleu_score": 33.07235309735639}, {"code": "static void udi_msc_csw_process(void){\n\t#if UDI_MSC_EP_CBW_DIR == UDI_MSC_EP_CBW_DIR_OUT\n  if (udi_msc_data_residue!= 0) {\n    // Stall endpoint OUT\n    udd_ep_set_stall(UDI_MSC_EP_OUT);\n  }\n#else\n  if (udi_msc_data_residue!= 0) {\n    // Stall endpoint IN\n    udd_ep_set_stall(UDI_MSC_EP_IN);\n  }\n#endif\n\n  // Prepare CSW\n  udi_msc_csw.dCSWSignature = cpu_to_le32(UDI_MSC_CSW_SIGNATURE);\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_data_residue);\n  udi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_PASS;\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 54.44668115863838}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tuint8_t dtr_status;\n\tuint32_t dtr_rate;\n\n\t/* Get the current DTR status */\n\tdtr_status = usb_cdc_get_dtr_status(port);\n\n\t/* Check if the DTR rate is 1200 */\n\tdtr_rate = usb_cdc_get_dtr_rate(port);\n\tif (dtr_rate == 1200) {\n\t\t/* Check if the DTR signal is enabled */\n\t\tif (b_enable) {\n\t\t\t/* Cancel any scheduled reset */\n\t\t\tcancelReset();\n\t\t} else {\n\t\t\t/* Schedule a system reset */\n\t\t\tinitiateReset();\n\t\t}\n\t}\n\n\t/* Update the DTR status */\n\tusb_cdc_set_dtr_status(port, b_enable);\n}", "CodeBleu_score": 36.880212288938765}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tif (cdc_dtr_status[port] == 0) {\n\t\t\tcdc_dtr_status[port] = 1;\n\t\t\tif (cdc_dtr_rate[port] == 1200) {\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cdc_dtr_status[port] == 1) {\n\t\t\tcdc_dtr_status[port] = 0;\n\t\t\tif (cdc_dtr_rate[port] == 1200) {\n\t\t\t\tinitiateReset();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 31.934366593199293}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tif (port < USB_PORT_COUNT) {\n\t\t\tif (usb_cdc_dtr_status[port] == 0) {\n\t\t\t\tusb_cdc_dtr_status[port] = 1;\n\t\t\t\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t\t\t\tcancelReset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (port < USB_PORT_COUNT) {\n\t\t\tif (usb_cdc_dtr_status[port] == 1) {\n\t\t\t\tusb_cdc_dtr_status[port] = 0;\n\t\t\t\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t\t\t\tinitiateReset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.13671594811937}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(SPI_PCS, 0xFF);\n\t\twhile (spiStatus(SPI_PCS) & SPI_RX_EMPTY);\n\t\tbuf[i] = spiRec(SPI_PCS);\n\t}\n\tspiSend(SPI_PCS, 0xFF);\n\twhile (spiStatus(SPI_PCS) & SPI_RX_EMPTY);\n\tbuf[i] = spiRec(SPI_PCS);\n}", "CodeBleu_score": 42.128096953571784}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tspiSend(0xFF);\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiRec();\n\t\tbuf[i] = spiRec();\n\t}\n\tspiRec();\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 49.344046177324294}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < nbyte; i++) {\n\t\tSPI_PCS;\n\t\tspiRec(buf[i]);\n\t}\n\tSPI_PCS;\n\tspiRec(buf[i]);\n}", "CodeBleu_score": 44.248353522397124}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = NULL;\n\tCRITICAL_SECTION_START\n\toldHandler = get_relocated_table_addr()[irq];\n\tget_relocated_table_addr()[irq] = newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 52.89561157056685}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *table;\n\n\t/*\n\t * Disable global interrupts to ensure atomic operation.\n\t */\n\t__disable_irq();\n\n\t/*\n\t * Get the address of the relocated interrupt vector table.\n\t */\n\ttable = get_relocated_table_addr();\n\n\t/*\n\t * Get the current handler for the specified IRQ.\n\t */\n\toldHandler = table[irq];\n\n\t/*\n\t * Replace the current handler with the new handler.\n\t */\n\ttable[irq] = newHandler;\n\n\t/*\n\t * Re-enable global interrupts.\n\t */\n\t__enable_irq();\n\n\t/*\n\t * Return the original ISR handler.\n\t */\n\treturn oldHandler;\n}", "CodeBleu_score": 52.423699301227686}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t", "CodeBleu_score": 3.528701867557328}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_task_cdc_isenabled() && (udi_cdc_is_rx_ready() > 0)) {\n\t\treturn udi_cdc_getc();\n\t}\n\treturn -1;\n}", "CodeBleu_score": 9.774039103067294}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (!isenabled) return -1;\n\tif (rx_buffer_head == rx_buffer_tail) return -1;\n\treturn rx_buffer[rx_buffer_tail];\n}", "CodeBleu_score": 16.567970710602108}, {"code": "int MarlinSerialUSB::peek(){\n\t\treturn -1;\n}", "CodeBleu_score": 3.463852886057403}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\tchar c = pending_char;\n\t\tpending_char = 0;\n\t\treturn c;\n\t}\n\tif (!usb_cdc_isenabled())\n\t\treturn -1;\n\tif (!usb_cdc_is_rx_ready())\n\t\treturn -1;\n\tchar c = usb_task_cdc_getc();\n\tif (emergency_parser)\n\t\temergency_parser->update(c);\n\treturn c;\n}", "CodeBleu_score": 53.90119072334245}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\tchar c = pending_char;\n\t\tpending_char = 0;\n\t\treturn c;\n\t}\n\tif (!is_enabled ||!is_configured) {\n\t\treturn -1;\n\t}\n\tif (!udi_cdc_is_rx_ready()) {\n\t\treturn -1;\n\t}\n\tchar c = udi_cdc_getc();\n\tif (emergency_parser.enabled) {\n\t\temergency_parser.update(c);\n\t}\n\treturn c;\n}", "CodeBleu_score": 52.848679311077284}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\treturn pending_char;\n\t}\n\tif (!usb_cdc_isenabled() ||!usb_cdc_configured()) {\n\t\treturn -1;\n\t}\n\tif (usb_task_cdc_isenabled() &&!usb_cdc_is_rx_ready()) {\n\t\treturn -1;\n\t}\n\tif (usb_cdc_is_rx_ready()) {\n\t\tchar c = udi_cdc_getc();\n\t\tif (emergency_parser.enabled) {\n\t\t\temergency_parser.update(c);\n\t\t}\n\t\treturn c;\n\t}\n\treturn -1;\n}", "CodeBleu_score": 47.00583151837153}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(USB_SERIAL)\n  if (usb_cdc_is_rx_ready())\n    return usb_cdc_get_rx_count();\n#endif\n  return 0;\n}", "CodeBleu_score": 20.191176219626612}, {"code": "int MarlinSerialUSB::available(){\n\t\treturn usb_cdc_isenabled()? usb_cdc_is_rx_ready() : 0;\n}", "CodeBleu_score": 14.789017970081385}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_cdc_is_rx_ready()) {\n\t\treturn MarlinSerial::available();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 34.031048818286514}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t#if defined(EEPROM_SIZE)\n  if (pos < EEPROMSize) {\n    if (writing) {\n      value[pos - EEPROM_BASE_ADDR] = ee_Read(pos, true);\n    }\n    if (crc!= NULL) {\n      crc16(crc, value, pos - EEPROM_BASE_ADDR);\n    }\n    pos++;\n    return true;\n  }\n#endif\n\n  if (pos < FLASHSize) {\n    if (writing) {\n      value[pos - FLASH_BASE_ADDR] = readFlash(pos);\n    }\n    if (crc!= NULL) {\n      crc16(crc, value, pos - FLASH_BASE_ADDR);\n    }\n    pos++;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 44.33830780214929}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tifdef EEPROM_DEBUG\n  Serial.print(\"PersistentStore::read_data(\");\n  Serial.print(pos);\n  Serial.print(\", \");\n  Serial.print(value);\n  Serial.print(\", \");\n  Serial.print(size);\n  Serial.print(\", \");\n  Serial.print(crc);\n  Serial.print(\", \");\n  Serial.print(writing);\n  Serial.println(\")\");\n#endif\n\n  // If the CRC value is not provided, return immediately\n  if (crc == NULL)\n    return false;\n\n  // If the value buffer is not provided, return immediately\n  if (value == NULL)\n    return false;\n\n  // If the size is zero, return immediately\n  if (size == 0)\n    return false;\n\n  // If the position is out of bounds, return immediately\n  if (pos < 0 || pos >= EEPROMSize)\n    return false;\n\n  // If the position is not aligned to a word boundary, return immediately\n  if (pos & 0x01)\n    return false;\n\n  // If the position is not aligned to a word boundary, return immediately\n  if (size & 0x01)\n    return false;\n\n  // If the size is out of bounds, return immediately\n  if (pos + size > EEPROMSize)\n    return false;\n\n  // If the size is zero, return immediately\n  if (size == 0)\n    return false;\n\n  // Read the data from the storage\n  for (size_t i = 0; i < size; i += 2) {\n\n    // Read the data from the storage\n    uint8_t data = ee_Read(pos + i, false);\n\n    // If the data is not stored, return immediately\n    if (data == 0xFF)\n      return false;\n\n    // Update the CRC value\n    crc16(crc, &data, 1);\n\n    // If we are writing the data to the value buffer, do it\n    if (writing) {\n      value[i] = data;\n      value[i + 1] = data;\n    }\n\n    // Increment the position\n    pos += 2;\n  }\n\n  // Return \"true\" if we reached the end of the operation\n  return true;\n}", "CodeBleu_score": 41.839190485311406}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t#ifdef DEBUG_PERSISTENT_STORE\n  Serial.print(F(\"PersistentStore::read_data: pos=\"));\n  Serial.print(pos);\n  Serial.print(F(\", size=\"));\n  Serial.print(size);\n  Serial.print(F(\", crc=\"));\n  Serial.println(*crc);\n#endif\n\n  // If the CRC is invalid, return false\n  if (*crc == 0xFFFF)\n    return false;\n\n  // Read data\n  for (size_t i = 0; i < size; i++) {\n\n    // Read a byte from the persistent storage\n    uint8_t b = read_byte(pos);\n\n    // If we reached the end of the persistent storage, return false\n    if (b == 0xFF)\n      return false;\n\n    // If we are writing, write the byte to the value buffer\n    if (writing)\n      *value++ = b;\n\n    // Update the CRC\n    crc16(crc, &b, 1);\n\n    // Increment the position\n    pos++;\n  }\n\n  // Return true\n  return true;\n}", "CodeBleu_score": 46.78401515610424}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tifdef ESP32\n  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n#endif\n\n  int8_t pwm_index = -1;\n  for (int i = 0; i < PWM_MAX_NUM; i++) {\n    if (pwm_pin[i] == pin) {\n      pwm_index = i;\n      break;\n    }\n  }\n  if (pwm_index < 0) {\n    pwm_index = pwm_index_first_free;\n    pwm_pin[pwm_index] = pin;\n    pwm_index_first_free = pwm_index + 1;\n    pwm_value[pwm_index] = 0;\n    pwm_freq[pwm_index] = freq;\n    pwm_res[pwm_index] = res;\n    pwm_timer_start(pwm_index);\n  }\n  pwm_value[pwm_index] = value;\n  ledcWrite(pwm_index, value);\n}", "CodeBleu_score": 60.07786450972728}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif!defined(ESP32)\n  if (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return; // Not a hardware PWM pin!\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n  else {\n    // No hardware PWM channel available, use software PWM\n    if (pwmInfo[0].used == 0) {\n      // First PWM pin, start timer\n      timer_start(0, freq);\n      pwmInfo[0].used = 1;\n    }\n    if (pwmInfo[0].used < PWM_MAX_NUM) {\n      // Allocate PWM to this channel\n      pwmInfo[0].pin[pwmInfo[0].used] = pin;\n      pwmInfo[0].value[pwmInfo[0].used] = value;\n      pwmInfo[0].used++;\n    }\n  }\n#endif\n}", "CodeBleu_score": 45.294766213186264}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif WITH_PWM\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n#endif\n  // Not a hardware PWM pin!\n  // Search for existing software PWM state\n  for (uint8_t i = 0; i < PWM_MAX_NUM; i++) {\n    if (pwmState[i].pin == pin) {\n      pwmState[i].value = value;\n      pwmState[i].freq = freq;\n      pwmState[i].res = res;\n      pwmState[i].last = millis();\n      return;\n    }\n  }\n  // Allocate new software PWM state\n  for (uint8_t i = 0; i < PWM_MAX_NUM; i++) {\n    if (pwmState[i].pin == 0) {\n      pwmState[i].pin = pin;\n      pwmState[i].value = value;\n      pwmState[i].freq = freq;\n      pwmState[i].res = res;\n      pwmState[i].last = millis();\n      if (pwm_count++ == 0) {\n        // Start the timer if this is the first PWM pin used\n        pwm_timer.begin(pwm_handler, PWM_TIMER_INTERVAL);\n        pwm_timer.start();\n      }\n      return;\n    }\n  }\n}", "CodeBleu_score": 60.91111060264256}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#ifdef SERVO_DELAY_ARRAY_LENGTH\n  static_assert(SERVO_DELAY_ARRAY_LENGTH == NUM_SERVOS, \"Servo delay array length does not match the number of servos.\");\n#endif\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 52.3198441123214}, {"code": "void Servo::move(const int value){\n\t#if defined(DEACTIVATE_SERVOS_AFTER_MOVE) && DEACTIVATE_SERVOS_AFTER_MOVE == 1\n  if (channel >= 0) {\n    detach();\n  }\n#endif\n  write(value);\n  safe_delay(delays[channel]);\n#if defined(DEACTIVATE_SERVOS_AFTER_MOVE) && DEACTIVATE_SERVOS_AFTER_MOVE == 1\n  if (channel >= 0) {\n    detach();\n  }\n#endif\n}", "CodeBleu_score": 50.73281256149441}, {"code": "void Servo::move(const int value){\n\t#if DEACTIVATE_SERVOS_AFTER_MOVE\n  if (channel >= 0) {\n    detach();\n  }\n#endif\n  write(value);\n  safe_delay(servo_delay[channel]);\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n  if (channel >= 0) {\n    detach();\n  }\n#endif\n}", "CodeBleu_score": 45.241757172246885}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\t//for each pin\n\tfor (uint32_t i = 0; i < 8; i++) {\n\t\t//if the pin has active PWM\n\t\tif (i2s_pins[i].duty_cycle!= 0) {\n\t\t\t//if the PWM tick count reaches zero\n\t\t\tif (i2s_pins[i].tick_count == 0) {\n\t\t\t\t//toggle the pin state between high and low\n\t\t\t\ti2s_pins[i].state =!i2s_pins[i].state;\n\t\t\t\t//set the tick count for the next transition\n\t\t\t\ti2s_pins[i].tick_count = i2s_pins[i].duty_cycle;\n\t\t\t}\n\t\t\t//decrement the PWM tick count\n\t\t\ti2s_pins[i].tick_count--;\n\t\t}\n\t}\n\t//store the updated port data into the current position of the DMA buffer\n\ti2s_buffer[i2s_buffer_position] = i2s_port;\n\t//increment the buffer position\n\ti2s_buffer_position++;\n\t//if the buffer is full, reset the buffer position\n\tif (i2s_buffer_position == i2s_buffer_size) {\n\t\ti2s_buffer_position = 0;\n\t}\n}", "CodeBleu_score": 29.265321026981674}, {"code": "void i2s_push_sample(){\n\t\tuint32_t data;\n\tuint32_t bit;\n\tuint32_t mask;\n\tuint32_t i;\n\n\tfor (i = 0; i < I2S_CHANNELS; i++) {\n\t\tif (i2s_state[i].active) {\n\t\t\tif (i2s_state[i].tick_count == 0) {\n\t\t\t\ti2s_state[i].tick_count = i2s_state[i].period;\n\t\t\t\ti2s_state[i].pin_state =!i2s_state[i].pin_state;\n\t\t\t} else {\n\t\t\t\ti2s_state[i].tick_count--;\n\t\t\t}\n\t\t}\n\t}\n\n\tdata = 0;\n\tfor (i = 0; i < I2S_CHANNELS; i++) {\n\t\tbit = 1 << i;\n\t\tmask = bit << I2S_PORT_SHIFT;\n\t\tif (i2s_state[i].pin_state) {\n\t\t\tdata |= mask;\n\t\t}\n\t}\n\n\ti2s_buffer[i2s_buffer_pos++] = data;\n}", "CodeBleu_score": 21.545069135948257}, {"code": "void i2s_push_sample(){\n\t\tuint32_t sample = 0;\n\tuint32_t i;\n\tfor (i = 0; i < I2S_PINS_NUM; i++) {\n\t\tif (i2s_pins[i].active_pwm) {\n\t\t\tif (i2s_pins[i].pwm_tick_count == 0) {\n\t\t\t\ti2s_pins[i].pwm_tick_count = i2s_pins[i].pwm_tick_count_max;\n\t\t\t\ti2s_pins[i].active_pwm = 0;\n\t\t\t\tif (i2s_pins[i].state == HIGH) {\n\t\t\t\t\ti2s_pins[i].state = LOW;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pins[i].state = HIGH;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ti2s_pins[i].pwm_tick_count--;\n\t\t\t}\n\t\t\tif (i2s_pins[i].state == HIGH) {\n\t\t\t\tsample |= (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\ti2s_dma_buffer[i2s_dma_buffer_pos] = sample;\n\ti2s_dma_buffer_pos++;\n}", "CodeBleu_score": 28.247491840186445}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_count;\n\n\tif (timer_num > 3) {\n\t\treturn 0;\n\t}\n\n\ttimer_count = TIMER_BASE_ADDR[timer_num]->TCNT;\n\n\treturn timer_count;\n}", "CodeBleu_score": 34.79752818634894}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t", "CodeBleu_score": 6.3673303957920355}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn 0;\n}", "CodeBleu_score": 6.769084640356114}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t data;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tdata = EEPROM.read(pos);\n\t\tif (writing) {\n\t\t\t*value = data;\n\t\t\tvalue++;\n\t\t}\n\t\tcrc16(crc, &data, 1);\n\t\tpos++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 58.13926077857297}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\n\tif (writing) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tvalue[i] = EEPROM.read(pos + i);\n\t\t\tcrc16(crc, &value[i], 1);\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tvalue[i] = EEPROM.read(pos + i);\n\t\t}\n\t}\n\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 61.23683465246157}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t// read the data from the EEPROM\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos + i);\n\t\t// update the CRC\n\t\tif (crc!= nullptr)\n\t\t\tcrc16(crc, &value[i], 1);\n\t}\n\t// update the position pointer\n\tpos += size;\n\t// return false if the reading is complete\n\treturn (pos >= EEPROM.length());\n}", "CodeBleu_score": 56.768962000665056}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint32_t retries = 0;\n\tuint32_t status = 0;\n\tbool success = false;\n\n\tif (sdio_handle == NULL || src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: SDIO handle or source pointer is null\n\");\n\t\treturn false;\n\t}\n\n\twhile (retries < SDIO_MAX_RETRIES) {\n\t\tstatus = SDIO_WriteBlocks(sdio_handle, src, block, 1, SDIO_TRANSFER_TIMEOUT);\n\t\tif (status == SD_OK) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t\tretries++;\n\t}\n\n\tif (!success) {\n\t\tprintf(\"SDIO_WriteBlock: Write block failed after %d retries\n\", retries);\n\t}\n\n\treturn success;\n}", "CodeBleu_score": 43.001584574708865}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint32_t retry = 0;\n\tbool status = false;\n\n\tif (sdio_handle == NULL || src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: SDIO handle or source pointer is null\n\");\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tif (HAL_SDIO_WriteBlocks(sdio_handle, (uint8_t *) src, block, 1, 1000) == HAL_OK) {\n\t\t\tstatus = true;\n\t\t\tbreak;\n\t\t}\n\t\tretry++;\n\t} while (retry < 10);\n\n\tif (retry == 10) {\n\t\tprintf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 41.121443970092145}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint32_t retry = 0;\n\tbool success = false;\n\tdo {\n\t\tif (SDIO_Handle == NULL || src == NULL) {\n\t\t\tCORE_ASSERT(false);\n\t\t\treturn false;\n\t\t}\n\t\tif (HAL_SDIO_WriteBlocks(&SDIO_Handle, (uint32_t *) src, block, 1, 1000) == HAL_OK) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t\tretry++;\n\t} while (retry < 100);\n\tif (!success) {\n\t\tprintf(\"SDIO_WriteBlock: Failed to write block %u\n\", block);\n\t}\n\treturn success;\n}", "CodeBleu_score": 37.78138079633393}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\ttemperature_timer_prescale = (uint16_t) (F_CPU / frequency / 1000);\n\t\ttimer_setCallbackPriority(TIMER_CHANNEL_TEMPERATURE, TEMPERATURE_TIMER_PRIORITY);\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\tstepper_timer_prescale = (uint16_t) (F_CPU / frequency / 1000);\n\t\ttimer_setCallbackPriority(TIMER_CHANNEL_STEPPER, STEPPER_TIMER_PRIORITY);\n\t} else {\n\t\tCORE_ASSERT_FAIL();\n\t}\n\ttimer_num->start(frequency, timer_num->setCallbackPriority);\n}", "CodeBleu_score": 46.754094335672626}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tCORE_DEBUG_ASSERT(timer_num < TIMER_CHANNEL_MAX);\n\tCORE_DEBUG_ASSERT(frequency!= 0);\n\n\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\ttimer_temperature_set_frequency(frequency);\n\t\ttimer_temperature_set_prescale(TIMER_PRESCALE_TEMPERATURE);\n\t\ttimer_temperature_set_callback_priority(TIMER_PRIORITY_TEMPERATURE);\n\t\ttimer_temperature_start();\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\ttimer_stepper_set_frequency(frequency);\n\t\ttimer_stepper_set_prescale(TIMER_PRESCALE_STEPPER);\n\t\ttimer_stepper_set_callback_priority(TIMER_PRIORITY_STEPPER);\n\t\ttimer_stepper_start();\n\t} else {\n\t\tCORE_ASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 40.7334053074319}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t", "CodeBleu_score": 2.9267475901190156}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\t// TODO: implement\n\treturn false;\n}", "CodeBleu_score": 2.16843765644704}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the EEPROM file\n\tfile = fopen(EEPROM_FILE, \"r+b\");\n\t// Check if the file was opened successfully\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\t// Check the file size\n\tfseek(file, 0, SEEK_END);\n\tint file_size = ftell(file);\n\t// If the file is smaller than the expected EEPROM size, fill the remainder of the buffer with a default erase value\n\tif (file_size < EEPROM_SIZE) {\n\t\tfseek(file, file_size, SEEK_SET);\n\t\tmemset(buffer + file_size, EEPROM_ERASE_VALUE, EEPROM_SIZE - file_size);\n\t}\n\t// Read the file's contents into the buffer\n\tfseek(file, 0, SEEK_SET);\n\tfread(buffer, 1, EEPROM_SIZE, file);\n\t// Close the file\n\tfclose(file);\n\t// Return true to indicate success\n\treturn true;\n}", "CodeBleu_score": 44.21260930062167}, {"code": "bool PersistentStore::access_start(){\n\t\t// TODO: implement\n\treturn false;\n}", "CodeBleu_score": 2.16843765644704}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i = 0;\n\tuint8_t receivedByte = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n\t\t}\n\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\t\treceivedByte <<= 1;\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_PORT, SPI_MISO_PIN) == GPIO_PIN_SET) {\n\t\t\treceivedByte |= 0x01;\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\t\tb <<= 1;\n\t}\n\treturn receivedByte;\n}", "CodeBleu_score": 35.886044353001814}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t rx = 0;\n\tuint8_t tx = b;\n\tfor (i = 0; i < 8; i++) {\n\t\tGPIO_Pin_Write(SPI_MOSI_PORT, SPI_MOSI_PIN, tx & 0x80);\n\t\tGPIO_Pin_Write(SPI_CLK_PORT, SPI_CLK_PIN, HIGH);\n\t\trx = rx << 1;\n\t\tif (GPIO_Pin_Read(SPI_MISO_PORT, SPI_MISO_PIN) == HIGH) {\n\t\t\trx |= 0x01;\n\t\t}\n\t\tGPIO_Pin_Write(SPI_CLK_PORT, SPI_CLK_PIN, LOW);\n\t\ttx = tx << 1;\n\t}\n\tdelaySPIFunc();\n\treturn rx;\n}", "CodeBleu_score": 40.510243581364016}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t receivedByte = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\t// set clock low\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\t// write most significant bit of byte to MOSI\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\t// toggle clock high\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\t// read bit from MISO\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\treceivedByte |= 0x01;\n\t\t}\n\t\t// shift byte left\n\t\tb <<= 1;\n\t\t// shift received byte right\n\t\treceivedByte <<= 1;\n\t}\n\t// introduce small delay\n\tHAL_Delay(SPI_DELAY_NS);\n\t// return received byte\n\treturn receivedByte;\n}", "CodeBleu_score": 37.04140231168208}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// read the received byte\n\tuint8_t byte = obj->serial_read();\n\n\t// check if the byte is a parity error\n\tif (obj->serial_rx_parity_error()) {\n\t\t// clear the parity error\n\t\tobj->serial_rx_parity_error_clear();\n\n\t\t// if enabled, update the emergency parser\n\t\tif (obj->emergency_parser.enabled) {\n\t\t\tobj->emergency_parser.update(byte);\n\t\t}\n\n\t\t// return\n\t\treturn;\n\t}\n\n\t// check if there is space available in the receive buffer\n\tif (obj->rx_head < obj->rx_tail + obj->rx_size) {\n\t\t// store the byte in the receive buffer\n\t\tobj->rx_buffer[obj->rx_head] = byte;\n\n\t\t// update the next buffer index\n\t\tobj->rx_head = (obj->rx_head + 1) % obj->rx_size;\n\n\t\t// if enabled, update the emergency parser\n\t\tif (obj->emergency_parser.enabled) {\n\t\t\tobj->emergency_parser.update(byte);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.97106791623393}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Get the received byte\n\tuint8_t rx_byte = uart_getc(obj);\n\t// Check for parity error\n\tif (uart_get_parity_error(obj)) {\n\t\t// Set the parity error flag\n\t\tobj->flags |= UART_FLAG_RX_PARITY_ERROR;\n\t\t// Clear the parity error flag\n\t\tuart_clear_parity_error(obj);\n\t}\n\t// Check if the receive buffer is full\n\tif (obj->rx_head == (obj->rx_tail + 1) % SERIAL_BUFFER_SIZE) {\n\t\t// Set the overflow flag\n\t\tobj->flags |= UART_FLAG_RX_OVERFLOW;\n\t}\n\t// Check if the receive buffer is empty\n\telse if (obj->rx_head == obj->rx_tail) {\n\t\t// Set the empty flag\n\t\tobj->flags |= UART_FLAG_RX_EMPTY;\n\t}\n\t// Store the received byte in the receive buffer\n\tobj->rx_buffer[obj->rx_head] = rx_byte;\n\t// Calculate the next buffer index\n\tobj->rx_head = (obj->rx_head + 1) % SERIAL_BUFFER_SIZE;\n\t// Check if the emergency parser is enabled\n\tif (obj->emergency_parser.enabled) {\n\t\t// Update the emergency parser\n\t\tobj->emergency_parser.update(obj, rx_byte);\n\t}\n}", "CodeBleu_score": 41.78350162343657}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Get the UART peripheral\n\tMSerialT *uart = reinterpret_cast<MSerialT*>(obj);\n\n\t// Read the received byte\n\tuint8_t byte = uart->uart->read();\n\n\t// Check for parity error\n\tif (uart->uart->is_parity_error()) {\n\t\t// Reset the UART peripheral\n\t\tuart->uart->reset();\n\n\t\t// Clear the parity error flag\n\t\tuart->uart->clear_parity_error();\n\n\t\t// Set the error flag\n\t\tuart->error = true;\n\t}\n\n\t// Check if the receive buffer is full\n\tif (uart->rx_buffer_head!= uart->rx_buffer_tail) {\n\t\t// Check if the receive buffer is full\n\t\tif (uart->rx_buffer_head == uart->rx_buffer_tail + 1) {\n\t\t\t// Reset the head pointer\n\t\t\tuart->rx_buffer_head = 0;\n\t\t}\n\n\t\t// Store the received byte in the receive buffer\n\t\tuart->rx_buffer[uart->rx_buffer_head] = byte;\n\n\t\t// Calculate the next buffer index\n\t\tuart->rx_buffer_head = (uart->rx_buffer_head + 1) % uart->rx_buffer_size;\n\t}\n\n\t// Check if the emergency parser is enabled\n\tif (uart->emergency_parser_enabled) {\n\t\t// Update the emergency parser with the received byte\n\t\tuart->emergency_parser->update(byte);\n\t}\n}", "CodeBleu_score": 34.17760494142568}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif(timer_instance[timer_num]->initialized &&!timer_instance[timer_num]->hasInterrupt) {\n\t\tif(timer_num == MF_TIMER_STEP) {\n\t\t\tNVIC_EnableIRQ(TIMER_A0_IRQn);\n\t\t\ttimer_instance[MF_TIMER_STEP]->hasInterrupt = true;\n\t\t} else if(timer_num == MF_TIMER_TEMP) {\n\t\t\tNVIC_EnableIRQ(TIMER_A1_IRQn);\n\t\t\ttimer_instance[MF_TIMER_TEMP]->hasInterrupt = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 47.27568997595902}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->initialized &&!timer_instance[timer_num]->hasInterrupt) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\tNVIC_SetPriority(TIMER0_IRQn, 0);\n\t\t\tNVIC_EnableIRQ(TIMER0_IRQn);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\tNVIC_SetPriority(TIMER1_IRQn, 0);\n\t\t\tNVIC_EnableIRQ(TIMER1_IRQn);\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 49.241429040838774}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt == false) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\tHAL_timer_attachInterrupt(timer_num, Step_Handler);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\tHAL_timer_attachInterrupt(timer_num, Temp_Handler);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 46.73785853230393}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\tvar hash, hashSep, pow uint32\n\thash, pow = HashStrRev(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif hash == hashSep {\n\t\t\tif s[i:i+len(sep)] == sep {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\tif i+len(sep) < len(s) {\n\t\t\thash = hash*PrimeRK + uint32(s[i+len(sep)]) - pow*uint32(s[i])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 39.67453089995767}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(s) == 0 || len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\tfor i := len(s) - 1; i >= 0; i-- {\n\t\t\tif sep[0] == s[i] {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\thash, pow := HashStrRev(sep)\n\tvar h uint32\n\tfor i := len(sep) - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hash {\n\t\tif string(s[len(s)-len(sep):]) == sep {\n\t\t\treturn len(s) - len(sep)\n\t\t}\n\t}\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= uint32(s[i+len(sep)]) * pow\n\t\tif h == hash {\n\t\t\tif string(s[i:i+len(sep)]) == sep {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 55.78019452417298}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\tvar (\n\t\tsepLen = len(sep)\n\t\tsepRev = Reverse[T](sep)\n\t\thash, pow = HashStrRev(sep)\n\t\thashRev, powRev = HashStrRev(sepRev)\n\t\thashS, powS = HashStrRev(s[:sepLen])\n\t\thashSRev, powSRev = HashStrRev(Reverse[T](s[:sepLen]))\n\t)\n\tfor i := sepLen; i <= len(s); i++ {\n\t\tif hash == hashS && hashRev == hashSRev {\n\t\t\tif string(s[i-sepLen:i]) == sep {\n\t\t\t\treturn i - sepLen\n\t\t\t}\n\t\t}\n\t\tif i < len(s) {\n\t\t\thashS = (hashS - powS*uint32(s[i-sepLen]))*PrimeRK + uint32(s[i])\n\t\t\thashSRev = (hashSRev - powSRev*uint32(s[i-sepLen]))*PrimeRK + uint32(s[i])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 32.83607974054892}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.txBuffer.Flush()\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tusbcdc.waitTxc = false\n\tinterrupt.Restore()\n}", "CodeBleu_score": 40.280959809500004}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.waitTxc = false\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txBuffer.Get())\n\t}\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.waitTxc = true\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 33.56209145663768}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.txBuffer.Flush()\n\tif usbcdc.waitTxc {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tusbcdc.waitTxc = false\n\tinterrupt.Restore(usbcdc.interruptMask)\n}", "CodeBleu_score": 33.498773222846765}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.SetBits(i2c.crReg.Clear)\n\ti2c.crReg.SetBits(i2c.crReg.Start)\n\ti2c.crReg.SetBits(i2c.crReg.Enable)\n\tfor!i2c.crReg.HasBits(i2c.crReg.Start) {\n\t}\n\ti2c.writeByte(address << 1)\n}", "CodeBleu_score": 34.00102331771591}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(I2C_CR_START)\n\tfor i2c.crReg.HasBits(I2C_CR_START) {\n\t}\n\ti2c.writeByte(address << 1 | uint8(write))\n}", "CodeBleu_score": 32.361150373779935}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.HasBits(i2c.crReg.Interrupt))\n\ti2c.crReg.SetBits(i2c.crReg.HasBits(i2c.crReg.Start))\n\ti2c.crReg.SetBits(i2c.crReg.HasBits(i2c.crReg.Enable))\n\n\tfor!i2c.crReg.HasBits(i2c.crReg.Interrupt) {\n\t}\n\n\ti2c.crReg.ClearBits(i2c.crReg.HasBits(i2c.crReg.Interrupt))\n\n\tif write {\n\t\ti2c.writeByte(address << 1)\n\t} else {\n\t\ti2c.writeByte((address << 1) | 0x01)\n\t}\n}", "CodeBleu_score": 32.01597346523266}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size\n\tstartAddr := start*int64(f.EraseBlockSize) + f.FlashDataStart\n\n\t// Configure the flash for erasing\n\tnrf.NVMC.SetCONFIG_WEN.Set()\n\n\t// Erase each block in the range\n\tfor i := start; i < start+len; i++ {\n\t\t// Calculate the start address of the block\n\t\tblockStartAddr := i*int64(f.EraseBlockSize) + f.FlashDataStart\n\n\t\t// Erase the block\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(blockStartAddr))\n\n\t\t// Wait until the flash is no longer busy\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// Set the flash back to read mode\n\tnrf.NVMC.SetCONFIG_WEN.Clear()\n\n\treturn nil\n}", "CodeBleu_score": 57.586232302632325}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"invalid block number\")\n\t}\n\tif start+len > f.NumBlocks() {\n\t\treturn errors.New(\"block number out of range\")\n\t}\n\tif f.EraseBlockSize > 0 {\n\t\t// Erase blocks in the flash memory.\n\t\tfor i := start; i < start+len; i++ {\n\t\t\t// Calculate the start address of the block.\n\t\t\tstartAddr := f.FlashDataStart + f.EraseBlockSize*i\n\t\t\t// Wait for any ongoing flash operations to complete.\n\t\t\tf.waitWhileFlashBusy()\n\t\t\t// Configure the flash for erasing.\n\t\t\tf.nrf.NVMC.SetCONFIG_WEN()\n\t\t\t// Erase the block.\n\t\t\tf.nrf.NVMC.ERASEPAGE.Set(uint32(startAddr))\n\t\t\t// Wait for the flash to become ready.\n\t\t\tf.waitWhileFlashBusy()\n\t\t}\n\t\t// Set the flash back to read mode.\n\t\tf.nrf.NVMC.SetCONFIG_WEN()\n\t\treturn nil\n\t}\n\treturn errors.New(\"flash block size is zero\")\n}", "CodeBleu_score": 50.82795395994834}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tf.EraseBlockSize = f.EraseBlockSize\n\tFlashDataStart = nrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tnrf.NVMC.ERASEPAGE.Set\n\tuint32\n\tuintptr\n\treturn nil\n}", "CodeBleu_score": 23.654699438619506}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds\n\tif off+int64(len(p)) > f.FlashDataEnd {\n\t\treturn 0, errors.New(\"write operation exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddr := f.FlashDataStart + off\n\n\t// Pad the byte slice to fit the write block size\n\tpaddedData := pad(p, f.WriteBlockSize)\n\n\t// Enable write mode on the flash memory controller\n\tf.NVMC.SetCONFIG_WEN()\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(paddedData); i += int(f.WriteBlockSize) {\n\t\t// Write a block of data\n\t\tf.NVMC.SetERASE_PAGE(uint32(startAddr))\n\t\tf.NVMC.SetWRITE_PAGE(uint32(startAddr), paddedData[i:i+int(f.WriteBlockSize)])\n\n\t\t// Wait for the flash memory to be ready after each write operation\n\t\tfor!f.NVMC.READY.HasBits(nrf.NVMC_READY_READY_Ready) {\n\t\t}\n\n\t\t// Increment the number of bytes written\n\t\tn += int(f.WriteBlockSize)\n\n\t\t// Increment the start address for the next block\n\t\tstartAddr += int64(f.WriteBlockSize)\n\t}\n\n\t// Return the number of bytes written\n\treturn n, nil\n}", "CodeBleu_score": 32.14867645670644}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor\n\tnewFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory\n\tvar dir *syscall.Dir\n\tfor {\n\t\tdir, err = syscall.Fdopendir(newFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif err!= syscall.EINTR {\n\t\t\t// Close the duplicated file descriptor\n\t\t\tsyscall.Close(newFd)\n\n\t\t\t// Return the error\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\n\t// Return the directory pointer\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 61.383237563134465}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// First, duplicate the provided file descriptor.\n\tdupFd, err := syscall.Dup(fd)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(dupFd)\n\n\t// Then, repeatedly attempt to open the directory using syscall.Fdopendir until it either succeeds or encounters an error other than syscall.EINTR.\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 55.72198800933463}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Attempt to open the directory using syscall.Fdopendir.\n\tdirPtr, err := syscall.Fdopendir(dupFd)\n\tif err == nil {\n\t\t// If the directory was successfully opened, return the directory pointer.\n\t\treturn uintptr(dirPtr), \"\", nil\n\t}\n\t// If the error is not \"syscall.EINTR\", close the duplicated file descriptor and return the error.\n\tif err!= syscall.EINTR {\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"\", err\n\t}\n\t// If the error is \"syscall.EINTR\", repeatedly attempt to open the directory using syscall.Fdopendir until it succeeds or encounters an error other than \"syscall.EINTR\".\n\tfor {\n\t\tdirPtr, err = syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\t// If the directory was successfully opened, return the directory pointer.\n\t\t\treturn uintptr(dirPtr), \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\t// If the error is not \"syscall.EINTR\", close the duplicated file descriptor and return the error.\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 52.7705648948021}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t size = 0;\n\tif (response) {\n\t\tesp_partition_t* partition = esp_ota_get_running_partition();\n\t\tif (partition) {\n\t\t\tsize = partition->size - partition->address;\n\t\t}\n\t} else {\n\t\tesp_partition_t* partition = esp_ota_get_running_partition();\n\t\tif (partition) {\n\t\t\tesp_image_metadata_t metadata;\n\t\t\tif (esp_image_metadata_load(partition->address, &metadata)) {\n\t\t\t\tsize = metadata.size;\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}", "CodeBleu_score": 44.905767101956314}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tesp_partition_pos_t *info = (esp_partition_pos_t *) malloc(sizeof(esp_partition_pos_t));\n\tesp_image_metadata_t *meta = (esp_image_metadata_t *) malloc(sizeof(esp_image_metadata_t));\n\tuint32_t size = 0;\n\tif (esp_image_verify_meta(running, info, meta) == ESP_OK) {\n\t\tif (response) {\n\t\t\tsize = info->size - meta->size;\n\t\t} else {\n\t\t\tsize = meta->size;\n\t\t}\n\t}\n\tfree(info);\n\tfree(meta);\n\treturn size;\n}", "CodeBleu_score": 40.44695007535272}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t freeSketchSpace = 0;\n\tesp_partition_t *running = esp_ota_get_running_partition();\n\tesp_app_desc_t running_app_info;\n\tif (esp_ota_get_partition_description(running, &running_app_info) == ESP_OK) {\n\t\tif (response) {\n\t\t\tfreeSketchSpace = running_app_info.app_free;\n\t\t} else {\n\t\t\tfreeSketchSpace = running_app_info.app_size;\n\t\t}\n\t}\n\treturn freeSketchSpace;\n}", "CodeBleu_score": 42.77303951760345}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGD(TAG, \"msc_update_write\");\n\tesp_err_t ret = ESP_OK;\n\tif (offset % partition->erase_size == 0) {\n\t\tESP_LOGD(TAG, \"msc_update_write: offset %d is aligned with sector size %d, erasing sector\", offset, partition->erase_size);\n\t\tret = esp_partition_erase_range(partition, offset, partition->erase_size);\n\t\tif (ret!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"msc_update_write: failed to erase sector, error code %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tESP_LOGD(TAG, \"msc_update_write: writing %d bytes to offset %d\", size, offset);\n\tret = esp_partition_write(partition, offset, data, size);\n\tif (ret!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"msc_update_write: failed to write data, error code %d\", ret);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 45.00602296531323}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGD(TAG, \"msc_update_write\");\n\tif (offset % partition->block_size!= 0) {\n\t\tESP_LOGE(TAG, \"msc_update_write: offset not aligned with partition block size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = ESP_OK;\n\tif (partition->size > offset + size) {\n\t\tESP_LOGD(TAG, \"msc_update_write: erasing sector at offset %d\", offset);\n\t\terr = esp_partition_erase_range(partition, offset, partition->block_size);\n\t\tif (err!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"msc_update_write: error erasing sector at offset %d\", offset);\n\t\t\treturn err;\n\t\t}\n\t}\n\tESP_LOGD(TAG, \"msc_update_write: writing data to offset %d\", offset);\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"msc_update_write: error writing data to offset %d\", offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 48.91900304977668}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGD(TAG, \"msc_update_write: partition=%p, offset=%d, size=%d\", partition, offset, size);\n\tif (offset % partition->block_size!= 0) {\n\t\tESP_LOGE(TAG, \"msc_update_write: offset is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"msc_update_write: esp_partition_erase_range failed, err=%d\", err);\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"msc_update_write: esp_partition_write failed, err=%d\", err);\n\t}\n\treturn err;\n}", "CodeBleu_score": 49.343491243590734}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tsize_t j = 0;\n\twhile (in[i]!= '\\0' && j < maxlen) {\n\t\tuint8_t c = hex_char_to_byte(in[i]);\n\t\tif (c < 0x10) {\n\t\t\tout[j] = c;\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\treturn j;\n}", "CodeBleu_score": 33.81266536603466}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tsize_t j = 0;\n\tuint8_t byte;\n\twhile (in[i] && j < maxlen) {\n\t\tbyte = hex_char_to_byte(in[i]);\n\t\tif (byte!= 0x10) {\n\t\t\tout[j++] = byte << 4;\n\t\t\tif (in[i + 1]) {\n\t\t\t\tbyte = hex_char_to_byte(in[i + 1]);\n\t\t\t\tif (byte!= 0x10) {\n\t\t\t\t\tout[j++] |= byte;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti += 2;\n\t}\n\treturn j;\n}", "CodeBleu_score": 43.12850537253835}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tsize_t len = strlen(in);\n\tsize_t out_len = 0;\n\tuint8_t byte;\n\twhile (i < len && out_len < maxlen) {\n\t\tif (in[i] =='') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tbyte = hex_char_to_byte(in[i]);\n\t\tif (byte > 0x0f) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (out_len % 2 == 0) {\n\t\t\tout[out_len / 2] = byte << 4;\n\t\t} else {\n\t\t\tout[out_len / 2] |= byte;\n\t\t}\n\t\ti++;\n\t\tout_len++;\n\t}\n\treturn out_len;\n}", "CodeBleu_score": 46.829955809091594}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (xRingbuffer!= NULL && xSemaphoreTake(xRingbufferLock, (TickType_t) 10) == pdTRUE) {\n\t\tuint32_t freeSize = xRingbufferGetCurFreeSize(xRingbuffer);\n\t\txSemaphoreGive(xRingbufferLock);\n\t\treturn freeSize;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 47.50367319683425}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (xRingbuffer == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(xRingbufferSemaphore, (portTickType) 5) == pdTRUE) {\n\t\tuint32_t freeSize = xRingbufferGetCurFreeSize(xRingbuffer);\n\t\txSemaphoreGive(xRingbufferSemaphore);\n\t\treturn freeSize;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 55.86733190507546}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buffer == NULL || tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, 1000) == pdTRUE) {\n\t\tint free_size = xRingbufferGetCurFreeSize(tx_ring_buffer);\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free_size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 70.84810853608201}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tlog_d(\"HardwareSerial::onReceive\");\n  HSERIAL_MUTEX_LOCK\n  if (function) {\n    _onReceiveCB = function;\n    _rxTimeout = onlyOnTimeout? _rxTimeout : 0;\n    if (_rxTimeout) {\n      _rxTimeout = millis() + _rxTimeout;\n    }\n  }\n  if (_onReceiveCB) {\n    _rxFIFO.setThreshold(FIFO_RX_FULL);\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 49.4400176252093}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if defined(ARDUINO_ARCH_ESP32)\n  if (onlyOnTimeout) {\n    _rxTimeout = 1000;\n  } else {\n    _rxTimeout = 0;\n  }\n#endif\n\n  // Lock the serial mutex\n  HSERIAL_MUTEX_LOCK;\n\n  // Assign the callback function to _onReceiveCB\n  _onReceiveCB = function;\n\n  // Configure the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n  if (onlyOnTimeout) {\n    _rxTimeout = 1000;\n  } else {\n    _rxTimeout = 0;\n  }\n\n  // If the callback is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n  if (_onReceiveCB!= NULL) {\n    _rxFIFOFullThreshold = 1;\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  }\n\n  // Unlock the serial mutex\n  HSERIAL_MUTEX_UNLOCK;\n}", "CodeBleu_score": 46.03048154230265}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#ifdef ARDUINO_ARCH_ESP32\n  if (onlyOnTimeout) {\n    _rxTimeout = 1;\n  } else {\n    _rxTimeout = 0;\n  }\n#endif\n  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  if (_onReceiveCB) {\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n    _uart.rx.full_thresh = UART_FIFO_FULL_THRESHOLD;\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 42.18299314080024}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t n = 0;\n\tint c;\n\twhile (n < length) {\n\t\tc = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\tn++;\n\t}\n\t*buffer = 0;\n\treturn n;\n}", "CodeBleu_score": 58.311265932358644}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t n = 0;\n\twhile (n < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tn++;\n\t}\n\t*buffer = 0;\n\treturn n;\n}", "CodeBleu_score": 58.313742048674364}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t n = 0;\n\twhile (n < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\tn++;\n\t}\n\t*buffer = '\\0';\n\treturn n;\n}", "CodeBleu_score": 61.37795255269797}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin == 0) {\n\t\tlog_e(\"Invalid pin\");\n\t\treturn;\n\t}\n\tif (frequency == 0) {\n\t\tlog_e(\"Invalid frequency\");\n\t\treturn;\n\t}\n\tif (duration == 0) {\n\t\tlog_e(\"Invalid duration\");\n\t\treturn;\n\t}\n\tif (tone_init() == 0) {\n\t\tlog_e(\"Could not initialize tone\");\n\t\treturn;\n\t}\n\tif (tone_is_pin_available(pin)) {\n\t\tlog_v(\"Pin %d is available\", pin);\n\t\ttone_msg_t msg;\n\t\tmsg.pin = pin;\n\t\tmsg.frequency = frequency;\n\t\tmsg.duration = duration;\n\t\tif (xQueueSend(_tone_queue, &msg, 0) == pdTRUE) {\n\t\t\tlog_v(\"Tone message sent to queue\");\n\t\t} else {\n\t\t\tlog_e(\"Could not send tone message to queue\");\n\t\t}\n\t} else {\n\t\tlog_e(\"Pin %d is already in use\", pin);\n\t}\n}", "CodeBleu_score": 44.29545277592427}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_v(\"tone\");\n\tlog_d(\"pin: %d\", pin);\n\tlog_d(\"frequency: %d\", frequency);\n\tlog_d(\"duration: %d\", duration);\n\n\tif (pin_is_available(pin)) {\n\t\ttone_msg_t tone_msg;\n\t\ttone_msg.pin = pin;\n\t\ttone_msg.frequency = frequency;\n\t\ttone_msg.duration = duration;\n\t\ttone_msg.command = TONE_START;\n\t\ttone_msg.state = TONE_STOPPED;\n\t\ttone_msg.duration_remaining = 0;\n\t\ttone_msg.frequency_remaining = 0;\n\t\ttone_msg.pin_state = 0;\n\t\ttone_msg.pin_state_remaining = 0;\n\n\t\tlog_d(\"tone_msg.pin: %d\", tone_msg.pin);\n\t\tlog_d(\"tone_msg.frequency: %d\", tone_msg.frequency);\n\t\tlog_d(\"tone_msg.duration: %d\", tone_msg.duration);\n\t\tlog_d(\"tone_msg.command: %d\", tone_msg.command);\n\t\tlog_d(\"tone_msg.state: %d\", tone_msg.state);\n\t\tlog_d(\"tone_msg.duration_remaining: %d\", tone_msg.duration_remaining);\n\t\tlog_d(\"tone_msg.frequency_remaining: %d\", tone_msg.frequency_remaining);\n\t\tlog_d(\"tone_msg.pin_state: %d\", tone_msg.pin_state);\n\t\tlog_d(\"tone_msg.pin_state_remaining: %d\", tone_msg.pin_state_remaining);\n\n\t\txQueueSend(_tone_queue, &tone_msg, 0);\n\t} else {\n\t\tlog_e(\"Pin %d is in use\", pin);\n\t}\n}", "CodeBleu_score": 32.839170467753185}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_v(\"tone: pin: %d, frequency: %d, duration: %d\", pin, frequency, duration);\n\tif (pin_is_available(pin)) {\n\t\tlog_v(\"tone: pin is available\");\n\t\ttone_msg_t tone_msg;\n\t\ttone_msg.pin = pin;\n\t\ttone_msg.frequency = frequency;\n\t\ttone_msg.duration = duration;\n\t\ttone_msg.cmd = TONE_START;\n\t\tif (xQueueSend(_tone_queue, &tone_msg, 0) == pdPASS) {\n\t\t\tlog_v(\"tone: tone_queue sent\");\n\t\t} else {\n\t\t\tlog_e(\"tone: tone_queue send failed\");\n\t\t}\n\t} else {\n\t\tlog_e(\"tone: pin is in use\");\n\t}\n}", "CodeBleu_score": 45.88403586861266}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (webUSBEnabled) {\n\t\t\treturn false;\n\t\t}\n\t\tif (USB_start() && (USB_version() >= 0x0210)) {\n\t\t\twebUSBEnabled = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\twebUSBEnabled = false;\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 27.450081096239693}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!started) {\n\t\twebUSBEnabled = enabled;\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (version < 0x0210) {\n\t\t\treturn false;\n\t\t}\n\t}\n\twebUSBEnabled = enabled;\n\treturn false;\n}", "CodeBleu_score": 42.56075761845091}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!enabled) {\n\t\twebUSBEnabled = false;\n\t\treturn false;\n\t}\n\tif (!usbStarted) {\n\t\twebUSBEnabled = true;\n\t\treturn true;\n\t}\n\tif (usbVersion < 0x0210) {\n\t\treturn true;\n\t}\n\twebUSBEnabled = true;\n\treturn false;\n}", "CodeBleu_score": 33.47932095836241}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t data[64];\n\tsize_t len = 0;\n\twhile (true) {\n\t\tlen = tud_cdc_n_read(data, sizeof(data));\n\t\tif (len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (xQueueSend(_rxQueue, data, len)!= pdPASS) {\n\t\t\t_log_e(\"RX queue full\");\n\t\t\t_event_post(USB_EVENT_RX_OVERFLOW, len);\n\t\t} else {\n\t\t\t_event_post(USB_EVENT_RX, len);\n\t\t}\n\t}\n}", "CodeBleu_score": 17.887217937068684}, {"code": "void USBCDC::_onRX(){\n\t\t// Read data into buffer\n\tuint8_t* buffer = _rx_buffer;\n\tint count = 0;\n\twhile (count < _rx_buffer_size) {\n\t\tint read = _cdc_n_read(buffer, _rx_buffer_size - count);\n\t\tif (read < 0) {\n\t\t\t// Error occurred, stop reading\n\t\t\tbreak;\n\t\t}\n\t\tcount += read;\n\t\tbuffer += read;\n\t}\n\n\t// Post receive event\n\tif (count > 0) {\n\t\t// Post receive event\n\t\tUSBEvent event;\n\t\tevent.type = USB_EVENT_RX;\n\t\tevent.data.rx.length = count;\n\t\t_event_post(event);\n\t}\n\n\t// Post overflow event\n\tif (count < _rx_buffer_size) {\n\t\t// Post overflow event\n\t\tUSBEvent event;\n\t\tevent.type = USB_EVENT_RX_OVERFLOW;\n\t\tevent.data.rx_overflow.length = _rx_buffer_size - count;\n\t\t_event_post(event);\n\t}\n}", "CodeBleu_score": 29.859609587739993}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t rx_buf[64];\n\tuint8_t rx_len;\n\tuint8_t rx_dropped;\n\n\t// Read data from the USB CDC device\n\trx_len = tud_cdc_n_read(rx_buf, sizeof(rx_buf));\n\n\t// If data was read, attempt to send to the receive queue\n\tif (rx_len) {\n\t\t// If the queue is full, post an overflow event with the number of dropped bytes\n\t\tif (!xQueueSend(this->rx_queue, rx_buf, 0)) {\n\t\t\trx_dropped = xQueueSend(this->rx_queue, rx_buf, 0);\n\t\t\tthis->log_e(F(\"USB CDC: RX queue overflow, dropped %d bytes\"), rx_dropped);\n\t\t}\n\n\t\t// Post a receive event with the length of the received data\n\t\tthis->event_post(USB_CDC_EVENT_RX, rx_len);\n\t}\n}", "CodeBleu_score": 18.623063106107246}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\trobotName := req.URL.Query().Get(\"name\")\n\tif robotName == \"\" {\n\t\ta.writeJSON(res, gobot.NewJSONResponse(\"error\", \"Robot name is required\"))\n\t\treturn\n\t}\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, gobot.NewJSONResponse(\"error\", \"No robot found with the given name\"))\n\t\treturn\n\t}\n\tdevices := make([]interface{}, 0)\n\trobot.Devices().Each(func(key string, device gobot.Device) {\n\t\tdevices = append(devices, device.JSON())\n\t})\n\ta.writeJSON(res, gobot.NewJSONResponse(\"success\", devices))\n}", "CodeBleu_score": 49.78078727082664}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": fmt.Sprintf(\"No robot with name %s\", robotName)})\n\t\treturn\n\t}\n\ta.writeJSON(res, robot.Devices())\n}", "CodeBleu_score": 30.384916122604867}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, gobot.NewJSONResponse(http.StatusBadRequest, \"no name specified\"))\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, gobot.NewJSONResponse(http.StatusNotFound, \"no robot found with name: \"+name))\n\t\treturn\n\t}\n\ta.writeJSON(res, gobot.NewJSONResponse(http.StatusOK, robot.Devices()))\n}", "CodeBleu_score": 35.926669011895}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := req.URL.Query().Get(\"robot\")\n\n\t// Check if the robot exists\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\t// Write an error message to the HTTP response indicating that no robot with the specified name was found\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]interface{}{\n\t\t\t\"error\": \"Robot not found\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Iterate through the connections of the robot and convert them to JSON format\n\tconnections := []map[string]interface{}{}\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, connection.JSON())\n\t})\n\n\t// Write the connections to the HTTP response\n\ta.writeJSON(res, http.StatusOK, map[string]interface{}{\n\t\t\"connections\": connections,\n\t})\n}", "CodeBleu_score": 55.76431301986923}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/v1/robots/\")\n\n\t// Check if the robot exists.\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Robot %s not found\", robotName)))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format.\n\tvar connections []gobot.JSONConnection\n\trobot.Connections().Each(func(key interface{}, value interface{}) {\n\t\tconnection := value.(gobot.JSONConnection)\n\t\tconnections = append(connections, connection)\n\t})\n\n\t// Write the connections to the HTTP response.\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 43.827186220945244}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/v1/robots/\")\n\t// Check if the robot exists\n\trobot, exists := a.master.Robot(robotName)\n\tif!exists {\n\t\t// If the robot does not exist, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot with name %s found\", robotName)))\n\t\treturn\n\t}\n\t// Iterate through the connections of the robot and convert them to JSON format\n\tconnections := robot.Connections().Map(func(key, value interface{}) interface{} {\n\t\treturn gobot.NewJSONConnection(key.(string), value.(gobot.Connection))\n\t})\n\t// Write the JSON-encoded connections to the HTTP response\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 30.72187479328304}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tdevice, err := a.master.Robot(robotName).Device(deviceName)\n\tif err!= nil {\n\t\ta.writeJSON(res, err.Error())\n\t\treturn\n\t}\n\tcommand := req.URL.Query().Get(\":command\")\n\terr = device.(gobot.Commander).Command(command)\n\tif err!= nil {\n\t\ta.writeJSON(res, err.Error())\n\t\treturn\n\t}\n\ta.writeJSON(res, \"OK\")\n}", "CodeBleu_score": 54.750423701439544}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\tif robot == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, gobot.ErrRobotName)\n\t\treturn\n\t}\n\tif device == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, gobot.ErrDeviceName)\n\t\treturn\n\t}\n\tif _, ok := a.master.Robot(robot).Device(device);!ok {\n\t\ta.writeJSON(res, http.StatusNotFound, gobot.ErrDeviceNotFound)\n\t\treturn\n\t}\n\tcommand := req.URL.Query().Get(\":command\")\n\tif command == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, gobot.ErrCommandName)\n\t\treturn\n\t}\n\terr := a.master.Robot(robot).Device(device).(gobot.Commander).Command(command)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, err)\n\t\treturn\n\t}\n\ta.writeJSON(res, http.StatusOK, nil)\n}", "CodeBleu_score": 46.455464833976926}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tdevice, err := a.master.Robot(robotName).Device(deviceName)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusBadRequest, err.Error())\n\t\treturn\n\t}\n\tcommand := req.URL.Query().Get(\":command\")\n\tif err := device.(gobot.Commander).Command(command); err!= nil {\n\t\ta.writeJSON(res, http.StatusBadRequest, err.Error())\n\t\treturn\n\t}\n\ta.writeJSON(res, http.StatusOK, \"Command executed successfully\")\n}", "CodeBleu_score": 51.035871653575086}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s)!= 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair)!= 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif pair[0]!= username || pair[1]!= password {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If we made it here, the credentials were correct.\n\t\t// So we call the next handler in the chain.\n\t\thttp.HandlerFunc(http.DefaultServeMux.ServeHTTP).ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.0708533565394}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\t// Get the Basic Authentication credentials\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Invalid authentication\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the credentials\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\t// Check if the credentials are valid\n\t\tif len(pair) == 2 && pair[0] == username && pair[1] == password {\n\t\t\t// Handle the request if the credentials are valid\n\t\t\t//...\n\t\t} else {\n\t\t\t// Return an error if the credentials are invalid\n\t\t\thttp.Error(w, \"Invalid authentication\", http.StatusUnauthorized)\n\t\t}\n\t}\n}", "CodeBleu_score": 53.225248826139016}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s)!= 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Delegate request to the given next handler.\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 49.834077062078926}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\t// Read the raw sensor value\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, fmt.Errorf(\"failed to read analog sensor: %w\", err)\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\t// Update the last read values\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 46.04007283200217}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tvar (\n\t\trawValue int\n\t\tscaledValue float64\n\t\terr error\n\t)\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection().AnalogRead == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog reading is not supported by the connection\")\n\t}\n\trawValue, err = a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue = a.sensorCfg.scale * float64(rawValue)\n\ta.sensorCfg.lastRawValue = rawValue\n\ta.sensorCfg.lastScaledValue = scaledValue\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 50.39612828578958}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading.\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection supports analog reading.\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn -1, -1, fmt.Errorf(\"the connection does not support analog reading\")\n\t}\n\n\t// Read the raw value from the sensor.\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn -1, -1, fmt.Errorf(\"failed to read analog value: %w\", err)\n\t}\n\n\t// Scale the raw value according to the sensor's configuration.\n\tscaled := a.scale(raw)\n\n\t// Update the last read values.\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\t// Return the raw and scaled values.\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 42.48068310674283}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{AnalogSensorDriver{AnalogReader: a, Pin: pin}}\n\tfor _, opt := range opts {\n\t\topt(d)\n\t}\n\td.Name = DefaultName\n\treturn d\n}", "CodeBleu_score": 33.56389663439271}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t// create a new GroveSoundSensorDriver\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\t// assign a default name\n\td.SetName(DefaultName)\n\t// return the driver\n\treturn d\n}", "CodeBleu_score": 21.597155795721935}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(\"GroveSoundSensorDriver\")\n\treturn d\n}", "CodeBleu_score": 26.991515325382032}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Soft reset\n\tif err := d.writeByteData(CommandReg, SoftReset); err!= nil {\n\t\treturn err\n\t}\n\t// The datasheet says 1000ms, but 100ms works better for me.\n\ttime.Sleep(100 * time.Millisecond)\n\t// Check if the device has finished the reset\n\tif err := d.readByteData(CommandReg); err!= nil {\n\t\treturn err\n\t}\n\t// Wait for the chip to be ready\n\ttime.Sleep(10 * time.Millisecond)\n\treturn nil\n}", "CodeBleu_score": 55.66264080575948}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tstatus, err := d.readByteData(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif (status & 0x1B)!= 0x00 {\n\t\treturn errors.New(\"MFRC522: Power-down mode not active\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 49.87868480037342}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Soft reset\n\td.writeByteData(CommandReg, SoftReset)\n\t// The datasheet does not specify the required delay, but 10 ms seems to work.\n\ttime.Sleep(10 * time.Millisecond)\n\t// Check if the soft reset was successful\n\tif (d.readByteData(CommandReg) & SoftReset)!= 0 {\n\t\treturn fmt.Errorf(\"failed to perform soft reset\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.035995781816936}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Get the number of bytes in the FIFO buffer\n\tfifoLength, err := d.getFifoLength()\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\t// Check the length of the byte slice\n\tif fifoLength!= uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO length %d does not match expected length %d\", fifoLength, len(backData))\n\t}\n\t// Read each byte from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(fifoReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.readByteData(controlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 55.16167189234944}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check if FIFO buffer is empty\n\tif err := d.isBitSet(MFRC522_Reg_FIFOLevel, MFRC522_Bit_FIFOLevel_Empty); err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Read FIFO buffer from MFRC522\n\tnumBytes, err := d.readFifoLength()\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\tif len(backData) < numBytes {\n\t\treturn 0, fmt.Errorf(\"expected %d bytes, but only %d bytes available\", len(backData), numBytes)\n\t}\n\n\tif err := d.read(MFRC522_Reg_FIFOData, backData); err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Read control register to get last bits received\n\treturn d.readControlRegister()\n}", "CodeBleu_score": 38.89467248944026}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check if FIFO buffer is empty\n\tif d.readRegister(FIFOLevelReg) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Check if FIFO buffer is full\n\tif d.readRegister(FIFOLevelReg)!= uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO buffer is not full\")\n\t}\n\n\t// Read FIFO buffer\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readRegister(FIFODataReg)\n\t}\n\n\t// Read control register\n\treturn d.readRegister(ControlReg), nil\n}", "CodeBleu_score": 28.658453701887098}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.Debug {\n\t\tfmt.Printf(\"piccHalt\n\")\n\t}\n\t// Build command buffer\n\tcmd := make([]byte, 4)\n\tcmd[0] = PICC_CMD_HALT\n\tcmd[1] = 0\n\tcmd[2] = 0\n\tcmd[3] = 0\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\tcmd = append(cmd, crc...)\n\t// Send the command.\n\tstatus, err := d.communicateWithPICC(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status!= STATUS_OK {\n\t\treturn fmt.Errorf(\"piccHalt: STATUS_OK\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 33.1368170239599}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.Debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\tcmd := []byte{0x50, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tcrc := d.calculateCRC(cmd)\n\tcmd = append(cmd, crc...)\n\terr := d.sendCommand(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.389287096032795}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halt\")\n\t}\n\tcommand := []byte{PICC_HALT}\n\tcommand = append(command, d.calculateCRC(command))\n\tstatus, err := d.communicateWithPICC(command)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status!= STATUS_OK {\n\t\treturn fmt.Errorf(\"Halt failed: %d\", status)\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.636684092797644}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the command buffer\n\tbuffer := make([]byte, 9)\n\t// Construct the command\n\tbuffer[0] = PICC_CMD_MF_READ\n\tbuffer[1] = block\n\t// Calculate the CRC\n\td.calculateCRC(buffer)\n\t// Send the command\n\terr := d.communicateWithPICC(buffer)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Read the data\n\tdata := make([]byte, 16)\n\terr = d.communicateWithPICC(data)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}", "CodeBleu_score": 32.65946563596559}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar\n\tbuffer\n\tbuffer\n\t=\n\tappend(buffer, d.PICC_CMD_MF_READ)\n\tbuffer\n\t=\n\tappend(buffer, block)\n\tcrc, err := d.calculateCRC(buffer)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tbuffer\n\t=\n\tappend(buffer, crc...)\n\treturn d.communicateWithPICC(buffer)\n}", "CodeBleu_score": 30.673840143314358}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar (\n\t\tstatus  uint8\n\t\tbuffer  [18]byte\n\t\treadLen uint8\n\t)\n\t// Prepare the read command\n\tbuffer[0] = PICC_CMD_MF_READ\n\tbuffer[1] = block\n\t// Calculate the CRC\n\tstatus = d.calculateCRC(buffer[:2])\n\tif status!= STATUS_OK {\n\t\treturn nil, fmt.Errorf(\"calculateCRC failed: %d\", status)\n\t}\n\t// Copy the CRC\n\tbuffer[2] = buffer[6]\n\tbuffer[3] = buffer[7]\n\t// Transmit the read command\n\tstatus = d.communicateWithPICC(buffer[:4])\n\tif status!= STATUS_OK {\n\t\treturn nil, fmt.Errorf(\"communicateWithPICC failed: %d\", status)\n\t}\n\t// Read the data\n\treadLen = 0\n\tfor readLen < 16 {\n\t\tstatus = d.readRegister(FIFOLevelReg)\n\t\tif status!= STATUS_OK {\n\t\t\treturn nil, fmt.Errorf(\"readRegister failed: %d\", status)\n\t\t}\n\t\t// Check for the end of the FIFO buffer\n\t\tif d.readRegister(FIFOLevelReg) == 0 {\n\t\t\tbreak\n\t\t}\n\t\t// Read the data from the FIFO buffer\n\t\tstatus = d.readRegister(FIFODataReg, buffer[readLen:readLen+1])\n\t\tif status!= STATUS_OK {\n\t\t\treturn nil, fmt.Errorf(\"readRegister failed: %d\", status)\n\t\t}\n\t\treadLen++\n\t}\n\t// Check for errors\n\tif status!= STATUS_OK {\n\t\treturn nil, fmt.Errorf(\"readRegister failed: %d\", status)\n\t}\n\t// Check for data overflow\n\tif readLen > 16 {\n\t\treturn nil, fmt.Errorf(\"read overflow\")\n\t}\n\t// Copy the data to the output buffer\n\treturn buffer[:readLen], nil\n}", "CodeBleu_score": 21.19637215782998}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t", "CodeBleu_score": 3.6650973421215025}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// 1. Clear the bit registers\n\td.clearRegisterBitMask(CollReg, 0x80)\n\td.clearRegisterBitMask(DivIrqReg, 0x04)\n\td.clearRegisterBitMask(FIFOLevelReg, 0x80)\n\td.clearRegisterBitMask(ErrorReg, 0x1B)\n\td.clearRegisterBitMask(Status2Reg, 0x08)\n\n\t// 2. Determine the number of bytes to send to the PICC\n\tvar sendData [16]byte\n\tvar sendLen uint8\n\tvar recLen uint8\n\tvar validBits uint8\n\n\t// 3. Transmit the data\n\tif reqMode == PICC_CMD_REQA {\n\t\tsendData[0] = reqMode\n\t\tsendLen = 2\n\t\trecLen = 2\n\t\tvalidBits = 0\n\t} else if reqMode == PICC_CMD_REQB {\n\t\tsendData[0] = reqMode\n\t\tsendLen = 1\n\t\trecLen = 1\n\t\tvalidBits = 0\n\t} else {\n\t\treturn fmt.Errorf(\"invalid request mode\")\n\t}\n\n\tif err := d.communicateWithPICC(sendData[:sendLen], answer[:recLen], &validBits); err!= nil {\n\t\treturn err\n\t}\n\n\t// 4. Check for error\n\tif recLen!= 1 || validBits!= 0 {\n\t\treturn fmt.Errorf(\"error in communication\")\n\t}\n\n\t// 5. Check for collision\n\tif (answer[0] & 0x08) == 0x08 {\n\t\treturn fmt.Errorf(\"collision detected\")\n\t}\n\n\t// 6. Check for PICC response\n\tif answer[0]!= reqMode {\n\t\treturn fmt.Errorf(\"invalid response\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 40.80169498138849}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check for correct answer buffer size\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Invalid answer buffer size\")\n\t}\n\n\t// Clear all bits in the collision register\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Tell the PICC we want to transmit and receive data\n\tcommand := [1]uint8{reqMode}\n\t_, err := d.transceive(command, answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Detect a possible collision\n\tif (d.readRegister(CollReg) & 0x20) == 0x20 {\n\t\treturn fmt.Errorf(\"Collision detected\")\n\t}\n\n\t// Tell the PICC to send the next frame\n\td.setRegisterBitMask(FIFOLevelReg, 0x80)\n\n\treturn nil\n}", "CodeBleu_score": 55.86342859552305}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\terr := d.digitalWrite(d.stepPin, false)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, true)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == CW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 68.35172440660024}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\terr := d.digitalWrite(d.stepPin, false)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, true)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 67.53702999065293}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 71.06721748929459}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 65.35723344835584}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name)\n\treturn nil\n}", "CodeBleu_score": 59.63169350838624}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 65.35723344835584}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, name string, value uint32, timestamp uint32) {\n\t\tif name == \"rising\" {\n\t\t\td.startTimestamp = timestamp\n\t\t} else if name == \"falling\" {\n\t\t\td.channel <- d.calculateDuration(timestamp)\n\t\t}\n\t}\n}", "CodeBleu_score": 37.61847171323893}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(event int, duration time.Duration, label string, port uint32, pin uint32) {\n\t\tif event == 1 {\n\t\t\td.startTimestamp = time.Now().UnixNano() / 1000\n\t\t} else if event == 2 {\n\t\t\td.durationChannel <- time.Now().UnixNano()/1000 - d.startTimestamp\n\t\t}\n\t}\n}", "CodeBleu_score": 29.74116243715974}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Duration\n\treturn func(pin int, duration time.Duration, eventType string, value uint32, timestamp uint32) {\n\t\tswitch eventType {\n\t\tcase \"rising\":\n\t\t\tstartTimestamp = time.Duration(timestamp) * time.Microsecond\n\t\tcase \"falling\":\n\t\t\td.durationChan <- time.Duration(timestamp-startTimestamp).Microseconds\n\t\t}\n\t}\n}", "CodeBleu_score": 44.02601386418324}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\td.emitTrigger()\n\tselect {\n\tcase <-d.measureChan:\n\t\td.measureMutex.Unlock()\n\t\treturn nil\n\tcase <-time.After(time.Duration(d.timeout) * time.Millisecond):\n\t\td.measureMutex.Unlock()\n\t\treturn fmt.Errorf(\"Timeout reached\")\n\t}\n}", "CodeBleu_score": 29.613236030823725}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.trigger()\n\n\tselect {\n\tcase <-d.measureDone:\n\t\td.measureTime = time.Since(d.startTime)\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n}", "CodeBleu_score": 36.888806404337814}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\td.trigger()\n\tselect {\n\tcase <-d.measure:\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n}", "CodeBleu_score": 26.195589223358873}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    try:\n        auth_token = os.environ[\"AUTH_TOKEN\"]\n        return auth_token\n    except KeyError:\n        pass\n    try:\n        state_item = self.get_state_item(self.STATE_ITEM_ACCESS_TOKEN)\n        if state_item is None:\n            raise AccountNotAuthorized\n        auth_token = state_item[\"access_token\"]\n        if state_item[\"expiration_time\"] < time.time():\n            auth_token = self.fetch_authentication_token_with_refresh_token(state_item[\"refresh_token\"])\n            state_item[\"access_token\"] = auth_token\n            state_item[\"expiration_time\"] = time.time() + state_item[\"expires_in\"] - 10\n            self.set_state_item(self.STATE_ITEM_ACCESS_TOKEN, state_item)\n        return auth_token\n    except KeyError:\n        raise AccountNotAuthorized\n\n", "CodeBleu_score": 35.87082857503142}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        token = os.environ.get('TOKEN')\n        if token:\n            return token\n        else:\n            token = self.get_state_item('access_token')\n            if token:\n                return token\n            else:\n                refresh_token = self.get_state_item('refresh_token')\n                if refresh_token:\n                    token = self.fetch_authentication_token_with_refresh_token(refresh_token)\n                    self.set_state_item('access_token', token)\n                    self.set_state_item('refresh_token', refresh_token)\n                    return token\n                else:\n                    raise AccountNotAuthorized('No access token available')\n    except Exception as exc:\n        raise AccountNotAuthorized(exc) from exc\n\n", "CodeBleu_score": 40.09390738604499}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return super().fetch_authentication_token()\n    except AccountNotAuthorized:\n        self.delete_local_session()\n        raise\n\n", "CodeBleu_score": 6.322862930755935}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    self.delete_local_session()\n    self.get_refresh_token()\n    try:\n        self.fetch_json_data(\"/v1/logout\", method=\"POST\", data={\"refresh_token\": self.refresh_token})\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 41.43447809348445}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\"/v1/logout\", method=\"POST\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 60.762296483216026}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n        return True\n    except AccountError:\n        return False\n\n", "CodeBleu_score": 55.805494287007974}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for item in self.options.get(\"used_packages\", []):\n        if item.get(\"optional\", False):\n            continue\n        pkg = self.get_package(item[\"name\"], item[\"spec\"])\n        if not pkg:\n            continue\n        if pkg.metadata.get(\"external\", False):\n            result.append({\"name\": pkg.name, \"version\": pkg.version, \"url\": pkg.metadata.get(\"url\")})\n        else:\n            result.append({\"name\": pkg.name, \"version\": pkg.version})\n    return result\n\n", "CodeBleu_score": 39.949431388725586}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for item in self.options.get(\"used_packages\", []):\n        if item.get(\"optional\", False):\n            continue\n        if item.get(\"external\", False):\n            result.append(item[\"name\"] + \" (\" + item[\"source_url\"] + \")\")\n        else:\n            result.append(item[\"name\"] + \" (\" + item[\"version\"] + \")\")\n    return result\n\n", "CodeBleu_score": 29.57117091897038}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    items = self.pm.get_all_packages()\n    for item in items:\n        if not item.is_optional:\n            result.append(item.name)\n            if item.is_external:\n                result.append(item.source)\n            result.append(item.version)\n    return result\n\n", "CodeBleu_score": 14.952210936845049}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n", "CodeBleu_score": 5.256410256410256}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    # cls: class\n    # env: str\n    # targets: list\n    # autoinstall: bool\n    # return: ProjectEnv\n    # raise: UndefinedEnvPlatformError\n    #\n    # cls.new\n    # config.get\n    # ProjectConfig.get_instance\n    # p.configure_project_packages\n    # p.set_project_env\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project_packages\n    # p.configure_project", "CodeBleu_score": 5.256410256410256}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n    env_config = cls.get_instance().get_env_config(env)\n    if not env_config:\n        raise exception.UndefinedEnvPlatformError(env)\n    env_cls = cls.get_platform_class(env_config.platform)\n    env_inst = env_cls(env_config.platform, autoinstall=autoinstall)\n    env_inst.set_project_env(env)\n    env_inst.configure_project_packages(env, targets)\n    return env_inst\n\n", "CodeBleu_score": 41.973956593155435}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 73.56846672699541}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 73.56846672699541}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 73.56846672699541}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef DEBUG\n    Serial.print(\"DeepSleep: \");\n    Serial.println(time_in_us);\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 62.177546077957516}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef ESP_IDF_VERSION_MAJOR\n    esp_sleep_enable_timer_wakeup(time_in_us);\n#else\n    esp_sleep_enable_ext1_wakeup(1 << 1, ESP_EXT1_WAKEUP_ALL_LOW);\n#endif\n    SetSleep();\n    if (time_in_us) {\n        esp_deep_sleep_start();\n    } else {\n        esp_deep_sleep(0);\n    }\n}", "CodeBleu_score": 48.669641300232094}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_USE_TIMER_WAKEUP\n    if (time_in_us) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n#endif\n\n    SetSleep();\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 59.39066275174104}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = _y;\n\tint h = _font->height;\n\tint y_max = _height - h;\n\tint y_min = _height - h - _bottom_fixed_area;\n\tif (y < y_min) {\n\t\ty = y_min;\n\t}\n\tif (y > y_max) {\n\t\ty = y_max;\n\t}\n\tif (y == y_min) {\n\t\ty = _height - h - _top_fixed_area;\n\t}\n\tif (y == y_max) {\n\t\ty = _height - h - _top_fixed_area;\n\t}\n\ttft.fillRect(0, y, _width, h, color);\n\ty += h;\n\tscrollAddress(y);\n\treturn y;\n}", "CodeBleu_score": 25.34425985986242}, {"code": "int Display::scroll_line(uint32_t color){\n\t", "CodeBleu_score": 1.6688059799790205}, {"code": "int Display::scroll_line(uint32_t color){\n\t", "CodeBleu_score": 1.6688059799790205}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// set up access points\n\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\n\t// set up HTML content\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\n\t// start the portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 61.874474982232385}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// set up access points\n\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\n\t// set up html content\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 61.874474982232385}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// set up access points\n\tthis->setAP(access_points);\n\n\t// set up html\n\tthis->setHtml(ssids);\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 51.431373896452484}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (!this->queue_enabled_flag) {\n\t\tthis->queue_enabled_flag = true;\n\t\tthis->flush_queue();\n\t\tthis->queue = new char[this->queue_size];\n\t\tthis->text = new char[this->text_size];\n\t\tthis->text_in = new char[this->text_size];\n\t}\n}", "CodeBleu_score": 25.239125788891233}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tthis->flush_queue();\n\t}\n\telse {\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 15.648379731125766}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tthis->queue = this->new_queue;\n\t\tthis->text = this->new_text;\n\t\tthis->text_in = this->new_text_in;\n\t} else {\n\t\tthis->queue = this->flush_queue;\n\t\tthis->text = this->flush_text;\n\t\tthis->text_in = this->flush_text_in;\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 21.919164910895134}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue!= NULL) {\n\t\tdelete this->queue;\n\t\tthis->queue = NULL;\n\t}\n\tthis->new_queue = true;\n}", "CodeBleu_score": 12.550133144877753}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea) {\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = NULL;\n\t}\n\tthis->queue_nmea = new Queue<char>(this->queue_nmea_size);\n}", "CodeBleu_score": 16.132689532455448}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tdelete this->queue;\n\t\tthis->queue = nullptr;\n\t}\n\tthis->new_queue = true;\n}", "CodeBleu_score": 13.176469620816041}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n/*\n * The function \"my_disp_flush\" updates a specified area of the display with new color data.\nIt starts a write transaction, sets the address window to the specified area, and iterates through each pixel in the area.\nFor each pixel, it writes the corresponding color from the provided color buffer.\nAfter updating the area, it ends the write transaction and notifies that the display flush is complete.\n */\n    lv_disp_drv_t *display_obj = (lv_disp_drv_t *)disp;\n    display_obj->tft.startWrite();\n    display_obj->tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n    for(int y = area->y1; y <= area->y2; y++) {\n        for(int x = area->x1; x <= area->x2; x++) {\n            display_obj->tft.writeColor(color_p->full);\n            color_p++;\n        }\n    }\n    display_obj->tft.endWrite();\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 64.71469032068528}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL)\n\t\treturn;\n\n\tint i;\n\tfor (i = 0; i < layer; i++)\n\t\tSerial.print('\\t');\n\tSerial.print(menu->name);\n\tSerial.println();\n\n\tMenu * child = menu->list;\n\twhile (child!= NULL) {\n\t\tshowMenuList(child, layer + 1);\n\t\tchild = child->next;\n\t}\n}", "CodeBleu_score": 43.514053358091395}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\tSerial.println(\"Menu is NULL\");\n\t\treturn;\n\t}\n\tif (menu->list == NULL) {\n\t\tSerial.println(\"Menu list is NULL\");\n\t\treturn;\n\t}\n\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.print(menu->list->get(i)->name);\n\t\tSerial.println();\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 64.44193859524579}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu->list->size() > 0) {\n\t\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\t\tSerial.print(String(layer) + \" \");\n\t\t\tmenu->list->get(i)->showName();\n\t\t\tSerial.println();\n\t\t}\n\t\tSerial.println();\n\t}\n}", "CodeBleu_score": 55.75221311883087}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char) random(33, 126);\n\t\t}\n\t\tint channel = random(1, 13);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tmac += (char) random(33, 126);\n\t\t}\n\t\tmac += \":\";\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tmac += (char) random(33, 126);\n\t\t}\n\t\tSerial.println(ssid + \" \" + String(channel) + \" \" + mac);\n\t\tgenerated++;\n\t}\n\treturn generated;\n}", "CodeBleu_score": 41.88806155525211}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\t// Generate random SSIDs\n\tfor (int i = 0; i < count; i++) {\n\t\t// Create random SSID\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char) random(97, 123);\n\t\t}\n\n\t\t// Create random channel\n\t\tint channel = random(1, 14);\n\n\t\t// Create random MAC address\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac += String(random(0, 256), HEX);\n\t\t\tif (j!= 5) {\n\t\t\t\tmac += \":\";\n\t\t\t}\n\t\t}\n\n\t\t// Add SSID to list\n\t\tthis->ssids->add(new SSID(ssid, channel, mac));\n\n\t\t// Print SSID to serial output\n\t\tSerial.println(ssid);\n\t}\n\n\t// Return number of generated SSIDs\n\treturn this->ssids->size;\n}", "CodeBleu_score": 40.882026534442225}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\t// generate the specified number of random SSIDs\n\tfor (int i = 0; i < count; i++) {\n\t\t// create a random SSID\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid.concat(char(random(97, 122)));\n\t\t}\n\t\t// create a random channel\n\t\tint channel = random(1, 14);\n\t\t// create a random MAC address\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tmac.concat(String(random(0, 255), HEX));\n\t\t\tmac.concat(\":\");\n\t\t}\n\t\tmac.concat(String(random(0, 255), HEX));\n\t\t// create a new WiFiAccessPoint\n\t\tWiFiAccessPoint *ap = new WiFiAccessPoint(ssid, channel, mac);\n\t\t// add the WiFiAccessPoint to the list\n\t\tssids->add(ap);\n\t\t// print the SSID to the serial output\n\t\tSerial.println(ap->toString());\n\t}\n\t// return the number of generated SSIDs\n\treturn ssids->size;\n}", "CodeBleu_score": 42.21919052794766}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print(private_key)\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 60.74213696057751}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Create a JWT (https://jwt.io) and encode it using the private key\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 76.4527720693834}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    pprint(message)\n    preview_capture('image.jpg')\n    url = upload_file('image.jpg', args.bucket_name)\n    client.publish(topic, url, qos=1)\n    if message.payload == b'on':\n        preview_capture('image.jpg')\n        url = upload_file('image.jpg', args.bucket_name)\n        client.publish(topic, url, qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 28.44512826569578}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message: {}'.format(message.payload))\n    print('Topic: {}'.format(message.topic))\n    print('QoS: {}'.format(message.qos))\n    if message.payload.decode() == 'on':\n        print('Previewing image...')\n        preview_capture('preview.jpg')\n        print('Uploading image...')\n        url = upload_file('preview.jpg', 'iot-camera-123')\n        print('Publishing image URL: {}'.format(url))\n        unused_client.publish(\n                'projects/iot-camera-123/locations/us-central1/registries/registry-123/devices/device-123/events/image',\n                url,\n                qos=1)\n    else:\n        print('Received message: off')\n", "CodeBleu_score": 33.60243588812783}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    pprint('Received message')\n    pprint(message.topic)\n    pprint(message.payload)\n    if message.payload == b'on':\n        preview_capture('preview.jpg')\n        url = upload_file('preview.jpg', 'iot-camera-demo')\n        pprint(url)\n        unused_client.publish(\n                'events/iot-camera-demo/preview', url, qos=1)\n    elif message.payload == b'off':\n        pprint('off')\n    else:\n        pprint('Unrecognized message')\n\n", "CodeBleu_score": 28.716251359168304}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP project id')\n    parser.add_argument(\n        '--subscription_name',\n        help='Pub/Sub subscription name')\n    return parser.parse_args()\n\n", "CodeBleu_score": 43.4273848480883}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT device connection')\n    parser.add_argument", "CodeBleu_score": 8.742346924184213}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='GCP project ID where the Pub/Sub topic exists.',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT', ''))\n    parser.add_argument(\n        '--subscription_name',\n        help='The name of the Cloud Pub/Sub subscription to which messages are '\n        'published by the device.',\n        required=True)\n    parser.add_argument(\n        '--registry_id',\n        help='The ID of the Google Cloud IoT Core registry.',\n        required=True)\n    parser.add_argument(\n        '--device_id',\n        help='The ID of the device. The ID must be in lowercase letters, '\n        'and less than 128 bytes long.',\n        required=True)\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.',\n        required=True)\n    parser.add_argument(\n        '--algorithm',\n        help='Algorithm used to generate the JWT.',\n        default='RS256',\n        choices=['RS256', 'ES256'])\n    parser.add_argument(\n        '--cloud_region',\n        help='Region where the Google Cloud IoT Core registry resides.',\n        default='us-central1')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root certificate used to verify the TLS connection to the '\n        'Google Cloud IoT Core registry.',\n        default='roots.pem')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='MQTT bridge hostname.',\n        default='mqtt.googleapis.com')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        help='MQTT bridge port.',\n        default=8883)\n    parser.add_argument(\n        '--mqtt_bridge_use_tls',\n        help='Use TLS when connecting to the MQTT bridge.',\n        action='store_true')\n    parser.add_argument(\n        '--mqtt_bridge_use_alpn',\n        help='Use ALPN when connecting to the MQTT bridge.',\n        action='store_true')\n    parser.add_argument(\n        '--mqtt_bridge_use_websocket',\n        help='Use MQTT over WebSocket when connecting to the MQTT bridge.',\n        action='store_true", "CodeBleu_score": 33.441311064657754}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/v1/projects/{}/locations/{}/registries/{}'\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n    scoped_credentials = credentials.with_scopes(scopes)\n    client = discovery.build('cloudiot', version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n    return client\n", "CodeBleu_score": 22.36025566653639}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    discovery_url = \"https://cloudiot.googleapis.com/v1/projects/iot-project-328421/locations/us-central1/registries/my-registry/devices:list\"\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n    client = discovery.build(\"cloudiot\", \"v1\", credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n    return client\n", "CodeBleu_score": 21.23658523159551}, {"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    discovery_url = 'https://cloudiot.googleapis.com/v1/projects/{project_id}/locations/{location_id}/registries/{registry_id}'.format(project_id=PROJECT_ID, location_id=LOCATION_ID, registry_id=REGISTRY_ID)\n    client = discovery.build('cloudiot', 'v1', credentials=credentials.with_scopes(scopes), discoveryServiceUrl=discovery_url)\n    return client\n", "CodeBleu_score": 35.40680494108269}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t  if hash_method =='sha1':\n        hash_asn1 = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method =='sha256':\n        hash_asn1 = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    else:\n        raise ValueError('Hash method is invalid.')\n    hash_asn1_hash_value = b''.join([hash_asn1, hash_value])\n    padded_hash_asn1_hash_value = _pad_for_signing(hash_asn1_hash_value, 256)\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash_asn1_hash_value)\n    return encrypted_signature\n\n", "CodeBleu_score": 27.078424171706672}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   # Get the ASN1 code for the hash method\n    try:\n        asn1_code = hash_method.asn1_code\n    except AttributeError:\n        raise ValueError('Invalid hash method')\n\n    # Concatenate the ASN1 code with the hash value\n    asn1_hash = asn1_code + hash_value\n\n    # Pad the hash for signing\n    padded_hash = _pad_for_signing(asn1_hash, priv_key.key_size)\n\n    # Encrypt the padded hash\n    signature = priv_key.blinded_encrypt(padded_hash)\n\n    return signature\n\n", "CodeBleu_score": 32.80727649548902}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   if hash_method not in hash_methods:\n        raise ValueError('Invalid hash method')\n\n    asn1_code = hash_methods[hash_method]\n\n    # Concatenate ASN1 code with hash value\n    hash_value_with_asn1 = asn1_code + hash_value\n\n    # Pad for signing\n    padded_hash = _pad_for_signing(hash_value_with_asn1, 256)\n\n    # Encrypt padded hash\n    signature = priv_key.blinded_encrypt(padded_hash)\n\n    return signature\n\n\n", "CodeBleu_score": 38.25919850182585}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t  # Convert the signature to an integer.\n    sig_int = core.decrypt_int(signature, pub_key)\n\n    # Find the hash method.\n    hash_method = _find_method_hash(sig_int)\n\n    # Compute the hash of the message.\n    hash_value = compute_hash(message, hash_method)\n\n    # Reconstruct the padded hash.\n    padded_hash = _pad_for_signing(hash_value, core.byte_size(sig_int))\n\n    # Compare the padded hash to the clear signature.\n    if padded_hash!= sig_int:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n", "CodeBleu_score": 17.823989354904768}, {"code": "def verify(message, signature, pub_key)\n\t try:\n        clearsig = core.decrypt_int(signature, pub_key)\n    except ValueError as e:\n        raise VerificationError(e)\n    except TypeError as e:\n        raise VerificationError(e)\n\n    hash_method = _find_method_hash(clearsig)\n    hashed_message = compute_hash(message, hash_method)\n    padded_hash = _pad_for_signing(hashed_message, common.byte_size(pub_key))\n    if clearsig!= padded_hash:\n        raise VerificationError('Verification failed')\n    return hash_method\n\n", "CodeBleu_score": 43.74742716513296}, {"code": "def verify(message, signature, pub_key)\n\t  if not isinstance(signature, bytes):\n        raise TypeError('Signature must be a byte string')\n\n    if not isinstance(pub_key, RSAPublicKey):\n        raise TypeError('Public key must be an RSAPublicKey object')\n\n    if pub_key.key_size < 1024:\n        raise ValueError('Public key must be at least 1024 bits')\n\n    if pub_key.key_size > 2048:\n        raise ValueError('Public key must be at most 2048 bits')\n\n    if pub_key.key_size % 8!= 0:\n        raise ValueError('Public key size must be a multiple of 8')\n\n    # convert signature to integer\n    sig_int = core.decrypt_int(signature, pub_key)\n\n    # find hash method\n    method_name = _find_method_hash(sig_int)\n\n    # compute hash\n    hash_value = compute_hash(message, method_name)\n\n    # reconstruct padded hash\n    padded_hash = _pad_for_signing(hash_value, pub_key.key_size // 8)\n\n    # verify\n    if padded_hash!= sig_int:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 39.96108583059732}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch > 0) {\n\t\tupdateJWT(epoch);\n\t\tMQTT_CLIENT_connect();\n\t\tMQTT_CLIENT_subscribe(mqttTopic);\n\t\tdebug_printInfo(\"MQTT: Connected\");\n\t} else {\n\t\tdebug_printInfo(\"MQTT: Time not valid\");\n\t}\n}", "CodeBleu_score": 28.633075826622147}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch > 0) {\n\t\tupdateJWT(epoch);\n\t}\n\tMQTT_CLIENT_connect(cid, mqttTopic);\n\tdebug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 23.6243654090025}, {"code": "static void connectMQTT(){\n\t\t// Get current time\n\ttime_t t = time(NULL);\n\n\t// If time is valid, update JWT\n\tif (t!= (time_t)-1) {\n\t\tupdateJWT(t);\n\t}\n\n\t// Connect to MQTT client\n\tMQTT_CLIENT_connect(cid, mqttTopic, mqttPassword, mqttClient);\n\n\t// Set flag to send MQTT SUBSCRIBE packet after connection is established\n\tmqttSubscribe = true;\n\n\tdebug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 49.021786133062676}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (str[i] - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 26.22892502452124}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + (str[i] - '0');\n\t}\n\t*num = result;\n\treturn str + width;\n}", "CodeBleu_score": 26.345225555483037}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tfor (int i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + (str[i] - '0');\n\t}\n\t*num = result;\n\treturn str + width;\n}", "CodeBleu_score": 25.01261686990177}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\n\tif (atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest)!= ATCA_SUCCESS) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (atcacert_get_signature(cert_def, cert, cert_size, signature)!= ATCA_SUCCESS) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\treturn atcac_verify_extern(ca_public_key, tbs_digest, signature);\n}", "CodeBleu_score": 45.28250499070662}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tuint8_t ca_public_key_copy[64];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\t// Check for null parameters\n\tif (cert_size < cert_def->cert_template.cert_size) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\t// Copy the CA public key into a local buffer\n\tmemcpy(ca_public_key_copy, ca_public_key, 64);\n\n\t// Get the TBS digest and signature\n\tret = atcacert_get_tbs_digest(cert_def, cert, tbs_digest);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\tret = atcacert_get_signature(cert_def, cert, signature);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t// Verify the TBS digest against the signature\n\tret = atcab_verify_extern(ca_public_key_copy, tbs_digest, signature);\n\tif (ret) {\n\t\treturn ATCACERT_E_VERIFY_FAILED;\n\t}\n\n\treturn ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 60.46230450352279}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *listHead = list;\n\ttimerStruct_t * volatile *prev = listHead;\n\ttimerStruct_t * volatile *next = (*listHead)->next;\n\twhile(next!= NULL)\n\t{\n\t\tif(next == timer)\n\t\t{\n\t\t\t(*prev)->next = next->next;\n\t\t\treturn true;\n\t\t}\n\t\tprev = next;\n\t\tnext = next->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 25.691776823733225}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *tmp = *list;\n\tif(tmp == NULL)\n\t{\n\t\treturn false;\n\t}\n\tif(tmp == timer)\n\t{\n\t\t*list = tmp->next;\n\t\treturn true;\n\t}\n\twhile(tmp->next!= NULL)\n\t{\n\t\tif(tmp->next == timer)\n\t\t{\n\t\t\ttmp->next = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\ttmp = tmp->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 26.575413277631743}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *prev = list;\n\ttimerStruct_t * volatile *current = list;\n\ttimerStruct_t * volatile *next = list;\n\twhile(*current!= NULL)\n\t{\n\t\tnext = &(*current)->next;\n\t\tif(*current == timer)\n\t\t{\n\t\t\t*prev = *next;\n\t\t\treturn true;\n\t\t}\n\t\tprev = current;\n\t\tcurrent = next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 24.729066900878653}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tint ret = BSD_ERROR;\n\tif (socket >= 0 && socket < MAX_SOCKETS) {\n\t\tif (gastrSockets[socket].bIsUsed) {\n\t\t\tif (gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE) {\n\t\t\t\tret = SOCKET_REQUEST(SOCKET_CMD_SSL_CLOSE, (uint8*) &gastrSockets[socket], sizeof(tstrSocket), NULL, 0, 0);\n\t\t\t} else {\n\t\t\t\tret = SOCKET_REQUEST(SOCKET_CMD_CLOSE, (uint8*) &gastrSockets[socket], sizeof(tstrSocket), NULL, 0, 0);\n\t\t\t}\n\t\t\tif (ret == SOCK_ERR_NO_ERROR) {\n\t\t\t\tm2m_memset((uint8*) &gastrSockets[socket], 0, sizeof(tstrSocket));\n\t\t\t\tret = BSD_SUCCESS;\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(BSD_ECONNRESET);\n\t\t\t}\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 41.61941655701176}, {"code": "int BSD_close(int socket){\n\tint status = BSD_SUCCESS;\n\ttstrSocket *pstrSocket;\n\n\tif (socket < 0) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\tstatus = BSD_ERROR;\n\t} else {\n\t\tpstrSocket = getSocketInfo(socket);\n\t\tif (pstrSocket == NULL) {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t\tstatus = BSD_ERROR;\n\t\t} else {\n\t\t\tif (pstrSocket->bIsUsed == 0) {\n\t\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t\t\tstatus = BSD_ERROR;\n\t\t\t} else {\n\t\t\t\tif (close(socket)!= SOCK_ERR_NO_ERROR) {\n\t\t\t\t\tstatus = BSD_ERROR;\n\t\t\t\t} else {\n\t\t\t\t\tm2m_memset(pstrSocket, 0, sizeof(tstrSocket));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 32.32430248451597}, {"code": "int BSD_close(int socket){\n\tint ret;\n\tif (socket < 0 || socket >= BSD_MAX_SOCKETS) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tif (gastrSockets[socket].bIsUsed == 0) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tret = close(socket);\n\tif (ret == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t}\n\tswitch (ret) {\n\tcase SOCK_ERR_INVALID_ARG:\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\tbreak;\n\tcase SOCK_ERR_INVALID:\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\tbreak;\n\tcase SOCK_ERR_NO_MEMORY:\n\t\tbsd_setErrNo(BSD_ENOMEM);\n\t\tbreak;\n\tdefault:\n\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\tbreak;\n\t}\n\treturn BSD_ERROR;\n}", "CodeBleu_score": 50.26367723953326}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint\t\ts32Ret;\n\t\n\ts32Ret = listen(socket, backlog);\n\tif(s32Ret!= SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(s32Ret);\n\t\ts32Ret = BSD_ERROR;\n\t}\n\treturn s32Ret;\n}", "CodeBleu_score": 28.82842887516737}, {"code": "int BSD_listen(int socket, int backlog){\n\tsint8 s8Ret = SOCK_ERR_INVALID;\n\t\n\ts8Ret = listen(socket, backlog);\n\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(s8Ret);\n\t\ts8Ret = BSD_ERROR;\n\t}\n\telse\n\t{\n\t\ts8Ret = BSD_SUCCESS;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 35.215833959771224}, {"code": "int BSD_listen(int socket, int backlog){\n\tsint8 s8Ret;\n\n\ts8Ret = listen(socket, backlog);\n\n\tif(s8Ret == SOCK_ERR_NO_ERROR)\n\t{\n\t\ts8Ret = BSD_SUCCESS;\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(s8Ret);\n\t\ts8Ret = BSD_ERROR;\n\t}\n\n\treturn s8Ret;\n}", "CodeBleu_score": 33.83011046239827}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tdebug_printInfo(\"MQTT: Connecting...\");\n\tuint32_t epoch = time(NULL);\n\tif (epoch == (uint32_t)-1) {\n\t\tdebug_printInfo(\"MQTT: Error: Could not get current time\");\n\t\treturn;\n\t}\n\n\tupdateJWT(epoch);\n\tif (MQTT_CLIENT_connect(cid, mqttTopic, mqttPassword, mqttPort, mqttServer, mqttClientId) == 0) {\n\t\tdebug_printInfo(\"MQTT: Connected\");\n\t\tMQTT_CLIENT_subscribe(mqttTopic, MQTT_QOS1);\n\t} else {\n\t\tdebug_printInfo(\"MQTT: Error: Could not connect to MQTT broker\");\n\t}\n}", "CodeBleu_score": 43.420329182012374}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch > 0) {\n\t\tupdateJWT(epoch);\n\t\tMQTT_CLIENT_connect(cid, mqttTopic, mqttPassword, 0);\n\t\tdebug_printInfo(\"MQTT: Connection attempt\");\n\t}\n\telse {\n\t\tdebug_printInfo(\"MQTT: Time not valid\");\n\t}\n}", "CodeBleu_score": 49.93822472272393}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch > 0) {\n\t\tupdateJWT(epoch);\n\t\tMQTT_CLIENT_connect();\n\t\tMQTT_CLIENT_subscribe(mqttTopic);\n\t}\n}", "CodeBleu_score": 21.306310672657798}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tdebug_printError(CLOUD_disconnect);\n\tMQTT_Disconnect(connectionInfo);\n}", "CodeBleu_score": 10.027240249293124}, {"code": "void CLOUD_disconnect(void){\n\t\tif (mqttState == CONNECTED) {\n\t\tMQTT_GetClientConnectionInfo(&connectionInfo);\n\t\tMQTT_Disconnect(&connectionInfo);\n\t}\n}", "CodeBleu_score": 43.82708311230966}, {"code": "void CLOUD_disconnect(void){\n\t\tif (mqttState == CONNECTED) {\n\t\tmqttGetClientConnectionInfo(&connectionInfo);\n\t\tMQTT_Disconnect(&connectionInfo);\n\t}\n}", "CodeBleu_score": 43.04150369609576}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tuint8_t wifi_creds = passed_wifi_creds;\n\tif(wifi_creds == 0) {\n\t\tdebug_printError(m2m_wifi_default_connect());\n\t} else {\n\t\tdebug_printError(m2m_wifi_connect(wifi_ssid, strlen(wifi_ssid), wifi_sec, wifi_auth_info, wifi_channel));\n\t}\n\treturn true;\n}", "CodeBleu_score": 30.9974179088351}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tsint8 ret;\n\tif(passed_wifi_creds) {\n\t\tret = m2m_wifi_connect(wifi_ssid, strlen(wifi_ssid), wifi_security, wifi_password, wifi_channel);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\n\tif(ret!= M2M_SUCCESS) {\n\t\tdebug_printError(\"m2m_wifi_connect\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.114828176405354}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds) {\n\t\t// Connect to the specified Wi-Fi network.\n\t\tm2m_wifi_connect(wifi_ssid, strlen(wifi_ssid), wifi_sec_type, wifi_auth_info, wifi_channel);\n\t} else {\n\t\t// Connect to the default Wi-Fi network.\n\t\tm2m_wifi_default_connect();\n\t}\n\treturn true;\n}", "CodeBleu_score": 36.43164257819079}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t", "CodeBleu_score": 0.7730807380978455}, {"code": "async function DisplaySensors(map){\n\t", "CodeBleu_score": 0.7730807380978455}, {"code": "async function DisplaySensors(map){\n\tCreate a client\nconst client = new ApolloClient({\nuri:\n\"https://api.graph.cool/simple/v1/cixm3j53d011z0172n1637390\",\n});\n\n// Send a GraphQL query to fetch sensor data\nconst response = await client.query({\nquery: gql`\n{\nlistSensors {\nid\nname\ngeo {\nlongitude\nlatitude\n}\n}\n}\n`,\n});\n\n// Log the API response\nconsole.log(response.data);\n\n// Log the retrieval of sensors\nconsole.log(\"Retrieved sensors:\");\n\n// Iterate through each sensor to create a marker\nresponse.data.listSensors.forEach(function(sensor) {\n// Create a marker\nconst marker = document.createElement(\"div\");\nmarker.className = \"marker\";\n\n// Add the marker to the map\nnew Marker({ element: marker })\n.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n.addTo(map);\n\n// Log the sensor's ID and name\nconsole.log(`Sensor ID: ${sensor.id}`);\nconsole.log(`Sensor name: ${sensor.name}`);\n});\n}", "CodeBleu_score": 44.932455903129316}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\")\n\tmarker.id = sensor.id\n\tmarker.className = \"sensor-marker\"\n\tmarker.style.backgroundColor = \"rgb(138, 236, 255)\"\n\tmarker.style.borderColor = \"rgb(138, 236, 255)\"\n\treturn marker\n}", "CodeBleu_score": 39.42219998868157}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 46.55188717795596}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"rgba(0, 128, 0, 0.5)\";\n\tmarker.style.border = \"1px solid rgba(0, 128, 0, 0.5)\";\n\tmarker.style.width = \"10px\";\n\tmarker.style.height = \"10px\";\n\tmarker.style.borderRadius = \"50%\";\n\tmarker.style.position = \"absolute\";\n\tmarker.style.top = \"0px\";\n\tmarker.style.left = \"0px\";\n\tmarker.style.cursor = \"pointer\";\n\treturn marker;\n}", "CodeBleu_score": 41.21712072553887}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n\n    # Attempt to import the module\n    try:\n        module = async_import_module(hass, module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Failed to import %s\", module_path)\n        raise\n\n    # Check if the module has requirements\n    if hasattr(module, \"__requires__\"):\n        # Process the module's requirements\n        requirements.async_process_requirements(hass, module.__requires__)\n\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 21.71093481139419}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as ex:\n        _LOGGER.error(\"Failed to import %s: %s\", module_path, ex)\n        raise\n    if not hass.config.skip_pip:\n        if not hass.config.requirements_path:\n            raise HomeAssistantError(\n                \"MFA modules require a requirements.txt file to be present in the config directory. Please create one.\"\n            )\n        requirements = getattr(module, \"REQUIREMENTS\", None)\n        if requirements:\n            if not isinstance(requirements, list):\n                raise HomeAssistantError(\n                    \"MFA module requirements must be a list of strings.\"\n                )\n            if not hass.data.get(DATA_REQUIREMENTS_PROCESSED, set()).isdisjoint(\n                requirements\n            ):\n                _LOGGER.warning(\n                    \"MFA module %s has already been processed.\", module_name\n                )\n                return module\n            hass.data[DATA_REQUIREMENTS_PROCESSED].update(requirements)\n            await requirements.async_process_requirements(hass, requirements)\n    return module", "CodeBleu_score": 44.39384240349332}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n\n    # Attempt to import the module\n    try:\n        module = await hass.async_add_executor_job(importlib.import_module, module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Multi-factor authentication module %s not found\", module_name)\n        raise\n\n    # Check if the module has requirements and pip installation is not skipped\n    if hasattr(module, \"REQUIREMENTS\"):\n        requirements = module.REQUIREMENTS\n        if requirements and not hass.config.skip_pip:\n            # Process the requirements if they haven't already been processed\n            processed = hass.data.get(DATA_REQUIREMENTS_PROCESSED, set())\n            if requirements not in processed:\n                # Process the requirements\n                await hass.async_process_requirements(requirements)\n                # Add the requirements to the processed set\n                processed.add(requirements)\n\n    # Return the loaded module\n    return module", "CodeBleu_score": 42.5656295337568}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Extract the PIN from the setup data\n    pin = setup_data[\"pin\"]\n\n    # Check if the user already has an entry in the data list\n    if user_id in self.data:\n        # Update the PIN\n        self.data[user_id][\"pin\"] = pin\n    else:\n        # Add a new entry to the data list\n        self.data[user_id] = {\"pin\": pin}\n\n    # Return the setup data\n    return setup_data\n", "CodeBleu_score": 37.50703108130836}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not self.data:\n        self.data = {}\n    if not isinstance(self.data, dict):\n        raise TypeError(\"data must be a dict\")\n    if user_id not in self.data:\n        self.data[user_id] = setup_data\n    else:\n        self.data[user_id] = setup_data\n    return self.data[user_id]\n", "CodeBleu_score": 31.753050798231442}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    return True\n\n", "CodeBleu_score": 36.954710318750436}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if not self._initialized:\n        async with self._lock:\n            if not self._initialized:\n                self._initialized = True\n                data = await self._store.async_load()\n                if data is None:\n                    data = {}\n                self._data = data\n                self._notify_settings = {\n                    user_id: NotifySetting(\n                        user_id=user_id,\n                        data=data.get(user_id, {}),\n                        hass=self._hass,\n                    )\n                    for user_id in data\n                }\n\n", "CodeBleu_score": 37.31379034026256}, {"code": "async def _async_load(self) -> None\n\t\n    if not self.hass.data.get(DATA_NOTIFY_SETTINGS):\n        # Acquire initialization lock to ensure thread safety\n        with self._lock:\n            # Check if user settings are already loaded\n            if self.hass.data.get(DATA_NOTIFY_SETTINGS):\n                return\n\n            # Attempt to load data from the user store\n            data = await self._store.async_load()\n\n            # If the data is empty, initialize an empty dictionary for user settings\n            if not data:\n                data = {}\n\n            # Populate the user settings by creating \"NotifySetting\" objects for each user\n            self.hass.data[DATA_NOTIFY_SETTINGS] = {\n                user: NotifySetting(self.hass, user, data.get(user, {}))\n                for user in self.hass.data[DATA_USERS]\n            }", "CodeBleu_score": 38.151663073731584}, {"code": "async def _async_load(self) -> None\n\t\n    async with self.init_lock:\n        if self.initialized:\n            return\n\n        self.data = {}\n        data = await self.store.async_load()\n        if not data:\n            data = {}\n        for user_id, user_data in data.items():\n            self.data[user_id] = NotifySetting(user_id, **user_data)\n\n        self.initialized = True\n\n", "CodeBleu_score": 32.98551506914408}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._async_load(user_id)\n    notification_settings = self._get_notification_settings(user_id)\n    if notification_settings is None:\n        return False\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n    if not self.is_otp_valid(otp):\n        return False\n    return True", "CodeBleu_score": 45.65264952375759}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    # Load user settings if not already loaded\n    if not self._user_settings:\n        await self._async_load()\n\n    # Retrieve notification settings for the specified user\n    notification_settings = self._user_settings.get(user_id, {})\n\n    # Validate user input\n    if notification_settings:\n        # Retrieve OTP from user input\n        otp = user_input.get(\"otp\")\n\n        # Validate OTP using an executor job\n        if otp:\n            try:\n                await self._async_validate_otp(user_id, otp)\n            except Exception as e:\n                _LOGGER.error(\"Failed to validate OTP: %s\", e)\n                return False\n            else:\n                return True\n        else:\n            _LOGGER.error(\"OTP is missing in user input\")\n            return False\n    else:\n        _LOGGER.error(\"No notification settings found for user %s\", user_id)\n        return False", "CodeBleu_score": 41.6499725478789}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self.hass.async_create_task(\n        self.hass.config_entries.flow.async_configure(\n            flow.FLOW_ID,\n            user_input,\n            data={\n                \"user_id\": user_id,\n                \"notification_id\": user_input[\"notification_id\"],\n            },\n        )\n    )\n    return True", "CodeBleu_score": 37.60651733494554}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n\n    entity_entry = perm_lookup.entity_dict.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_id = entity_entry.get(\"device_id\")\n    if device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_dict.get(device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.get(\"area_id\")\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.16914255341071}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_dict.get(entity_id, None)\n    if entity_entry is None:\n        return None\n    device_id = entity_entry.get(\"device_id\", None)\n    if device_id is None:\n        return None\n    device_entry = perm_lookup.device_dict.get(device_id, None)\n    if device_entry is None:\n        return None\n    area_id = device_entry.get(\"area_id\", None)\n    if area_id is None:\n        return None\n    return area_dict.get(area_id, None)\n\n", "CodeBleu_score": 59.030839278539446}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n\n    # Retrieve the entity entry\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if entity_entry is None:\n        return None\n\n    # Retrieve the device entry\n    device_id = entity_entry.get(\"device_id\")\n    if device_id is None:\n        return None\n    device_entry = perm_lookup.get_device(device_id)\n    if device_entry is None:\n        return None\n\n    # Retrieve the area ID\n    area_id = device_entry.get(\"area_id\")\n    if area_id is None:\n        return None\n\n    # Return the permissions for the area\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 62.142779968786}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_dict in policies:\n        if policy_dict is None:\n            continue\n\n        assert isinstance(policy_dict, dict)\n\n        for category in policy_dict:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [src.get(category) for src in policies if isinstance(src, dict)]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return cast(PolicyType, policy)", "CodeBleu_score": 58.33824367186835}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy in policies:\n        for category, category_policy in policy.items():\n            if category in seen:\n                continue\n            seen.add(category)\n            category_sources = [src.get(category) for src in policies if isinstance(src, dict)]\n            policy[category] = _merge_policies(category_sources)\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 59.86644506761504}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for category in p:\n            if category in seen:\n                continue\n            seen.add(category)\n            policy[category] = _merge_policies(\n                [src.get(category) for src in policies if isinstance(src, dict)]\n            )\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 62.07027636112694}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in processed:\n        return await async_import_module(hass, provider)\n\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Failed to import authentication provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Failed to import authentication provider {provider}\"\n        ) from err\n\n    if not hasattr(module, \"AUTH_PROVIDERS\"):\n        return module\n\n    if not hasattr(module, \"AUTH_PROVIDERS_REQUIREMENTS\"):\n        processed.add(provider)\n        return module\n\n    requirements = module.AUTH_PROVIDERS_REQUIREMENTS\n    if requirements is None:\n        processed.add(provider)\n        return module\n\n    hass.async_create_task(\n        hass.async_add_executor_job(\n            requirements.async_process_requirements,\n            hass,\n            requirements,\n            processed,\n        )\n    )\n    return module", "CodeBleu_score": 50.39781683220952}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in hass.data[DATA_AUTH_PROVIDERS]:\n        return hass.data[DATA_AUTH_PROVIDERS][provider]\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Unable to load auth provider module: %s\", err)\n        raise HomeAssistantError(\n            \"Unable to load auth provider module: {}\".format(err)\n        ) from err\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load auth provider module: %s\", err)\n        raise HomeAssistantError(\n            \"Unable to load auth provider module: {}\".format(err)\n        ) from err\n    else:\n        hass.data[DATA_AUTH_PROVIDERS][provider] = module\n        if module.__dict__.get(\"__auth_requirements__\") is not None:\n            for requirement in module.__dict__[\"__auth_requirements__\"]:\n                if requirement in hass.data[DATA_AUTH_REQUIREMENTS]:\n                    continue\n                try:\n                    await async_import_module(hass, requirement)\n                except ModuleNotFoundError as err:\n                    _LOGGER.error(\n                        \"Unable to load auth provider module: %s\", err\n                    )\n                    raise HomeAssistantError(\n                        \"Unable to load auth provider module: {}\".format(err)\n                    ) from err\n                except ImportError as err:\n                    _LOGGER.error(\n                        \"Unable to load auth provider module: %s\", err\n                    )\n                    raise HomeAssistantError(\n                        \"Unable to load auth provider module: {}\".format(err)\n                    ) from err\n                else:\n                    hass.data[DATA_AUTH_REQUIREMENTS].add(requirement)\n    return module\n", "CodeBleu_score": 35.935892512300086}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in processed:\n        return _get_module(hass.data[DATA_IMPORT_CACHE], provider)\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Error loading authentication provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Error loading authentication provider module {provider}: {err}\"\n        ) from err\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error loading authentication provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Error loading authentication provider module {provider}: {err}\"\n        ) from err\n    except Exception as err:\n        _LOGGER.error(\n            \"Error loading authentication provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Error loading authentication provider module {provider}: {err}\"\n        ) from err\n    else:\n        if not hasattr(module, \"AUTH_PROVIDERS\"):\n            _LOGGER.error(\n                \"Authentication provider module %s does not have the AUTH_PROVIDERS attribute\",\n                provider,\n            )\n            raise HomeAssistantError(\n                f\"Authentication provider module {provider} does not have the AUTH_PROVIDERS attribute\"\n            )\n        requirements = getattr(module, \"AUTH_PROVIDERS\", [])\n        if not requirements:\n            processed.add(provider)\n            return module\n        try:\n            hass.async_create_task(\n                hass.requirements.async_process_requirements(\n                    hass, requirements, provider\n                )\n            )\n        except Exception as err:\n            _LOGGER.error(\n                \"Error loading authentication provider module %s: %s\", provider, err\n            )\n            raise HomeAssistantError(\n                f\"Error loading authentication provider module {provider}: {err}\"\n            ) from err\n        processed.add(provider)\n        return module", "CodeBleu_score": 43.04966984764115}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"a\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password.encode(\"utf-8\")\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            else:\n                raise InvalidAuth()\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n    raise InvalidAuth()\n\n", "CodeBleu_score": 39.66045891340683}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), user.password_hash):\n                return\n            else:\n                raise InvalidAuth()\n    raise InvalidAuth()\n", "CodeBleu_score": 31.374435027694393}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password.encode()\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth(f\"Invalid username or password for user {username}\")\n    raise InvalidAuth(f\"Invalid username or password for user {username}\")\n\n", "CodeBleu_score": 39.24677760085656}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username", "CodeBleu_score": 5.038543046854512}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username", "CodeBleu_score": 5.038543046854512}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username", "CodeBleu_score": 5.038543046854512}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        self.async_initialize()\n    try:\n        await self._store.async_remove_auth(credentials.username)\n    except KeyError:\n        pass\n    await self.async_save()\n", "CodeBleu_score": 48.67099125006633}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.initialized:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except InvalidAuth:\n        pass\n    await self.async_save()\n", "CodeBleu_score": 45.9505112554716}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except InvalidAuth:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 45.970787858016806}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout=timeout)\n        except RuntimeError:\n            thread.join()\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            try:\n                async_raise(SystemExit)\n            except RuntimeError:\n                pass\n        joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 51.969958783557544}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            pass\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        async_raise(SystemExit)\n    return joined", "CodeBleu_score": 53.323944971619795}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        async_raise(SystemExit, \"Thread interrupted\")\n    return joined\n\n", "CodeBleu_score": 55.35779158293017}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if not thread.is_alive() and not thread.is_daemon()]\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = shutdown_timeout / len(threads)\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(f\"Failed to join thread {thread.name}: {e}\")\n\n", "CodeBleu_score": 28.40633008327004}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if thread.is_alive() and not thread.daemon and thread!= threading.main_thread()]\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = shutdown_timeout / len(threads)\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(f\"Failed to join thread {thread.name}: {e}\")\n\n", "CodeBleu_score": 32.15019767623326}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()]\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = shutdown_timeout / len(threads)\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(f\"Failed to join thread {thread.name}: {e}\")\n", "CodeBleu_score": 37.69032035996197}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_with_setup_started = bool(remaining_with_setup_started)\n", "CodeBleu_score": 49.52168913522297}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n      self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_setups_with_started = {}\n\n\n\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" sends an internal dispatcher signal with the remaining setups.\"\"\"\n    self._async_dispatcher_send(\n      signal=self._signal_name_remaining_setups_with_started,\n      data=remaining_with_setup_started,\n    )\n\n\n\n\n\n def _async_dispatcher_send_internal_setup_started(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal_setup_started\" sends an internal dispatcher signal with the setup name.\"\"\"\n    self._async_dispatcher_send(\n      signal=self._signal_name_setup_started,\n      data=setup_name,\n    )\n\n\n\n\n\n def _async_dispatcher_send_internal_setup_finished(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal_setup_finished\" sends an internal dispatcher signal with the setup name.\"\"\"\n    self._async_dispatcher_send(\n      signal=self._signal_name_setup_finished,\n      data=setup_name,\n    )\n\n\n\n\n\n def _async_dispatcher_send_internal_setup_failed(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal_setup_failed\" sends an internal dispatcher signal with the setup name.\"\"\"\n    self._async_dispatcher_send(\n      signal=self._signal_name_setup_failed,\n      data=setup_name,\n    )\n\n\n\n\n\n def _async_dispatcher_send_internal_setup_succeeded(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal_setup_succeeded\" sends an internal dispatcher signal with the setup name.\"\"\"\n    self._async_dispatcher_send(\n      signal=self._signal_name_setup_succeeded,\n      data=setup_name,\n    )\n\n\n\n\n\n def _async_dispatcher_send_internal_setup_failed_to_start(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatcher_send", "CodeBleu_score": 43.71239546831247}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n      self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_with_setup_started = bool(remaining_with_setup_started)\n\n def _async_dispatch_and_return_remaining(self, remaining_with_setup_started: dict[str, float]) -> dict[str, float]:\n    \"\"\"The function \"_async_dispatch_and_return_remaining\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 48.57833386982635}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.has_error:\n        return\n\n    # If we are generating the file, we should not check the file\n    if config.generate:\n        return\n\n    # Read the current content of bluetooth.py\n    fp = open(config.path, \"r\")\n    str = fp.read()\n    fp.close()\n\n    # Generate and validate the file\n    generated_content = generate_and_validate(integrations)\n\n    # If the content is different, add an error\n    if generated_content!= str:\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py is not up to date. Please run `ha config generate` to update it.\",\n            fixable=True,\n        )\n\n", "CodeBleu_score": 50.52180073312131}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    config.add_error(\n        \"bluetooth\",\n        \"bluetooth.py is not up to date, please run `ha generate bluetooth` to fix\",\n        fixable=True,\n        fix_func=lambda: generate_and_validate(integrations),\n    )\n\n", "CodeBleu_score": 20.98381290119538}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.bluetooth_file_path is None:\n        return\n\n    if config.bluetooth_file_path.is_file():\n        with open(config.bluetooth_file_path, \"r\", encoding=\"utf-8\") as fp:\n            str = fp.read()\n    else:\n        str = \"\"\n\n    generated = generate_and_validate(integrations)\n\n    if str!= generated:\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py is not up to date\",\n            \"Please run `ha generate bluetooth.py` to generate the file\",\n        )\n\n", "CodeBleu_score": 45.76783825230949}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\tvar e struct {\n\t\tError struct {\n\t\t\tCode    string `json:\".tag\"`\n\t\t\tMessage string `json:\"error\"`\n\t\t} `json:\"error\"`\n\t}\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post\n\tif e.Error.Code!= \"\" {\n\t\tlogger.Info\n\t}\n\td.AccessToken = resp.AccessToken\n\td.TokenType = resp.TokenType\n\td.ExpiresIn = resp.ExpiresIn\n\treturn nil\n}", "CodeBleu_score": 49.912818109388326}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t}\n\tvar e error\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post\n\tif e!= nil {\n\t\tlogger.Info(e.Error())\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 58.73310039732469}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp RefreshTokenResponse\n\tvar e error\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post\n\tif e!= nil {\n\t\tlogger.Info(\"refreshToken\", zap.Error(e))\n\t\treturn e\n\t}\n\tif resp.AccessToken!= \"\" {\n\t\td.AccessToken = resp.AccessToken\n\t}\n\treturn nil\n}", "CodeBleu_score": 58.94899289050893}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.NewRestyRequest()\n\treq.SetError(&d.error)\n\treq.SetResult(resp)\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"fields\", \"*\")\n\treq.SetMethod(method)\n\treq.SetBody(nil)\n\treq.SetPath(url)\n\treq.SetError(&d.error)\n\treq.SetResult(resp)\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tres, err := req.Execute()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := req.Execute(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 53.19849340317748}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.NewReq(url, method, callback, resp)\n\treq.SetQueryParam(\"access_token\", d.accessToken)\n\treq.SetQueryParam(\"alt\", \"json\")\n\treq.SetQueryParam(\"prettyPrint\", \"false\")\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\n\tvar err error\n\tvar body []byte\n\tvar respBody []byte\n\tvar respErr error\n\n\tfor i := 0; i < 2; i++ {\n\t\tbody, err = req.Execute()\n\t\tif err!= nil {\n\t\t\tif i == 0 && strings.Contains(err.Error(), \"401\") {\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err!= nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\trespErr = req.SetResult(body, resp)\n\t\tif respErr!= nil {\n\t\t\treturn nil, respErr\n\t\t}\n\t\trespBody = body\n\t\tbreak\n\t}\n\treturn respBody, nil\n}", "CodeBleu_score": 49.3851371181571}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.request(url, method, callback)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\trespBody, err := req.Execute()\n\tif err!= nil {\n\t\tif err.Error() == \"401 Unauthorized\" {\n\t\t\td.refreshToken()\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, err\n\t}\n\tif resp!= nil {\n\t\terr = json.Unmarshal(respBody, resp)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn respBody, nil\n}", "CodeBleu_score": 53.47147969468826}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size based on the file size and the maximum chunk size allowed by Google Drive.\n\tchunkSize := stream.GetSize() / 10\n\tif chunkSize > 100 * 1024 * 1024 {\n\t\tchunkSize = 100 * 1024 * 1024\n\t}\n\tif chunkSize < 5 * 1024 * 1024 {\n\t\tchunkSize = 5 * 1024 * 1024\n\t}\n\n\t// Create a new HTTP request for uploading the file in chunks.\n\treq, err := d.request.New(ctx, http.MethodPut, url, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Upload the file in chunks.\n\tfor start := int64(0); start < stream.GetSize(); start += chunkSize {\n\t\tfinish := start + chunkSize - 1\n\t\tif finish >= stream.GetSize() {\n\t\t\tfinish = stream.GetSize() - 1\n\t\t}\n\n\t\t// Create a new request for the current chunk.\n\t\treq, err = d.request.New(ctx, http.MethodPut, url, nil)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the request headers for the current chunk.\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext\n\n\t\t// Send the request and handle the response.\n\t\tresp, err := req.Send()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode!= http.StatusCreated {\n\t\t\treturn errors.New(resp.Status)\n\t\t}\n\n\t\t// Check for context cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 54.93836946691256}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size based on the file size and the maximum chunk size allowed by the API.\n\tchunkSize := stream.GetSize() / 10\n\tif chunkSize > 100000000 {\n\t\tchunkSize = 100000000\n\t}\n\tif chunkSize < 100000 {\n\t\tchunkSize = 100000\n\t}\n\t// Create a new request to upload the file.\n\treq := d.request.New(ctx, http.MethodPut, url)\n\t// Read the file in chunks and upload each chunk sequentially.\n\tfor start := int64(0); start < stream.GetSize(); start += chunkSize {\n\t\t// Check for context cancellation.\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\t// Set the Content-Length and Content-Range headers for the current chunk.\n\t\tfinish := start + chunkSize - 1\n\t\tif finish > stream.GetSize() {\n\t\t\tfinish = stream.GetSize() - 1\n\t\t}\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", start, finish, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext()\n\t\t// Send the request and handle the response.\n\t\tif err := req.Do(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.31402216866237}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context.\n\tvar reqBody models.UnMountStorageRequest\n\tif err := ctx.Bind(&reqBody); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidJSON, err.Error()))\n\t}\n\n\t// Get the mount point from the request body.\n\tmountPoint := reqBody.MountPoint\n\n\t// Return a client error if the mount point is empty.\n\tif mountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidMountPoint))\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrUnmountStorage, err.Error()))\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrDeleteConfig, err.Error()))\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success))\n}", "CodeBleu_score": 50.73225190239754}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar reqBody UmountStorageReq\n\tif err := ctx.Bind(&reqBody); err!= nil {\n\t\treturn common_err.NewClientError(err)\n\t}\n\tif reqBody.MountPoint == \"\" {\n\t\treturn common_err.NewClientError(errors.New(\"mount_point is empty\"))\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(reqBody.MountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err)\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(reqBody.MountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err)\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.SuccessResp(nil))\n}", "CodeBleu_score": 36.5944976672776}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar data storage.StorageConfig\n\tif err := ctx.Bind(&data); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to bind data\", http.StatusBadRequest)\n\t}\n\tif data.MountPoint == \"\" {\n\t\treturn common_err.GetMsg(nil, \"Mount point is empty\", http.StatusBadRequest)\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(data.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to unmount storage\", http.StatusInternalServerError)\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(data.Name); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to delete config\", http.StatusInternalServerError)\n\t}\n\treturn ctx.JSON(http.StatusOK, gin.H{\n\t\t\"message\": \"Successfully unmounted storage\",\n\t})\n}", "CodeBleu_score": 40.997267627842774}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return an error response if the file path is missing\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingParam))\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// Return an error response if the file does not exist\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.68577344722174}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\t// Check if the path is provided\n\tif filePath == \"\" {\n\t\t// If the path is missing, return an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrParamMissing))\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// If the file does not exist, return an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\t// If the file exists, return it to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.74444095469166}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidParams))\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.73052090594384}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.GetMsg(err, http.StatusBadRequest)\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn common_err.GetMsg(err, http.StatusInternalServerError)\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(nil, http.StatusOK))\n}", "CodeBleu_score": 60.89060546605825}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the \"name\" parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully\"})\n}", "CodeBleu_score": 53.66598045327202}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\".\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.String(http.StatusOK, \"Notification sent successfully.\")\n}", "CodeBleu_score": 53.174882132308895}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running\n\tif!sendMeg.IsRunning() {\n\t\tsendMeg.Start()\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Printf(\"Message type: %d\nMessage: %s\nError: %v\n\n\", ws.Op, message, err)\n\t}\n\n\t// Close the WebSocket connection\n\tws.Close()\n\n\t// Remove the WebSocket connection from the list of connections\n\tfor i, connection := range connections {\n\t\tif connection == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Return nil\n\treturn nil\n}", "CodeBleu_score": 45.73116102838372}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection.\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\t// If the message sending service is not running, start it.\n\tif!sendMeg.IsRunning() {\n\t\tsendMeg.Start()\n\t}\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(string(msg))\n\t}\n}", "CodeBleu_score": 40.728395094045474}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upgrader.Upgrade(ctx.Response, ctx.Request, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tsendMeg.AddConnection(ws)\n\tgo func() {\n\t\tfor {\n\t\t\t_, message, err := ws.ReadMessage()\n\t\t\tif err!= nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(\"Message type: \", websocket.BinaryMessage)\n\t\t\tfmt.Println(\"Received message: \", string(message))\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 38.111670519245244}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system hardware information\n\tsystemHardwareInfo := service.MyService.System().GetHardwareInfo()\n\t// Check if the system hardware information is available\n\tif systemHardwareInfo!= nil {\n\t\t// Return the system hardware information as a JSON response\n\t\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n\t}\n\t// If the system hardware information is not available, return \"nil\"\n\treturn nil\n}", "CodeBleu_score": 18.56825007302669}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\terr error\n\t)\n\n\t// Get the system hardware information\n\tsystemHardwareInfo, err := service.MyService.System().GetSystemHardwareInfo()\n\tif err!= nil {\n\t\treturn common_err.NewError(common_err.ErrorHardwareInfo, err)\n\t}\n\n\t// Return the system hardware information as a JSON response\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 18.836318968841848}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the hardware information\n\thardwareInfo, err := service.MyService.System().GetHardwareInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrNotFound, err.Error()))\n\t}\n\t// Return the hardware information\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}", "CodeBleu_score": 19.651243059943873}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 70.26610648424769}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 70.9889187082285}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.listServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 62.07500638102484}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Marshal the message map to JSON\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to marshal message to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create the event\n\tevent := &MyService.NotifyEvent{\n\t\tName:     name,\n\t\tMessage:  string(messageJSON),\n\t\tResponse: &MyService.NotifyResponse{},\n\t}\n\n\t// Publish the event to the message bus\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), event)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log the response status code\n\tlogger.Info(\"Response status code\", zap.String(\"status\", response.Status))\n\n\t// Check if the response status code is not OK\n\tif response.StatusCode!= http.StatusOK {\n\t\t// Log the response details\n\t\tlogger.Error(\"Failed to send notification\", zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 43.824485815284916}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Marshal the message map to a JSON string\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"failed to marshal message map to JSON string\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create a new context with a timeout\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Create a request to send the notification\n\trequest, err := http.NewRequest(\"POST\", \"http://localhost:8080/notify/\"+name, bytes.NewBuffer(messageJSON))\n\tif err!= nil {\n\t\tlogger.Error(\"failed to create request to send notification\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Set the request headers\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\n\t// Send the request and get the response\n\tresponse, err := http.DefaultClient.Do(request.WithContext(ctx))\n\tif err!= nil {\n\t\tlogger.Error(\"failed to send request to send notification\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Check the response status code\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"failed to send notification\", zap.String(\"status\", response.Status))\n\t\treturn\n\t}\n\n\t// Close the response body\n\tdefer response.Body.Close()\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err!= nil {\n\t\tlogger.Error(\"failed to read response body\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Unmarshal the response body to a map\n\tvar responseMap map[string]interface{}\n\terr = json.Unmarshal(body, &responseMap)\n\tif err!= nil {\n\t\tlogger.Error(\"failed to unmarshal response body\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log the response\n\tlogger.Info(\"notification sent\", zap.Any(\"response\", responseMap))\n}", "CodeBleu_score": 41.4838511222383}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tlogger.Debug(\"Sending notification\", zap.String(\"name\", name), zap.Any(\"message\", message))\n\n\t// Marshal the message map to JSON\n\tjsonBytes, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create a new request to send the notification\n\trequest, err := http.NewRequest(\"POST\", \"http://notify-service:8080/send\", bytes.NewBuffer(jsonBytes))\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to create request\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Set the request headers\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\trequest.Header.Set(\"X-Notify-Name\", name)\n\n\t// Send the request to the notify service\n\tresponse, err := http.DefaultClient.Do(request)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to send request\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Check the response status code\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to send notification\", zap.Int(\"status\", response.StatusCode), zap.String(\"body\", response.Status))\n\t\treturn\n\t}\n\n\t// Close the response body\n\tdefer response.Body.Close()\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to read response body\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Unmarshal the response body to a map\n\tvar responseMap map[string]interface{}\n\terr = json.Unmarshal(body, &responseMap)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to unmarshal response body\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log the response details\n\tlogger.Info(\"Sent notification\", zap.String(\"name\", name), zap.Any(\"response\", responseMap))\n}", "CodeBleu_score": 38.46926882017216}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.messageBus == nil {\n\t\tc.messageBus = message_bus.NewClientWithResponses(c.address)\n\t}\n\treturn c.messageBus\n}", "CodeBleu_score": 23.877209351557845}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient, err := message_bus.NewClientWithResponses()\n\tif err!= nil {\n\t\tpanic(err)\n\t}\n\n\taddress, err := c.external.GetMessageBusAddress()\n\tif err!= nil {\n\t\tclient.SetServer(message_bus.NewDefaultErrorServer())\n\t\treturn client\n\t}\n\n\tclient.SetServer(message_bus.NewServer(address))\n\treturn client\n}", "CodeBleu_score": 38.18432826661636}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar messageBus *message_bus.ClientWithResponses\n\tvar err error\n\tif c.messageBusAddress == \"\" {\n\t\tc.messageBusAddress = message_bus.GetMessageBusAddress(c.runtimePath)\n\t}\n\tif c.messageBusAddress!= \"\" {\n\t\tmessageBus, err = message_bus.NewClientWithResponses(c.messageBusAddress)\n\t\tif err!= nil {\n\t\t\tc.messageBusAddress = message_bus.DefaultErrorMessage\n\t\t}\n\t} else {\n\t\tmessageBus, err = message_bus.NewClientWithResponses(message_bus.DefaultErrorMessage)\n\t}\n\treturn messageBus\n}", "CodeBleu_score": 32.847403620927516}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tif request == nil {\n\t\treturn \"\"\n\t}\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"\" {\n\t\treturn \"\"\n\t}\n\tips := strings.Split(ip, \",\")\n\tif len(ips) > 0 {\n\t\tip = ips[0]\n\t}\n\tip = strings.TrimSpace(ip)\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 64.15919287698402}, {"code": "func GetIP(request *http.Request) string{\n\t\t// Check for the \"x-forwarded-for\" header and extract the first IP\n\tips := strings.Split(request.Header.Get(\"x-forwarded-for\"), \",\")\n\tif len(ips) > 0 {\n\t\treturn strings.TrimSpace(ips[0])\n\t}\n\n\t// If the header is not available, use the request's remote address\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 47.96250982719752}, {"code": "func GetIP(request *http.Request) string{\n\t\tif request == nil {\n\t\treturn \"\"\n\t}\n\t// First check the \"x-forwarded-for\" header.\n\t// The \"x-forwarded-for\" header is a comma-separated list of IP addresses.\n\t// The first IP is the most recent and should be the one we want.\n\tips := strings.Split(request.Header.Get(\"X-Forwarded-For\"), \",\")\n\tif len(ips) > 0 && ips[0]!= \"\" {\n\t\t// Convert the loopback addresses \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\" before returning the IP address.\n\t\tip := strings.TrimSpace(ips[0])\n\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\tip = \"127.0.0.1\"\n\t\t}\n\t\treturn ip\n\t}\n\t// If the \"x-forwarded-for\" header is not available, use the request's remote address.\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\t// Convert the loopback addresses \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\" before returning the IP address.\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 50.65777725055002}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define paths for the modules directory and the entry file\n\tmodulesDir := filepath.Join(c.config.App.ModulesDir, \"modules\")\n\tentryFile := filepath.Join(c.config.App.ModulesDir, \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif err := c.createFile(entryFile); err!= nil {\n\t\tc.logger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read the modules directory\n\tmodules, err := os.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tc.logger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Initialize the JSON array for the entry file\n\tvar entries []interface{}\n\n\t// Loop through each module directory\n\tfor _, module := range modules {\n\t\t// Skip non-directories\n\t\tif!module.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Read the entry.json file in the module directory\n\t\tentryFile := filepath.Join(modulesDir, module.Name(), \"entry.json\")\n\t\tdata, err := os.ReadFile(entryFile)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Unmarshal the JSON data into an interface{}\n\t\tvar entry interface{}\n\t\tif err := json.Unmarshal(data, &entry); err!= nil {\n\t\t\tc.logger.Error(\"Failed to unmarshal entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the entry to the JSON array\n\t\tentries = append(entries, entry)\n\t}\n\n\t// Marshal the JSON array to JSON data\n\tdata, err := json.Marshal(entries)\n\tif err!= nil {\n\t\tc.logger.Error(\"Failed to marshal entries\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Write the JSON data to the entry file\n\tif err := os.WriteFile(entryFile, data, 0644); err!= nil {\n\t\tc.logger.Error(\"Failed to write entries\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 38.69083024087773}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif iface.Flags&net.FlagLoopback!= 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := iface.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"are you connected to the network?\")\n}", "CodeBleu_score": 53.36053886739202}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", errors.New(\"failed to get interfaces\")\n\t}\n\tfor _, iface := range ifaces {\n\t\tmac := iface.HardwareAddr.String()\n\t\tif mac == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\taddrs, err := iface.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", errors.New(\"failed to get addresses\")\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, name := range c.GetNet() {\n\t\t\t\tif name == ip.String() {\n\t\t\t\t\treturn mac, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"failed to get MAC address\")\n}", "CodeBleu_score": 50.43114325581355}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", errors.New(\"Failed to get network interfaces\")\n\t}\n\tnetworks, err := c.GetNet()\n\tif err!= nil {\n\t\treturn \"\", errors.New(\"Failed to get network names\")\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, net := range networks {\n\t\t\tif net.Name == iface.Name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching interface found\")\n}", "CodeBleu_score": 56.09899456694508}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tuint32_t requestCount = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\trc = EINVAL;\n\t} else {\n\t\t/* Add a reference to the request object */\n\t\ttaosAddRef(pRequest);\n\n\t\t/* Increment the request count for the TSC object */\n\t\trequestCount = atomic_add_fetch_32(&pTscObj->requestCount, 1);\n\n\t\t/* Update the application's request summary */\n\t\tif (pTscObj->pAppObj!= NULL) {\n\t\t\tatomic_add_fetch_32(&pTscObj->pAppObj->requestCount, 1);\n\t\t}\n\n\t\t/* Log debug information about the new request */\n\t\tif (gDebugLevel >= 3) {\n\t\t\tprintf(\"registerRequest: Request %p: requestCount=%u\n\", pRequest, requestCount);\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 35.77204469735932}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tint32_t i;\n\n\tif (pRequest == NULL) {\n\t\treturn TSC_ERR_INVALID_PARAM;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\treturn TSC_ERR_INVALID_PARAM;\n\t}\n\n\tif (pTscObj->pAppObj!= NULL) {\n\t\t/*\n\t\t * Update the application's request summary, including total and current request counts.\n\t\t */\n\t\tif (pTscObj->pAppObj->pRequestSummary!= NULL) {\n\t\t\t/*\n\t\t\t * Increment the total request count.\n\t\t\t */\n\t\t\tatomic_add_fetch_64(&(pTscObj->pAppObj->pRequestSummary->totalRequestCount), 1);\n\n\t\t\t/*\n\t\t\t * Increment the current request count.\n\t\t\t */\n\t\t\tatomic_add_fetch_64(&(pTscObj->pAppObj->pRequestSummary->currentRequestCount), 1);\n\t\t}\n\t}\n\n\t/*\n\t * Add a reference to the request object.\n\t */\n\ttaosAddRef(pRequest);\n\n\t/*\n\t * Increment the request count for the TSC object.\n\t */\n\tatomic_add_fetch_64(&(pTscObj->requestCount), 1);\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tif (pTscObj->debugLevel >= TSC_DEBUG_LEVEL_INFO) {\n\t\t/*\n\t\t * Log debug information about the new request.\n\t\t */\n\t\tif (pTscObj->debugLevel >= TSC_DEBUG_LEVEL_INFO) {\n\t\t\t/*\n\t\t\t * Log the request information.\n\t\t\t */\n\t\t\ttscDebug(pTscObj, TSC_DEBUG_LEVEL_INFO, \"registerRequest: request=%p, requestCount=%llu, requestSummary=%p, totalRequestCount=%llu, currentRequestCount=%llu\", pRequest, pTscObj->requestCount, pTscObj->pAppObj->pRequestSummary, pTscObj->pAppObj->pRequestSummary->totalRequestCount, pTscObj->pAppObj->pRequestSummary->currentRequestCount);\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 44.262972410603254}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc;\n\n\t/* Add a reference to the request object */\n\ttaosAddRef(pRequest);\n\n\t/* Increment the request count for the associated TSC object */\n\trc = taosAtomicAddFetch_64(pTscObj->pRequestCount, 1);\n\n\t/* Update the application's request summary, if applicable */\n\tif (pTscObj->pAppInfo!= NULL) {\n\t\t/* Update the application's total request count */\n\t\trc = taosAtomicAddFetch_64(pTscObj->pAppInfo->pTotalRequestCount, 1);\n\n\t\t/* Update the application's current request count */\n\t\trc = taosAtomicAddFetch_64(pTscObj->pAppInfo->pCurrentRequestCount, 1);\n\t}\n\n\t/* Log debug information about the new request */\n\tif (pTscObj->pDebugInfo!= NULL) {\n\t\t/* Log debug information about the new request */\n\t\trc = tscDebug(pTscObj, \"Registering request %p, request count = %\" PRIu64 \", app request count = %\" PRIu64, pRequest, pTscObj->pRequestCount, (pTscObj->pAppInfo == NULL)? 0 : pTscObj->pAppInfo->pCurrentRequestCount);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 45.118120031416495}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->primaryDb == NULL) {\n\t\treturn true;\n\t}\n\tif (strcmp(pRequest->primaryDb, exceptDb) == 0) {\n\t\treturn true;\n\t}\n\tint i = 0;\n\twhile (pRequest->dbs[i]!= NULL) {\n\t\tchar *db = pRequest->dbs[i];\n\t\tif (db[0] == '.') {\n\t\t\tdb++;\n\t\t}\n\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\treturn true;\n\t\t}\n\t\ti++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.53509978964843}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool result = false;\n\tif (code == RPC_REDIRECT_ERROR) {\n\t\tif (msgType!= MSG_RPC_RESPONSE) {\n\t\t\tresult = true;\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 28.154634760969078}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool result = false;\n\tswitch (code) {\n\t\tcase RPC_ERROR_CODE_NEED_REDIRECT:\n\t\t\tif (msgType!= MSG_TYPE_CLIENT_RPC_REQUEST) {\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_ERROR_CODE_NEED_REDIRECT_ERROR:\n\t\t\tif (msgType!= MSG_TYPE_CLIENT_RPC_REQUEST && msgType!= MSG_TYPE_CLIENT_RPC_REQUEST_ERROR) {\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn result;\n}", "CodeBleu_score": 33.403009096486414}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool ret = false;\n\tif (code == CLIENT_RPC_RFP_ERROR_CODE) {\n\t\tif (msgType!= CLIENT_RPC_RFP_MSG_TYPE_1 && msgType!= CLIENT_RPC_RFP_MSG_TYPE_2 && msgType!= CLIENT_RPC_RFP_MSG_TYPE_3) {\n\t\t\tret = true;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 36.233550847949616}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint64_t rid;\n\tint32_t ret;\n\tint32_t i;\n\tint32_t stopCount = 0;\n\tint32_t totalCount = 0;\n\tint32_t stopQueryCount = 0;\n\tint32_t totalQueryCount = 0;\n\tint32_t queryCount = 0;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\ttotalCount = taosHashCount(pRequests);\n\tfor (i = 0; i < totalCount; i++) {\n\t\tret = taosHashIterate(pRequests, &rid);\n\t\tif (ret == TAO_OK) {\n\t\t\tstopCount++;\n\t\t\tret = acquireRequest(rid);\n\t\t\tif (ret == TAO_OK) {\n\t\t\t\tstopQueryCount++;\n\t\t\t\tqueryCount = taos_stop_query(rid);\n\t\t\t\treleaseRequest(rid);\n\t\t\t}\n\t\t}\n\t}\n\ttotalQueryCount = taosHashCount(pRequests);\n\ttaos_log_info(\"Stop %d requests, %d queries\", stopCount, stopQueryCount);\n\tif (totalCount!= stopCount) {\n\t\ttaos_log_error(\"Stop %d requests, %d queries\", stopCount, stopQueryCount);\n\t}\n}", "CodeBleu_score": 36.83920210315159}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObjIter iter;\n\tSHashObj *pRequest;\n\tint64_t rid;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\ttaosInitHashIter(&iter, pRequests);\n\n\twhile ((pRequest = taosNextHashIter(&iter))!= NULL) {\n\t\trid = (int64_t)pRequest->key;\n\t\tacquireRequest(rid);\n\t\tif (pRequest->value!= NULL) {\n\t\t\ttaos_stop_query((TAOS_QUERY *)pRequest->value);\n\t\t}\n\t\treleaseRequest(rid);\n\t}\n}", "CodeBleu_score": 48.14790324567142}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashIter *pIter;\n\tSRequest *pRequest;\n\tint64_t rid;\n\n\tpIter = taosHashIterCreate(pRequests);\n\twhile (taosHashIterNext(pIter, &rid, (void **)&pRequest)) {\n\t\tif (pRequest->pQuery!= NULL) {\n\t\t\ttaos_stop_query(pRequest->pQuery);\n\t\t}\n\t\treleaseRequest(rid);\n\t}\n\ttaosHashIterDestroy(pIter);\n}", "CodeBleu_score": 42.53888324540075}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&tscCrashReportClientStop, 1, 0) == 0) {\n\t\ttscLog(LOG_ERROR, \"tscStopCrashReport: Crash report thread is already stopped.\");\n\t\treturn;\n\t}\n\n\twhile (tscCrashReportClientStop!= 0) {\n\t\ttaosMsleep(1);\n\t}\n}", "CodeBleu_score": 46.47914630294546}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0) == 0) {\n\t\ttscLog(TSC_LOG_ERROR, \"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\twhile (atomic_load_32(&clientStop)!= 0) {\n\t\ttaosMsleep(1);\n\t}\n}", "CodeBleu_score": 68.7434979777736}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&tscClientStop, 0, 1) == 0) {\n\t\ttscLog(TSC_LOG_ERROR, \"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\twhile (tscClientStop!= 0) {\n\t\ttaosMsleep(1);\n\t}\n}", "CodeBleu_score": 53.88153311794446}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tif (properties->content_length > 0) {\n\t\t*(S3UInt64 *)callbackData = properties->content_length;\n\t} else {\n\t\t*(S3UInt64 *)callbackData = 0;\n\t}\n\treturn status;\n}", "CodeBleu_score": 59.068763397672086}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3_LOG_DEBUG(\"Entering responsePropertiesCallback\n\");\n\n\tif (properties!= NULL) {\n\t\tif (properties->content_length > 0) {\n\t\t\t*(S3UInt64 *)callbackData = properties->content_length;\n\t\t} else {\n\t\t\t*(S3UInt64 *)callbackData = 0;\n\t\t}\n\t}\n\n\tS3_LOG_DEBUG(\"Exiting responsePropertiesCallback\n\");\n\treturn status;\n}", "CodeBleu_score": 50.708333598698104}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tif (properties->content_length > 0) {\n\t\t*(size_t *) callbackData = properties->content_length;\n\t} else {\n\t\t*(size_t *) callbackData = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 61.72339597663685}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosMkDir(tsCheckpointBackupDir, 0777)!= 0) {\n    uError(\"[rsync] mkdir %s error,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate config file error\");\n    return;\n  }\n\n#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointPort);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd)!= 0) {\n    uError(\"[rsync] start rsync error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 60.696447019669584}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  //  changeDirFromLinuxToWindows(tsCheckpointBackupDir);\n#endif\n\n  if (taosMkDir(tsCheckpointBackupDir, 0755) == -1) {\n    uError(\"[rsync] mkdir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n#ifdef WINDOWS\n  //  changeDirFromWindowsToLinux(tsCheckpointBackupDir);\n#endif\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir) == -1) {\n    uError(\"[rsync] generate config file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointPort);\n  if (system(cmd) == -1) {\n    uError(\"[rsync] start error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start success\");\n  }\n}", "CodeBleu_score": 56.32877270833306}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate checkpoint backup config file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n#ifdef WINDOWS\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%srsync.conf --port=%d\", path, tsCheckpointBackupPort);\n#else\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupPort);\n#endif\n  uDebug(\"[rsync] start checkpoint backup, cmd:%s\", cmd);\n  system(cmd);\n  uDebug(\"[rsync] start checkpoint backup success\");\n}", "CodeBleu_score": 55.7043809557627}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\t// get the dispatcher\n\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\t// if the dispatcher is found\n\tif (dispatcher!= null) {\n\t\t// shutdown the dispatcher\n\t\tdispatcher.shutdownNow();\n\t\t// remove the dispatcher\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\t// throw a runtime exception\n\t\tthrow new RuntimeException(\"The dispatcher with the specified ID is not registered.\");\n\t}\n}", "CodeBleu_score": 54.45839922384989}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatcherId == null) {\n\t\tthrow new IllegalArgumentException(\"The parameter 'dispatcherId' must not be null.\");\n\t}\n\tif (dispatcherId.isEmpty()) {\n\t\tthrow new IllegalArgumentException(\"The parameter 'dispatcherId' must not be an empty string.\");\n\t}\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"The dispatcher with the specified ID is not registered.\");\n\t}\n}", "CodeBleu_score": 36.82832342137799}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\t//TODO: implement\n}", "CodeBleu_score": 2.950171161196606}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t", "CodeBleu_score": 13.361017427649136}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\n//        getChildren(parent)\n//               .filter(childFilter)\n//               .forEach(child -> {\n//                    try {\n//                        tell(child, msg, highPriority);\n//                    } catch (TbActorNotRegisteredException e) {\n//                        warn(String.format(\"Could not send message to child actor %s of %s. Actor is not registered.\", child, parent));\n//                    }\n//                });\n//    }", "CodeBleu_score": 13.361017427649136}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t", "CodeBleu_score": 13.361017427649136}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (destroying.get() == DESTROYING) {\n            if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n                // If we are destroying and the message is a rule node updated message, we may try to reinitialize the actor\n                if (ready.get() == FAILED) {\n                    tryInit(1);\n                }\n            } else {\n                // If we are destroying and the message is not a rule node updated message, we notify the message that the actor has stopped\n                msg.onTbActorStopped();\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 56.02415836257132}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (msg.getType() == RULE_NODE_UPDATED_MSG) {\n//            if (destroying.get() == DESTROYING) {\n//                if (msg.getRuleNode().isRuleNodeUpdated()) {\n//                    if (ready.compareAndSet(NOT_READY, READY)) {\n//                        tryInit(1);\n//                    } else {\n//                        log.trace(\"[{}] Failed to reinitialize actor\", selfId);\n//                    }\n//                }\n//            }\n//        }\n//\n//        if (destroying.get() == NOT_DESTROYING) {\n//            if (highPriority) {\n//                highPriorityMsgs.add(msg);\n//                tryProcessQueue(true);\n//            } else {\n//                normalPriorityMsgs.add(msg);\n//                tryProcessQueue(true);\n//            }\n//        } else {\n//            msg.onTbActorStopped();\n//        }\n    }", "CodeBleu_score": 15.117759789936075}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (destroying.get() == DESTROYING) {\n            if (msg.getType() == RULE_NODE_UPDATED_MSG) {\n                // If we are in the process of destroying and the message is a high-priority RULE_NODE_UPDATED_MSG,\n                // we may need to reinitialize the actor\n                if (!reinitializing.get() &&!destroyed.get()) {\n                    dispatcher.getExecutor().execute(() -> tryInit(1));\n                }\n            } else {\n                msg.onActorStopped();\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 57.4717092766708}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\ty {\n    if (destroyInProgress.get()) {\n        return;\n    }\n    if (ready.get() == NOT_READY) {\n        return;\n    }\n    if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n        ready.set(FREE);\n        return;\n    }\n    int processed = 0;\n    while (processed < mailboxThroughput) {\n        TbActorMsg msg;\n        if (!highPriorityMsgs.isEmpty()) {\n            msg = highPriorityMsgs.poll();\n        } else {\n            msg = normalPriorityMsgs.poll();\n        }\n        if (msg == null) {\n            break;\n        }\n        try {\n            actor.process(msg);\n            processed++;\n        } catch (TbActorInitializationException e) {\n            stopReason = TbActorStopReason.INITIALIZATION_FAILURE;\n            destroy(e);\n            return;\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n            actor.processFailure(msg, t);\n            if (stopReason == null) {\n                stopReason = TbActorStopReason.PROCESS_FAILURE;\n            }\n            if (stopReason == TbActorStopReason.PROCESS_FAILURE) {\n                destroy(t);\n            }\n        }\n    }\n    if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n        ready.set(FREE);\n    }\n} catch (Throwable t) {\n    log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n}\n}", "CodeBleu_score": 47.28513194551125}, {"code": "private void processMailbox(){\n\ty {\n    // Check if the actor is stopped or destroyed\n    if (destroyInProgress.get()) {\n        // If the actor is stopped, destroy it\n        if (stopReason.isStopped()) {\n            actor.destroy(stopReason, null);\n        }\n        // If the actor is destroyed, stop processing the mailbox\n        return;\n    }\n\n    // Check if the actor is ready\n    if (ready.get() == NOT_READY) {\n        // If the actor is not ready, stop processing the mailbox\n        return;\n    }\n\n    // Process high priority messages\n    while (highPriorityMsgs.peek()!= null) {\n        TbActorMsg msg = highPriorityMsgs.poll();\n        try {\n            actor.process(msg);\n        } catch (TbActorInitializationException e) {\n            stopReason = TbActorStopReason.INITIALIZATION_FAILED;\n            destroy(e);\n            return;\n        } catch (Throwable t) {\n            log.error(\"[{}] Failed to process high priority message: {}\", selfId, t);\n            applyProcessFailureStrategy(t);\n            return;\n        }\n    }\n\n    // Process normal priority messages\n    while (normalPriorityMsgs.peek()!= null) {\n        TbActorMsg msg = normalPriorityMsgs.poll();\n        try {\n            actor.process(msg);\n        } catch (TbActorInitializationException e) {\n            stopReason = TbActorStopReason.INITIALIZATION_FAILED;\n            destroy(e);\n            return;\n        } catch (Throwable t) {\n            log.error(\"[{}] Failed to process normal priority message: {}\", selfId, t);\n            applyProcessFailureStrategy(t);\n            return;\n        }\n    }\n\n    // Set the actor's status to free and schedule a queue processing attempt\n    ready.set(READY);\n    tryProcessQueue(false);\n} catch (Throwable t) {\n    log.error(\"[{}] Failed to process mailbox: {}\", selfId, t);\n    applyProcessFailureStrategy(t);\n}\n}", "CodeBleu_score": 39.92911629724117}, {"code": "private void processMailbox(){\n\tocessMailbox:\n        try {\n            while (true) {\n                if (destroyInProgress.get()) {\n                    break processMailbox;\n                }\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    break processMailbox;\n                }\n                if (highPriorityMsgs.isEmpty()) {\n                    processNormalPriorityMsgs();\n                } else {\n                    processHighPriorityMsgs();\n                }\n            }\n            if (destroyInProgress.get()) {\n                return;\n            }\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                if (ready.compareAndSet(READY, FREE)) {\n                    tryProcessQueue(false);\n                }\n            }\n        } catch (Throwable t) {\n            if (destroyInProgress.get()) {\n                return;\n            }\n            if (stopReason == null) {\n                stopReason = TbActorStopReason.PROCESSING_FAILED;\n            }\n            destroy(t);\n        }\n    }", "CodeBleu_score": 28.361903253433766}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t// 1. Check if the tenant ID corresponds to the system tenant.\n    if (tenantId.isSysTenantId()) {\n        return true;\n    }\n// 2. Retrieve the tenant's profile.\n    ProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId, level, ignoreTenantNotFound);\n// 3. Fetch the rate limit configuration from the tenant profile.\n    RateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\n// 4. Check the rate limit.\n    if (rateLimitConfiguration.getRateLimit() == null) {\n        return true;\n    }\n// 5. Process a rate limit notification.\n    processRateLimitNotification(api, tenantId, rateLimitConfiguration);\n// 6. Return whether the rate limit check was successful.\n    return true;\n}", "CodeBleu_score": 28.56981474426895}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t//        if (tenantId.isSysTenantId()) {\n//            return true;\n//        }\n//\n//        TenantProfile tenantProfile = getTenantProfile(tenantId);\n//        RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n//        if (rateLimitConfiguration == null) {\n//            if (ignoreTenantNotFound) {\n//                return true;\n//            } else {\n//                throw new TenantProfileNotFoundException(tenantId);\n//            }\n//        }\n//\n//        RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n//        if (rateLimit == null) {\n//            return true;\n//        }\n//\n//        boolean exceeded = rateLimit.isExceeded(level);\n//        if (exceeded) {\n//            processRateLimitNotification(tenantId, api, level);\n//        }\n//\n//        return!exceeded;\n//    }", "CodeBleu_score": 5.262946726493438}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\t// \u8ba1\u7b97\u8fc7\u671f\u65f6\u95f4\n\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\t// \u904d\u5386 DTLS sessions map\n\tIterator<Map.Entry<String, DTLSServerSession>> it = dtlsSessions.entrySet().iterator();\n\t// \u904d\u5386 DTLS sessions map\n\twhile (it.hasNext()) {\n\t\tMap.Entry<String, DTLSServerSession> entry = it.next();\n\t\t// \u83b7\u53d6 DTLS sessions map \u7684 value\n\t\tDTLSServerSession session = entry.getValue();\n\t\t// \u83b7\u53d6 DTLS sessions map \u7684 value \u7684\u6700\u540e\u6d3b\u8dc3\u65f6\u95f4\n\t\tlong lastActivityTime = session.getLastActivityTime();\n\t\t// \u8fc7\u671f\u65f6\u95f4\u5927\u4e8e\u6700\u540e\u6d3b\u8dc3\u65f6\u95f4\n\t\tif (expirationTime > lastActivityTime) {\n\t\t\t// \u79fb\u9664 DTLS sessions map \u7684 value\n\t\t\tit.remove();\n\t\t\t// \u6253\u5370\u65e5\u5fd7\n\t\t\tlogger.trace(\"Removed DTLS session {} due to inactivity timeout.\", entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 44.840046231941535}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTimeMillis = System.currentTimeMillis();\n\tlong expirationTime = currentTimeMillis - inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(entry.getKey());\n\t\t\tlog.debug(\"Removed DTLS session {} due to timeout\", entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 40.4406367810806}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTimeMillis = System.currentTimeMillis();\n\tlong expirationTime = currentTimeMillis - inactivityTimeout;\n\tIterator<Map.Entry<String, DtlsSession>> iterator = dtlsSessions.entrySet().iterator();\n\twhile (iterator.hasNext()) {\n\t\tMap.Entry<String, DtlsSession> entry = iterator.next();\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tdtlsSessions.removeIf(entry::equals);\n\t\t\tlogger.debug(\"Removed DTLS session for \" + entry.getKey() + \" because it has been inactive for too long.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 33.64357889747551}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n} else {\nreturn timeseries.entrySet().stream().flatMap(entry -> entry.getValue().stream().map(value -> new TsKvEntry(entry.getKey(), parseValue(entry.getKey(), value))))\n.collect(Collectors.toList());\n}\n}", "CodeBleu_score": 23.155840575455397}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n}\nList<TsKvEntry> result = new ArrayList<>();\nfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\nString key = entry.getKey();\nList<JsonNode> values = entry.getValue();\nList<KvEntry> parsedValues = new ArrayList<>();\nfor (JsonNode value : values) {\nparsedValues.add(parseValue(key, value));\n}\nresult.add(new TsKvEntry(key, parsedValues));\n}\nreturn result;\n}", "CodeBleu_score": 38.735426061986644}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n}\nList<TsKvEntry> result = new ArrayList<>();\nfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\nString key = entry.getKey();\nList<JsonNode> values = entry.getValue();\nif (values.isEmpty()) {\ncontinue;\n}\nList<LongDataEntry> longDataEntries = new ArrayList<>();\nList<DoubleDataEntry> doubleDataEntries = new ArrayList<>();\nList<StringDataEntry> stringDataEntries = new ArrayList<>();\nList<BooleanDataEntry> booleanDataEntries = new ArrayList<>();\nList<JsonDataEntry> jsonDataEntries = new ArrayList<>();\nfor (JsonNode value : values) {\nKvEntry kvEntry = parseValue(key, value);\nif (kvEntry instanceof LongDataEntry) {\nlongDataEntries.add((LongDataEntry) kvEntry);\n} else if (kvEntry instanceof DoubleDataEntry) {\ndoubleDataEntries.add((DoubleDataEntry) kvEntry);\n} else if (kvEntry instanceof StringDataEntry) {\nstringDataEntries.add((StringDataEntry) kvEntry);\n} else if (kvEntry instanceof BooleanDataEntry) {\nbooleanDataEntries.add((BooleanDataEntry) kvEntry);\n} else if (kvEntry instanceof JsonDataEntry) {\njsonDataEntries.add((JsonDataEntry) kvEntry);\n} else {\nthrow new RuntimeException(CAN_T_PARSE_VALUE + value);\n}\n}\nresult.add(new TsKvEntry(key, longDataEntries, doubleDataEntries, stringDataEntries, booleanDataEntries, jsonDataEntries));\n}\nreturn result;\n}", "CodeBleu_score": 38.31437477762044}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\n//        Map<String, String> body = new HashMap<>();\n//        body.put(\"refreshToken\", this.refreshToken);\n//        body.put(\"grantType\", \"refresh_token\");\n//        body.put(\"clientId\", this.clientId);\n//        body.put(\"clientSecret\", this.clientSecret);\n//\n//        ResponseEntity<JsonNode> response = postForEntity(this.refreshTokenEndpoint, body);\n//        if (response.getStatusCode()!= HttpStatus.OK) {\n//            throw new AuthenticationException(\"Failed to refresh token\");\n//        }\n//\n//        setTokenInfo(currentTimeMillis(), response.getBody());\n//        this.refreshTokenExpTs = JWT.decode(this.refreshToken).getExpiresAtAsInstant().toEpochMilli();\n//        this.mainTokenExpTs = JWT.decode(this.mainToken).getExpiresAtAsInstant().toEpochMilli();\n//        this.clientServerTimeDiff = JWT.decode(this.mainToken).getIssuedAtAsInstant().toEpochMilli() - currentTimeMillis();\n//    }", "CodeBleu_score": 1.4566164722189534}, {"code": "public void refreshToken(){\n\t\nMap<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", this.refreshToken);\n        request.put(\"grantType\", \"refresh_token\");\n        request.put(\"clientId\", this.clientId);\n        request.put(\"clientSecret\", this.clientSecret);\n        request.put(\"scope\", this.scope);\n        request.put(\"tokenType\", \"refresh_token\");\n\n        ResponseEntity<JsonNode> response = postForEntity(this.tokenEndpoint, request);\n\n        if (response.getStatusCode() == HttpStatus.OK) {\n            JsonNode tokenInfo = response.getBody();\n            long ts = currentTimeMillis();\n            setTokenInfo(ts, tokenInfo);\n        }\n    }", "CodeBleu_score": 47.39729265497029}, {"code": "public void refreshToken(){\n\t//        Map<String, String> requestMap = new HashMap<>();\n//        requestMap.put(\"refreshToken\", this.refreshToken);\n//        try {\n//            ResponseEntity<String> response = this.restTemplate.postForEntity(this.authEndpoint, requestMap, String.class);\n//            if (response.getStatusCode() == HttpStatus.OK) {\n//                this.setTokenInfo(currentTimeMillis(), getBody(response));\n//            }\n//        } catch (Exception e) {\n//            logger.error(\"Error while refreshing token\", e);\n//        }\n    }", "CodeBleu_score": 1.6078250809239212}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t//        String url = \"http://localhost:8080/api/auth/login\";\n//        String url = \"http://192.168.1.200:8080/api/auth/login\";\n        String url = \"http://192.168.1.11:8080/api/auth/login\";\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", );\n        long ts = System.currentTimeMillis();\n        ResponseEntity<JsonNode> response = postForEntity(url, loginRequest);\n        if (response.getStatusCode() == HttpStatus.OK) {\n            setTokenInfo(ts, response.getBody());\n        } else {\n            throw new RuntimeException(\"Login failed\");\n        }\n    }", "CodeBleu_score": 56.14683845519923}, {"code": " private void doLogin(){\n\t//        System.out.println(\"doLogin\");\n        long ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", );\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<Map<String, String>> request = new HttpEntity<>(loginRequest, headers);\n        ResponseEntity<JsonNode> response = postForEntity(loginUrl, request, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 60.490389723236326}, {"code": " private void doLogin(){\n\t//        long ts = System.currentTimeMillis();\n//        Map<String, String> loginRequest = new HashMap<>();\n//        loginRequest.put(\"username\", username);\n//        loginRequest.put(\"password\", );\n//        ResponseEntity<JsonNode> response = postForEntity(\"/api/auth/login\", loginRequest);\n//        setTokenInfo(ts, response.getBody());\n//        LOGGER.info(\"Logged in successfully.\");\n//        LOGGER.info(\"Current token: \" + mainToken);\n//        LOGGER.info(\"Current refresh token: \" + refreshToken);\n//        LOGGER.info(\"Current token expiration time: \" + mainTokenExpTs);\n//        LOGGER.info(\"Current refresh token expiration time: \" + refreshTokenExpTs);\n//        LOGGER.info(\"Current client-server time difference: \" + clientServerTimeDiff);\n    }", "CodeBleu_score": 1.452003087170041}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> responseEntity = restTemplate.getForEntity(\n\t\t\t\t\"http://localhost:8080/api/device/{deviceId}\", Device.class, deviceId);\n\t\treturn Optional.of(responseEntity.getBody());\n\t} catch (HttpStatusCodeException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.51293389086567}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\tResponseEntity<Device> responseEntity = getForEntity(deviceId.toString(), Device.class);\n\tHttpStatus httpStatus = responseEntity.getStatusCode();\n\tif (httpStatus.is4xxClientError()) {\n\t\tthrow new DeviceNotFoundException(deviceId);\n\t}\n\treturn ofNullable(responseEntity.getBody());\n}", "CodeBleu_score": 35.37146262707036}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\t// 1. Create a URI template\n\tURI uri = UriComponentsBuilder.fromUriString(uri)\n\t\t.path(\"/api/device/{deviceId}\")\n\t\t.buildAndExpand(deviceId)\n\t\t.toUri();\n\n\t// 2. Send the GET request\n\tResponseEntity<Device> response = restTemplate.getForEntity(uri, Device.class);\n\n\t// 3. Return the device\n\treturn Optional.ofNullable(response.getBody());\n}", "CodeBleu_score": 40.59741310280856}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tDeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n\t\tResponseEntity<Device> response = postForEntity(deviceWithCredentials, \"/api/device-with-credentials\", Device.class);\n\t\treturn ofNullable(response.getBody());\n\t} catch (HttpStatusCodeException e) {\n\t\treturn empty();\n\t}\n}", "CodeBleu_score": 39.00657450948373}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nreturn ofNullable(postForEntity(device, credentials, Device.class));\n} catch (HttpStatusCodeException e) {\nif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn empty();\n}\nthrow e;\n}\n}", "CodeBleu_score": 23.373352328651727}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\treturn ofNullable(postForObject(device, credentials));\n}", "CodeBleu_score": 9.33403160626904}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}, {"code": "brightness(addr, val){\n\t/**\n * The function \"brightness\" adjusts the brightness of LED devices.\nIf only one argument is provided, it sets the brightness for all devices to the given value.\nIf two arguments are provided, it sets the brightness for the specified device address to the given value, mapped from a percentage (0-100) to a scale used by the LED controller (0-15).\nThe function returns the context object for method chaining.\n */\n    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.07739753123354}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n  val = addr;\n  this.each(function(device) {\n    this.brightness(device, val);\n  });\n} else {\n  this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n}\nreturn this;\n}", "CodeBleu_score": 97.49137623160196}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\nbound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\nif (this[key] && typeof this[key] === \"function\") {\nbound[key] = this[key].bind(this, addr);\n}\n});\nreturn bound;\n}", "CodeBleu_score": 96.20205970950842}, {"code": "device(addr){\n\tconst bound = {};\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\nbound[key] = this[key].bind(this, addr);\n});\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\nif (this[key] && typeof this[key] === \"function\") {\nbound[key] = this[key].bind(this, addr);\n}\n});\nreturn bound;\n}", "CodeBleu_score": 96.20205970950842}, {"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\nbound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\nif (this[key] && typeof this[key] === \"function\") {\nbound[key] = this[key].bind(this, addr);\n}\n});\nreturn bound;\n}", "CodeBleu_score": 96.20205970950842}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\tif (!target[method]) {\n\t\t\tconsole.warn(`Cannot install callback reconciliation for method ${method} on target ${target}`)\n\t\t\treturn\n\t\t}\n\t\ttarget[method + 'WithCallback'] = (callback, duration = 1000) => {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tconsole.warn(`Callback for method ${method} is not a function`)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst promises = []\n\t\t\tfor (let i = 0; i < target.length; i++) {\n\t\t\t\tpromises.push(target[i][method]())\n\t\t\t}\n\t\t\tPromise.all(promises).then(() => callback())\n\t\t}\n\t})\n}", "CodeBleu_score": 34.74067862139583}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (duration, callback) => {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tcallback = () => {}\n\t\t\t}\n\t\t\tlet promises = []\n\t\t\tthis.forEach(element => {\n\t\t\t\tpromises.push(element[method](duration))\n\t\t\t})\n\t\t\tPromise.all(promises).then(callback)\n\t\t}\n\t})\n}", "CodeBleu_score": 25.21515583926685}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\tif (!target[method]) {\n\t\t\tthrow new Error(`Method ${method} does not exist on target ${target}`)\n\t\t}\n\t\ttarget[method] = (...args) => {\n\t\t\tconst promises = []\n\t\t\tconst callback = args.pop()\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Last argument must be a function')\n\t\t\t}\n\t\t\tfor (let i = 0; i < target.length; i++) {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\ttarget[method](target[i],...args)\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t}, 1000)\n\t\t\t\t}))\n\t\t\t}\n\t\t\tPromise.all(promises).then(callback)\n\t\t}\n\t})\n}", "CodeBleu_score": 39.42821826111249}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 74.03081486126135}, {"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 74.03081486126135}, {"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 74.03081486126135}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t buffer_size;\n\tuint32_t active_channels;\n\n\t/* Check if the buffer size is sufficient to hold the data samples */\n\tbuffer_size = sequence->buffer_size;\n\tactive_channels = adc_channel_get_all_enabled(sequence->channels);\n\n\tif (buffer_size < active_channels * sequence->channels_length) {\n\t\tLOG_ERR(\"Insufficient buffer size provided\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Update the buffer size and active channels */\n\tdata->buffer_size = buffer_size;\n\tdata->active_channels = active_channels;\n\n\treturn 0;\n}", "CodeBleu_score": 49.740404111668155}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t buffer_size;\n\tint ret;\n\n\tif (sequence->options & ADC_ASYNC) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < sequence->buffer_size_max) {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sequence->buffer_size < (sequence->buffer_size_max / 2)) {\n\t\treturn -ENOMEM;\n\t}\n\n\tbuffer_size = sequence->buffer_size;\n\n\tret = adc_channel_get(dev, sequence->channel_id, &buffer_size);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (buffer_size < sequence->buffer_size_max) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.56593467377379}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t channel_mask = sequence->channels;\n\tuint32_t channel_count = 0;\n\tuint32_t buffer_size = 0;\n\n\t/* Calculate the number of active channels */\n\twhile (channel_mask) {\n\t\tif (channel_mask & 1) {\n\t\t\tchannel_count++;\n\t\t}\n\t\tchannel_mask >>= 1;\n\t}\n\n\t/* Calculate the buffer size based on the number of active channels and the size of each data sample */\n\tif (data->resolution == ADC_RESOLUTION_12BIT) {\n\t\tbuffer_size = channel_count * sizeof(uint16_t);\n\t} else if (data->resolution == ADC_RESOLUTION_10BIT) {\n\t\tbuffer_size = channel_count * sizeof(uint16_t);\n\t} else if (data->resolution == ADC_RESOLUTION_8BIT) {\n\t\tbuffer_size = channel_count * sizeof(uint8_t);\n\t}\n\n\t/* Check if the buffer size is sufficient */\n\tif (sequence->buffer_size < buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.14124906208697}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_context *ctx = &data->context;\n\tint ret;\n\n\tif (sequence->resolution!= data->resolution) {\n\t\tLOG_ERR(\"Invalid resolution %d, expected %d\", sequence->resolution,\n\t\t\tdata->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~data->channels) {\n\t\tLOG_ERR(\"Invalid channel mask %x, expected %x\", sequence->channels,\n\t\t\tdata->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tadc_context_start_read(ctx, sequence);\n\n\treturn adc_context_wait_for_completion(ctx);\n}", "CodeBleu_score": 58.93551560312731}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"ADC resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~config->channels) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tadc_context_start_read(dev, sequence);\n\tadc_context_wait_for_completion(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 66.20054159355406}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_context *ctx = &data->ctx;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"ADC resolution does not match device resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (channels > config->channels) {\n\t\tLOG_ERR(\"Invalid channels specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn ret;\n\t}\n\n\tret = adc_context_start_read(ctx, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to start ADC read context\");\n\t\treturn ret;\n\t}\n\n\tadc_context_wait_for_completion(ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 59.05657186347473}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\t// get the ADC data structure from the context\n\tstruct adc_data *adc = ctx->adc;\n\n\t// set the channels to be sampled\n\tadc->channels = ctx->channels;\n\n\t// initialize the repeat buffer with the data buffer\n\tadc->repeat_buffer = adc->data_buffer;\n\n\t// release a semaphore to signal the start of sampling\n\tk_sem_give(&adc->start_sem);\n}", "CodeBleu_score": 53.51346426641879}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tdata->channels = ctx->channels;\n\tdata->repeat_buffer = data->buffer;\n\tk_sem_give(&data->start_sem);\n}", "CodeBleu_score": 57.81962181763923}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tstruct adc_config *config = &data->config;\n\tstruct adc_channel_config *channel_config;\n\tstruct adc_channel_mask channel_mask;\n\tuint8_t i;\n\tuint8_t channel_count;\n\tuint8_t channel_index;\n\n\t/*\n\t * Retrieve the channel configuration from the context.\n\t */\n\tchannel_config = ctx->channel_config;\n\n\t/*\n\t * Clear the channel mask.\n\t */\n\tadc_channel_mask_clear(&channel_mask);\n\n\t/*\n\t * Set the channel mask.\n\t */\n\tchannel_count = config->channel_count;\n\tfor (i = 0; i < channel_count; i++) {\n\t\tchannel_index = channel_config[i].channel_index;\n\t\tadc_channel_mask_set_channel(&channel_mask, channel_index);\n\t}\n\n\t/*\n\t * Set the channel mask.\n\t */\n\tadc_set_channel_mask(&channel_mask);\n\n\t/*\n\t * Initialize the repeat buffer with the data buffer.\n\t */\n\tadc_repeat_buffer_init(data->repeat_buffer, data->buffer, config->buffer_resolution);\n\n\t/*\n\t * Release the semaphore to signal the start of sampling.\n\t */\n\tk_sem_give(&data->sem_start_sampling);\n}", "CodeBleu_score": 36.615915384266366}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = (struct adc_data_container *)ctx->adc_data_container;\n\n\tif (repeat_sampling) {\n\t\tadc_data_container->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tadc_data_container->buffer_pointer = adc_data_container->single_buffer;\n\t}\n}", "CodeBleu_score": 45.48111865002397}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\t/* Retrieve the ADC data container from the context */\n\tstruct adc_data_container *adc_data = adc_context_get_data_container(ctx);\n\n\t/* If repeat sampling is enabled, set the buffer pointer to the repeat buffer */\n\tif (repeat_sampling) {\n\t\tadc_data->buffer_pointer = adc_data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 53.13581752497337}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->adc_data_container = &ctx->repeat_buffer;\n\t} else {\n\t\tctx->adc_data_container = &ctx->buffer;\n\t}\n}", "CodeBleu_score": 35.80297709318319}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->config;\n\tstruct adc_context *context = &data->context;\n\tuint16_t *result = data->result;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (int i = 0; i < config->channels_num; i++) {\n\t\t\tret = adc_ad559x_read_channel(config->dev, config->channels[i], &result[i]);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", config->channels[i], ret);\n\t\t\t\tdata->context_complete = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tk_sem_give(&data->sem);\n\t}\n}", "CodeBleu_score": 41.84734617075779}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->config;\n\tstruct adc_context *ctx = data->ctx;\n\tstruct adc_channel_cfg *channel_cfg;\n\tuint8_t channel;\n\tuint16_t val;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->channel_cnt; channel++) {\n\t\t\tchannel_cfg = &ctx->channel_cfg[channel];\n\n\t\t\tret = adc_ad559x_read_channel(config->dev, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %u\", channel);\n\t\t\t\tdata->sampling_done = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tadc_context_update_buffer(ctx, channel_cfg, val);\n\t\t}\n\n\t\tif (data->sampling_done) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tadc_context_complete(ctx);\n}", "CodeBleu_score": 45.796260506905085}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\ttruct adc_context *ctx = &data->ctx;\n\tconst struct adc_ad559x_config *config = ctx->device->config;\n\tuint8_t channel;\n\tuint16_t val;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->channels; channel++) {\n\t\t\tif (!BIT(channel) & ctx->channel_mask) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(ctx->device, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tctx->flags |= ADC_CONTEXT_FLAG_ERROR;\n\t\t\t} else {\n\t\t\t\tctx->buffer[channel] = val;\n\t\t\t}\n\t\t}\n\n\t\tctx->flags |= ADC_CONTEXT_FLAG_COMPLETE;\n\t\tk_sem_give(&ctx->sem);\n\t}\n}", "CodeBleu_score": 45.79619918871452}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\n\tk_sleep(K_MSEC(config->ready_time));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\twhile ((reg_val & ADS1112_REG_CONFIG_DRDY)!= ADS1112_REG_CONFIG_DRDY) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 69.53719067910339}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\tk_sleep(K_MSEC(config->ready_time_ms));\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t\tk_sleep(K_USEC(100));\n\t} while ((reg_val & ADS1112_REG_CONFIG_DRDY) == 0);\n\treturn 0;\n}", "CodeBleu_score": 47.35228431022389}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[3] = {0};\n\tint rc = 0;\n\n\tk_sleep(K_USEC(config->ready_time_us));\n\n\trc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\twhile ((buf[2] & 0x80)!= 0) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.50455404105383}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\n\tif (sequence->options & ADC_SEQ_OPTION_CALIBRATE) {\n\t\tbuffer_size += 3;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_EXTRA_SAMPLING) {\n\t\tbuffer_size += sequence->extra_sampling;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_CONTINUOUS) {\n\t\tbuffer_size += sequence->buffer_size;\n\t}\n\n\tif (buffer_size < sequence->buffer_size) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.87870827514664}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t buffer_size;\n\tuint32_t required_buffer_size;\n\tuint32_t extra_samplings;\n\n\t/* Calculate the required buffer size based on the number of samplings, including any extra samplings specified in the sequence options. */\n\textra_samplings = sequence->options.extra_samplings;\n\trequired_buffer_size = sequence->num_samplings + extra_samplings;\n\n\t/* Calculate the buffer size based on the sequence buffer. */\n\tbuffer_size = sequence->buffer_size;\n\n\t/* Check if the buffer size is sufficient. */\n\tif (buffer_size < required_buffer_size) {\n\t\t/* Log an error message and return an error code if the buffer size is insufficient. */\n\t\tlog_error(\"Buffer size is insufficient for the ADC sequence. Required size: %d, Buffer size: %d\", required_buffer_size, buffer_size);\n\t\treturn -1;\n\t}\n\n\t/* Return 0 if the buffer size is sufficient. */\n\treturn 0;\n}", "CodeBleu_score": 42.53078813698932}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t required_buffer_size;\n\tint result;\n\n\tif (sequence->options & ADC_SEQ_OPTION_SINGLE_SHOT) {\n\t\trequired_buffer_size = 1;\n\t} else {\n\t\trequired_buffer_size = sequence->length + sequence->options & ADC_SEQ_OPTION_EXTRA_SAMPLINGS;\n\t}\n\n\tresult = adc_validate_buffer_size(sequence, required_buffer_size);\n\tif (result) {\n\t\tLOG_ERR(\"ADC buffer size is insufficient for the ADC sequence\");\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 40.323496856342}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->adc_sequence = sequence;\n\tdata->wait = wait;\n\n\tret = ads1112_adc_context_start_read(dev);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_adc_context_wait_for_completion(dev);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 60.29112760280946}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (!data) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tret = ads1112_adc_context_start_read(dev, sequence, wait);\n\n\treturn ret;\n}", "CodeBleu_score": 61.1996704131754}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (data->adc_context) {\n\t\tLOG_ERR(\"ADC read already in progress\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->adc_context = k_malloc(sizeof(struct ads1112_adc_context));\n\tif (!data->adc_context) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->adc_context->buffer = sequence->buffer;\n\tdata->adc_context->buffer_length = sequence->buffer_length;\n\tdata->adc_context->buffer_pos = 0;\n\tdata->adc_context->wait = wait;\n\n\tret = ads1112_adc_context_start_read(dev, sequence);\n\tif (ret < 0) {\n\t\tk_free(data->adc_context);\n\t\tdata->adc_context = NULL;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 49.8029588743638}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\tint i;\n\tstruct audio_codec_prop prop;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 2; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"rate\") == 0) {\n\t\t\tprop.rate = atoi(argv[i + 1]);\n\t\t\ti++;\n\t\t} else if (strcmp(argv[i], \"channels\") == 0) {\n\t\t\tprop.channels = atoi(argv[i + 1]);\n\t\t\ti++;\n\t\t} else if (strcmp(argv[i], \"format\") == 0) {\n\t\t\tprop.format = atoi(argv[i + 1]);\n\t\t\ti++;\n\t\t} else {\n\t\t\tshell_error(sh, \"Invalid argument\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = audio_codec_apply_properties(dev, &prop);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.148608098176865}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t", "CodeBleu_score": 34.52460135924148}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret = 0;\n\tstruct device *dev = NULL;\n\tstruct device_node_info *node_info = NULL;\n\tstruct audio_codec_properties *prop = NULL;\n\tconst struct audio_codec_driver *codec_driver = NULL;\n\tconst struct audio_codec_ops *codec_ops = NULL;\n\n\tif (argc!= 2) {\n\t\tshell_error(sh, \"Incorrect number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Get the device */\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Get the device node info */\n\tnode_info = device_node_info_get(dev);\n\tif (!node_info) {\n\t\tshell_error(sh, \"Failed to get device node info\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Get the codec driver */\n\tcodec_driver = device_driver_get_binding(node_info->driver);\n\tif (!codec_driver) {\n\t\tshell_error(sh, \"Failed to get codec driver\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Get the codec ops */\n\tcodec_ops = codec_driver->ops;\n\tif (!codec_ops) {\n\t\tshell_error(sh, \"Failed to get codec ops\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Allocate memory for the audio codec properties */\n\tprop = k_malloc(sizeof(struct audio_codec_properties));\n\tif (!prop) {\n\t\tshell_error(sh, \"Failed to allocate memory for properties\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Parse the input arguments */\n\tif (parse_args(sh, argc, argv, prop) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto free_prop;\n\t}\n\n\t/* Apply the audio codec properties */\n\tret = codec_ops->apply_properties(dev, prop);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t}\n\nfree_prop:\n\tk_free(prop);\n\treturn ret;\n}", "CodeBleu_score": 55.463102281125174}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\tint i2s_cmd = 0;\n\n\tif (data == NULL) {\n\t\tLOG_ERR(\"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase DM_TRIGGER_START:\n\t\tif (data->state == STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device already active\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\ti2s_cmd = I2S_CMD_START;\n\t\tbreak;\n\tcase DM_TRIGGER_STOP:\n\t\tif (data->state == STATE_INACTIVE) {\n\t\t\tLOG_ERR(\"Device already inactive\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\ti2s_cmd = I2S_CMD_STOP;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2s_send_cmd(data->i2s_dev, i2s_cmd);\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"Failed to send I2S command\");\n\t\treturn ret;\n\t}\n\n\tif (cmd == DM_TRIGGER_START) {\n\t\tdata->state = STATE_ACTIVE;\n\t} else {\n\t\tdata->state = STATE_INACTIVE;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 55.63082583755826}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_CONFIG) {\n\t\t\tret = mpxxdtyy_i2s_set_cmd(dev, MPXXDTYY_I2S_CMD_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"failed to set I2S start command\");\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"device not in CONFIG state\");\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_set_cmd(dev, MPXXDTYY_I2S_CMD_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIG;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"failed to set I2S stop command\");\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"device not in ACTIVE state\");\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"unsupported trigger command\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 53.054742697556144}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device is already active\");\n\t\t\tret = -EALREADY;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURING) {\n\t\t\tLOG_ERR(\"Device is already configuring\");\n\t\t\tret = -EALREADY;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = mpxxdtyy_i2s_cmd(dev, I2S_CMD_START);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to start I2S\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURING) {\n\t\t\tLOG_ERR(\"Device is still configuring\");\n\t\t\tret = -EALREADY;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data->state == MPXXDTYY_STATE_INACTIVE) {\n\t\t\tLOG_ERR(\"Device is already inactive\");\n\t\t\tret = -EALREADY;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = mpxxdtyy_i2s_cmd(dev, I2S_CMD_STOP);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to stop I2S\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_INACTIVE;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 49.79984034644549}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = config->display_mode_cmd;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_blink_enable) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t}\n\n\tif (config->cursor_enable) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 62.963934042436954}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tcmd |= (enabled? BIT(3) : 0);\n\tcmd |= (config->display_blink? BIT(2) : 0);\n\tcmd |= (config->cursor_blink? BIT(1) : 0);\n\tcmd |= (config->cursor_display? BIT(0) : 0);\n\n\tauxdisplay_hd44780_command(dev, 0, cmd, config->mode);\n}", "CodeBleu_score": 38.59317001905423}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t mode = 0;\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR) {\n\t\tmode |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK) {\n\t\tmode |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY) {\n\t\tmode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_BLINK) {\n\t\tmode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_BLINK;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT) {\n\t\tmode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT_RIGHT) {\n\t\tmode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT_RIGHT;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, AUXDISPLAY_HD44780_DISPLAY_MODE_SET | mode, AUXDISPLAY_HD44780_MODE_8_BIT);\n\n\tif (enabled) {\n\t\tconfig->display_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY;\n\t} else {\n\t\tconfig->display_mode &= ~AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY;\n\t}\n}", "CodeBleu_score": 48.93127108227977}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (config->busy_gpio.port == GPIO_PORT_NONE) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpio);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 74.5858592721379}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tuint32_t pin_status;\n\n\tif (config->busy_gpio_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin, &pin_status);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn pin_status;\n}", "CodeBleu_score": 68.22169606089399}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\n\tif (config->busy_gpio_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n\n\treturn ret;\n}", "CodeBleu_score": 71.66436649610162}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst struct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[config->special_command_prefix_length + 1];\n\n\t/* Construct the buffer */\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\t/* Write the buffer to the device */\n\tint ret = i2c_write_dt(&config->i2c, config->i2c_address, buffer,\n\t\t\t       sizeof(buffer), K_NO_WAIT);\n\n\t/* Introduce a delay */\n\tk_msleep(config->special_command_delay);\n\n\treturn ret;\n}", "CodeBleu_score": 62.020923409116655}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct i2c_msg msg;\n\tuint8_t buffer[3];\n\n\t/* Construct buffer */\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\t/* Write buffer to device */\n\tmsg.buf = buffer;\n\tmsg.len = 2;\n\tmsg.flags = 0;\n\n\tint ret = i2c_write_dt(&config->i2c, &msg, 1);\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* Wait for device to process command */\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn ret;\n}", "CodeBleu_score": 62.76685091889623}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write_dt(&config->i2c, config->i2c_address, buffer, 2);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2C write error\");\n\t\treturn ret;\n\t}\n\n\tk_msleep(config->special_command_delay_ms);\n\n\treturn 0;\n}", "CodeBleu_score": 61.54046375211462}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tconst struct bbram_emul_config *config = dev->config;\n\tuint8_t *mem = data_->mem;\n\n\tif (size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, mem + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 68.17006970807638}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tsize_t end_addr = offset + size;\n\n\tif (offset >= data_ptr->size) {\n\t\tLOG_ERR(\"Invalid offset\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (end_addr > data_ptr->size) {\n\t\tLOG_ERR(\"Invalid size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Invalid memory\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, data_ptr->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 59.341619966032574}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *ram = data_->ram;\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &ram[offset], size);\n\treturn 0;\n}", "CodeBleu_score": 51.60824790654613}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\n\tif (data_ptr->status.is_invalid) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data_ptr->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 63.25859859299493}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *memory = data_->memory;\n\tsize_t memory_size = data_->memory_size;\n\n\tif (size > memory_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (offset + size > memory_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(memory + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 60.882246880087386}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\n\tif (size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_ + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 64.97061653285763}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -1;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 71.32698615367283}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing required argument for BBRAM device\");\n\t\treturn -ENOENT;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Failed to find BBRAM device %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 75.83718713093253}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 84.33113275123247}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_uart_config *config = dev->config;\n\tstruct h4_uart_data *data = dev->data;\n\tsize_t num_read;\n\tsize_t bytes_remaining = data->header_bytes_remaining;\n\tuint8_t *buffer = data->header_buffer;\n\tint err;\n\n\tif (bytes_remaining == 0) {\n\t\treturn;\n\t}\n\n\tnum_read = data->header_bytes_read;\n\n\terr = uart_fifo_read(config, buffer + num_read, bytes_remaining, &num_read);\n\tif (err) {\n\t\tLOG_ERR(\"UART FIFO read failed\");\n\t\treturn;\n\t}\n\n\tdata->header_bytes_read += num_read;\n\tdata->header_bytes_remaining -= num_read;\n}", "CodeBleu_score": 47.842707222217854}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct uart_fifo_config *config = uart_fifo_get_config(dev);\n\tuint8_t *buf = config->buffer;\n\tsize_t len = config->len;\n\tsize_t read_len = 0;\n\tint ret;\n\n\tif (len == 0) {\n\t\treturn;\n\t}\n\n\t/* Read the header bytes from the UART FIFO */\n\tret = uart_fifo_read(dev, buf, len, &read_len);\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"Failed to read header from UART FIFO\");\n\t\treturn;\n\t}\n\n\t/* Update the remaining byte count */\n\tlen -= read_len;\n\tconfig->len = len;\n}", "CodeBleu_score": 43.463331988007646}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_uart_data *data = dev->data;\n\tuint8_t *buf = data->rx_buf;\n\tsize_t len = data->rx_len;\n\tsize_t rem = len - data->rx_cnt;\n\tsize_t cnt = uart_fifo_read(dev, buf + data->rx_cnt, rem);\n\tif (cnt < rem) {\n\t\tLOG_ERR(\"UART read failed\");\n\t}\n\tdata->rx_cnt += cnt;\n}", "CodeBleu_score": 34.410648976831595}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t i = 0;\n\twhile (i < len) {\n\t\tsize_t n = uart_fifo_read(uart, buf, MIN(len - i, 33));\n\t\tif (n == 0) {\n\t\t\tLOG_ERR(\"UART FIFO read failed\");\n\t\t\treturn 0;\n\t\t}\n\t\ti += n;\n\t}\n\treturn i;\n}", "CodeBleu_score": 41.88119088785292}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t bytes_read = 0;\n\tuint8_t buffer[33];\n\tint ret;\n\twhile (len > 0) {\n\t\tret = uart_fifo_read(uart, buffer, MIN(len, 33));\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"uart_fifo_read failed with code %d\", ret);\n\t\t\treturn bytes_read;\n\t\t}\n\t\tbytes_read += ret;\n\t\tlen -= ret;\n\t}\n\treturn bytes_read;\n}", "CodeBleu_score": 35.177634853890375}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read_len;\n\tsize_t ret;\n\n\tif (len > sizeof(buf)) {\n\t\treturn 0;\n\t}\n\n\tread_len = uart_fifo_read(uart, buf, len, K_NO_WAIT);\n\tif (read_len!= len) {\n\t\tLOG_ERR(\"UART FIFO read failed\");\n\t\treturn 0;\n\t}\n\n\tret = len;\n\twhile (len > 0) {\n\t\tif (uart_fifo_read(uart, buf, len, K_NO_WAIT)!= len) {\n\t\t\tLOG_ERR(\"UART FIFO read failed\");\n\t\t\treturn 0;\n\t\t}\n\t\tlen = 0;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 47.30422910893953}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *chan_data = chan->data;\n\tint priority = 0;\n\tint i;\n\n\t/* Lock the channel data */\n\tchan_data->lock();\n\n\t/* Iterate through the observers */\n\tfor (i = 0; i < ZBUS_CHANNEL_MAX_OBSERVERS; i++) {\n\t\t/* Check if the observer is enabled */\n\t\tif (chan_data->observers[i].enabled) {\n\t\t\t/* Check if the observer has a higher priority than the current highest */\n\t\t\tif (chan_data->observers[i].priority < priority) {\n\t\t\t\t/* Update the highest observer priority */\n\t\t\t\tpriority = chan_data->observers[i].priority;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the channel's highest observer priority to the determined value */\n\tchan->highest_observer_priority = priority;\n\n\t/* Unlock the channel data */\n\tchan_data->unlock();\n}", "CodeBleu_score": 24.56033078366957}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *data = (struct zbus_channel_data *)chan->data;\n\tuint8_t new_hop = data->highest_hop;\n\tuint8_t i;\n\tzbus_spinlock_lock(&data->lock);\n\tfor (i = 0; i < ZBUS_MAX_OBSERVERS; i++) {\n\t\tif (data->observers[i].enabled) {\n\t\t\tif (data->observers[i].priority < new_hop) {\n\t\t\t\tnew_hop = data->observers[i].priority;\n\t\t\t}\n\t\t}\n\t}\n\tdata->highest_hop = new_hop;\n\tzbus_spinlock_unlock(&data->lock);\n}", "CodeBleu_score": 25.168718720374482}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *data = chan->data;\n\tint highest_hop = 0;\n\tint i;\n\n\tZBUS_CHANNEL_DATA_LOCK(data);\n\tfor (i = 0; i < ZBUS_CHANNEL_MAX_OBSERVERS; i++) {\n\t\tif (data->observers[i].enabled) {\n\t\t\tif (data->observers[i].priority < highest_hop) {\n\t\t\t\thighest_hop = data->observers[i].priority;\n\t\t\t}\n\t\t}\n\t}\n\tZBUS_CHANNEL_DATA_UNLOCK(data);\n\tdata->highest_hop = highest_hop;\n}", "CodeBleu_score": 24.79695485288925}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_observers.observers_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_observers.observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\tif (observation->obs!= obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!observation->chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.26131804868385}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_data.observers_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_data.observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.572881395479587}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\tstruct zbus_channel *chan;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_data.observers_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_data.observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\tif (observation->obs == obs &&!observation_mask->enabled) {\n\t\t\t\tchan = observation->chan;\n\n\t\t\t\t__ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\t\t\t\tchan_update_hop(chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 15.958110807561274}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (k_is_in_isr()) {\n\t\t_ZBUS_ASSERT(false);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!obs) {\n\t\t_ZBUS_ASSERT(false);\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\n\tobs->prio = k_thread_priority_get(k_current_get());\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 32.658395271774}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (k_is_in_isr()) {\n\t\t_ZBUS_ASSERT(false, \"zbus_obs_attach_to_thread cannot be called from an ISR\");\n\t\treturn -EPERM;\n\t}\n\n\tif (obs == NULL) {\n\t\t_ZBUS_ASSERT(false, \"zbus_obs_attach_to_thread called with null observer\");\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tobs->priority = k_thread_priority_get(k_current_get());\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs->lock, key);\n\treturn 0;\n}", "CodeBleu_score": 35.26751716217154}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tK_ASSERT(k_is_in_isr() == 0);\n\tK_ASSERT(obs!= NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tobs->priority = k_thread_priority_get(k_current_get());\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 35.850297939094375}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\tint prio;\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 46.232230150899895}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\tk_timeout_t end_time = sys_timepoint_calc(timeout);\n\n\tint prio;\n\tint err = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 45.76988919380311}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\tk_timeout_t end_time = sys_timepoint_calc(timeout);\n\n\tint prio;\n\tint err = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 45.76988919380311}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (enable) {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MAC_ITR |= Int;\n\t\t} else {\n\t\t\tETH->MAC_ITR_AB |= Int;\n\t\t}\n\t} else {\n\t\tETH->MAC_ITR &= ~Int;\n\t\tETH->MAC_ITR_AB &= ~Int;\n\t}\n}", "CodeBleu_score": 32.91065151502177}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_FUNCTIONAL_STATE(enable));\n\tif (enable) {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->ETH_IER |= Int;\n\t\t} else {\n\t\t\tETH->ETH_IER_AB |= Int;\n\t\t}\n\t} else {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->ETH_IDR |= Int;\n\t\t} else {\n\t\t\tETH->ETH_IDR_AB |= Int;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.32954386665035}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tif (enable) {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MAC_IT_EN_REG |= Int;\n\t\t} else {\n\t\t\tETH->MAC_IT_EN_REG |= Int << 16;\n\t\t}\n\t} else {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MAC_IT_EN_REG &= ~Int;\n\t\t} else {\n\t\t\tETH->MAC_IT_EN_REG &= ~(Int << 16);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.72430205041509}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txDesc;\n\ttxDesc = ETH_TX_DESC_BASE;\n\twhile (txDesc->status & ETH_TX_DESC_OWN) {\n\t\ttxDesc++;\n\t\tif (txDesc >= (ETH_TX_DESC *) (ETH_TX_DESC_BASE + ETH_TX_DESC_NUM * sizeof(ETH_TX_DESC))) {\n\t\t\ttxDesc = (ETH_TX_DESC *) ETH_TX_DESC_BASE;\n\t\t}\n\t}\n\treturn txDesc;\n}", "CodeBleu_score": 44.31086441528223}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc = 0;\n\tuint32_t reg_val;\n\n\treg_val = ETH->DMATXDESC;\n\ttx_desc = (ETH_TX_DESC *) reg_val;\n\n\twhile (tx_desc->status & ETH_TX_DESC_OWN) {\n\t\tif (tx_desc == (ETH_TX_DESC *) ETH->DMATXDESC) {\n\t\t\treturn 0;\n\t\t}\n\t\ttx_desc = (ETH_TX_DESC *) ((uint32_t) tx_desc + 4);\n\t}\n\treturn tx_desc;\n}", "CodeBleu_score": 51.04930327864151}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txDesc = 0;\n\tuint32_t descAddr = ETH_GetTxDescAddr();\n\tuint32_t descStatus = ETH_GetTxDescStatus(descAddr);\n\twhile ((descStatus & ETH_TX_DESC_OWN) == ETH_TX_DESC_OWN) {\n\t\tdescAddr = (descAddr + sizeof(ETH_TX_DESC)) % ETH_TX_DESC_LIST_SIZE;\n\t\tdescStatus = ETH_GetTxDescStatus(descAddr);\n\t}\n\ttxDesc = (ETH_TX_DESC *) descAddr;\n\treturn txDesc;\n}", "CodeBleu_score": 31.35025302126483}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\n#ifdef RT_USING_LOG\n    rt_err_t ret = RT_EOK;\n#endif\n\n    RT_ASSERT(device!= RT_NULL);\n    RT_ASSERT(value!= RT_NULL);\n\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    /*\n     * Initialize and enable the DAC channel for the specified device.\n     * Assert that the device is not null and retrieve the corresponding DAC channel.\n     * Attempt to enable the DAC output with the specified value using the Cy_CSDIDAC_OutputEnable function.\n     * If the initialization fails, log an error message and return an error code; otherwise, return RT_EOK indicating success.\n     */\n    if (Cy_CSDIDAC_Init(cyp_dac_get_base(device), cyp_dac_channel)!= CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"Cy_CSDIDAC_Init failed\");\n        return -RT_ERROR;\n    }\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_get_base(device), cyp_dac_channel)!= CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable failed\");\n        return -RT_ERROR;\n    }\n\n    /*\n     * Set the output value for the DAC channel.\n     * Assert that the device is not null and retrieve the corresponding DAC channel.\n     * Attempt to set the output value for the DAC channel using the Cy_CSDIDAC_SetValue function.\n     * If the initialization fails, log an error message and return an error code; otherwise, return RT_EOK indicating success.\n     */\n    if (Cy_CSDIDAC_SetValue(cyp_dac_get_base(device), cyp_dac_channel, *value)!= CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"Cy_CSDIDAC_SetValue failed\");\n        return -RT_ERROR;\n    }\n\n    return ret;\n}", "CodeBleu_score": 48.802643728361865}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t#ifdef RT_USING_CSDIDAC\n    struct cyp_dac_device *dac = (struct cyp_dac_device *)device;\n    rt_err_t result = RT_EOK;\n    uint32_t cyp_dac_channel = 0;\n\n    RT_ASSERT(device!= RT_NULL);\n    RT_ASSERT(value!= RT_NULL);\n\n    if (dac->inited == RT_FALSE)\n    {\n        LOG_E(\"DAC device is not initialized\");\n        return -RT_ERROR;\n    }\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n    result = Cy_CSDIDAC_OutputEnable(dac->base, cyp_dac_channel, *value);\n    if (result!= CY_CSDIDAC_STATUS_OK)\n    {\n        LOG_E(\"DAC output enable failed\");\n        return -RT_ERROR;\n    }\n\n    return result;\n#else\n    RT_ASSERT(0);\n    return -RT_ERROR;\n#endif\n}", "CodeBleu_score": 55.032070816744614}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\trt_uint32_t cyp_dac_channel = 0;\n\trt_uint32_t cyp_adc_channel = 0;\n\n\tRT_ASSERT(device!= RT_NULL);\n\tcyp_dac_channel = cyp_dac_get_channel(channel);\n\tcyp_adc_channel = cyp_adc_get_channel(channel);\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value);\n\tif (result!= RT_EOK) {\n\t\trt_kprintf(\"Error: Cy_CSDIDAC_OutputEnable failed\n\");\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 54.4526289655362}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t read_size;\n\trt_uint8_t *p_buf = buf;\n\n\tif (addr + size > 0x00008000) {\n\t\trt_kprintf(\"ifx_flash_read_32k: invalid argument\n\");\n\t\treturn IFX_FLASH_LOG_E;\n\t}\n\n\tread_size = size;\n\tfor (i = 0; i < read_size; i++) {\n\t\t*p_buf++ = *(volatile rt_uint8_t *) (addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 44.73692782570146}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr > FLASH_END_ADDR) {\n\t\treturn IFX_FLASH_ERR_INVALID_ARG;\n\t}\n\telse if (addr + size > FLASH_END_ADDR) {\n\t\treturn IFX_FLASH_ERR_INVALID_ARG;\n\t}\n\telse {\n\t\trt_uint32_t i;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tbuf[i] = *(volatile rt_uint8_t *) (addr + i);\n\t\t}\n\t\treturn size;\n\t}\n}", "CodeBleu_score": 44.36146389589523}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t j;\n\trt_uint32_t read_size;\n\n\tif (addr + size > FLASH_END_ADDRESS) {\n\t\tLOG_E(\"Read address exceeds flash memory end address.\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tread_size = size;\n\tfor (i = 0; i < read_size; i += 4) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tbuf[i + j] = *((rt_uint8_t *) (addr + i + j));\n\t\t}\n\t}\n\n\treturn read_size;\n}", "CodeBleu_score": 48.6609397460412}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n\trt_uint32_t count = cyhal_timer_read(cyhal_timer);\n\treturn count;\n}", "CodeBleu_score": 60.34207607368959}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\trt_uint32_t count;\n\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *cy_timer = (cyhal_timer_t *)timer->parent.user_data;\n\tcount = cyhal_timer_read(cy_timer);\n\treturn count;\n}", "CodeBleu_score": 68.28613263722411}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\trt_uint32_t count;\n\tcyhal_timer_read(timer_obj, &count);\n\treturn count;\n}", "CodeBleu_score": 59.86588927278077}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.254098710312575}, {"code": "void dfs_lock(void){\n\t\twhile (rt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER)!= RT_EOK) {\n\t\tRT_ASSERT(0);\n\t}\n}", "CodeBleu_score": 30.43110013992419}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_mutex, RT_WAIT_FOREVER);\n}", "CodeBleu_score": 3.7812012864728524}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\tif (startfd < 0)\n\t{\n\t\tstartfd = 0;\n\t}\n\tif (startfd >= fdt->maxfd)\n\t{\n\t\tstartfd = 0;\n\t}\n\n\tfor (index = startfd; index < fdt->maxfd; index++)\n\t{\n\t\tif (fdt->fds[index] == NULL)\n\t\t{\n\t\t\tfd = index;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index == fdt->maxfd)\n\t{\n\t\tfd = fd_slot_expand(fdt, fdt->maxfd);\n\t\tif (fd < 0)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 45.1112082796948}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (fdt->fds[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\treturn fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 24.57764947217726}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint index;\n\n\t/* search from the specified index */\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/* search from the beginning */\n\tfor (index = 0; index < startfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/* expand the fd table */\n\treturn fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 37.584770828271544}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < RT_ERR_COUNT; i++) {\n\t\tif (rt_err_code[i] == error) {\n\t\t\treturn rt_err_str[i];\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 45.9951713907756}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < sizeof(error_strings) / sizeof(error_strings[0]); i++) {\n\t\tif (error_strings[i].error == error) {\n\t\t\treturn error_strings[i].string;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 58.754690213226034}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < RT_ERRNO_MAX; i++) {\n\t\tif (error == rt_errno[i]) {\n\t\t\treturn rt_strerror[i];\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 45.70639758959075}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_thread_idle_hook_table[rt_thread_idle_hook_index] == RT_NULL) {\n\t\trt_thread_idle_hook_table[rt_thread_idle_hook_index] = hook;\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 29.377141638656134}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\trt_spinlock_t *lock;\n\trt_thread_t thread;\n\trt_list_t *list;\n\trt_list_t *node;\n\n\tlock = &rt_thread_idle_lock;\n\tlevel = rt_hw_interrupt_disable();\n\trt_spin_lock(lock);\n\n\tif (rt_list_isempty(&rt_thread_idle_list)) {\n\t\trt_spin_unlock(lock);\n\t\trt_hw_interrupt_enable(level);\n\t\treturn -RT_EFULL;\n\t}\n\n\tlist = &rt_thread_idle_list;\n\tnode = list->next;\n\tthread = RT_LIST_ENTRY(node, rt_thread_t, tlist);\n\trt_list_remove(node);\n\trt_spin_unlock(lock);\n\n\trt_hw_interrupt_enable(level);\n\n\tthread->thread_idle_hook = hook;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 28.17677222626682}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\tstruct rt_thread *thread;\n\n\t/* lock the idle hook list */\n\tlevel = rt_hw_interrupt_disable();\n\t/* find an empty slot */\n\tfor (thread = rt_thread_idle_entry; thread!= RT_NULL; thread = thread->next) {\n\t\tif (thread->stack_size == 0) {\n\t\t\t/* assign the hook to the slot */\n\t\t\tthread->entry = hook;\n\t\t\t/* release the lock */\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\t/* return success */\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\t/* release the lock */\n\trt_hw_interrupt_enable(level);\n\t/* return error */\n\treturn -RT_EFULL;\n}", "CodeBleu_score": 37.58073693337006}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_list_t *idle_hook_list;\n\trt_list_t *idle_hook_list_entry;\n\n\t/* Lock the spinlock to ensure thread safety */\n\tlevel = rt_hw_interrupt_disable();\n\trt_enter_critical();\n\n\t/* Iterate through the idle hook list to find the specified hook */\n\tidle_hook_list = rt_thread_idle_get_hook_list();\n\trt_list_foreach(idle_hook_list_entry, idle_hook_list) {\n\t\t/* If the hook is found, set the corresponding entry to null and return a success code */\n\t\tif ((void *)idle_hook_list_entry->next == hook) {\n\t\t\tidle_hook_list_entry->next = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If the hook is not found, return an error code indicating that the operation is not supported */\n\tif (result!= RT_EOK) {\n\t\tresult = -RT_ENOSYS;\n\t}\n\n\t/* Unlock the spinlock and return the result */\n\trt_exit_critical();\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}", "CodeBleu_score": 31.01520169306371}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_thread_t thread;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* check thread is idle thread */\n\tif (thread!= RT_NULL)\n\t{\n\t\trt_err_t result = RT_EOK;\n\t\trt_list_t *list;\n\n\t\t/* lock the spinlock */\n\t\trt_spin_lock_irqsave(&rt_thread_idle_lock, level);\n\n\t\t/* iterate through the idle hook list */\n\t\tlist = rt_list_entry(rt_thread_idle_list.next, rt_list_t, list);\n\t\twhile (list!= RT_NULL)\n\t\t{\n\t\t\t/* check the idle hook */\n\t\t\tif (list->next == RT_NULL)\n\t\t\t{\n\t\t\t\t/* remove the idle hook */\n\t\t\t\tlist->next = RT_NULL;\n\t\t\t\tresult = RT_EOK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check the idle hook */\n\t\t\t\tif (list->next->next == RT_NULL)\n\t\t\t\t{\n\t\t\t\t\t/* remove the idle hook */\n\t\t\t\t\tlist->next = RT_NULL;\n\t\t\t\t\tresult = RT_EOK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* next list */\n\t\t\tlist = list->next;\n\t\t}\n\n\t\t/* unlock the spinlock */\n\t\trt_spin_unlock_irqrestore(&rt_thread_idle_lock, level);\n\n\t\t/* return result */\n\t\treturn result;\n\t}\n\telse\n\t{\n\t\t/* return error code */\n\t\treturn -RT_ERROR;\n\t}\n}", "CodeBleu_score": 46.37935834464083}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_list_t *list;\n\trt_list_t *node;\n\trt_thread_idle_hook_t *idle_hook;\n\n\t/* get idle hook list */\n\tlist = &rt_thread_idle_hook_list;\n\n\t/* lock the spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* find the idle hook */\n\trt_list_for_each(node, list) {\n\t\tidle_hook = rt_list_entry(node, rt_thread_idle_hook_t, list);\n\t\tif (idle_hook->hook == hook) {\n\t\t\t/* set the idle hook to null */\n\t\t\tidle_hook->hook = RT_NULL;\n\n\t\t\t/* unlock the spinlock */\n\t\t\trt_hw_interrupt_enable(level);\n\n\t\t\t/* return success */\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* unlock the spinlock */\n\trt_hw_interrupt_enable(level);\n\n\t/* return error */\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 29.853453861275725}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_base_t level;\n\trt_thread_t *thread;\n\n\t/*\n\t * Ensure the scheduler is unlocked.\n\t */\n\trt_scheduler_lock();\n\n\t/*\n\t * Dequeue and wake up each suspended thread from the list.\n\t */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\n\t\t/*\n\t\t * Set the thread's error code to the specified value.\n\t\t */\n\t\tthread->error = thread_error;\n\n\t\t/*\n\t\t * Wake up the thread.\n\t\t */\n\t\trt_thread_wakeup(thread);\n\n\t\t/*\n\t\t * Remove the thread from the suspension list.\n\t\t */\n\t\trt_list_remove(&thread->tlist);\n\t}\n\n\t/*\n\t * Ensure the scheduler is locked again.\n\t */\n\trt_scheduler_unlock();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.488153669905504}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t ret = RT_EOK;\n\trt_thread_t *thread = RT_NULL;\n\n\t/* Check the scheduler is unlocked */\n\tif (rt_scheduler_is_locked()) {\n\t\treturn -RT_EPERM;\n\t}\n\n\t/* Dequeue and wake up each suspended thread from the list */\n\twhile ((thread = rt_list_entry(susp_list->next, rt_thread_t, tlist))!= RT_NULL) {\n\t\t/* Dequeue the thread from the list */\n\t\trt_list_remove(&thread->tlist);\n\n\t\t/* Wake up the thread */\n\t\trt_thread_wakeup(thread);\n\n\t\t/* If the thread is suspended, then it will be resumed by the scheduler */\n\t\tif (thread->stat == RT_THREAD_SUSPEND) {\n\t\t\t/* Set the thread error */\n\t\t\tthread->error = thread_error;\n\n\t\t\t/* Set the thread state */\n\t\t\tthread->stat = RT_THREAD_READY;\n\n\t\t\t/* Set the thread priority */\n\t\t\trt_thread_priority_change(thread, thread->current_priority);\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 28.397592204887047}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t *thread;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\t\trt_thread_resume(thread);\n\t\trt_list_del(&thread->tlist);\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.611197473436103}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\tif (new_console!= RT_NULL && new_console!= old_console) {\n\t\trt_device_close(old_console);\n\t\trt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\trt_console_set_device(new_console);\n\t}\n\treturn old_console;\n}", "CodeBleu_score": 37.41200091787723}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\tif (old_console) {\n\t\trt_device_close(old_console);\n\t}\n\trt_device_t new_console = rt_device_find(name);\n\tif (new_console && (new_console!= old_console) && (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK)) {\n\t\trt_console_set_device(new_console);\n\t}\n\treturn old_console;\n}", "CodeBleu_score": 45.45780574557522}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\n\tif (new_console!= RT_NULL && new_console!= old_console) {\n\t\trt_device_close(old_console);\n\t\trt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\trt_console_set_device(new_console);\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 37.41200091787723}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\trt_list_t *list;\n\n\tswitch (type) {\n\t\tcase RT_OBJECT_CLASS_THREAD:\n\t\t\tlist = &rt_thread_list;\n\t\t\tbreak;\n\t\tcase RT_OBJECT_CLASS_MUTEX:\n\t\t\tlist = &rt_mutex_list;\n\t\t\tbreak;\n\t\tcase RT_OBJECT_CLASS_SEMAPHORE:\n\t\t\tlist = &rt_semaphore_list;\n\t\t\tbreak;\n\t\tcase RT_OBJECT_CLASS_MAILBOX:\n\t\t\tlist = &rt_mailbox_list;\n\t\t\tbreak;\n\t\tcase RT_OBJECT_CLASS_MESSAGEQUEUE:\n\t\t\tlist = &rt_mqueue_list;\n\t\t\tbreak;\n\t\tcase RT_OBJECT_CLASS_MEMHEAP:\n\t\t\tlist = &rt_memheap_list;\n\t\t\tbreak;\n\t\tcase RT_OBJECT_CLASS_DEVICE:\n\t\t\tlist = &rt_device_list;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -RT_ERROR;\n\t}\n\n\trt_spin_lock_irqsave(&rt_object_spinlock);\n\trt_list_for_each(list, rt_object_t, list, node) {\n\t\tcount++;\n\t}\n\trt_spin_unlock_irqrestore(&rt_object_spinlock);\n\n\treturn count;\n}", "CodeBleu_score": 41.58281322902523}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_object_information *info;\n\tstruct rt_list_head *list;\n\trt_spin_lock_irqsave(&rt_object_information_lock, flags);\n\tinfo = rt_object_information_get(type);\n\tlist = &info->list;\n\trt_list_for_each(list, rt_object, node) {\n\t\tcount++;\n\t}\n\trt_spin_unlock_irqrestore(&rt_object_information_lock, flags);\n\treturn count;\n}", "CodeBleu_score": 45.83819416140237}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\trt_list_t *list;\n\trt_object_t *object;\n\n\trt_spin_lock_irqsave(&rt_object_class_lock[type], flags);\n\tlist = &rt_object_class[type];\n\trt_list_for_each(object, list, list) {\n\t\tcount++;\n\t}\n\trt_spin_unlock_irqrestore(&rt_object_class_lock[type], flags);\n\n\treturn count;\n}", "CodeBleu_score": 38.9646647494814}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\tRT_OBJECT_HOOK_CALL(object, detach);\n\n\trt_object_information_t info = object->info;\n\trt_spin_lock_irqsave(&info->lock);\n\trt_list_remove(&info->list);\n\trt_spin_unlock_irqrestore(&info->lock);\n\tobject->type = 0;\n}", "CodeBleu_score": 23.725134283717065}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\t/* Call the hook function for detachment. */\n\tRT_OBJECT_HOOK_CALL(object, detach);\n\t/* Get the object's information structure. */\n\trt_object_info_t info = &(object->info);\n\t/* Lock the spinlock to ensure thread safety. */\n\trt_spin_lock_irqsave(&info->lock);\n\t/* Remove the object from its list. */\n\trt_list_remove(&(object->list));\n\t/* Unlock the spinlock. */\n\trt_spin_unlock_irqrestore(&info->lock);\n\t/* Set the object's type to zero. */\n\tobject->type = 0;\n}", "CodeBleu_score": 29.154426309895175}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\tRT_OBJECT_HOOK_CALL(object, detach);\n\trt_object_get_information(object);\n\trt_spin_lock_irqsave(&object->parent.parent.spinlock);\n\trt_list_remove(&object->parent.list);\n\trt_spin_unlock_irqrestore(&object->parent.parent.spinlock);\n\tobject->parent.type = RT_Object_Class_Type_None;\n}", "CodeBleu_score": 28.525494711783274}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result;\n\trt_base_t level;\n\tstruct rt_object_information *information;\n\n\t/* object check */\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (obj));\n\n\tinformation = rt_object_get_information((enum rt_object_class_type)obj->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\n\t/* remove from old list */\n\trt_list_remove(&(obj->list));\n\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\t/* reset object type */\n\tobj->type = RT_Object_Class_Null;\n\n\t/* free the memory of object */\n\tRT_KERNEL_FREE(obj);\n\n\treturn result;\n}", "CodeBleu_score": 42.11433938884936}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result;\n\trt_base_t level;\n\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (obj));\n\n\t/* remove from old list */\n\tlevel = rt_spin_lock_irqsave(&(obj->information->spinlock));\n\trt_list_remove(&(obj->list));\n\trt_spin_unlock_irqrestore(&(obj->information->spinlock), level);\n\n\t/* reset object type */\n\tobj->type = RT_Object_Class_Null;\n\n\t/* free the memory of object */\n\tRT_KERNEL_FREE(obj);\n\n\treturn result;\n}", "CodeBleu_score": 40.87502106567454}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n\t/* destroy the object */\n\tif (obj->destroy!= RT_NULL) {\n\t\trt_err_t res = obj->destroy(obj);\n\t\trt_object_delete(obj);\n\t\treturn res;\n\t}\n\n\trt_object_delete(obj);\n\treturn RT_EOK;\n}", "CodeBleu_score": 43.95053561231994}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\tthread_t thread;\n\trt_uint8_t thread_status;\n\n\tthread = rt_thread_self();\n\tthread_status = rt_sched_thread_get_stat(thread);\n\tif (thread_status!= RT_THREAD_CLOSE)\n\t{\n\t\trt_sched_lock_level_t slvl;\n\n\t\t/* enter critical */\n\t\trt_enter_critical();\n\n\t\t/* check if thread is already closed */\n\t\tthread_status = rt_sched_thread_get_stat(thread);\n\t\tif (thread_status!= RT_THREAD_CLOSE)\n\t\t{\n\t\t\t/* remove from schedule */\n\t\t\trt_sched_remove_thread(thread);\n\n\t\t\t/* release thread timer */\n\t\t\trt_timer_detach(&(thread->thread_timer));\n\n\t\t\t/* change stat */\n\t\t\trt_sched_thread_close(thread);\n\t\t}\n\n\t\t/* scheduler works are done */\n\t\trt_exit_critical_safe(slvl);\n\n\t\t/* enqueue defunct thread */\n\t\trt_thread_defunct_enqueue(thread);\n\t}\n\n\t/* trigger a context switch */\n\trt_schedule();\n}", "CodeBleu_score": 55.7144516330049}, {"code": "static void _thread_exit(void){\n\tdefined(RT_USING_HOOK)\n    rt_thread_t thread;\n    rt_uint8_t level;\n\n    thread = rt_thread_self();\n    level = rt_hw_interrupt_disable();\n    if (thread->stat == RT_THREAD_CLOSE)\n    {\n        rt_hw_interrupt_enable(level);\n        return;\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    /* thread exit hook */\n    rt_thread_exit_hook(thread);\n#endif\n\n    /* thread exit */\n    rt_thread_close(rt_thread_self());\n\n    /* trigger a context switch to the next thread */\n    rt_schedule();\n}", "CodeBleu_score": 59.478429368212595}, {"code": "static void _thread_exit(void){\n\tthread_t thread;\n\trt_err_t result;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* enter critical */\n\trt_enter_critical();\n\n\t/* close thread */\n\tresult = rt_thread_close(thread);\n\n\t/* check result */\n\tif (result == RT_EOK) {\n\t\t/* add to defunct thread list */\n\t\trt_thread_defunct_enqueue(thread);\n\t}\n\n\t/* exit critical */\n\trt_exit_critical();\n\n\t/* trigger context switch */\n\trt_schedule();\n}", "CodeBleu_score": 61.71941671515944}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread = (rt_thread_t) parameter;\n\tRT_ASSERT(thread!= RT_NULL);\n\trt_sched_lock();\n\tif (thread->stat == RT_THREAD_SUSPEND) {\n\t\tthread->error = -RT_ETIMEOUT;\n\t\trt_list_remove(&thread->tlist);\n\t\trt_list_insert_after(&rt_thread_ready_list, &thread->tlist);\n\t}\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 35.69692260617803}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t *thread = (rt_thread_t *)parameter;\n\trt_err_t result;\n\n\t/*\n\t * Check if the thread is valid.\n\t */\n\tif (thread == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if the scheduler is locked.\n\t */\n\tif (rt_sched_lock_nest > 0) {\n\t\treturn;\n\t}\n\n\t/*\n\t * Lock the scheduler.\n\t */\n\trt_sched_lock();\n\n\t/*\n\t * Check if the thread is suspended.\n\t */\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\t/*\n\t\t * Unlock the scheduler.\n\t\t */\n\t\trt_sched_unlock();\n\t\treturn;\n\t}\n\n\t/*\n\t * Set the thread's error number to a timeout value.\n\t */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/*\n\t * Remove the thread from the suspend list.\n\t */\n\tresult = rt_list_remove(&thread->tlist);\n\tRT_ASSERT(result == RT_EOK);\n\n\t/*\n\t * Insert the thread into the ready list.\n\t */\n\tresult = rt_list_insert_after(&rt_thread_ready_list, &thread->tlist);\n\tRT_ASSERT(result == RT_EOK);\n\n\t/*\n\t * Unlock the scheduler.\n\t */\n\trt_sched_unlock();\n}", "CodeBleu_score": 38.994282072109534}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t *thread;\n\tthread = (rt_thread_t *)parameter;\n\trt_err_t result;\n\tif (thread == RT_NULL) {\n\t\treturn;\n\t}\n\tresult = rt_object_get_type(&thread->parent.parent);\n\tRT_ASSERT(result == RT_Object_Class_Thread);\n\trt_sched_lock();\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_sched_unlock();\n\t\treturn;\n\t}\n\tthread->error = -RT_ETIMEOUT;\n\trt_list_remove(&thread->tlist);\n\trt_list_insert_after(&rt_thread_ready_list, &thread->tlist);\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 40.91208765338577}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spin_lock_irqsave(&thread->lock);\n\n\tif (thread->mutex_pending) {\n\t\trt_mutex_t mutex = thread->mutex_pending;\n\t\trt_list_t *node = rt_list_entry(thread->node.next, rt_list_t, node);\n\n\t\trt_list_remove(&thread->node);\n\t\tmutex->owner = RT_NULL;\n\t\tmutex->owner_thread = RT_NULL;\n\t\tmutex->waiting_thread = RT_NULL;\n\t\tthread->mutex_pending = RT_NULL;\n\n\t\trt_spin_unlock_irqrestore(&thread->lock);\n\t\trt_mutex_release(mutex);\n\t} else {\n\t\trt_spin_unlock_irqrestore(&thread->lock);\n\t}\n}", "CodeBleu_score": 32.63945002343853}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spin_lock_irqsave(&_thread_list_lock, flags);\n\trt_list_t *node = rt_list_entry(thread->thread_mutex_list.next, rt_list_t, next);\n\tif (node!= &thread->thread_mutex_list) {\n\t\trt_list_del(node);\n\t\trt_list_init(node);\n\t\trt_spin_unlock_irqrestore(&_thread_list_lock, flags);\n\t\trt_mutex_release(thread->thread_mutex);\n\t\trt_spin_lock_irqsave(&_thread_list_lock, flags);\n\t}\n\trt_spin_unlock_irqrestore(&_thread_list_lock, flags);\n}", "CodeBleu_score": 33.74348644129993}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_mutex_t mutex;\n\n\tlevel = rt_spin_lock_irqsave(&thread->spin_lock);\n\tif (thread->wait_obj!= RT_NULL) {\n\t\tmutex = (rt_mutex_t)thread->wait_obj;\n\t\trt_list_remove(&thread->tlist);\n\t\tthread->wait_obj = RT_NULL;\n\t\tmutex->owner = RT_NULL;\n\t}\n\trt_spin_unlock_irqrestore(&thread->spin_lock, level);\n\n\twhile (thread->take_mutex!= RT_NULL) {\n\t\trt_mutex_release(thread->take_mutex);\n\t}\n}", "CodeBleu_score": 36.091486473593186}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* thread startup */\n\tthread->stat = RT_THREAD_INIT;\n\n\t/* thread priority */\n\tthread->current_priority = thread->initial_priority;\n\tthread->static_priority = thread->initial_priority;\n\n\t/* thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* thread startup */\n\terror = rt_thread_resume(thread);\n\n\treturn error;\n}", "CodeBleu_score": 55.00570949155915}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\trt_thread_priority_t priority;\n\trt_uint32_t priority_mask;\n\trt_uint32_t priority_bits;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* check thread state */\n\tif (thread->stat!= RT_THREAD_INIT)\n\t{\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check thread type */\n\tif (thread->type!= RT_Thread_Thread)\n\t{\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get priority */\n\tpriority = rt_thread_priority_get(thread);\n\n\t/* calculate priority attributes */\n\tpriority_mask = (1 << priority) - 1;\n\tpriority_bits = 0;\n\n\twhile (priority_mask)\n\t{\n\t\tpriority_bits++;\n\t\tpriority_mask >>= 1;\n\t}\n\n\t/* set thread priority attributes */\n\tthread->priority_mask = priority_mask;\n\tthread->priority_bits = priority_bits;\n\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume the thread */\n\terror = rt_thread_resume(thread);\n\n\tif (error == RT_EOK)\n\t{\n\t\t/* trigger a scheduler */\n\t\trt_schedule();\n\t}\n\n\treturn error;\n}", "CodeBleu_score": 48.01429322956663}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_list_head;\n\trt_timer_t *timer;\n\trt_tick_t timeout;\n\n\ttimer_list_head = &timer_list[0];\n\tif (rt_list_isempty(timer_list_head)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\ttimer = rt_list_entry(timer_list_head->next, rt_timer_t, timer_list);\n\ttimeout = timer->timeout;\n\t*timeout_tick = timeout;\n\treturn RT_EOK;\n}", "CodeBleu_score": 42.083345822015396}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t", "CodeBleu_score": 5.182189237133654}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_skip_list;\n\trt_list_t *timer_list_entry;\n\trt_tick_t current_tick;\n\trt_tick_t next_timeout_tick;\n\n\t/* get the current tick */\n\tcurrent_tick = rt_tick_get();\n\n\t/* get the first skip list */\n\ttimer_skip_list = timer_list;\n\n\t/* if the skip list is not empty */\n\tif (!rt_list_isempty(timer_skip_list)) {\n\t\t/* get the first timer entry */\n\t\ttimer_list_entry = timer_skip_list->next;\n\n\t\t/* get the timeout tick */\n\t\tnext_timeout_tick = rt_list_entry(timer_list_entry, struct rt_timer, timer_list)->timeout;\n\n\t\t/* if the timeout tick is not in the past */\n\t\tif (next_timeout_tick > current_tick) {\n\t\t\t/* set the timeout tick */\n\t\t\t*timeout_tick = next_timeout_tick - current_tick;\n\n\t\t\t/* return the status */\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* return an error code */\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 43.1307521596642}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\n#ifdef RT_USING_TIMER_HOOK\n    rt_timer_t timer;\n#endif\n\n#ifdef RT_USING_TIMER_SOFT_COUNTDOWN\n    if (time == RT_TIMER_SOFT_COUNTDOWN)\n    {\n        time = RT_TICK_MAX;\n    }\n#endif\n\n#ifdef RT_USING_TIMER_SOFT_COUNTDOWN\n    if (time > RT_TICK_MAX)\n    {\n        return RT_NULL;\n    }\n#endif\n\n    /* create timer */\n    rt_object_t timer_obj = rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer_obj == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    rt_timer_t timer = (rt_timer_t) timer_obj;\n    _timer_init(timer, timeout, parameter, time, flag);\n\n#ifdef RT_USING_TIMER_HOOK\n    rt_timer_hook_insert(timer);\n#endif\n\n    return timer;\n}", "CodeBleu_score": 56.35516689876733}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_HEAP\n    rt_timer_t timer;\n\n    RT_ASSERT(timeout!= RT_NULL);\n\n    /* allocate memory for timer */\n    timer = (rt_timer_t)rt_object_allocate(&rt_timer_class);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n#else\n    RT_ASSERT(timeout!= RT_NULL);\n\n    rt_kprintf(\"RT_USING_HEAP is not enabled!\n\");\n\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 66.52155883343653}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\n#ifdef RT_USING_TIMER_ALL_SOFT\n    flag |= RT_TIMER_FLAG_SOFT_TIMER;\n#endif\n\n    rt_timer_t timer;\n    RT_ASSERT(timeout!= RT_NULL);\n\n    timer = (rt_timer_t) rt_object_allocate(&rt_timer_class);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* initialize timer name */\n    rt_strncpy(timer->parent.name, name, RT_NAME_MAX);\n\n    /* initialize timer list */\n    rt_list_init(&(timer->parent.list));\n\n    return timer;\n}", "CodeBleu_score": 65.72529860423089}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// If the request is not a valid API request, return a \"Not Found\" error response\n\tif!a.isValidRequest(req) {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\n\t// Create a recorder to capture the response\n\trec := httptest.NewRecorder()\n\n\t// Serve the request through the API router\n\ta.router.ServeHTTP(rec, req)\n\n\t// Copy the recorder's headers to the original response\n\tfor name, values := range rec.Header() {\n\t\tfor _, value := range values {\n\t\t\tres.Header().Add(name, value)\n\t\t}\n\t}\n\n\t// If the request is unauthorized, return a \"Not Authorized\" error response\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// If the request is authorized, forward it to the router\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 59.3247334296539}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a recorder to capture the response.\n\trec := httptest.NewRecorder()\n\n\t// Copy the response headers to the original response.\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\n\t// If the request is not authorized, send a \"Not Authorized\" error response.\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// If all handlers pass without unauthorized status, forward the request to the router.\n\ta.router.ServeHTTP(rec, req)\n\n\t// Copy the response headers to the original response.\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n}", "CodeBleu_score": 59.291126767666725}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder to capture the response.\n\trec := httptest.NewRecorder()\n\n\t// Call the first handler, which is the authentication handler.\n\ta.authHandler(rec, req)\n\n\t// If the authentication handler returns a \"401 Unauthorized\" status,\n\t// it sends a \"Not Authorized\" error response and stops further processing.\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// Otherwise, call the second handler, which is the router.\n\ta.router.ServeHTTP(res, req)\n\n\t// Copy the recorder's headers to the original response.\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n}", "CodeBleu_score": 67.49687462696036}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.assets.Open(path)\n\tif err!= nil {\n\t\thttp.Error(res, \"Not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\tcontentType := mime.TypeByExtension(filepath.Ext(path))\n\tres.Header().Set(\"Content-Type\", contentType)\n\tif _, err := io.Copy(res, asset); err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t}\n}", "CodeBleu_score": 44.61399208849992}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Retrieve the requested asset based on the URL path.\n\tasset, err := a.Asset(req.URL.Path)\n\tif err!= nil {\n\t\thttp.Error(res, \"Not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\t// Set the appropriate Content-Type header based on the file extension.\n\tres.Header().Set(\"Content-Type\", http.DetectContentType(asset))\n\t// Write the asset content to the response.\n\tres.Write(asset)\n}", "CodeBleu_score": 32.91133220196936}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tasset, err := a.assets.Get(path)\n\tif err!= nil {\n\t\thttp.Error(res, \"404 not found.\", http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", mime.TypeByExtension(filepath.Ext(path)))\n\tres.Write(asset)\n}", "CodeBleu_score": 36.86569276015881}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/v1/robots/\")\n\t// Find the robot with the specified name\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]interface{}{\n\t\t\t\"error\": fmt.Sprintf(\"No robot found with name %s\", robotName),\n\t\t})\n\t\treturn\n\t}\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\t// Convert the connections to JSON format\n\tjsonConnections, err := gobot.NewJSONConnection(connections)\n\tif err!= nil {\n\t\t// If the connections cannot be converted to JSON, write a JSON error message\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"Unable to convert connections to JSON\",\n\t\t})\n\t\treturn\n\t}\n\t// Write the JSON response containing the connections\n\ta.writeJSON(res, http.StatusOK, jsonConnections)\n}", "CodeBleu_score": 38.816596167500414}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\tname := req.URL.Query().Get(\"name\")\n\n\t// Find the corresponding robot using the master instance\n\trobot, err := a.master.Robot(name)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"error\": \"no robot found with name \" + name,\n\t\t})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := gobot.NewJSONConnection(connections)\n\tif err!= nil {\n\t\t// If there is an error converting the connections to JSON, write a JSON error message\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"error\": \"error converting connections to JSON\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\ta.writeJSON(res, jsonConnections)\n}", "CodeBleu_score": 44.56647021950346}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := req.URL.Query().Get(\"robot\")\n\n\t// Find the corresponding robot using the master instance\n\trobot, err := a.master.FindRobot(robotName)\n\tif err!= nil {\n\t\t// Write a JSON error message indicating that no robot was found with the specified name\n\t\ta.writeJSON(res, \"error\", fmt.Sprintf(\"No robot found with name %s\", robotName))\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// Write a JSON error message indicating that an error occurred while converting the connections to JSON format\n\t\ta.writeJSON(res, \"error\", \"An error occurred while converting the connections to JSON format\")\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 38.428587423278536}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(http.StatusOK)\n\t}\n}", "CodeBleu_score": 51.81185808873452}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized.\n\"))\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(\"Authorized.\n\"))\n\t}\n}", "CodeBleu_score": 50.82526464238877}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method!= \"GET\" {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(\"Hello \" + user + \"!\"))\n\t}\n}", "CodeBleu_score": 52.7614094555485}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - (slope * fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input) + intercept\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.2365580665121}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMax - slope * fromMax\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 53.9828369428099}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.980882267028065}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"No connection set for %s\", a.Name())\n\t}\n\tif!a.Connection().AnalogReadSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"Connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := a.sensorCfg.scale * float64(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 52.236721544854106}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif a.Connection() == nil {\n\t\treturn 0, 0, ErrNoConnection\n\t}\n\tif!a.Connection().AnalogRead {\n\t\treturn 0, 0, ErrNotSupported\n\t}\n\tpin := a.Pin\n\tif pin < 0 {\n\t\treturn 0, 0, ErrInvalidPin\n\t}\n\trawValue, err := a.Connection().AnalogRead(pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue := float64(rawValue) * a.sensorCfg.scale\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 44.80797659994187}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is not valid\")\n\t}\n\tif!a.Connection().AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\traw, err := a.Connection().AnalogReadPin(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := a.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.99654043020625}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 40.09414721088014}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(value int) float64 {\n\t\tslope := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\t\tintercept := toMin - slope*float64(fromMin)\n\t\treturn slope*float64(value) + intercept\n\t}\n}", "CodeBleu_score": 48.068830287265556}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}", "CodeBleu_score": 40.602250804276316}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(DefaultName)\n\td.AddEvent(VibrationEvent)\n\td.On(DataEvent, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(VibrationEvent, true)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 31.29390698494171}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.DefaultName = \"GrovePiezoVibrationSensorDriver\"\n\td.AddEvent(\"vibration\", events.NewEvent())\n\td.Event(\"data\").Attach(func(data interface{}) {\n\t\td.Publish(\"vibration\", data.(int))\n\t})\n\tif err := d.Event(\"data\").Attach(func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(\"vibration\", data)\n\t\t}\n\t}); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 55.954126417596925}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(DefaultName)\n\td.AddEvent(\"vibration\")\n\td.On(DataEvent, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(\"vibration\", true)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 31.918178238612626}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz < 0 {\n\t\treturn errors.New(\"Tone: frequency must be greater than 0\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"Tone: duration must be greater than 0\")\n\t}\n\tperiod := time.Duration(60000000 / hz)\n\ttempo := time.Duration(60000000 / d.Bpm)\n\td.On()\n\tfor i := 0; i < int(duration/tempo.Seconds()); i++ {\n\t\ttime.Sleep(period)\n\t\td.Off()\n\t\ttime.Sleep(period)\n\t}\n\td.Off()\n\treturn nil\n}", "CodeBleu_score": 32.47565640256471}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\td.Lock()\n\tdefer d.Unlock()\n\tif d.on {\n\t\treturn errors.New(\"buzzer is already on\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"invalid frequency\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"invalid duration\")\n\t}\n\td.on = true\n\td.hz = hz\n\td.duration = duration\n\td.On()\n\tgo func() {\n\t\tfor {\n\t\t\td.Off()\n\t\t\ttime.Sleep(time.Duration(d.period) * time.Millisecond)\n\t\t\td.On()\n\t\t\ttime.Sleep(time.Duration(d.period) * time.Millisecond)\n\t\t\tif d.duration <= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\td.duration -= 2 * d.period\n\t\t}\n\t\td.Lock()\n\t\td.on = false\n\t\td.Unlock()\n\t}()\n\treturn nil\n}", "CodeBleu_score": 28.14377579120547}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"Tone: frequency must be positive\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"Tone: duration must be positive\")\n\t}\n\tif d.bpm <= 0 {\n\t\treturn errors.New(\"Tone: tempo must be positive\")\n\t}\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\tif d.isPlaying {\n\t\treturn errors.New(\"Tone: tone is already playing\")\n\t}\n\td.isPlaying = true\n\td.hz = hz\n\td.duration = duration\n\td.period = time.Duration(float64(time.Second) / (d.bpm * hz))\n\tgo func() {\n\t\tdefer func() {\n\t\t\td.mu.Lock()\n\t\t\td.isPlaying = false\n\t\t\td.mu.Unlock()\n\t\t}()\n\t\tfor {\n\t\t\tif err := d.On(); err!= nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(d.period / 2)\n\t\t\tif err := d.Off(); err!= nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(d.period / 2)\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 30.357910232307766}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"cannot sleep without a sleep pin\")\n\t}\n\td.stopIfRunning()\n\tif err := d.digitalWrite(d.sleepPin, d.sleepActive); err!= nil {\n\t\treturn err\n\t}\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 48.49991186779773}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.221785502909565}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif!d.sleepPinSet {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, d.sleepPinLow)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.44159947809418}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 54.09139753273928}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.sys == nil {\n\t\treturn nil, NewError(\"AnalogPinsAdaptor\", \"System is not initialized\")\n\t}\n\tif a.pins == nil {\n\t\treturn nil, NewError(\"AnalogPinsAdaptor\", \"Pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, NewError(\"AnalogPinsAdaptor\", \"Unable to translate pin ID: %v\", err)\n\t}\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 45.87011434821242}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor: pins map not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params := a.translate(id)\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 42.073208383873876}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 60.39754526414518}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock\npin, err := a.digitalPin(id)\nif err!= nil {\nreturn err\n}\nsystem.WithPinDirectionOutput(pin, func() {\npin.Write(val)\n})\na.mutex.Unlock\nreturn nil\n}", "CodeBleu_score": 44.471004859035794}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\terr = pin.Write(val)\n\treturn err\n}", "CodeBleu_score": 64.79856817817199}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.connected {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor not connected\")\n\t}\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor has no pins\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\tif len(opts) > 0 {\n\t\t\tfor _, opt := range opts {\n\t\t\t\topt(pin)\n\t\t\t}\n\t\t}\n\t\treturn pin, nil\n\t}\n\tchip, line, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := a.NewDigitalPin(chip, line)\n\ta.initialize(pin)\n\ta.pins[id] = pin\n\tif len(opts) > 0 {\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 48.58764250392002}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.connected {\n\t\treturn nil, fmt.Errorf(\"digitalPin: adaptor is not connected\")\n\t}\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"digitalPin: no pins available\")\n\t}\n\tpin, ok := a.pins[id]\n\tif!ok {\n\t\tpin, err := a.translate(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = gobot.NewDigitalPin(pin.Name, pin.Pin, pin.DigitalPinOptions...)\n\t\ta.pins[id] = pin\n\t\tpin.ApplyOptions(opts...)\n\t\tpin.Initialize()\n\t\treturn pin, nil\n\t}\n\tpin.ApplyOptions(opts...)\n\treturn pin, nil\n}", "CodeBleu_score": 48.13330522904653}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.Connected() {\n\t\treturn nil, errors.New(\"digital pin adaptor is not connected\")\n\t}\n\n\tif len(a.Pins()) == 0 {\n\t\treturn nil, errors.New(\"digital pin adaptor has no pins\")\n\t}\n\n\tvar pin gobot.DigitalPiner\n\tif len(opts) > 0 {\n\t\tpin = a.Pins()[id]\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t} else {\n\t\tpin = a.Pins()[id]\n\t}\n\n\tif pin == nil {\n\t\tpin = a.NewDigitalPin(id)\n\t\tif err := pin.ApplyOptions(opts...); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.Pins()[id] = pin\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 47.918557037908215}]}
