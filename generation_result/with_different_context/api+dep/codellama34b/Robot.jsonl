{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Retrieve the list of required files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    if (download) {\n      // Check if each file exists locally\n      for (auto &file : files) {\n        // If the file doesn't exist locally, request the file and log the download action\n        if (!FileTransfer::FileExists(file)) {\n          RequestFile(file);\n          log_info(\"Downloaded file \\\"\" + file + \"\\\"\");\n        }\n        // Otherwise, log that the file is found in the cache\n        else {\n          log_info(\"File \\\"\" + file + \"\\\" found in cache\");\n        }\n      }\n    }\n\n    return files;\n  }", "CodeBleu_score": 67.17231588687683}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Retrieve the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if each file exists locally\n    if (download) {\n      for (auto &file : required_files) {\n        // If the file does not exist, request the file and log the download action\n        if (!FileTransfer::FileExists(file)) {\n          RequestFile(file);\n          log_info(\"Downloaded \" + file);\n        }\n        // Log that the file is found in the cache\n        else {\n          log_info(\"Found \" + file + \" in the cache\");\n        }\n      }\n    }\n\n    return required_files;\n  }", "CodeBleu_score": 69.04719474585337}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Download the files if requested\n    if (download) {\n      for (auto &file : required_files) {\n        if (!FileTransfer::FileExists(file)) {\n          RequestFile(file);\n          log_info(\"Downloaded file \\\"\" + file + \"\\\"\");\n        } else {\n          log_info(\"Found file \\\"\" + file + \"\\\" in cache\");\n        }\n      }\n    }\n\n    return required_files;\n  }", "CodeBleu_score": 69.3007979955249}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tREQUIRE_CARLA_EPISODE();\n  rpc::Actor actor;\n  auto parent_walker = Episode->GetActor(parent);\n  if (parent_walker == nullptr) {\n    RPC_THROW_ERROR(rpc::ActorNotFound(parent));\n  }\n  auto parent_walker_type = parent_walker->GetTypeId();\n  if (parent_walker_type.find(\"walker\") != std::string::npos) {\n    if (attachment_type == rpc::AttachmentType::Rigid) {\n      RPC_THROW_ERROR(rpc::InvalidParent(parent));\n    }\n    if (attachment_type == rpc::AttachmentType::SpringArm) {\n      if (transform.rotation.Pitch != 0.0f ||\n          transform.rotation.Roll != 0.0f ||\n          transform.rotation.Yaw != 0.0f) {\n        RPC_THROW_ERROR(rpc::InvalidParent(parent));\n      }\n      if (transform.location.x != 0.0f ||\n          transform.location.y != 0.0f) {\n        RPC_THROW_ERROR(rpc::InvalidParent(parent));\n      }\n    }\n  }\n  actor = Episode->SpawnActorWithParent(\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n  return actor;\n}", "CodeBleu_score": 47.52786811781684}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tif (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    geom::Vector3D translation = transform.location;\n    geom::Vector3D rotation = transform.rotation.GetForwardVector();\n    if (translation.x == 0 && translation.y == 0 &&\n        std::abs(translation.z) < geom::Math::Dot(rotation, translation)) {\n      std::cout << \"Warning: The spawned actor's translation is only in the 'z' axis. \"\n                << \"This can lead to ill-formed SpringArm or SpringArmGhost attachments. \"\n                << \"Please use a different translation vector.\" << std::endl;\n    }\n  }\n  return _pimpl->SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 55.14553326408957}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tREQUIRE_CARLA_EPISODE();\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    geom::Vector3D translation = transform.location;\n    if (std::abs(translation.x) < geom::Math::Dot(translation, translation) * std::numeric_limits<float>::epsilon() &&\n        std::abs(translation.y) < geom::Math::Dot(translation, translation) * std::numeric_limits<float>::epsilon()) {\n      if (std::abs(translation.z) < geom::Math::Dot(translation, translation) * std::numeric_limits<float>::epsilon()) {\n        CARLA_WARNING(\"SpawnActorWithParent: Attachment type is SpringArm or SpringArmGhost, but translation is only in the 'z' axis\");\n      } else {\n        CARLA_WARNING(\"SpawnActorWithParent: Attachment type is SpringArm or SpringArmGhost, but translation is only in the 'x' and 'y' axes\");\n      }\n    }\n  }\n  return _pimpl->SpawnActorWithParent(\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 55.40354021888363}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Retrieve token for G-buffer.\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\"simulator_get_gbuffer_token\", ActorId, GBufferId);\n\n  // Copy token data.\n  std::vector<unsigned char> token;\n  token.resize(token_data.size());\n  std::memcpy(token.data(), token_data.data(), token_data.size());\n\n  // Subscribe to streaming client.\n  _pimpl->streaming_client.Subscribe(std::move(token), std::move(callback));\n}", "CodeBleu_score": 66.78202582045118}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Retrieve the token for the G-buffer.\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\"simulator_get_gbuffer_token\", ActorId, GBufferId);\n\n  // Copy the token data.\n  std::vector<unsigned char> token(token_data.size());\n  std::memcpy(token.data(), token_data.data(), token.size());\n\n  // Subscribe to the streaming client.\n  _pimpl->streaming_client.Subscribe(\n        std::move(token),\n        callback);\n}", "CodeBleu_score": 66.76246321067195}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Retrieve the token for the G-buffer.\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\"simulator_get_gbuffer_token\", ActorId, GBufferId);\n\n  // Copy the token data.\n  std::vector<unsigned char> token(token_data.size());\n  std::memcpy(token.data(), token_data.data(), token.size());\n\n  // Subscribe to the streaming client using the provided callback function.\n  _pimpl->streaming_client.Subscribe(\n        std::move(token),\n        std::move(callback));\n}", "CodeBleu_score": 66.54554710997199}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> walker_navigation = _walker_navigation.load();\n  if (walker_navigation != nullptr) {\n    return walker_navigation;\n  }\n  walker_navigation = std::make_shared<WalkerNavigation>(_episode_proxy);\n  std::shared_ptr<WalkerNavigation> expected_null = nullptr;\n  if (_walker_navigation.compare_exchange_strong(expected_null, walker_navigation)) {\n    return walker_navigation;\n  }\n  return _walker_navigation.load();\n}", "CodeBleu_score": 53.54042225682447}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = GetNavigation();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(GetActor());\n    SetNavigation(navigation);\n  }\n  return navigation;\n}", "CodeBleu_score": 39.441633351604835}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n    if (!_walker_navigation.compare_exchange(navigation, navigation)) {\n      navigation = _walker_navigation.load();\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 53.50267614574493}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\ttime_point start = std::chrono::system_clock::now();\n  time_point end = start + timeout;\n\n  while (episode.GetState()->GetTimestamp() < frame) {\n\n    if (std::chrono::system_clock::now() > end) {\n      return false;\n    }\n\n    std::this_thread::yield();\n  }\n\n  episode.GetState()->SetTimestamp(frame);\n\n  return true;\n}", "CodeBleu_score": 43.0875750794807}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tconst auto end = std::chrono::system_clock::now() + timeout.to_chrono<std::chrono::milliseconds>();\n  while (std::chrono::system_clock::now() < end) {\n    if (episode.GetState()->GetTimestamp() < frame) {\n      std::this_thread::yield();\n    } else {\n      episode.GetState()->GetTrafficManager()->Tick();\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 43.889065400837765}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tconst auto end = std::chrono::system_clock::now() + timeout.to_chrono<std::chrono::milliseconds>();\n  while (std::chrono::system_clock::now() < end) {\n    if (episode.GetState()->GetTimestamp().frame < frame) {\n      std::this_thread::yield();\n    } else {\n      episode.GetState()->GetTrafficManager()->Tick();\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 45.600027440366}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tauto id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n    return GetEpisode(id);\n  }", "CodeBleu_score": 17.70031269839411}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t_client.LoadEpisode(map_name, reset_settings, map_layers);\n    return GetCurrentEpisode();\n  }", "CodeBleu_score": 17.035310104170524}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t// Make sure client is ready.\n    Ready();\n    // Send request to server.\n    _client.LoadEpisode(std::move(map_name), reset_settings, map_layers);\n    // Wait for the episode to be ready.\n    GetReadyCurrentEpisode();\n    // Return episode proxy.\n    return EpisodeProxy{shared_from_this()};\n  }", "CodeBleu_score": 20.193832361205725}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tREQUIRE_CARLA_EPISODE();\n  auto *walker = _episode->GetWalker(controller.GetParent());\n  DEBUG_ASSERT(walker != nullptr);\n  _episode->CreateNavigationIfMissing();\n  _episode->RegisterController(controller.GetId(), controller.GetParent());\n}", "CodeBleu_score": 48.55436472661571}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(controller.GetWalker() != nullptr);\n  DEBUG_ASSERT(controller.GetParent() == nullptr);\n  DEBUG_ASSERT(_episode != nullptr);\n  auto walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"Trying to register a controller with a walker that does not exist\"));\n  }\n  walker->GetId();\n  throw_exception(std::runtime_error(\"Trying to register a controller with a walker that does not exist\"));\n}", "CodeBleu_score": 63.46823114843524}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(_episode != nullptr);\n  auto walker = GetWalker(controller.GetParent());\n  DEBUG_ASSERT(walker != nullptr);\n  _episode->CreateNavigationIfMissing();\n  auto nav = _episode->GetNavigation();\n  DEBUG_ASSERT(nav != nullptr);\n  nav->RegisterWalker(controller.GetId(), walker->GetId());\n}", "CodeBleu_score": 62.10961812875693}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tREQUIRE_CARLA_EPISODE();\n  auto *actor_description = _client.GetActorDescription(blueprint);\n  auto result = _client.SpawnActorWithParent(\n      *actor_description,\n      transform,\n      parent != nullptr ? parent->GetId() : 0,\n      attachment_type,\n      socket_name);\n  if (result.HasError()) {\n    throw_exception(std::runtime_error(result.GetError().GetMessage()));\n  }\n  auto id = result.Get();\n  if (gc == GarbageCollectionPolicy::Inherit) {\n    gc = parent != nullptr ? parent->GetGarbageCollectionPolicy() : GarbageCollectionPolicy::Enabled;\n  }\n  auto actor = boost::make_shared<Actor>(\n      GetCurrentEpisode(),\n      id,\n      gc);\n  _episode->RegisterActor(actor);\n  log_debug(\"spawned actor\", actor->GetDisplayId());\n  return actor;\n}", "CodeBleu_score": 52.10144022314091}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tREQUIRE_CARLA_EPISODE();\n  auto description = blueprint.MakeActorDescription();\n  SharedPtr<Actor> actor = _episode->CreateActor(\n      std::move(description),\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n  if (actor == nullptr) {\n    return nullptr;\n  }\n  actor->SetGarbageCollectionPolicy(gc);\n  _client.SpawnActor(*actor);\n  log_debug(\"spawned actor\", actor->GetDisplayId());\n  return actor;\n}", "CodeBleu_score": 40.91390678464252}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tREQUIRE_CARLA_EPISODE();\n    auto *actor = _episode->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n    _client.SpawnActor(*actor);\n    return SharedPtr<Actor>(actor);\n  }", "CodeBleu_score": 26.587369637805796}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tREQUIRE_CARLA_EPISODE();\n  auto ep = EpisodeProxy{shared_from_this(), _episode};\n  DEBUG_ASSERT(sensor.GetActorDescription().GetStreamToken().has_value());\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken().value(),\n      [ep, sensor, callback](auto buffer) {\n        auto data = sensor::Deserializer::Deserialize(\n            std::move(buffer),\n            sensor.GetActorDescription().GetSensorType());\n        data->SetEpisode(ep);\n        callback(std::move(data));\n      });\n}", "CodeBleu_score": 56.93387773106424}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tREQUIRE_CARLA_EPISODE();\n  auto ep = GetCurrentEpisode();\n  DEBUG_ASSERT(ep != nullptr);\n  auto stream = sensor.GetActorDescription().GetStreamToken();\n  DEBUG_ASSERT(stream != nullptr);\n  ep->Lock()->SubscribeToStream(\n      *stream,\n      [cb=std::move(callback), ep, weak=WeakPtr<Simulator>(SharedPtr<Simulator>(this)), sensor](auto buffer) {\n        auto data = sensor::Deserializer::Deserialize(buffer);\n        data->SetEpisode(ep);\n        data->_episode = ep;\n        cb(std::move(data));\n      });\n}", "CodeBleu_score": 65.93200570565212}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tREQUIRE_CARLA_EPISODE();\n  auto ep = EpisodeProxy{_episode};\n  DEBUG_ASSERT(ep.IsValid());\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [ep, sensor, callback](auto buffer) {\n        SharedPtr<sensor::SensorData> sensor_data = sensor::Deserializer::Deserialize(\n            buffer,\n            sensor.GetActorDescription().GetSensorType());\n        if (sensor_data != nullptr) {\n          sensor_data->SetEpisode(ep);\n          callback(std::move(sensor_data));\n        }\n      });\n}", "CodeBleu_score": 48.87054792067208}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get the current walkers\n    auto walkers = _walkers.Load();\n\n    // if there are none, return\n    if (walkers->empty())\n      return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove walkers that no longer exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd\n    _nav.UpdateCrowd(state->GetTimeStamp());\n\n    // prepare batch commands\n    std::vector<carla::rpc::Command> commands;\n    commands.reserve(walkers->size());\n\n    // get the walker speed\n    const float walker_speed = _nav.GetWalkerSpeed();\n\n    // for each walker\n    for (auto &&walker : *walkers) {\n\n      // get the transform\n      carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n\n      // get the speed\n      float speed = walker_speed;\n\n      // if the walker is alive\n      if (_nav.IsWalkerAlive(walker.walker)) {\n\n        // get the speed\n        speed = _nav.GetWalkerSpeed(walker.walker);\n\n        // if the walker is dead\n      } else {\n\n        // set the transform\n        transform = _nav.GetWalkerTransform(walker.walker);\n\n        // set the speed\n        speed = 0.0f;\n\n        // set the walker dead\n        _nav.SetWalkerDead(walker.walker);\n\n        // set the walker dead\n        _simulator.lock()->SetActorCollisions(walker.walker, false);\n\n      }\n\n      // set the transform\n      commands.emplace_back(carla::rpc::Command::ApplyWalkerState(walker.walker, transform, speed));\n\n    }\n\n    // apply batch sync\n    _sim", "CodeBleu_score": 59.69530057964507}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get current walkers\n    auto walkers = _walkers.Load();\n\n    // check if list is empty\n    if (walkers->empty())\n      return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove walkers that no longer exist\n    CheckIfWalkerExist(std::move(walkers), *state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update crowd\n    _nav.UpdateCrowd();\n\n    // create commands\n    std::vector<carla::nav::WalkerCommand> commands;\n    commands.reserve(walkers->size());\n\n    // get the crowd\n    const dtCrowd *crowd = _nav.GetCrowd();\n\n    // for each walker\n    for (auto &&walker : *walkers) {\n      // get the agent\n      const dtCrowdAgent *agent = crowd->getAgent(walker.walker);\n      // check if agent is valid\n      if (agent) {\n        // get the transform\n        carla::geom::Transform transform = _nav.GetWalkerTransform(walker.walker);\n        // get the speed\n        float speed = _nav.GetWalkerSpeed(walker.walker);\n        // add to the commands\n        commands.emplace_back(carla::nav::WalkerCommand{walker.walker, transform, speed});\n      }\n    }\n\n    // apply batch sync\n    _simulator.lock()->ApplyBatchSync(commands, true);\n\n    // check if any walker is dead\n    for (auto &&walker : *walkers) {\n      // get the agent\n      const dtCrowdAgent *agent = crowd->getAgent(walker.walker);\n      // check if agent is valid\n      if (agent) {\n        // check if it is dead\n        if (!_nav.IsWalkerAlive(walker.walker)) {\n          // remove from the crowd\n          _nav.RemoveAgent(walker.walker);\n          //", "CodeBleu_score": 62.20124913452329}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get current walkers\n    auto walkers = _walkers.Load();\n\n    // if there are no walkers, return\n    if (walkers->empty())\n      return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove any walkers that no longer exist\n    CheckIfWalkerExist(*walkers, *state);\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode);\n\n    // update the crowd\n    _nav.UpdateCrowd(state->GetTimeStamp());\n\n    // prepare the batch\n    std::vector<carla::command::Command> commands;\n    commands.reserve(walkers->size());\n\n    // for each walker\n    for (auto &&walker : *walkers) {\n\n      // get the walker transform and speed\n      carla::geom::Transform transform = _nav.GetWalkerTransform(walker.walker);\n      float speed = _nav.GetWalkerSpeed(walker.walker);\n\n      // apply the transform and speed in a batch\n      commands.emplace_back(carla::command::ApplyWalkerState{walker.walker, transform, speed});\n\n      // check if the walker is dead\n      if (!_nav.IsWalkerAlive(walker.walker)) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n\n    }\n\n    // apply the batch\n    _simulator.lock()->ApplyBatchSync(std::move(commands), true);\n\n  }", "CodeBleu_score": 57.58862475510236}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(_attributes.size());\n  for (const auto &attribute : _attributes) {\n    description.attributes.push_back(attribute.first);\n  }\n  return description;\n}", "CodeBleu_score": 79.75401775977168}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.push_back(attribute->MakeAttributeDescription());\n  }\n  return description;\n}", "CodeBleu_score": 73.21008970381075}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &&attribute : _attributes) {\n    description.attributes.push_back(attribute.second.GetRpcAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 73.02642845681389}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n  for (auto &pair : _blueprints) {\n    if (pair.second.ContainsAttribute(name)) {\n      if (pair.second.GetAttribute(name).GetValue() == value) {\n        result->Add(pair.second);\n      }\n    } else if (pair.second.GetRecommendedValues().ContainsAttribute(name)) {\n      if (pair.second.GetRecommendedValues().GetAttribute(name).GetValue() == value) {\n        result->Add(pair.second);\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 45.65920064533727}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n    for (const auto &pair : blueprints_) {\n        if (pair.second.ContainsAttribute(name)) {\n            if (pair.second.GetAttribute(name).GetValue() == value ||\n                pair.second.GetAttribute(name).GetRecommendedValues().Contains(value)) {\n                result->AddBlueprint(pair.second);\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 39.9247794269792}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (auto &pair : blueprints_) {\n    if (pair.second.ContainsAttribute(name)) {\n      if (pair.second.GetAttribute(name) == value) {\n        result->AddBlueprint(pair.first, pair.second);\n      }\n    } else if (pair.second.GetRecommendedValues().count(name) > 0) {\n      if (pair.second.GetRecommendedValues().at(name).Contains(value)) {\n        result->AddBlueprint(pair.first, pair.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 43.424706441098394}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string full_path = GetFullFilePath(path);\n    if (!ValidateFilePath(full_path)) {\n        return false;\n    }\n\n    std::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n    if (!out.good()) {\n        return false;\n    }\n\n    out.write(reinterpret_cast<char*>(content.data()), content.size());\n    out.close();\n\n    return true;\n}", "CodeBleu_score": 47.70425512318796}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string full_path = _base_path + path;\n    if (!FileSystem::ValidateFilePath(full_path)) {\n        return false;\n    }\n    std::ofstream out(full_path, std::ios::binary);\n    if (!out.good()) {\n        out.close();\n        return false;\n    }\n    out.write(reinterpret_cast<const char*>(content.data()), content.size());\n    out.close();\n    return true;\n}", "CodeBleu_score": 44.067111217067556}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string full_path = GetFullPath(path);\n  if (!ValidateFilePath(full_path)) {\n    return false;\n  }\n  std::ofstream out(full_path, std::ios::binary);\n  if (!out.good()) {\n    return false;\n  }\n  out.write(reinterpret_cast<char *>(content.data()), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 41.62209738706344}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tgeom::Location location = geom::Math::Rotate(transform.rotation.yaw, transform.location);\n    location.x += parent_bounding_box_location.x;\n    location.y += parent_bounding_box_location.y;\n\n    geom::Vector3D extents = parent_bounding_box_extents;\n    geom::Vector3D corners[4];\n    corners[0] = geom::Math::Rotate(transform.rotation.yaw, geom::Vector3D(-extents.x, -extents.y, 0.0f));\n    corners[1] = geom::Math::Rotate(transform.rotation.yaw, geom::Vector3D(extents.x, -extents.y, 0.0f));\n    corners[2] = geom::Math::Rotate(transform.rotation.yaw, geom::Vector3D(extents.x, extents.y, 0.0f));\n    corners[3] = geom::Math::Rotate(transform.rotation.yaw, geom::Vector3D(-extents.x, extents.y, 0.0f));\n\n    return std::make_shared<const Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 41.3609270809866}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tgeom::Location location = geom::Math::Rotate(transform.rotation.yaw, transform.location) +\n        _parent_bounds->GetLocation(frame);\n\n    geom::Vector3D extents = _parent_bounds->GetExtent(frame);\n\n    geom::Vector3D corners[4];\n    corners[0] = geom::Math::Rotate(transform.rotation.yaw, {extents.x, extents.y, 0.0f});\n    corners[1] = geom::Math::Rotate(transform.rotation.yaw, {extents.x, -extents.y, 0.0f});\n    corners[2] = geom::Math::Rotate(transform.rotation.yaw, {-extents.x, -extents.y, 0.0f});\n    corners[3] = geom::Math::Rotate(transform.rotation.yaw, {-extents.x, extents.y, 0.0f});\n\n    return std::make_shared<const Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 40.59380738809675}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst geom::Location parent_location = transform.GetLocation();\n  const geom::Location location =\n      Rotate(transform.GetRotation().yaw, parent_location);\n\n  const geom::Vector3D extents = _bounds.GetExtent();\n  const geom::Vector3D x = Rotate(transform.GetRotation().yaw, {extents.x, 0.0f, 0.0f});\n  const geom::Vector3D y = Rotate(transform.GetRotation().yaw, {0.0f, extents.y, 0.0f});\n  const geom::Vector3D z = {0.0f, 0.0f, extents.z};\n\n  const geom::Vector3D v0 = location + x + y + z;\n  const geom::Vector3D v1 = location + x + y - z;\n  const geom::Vector3D v2 = location + x - y - z;\n  const geom::Vector3D v3 = location + x - y + z;\n  const geom::Vector3D v4 = location - x + y + z;\n  const geom::Vector3D v5 = location - x + y - z;\n  const geom::Vector3D v6 = location - x - y - z;\n  const geom::Vector3D v7 = location - x - y + z;\n\n  return std::make_shared<const Bounds>(frame, v0, v1, v2, v3, v4, v5, v6, v7);\n}", "CodeBleu_score": 36.60113557935828}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t_episode.Lock()->GetLightManager()->GetAllLights(_lights);\n  for (auto &light : _lights) {\n    auto light_state = _episode.Lock()->QueryLightsStateToServer(light.first);\n    auto search = _lights.find(light.first);\n    if (search != _lights.end()) {\n      search->second->Set(light_state);\n    } else {\n      auto new_light = LightFactory::MakeLight(light_state);\n      _lights.insert(std::make_pair(light.first, new_light));\n    }\n  }\n}", "CodeBleu_score": 38.09334969013418}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex to ensure thread safety.\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Retrieve the light states from the server.\n  std::vector<LightState> states = _episode.Lock()->GetLightManager()->GetLightsState();\n\n  // Iterate through the light states and update the local light states.\n  for (auto &state : states) {\n\n    // Find the light in the _lights map.\n    auto found = _lights.find(state.GetId());\n\n    // If the light does not already exist in the map, create a new light object.\n    if (found == _lights.end()) {\n      _lights.insert({state.GetId(), Light(state)});\n    }\n    // Otherwise, update the light state.\n    else {\n      found->second.SetLightState(state);\n    }\n  }\n}", "CodeBleu_score": 35.34584223161071}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex to ensure thread safety.\n  std::lock_guard<std::mutex> lock(_mutex);\n  // Retrieve the light states from the server.\n  std::vector<rpc::LightState> server_lights = _episode.Lock()->GetLightManager()->GetLightsState();\n  // Update the local light states.\n  for (auto &server_light : server_lights) {\n    // Search for the light in the local lights map.\n    auto local_light = _lights.find(server_light.GetId());\n    if (local_light == _lights.end()) {\n      // The light does not exist locally yet, create a new light object.\n      _lights.emplace(server_light.GetId(), Light(server_light));\n    } else {\n      // The light exists locally, update the light state.\n      local_light->second.SetState(server_light);\n    }\n  }\n}", "CodeBleu_score": 37.70829916429098}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t_episode.Lock()->UpdateServerLightsState(discard_client);\n}", "CodeBleu_score": 11.840277977740737}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t_episode.Lock()->UpdateServerLightsState(discard_client);\n}", "CodeBleu_score": 11.840277977740737}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t_episode.Lock()->UpdateServerLightsState(discard_client);\n}", "CodeBleu_score": 11.840277977740737}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"ServerSideSensor::Send called\");\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not \\\"sensor.other.v2x_custom\\\"\");\n        return;\n    }\n    GetEpisode().Lock()->Send(message, GetContext());\n}", "CodeBleu_score": 57.57122908696394}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"ServerSideSensor::Send called\");\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"ServerSideSensor::Send called with wrong sensor ID\");\n        return;\n    }\n    GetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 57.065582990516184}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"ServerSideSensor::Send called\");\n\n    if (GetActorDescription()->GetId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"ServerSideSensor::Send called with wrong sensor ID\");\n        return;\n    }\n\n    GetEpisode().Lock()->Send(message, GetDisplayId());\n}", "CodeBleu_score": 58.763506192552924}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n        tm.RegisterVehicles(this, tm_port);\n    } else {\n        tm.UnregisterVehicles(this, tm_port);\n    }\n}", "CodeBleu_score": 49.61547041286293}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n    tm.RegisterVehicles(this, 1, tm_port);\n  } else {\n    tm.UnregisterVehicles(this, 1);\n  }\n}", "CodeBleu_score": 44.925921138991974}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n\t\ttm.RegisterVehicles(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 41.57662892093094}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\n\t// Retrieve the walker actor.\n\twalker = GetParent();\n\n\t// Add the walker to the navigation system.\n\tGetEpisode().Lock()->GetNavigation().AddWalker(walker, walker->GetLocation());\n\n\t// Disable the physics simulation and collisions for the walker.\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker->GetId(), false);\n\tGetEpisode().Lock()->SetActorCollisions(walker->GetId(), false);\n}", "CodeBleu_score": 46.3655212862237}, {"code": "void WalkerAIController::Start(){\n\t_walker = GetParent()->GetParent();\n  GetEpisode().Lock()->RegisterAIController(this);\n  GetEpisode().Lock()->AddActor(_walker, {});\n  _start_location = _walker->GetLocation();\n  GetEpisode().Lock()->SetActorLocation(_walker->GetId(), _start_location);\n  GetEpisode().Lock()->SetActorCollisions(_walker->GetId(), false);\n  GetEpisode().Lock()->SetActorSimulatePhysics(_walker->GetId(), false);\n}", "CodeBleu_score": 48.03834804455438}, {"code": "void WalkerAIController::Start(){\n\t// Retrieve the walker actor.\n  _walker = GetParent()->GetActor();\n\n  // Add the walker to the navigation system.\n  GetEpisode().Lock()->AddWalker(_walker->GetId(), _walker->GetLocation());\n\n  // Disable the physics simulation and collisions for the walker.\n  GetEpisode().Lock()->SetActorSimulatePhysics(_walker->GetId(), false);\n  GetEpisode().Lock()->SetActorCollisions(_walker->GetId(), false);\n}", "CodeBleu_score": 39.657128932545774}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav) {\n        auto walker = GetParent();\n        if (walker) {\n            if (nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n                _max_speed = max_speed;\n            } else {\n                log_warning(\"Failed to set walker's max speed.\");\n            }\n        } else {\n            log_warning(\"Failed to find parent walker for walker controller.\");\n        }\n    } else {\n        log_warning(\"Failed to get navigation for walker controller.\");\n    }\n}", "CodeBleu_score": 64.73251700324948}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n    if (!nav) {\n        log_warning(\"Failed to set max speed: Can't find the navigation module.\");\n        return;\n    }\n    auto walker = GetParent();\n    if (!walker) {\n        log_warning(\"Failed to set max speed: Can't find the walker actor.\");\n        return;\n    }\n    if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"Failed to set max speed: Unknown error.\");\n    }\n}", "CodeBleu_score": 67.32586665822369}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n    if (!nav) {\n        return;\n    }\n    auto walker = GetParent();\n    if (!walker) {\n        return;\n    }\n    if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"Failed to set max speed for walker: \" + walker->GetDisplayId());\n    }\n}", "CodeBleu_score": 59.49302194493664}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t// Get the previous waypoints from the map\n    std::vector<Waypoint> waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n\n    // Create a vector of shared pointers to the previous waypoints\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n        result.emplace_back(std::move(waypoint._parent->GetWaypoint(waypoint._waypoint)));\n    }\n\n    return result;\n}", "CodeBleu_score": 77.44640943001907}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t// Retrieve previous waypoints from the parent map\n  std::vector<Waypoint> waypoints = _parent->GetPrevious(_s, distance);\n\n  // Create a vector of shared pointers to waypoints\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n\n  // For each retrieved waypoint, create a shared pointer and add it to the result vector\n  for (auto& waypoint : waypoints) {\n    result.emplace_back(\n        std::move(std::make_shared<Waypoint>(std::move(waypoint))));\n  }\n\n  return result;\n}", "CodeBleu_score": 69.3958355105326}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : _parent->GetMap().GetPrevious(id, distance)) {\n    result.emplace_back(\n        std::move(SharedPtr<Waypoint>(new Waypoint(_parent, waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 67.54074347949154}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n  std::set<std::string> added_signals;\n\n  for (auto &signal : _parent->GetMap().GetSignalsInDistance(GetTransform().location, distance)) {\n    if (added_signals.count(signal->GetId()) == 0) {\n      result.emplace_back(new Landmark(signal, _parent));\n      added_signals.insert(signal->GetId());\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 36.69435345426931}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<SharedPtr<Signal>> added_signals;\n  std::vector<SharedPtr<Signal>> signals = GetMap().GetSignalsInDistance(\n      GetTransform().location, distance, stop_at_junction);\n  for (auto &signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      SharedPtr<Waypoint> landmark_waypoint =\n          SharedPtr<Waypoint>(new Waypoint(_parent, signal->GetTransform()));\n      SharedPtr<Landmark> landmark =\n          SharedPtr<Landmark>(new Landmark(landmark_waypoint));\n      result.push_back(landmark);\n      added_signals.insert(signal);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 53.488288073890125}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n\n  std::set<std::string> added_signals;\n  std::vector<SharedPtr<Waypoint>> signals = GetMap().GetSignalsInDistance(GetTransform().location, distance);\n  for (auto &signal : signals) {\n    if (added_signals.count(signal->GetLandmark()->GetId()) == 0) {\n      added_signals.insert(signal->GetLandmark()->GetId());\n      result.emplace_back(signal->GetLandmark());\n    }\n  }\n\n  if (!stop_at_junction) {\n    std::vector<SharedPtr<Waypoint>> landmarks = GetMap().GetLandmarksInDistance(GetTransform().location, distance);\n    for (auto &landmark : landmarks) {\n      if (added_signals.count(landmark->GetLandmark()->GetId()) == 0) {\n        added_signals.insert(landmark->GetLandmark()->GetId());\n        result.emplace_back(landmark->GetLandmark());\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 47.05098463146696}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    uint64_t id = _episode.Lock()->SetEpisodeSettings(settings);\n    if (settings.fixed_delta_seconds.has_value()) {\n      const auto new_settings = _episode.Lock()->GetEpisodeSettings();\n      if (new_settings.fixed_delta_seconds.get() != settings.fixed_delta_seconds.get()) {\n        log_warning(\"failed to set fixed delta seconds to \" +\n            std::to_string(settings.fixed_delta_seconds.get()));\n      }\n    }\n    return id;\n  }", "CodeBleu_score": 39.88034439280131}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    auto new_settings = settings;\n    if (new_settings.fixed_delta_seconds.has_value()) {\n      const auto delta_seconds = new_settings.fixed_delta_seconds.get();\n      new_settings.fixed_delta_seconds = delta_seconds + std::numeric_limits<float>::epsilon();\n      auto current_snapshot = _episode.Lock()->GetWorldSnapshot();\n      auto current_time = current_snapshot.GetTimestamp();\n      auto current_delta = current_snapshot.GetTimestamp().delta_seconds;\n      auto current_frame = current_snapshot.GetTimestamp().frame;\n      auto current_subframe = current_snapshot.GetTimestamp().subframe;\n      auto attempts = 0u;\n      while (std::abs(current_delta - delta_seconds) > std::numeric_limits<float>::epsilon()) {\n        if (attempts++ > 100u) {\n          log_warning(\"failed to set fixed delta time to\", delta_seconds, \"after\", attempts, \"attempts\");\n          break;\n        }\n        _episode.Lock()->SetEpisodeSettings(new_settings, local_timeout);\n        auto next_snapshot = _episode.Lock()->GetWorldSnapshot();\n        auto next_time = next_snapshot.GetTimestamp();\n        current_delta = next_time.delta_seconds;\n        current_frame = next_time.frame;\n        current_subframe = next_time.subframe;\n      }\n      new_settings.fixed_delta_seconds = delta_seconds;\n    }\n    return _episode.Lock()->SetEpisodeSettings(new_settings, local_timeout);\n  }", "CodeBleu_score": 53.82777260609465}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n\n    auto new_settings = settings;\n    if (new_settings.fixed_delta_seconds.has_value()) {\n        const auto delta = new_settings.fixed_delta_seconds.get();\n        new_settings.fixed_delta_seconds = 0.0f;\n        _episode.Lock()->SetEpisodeSettings(new_settings, local_timeout);\n        new_settings.fixed_delta_seconds = delta;\n\n        const auto current_snapshot = _episode.Lock()->GetWorldSnapshot();\n        const auto current_delta = current_snapshot.GetTimestamp().delta_seconds;\n        const auto delta_diff = std::abs(delta - current_delta);\n        if (delta_diff > std::numeric_limits<float>::epsilon()) {\n            log_warning(\"Provided fixed delta seconds \", delta, \" differs from current \", current_delta, \" by \", delta_diff);\n        }\n    }\n\n    return _episode.Lock()->SetEpisodeSettings(new_settings, local_timeout);\n  }", "CodeBleu_score": 54.53773117700895}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tconst Vector2f& point,\n\tconst Vector2f& segmentStart,\n\tconst Vector2f& segmentEnd\n}", "CodeBleu_score": 10.947400253562357}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat segment_length = Math::Distance2D(segment_start, segment_end);\n    if (segment_length == 0) {\n        float distance_to_start = Math::Distance2D(point, segment_start);\n        float distance_to_end = Math::Distance2D(point, segment_end);\n        if (distance_to_start < distance_to_end) {\n            return std::make_pair(0, distance_to_start);\n        }\n        return std::make_pair(1, distance_to_end);\n    }\n    float t = Math::Clamp(Math::Dot2D(point, segment_end, segment_start) / (segment_length * segment_length), 0, 1);\n    float distance_along_segment = t * segment_length;\n    float distance_to_projection = Math::Distance2D(point, Math::Lerp(segment_start, segment_end, t));\n    return std::make_pair(distance_along_segment, distance_to_projection);\n}", "CodeBleu_score": 38.086482939361915}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t/*\n\t * @param {const Vector2D} point The point\n\t * @param {const Vector2D} segmentStart The first endpoint of the line segment\n\t * @param {const Vector2D} segmentEnd The second endpoint of the line segment\n\t * @return {std::pair<float, float>} The first element is the distance along the line segment and the second element is the distance from the projection to the point.\n\t */\n\treturn Math::DistanceSegmentToPoint(const Vector2D& point, const Vector2D& segmentStart, const Vector2D& segmentEnd);\n}", "CodeBleu_score": 12.742071658619187}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n    size_t initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 0; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i + 1);\n      AddIndex(initial_index + i + 2);\n    }\n  }", "CodeBleu_score": 56.074075625079175}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n    const auto initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 57.007491219093474}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n\n    const index_type initial_index = AddVertex(vertices[0]);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(AddVertex(vertices[i]));\n      AddIndex(AddVertex(vertices[i + 1]));\n    }\n  }", "CodeBleu_score": 62.32585341293565}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  _strand.post([this, message]() {\n    if (!_socket.is_open()) {\n      log_error(\"cannot write to closed socket\");\n      return;\n    }\n    _deadline.expires_from_now(boost::posix_time::seconds(10));\n    boost::asio::async_write(\n        _socket,\n        message->GetBufferSequence(),\n        boost::asio::bind_executor(\n            _strand,\n            boost::bind(&Primary::HandleSent,\n                        shared_from_this(),\n                        message,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred)));\n  });\n}", "CodeBleu_score": 36.722901556644224}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  DEBUG_ASSERT(message->size() <= MaximumMessageSize);\n  boost::asio::post(\n      _strand,\n      boost::asio::bind_executor(\n          _strand,\n          [this, message]() {\n            if (!_socket.is_open()) {\n              log_error(\"trying to write to a closed socket\");\n              return;\n            }\n            _deadline.expires_from_now(boost::posix_time::seconds(30));\n            boost::asio::async_write(\n                _socket,\n                message->GetBufferSequence(),\n                boost::asio::bind_executor(\n                    _strand,\n                    [this, message](boost::system::error_code ec, size_t) {\n                      if (ec) {\n                        log_error(\"write: \" + ec.message());\n                        CloseNow();\n                      }\n                    }));\n          }));\n}", "CodeBleu_score": 43.938814819864646}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  DEBUG_ASSERT(message->size() <= carla::streaming::detail::tcp::Message::MAX_SIZE);\n  boost::asio::post(\n      _strand,\n      boost::asio::bind_executor(\n          _strand,\n          [this, message]() {\n            if (!_socket.is_open()) {\n              return;\n            }\n            _deadline.expires_from_now(boost::posix_time::seconds(10));\n            boost::asio::async_write(\n                _socket,\n                message->GetBufferSequence(),\n                boost::asio::bind_executor(\n                    _strand,\n                    [this, weak = std::weak_ptr<Primary>(shared_from_this()), message](\n                        boost::system::error_code ec,\n                        size_t) {\n                      if (auto self = weak.lock()) {\n                        if (ec) {\n                          log_error(ec.message());\n                          self->CloseNow();\n                        }\n                      }\n                    }));\n          }));\n}", "CodeBleu_score": 44.574253197592064}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (_deadline.expires_at() > boost::posix_time::neg_infin) {\n\t\t_deadline.cancel();\n\t}\n\n\tif (!ec && _socket.is_open()) {\n\t\tboost::system::error_code ignored_ec;\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\t_socket.close(ignored_ec);\n\t}\n\n\t_on_closed(ec);\n\tLogDebug(\"session closed\");\n}", "CodeBleu_score": 52.261788255603236}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\n\n  if (!ec && _socket.is_open()) {\n    boost::system::error_code ec;\n    _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    _socket.close(ec);\n  }\n\n  _on_closed(ec);\n\n  log_debug(\"Session closed\");\n}", "CodeBleu_score": 51.898638833048096}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\n\n    if (!ec && _socket.is_open()) {\n        boost::system::error_code ignored_ec;\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n        _socket.close(ignored_ec);\n    }\n\n    _on_closed(ec);\n\n    log_debug(\"Session closed\");\n}", "CodeBleu_score": 60.647953900063065}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\tstd::string msg = \"Are you alive?\";\n    log_info(\"Sending message: \" + msg);\n    auto buffer = std::make_unique<Buffer>(msg.c_str(), msg.size());\n    _router->WriteToNext(std::move(buffer), YOU_ALIVE);\n    auto fut = _router->ReadFromNext();\n    log_info(\"Received response: \" + fut.get()->data);\n}", "CodeBleu_score": 54.04853538711312}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tstd::string msg = \"Are you alive?\";\n  std::unique_ptr<Buffer> buffer = std::make_unique<Buffer>(msg.c_str(), msg.size());\n  log_info(\"Sending \\\"Are you alive?\\\" to the system\");\n  _router->WriteToNext(std::move(buffer), YOU_ALIVE);\n  log_info(\"Waiting for the system to respond\");\n  std::unique_ptr<Buffer> response = fut.get();\n  log_info(\"System responded with \" + std::string(response->data));\n}", "CodeBleu_score": 48.229047713187775}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tstd::string msg = \"Are you alive?\";\n    std::vector<uint8_t> buffer = CreateBuffer(msg);\n    log_info(\"Sending \\\"Are you alive?\\\"\");\n    _router->WriteToNext(buffer, YOU_ALIVE);\n    std::vector<uint8_t> response = _router->ReadFromNext();\n    log_info(\"Response: \" + std::string(response.begin(), response.end()));\n}", "CodeBleu_score": 48.390877695198476}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Check if sensor is active on any secondary server\n  auto fut = _secondary_server_map.find(sensor_id);\n  if (fut != _secondary_server_map.end()) {\n    // Create buffer with sensor ID\n    auto buffer = std::make_unique<Buffer>();\n    buffer->data = reinterpret_cast<uint8_t *>(&sensor_id);\n    buffer->size = sizeof(sensor_id);\n\n    // Send ENABLE_ROS command to server\n    _router->WriteToOne(fut->second, Command::ENABLE_ROS, std::move(buffer));\n\n    // Wait for response\n    auto response = _router->ReadFromOne(fut->second);\n\n    // Check if response is valid\n    if (response.command == Command::ENABLE_ROS_RESPONSE) {\n      // Check if sensor was successfully enabled\n      if (reinterpret_cast<bool *>(response.buffer.data)[0]) {\n        // Add sensor to active sensor map\n        _active_sensor_map.insert(std::make_pair(sensor_id, fut->second));\n      } else {\n        // Log error\n        log_error(\"Failed to enable sensor \" << sensor_id);\n      }\n    } else {\n      // Log error\n      log_error(\"Unexpected response from server \" << fut->second);\n    }\n  } else {\n    // Log error\n    log_error(\"Sensor \" << sensor_id << \" is not active on any secondary server\");\n  }\n}", "CodeBleu_score": 52.29441043974059}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tauto fut = std::async(std::launch::async, [&] {\n        auto server_id = _servers.find(sensor_id);\n        if (server_id != _servers.end()) {\n            std::vector<uint8_t> buffer(sizeof(sensor_id));\n            memcpy(buffer.data(), &sensor_id, sizeof(sensor_id));\n            auto response = _router->SendCommand(server_id->second,\n                                                 Command::ENABLE_ROS, buffer);\n            if (response.status == Status::OK) {\n                auto response_id = reinterpret_cast<stream_id *>(\n                    response.buffer.data);\n                if (*response_id == sensor_id) {\n                    _servers.erase(server_id);\n                }\n            }\n        } else {\n            log_error(\"Sensor not found on any secondary server\");\n        }\n    });\n    fut.get();\n}", "CodeBleu_score": 51.32317265791275}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Create a buffer to hold the sensor ID\n  auto buffer = std::make_unique<Buffer>();\n  buffer->WriteData(reinterpret_cast<char *>(&sensor_id), sizeof(sensor_id));\n\n  // Send the buffer to all servers\n  auto fut = _router->WriteToOne(\n      buffer.get(),\n      [&](const Server &server, const std::shared_ptr<Buffer> &buffer) {\n        // Process the server's response\n        auto response = buffer->ReadData();\n        if (response.size() != sizeof(Response)) {\n          log_error(\"Invalid response from server \" + server.GetId());\n          return;\n        }\n        auto response_id = reinterpret_cast<Response *>(response.data());\n        if (*response_id != Response::ENABLE_ROS) {\n          log_error(\"Invalid response from server \" + server.GetId());\n          return;\n        }\n        log_info(\"Sensor \" + std::to_string(sensor_id) + \" enabled on \" +\n                 server.GetId());\n      });\n\n  // Wait for the server to respond\n  fut.get();\n}", "CodeBleu_score": 48.7074195096627}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// If the sensor is already activated, return the existing token.\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"sensor\", sensor_id, \"already activated, returning existing token\");\n    return it->second;\n  }\n\n  // Otherwise, enable the sensor on a secondary server and retrieve a new token.\n  log_debug(\"sensor\", sensor_id, \"not activated, enabling sensor on a secondary server\");\n  auto new_token = SendGetToken(sensor_id);\n  _tokens.emplace(sensor_id, new_token);\n  return new_token;\n}", "CodeBleu_score": 51.113966315920266}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n  log_debug(\"asking for a token for sensor id: \", sensor_id);\n\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"already have a token for sensor id: \", sensor_id);\n    return it->second;\n  }\n\n  log_debug(\"activating sensor id: \", sensor_id);\n  auto token = SendGetToken(sensor_id);\n  _tokens.insert(std::make_pair(sensor_id, token));\n  _server_map.insert(std::make_pair(token.get_port(), _router->GetNextServer()));\n  return token;\n}", "CodeBleu_score": 57.681704102158136}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(buf));\n\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  return new_token;\n}", "CodeBleu_score": 42.13988322740194}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!ReadyCheck()) {\n        return false;\n    }\n    DEBUG_ASSERT(_crowd != nullptr);\n    bool result = false;\n    // Search for the agent id in the walker and vehicle mappings.\n    auto it_walker = _mapped_walkers_id.find(id);\n    auto it_vehicle = _mapped_vehicles_id.find(id);\n    if (it_walker != _mapped_walkers_id.end()) {\n        // Enter a critical section to safely remove the agent from the crowd.\n        _crowd->removeAgent(it_walker->second);\n        // Update the walker manager.\n        _walker_manager.RemoveWalker(id);\n        // Remove the id from the mappings.\n        _mapped_walkers_id.erase(it_walker);\n        _mapped_by_index.erase(it_walker->second);\n        result = true;\n    } else if (it_vehicle != _mapped_vehicles_id.end()) {\n        // Enter a critical section to safely remove the agent from the crowd.\n        _crowd->removeAgent(it_vehicle->second);\n        // Update the vehicle manager.\n        _vehicle_manager.RemoveVehicle(id);\n        // Remove the id from the mappings.\n        _mapped_vehicles_id.erase(it_vehicle);\n        _mapped_by_index.erase(it_vehicle->second);\n        result = true;\n    }\n    return result;\n}", "CodeBleu_score": 59.80635800100881}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t// Make sure we are ready to remove agents.\n  if (!_ready) {\n    return false;\n  }\n\n  // Make sure the crowd is valid.\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // Search for the actor in the walker and vehicle mappings.\n  auto walker_it = _mapped_walkers_id.find(id);\n  auto vehicle_it = _mapped_vehicles_id.find(id);\n\n  // If the actor is not found, return false.\n  if (walker_it == _mapped_walkers_id.end() && vehicle_it == _mapped_vehicles_id.end()) {\n    return false;\n  }\n\n  // Enter a critical section to remove the agent from the crowd.\n  {\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Remove the agent from the crowd.\n    _crowd->removeAgent(walker_it != _mapped_walkers_id.end() ? walker_it->second : vehicle_it->second);\n  }\n\n  // Update the walker or vehicle manager.\n  if (walker_it != _mapped_walkers_id.end()) {\n    _walker_manager.RemoveWalker(id);\n    _mapped_walkers_id.erase(walker_it);\n  } else {\n    _vehicle_manager.RemoveVehicle(id);\n    _mapped_vehicles_id.erase(vehicle_it);\n  }\n\n  // Remove the id from the mapping by index.\n  _mapped_by_index.erase(id);\n\n  return true;\n}", "CodeBleu_score": 64.59450430750917}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t// Check if the system is ready\n  if (!ReadyCheck())\n    return false;\n\n  // Check if the crowd is null\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // Search for the walker\n  auto it_walker = _mapped_walkers_id.find(id);\n  if (it_walker != _mapped_walkers_id.end()) {\n    // Enter critical section\n    _mutex.lock();\n    // Remove the walker from the crowd\n    _crowd->removeAgent(it_walker->second);\n    // Update the walker manager\n    _walker_manager.RemoveWalker(id);\n    // Remove the walker from the mapping\n    _mapped_walkers_id.erase(it_walker);\n    // Leave critical section\n    _mutex.unlock();\n    return true;\n  }\n\n  // Search for the vehicle\n  auto it_vehicle = _mapped_vehicles_id.find(id);\n  if (it_vehicle != _mapped_vehicles_id.end()) {\n    // Enter critical section\n    _mutex.lock();\n    // Remove the vehicle from the crowd\n    _crowd->removeAgent(it_vehicle->second);\n    // Update the vehicle manager\n    _vehicle_manager.RemoveVehicle(id);\n    // Remove the vehicle from the mapping\n    _mapped_vehicles_id.erase(it_vehicle);\n    // Leave critical section\n    _mutex.unlock();\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 61.948325978043236}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    auto actor = it->second;\n    auto location = actor->GetLocation();\n    float sq_distance = location.DistanceSquared(direction);\n    return _crowd->HasVehicleNear(location, sq_distance);\n  }\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    auto actor = it->second;\n    auto location = actor->GetLocation();\n    float sq_distance = location.DistanceSquared(direction);\n    return _crowd->HasVehicleNear(location, sq_distance);\n  }\n  return false;\n}", "CodeBleu_score": 62.38399646985366}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tstd::lock_guard<std::mutex> lock(_vehicle_near_mutex);\n  // Check if actor is a walker\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    return _crowd->hasVehicleNear(it->second, distance, direction);\n  }\n  // Check if actor is a vehicle\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    return _crowd->hasVehicleNear(it->second, distance, direction);\n  }\n  return false;\n}", "CodeBleu_score": 63.37238132373398}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t// search for the actor in the mapped walkers and vehicles\n  auto walker_it = _mapped_walkers_id.find(id);\n  auto vehicle_it = _mapped_vehicles_id.find(id);\n\n  if (walker_it != _mapped_walkers_id.end()) {\n    // enter a critical section\n    _critical_section.lock();\n\n    // compute the squared distance\n    float squared_distance = distance * distance;\n\n    // use the crowd system to determine if a vehicle is nearby\n    bool result = _crowd->hasVehicleNear(walker_it->second, squared_distance, direction);\n\n    // leave the critical section\n    _critical_section.unlock();\n\n    return result;\n  } else if (vehicle_it != _mapped_vehicles_id.end()) {\n    // enter a critical section\n    _critical_section.lock();\n\n    // compute the squared distance\n    float squared_distance = distance * distance;\n\n    // use the crowd system to determine if a vehicle is nearby\n    bool result = _crowd->hasVehicleNear(vehicle_it->second, squared_distance, direction);\n\n    // leave the critical section\n    _critical_section.unlock();\n\n    return result;\n  } else {\n    // actor not found\n    return false;\n  }\n}", "CodeBleu_score": 53.951257763821204}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tauto event = info.event;\n  auto route = info.route;\n  auto route_point = info.route_point;\n  auto current_section = route->GetSectionAt(route_point);\n  auto current_section_id = current_section->GetId();\n  auto current_section_type = current_section->GetType();\n  auto current_section_end = current_section->GetEnd();\n  auto current_section_length = current_section->GetLength();\n  auto current_section_geodesic_length = current_section->GetGeodesicLength();\n  auto current_section_geodesic_start_location = current_section->GetGeodesicStartLocation();\n  auto current_section_geodesic_end_location = current_section->GetGeodesicEndLocation();\n  auto current_section_geodesic_start_distance = current_section->GetGeodesicStartDistance();\n  auto current_section_geodesic_end_distance = current_section->GetGeodesicEndDistance();\n  auto current_section_geodesic_velocity = current_section->GetGeodesicVelocity();\n  auto current_section_geodesic_acceleration = current_section->GetGeodesicAcceleration();\n  auto current_section_geodesic_deviation = current_section->GetGeodesicDeviation();\n  auto current_section_geodesic_start_time = current_section->GetGeodesicStartTime();\n  auto current_section_geodesic_end_time = current_section->GetGeodesicEndTime();\n  auto current_section_geodesic_start_speed = current_section->GetGeodesicStartSpeed();\n  auto current_section_geodesic_end_speed = current_section->GetGeodesicEndSpeed();\n  auto current_section_geodesic_start_acceleration = current_section->GetGeodesicStartAcceleration();\n  auto current_section_geodesic_end_acceleration = current_section->GetGeodesicEndAcceleration();\n  auto current_section_geodesic_start_deviation = current_section->GetGeodesicStartDeviation();", "CodeBleu_score": 35.60156973587981}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tconst RoutePoint &point = info.route->GetCurrentPoint();\n    WalkerEventVisitor visitor(this, id, info, point, delta);\n    return boost::variant2::visit(visitor, info.event);\n}", "CodeBleu_score": 62.76511130973469}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tEventResult result = EventResult::Continue;\n\n\tif (info.route.empty()) {\n\t\treturn result;\n\t}\n\n\tRoutePoint &routePoint = info.route.front();\n\tWalkerEventVisitor visitor(delta, routePoint, info, this);\n\tresult = boost::variant2::visit(visitor, routePoint.event);\n\n\tif (result == EventResult::Continue) {\n\t\tinfo.route.pop_front();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 48.43514399093449}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        matched_ = true;\n        first_connected_ = true;\n        std::cout << \"CarlaListenerImpl publication matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_ = false;\n        std::cout << \"CarlaListenerImpl publication unmatched.\" << std::endl;\n    } else {\n        std::cout << \"error: CarlaListenerImpl publication matched current_count_change \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 56.367039429506335}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        if (info.total_count_change == 1) {\n            matched_ = true;\n            first_connected_ = true;\n            std::cout << \"Writer matched.\" << std::endl;\n        } else {\n            std::cout << \"Writer already matched.\" << std::endl;\n        }\n    } else if (info.current_count_change == -1) {\n        if (info.total_count_change == -1) {\n            matched_ = false;\n            std::cout << \"Writer unmatched.\" << std::endl;\n        } else {\n            std::cout << \"Writer not matched.\" << std::endl;\n        }\n    } else {\n        std::cout << \"Invalid matched count received.\" << std::endl;\n    }\n}", "CodeBleu_score": 55.64500907469826}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        matched_ = info.current_count;\n        first_connected_ = true;\n        std::cout << \"Publication matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_ = info.current_count;\n        std::cout << \"Publication unmatched.\" << std::endl;\n    } else {\n        std::cout << \"Publication matched change is invalid: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 67.20250366537658}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    std::cout << \"Subscriber matched.\" << std::endl;\n    _owner->SetMatched(true);\n    _owner->SetFirstConnected(true);\n  } else if (info.current_count_change == -1) {\n    std::cout << \"Subscriber unmatched.\" << std::endl;\n    _owner->SetMatched(false);\n    if (info.current_count == 0) {\n      _owner->DestroySubscriber();\n    }\n  } else {\n    std::cerr << \"Invalid matched count received: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 60.64381605520636}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        _owner->matched_count++;\n        _owner->first_connected = true;\n    } else if (info.current_count_change == -1) {\n        _owner->matched_count--;\n        if (_owner->matched_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        logError(CARLA_SUBSCRIBER, \"Invalid matched_count change.\");\n    }\n}", "CodeBleu_score": 56.6876803803408}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        std::cout << \"Matched publisher: \" << info.last_publication_handle << std::endl;\n        std::cout << \"total matched: \" << info.total_count << std::endl;\n        std::cout << \"current matched: \" << info.current_count << std::endl;\n        _first_connected = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Unmatched publisher: \" << info.last_publication_handle << std::endl;\n        std::cout << \"total matched: \" << info.total_count << std::endl;\n        std::cout << \"current matched: \" << info.current_count << std::endl;\n        if (info.total_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cerr << \"Invalid matched publisher status.\" << std::endl;\n    }\n}", "CodeBleu_score": 63.73563470228565}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif(!key_ptr) {\n        return false;\n    }\n    CarlaCollisionEvent* type = static_cast<CarlaCollisionEvent*>(data);\n    if(!type->isKeyDefined()) {\n        return false;\n    }\n    eprosima::fastcdr::FastBuffer buffer;\n    eprosima::fastcdr::Cdr ser(buffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        key_ptr->serializeKey(ser);\n        m_md5.update(ser.getSerializedData(), static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for(uint8_t i = 0;i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        ser.serializeKey(*key_ptr);\n        for(uint8_t i = 0;i < 16; ++i) {\n            handle->value[i] = buffer.data[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 68.07926429853785}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif(!m_isGetKeyDefined)\n        return false;\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer;\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    p_type->serializeKey(ser);\n    m_md5.init();\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16) {\n        m_md5.update(ser.getSerializedData(), static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for(uint8_t i = 0;i<16;++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for(uint8_t i = 0;i<16;++i) {\n            handle->value[i] = 0;\n        }\n        memcpy(&handle->value[0], ser.getSerializedData(),\n                static_cast<size_t>(ser.getSerializedDataLength()));\n    }\n    return true;\n}", "CodeBleu_score": 61.79317238142153}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif(!this->isKeyDefined_)\n        return false;\n\n    CarlaCollisionEvent* key = (CarlaCollisionEvent*) data;\n    //SerializedPayload_t static_data(0);\n    SerializedPayload_t static_data(0);\n    static_data.length = static_data.max_size = CarlaCollisionEvent::getKeyMaxCdrSerializedSize(key, this->m_typeSize.getRawBuffer());\n    static_data.data = eprosima::fastrtps::rtps::SerializedPayload_t::_duplicate_max_size(key, static_data.length);\n    static_data.encapsulation = this->encapsulation_;\n\n    if(static_data.data == NULL)\n        return false;\n\n    memcpy(static_data.data, key, static_data.length);\n\n    if (force_md5 || CarlaCollisionEvent::isKeyDefined()) {\n        MD5 m;\n        m.init();\n        m.update(static_data.data, static_data.length);\n        m.finalize();\n        memcpy(handle->value, m.digest, 16);\n    } else {\n        memcpy(handle->value, static_data.data, static_data.length);\n    }\n    return true;\n}", "CodeBleu_score": 37.787947658167184}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages a buffer to store the serialized data.\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer,\n            eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl *p_type = static_cast<CarlaEgoVehicleControl*>(data);\n        p_type->serialize(ser); // Serialize the object:\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 79.99862045810643}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages a buffer that can be dynamically resized.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, ser.endianness()); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data); // Deserialized data\n        p_type->serialize(ser); // Serialize the object:\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 79.18578134299786}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages a buffer that can be dynamically resized.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer,\n            static_cast<eprosima::fastcdr::Cdr::Endianness>(payload->endianness));\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::Endianness::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    p_type->serialize(ser);\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 69.88394004611952}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) {\n        return;\n    }\n    switch (msg.msgid) {\n    case MAVLINK_MSG_ID_GPS_RAW_INT:\n        if (target_sysid_set) {\n            return;\n        }\n        mavlink_gps_raw_int_t gps_raw;\n        mavlink_msg_gps_raw_int_decode(&msg, &gps_raw);\n        if (gps_raw.fix_type != 3) {\n            return;\n        }\n        target_sysid = gps_raw.sysid;\n        target_set = true;\n        target_sysid_set = true;\n        tracker.gcs().request_datastream_position(target_sysid);\n        tracker.gcs().request_datastream_airpressure(target_sysid);\n        break;\n    case MAVLINK_MSG_ID_HEARTBEAT:\n        if (target_sysid_set) {\n            return;\n        }\n        mavlink_heartbeat_t heartbeat;\n        mavlink_msg_heartbeat_decode(&msg, &heartbeat);\n        if (heartbeat.type != MAV_TYPE_GCS) {\n            return;\n        }\n        target_sysid = heartbeat.sysid;\n        target_set = true;\n        target_sysid_set = true;\n        tracker.gcs().request_datastream_position(target_sysid);\n        tracker.gcs().request_datastream_airpressure(target_sysid);\n        break;\n    case MAVLINK_MSG_ID_SYS_STATUS:\n        if (target_sysid_set) {\n            return;\n        }\n        mavlink_sys_status_t sys_status;\n        mavlink_msg_sys_status_decode(&msg, &sys_status);\n        if (sys_status.onboard_control_sensors_present != 0x00000010) {\n            return;\n        }\n        target_sysid", "CodeBleu_score": 42.183756228266766}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (tracker.g.sysid_target != 0) {\n        // target already set\n        return;\n    }\n\n    switch (msg.msgid) {\n\n    case MAVLINK_MSG_ID_GPS_RAW_INT:\n    case MAVLINK_MSG_ID_GPS_RAW:\n    case MAVLINK_MSG_ID_GPS_STATUS:\n    case MAVLINK_MSG_ID_GPS2_RAW:\n    case MAVLINK_MSG_ID_GPS2_RTK:\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV:\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_RAW_INT:\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_RAW:\n    case MAVLINK_MSG_ID_HIGH_LATENCY:\n    case MAVLINK_MSG_ID_HIGH_LATENCY2:\n    case MAVLINK_MSG_ID_HIGH_LATENCY2_RAW:\n    case MAVLINK_MSG_ID_HIGH_LATENCY2_RAW_AIRSPEED:\n    case MAVLINK_MSG_ID_HIGH_LATENCY2_RAW_AIRSPEED_CELLS:\n    case MAVLINK_MSG_ID_HIGH_LATENCY2_RAW_CELLS:\n    case MAVLINK_MSG_ID_HIGH_LATENCY2_RAW_CELLS_AIRSPEED:\n    case MAVLINK_MSG_ID_HIGH_LATENCY2_RAW_CELLS_AIRSPEED_CELLS:\n    case MAVLINK_MSG_ID_HIGH_LATENCY2", "CodeBleu_score": 21.082973658404647}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t// exit immediately if the target has been set\n    if (tracker.g.sysid_target.get() != 0) {\n        return;\n    }\n\n    // decode message\n    mavlink_msg_heartbeat_decode(&msg, &tracker.heartbeat);\n\n    // exit immediately if this is not a message that should be tracked\n    if (tracker.heartbeat.type != MAV_TYPE_GCS &&\n        tracker.heartbeat.type != MAV_TYPE_ONBOARD_CONTROLLER &&\n        tracker.heartbeat.type != MAV_TYPE_GIMBAL &&\n        tracker.heartbeat.type != MAV_TYPE_CAMERA &&\n        tracker.heartbeat.type != MAV_TYPE_ADSB) {\n        return;\n    }\n\n    // set sysid to target and request position and air pressure data streams\n    if (tracker.g.sysid_target.get() == 0) {\n        tracker.g.sysid_target.set(tracker.heartbeat.sysid);\n        tracker.gcs().request_datastream_position(tracker.heartbeat.sysid, tracker.heartbeat.compid, true);\n        tracker.gcs().request_datastream_airpressure(tracker.heartbeat.sysid, tracker.heartbeat.compid, true);\n    }\n\n    // flag that the target has been set\n    tracker.g.flag_sysid_target.set(1);\n}", "CodeBleu_score": 41.64559912398629}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (vehicle->barometer != NULL) {\n        result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n        if (result == MAV_RESULT_ACCEPTED) {\n            vehicle->barometer->set_needs_calibration(true);\n        }\n    }\n    return result;\n}", "CodeBleu_score": 57.445057902876705}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _barometer_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.91618036712919}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    // let the base class handle the message first\n    result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n    // if the base class returns ACCEPTED, set a flag to indicate that altitude calibration is needed on the next barometer update\n    if (result == MAV_RESULT_ACCEPTED) {\n        _barometer_calibration_needed = true;\n    }\n\n    // return the result of the base class handler\n    return result;\n}", "CodeBleu_score": 63.89299679373238}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tif (packet.param1 == 1.0) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 75.82187070476459}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    float command = packet.param1;\n    if (is_equal(command, 1.0)) {\n        tracker.arm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_zero(command)) {\n        tracker.disarm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}", "CodeBleu_score": 56.54850119983708}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tif (is_zero(packet.param1)) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (is_equal(packet.param1, 1.0)) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 84.77884612458475}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < num_gcs; i++) {\n        if (gcs_array[i].sysid == sysid && gcs_array[i].compid == compid) {\n            if (HAVE_PAYLOAD_SPACE(gcs_array[i], MAVLINK_MSG_ID_HIGHRES_IMU, MAVLINK_MSG_ID_HIGHRES_IMU_LEN)) {\n                mavlink_msg_request_data_stream_send(gcs_array[i].chan, gcs_array[i].sysid, gcs_array[i].compid, MAV_DATA_STREAM_POSITION, MAV_DATA_STREAM_POSITION_UPDATE_RATE, 1);\n            }\n        }\n    }\n}", "CodeBleu_score": 50.98380108659666}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < num_gcs; i++) {\n        if (gcs_channel[i] != NULL) {\n            if (gcs_channel[i]->available_payload_space() >= MAVLINK_MSG_ID_HIL_GPS_LEN) {\n                mavlink_msg_request_data_stream_send(gcs_channel[i], sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n            }\n        }\n    }\n}", "CodeBleu_score": 51.35702334786505}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < num_gcs; i++) {\n        if (gcs[i].sysid == sysid && gcs[i].compid == compid) {\n            if (gcs[i].have_payload_space) {\n                mavlink_msg_request_data_stream_send(gcs[i].chan, 1, 1, MAV_DATA_STREAM_POSITION, 10, 1);\n            }\n            break;\n        }\n    }\n}", "CodeBleu_score": 46.75749337441298}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAP::ahrs.get_instance();\n  if (AP::ahrs.cos_pitch == 0.0) {\n    return false;\n  }\n  ef_pitch = atan2(-AP::ahrs.sin_roll*cos(pitch) + AP::ahrs.cos_roll*sin(yaw),\n                   AP::ahrs.cos_roll*cos(pitch) + AP::ahrs.sin_roll*sin(yaw));\n  ef_yaw = atan2(sin(yaw)*AP::ahrs.cos_pitch,\n                 cos(pitch)*AP::ahrs.cos_roll - sin(pitch)*AP::ahrs.sin_roll*sin(yaw));\n  return true;\n}", "CodeBleu_score": 52.32846489318255}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAP_AHRS* ahrs = AP_AHRS::get_instance();\n  if (ahrs->cos_pitch() != 0) {\n    ef_pitch = atan2f(ahrs->sin_roll() * sinf(pitch) + ahrs->cos_roll() * sinf(yaw),\n                      ahrs->cos_roll() * cosf(yaw) - ahrs->sin_roll() * sinf(pitch));\n    ef_yaw = atan2f(sinf(yaw) * ahrs->cos_pitch(),\n                    cosf(yaw) * ahrs->cos_roll() * ahrs->cos_pitch() - ahrs->sin_roll() * sinf(pitch));\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 55.85159461154719}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAP::ahrs.update();\n  if (AP::ahrs.cos_pitch != 0) {\n    ef_pitch = atan2(AP::ahrs.sin_roll, AP::ahrs.cos_roll);\n    ef_yaw = atan2(sin(yaw) * AP::ahrs.cos_pitch, cos(yaw) * AP::ahrs.cos_pitch);\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 40.93672359795386}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t// if we are not in auto mode then do nothing\n    if (tracker.mode != Tracker::TRACKER_MODE_AUTO) {\n        return;\n    }\n\n    // if we don't have a valid target then do nothing\n    if (tracker.nav_status.status != Tracker::NavStatus::STATUS_TARGET_TRACKING) {\n        return;\n    }\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate target pitch and yaw in centi-degrees\n    float target_pitch = 0;\n    float target_yaw = 0;\n    calc_target_pitch_yaw(target_pitch, target_yaw);\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    calc_angle_error(target_pitch, target_yaw, direction_reversed);\n\n    // if we have a valid target distance or no minimum distance is set\n    if (tracker.nav_status.target_distance_valid || !tracker.g.min_distance) {\n        // update pitch and yaw servos\n        update_pitch_servo(target_pitch);\n        update_yaw_servo(target_yaw);\n    }\n}", "CodeBleu_score": 34.93430410203747}, {"code": "void Mode::update_auto(void){\n\t// calculate target pitch and yaw in centidegrees\n    Parameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float pitch_target;\n    float yaw_target;\n    if (nav_status.valid_target) {\n        pitch_target = nav_status.altitude * 100.0f / g.pitch_gain;\n        yaw_target = (nav_status.bearing + g.yaw_trim) * 100.0f;\n    } else {\n        pitch_target = 0.0f;\n        yaw_target = 0.0f;\n    }\n\n    // check if direction is reversed\n    bool direction_reversed = Mode::get_ef_yaw_direction();\n\n    // calculate angle error in centidegrees\n    Mode::calc_angle_error(pitch_target, yaw_target, direction_reversed);\n\n    // update pitch and yaw servos\n    if (nav_status.valid_target || !g.min_distance) {\n        tracker.update_pitch_servo();\n        tracker.update_yaw_servo();\n    }\n}", "CodeBleu_score": 51.506394483209505}, {"code": "void Mode::update_auto(void){\n\tParameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    struct Tracker::NavState &nav_state = tracker.nav_state;\n\n    // if we are in the process of landing, do not update the target\n    if (nav_state.is_landing) {\n        return;\n    }\n\n    // if we are not in the process of landing, and we have a valid target, update the target\n    if (nav_status.valid && nav_status.distance_cm < g.max_acquire_distance) {\n        // calculate the target yaw and pitch\n        float target_yaw = wrap_180_cd(nav_status.bearing * 100.0f);\n        float target_pitch = constrain_float(nav_status.altitude * 100.0f, g.pitch_min * 100.0f, g.pitch_max * 100.0f);\n\n        // check if the direction is reversed\n        bool direction_reversed = get_ef_yaw_direction();\n\n        // calculate angle error in centidegrees\n        calc_angle_error(target_pitch, target_yaw, direction_reversed);\n\n        // update the pitch and yaw servos\n        tracker.update_pitch_servo();\n        tracker.update_yaw_servo();\n    }\n}", "CodeBleu_score": 54.03603755847548}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t//update GPS\n    gps.update();\n\n    //check if GPS has a fix\n    if (gps.status() >= 3) {\n        //if there is a fix, check if the last message time has changed\n        if (gps.last_message_time_ms() != gps_last_message_time_ms) {\n            //if the last message time has changed, update the last message time\n            gps_last_message_time_ms = gps.last_message_time_ms();\n\n            //if the location is valid, decrement the countdown\n            if (gps.location().is_valid()) {\n                gps_countdown--;\n            }\n            //if the location is not valid, reset the countdown\n            else {\n                gps_countdown = GPS_COUNTDOWN;\n            }\n        }\n\n        //if the countdown is one, set the home location\n        if (gps_countdown == 1) {\n            set_home(gps.location());\n        }\n    }\n}", "CodeBleu_score": 40.07186889967257}, {"code": "void Tracker::update_GPS(void){\n\t// Update the GPS data\n    gps.update();\n\n    // Check if the GPS status has changed\n    if (gps.status() != last_gps_status) {\n        // The GPS status has changed, so update the last GPS status\n        last_gps_status = gps.status();\n\n        // If the GPS status is at least 3D fix, then update the last GPS message time\n        if (last_gps_status >= 3) {\n            last_gps_message_time_ms = millis();\n        }\n    }\n\n    // If the GPS status is at least 3D fix, then check if the last message time has changed\n    if (last_gps_status >= 3) {\n        // If the last message time has changed, then update the last GPS message time\n        if (gps.last_message_time_ms() != last_gps_message_time_ms) {\n            last_gps_message_time_ms = gps.last_message_time_ms();\n\n            // If the GPS location is valid, then update the home location\n            if (gps.location().is_valid()) {\n                set_home(gps.location());\n            }\n        }\n    }\n\n    // If the GPS status is at least 3D fix, then check if the ground start countdown is less than one\n    if (last_gps_status >= 3 && ground_start_countdown < 1) {\n        // If the GPS location is valid, then update the home location\n        if (gps.location().is_valid()) {\n            // Set the home location\n            set_home(gps.location());\n\n            // Set the ground start countdown to one\n            ground_start_countdown = 1;\n        }\n    }\n}", "CodeBleu_score": 48.61546371709604}, {"code": "void Tracker::update_GPS(void){\n\tgps.update();\n    if (gps.last_message_time_ms() != last_message_time_ms) {\n        last_message_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= 3) {\n            if (gps.location().is_valid()) {\n                if (gps_countdown == 0) {\n                    set_home(gps.location());\n                    gps_countdown = 1;\n                }\n            }\n            else {\n                gps_countdown = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 45.533909640051974}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t//Serial.println(pitch);\n\tif(pitch < 0) {\n\t\tpitch = 0;\n\t}\n\tif(pitch > 180) {\n\t\tpitch = 180;\n\t}\n\t//Serial.println(pitch);\n\t//Serial.println(pitch * 200 / 180);\n\t//pitch = pitch * 200 / 180;\n\t//Serial.println(pitch);\n\t//pitch = pitch / 200 * 180;\n\t//Serial.println(pitch);\n\t//pitch = 180 - pitch;\n\t//Serial.println(pitch);\n\t//pitch = pitch / 180 * 200;\n\t//Serial.println(pitch);\n\t//pitch = 200 - pitch;\n\t//Serial.println(pitch);\n\t//pitch = pitch / 200 * 180;\n\t//Serial.println(pitch);\n\t//pitch = 180 - pitch;\n\t//Serial.println(pitch);\n\t//pitch = pitch / 180 * 200;\n\t//Serial.println(pitch);\n\t//pitch = 200 - pitch;\n\t//Serial.println(pitch);\n\t//pitch = pitch / 200 * 180;\n\t//Serial.println(pitch);\n\t//pitch = 180 - pitch;\n\t//Serial.println(pitch);\n\t//pitch = pitch / 180 * 200;\n\t//Serial.println(pitch);\n\t//pitch = 200 - pitch;\n\t//Serial.println(pitch);\n\t//pitch = pitch / 200 * 180;\n\t//Serial.println(pitch);\n\t//pitch = 180 - pitch;\n\t//Serial.println(pitch);\n\t//pitch = pitch / 180 * 200;\n\t//Serial.println(pitch);\n\t//pitch = 200", "CodeBleu_score": 9.20160373497307}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tif (pitch > 180) {\n    pitch = 180;\n  } else if (pitch < 0) {\n    pitch = 0;\n  }\n  if (pitch > 90) {\n    pitch = 90;\n  } else if (pitch < 0) {\n    pitch = 0;\n  }\n  //map(pitch, 0, 180, 1000, 2000);\n  //pitch = map(pitch, 0, 180, 1000, 2000);\n  pitch = 1500 + (pitch * 5);\n  if (pitch < 1000) {\n    pitch = 1000;\n  } else if (pitch > 2000) {\n    pitch = 2000;\n  }\n  //Serial.println(pitch);\n  //pitch = map(pitch, 0, 180, 1000, 2000);\n  //Serial.println(pitch);\n  //Serial.println(pitch);\n  pitch_onoff_servo.writeMicroseconds(pitch);\n}", "CodeBleu_score": 18.914905071911512}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call base class barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if we get this far, baro is good\n    if (_flags.baro_hgt == 0) {\n        return true;\n    }\n\n    // if we are using GPS altitude then we can't do a baro check\n    if (_flags.gps_hgt) {\n        return true;\n    }\n\n    // if baro health is good then return true\n    if (_flags.baro_hgt == 2) {\n        return true;\n    }\n\n    // if we get this far then we have a baro altitude\n    float baro_alt = _barometer->get_altitude();\n    float inav_alt = _inertial_nav.get_altitude();\n\n    // check for large difference between baro and inav altitude\n    if (fabsf(baro_alt - inav_alt) > 2000) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm:Baro\"));\n        }\n        return false;\n    }\n\n    // baro looks good\n    return true;\n}", "CodeBleu_score": 44.389941641998256}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call the base class's barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // return immediately if we don't care about the baro check\n    if (!arming_checks_enabled(ARMING_CHECK_BARO)) {\n        return true;\n    }\n\n    // check baro reference\n    if (!_baro.get_reference()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"baro ref\"));\n        }\n        return false;\n    }\n\n    // check baro altitude\n    float baro_alt = _baro.get_altitude();\n    float inav_alt = _inertial_nav.get_altitude();\n    float alt_error = fabsf(baro_alt - inav_alt);\n    if (alt_error > BARO_ALT_MAX_DISPARITY) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING,PSTR(\"baro alt:%d\"),(int)alt_error);\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 50.43677130071359}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (arming_checks & ARMING_CHECK_BARO) {\n        // check baro\n        if (!_baro_healthy) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Barometer not healthy\"));\n            }\n            return false;\n        }\n        if (!_baro_calibrated) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Barometer not calibrated\"));\n            }\n            return false;\n        }\n        // check baro altitude\n        float baro_alt = _baro_alt;\n        if (fabsf(baro_alt - _inertial_nav.get_altitude()) > BARO_ALT_MAX_DISPARITY) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro altitude disparity\"));\n            }\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 47.719442345233}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (copter.wp_nav->get_terrain_source() == AP_WaypointNavigator::TERRAIN_SOURCE_RF) {\n        return false;\n    }\n    if (copter.wp_nav->get_terrain_source() == AP_WaypointNavigator::TERRAIN_SOURCE_TERRAINDB &&\n        copter.mode_rtl.get_alt_type() == AP_RTL::RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 76.49401797105764}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tconst AP_Terrain::TerrainSource terrain_source = _copter.wp_nav->get_terrain_source();\n    if (terrain_source == AP_Terrain::TerrainSource::RangeFinder) {\n        return false;\n    }\n    if (terrain_source == AP_Terrain::TerrainSource::TerrainDatabase && _copter.mode_rtl.get_alt_type() == AP_RTL::RTL_Altitude_Terrain) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 71.20044884357071}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (copter.wp_nav->get_terrain_source() == AP_Waypoint_Navigator::TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (copter.wp_nav->get_terrain_source() == AP_Waypoint_Navigator::TERRAIN_SOURCE_TERRAINDB &&\n        copter.mode_rtl.get_alt_type() == AP_RTL::ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 77.08013782701559}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// set loop time for attitude, position, and motor controllers\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    position_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // run attitude rate controller\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 49.52909131893192}, {"code": "void Copter::run_rate_controller(){\n\tfloat dt = AP::scheduler.get_last_loop_time_s();\n    attitude_control->rate_controller_run(dt);\n    motors->set_dt(dt);\n    attitude_control->set_dt(dt);\n    position_control->set_dt(dt);\n}", "CodeBleu_score": 57.442463848366046}, {"code": "void Copter::run_rate_controller(){\n\t// set loop time\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // run attitude controller\n    attitude_control->rate_controller_run();\n\n    // run position controller\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    pos_control->rate_controller_run();\n\n    // run motor controllers\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->rate_controller_run();\n}", "CodeBleu_score": 46.27576679410842}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // check if location has changed\n    if (old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    // check if altitude frame has changed\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // update target location\n    mode_guided.set_destination(new_loc);\n\n    return true;\n}", "CodeBleu_score": 59.03617910994028}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit immediately if we're not in guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // get next waypoint\n    Location target_loc;\n    if (!flightmode->get_wp(target_loc)) {\n        return false;\n    }\n\n    // exit immediately if old location is same as new location\n    if (old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    // exit immediately if altitude frames are different\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set new location as target\n    mode_guided.set_destination(new_loc);\n\n    // return success\n    return true;\n}", "CodeBleu_score": 63.655730608335624}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit immediately if not in guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // get next waypoint\n    Location target_loc;\n    if (!flightmode->get_wp(target_loc)) {\n        return false;\n    }\n\n    // check if we've reached the waypoint\n    if (old_loc.same_loc_as(target_loc)) {\n        return false;\n    }\n\n    // check if altitude frame has changed\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set target location\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 70.04856616919047}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AUXSWITCH_HIGH) {\n        copter.set_mode(mode);\n    } else if (copter.flightmode->mode_number == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 57.463950081572854}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (channel_aux.get_aux_switch_position(ch_flag) == AUX_SWITCH_HIGH) {\n        copter.set_mode(mode);\n    } else if (copter.flightmode->mode_number == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 59.69722290464256}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode);\n    } else if (copter.flightmode->mode_number == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 58.683063669865774}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\tfloat roll_trim, pitch_trim;\n    float roll_input = channel_roll->get_control_in();\n    float pitch_input = channel_pitch->get_control_in();\n\n    // exit immediately if not in level mode\n    if (control_mode != LEVEL) {\n        return;\n    }\n\n    // calculate trim values from control inputs\n    roll_trim = ToRad(roll_input * 20.0f);\n    pitch_trim = ToRad(pitch_input * 20.0f);\n\n    // add trim to ahrs\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    gcs().send_text_P(SEVERITY_INFO,PSTR(\"Trim Saved\"));\n}", "CodeBleu_score": 51.73127733643004}, {"code": "void Copter::save_trim(){\n\tfloat roll_trim = 0.0f;\n    float pitch_trim = 0.0f;\n\n    // get roll and pitch trim\n    roll_trim = channel_roll->get_control_in() * ToRad(100.0f);\n    pitch_trim = channel_pitch->get_control_in() * ToRad(100.0f);\n\n    // add trim to ahrs\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    gcs().send_text_P(MAV_SEVERITY_INFO,PSTR(\"Trim Saved\"));\n}", "CodeBleu_score": 61.132612343585805}, {"code": "void Copter::save_trim(){\n\t// save trim\n    float roll_trim = channel_roll->get_control_in() * ToRad(4500);\n    float pitch_trim = channel_pitch->get_control_in() * ToRad(4500);\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send trim values\n    gcs_send_text_P(MAV_SEVERITY_INFO,\"Trim Saved\");\n}", "CodeBleu_score": 61.09352984831731}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat look_ahead_yaw = 0.0f;\n\n    // get the copter's velocity\n    Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // calculate the speed squared\n    float speed_sq = vel.length_squared();\n\n    // if the copter's position is valid and the speed exceeds a minimum threshold, calculate the look-ahead yaw angle\n    if (copter.position_ok && speed_sq > 100.0f) {\n        // calculate the look-ahead yaw angle\n        look_ahead_yaw = atan2f(vel.y, vel.x) * RADIANS_TO_DEGREES;\n    }\n\n    // return the look-ahead yaw angle\n    return look_ahead_yaw;\n}", "CodeBleu_score": 51.587035499219624}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat yaw;\n    float speed_sq;\n\n    // retrieve copter's velocity\n    Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // calculate speed squared\n    speed_sq = vel.xy().length_squared();\n\n    // if copter's position is valid and speed exceeds a minimum threshold, update look-ahead yaw angle using arctangent of velocity components\n    if (copter.position_ok && speed_sq > 100.0f) {\n        yaw = atan2f(vel.y, vel.x);\n    }\n\n    // return look-ahead yaw angle\n    return yaw;\n}", "CodeBleu_score": 50.7842245405072}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.xy().length_squared();\n    if (copter.position_ok && speed_sq > 250000) {\n        // we are moving at high speed, so we can trust the velocity estimate\n        float look_ahead_yaw = atan2f(vel.y, vel.x);\n        look_ahead_yaw = wrap_180_cd(look_ahead_yaw * 100);\n        return look_ahead_yaw;\n    }\n    return 0;\n}", "CodeBleu_score": 56.82511344953873}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// if arming checks are disabled or the watchdog was armed,\n    // bypass the checks and return true\n    if (!_arming_checks_enabled || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // rudder arming check\n    if (method == AP_Arming::RUDDER) {\n        if (get_rudder_arming_type() == AP_Arming::RUDDER_DISABLED) {\n            return false;\n        }\n        if (!plane.get_throttle_input()) {\n            return false;\n        }\n    }\n\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 47.28425645255807}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\n        if (is_zero(plane.get_rudder_input()) ||\n            plane.get_throttle_input() != 0) {\n            gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Rudder Arming Disabled\"));\n            return false;\n        }\n    }\n    if (!_arming_checks_enabled || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 55.8232876240498}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// exit immediately if arming checks are disabled or if the watchdog was armed\n    if (!_arming_checks_enabled || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // check for rudder arming\n    if (method == AP_Arming::RUDDER) {\n        if (plane.get_throttle_input() > 0.0f || !get_rudder_arming_type()) {\n            return false;\n        }\n    }\n\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 41.99902833705698}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// exit immediately if already armed\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // check if we are in a low battery condition\n    if (!hal.util->battery_ok_to_arm()) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_rc_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_gps_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_barometer_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_compass_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_ins_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_rc_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_ins_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_ins_checks_complete() == false) {\n        return false;\n    }\n\n    // check if we are in a pre-arm check condition\n    if (plane.pre_arm_ins_checks_complete() == false) {\n        return false;\n    }", "CodeBleu_score": 33.100006358102554}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// don't allow arming if we are already armed\n    if (hal.util->get_soft_armed()) {\n        return false;\n    }\n\n    // don't allow arming if we are in a failsafe state\n    if (plane.failsafe.state() != AP_Rally::FAILSAFE_NONE) {\n        return false;\n    }\n\n    // don't allow arming if the vehicle is not in a good position to arm\n    if (do_arming_checks && !arming_checks()) {\n        return false;\n    }\n\n    // don't allow arming if the vehicle is in a rally\n    if (plane.rally.enabled() && !plane.rally.arm_allowed()) {\n        return false;\n    }\n\n    // don't allow arming if the vehicle is in a fence\n    if (plane.fence.enabled() && !plane.fence.arm_allowed()) {\n        return false;\n    }\n\n    // don't allow arming if we are in a takeoff or landing\n    if (plane.control_mode == AUTO && (plane.auto_state.takeoff_complete || plane.auto_state.land_complete)) {\n        return false;\n    }\n\n    // don't allow arming if we are in a guided mode\n    if (plane.control_mode == GUIDED) {\n        return false;\n    }\n\n    // don't allow arming if we are in a circle mode\n    if (plane.control_mode == CIRCLE) {\n        return false;\n    }\n\n    // don't allow arming if we are in a loiter mode\n    if (plane.control_mode == LOITER) {\n        return false;\n    }\n\n    // don't allow arming if we are in a rtl mode\n    if (plane.control_mode == RTL) {\n        return false;\n    }\n\n    // don't allow arming if we are in a rtl mode\n    if (plane.control_mode == SMART_RTL) {\n        return false;\n    }", "CodeBleu_score": 31.972331734710902}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tif (method == AP_Arming::MANUAL) {\n        if (!hal.util->get_soft_armed()) {\n            plane.ahrs.set_home(plane.gps.location());\n            plane.ahrs.set_home_to_current_location();\n            plane.gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Arming from GCS\");\n        }\n    } else if (method == AP_Arming::GPS) {\n        if (!hal.util->get_soft_armed()) {\n            plane.ahrs.set_home(plane.gps.location());\n            plane.ahrs.set_home_to_current_location();\n            plane.gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Arming from GPS\");\n        }\n    } else if (method == AP_Arming::INS) {\n        if (!hal.util->get_soft_armed()) {\n            plane.ahrs.set_home(plane.ahrs.get_position());\n            plane.ahrs.set_home_to_current_location();\n            plane.gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Arming from INS\");\n        }\n    }\n\n    if (do_arming_checks && !check_all()) {\n        return false;\n    }\n\n    update_home();\n    update_current_loc();\n\n    hal.util->set_soft_armed(true);\n    change_arm_state();\n    delay_arming(true);\n    send_arm_disarm_statustext();\n\n    return true;\n}", "CodeBleu_score": 49.23483437378005}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // check if there is a disarm button\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            sub.armed_error_msg = ARMING_DISARM_BUTTON_MISSING;\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 74.19035000878125}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (armed()) {\n        return true;\n    }\n\n    // make sure the craft has a disarm button assigned before it is armed\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, PSTR(\"No disarm button assigned\"));\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.61922608179482}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // check for disarm button\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, \"No disarm button assigned\");\n        }\n        return false;\n    }\n\n    // standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 75.75976823436245}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x * cos_yaw + y * sin_yaw;\n  float ne_y = -x * sin_yaw + y * cos_yaw;\n\n  x = ne_x;\n  y = ne_y;\n}", "CodeBleu_score": 56.2511775137542}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n  ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n  ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n  x = ne_x;\n  y = ne_y;\n}", "CodeBleu_score": 58.46140169503787}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n  ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n  ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n  x = ne_x;\n  y = ne_y;\n}", "CodeBleu_score": 61.09234333797653}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tfloat yaw = packet.param1;\n    float yaw_rate = packet.param2;\n    float direction = packet.param3;\n    float relative_angle = packet.param4;\n\n    if (yaw < 0 || yaw > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (yaw_rate < 0 || yaw_rate > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (direction < 0 || direction > 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (relative_angle < 0 || relative_angle > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set_auto_yaw_look_at_heading(yaw, yaw_rate, direction, relative_angle);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 36.1891915271246}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tif (packet.param1 < 0 || packet.param1 > 36000) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param4 < 0 || packet.param4 > 36000) {\n        return MAV_RESULT_DENIED;\n    }\n    sub.mode_auto.set_auto_yaw_look_at_heading(ToRad(packet.param1/100.0f), packet.param4/100.0f);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.10923504569426}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tif (packet.param1 < 0 || packet.param1 > 36000) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param4 < 0 || packet.param4 > 36000) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s = math::radians(100.0f);\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s_accurate = math::radians(1.0f);\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s_accurate_threshold = math::radians(5.0f);\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s_normal_threshold = math::radians(20.0f);\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s_slow_threshold = math::radians(40.0f);\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s_slowest_threshold = math::radians(60.0f);\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s_slowest = math::radians(10.0f);\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s_slowest_threshold = math::radians(80.0f);\n\n\t// XXX: this should be a parameter\n\tfloat yaw_speed_rad_s_slowest = math::radians(10.0f);\n\n\tfloat yaw_speed_rad_s_accurate_threshold = math::radians(5.0f);\n\n\tfloat yaw_speed_rad_s_normal_threshold = math::radians(20.0f);\n\n\tfloat yaw_speed_rad_s_slow_threshold = math::rad", "CodeBleu_score": 30.956784817705092}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tif (control_mode == MAV_MODE_GUIDED_ARMED || control_mode == MAV_MODE_GUIDED_DISARMED || control_mode == MAV_MODE_AUTO) {\n        return wrap_360_cd(wp_bearing_to_destination) / 2;\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 48.46659858202457}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tuint8_t tgt_heading = 0;\n\tif (control_mode == MAV_MODE_GUIDED_ARMED || control_mode == MAV_MODE_GUIDED_DISARMED || control_mode == MAV_MODE_AUTO) {\n\t\ttgt_heading = (uint8_t)(wrap_360_cd(waypoint_bearing) / 2);\n\t}\n\treturn tgt_heading;\n}", "CodeBleu_score": 40.082711669836144}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tif (control_mode == MAV_MODE_GUIDED_ARMED || control_mode == MAV_MODE_GUIDED_DISARMED || control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_AUTO_ARMED || control_mode == MAV_MODE_AUTO_DISARMED) {\n        return wrap_360_cd(next_wp_bearing) / 2;\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 44.32413405550024}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log) {\n    logger.WriteCriticalBlock(\n        LOG_PACKET_HEADER_INIT,\n        logger.GetCurrentTime(),\n        id,\n        value);\n  }\n}", "CodeBleu_score": 31.928533994867216}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log) {\n    LOG_PACKET_HEADER_INIT\n    logger.WriteCriticalBlock\n      should_log\n      AP_HAL::micros64\n\n\n\n\n", "CodeBleu_score": 15.003136146520877}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(id)) {\n        logger.WriteCriticalBlock(\n            LOG_PACKET_HEADER_INIT,\n            id,\n            value\n        );\n    }\n}", "CodeBleu_score": 32.38734057216208}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\tif (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 37.38323939811989}, {"code": "void Sub::update_home_from_EKF(){\n\t// exit immediately if home is already set\n    if (ahrs.home_is_set) {\n        return;\n    }\n    // set home to current location in-flight\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 51.52677472534798}, {"code": "void Sub::update_home_from_EKF(){\n\tif (ahrs.home_is_set()) {\n        // home already set\n        return;\n    }\n    if (motors.armed()) {\n        // set home to current location in-flight\n        set_home_to_current_location_inflight();\n    } else {\n        // set home to current location\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 55.543990573553224}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\tif (!motors.armed()) {\n        motors.set_throttle_out(0);\n        motors.set_desired_spool_state(Motors::SpoolState::Unlimited);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    motors.set_desired_spool_state(Motors::SpoolState::Unlimited);\n\n    attitude_control->set_throttle_out(channel_throttle->norm_input());\n    attitude_control->set_angle_boost(0);\n\n    attitude_control->input_rate_bf_roll_pitch_yaw(\n        channel_roll->get_control_in() * attitude_control->get_max_rate_yaw(),\n        channel_pitch->get_control_in() * attitude_control->get_max_rate_yaw(),\n        channel_yaw->get_control_in() * attitude_control->get_max_rate_yaw()\n    );\n\n    attitude_control->run();\n\n    motors.set_forward(channel_forward->norm_input());\n    motors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 54.61601427034364}, {"code": "void ModeAcro::run(){\n\tif (!motors.armed()) {\n        motors.set_throttle_out(0, true);\n        motors.set_desired_spool_state(AP_Motors::SpoolState_Idle);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    motors.set_desired_spool_state(AP_Motors::SpoolState_Unlimited);\n\n    // convert pilot input to desired body frame rates\n    attitude_control->get_pilot_desired_angle_rates(channel_roll->norm_input(),\n                                                   channel_pitch->norm_input(),\n                                                   channel_yaw->norm_input());\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(channel_roll->get_control_in(),\n                                                   channel_pitch->get_control_in(),\n                                                   channel_yaw->get_control_in());\n\n    // output pilot's throttle input without angle boost\n    motors.set_throttle_out(channel_throttle->norm_input(), false);\n\n    // set forward and lateral motor inputs\n    motors.set_forward(channel_throttle->get_control_in());\n    motors.set_lateral(channel_lateral->get_control_in());\n}", "CodeBleu_score": 52.40597754269161}, {"code": "void ModeAcro::run(){\n\t// if motors not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n    if (!motors.armed()) {\n        motors.set_throttle_out(0, true);\n        motors.set_desired_spool_state(AP_Motors::Spool_Idle);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // if armed, set spool state to unlimited throttle\n    motors.set_desired_spool_state(AP_Motors::Spool_Unlimited);\n\n    // convert pilot inputs to desired body frame rates\n    get_pilot_desired_angle_rates();\n\n    // run attitude controller with pilot's desired angle rates\n    attitude_control->input_rate_bf_roll_pitch_yaw(channel_roll->get_control_in(), channel_pitch->get_control_in(), channel_yaw->get_control_in());\n\n    // output pilot's throttle input without angle boost\n    motors.set_throttle_out(channel_throttle->norm_input(), false);\n\n    // set forward and lateral motor inputs based on pilot controls\n    motors.set_forward(channel_throttle->norm_input());\n    motors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 43.16098719253794}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// initialize wpnav\n    sub.wp_nav.init(true);\n    sub.wp_nav.set_guided_WP();\n    sub.wp_nav.set_destination(sub.wp_nav.get_wp_stopping_point());\n    sub.auto_yaw_mode = get_default_auto_yaw_mode();\n    set_auto_yaw_mode(sub.auto_yaw_mode);\n    sub.wp_nav.set_speed_xy(sub.wp_nav.get_cruise_speed());\n    sub.wp_nav.set_speed_z(sub.wp_nav.get_cruise_speed(), true);\n}", "CodeBleu_score": 39.27248341195661}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set target to stopping point\n    wp_nav.set_wp_stopping_point_xy(inertial_nav.get_position());\n\n    // set target to destination\n    wp_nav.set_wp_destination(wp_nav.get_wp_stopping_point());\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n\n    // set guided_WP_yaw_mode to true\n    guided_WP_yaw_mode = true;\n\n    // set guided_WP_yaw_mode to true\n    guided_WP_yaw_mode = true;\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n\n    // set guided_WP_yaw_mode to true\n    guided_WP_yaw_mode = true;\n\n    // set guided_WP_yaw_mode to true\n    guided_WP_yaw_mode = true;\n}", "CodeBleu_score": 42.2510480590149}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set guided position control mode\n    pos_control.set_mode(AUTO);\n\n    // get the stopping point\n    wp_nav.get_wp_stopping_point(stopping_point);\n\n    // set destination to stopping point\n    wp_nav.set_wp_destination(stopping_point);\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 40.233327064203955}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// initialize vertical speeds and accelerations\n    position_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);\n    position_control->set_accel_z(-g.pilot_accel_z);\n\n    // initialize horizontal speed and acceleration controllers\n    position_control->init_xy_controller(g.pilot_accel_xy, g.pilot_accel_z);\n\n    // initialize vertical speed and acceleration controllers\n    position_control->init_z_controller(g.pilot_accel_z);\n\n    // set target vertical speed to zero\n    position_control->set_speed_z(0, 0);\n\n    // set target horizontal speed and acceleration to zero\n    position_control->set_speed_xy(0, 0);\n    position_control->set_accel_xy(0, 0);\n\n    // set target yaw rate to zero\n    attitude_control->set_yaw_target_to_current_heading();\n\n    // initialise yaw control mode\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 48.92412940253427}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set vertical speeds and accelerations\n    position_control->set_speed_z(sub.get_pilot_desired_speed_z(), sub.get_pilot_accel_z());\n\n    // initialize vertical position controller\n    position_control->init_z_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_controller();\n\n    // set yaw control mode\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n\n    // clear loiter target\n    wp_nav.clear_loiter_target();\n}", "CodeBleu_score": 42.987360095620765}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// initialise vertical speed and acceleration\n    position_control->set_speed_z(-sub.pilot_accel_z, sub.pilot_accel_z);\n    position_control->set_accel_z(-sub.pilot_accel_z, sub.pilot_accel_z);\n\n    // initialise horizontal speed and acceleration\n    position_control->set_speed_xy(sub.pilot_accel_xy);\n    position_control->set_accel_xy(sub.pilot_accel_xy);\n\n    // initialise horizontal position controller\n    position_control->init_xy_controller();\n\n    // initialise vertical position controller\n    position_control->init_z_controller();\n\n    // initialise yaw controller\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 52.533683631366756}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\tif (guided_limit.start_time_ms == 0) {\n        guided_limit.start_time_ms = millis();\n    }\n    if (guided_limit.start_pos.alt == 0) {\n        guided_limit.start_pos.alt = inertial_nav.get_altitude();\n    }\n    if (guided_limit.start_pos.xy.x == 0 && guided_limit.start_pos.xy.y == 0) {\n        guided_limit.start_pos.xy = inertial_nav.get_position_neu_cm();\n    }\n    if (is_zero(guided_limit.start_pos.xy.x) || is_zero(guided_limit.start_pos.xy.y)) {\n        guided_limit.start_pos.xy = inertial_nav.get_position_neu_cm();\n    }\n\n    // check for timeout\n    if (guided_limit.timeout_ms > 0 && (millis() - guided_limit.start_time_ms) > guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // check for minimum altitude\n    if (guided_limit.min_alt_cm > 0 && inertial_nav.get_altitude() < guided_limit.start_pos.alt - guided_limit.min_alt_cm) {\n        return true;\n    }\n\n    // check for maximum altitude\n    if (guided_limit.max_alt_cm > 0 && inertial_nav.get_altitude() > guided_limit.start_pos.alt + guided_limit.max_alt_cm) {\n        return true;\n    }\n\n    // check for horizontal distance moved\n    if (guided_limit.max_xy_cm > 0 && get_horizontal_distance_cm(guided_limit.start_pos.xy, inertial_nav.get_position_neu_cm()) > guided_limit.max_xy_cm) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 52.72270652154391}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// check for time out\n    if (g.guided_timeout > 0 && (millis() - guided_limit.start_time_ms) > g.guided_timeout*1000) {\n        return true;\n    }\n\n    // check for altitude limits\n    if (g.guided_min_alt > 0 && current_loc.alt < g.guided_min_alt) {\n        return true;\n    }\n\n    if (g.guided_max_alt > 0 && current_loc.alt > g.guided_max_alt) {\n        return true;\n    }\n\n    // check for horizontal distance limits\n    if (g.guided_max_hor_distance > 0) {\n        // get horizontal distance moved\n        Vector3f delta_pos = inertial_nav.get_position_neu_cm() - guided_limit.start_pos;\n        float horizontal_distance = pythagorous2(delta_pos.x, delta_pos.y);\n        if (horizontal_distance > g.guided_max_hor_distance) {\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 57.50564706834306}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// check if we have reached the end of the waypoint\n    if (g.guided_limit_wp_cm <= 0) {\n        return false;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp_cm)) {\n        return true;\n    }\n\n    // check if we have reached the end of the guided mode\n    if (is_zero(g.guided_limit_wp", "CodeBleu_score": 48.89064388487561}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\tif (hal.scheduler->millis() - motor_test_start_time > 1000) {\n        motor_test_start_time = hal.scheduler->millis();\n        if (motor_test_start_time == 0) {\n            motor_test_start_time = 1;\n        }\n        if (motor_test_request_time != 0 && hal.scheduler->millis() - motor_test_request_time > 500) {\n            gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Motor test timeout\"));\n            pass = false;\n            gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Motor test failed\"));\n            AP::arming().disarm();\n            motor_test_complete = true;\n            motor_test_passed = false;\n            motor_test_failed_time = hal.scheduler->millis();\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 51.451825413772625}, {"code": "bool Sub::verify_motor_test(){\n\tif (hal.scheduler->micros() - _motor_test_last_send_micros > 1000000UL) {\n        gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Motor test timeout\"));\n        _motor_test_pass = false;\n        _motor_test_enabled = false;\n        AP_HAL::millis(_motor_test_start_time);\n        AP_HAL::millis(_motor_test_end_time);\n        AP_HAL::millis(_motor_test_last_send_micros);\n        AP::arming().disarm();\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 51.8858202861318}, {"code": "bool Sub::verify_motor_test(){\n\tuint32_t now = hal.scheduler->millis();\n    if ((now - motor_test_last_received_time) > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        motor_test_pass = false;\n        motor_test_enabled = false;\n        AP_HAL::millis_t end_time = hal.scheduler->millis();\n        motor_test_failure_time = (end_time - motor_test_start_time) / 1000;\n        AP::arming().disarm();\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 54.43429134349762}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t//Retrieve the roll and pitch targets from wp_nav\n  int16_t roll_target = wp_nav.get_roll();\n  int16_t pitch_target = wp_nav.get_pitch();\n\n  //Constrain the targets within a specified maximum angle range\n  roll_target = constrain_int16(roll_target, -MAX_ROLL_ANGLE_WPNAV, MAX_ROLL_ANGLE_WPNAV);\n  pitch_target = constrain_int16(pitch_target, -MAX_PITCH_ANGLE_WPNAV, MAX_PITCH_ANGLE_WPNAV);\n\n  //Normalize the targets\n  lateral_out = (float)roll_target / MAX_ROLL_ANGLE_WPNAV;\n  forward_out = (float)pitch_target / MAX_PITCH_ANGLE_WPNAV;\n\n  //Print the targets\n  //Serial.print(\"roll_target: \");\n  //Serial.print(roll_target);\n  //Serial.print(\" pitch_target: \");\n  //Serial.println(pitch_target);\n}", "CodeBleu_score": 45.66396344037595}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// get the roll and pitch targets in centidegrees\n    int16_t roll_cd = wp_nav.get_roll();\n    int16_t pitch_cd = wp_nav.get_pitch();\n\n    // constrain the targets within a specified maximum angle range\n    roll_cd = constrain_int16(roll_cd, -max_roll_cd, max_roll_cd);\n    pitch_cd = constrain_int16(pitch_cd, -max_pitch_cd, max_pitch_cd);\n\n    // normalize the targets\n    lateral_out = (float)roll_cd / max_roll_cd;\n    forward_out = (float)pitch_cd / max_pitch_cd;\n}", "CodeBleu_score": 47.48567642187936}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Retrieve roll and pitch targets from wp_nav in centidegrees\n    float roll_target = wp_nav.get_roll() * 100.0;\n    float pitch_target = wp_nav.get_pitch() * 100.0;\n\n    // Constrain the targets within a specified maximum angle range\n    roll_target = constrain_int16(roll_target, -wp_nav_max_roll_angle_cdeg, wp_nav_max_roll_angle_cdeg);\n    pitch_target = constrain_int16(pitch_target, -wp_nav_max_pitch_angle_cdeg, wp_nav_max_pitch_angle_cdeg);\n\n    // Normalize the targets\n    float roll_norm = (roll_target + wp_nav_max_roll_angle_cdeg) / (2 * wp_nav_max_roll_angle_cdeg);\n    float pitch_norm = (pitch_target + wp_nav_max_pitch_angle_cdeg) / (2 * wp_nav_max_pitch_angle_cdeg);\n\n    // Assign the normalized values to lateral_out and forward_out\n    lateral_out = roll_norm;\n    forward_out = pitch_norm;\n}", "CodeBleu_score": 42.15234966759145}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\tif (barometer.update()) {\n        if (barometer.get_altitude() > 0) {\n            barometer.update_calibration();\n        }\n        if (depth_sensor.present) {\n            if (barometer.healthy) {\n                depth_sensor.healthy = true;\n            }\n            else {\n                depth_sensor.healthy = false;\n            }\n        }\n    }\n}", "CodeBleu_score": 65.66122058305015}, {"code": "void Sub::read_barometer(){\n\t// read the barometer\n  baro_sensor.update();\n\n  // if the altitude is above zero, update the calibration\n  if (baro_sensor.get_altitude() > 0) {\n    baro_sensor.update_calibration();\n  }\n\n  // if the depth sensor is present, update the sensor health status based on the barometer's health\n  if (depth_sensor.present) {\n    depth_sensor.healthy = baro_sensor.healthy;\n  }\n}", "CodeBleu_score": 62.06527586997473}, {"code": "void Sub::read_barometer(){\n\tif (barometer.get_altitude() > 0) {\n    barometer.update_calibration();\n  }\n  if (depth_sensor.present) {\n    depth_sensor.healthy = barometer.healthy;\n  }\n}", "CodeBleu_score": 61.130314332910515}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\tif (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return true;\n    }\n    if (inertial_nav.have_position() && !inertial_nav.get_filter_status().pred_pos_horiz_abs) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 47.23757595905106}, {"code": "bool Sub::ekf_position_ok(){\n\tif (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return true;\n    }\n    if (!inertial_nav.get_filter_status().flags.optflow) {\n        return false;\n    }\n    if (inertial_nav.get_filter_status().flags.pred_pos_horiz) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.const_pos_mode) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 53.622728314121694}, {"code": "bool Sub::ekf_position_ok(){\n\tif (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return true;\n    }\n    if (!ekf.position_ok()) {\n        return false;\n    }\n    if (ekf.get_filter_status().flags.in_flight) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 45.892068311331634}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!control_mode->requires_position() && !control_mode->requires_velocity()) {\n        return true;\n    }\n\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, PSTR(\"PreArm: AHRS\"));\n        }\n        return false;\n    }\n\n    if (!rover.ekf_position_ok()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, PSTR(\"PreArm: EKF\"));\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 52.3788985123952}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if we don't need position or velocity, we are good\n    if (!ap.control_mode->requires_position() && !ap.control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, PSTR(\"PreArm: AHRS not ready\"));\n        }\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ap.ekf_position_ok()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, PSTR(\"PreArm: EKF failsafe active\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ap.position_ok()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, PSTR(\"PreArm: Position not valid\"));\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 61.99291848938777}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if we don't need position or velocity, we don't need to check GPS\n    if (!control_mode->requires_position() && !control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check AHRS system is ready\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, PSTR(\"Pre-Arm: AHRS not ready\"));\n        }\n        return false;\n    }\n\n    // check EKF failsafe is not triggered\n    if (ahrs.get_ekf().get_failsafe_status() == AP_AHRS::EKF_FAILSAFE_TRIGGERED) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, PSTR(\"Pre-Arm: EKF failsafe\"));\n        }\n        return false;\n    }\n\n    // check position estimate is valid\n    if (!rover.ekf_position_ok()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, PSTR(\"Pre-Arm: EKF position invalid\"));\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 55.77835714946306}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // exit immediately if safety switch is not engaged\n    if (!hal.util->safety_switch_state()) {\n        return false;\n    }\n\n    // exit immediately if we are not allowed to arm\n    if (!can_arm(method)) {\n        return false;\n    }\n\n    // perform arming checks if required\n    if (do_arming_checks && !pre_arm_checks(method)) {\n        return false;\n    }\n\n    // perform arming checks if required\n    if (do_arming_checks && !pre_arm_checks(method)) {\n        return false;\n    }\n\n    // update armed state\n    _armed = true;\n\n    // set SmartRTL home location\n    rover.g2.smart_rtl.set_home();\n\n    // initialize simple mode heading\n    rover.mode_simple.init_heading();\n\n    // record home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    send_arm_disarm_statustext();\n\n    return true;\n}", "CodeBleu_score": 56.55609714722465}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // perform arming checks if required\n    if (do_arming_checks) {\n        if (!pre_arm_checks(method)) {\n            return false;\n        }\n    }\n\n    // exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // set armed state\n    armed = true;\n\n    // set SmartRTL home location\n    rover.g2.smart_rtl.set_home();\n\n    // initialize simple mode heading\n    rover.mode_simple.init_heading();\n\n    // record home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    send_arm_disarm_statustext();\n\n    return true;\n}", "CodeBleu_score": 60.532306521653936}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks) {\n        // perform arming checks\n        if (!pre_arm_checks(true)) {\n            // arming checks failed\n            return false;\n        }\n    }\n\n    // set armed state\n    set_armed(true);\n\n    // set home location\n    rover.g2.smart_rtl.set_home();\n\n    // set simple mode heading\n    rover.mode_simple.init_heading();\n\n    // record home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    send_arm_disarm_statustext();\n\n    return true;\n}", "CodeBleu_score": 49.5187202200873}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (charging_enabled) {\n                charging_enabled = false;\n                charging_disabled_time = millis();\n            }\n        } else {\n            if (!charging_enabled) {\n                charging_enabled = true;\n                charging_disabled_time = 0;\n            }\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            charging_disabled_time = millis();\n        }\n        if (charging_disabled_time != 0 && millis() - charging_disabled_time > 10000) {\n            charging_disabled_time = 0;\n        }\n    }\n}", "CodeBleu_score": 52.1479470102608}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed && !charging_enabled && checkShouldCharge()) {\n        // Enable charging\n        charging_enabled = true;\n        digitalWrite(PIN_CHARGING_ENABLE, HIGH);\n        charging_disabled_time = 0;\n        return;\n    }\n\n    if (!charging_allowed || !checkShouldCharge()) {\n        // Disable charging\n        charging_enabled = false;\n        digitalWrite(PIN_CHARGING_ENABLE, LOW);\n        charging_disabled_time = millis();\n        return;\n    }\n\n    if (charging_disabled_time > 0 && millis() - charging_disabled_time > CHARGING_DISABLE_TIMEOUT) {\n        // Retry enabling charging\n        charging_disabled_time = 0;\n        updateChargingEnabled();\n    }\n}", "CodeBleu_score": 54.659451731072274}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed && checkShouldCharge()) {\n        charging_enabled = false;\n        charging_disabled_timestamp = millis();\n    } else if (!charging_allowed || !checkShouldCharge()) {\n        if (charging_enabled) {\n            charging_enabled = false;\n            charging_disabled_timestamp = millis();\n        } else if (charging_disabled_timestamp + CHARGING_DISABLED_DELAY_MS < millis()) {\n            charging_enabled = true;\n        }\n    }\n}", "CodeBleu_score": 45.31985634421505}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\tif (rosRunning) {\n        if (size >= 4) {\n            uint16_t crc = CRC16.ccitt((uint8_t *) message, size);\n            memcpy((uint8_t *) message + size, &crc, 2);\n            packetSerial.send(message, size + 2);\n        }\n    }\n}", "CodeBleu_score": 46.57524887773298}, {"code": "void sendMessage(void *message, size_t size){\n\tif (rosRunning && size >= 4) {\n    uint16_t crc = CRC16.ccitt((uint8_t*)message, size);\n    packetSerial.send(message, size);\n    packetSerial.send(&crc, 2);\n  }\n}", "CodeBleu_score": 36.57582428898123}, {"code": "void sendMessage(void *message, size_t size){\n\t// Check if ROS is running and the message size is at least 4 bytes\n    if (rosRunning && size >= 4) {\n        // Calculate CRC\n        uint16_t crc = CRC16.ccitt((uint8_t *) message, size);\n        // Append CRC to message\n        memcpy((uint8_t *) message + size, &crc, sizeof(crc));\n        // Send message\n        packetSerial.send((uint8_t *) message, size + sizeof(crc));\n    }\n}", "CodeBleu_score": 48.026413757467985}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\tsoundSerial.begin(9600);\n  soundSerial.flush();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial.read();\n  soundSerial", "CodeBleu_score": 35.92394569707748}, {"code": "bool MP3Sound::begin(){\n\tsoundSerial.begin(9600);\n  soundSerial.flush();\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x0F);\n  soundSerial.write(0x01);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0xEF);\n  delay(200);\n  if (soundSerial.available() > 0) {\n    if (soundSerial.read() == 0x7E) {\n      if (soundSerial.read() == 0xFF) {\n        if (soundSerial.read() == 0x06) {\n          if (soundSerial.read() == 0x00) {\n            if (soundSerial.read() == 0x00) {\n              if (soundSerial.read() == 0x00) {\n                if (soundSerial.read() == 0x00) {\n                  if (soundSerial.read() == 0xEF) {\n                    numSdTracks = soundSerial.read();\n                    return true;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 39.536367309251}, {"code": "bool MP3Sound::begin(){\n\tsoundSerial.begin(9600);\n  soundSerial.flush();\n  while (soundSerial.available()) {\n    soundSerial.read();\n  }\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x0F);\n  soundSerial.write(0x01);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0xEF);\n  delay(100);\n  if (soundSerial.available()) {\n    if (soundSerial.read() == 0x7E) {\n      if (soundSerial.read() == 0xFF) {\n        if (soundSerial.read() == 0x06) {\n          if (soundSerial.read() == 0x00) {\n            if (soundSerial.read() == 0xEF) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 46.75768088078674}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tint num_active_sounds = active_sounds.size();\n\tif (num_active_sounds == 0 || isPlaying())\n\t\treturn num_active_sounds;\n\t\n\t// Play the last sound in the active_sounds list.\n\tmyMP3 = active_sounds.back();\n\tmyMP3.play();\n\t\n\t// Remove the sound from the active_sounds list.\n\tactive_sounds.pop_back();\n\t\n\treturn active_sounds.size();\n}", "CodeBleu_score": 55.33439287467116}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t} else {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.2946511255404}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\tmyMP3.play(active_sounds.back());\n\tactive_sounds.pop_back();\n\treturn active_sounds.size();\n}", "CodeBleu_score": 42.966536449529855}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tbool command_handled = true;\n  AbstractCamera *ac = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      ac->mmf_request = r;\n      ac->mmf_request_size = r->size;\n      ac->mmf_request_position = 0;\n      ac->mmf_request_position_in_mmf = 0;\n      ac->mmf_request_pending = true;\n      ac->mmf_request_pending_step = 0;\n      ac->mmf_request_pending_step_size = 0;\n      ac->mmf_request_pending_step_position = 0;\n      ac->mmf_request_pending_step_position_in_mmf = 0;\n      ac->mmf_request_pending_step_size_in_mmf = 0;\n      ac->mmf_request_pending_step_data = NULL;\n      ac->mmf_request_pending_step_data_position = 0;\n      ac->mmf_request_pending_step_data_size = 0;\n      ac->mmf_request_pending_step_data_position_in_mmf = 0;\n      ac->mmf_request_pending_step_data_size_in_mmf = 0;\n      ac->mmf_request_pending_step_data_position_in_request = 0;\n      ac->mmf_request_pending_step_data_size_in_request = 0;\n      ac->mmf_request_pending_step_data_position_in_mmf_step = 0;\n      ac->mmf_request_pending_step_data_size_in_mmf_step = 0;\n      ac->mmf_request_pending_step_data_position_in_request_step = 0;\n      ac->mmf_request_pending_step_data_size_in_request_step = 0;\n      ac->mmf_request_pending_step_", "CodeBleu_score": 48.03568869919106}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *ac = (WbAbstractCamera *)d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      ac->memory_mapped_file_request = r;\n      ac->memory_mapped_file_request_size = r->size;\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 48.90981559062474}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *ac = (WbAbstractCamera *)d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      ac->memory_mapped_file_request = r;\n      ac->memory_mapped_file_request->pointer = NULL;\n      ac->memory_mapped_file_request->size = 0;\n      ac->memory_mapped_file_request->is_get = false;\n      ac->memory_mapped_file_request->is_request_read = false;\n      ac->memory_mapped_file_request->is_request_write = true;\n      ac->memory_mapped_file_request->is_c_string = false;\n      ac->memory_mapped_file_request->is_overwritten = false;\n      ac->memory_mapped_file_request->is_image = false;\n      ac->memory_mapped_file_request->is_image_loaded = false;\n      ac->memory_mapped_file_request->is_image_requested = false;\n      ac->memory_mapped_file_request->is_image_request_pending = false;\n      ac->memory_mapped_file_request->is_image_request_cancelled = false;\n      ac->memory_mapped_file_request->is_image_request_completed = false;\n      ac->memory_mapped_file_request->is_image_request_failed = false;\n      ac->memory_mapped_file_request->is_image_request_cancelled = false;\n      ac->memory_mapped_file_request->is_image_request_failed = false;\n      ac->memory_mapped_file_request->is_image_request_completed = false;\n      ac->memory_mapped_file_request->is_image_request_cancelled = false;\n      ac->memory_mapped_file_request->is_image_request_failed = false;\n      ac->memory_mapped_file_request->is_image_request_completed = false;\n      ac->", "CodeBleu_score": 42.73499400005364}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock_step();\n  WbAbstractCamera *ac = d->pdata;\n  if (ac->has_get_info) {\n    robot_mutex_unlock_step();\n    return ac->height;\n  }\n  robot_mutex_unlock_step();\n  return -1;\n}", "CodeBleu_score": 54.866026794201694}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock_step();\n  int result = -1;\n  if (d->pdata) {\n    WbAbstractCameraData *data = d->pdata;\n    result = data->height;\n  }\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 63.56666616310027}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock_step();\n  int result = -1;\n  WbAbstractCamera *ac = d->pdata;\n  if (ac && ac->data) {\n    result = ac->data->height;\n  }\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 65.00293441456326}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (!accelerometer)\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  else\n    sampling_period = accelerometer->sampling_period;\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 53.173459493525286}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 59.840755812614276}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 59.60300465591681}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(const_cast<char *>(dms));\n  return result;\n}", "CodeBleu_score": 49.16345430591673}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result = string(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 44.961763127535825}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 39.49280121053885}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass,\"argument not a box\");\n    dUASSERT(plane,\"argument not a plane\");\n\n    const dReal* sides = ((dxBox*)g)->side;\n    const dReal* pos = g->final_posr->pos;\n    const dReal* R = g->final_posr->R;\n\n    dVector3 diff;\n    dSubtractVectors3(diff, x, y, z, pos);\n\n    dVector3 r;\n    dMultiply0_331(r, R, diff);\n\n    // check each axis for proximity to the box's surface\n    dReal Q1 = dCalcVectorDot3_41(r, sides);\n    dReal Q2 = dCalcVectorDot3_41(r, sides + 1);\n    dReal Q3 = dCalcVectorDot3_41(r, sides + 2);\n\n    // set the plane's normal and distance based on the closest surface\n    if (dFabs(Q1) > dFabs(Q2)) {\n        if (dFabs(Q1) > dFabs(Q3)) {\n            plane[0] = R[0];\n            plane[1] = R[4];\n            plane[2] = R[8];\n            plane[3] = -dCalcVectorDot3_331(pos, R, sides);\n        } else {\n            plane[0] = R[2];\n            plane[1] = R[6];\n            plane[2] = R[10];\n            plane[3] = -dCalcVectorDot3_331(pos, R, sides + 2);\n        }\n    } else {\n        if (dFabs(Q2) > dFabs(Q3)) {\n            plane[0] = R[1];\n            plane[1] = R[5];\n            plane[2] = R[9];\n            plane[3] = -dCalcVectorDot3_331(pos, R, sides + 1);\n        } else {\n            plane[0", "CodeBleu_score": 41.74202798801082}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tconst dReal* R;\n  const dReal* pos;\n  dVector3 diff;\n  dVector3 normal;\n  dReal depth;\n  dReal length;\n  int i;\n  int closest;\n  dReal closest_distance;\n  dReal distance;\n  dGeomBoxGetParams(g, normal, &depth);\n  R = dGeomGetRotation(g);\n  pos = dGeomGetPosition(g);\n  diff[0] = x - pos[0];\n  diff[1] = y - pos[1];\n  diff[2] = z - pos[2];\n  dMultiply0_331(normal, R, normal);\n  closest = 0;\n  closest_distance = dFabs(dCalcVectorDot3_41(normal, diff));\n  for (i = 1; i < 3; i++) {\n    dCalcVectorCross3(normal, normal, R + i*4);\n    length = dCalcVectorDot3_41(normal, normal);\n    if (length > 0) {\n      normal[0] /= length;\n      normal[1] /= length;\n      normal[2] /= length;\n      distance = dFabs(dCalcVectorDot3_41(normal, diff));\n      if (distance < closest_distance) {\n        closest_distance = distance;\n        closest = i;\n      }\n    }\n  }\n  plane[0] = normal[0];\n  plane[1] = normal[1];\n  plane[2] = normal[2];\n  plane[3] = -closest_distance;\n}", "CodeBleu_score": 40.610249078331485}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n    dGeomBoxGetParams(g, plane);\n    dReal* R = g->R;\n    dReal* pos = g->pos;\n    dVector3 v;\n    v[0] = x - pos[0];\n    v[1] = y - pos[1];\n    v[2] = z - pos[2];\n    dMultiply1_331(v, R, v);\n    plane[0] = 0;\n    plane[1] = 0;\n    plane[2] = 0;\n    plane[3] = 0;\n    if (dFabs(v[0]) > dFabs(v[1])) {\n        if (dFabs(v[0]) > dFabs(v[2])) {\n            plane[0] = dCalcVectorDot3_41(plane, v);\n            plane[0] = -dSign(plane[0]);\n        }\n        else {\n            plane[2] = dCalcVectorDot3_41(plane, v);\n            plane[2] = -dSign(plane[2]);\n        }\n    }\n    else if (dFabs(v[1]) > dFabs(v[2])) {\n        plane[1] = dCalcVectorDot3_41(plane, v);\n        plane[1] = -dSign(plane[1]);\n    }\n    else {\n        plane[2] = dCalcVectorDot3_41(plane, v);\n        plane[2] = -dSign(plane[2]);\n    }\n}", "CodeBleu_score": 35.68694207871778}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t// Make sure the box has a body\n  dUASSERT(box->body, \"The box must have a body\");\n\n  // Make sure the flags are valid\n  dUASSERT(flags & (1 | 2), \"The flags must be 1 or 2\");\n\n  // Initialize the immersion data\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.performImmersionChecking = (flags & 1) != 0;\n\n  // Perform the immersion checking\n  dIASSERT(box->body);\n  dImmerseBox_BoxBox(box->body, &data, 0, 1);\n\n  // Return the result\n  return data.immersion->isImmersed;\n}", "CodeBleu_score": 48.595665733690346}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t// make sure the object is a box\n  dUASSERT(box->type == dBoxClass, \"argument not an box\");\n\n  // make sure the object has a body\n  dUASSERT(box->body, \"box must have a body\");\n\n  // make sure the immersion is valid\n  dUASSERT(immersion, \"argument not an immersion\");\n\n  // make sure the flags are valid\n  dUASSERT(flags & (dImmerseBox1Flag | dImmerseBox2Flag), \"invalid flags\");\n\n  // initialize the immersion data\n  sBoxImmersionData data;\n  data.body = box->body;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n\n  // perform the immersion checking\n  data.performImmersionChecking = 1;\n  dSpaceCollide(0, &data, &sBoxImmersionData::sBoxImmersionCallBack);\n\n  return data.performImmersionChecking;\n}", "CodeBleu_score": 46.4795455924208}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT(box && fluidPlane && immersion, \"dxBox::dImmerseBox: Arguments are NULL\");\n  dUASSERT(box->body, \"dxBox::dImmerseBox: Box has no body\");\n  dUASSERT(flags & NUMI_MASK, \"dxBox::dImmerseBox: Invalid flags\");\n\n  dIASSERT(box->body);\n\n  // Initialize the immersion data\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.performImmersionChecking = flags & NUMI_MASK;\n\n  // Perform the immersion checking\n  return dImmerseBox_BoxImmersionData(&data);\n}", "CodeBleu_score": 48.17717205543901}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"The first object (a box) has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"The second object (a capsule) has no body and hence cannot be tested for immersion into a fluid\");\n\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n\n  // get axis of the capsule\n  dVector3 axis;\n  dGeomCapsuleGetAxis(capsule, axis);\n\n  // get the capsule radius\n  dReal radius = dGeomCapsuleGetRadius(capsule);\n\n  // get the box rotation matrix\n  dMatrix3 R;\n  dGeomBoxGetRotation(box, R);\n\n  // get the box position\n  dVector3 p;\n  dGeomBoxGetPosition(box, p);\n\n  // get the capsule position\n  dVector3 q;\n  dGeomCapsuleGetPosition(capsule, q);\n\n  // get the capsule length\n  dReal length = dGeomCapsuleGetLength(capsule);\n\n  // compute the capsule position in the box frame\n  dVector3 q_in_box;\n  dMultiply0_331(q_in_box, R, q - p);\n\n  // compute the capsule axis in the box frame\n  dVector3 axis_in_box;\n  dMultiply0_331(axis_in_box, R, axis);\n\n  // check if the capsule axis is parallel to a box axis\n  dReal parallel_axis = fabs(dCalcVectorDot3(axis_in_box, R + 0) - 1.0) +\n                        fabs(dCalcVectorDot3(axis_in_box, R + 4) - 1.0) +\n                        fabs(dCalcVectorDot3(axis_in_box, R + 8) - 1", "CodeBleu_score": 43.94428683759454}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->body, \"Both objects must be attached to a body\");\n\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n\n  // Get the box's position and rotation relative to the fluid.\n  dVector3 boxPosition;\n  dQuaternion boxRotation;\n  dGeomGetRelPointPos (box->gflags, box->final_posr->pos, box->final_posr->R, capsule->final_posr->pos, boxPosition);\n  dGeomGetQuaternion (box->gflags, box->final_posr->R, capsule->final_posr->R, boxRotation);\n\n  // Get the capsule's position and rotation relative to the fluid.\n  dVector3 capsulePosition;\n  dQuaternion capsuleRotation;\n  dGeomGetRelPointPos (capsule->gflags, capsule->final_posr->pos, capsule->final_posr->R, capsule->final_posr->pos, capsulePosition);\n  dGeomGetQuaternion (capsule->gflags, capsule->final_posr->R, capsule->final_posr->R, capsuleRotation);\n\n  // Get the box's dimensions.\n  dVector3 boxSize;\n  dGeomBoxGetLengths (box, boxSize);\n\n  // Get the capsule's dimensions.\n  dReal capsuleRadius, capsuleLength;\n  dGeomCapsuleGetParams (capsule, &capsuleRadius, &capsuleLength);\n\n  // Get the capsule's axis.\n  dVector3 capsuleAxis;\n  dGeomCapsuleGetAxis (capsule, capsuleAxis);\n\n  // Compute the box's normal.\n  dVector3 boxNormal;\n  dGeomBoxGetNormal (box, boxNormal);\n\n  // Compute the capsule's normal.\n  dVector3 capsuleNormal;", "CodeBleu_score": 44.54496041053528}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body && o2->body, \"This immersion function was not designed for use with two static geoms\");\n\n  dxBox *box = (dxBox*) o1;\n  dxCapsule *capsule = (dxCapsule*) o2;\n\n  // Make sure the box is actually a box\n  dUASSERT(box->type == dBoxClass, \"The first argument of dImmerseBoxCapsule is not a box\");\n\n  // Make sure the capsule is actually a capsule\n  dUASSERT(capsule->type == dCapsuleClass, \"The second argument of dImmerseBoxCapsule is not a capsule\");\n\n  // Make sure the two bodies are not the same\n  dUASSERT(box->body != capsule->body, \"The box and capsule are both connected to the same body\");\n\n  // Make sure the two geoms are not the same\n  dUASSERT(box != capsule, \"The arguments to dImmerseBoxCapsule are the same object\");\n\n  // Find the point on the box that is closest to the capsule line segment\n  dVector3 closestPoint;\n  dClosestPointOnBox(closestPoint, box, capsule->final_posr.position);\n\n  // Find the distance between the closest point on the box and the capsule line segment\n  dVector3 diff;\n  dSubtractVectors3(diff, closestPoint, capsule->final_posr.position);\n  dReal distance = dCalcVectorLength3(diff);\n\n  // If the closest point on the box is not within the capsule radius of the capsule line segment, then there is no collision\n  if (distance > capsule->radius)\n    return 0;\n\n  // Find the normalized direction vector from the capsule line segment to the closest point on the box\n  dVector3 normalizedDirectionVector;\n  dNormalize3(normalizedDirectionVector, diff);\n\n  // Find the point on the capsule line segment that is closest to the box\n  dVector3 closestPointOnCaps", "CodeBleu_score": 46.285259286049076}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t// Calculate the volume of the immersed hemisphere\n    dReal volume;\n    if (zIOverR < tanTheta0) {\n        // If the capsule is completely immersed, the volume is the entire volume of the hemisphere\n        volume = sHemisphereIntegrationData::volumeIntegrand(sinTheta1, 1.0);\n    } else {\n        // If the capsule is partially immersed, the volume is the volume of the hemisphere from the water line to the top of the hemisphere\n        volume = sHemisphereIntegrationData::volumeIntegrand(sinTheta1, 1.0) - sHemisphereIntegrationData::volumeIntegrand(tanTheta0, 1.0);\n    }\n    if (zIOverR > sinTheta1) {\n        // If the capsule is completely immersed, the volume is the entire volume of the hemisphere\n        volume += sHemisphereIntegrationData::volumeIntegrand(zIOverR, 1.0);\n    } else {\n        // If the capsule is partially immersed, the volume is the volume of the hemisphere from the water line to the top of the hemisphere\n        volume += sHemisphereIntegrationData::volumeIntegrand(zIOverR, 1.0) - sHemisphereIntegrationData::volumeIntegrand(sinTheta1, 1.0);\n    }\n    volume *= 0.5;\n\n    // Normalize the volume\n    volume *= 0.5 * M_PI;\n\n    return volume;\n}", "CodeBleu_score": 33.63668339223587}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t// The first part of the integration is from theta0 to theta1\n    dReal theta0 = atan(tanTheta0);\n    dReal theta1 = asin(sinTheta1);\n    dReal result1 = sSimpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(theta0, theta1, *this);\n\n    // The second part of the integration is from theta1 to theta2\n    dReal theta2 = M_PI_2 - theta0;\n    dReal result2 = sSimpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(theta1, theta2, *this);\n\n    // Return the sum of the two parts\n    return result1 + result2;\n}", "CodeBleu_score": 45.780612830709295}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t// The first integration is from theta0 to theta1\n    // The second integration is from theta1 to theta2\n    // The second integration is only necessary if theta2 is less than pi\n\n    // The integration limits are given by theta0 and theta2\n    // The integration is done from theta0 to theta1 and from theta1 to theta2\n\n    // This function calculates the volume of the hemisphere in the range theta0 to theta2\n    // The range theta0 to theta1 is handled by the first integration\n    // The range theta1 to theta2 is handled by the second integration\n\n    // This function is only called if theta0 is less than theta2\n    // The range theta0 to theta1 is handled by the first integration\n    // The range theta1 to theta2 is handled by the second integration\n\n    // This function is only called if theta0 is less than theta2\n    // The range theta0 to theta1 is handled by the first integration\n    // The range theta1 to theta2 is handled by the second integration\n\n    // The first integration is from theta0 to theta1\n    // The second integration is from theta1 to theta2\n    // The second integration is only necessary if theta2 is less than pi\n\n    // The integration limits are given by theta0 and theta2\n    // The integration is done from theta0 to theta1 and from theta1 to theta2\n\n    // This function calculates the volume of the hemisphere in the range theta0 to theta2\n    // The range theta0 to theta1 is handled by the first integration\n    // The range theta1 to theta2 is handled by the second integration\n\n    // This function is only called if theta0 is less than theta2\n    // The range theta0 to theta1 is handled by the first integration\n    // The range theta1 to theta2 is handled by the second integration\n\n    // This function is only called if theta0 is less than theta2\n    // The range theta0 to theta1 is handled by the first integration\n    // The range theta1 to theta", "CodeBleu_score": 7.0988038329265475}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tsHemisphereIntegrationData hemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1, volume);\n\n    return simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(hemisphereIntegrationData, 0.0, M_PI_2) / volume;\n}", "CodeBleu_score": 34.33471393543229}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\treturn volume * simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(zIOverR, tanTheta0, sinTheta1);\n}", "CodeBleu_score": 33.8140251409062}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tdReal xBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(zIOverR, tanTheta0, sinTheta1, volume);\n    return xBuoyancyCenter;\n}", "CodeBleu_score": 40.82477278609875}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh must be a body and the second a fluid\");\n\n  dxTriMesh *mesh = (dxTriMesh*) o2;\n  const dReal *mesh_pos = mesh->final_posr->pos;\n  const dReal *mesh_R = mesh->final_posr->R;\n  const dMatrix3& mesh_R_T = mesh->final_posr->R_T;\n\n  dxCapsule *capsule = (dxCapsule*) o1;\n  const dReal *capsule_pos = capsule->final_posr->pos;\n  const dReal *capsule_R = capsule->final_posr->R;\n  const dVector3& capsule_axis = capsule->final_posr->R[2];\n  dVector3 p,normal,point;\n  dReal depth;\n  dReal capsule_radius = capsule->radius;\n  dReal capsule_length = capsule->lz;\n  dReal fluid_plane_height = mesh->fluidPlane[3];\n  dReal fluid_plane_normal[4];\n  fluid_plane_normal[0] = mesh->fluidPlane[0];\n  fluid_plane_normal[1] = mesh->fluidPlane[1];\n  fluid_plane_normal[2] = mesh->fluidPlane[2];\n  fluid_plane_normal[3] = mesh->fluidPlane[3];\n\n  // Checking if the capsule is intersecting the fluid surface.\n  // If it is, we must find the intersection point.\n  if (dCollideCCTL(capsule_pos,capsule_R,capsule_length,capsule_radius,\n\t\t   mesh_pos,mesh_R,mesh_R_T,\n\t\t   fluid_plane_normal,fluid_plane_height,&depth,&normal,&point,0) == 1) {", "CodeBleu_score": 45.276354611061095}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"The first argument of dImmerseCapsuleTrimesh has no body and hence cannot be tested for immersion into a triangle mesh\");\n  dUASSERT(o2->type == dTriMeshClass, \"The second argument of dImmerseCapsuleTrimesh must be a triangle mesh\");\n\n  dxTriMesh *mesh = (dxTriMesh*) o2;\n  sCapsuleTrimeshImmersionData data(o1, mesh, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 40.834748310861954}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"The first argument of dImmerseCapsuleTrimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 29.942183737154537}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the sleep duration from the input\n  std::chrono::milliseconds duration = getInput<std::chrono::milliseconds>(0);\n  // If the duration is missing or non-positive, return SUCCESS\n  if (!duration.count()) {\n    return NodeStatus::SUCCESS;\n  }\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n  // Start a timer\n  timer_.add(duration, [this]() {\n    // Emit a wake-up signal\n    emitWakeUpSignal();\n  });\n  // Set a callback to emit a wake-up signal when the timer expires\n  timer_.setCallback(\n      [this]() {\n        // Emit a wake-up signal\n        emitWakeUpSignal();\n      });\n  // If the timer is aborted, ensure the timer_waiting_ flag is reset\n  timer_.setAbortedCallback(\n      [this]() {\n        timer_waiting_ = false;\n      });\n  // Indicate that the timer is waiting\n  timer_waiting_ = true;\n  // Return RUNNING\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 50.86145746041982}, {"code": "NodeStatus SleepNode::onStart(){\n\tif (getInput<std::chrono::milliseconds>(\"duration\", milliseconds_)) {\n    if (milliseconds_.count() <= 0) {\n      return NodeStatus::SUCCESS;\n    }\n    setStatus(NodeStatus::RUNNING);\n    timer_.add(milliseconds_, &SleepNode::emitWakeUpSignal, this);\n    timer_waiting_ = true;\n  }\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 35.08252010605251}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Get the sleep duration from the input\n  std::chrono::milliseconds sleep_duration;\n  if (getInput<std::chrono::milliseconds>(sleep_duration, \"sleep_duration\")) {\n    // If the sleep duration is missing or non-positive, return SUCCESS\n    if (sleep_duration.count() <= 0) {\n      return NodeStatus::SUCCESS;\n    }\n\n    // Set the node status to RUNNING\n    setStatus(NodeStatus::RUNNING);\n\n    // Start a timer\n    timer_.add(sleep_duration, [this]() {\n      // Emit a wake-up signal\n      emitWakeUpSignal();\n    });\n\n    // Set the timer_waiting_ flag\n    timer_waiting_ = true;\n  }\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 43.53655928353102}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// Get the entry\n\tBlackboard::Entry *entry = config().blackboard->getEntry(config().entry_name);\n\tif (entry == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\t// Lock the entry\n\tstd::unique_lock<std::mutex> lock(entry->mtx);\n\t// Check if the entry has been updated\n\tif (entry->seq_id != seq_id_) {\n\t\tseq_id_ = entry->seq_id;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 44.19245440832974}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tNodeStatus status = NodeStatus::FAILURE;\n\n    std::string entry_name = getInput<std::string>(\"entry_name\");\n    std::string entry_value = getInput<std::string>(\"entry_value\");\n\n    if (entry_name.empty()) {\n        throw BT::RuntimeError(\"error reading port [entry_name]: invalid data\");\n    }\n\n    if (entry_value.empty()) {\n        throw BT::RuntimeError(\"error reading port [entry_value]: invalid data\");\n    }\n\n    if (getInput<bool>(\"update_value\")) {\n        config().blackboard->set(entry_name, entry_value);\n    }\n\n    std::string stored_value = config().blackboard->get<std::string>(entry_name);\n    if (stored_value == entry_value) {\n        status = NodeStatus::SUCCESS;\n    }\n\n    return status;\n}", "CodeBleu_score": 41.73202688242647}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tstd::string entry_name = getInput<std::string>(\"entry_name\");\n    std::string entry_value = getInput<std::string>(\"entry_value\");\n\n    if (entry_name.empty()) {\n        throw BT::RuntimeError(\"error reading port [entry_name]: invalid entry name request\");\n    }\n\n    std::string stored_value = config().blackboard->getAny(entry_name);\n\n    if (stored_value != entry_value) {\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 41.695022989578284}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n        return children_nodes_.size() + success_threshold_;\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 52.585632009418106}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n    return std::max(static_cast<int>(children_nodes_.size()) + success_threshold_, 0);\n  }\n  return static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 58.00435260895771}, {"code": "size_t ParallelNode::successThreshold() const{\n\tsize_t threshold = std::max(success_threshold_, size_t(0));\n  if (threshold == 0) {\n    threshold = children_nodes_.size();\n  }\n  return threshold;\n}", "CodeBleu_score": 48.79278973252971}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile(ros::ok()) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    auto now = std::chrono::system_clock::now();\n    auto diff = now - _p->last_heartbeat;\n    bool is_active = diff < std::chrono::milliseconds(1000);\n    if(is_active != _p->heartbeat_active) {\n      _p->heartbeat_active = is_active;\n      enableAllHooks(_p->heartbeat_active);\n    }\n  }\n}", "CodeBleu_score": 52.043693453328}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile(!_p->stop_heartbeat_loop) {\n    // sleep for 10 milliseconds\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    // check heartbeat status\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    auto now = std::chrono::system_clock::now();\n    auto elapsed = now - _p->last_heartbeat;\n    auto elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count();\n    bool heartbeat_active = elapsed_ms < _p->heartbeat_timeout;\n    if(heartbeat_active != _p->heartbeat_active) {\n      _p->heartbeat_active = heartbeat_active;\n      // enable/disable breakpoints\n      enableAllHooks(_p->heartbeat_active);\n    }\n  }\n}", "CodeBleu_score": 54.335124241757995}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile (_p->running) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    if (_p->heartbeat_enabled) {\n      auto now = std::chrono::system_clock::now();\n      if (now - _p->last_heartbeat > std::chrono::milliseconds(500)) {\n        _p->heartbeat_enabled = false;\n        enableAllHooks(false);\n      }\n    }\n  }\n}", "CodeBleu_score": 53.085994137498716}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> bb_dump;\n    std::string bb_name;\n    std::stringstream ss(bb_list);\n    nlohmann::json bb_json;\n\n    while(std::getline(ss, bb_name, ' ')) {\n        auto it = subtrees.find(bb_name);\n        if (it != subtrees.end()) {\n            std::lock_guard<std::mutex> lock(it->second.lock);\n            if (it->second.valid) {\n                nlohmann::json bb_json = ExportBlackboardToJSON(it->second.tree);\n                bb_json[\"name\"] = bb_name;\n                bb_json[\"root_name\"] = it->second.tree.root_node->name;\n                bb_json[\"root_type\"] = it->second.tree.root_node->get_type();\n                bb_json[\"root_status\"] = it->second.tree.root_node->status;\n                bb_json[\"root_tick_count\"] = it->second.tree.root_node->tick_count;\n                bb_json[\"root_blackboard\"] = it->second.tree.root_node->blackboard;\n                bb_json[\"root_child_count\"] = it->second.tree.root_node->child_count;\n                bb_json[\"root_child_index\"] = it->second.tree.root_node->child_index;\n                bb_json[\"root_has_parent\"] = it->second.tree.root_node->has_parent;\n                bb_json[\"root_parent_index\"] = it->second.tree.root_node->parent_index;\n                bb_json[\"root_parent_name\"] = it->second.tree.root_node->parent_name;\n                bb_json[\"root_parent_type\"] = it->second.tree.root_node->parent_type;\n                bb_json[\"root_parent_status\"] = it->second.tree.root_node->parent_status;\n                bb_json[\"root_parent_tick_count\"] = it->", "CodeBleu_score": 35.68841637500098}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> msgpack_bb_list;\n    std::vector<std::string> bb_names = BT::splitString(bb_list, ',');\n    for (auto it = bb_names.begin(); it != bb_names.end(); it++) {\n        auto subtree = _p->subtrees.find(*it);\n        if (subtree != _p->subtrees.end()) {\n            subtree->second.lock.lock();\n            nlohmann::json bb_json = ExportBlackboardToJSON(subtree->second.root_node);\n            subtree->second.lock.unlock();\n            msgpack_bb_list.insert(msgpack_bb_list.end(), nlohmann::json::to_msgpack(bb_json).begin(), nlohmann::json::to_msgpack(bb_json).end());\n        }\n    }\n    return msgpack_bb_list;\n}", "CodeBleu_score": 53.18157251664428}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> bb_dump;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    nlohmann::json bb_dump_json;\n\n    while (std::getline(ss, bb_name, ' ')) {\n        if (bb_name.empty())\n            continue;\n\n        std::lock_guard<std::mutex> lock(_p->subtrees.at(bb_name)->lock);\n        if (_p->subtrees.at(bb_name)->valid) {\n            nlohmann::json bb_json = ExportBlackboardToJSON(bb_name);\n            bb_dump_json[bb_name] = bb_json;\n        }\n    }\n\n    bb_dump = nlohmann::json::to_msgpack(bb_dump_json);\n    return bb_dump;\n}", "CodeBleu_score": 45.842531698240556}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n    return false;\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->status != Status::BREAKPOINT)\n    return false;\n  hook->status = Status::READY;\n  hook->result = result;\n  hook->remove = remove;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 40.804258252962015}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if (hook->status != Hook::BREAKPOINT) {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 45.042712071307115}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->status != Hook::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 47.2282977287134}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  if (halt_requested_.load()) {\n    halt_requested_.store(false);\n    return prev_status;\n  }\n\n  try {\n    std::future<NodeStatus> future =\n        std::async(std::launch::async, tick_functor_, *this);\n\n    std::future_status status = future.wait_for(std::chrono::milliseconds(0));\n    while (status != std::future_status::ready) {\n      if (halt_requested_.load()) {\n        future.wait();\n        return prev_status;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n      status = future.wait_for(std::chrono::milliseconds(0));\n    }\n    NodeStatus tick_status = future.get();\n    if (tick_status != prev_status) {\n      setStatus(tick_status);\n    }\n    return tick_status;\n  } catch (std::exception& e) {\n    ROS_ERROR_STREAM(\"Exception in threaded tick: \" << e.what());\n    setStatus(NodeStatus::IDLE);\n    return NodeStatus::IDLE;\n  }\n}", "CodeBleu_score": 46.932580463769256}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  halt_requested_.store(false);\n\n  std::async(std::launch::async, [this] {\n    try {\n      NodeStatus status = tick_functor_(*this);\n\n      if(status != prev_status) {\n        setStatus(status);\n      }\n    } catch(std::exception& e) {\n      ROS_ERROR_STREAM(\"Exception in threaded action tick function: \" << e.what());\n      setStatus(NodeStatus::IDLE);\n    }\n  });\n\n  if(std::current_exception()) {\n    try {\n      std::rethrow_exception(std::current_exception());\n    } catch(std::exception& e) {\n      ROS_ERROR_STREAM(\"Exception in threaded action tick function: \" << e.what());\n      setStatus(NodeStatus::IDLE);\n    }\n  }\n\n  return status();\n}", "CodeBleu_score": 49.77504871108892}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  // Reset halt_requested_ to allow the tick function to run.\n  halt_requested_.store(false);\n\n  // Start a new asynchronous thread to run the tick function.\n  std::future<NodeStatus> future = std::async(std::launch::async, [this]() {\n    // Run the tick function.\n    NodeStatus status = tick_functor_(*this);\n\n    // If the tick function completes without a halt request, update the node status.\n    if (!halt_requested_.load()) {\n      setStatus(status);\n    }\n\n    return status;\n  });\n\n  // Wait for the asynchronous thread to complete.\n  try {\n    future.wait();\n  } catch (const std::exception& e) {\n    // If an exception occurs, log an error and set the node status to IDLE.\n    RCLCPP_ERROR(node_->get_logger(), \"Exception thrown while running asynchronous thread: %s\", e.what());\n    setStatus(NodeStatus::IDLE);\n  }\n\n  // If an exception occurred in the asynchronous thread, rethrow it.\n  try {\n    future.get();\n  } catch (const std::exception& e) {\n    RCLCPP_ERROR(node_->get_logger(), \"Exception thrown while running asynchronous thread: %s\", e.what());\n    throw;\n  }\n\n  // If an exception was stored, rethrow it.\n  if (stored_exception_) {\n    std::rethrow_exception(stored_exception_);\n  }\n\n  return status();\n}", "CodeBleu_score": 47.35255522249897}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// recursive lambda function to print the tree\n    std::function<void(const TreeNode*, int)> recursivePrint = [&](const TreeNode* node, int depth) {\n        // print the node's depth and name\n        stream << std::string(depth, '\\t') << node->name << std::endl;\n        // cast the node to a control node and decorator node to check if it is one of those types\n        const auto control = dynamic_cast<const ControlNode*>(node);\n        const auto decorator = dynamic_cast<const DecoratorNode*>(node);\n        // if it is a control node, print its children\n        if (control) {\n            for (const auto& child : control->children) {\n                recursivePrint(child, depth + 1);\n            }\n        }\n        // if it is a decorator node, print its child\n        else if (decorator) {\n            recursivePrint(decorator->child, depth + 1);\n        }\n    };\n    // print the separator line and root node\n    stream << \"------------------------------------------------------------------------\" << std::endl;\n    recursivePrint(root_node, 0);\n    // print the separator line\n    stream << \"------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 48.70143107211575}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// define a recursive lambda function to handle the printing\n    auto recursivePrint = [&recursivePrint](const TreeNode* node, int depth) {\n        // indent the output based on the depth\n        stream << std::string(depth * 2, ' ');\n        // print the node's name\n        stream << node->name << '\n';\n        // if the node is a control node, recursively print the children\n        if (const auto* control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children) {\n                recursivePrint(child.get(), depth + 1);\n            }\n        }\n        // if the node is a decorator node, recursively print the child\n        else if (const auto* decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            recursivePrint(decorator->child, depth + 1);\n        }\n    };\n    // begin with a separator line\n    stream << \"==========\n\";\n    // print the tree starting from the root node\n    recursivePrint(root_node, 0);\n    // end with a separator line\n    stream << \"==========\n\";\n}", "CodeBleu_score": 47.69482062714563}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// define a recursive lambda function to handle the printing\n  std::function<void(const TreeNode*, int)> recursivePrint = [&](const TreeNode* node, int depth) {\n    // indent the output based on the node's depth\n    for (int i = 0; i < depth; i++) {\n      stream << \"  \";\n    }\n    // print the node's name\n    stream << node->name << \"\n\";\n    // recursively print the children for ControlNode or the child for DecoratorNode\n    if (auto control = dynamic_cast<const ControlNode*>(node)) {\n      for (auto child : control->children) {\n        recursivePrint(child, depth + 1);\n      }\n    } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n      recursivePrint(decorator->child, depth + 1);\n    }\n  };\n  // begin with a separator line\n  stream << \"--------------------------------------------------------------------------------------------------\n\";\n  // print the root node\n  recursivePrint(root_node, 0);\n  // end with a separator line\n  stream << \"--------------------------------------------------------------------------------------------------\n\";\n}", "CodeBleu_score": 47.73911319916554}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 92.96577020547093}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 92.96577020547093}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 92.96577020547093}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t// Check if the registration ID already exists in the builders map.\n    if (_p->builders.find(manifest.registrationID) != _p->builders.end()) {\n        throw BehaviorTreeException(\"The registration ID \\\"\" +\n                                    manifest.registrationID +\n                                    \"\\\" is already registered.\");\n    }\n\n    // Insert the builder and manifest into their respective maps using the registration ID.\n    _p->builders.insert(std::make_pair(manifest.registrationID, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 52.54938605781998}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"A builder with ID \" + manifest.registrationID + \" is already registered.\");\n    }\n\n    builders.insert(std::make_pair(manifest.registrationID, builder));\n    manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 51.11977001523944}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"Failed to register builder. ID \" +\n                                    manifest.registrationID +\n                                    \" is already registered.\");\n    }\n    builders.insert({manifest.registrationID, builder});\n    manifests.insert({manifest.registrationID, manifest});\n}", "CodeBleu_score": 47.21872068466849}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest(ID, ActionNode::TYPE, std::move(ports));\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 64.19956048536687}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n\n  TreeNodeManifest manifest(ID, ActionNode::TYPE, std::move(ports));\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 59.968389988823944}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tregisterBuilder(\n      TreeNodeManifest(ID, ActionNode::TYPE, ports),\n      [tick_functor](const std::string&, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(config, tick_functor);\n      });\n}", "CodeBleu_score": 42.216309807426875}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        bb.push_back(Blackboard::create());\n        sub->blackboard->cloneInto(bb.back());\n    }\n    return bb;\n}", "CodeBleu_score": 79.06045304680563}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (size_t i = 0; i < tree.subtrees.size(); i++) {\n        bb.push_back(Blackboard::create());\n        tree.subtrees[i]->blackboard->cloneInto(bb.back());\n    }\n    return bb;\n}", "CodeBleu_score": 69.0161278152079}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (size_t i = 0; i < tree.subtrees.size(); i++) {\n        bb.push_back(Blackboard::create());\n        tree.subtrees[i]->blackboard->cloneInto(bb.back());\n    }\n    return bb;\n}", "CodeBleu_score": 69.0161278152079}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor.has_value())\n  {\n    return executor.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 88.44682696911835}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 94.95952810948299}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(!executor)\n    return nonstd::make_unexpected(executor.error());\n  else\n    return executor.value()(env);\n}", "CodeBleu_score": 72.40544061155218}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex_);\n    if (handle_ != nullptr) {\n        throw RuntimeError(\"Shared library already loaded.\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        throw RuntimeError(dlerror());\n    }\n    path_ = path;\n}", "CodeBleu_score": 48.86078643329312}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex_);\n  if (handle_) {\n    throw RuntimeError(\"Shared library already loaded\");\n  }\n  handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle_) {\n    throw RuntimeError(dlerror());\n  }\n  path_ = path;\n}", "CodeBleu_score": 48.6836122578873}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex_);\n    if (loaded_) {\n        throw RuntimeError(\"SharedLibrary::load: Library already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        throw RuntimeError(\"SharedLibrary::load: \" + std::string(dlerror()));\n    }\n    loaded_ = true;\n    path_ = path;\n}", "CodeBleu_score": 52.878514020032476}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n    return false;\n  }\n  StringView stripped = str.trim();\n  if (stripped.size() < 3) {\n    return false;\n  }\n  if (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n    return false;\n  }\n  if (stripped_pointer != nullptr) {\n    *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n  }\n  return true;\n}", "CodeBleu_score": 28.244105294167078}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n    return false;\n  }\n  str = str.trim();\n  if (str.size() < 3) {\n    return false;\n  }\n  if (str[0] != '{' || str[str.size() - 1] != '}') {\n    return false;\n  }\n  if (stripped_pointer) {\n    *stripped_pointer = str.substr(1, str.size() - 2);\n  }\n  return true;\n}", "CodeBleu_score": 25.390754648765924}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str;\n\tstripped.trim();\n\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 26.768819350633866}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble lineCost = 0;\n    unsigned char cost;\n    double pointCost;\n    LineIterator line(x0, y0, x1, y1);\n    line.advance();\n    while(!line.isDone()) {\n      cost = costmap_.getCost(line.getX(), line.getY());\n      //if the cell is in an obstacle the path is invalid\n      if(cost == NO_INFORMATION)\n        return -2;\n      if(cost == LETHAL_OBSTACLE)\n        return -1;\n\n      pointCost = cost;\n      if(pointCost < 0)\n        return pointCost;\n      if(pointCost > lineCost)\n        lineCost = pointCost;\n      line.advance();\n    }\n    return lineCost;\n  }", "CodeBleu_score": 59.23359203635894}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble line_cost = 0;\n  LineIterator line(x0, y0, x1, y1);\n  for(; !line.isDone(); line.advance()) {\n    double cost = pointCost(line.getX(), line.getY());\n    if(cost < 0)\n      return cost;\n    if(cost > line_cost)\n      line_cost = cost;\n  }\n  return line_cost;\n}", "CodeBleu_score": 65.21356904222979}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble cost = 0;\n    LineIterator line(x0, y0, x1, y1);\n    while(!line.isDone()) {\n      double point_cost = pointCost(line.getX(), line.getY());\n      if(point_cost < 0)\n        return point_cost;\n      if(point_cost > cost)\n        cost = point_cost;\n      line.advance();\n    }\n    return cost;\n  }", "CodeBleu_score": 67.49046644316988}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif(path.empty())\n        return;\n\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n\n    for(std::size_t i = 0; i < path.size(); ++i)\n        gui_path.poses[i] = path[i];\n\n    pub.publish(gui_path);\n}", "CodeBleu_score": 83.32221397269772}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif(path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  for(unsigned int i=0; i < path.size(); ++i)\n    gui_path.poses[i] = path[i];\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 91.96526209156046}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif(path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  for(std::size_t i = 0; i < path.size(); ++i)\n    gui_path.poses[i] = path[i];\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 84.41214184810443}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tif (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 59.774417142186955}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t// Check if the robot is rotating\n  if (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n    // Check if the robot is translating\n    if (abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 57.15625269162972}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t// Get the velocities from the odometry message.\n  double linear_velocity = base_odom.twist.twist.linear.x;\n  double angular_velocity = base_odom.twist.twist.angular.z;\n\n  // Check if the robot has stopped.\n  if (fabs(linear_velocity) <= trans_stopped_velocity && fabs(angular_velocity) <= rot_stopped_velocity) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}", "CodeBleu_score": 50.57272819055578}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup) {\n    if (restore_defaults) {\n      config = default_config;\n    }\n    lock_guard<mutex> guard(config_mutex);\n    current_config = config;\n  }\n  else {\n    lock_guard<mutex> guard(config_mutex);\n    default_config = config;\n    current_config = default_config;\n    setup = true;\n  }\n}", "CodeBleu_score": 48.93199518316206}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_ && restore_defaults) {\n        config.horizontal_acceleration_limit = DEFAULT_HORIZONTAL_ACCELERATION_LIMIT;\n        config.vertical_acceleration_limit = DEFAULT_VERTICAL_ACCELERATION_LIMIT;\n        config.max_speed_horizontal = DEFAULT_MAX_SPEED_HORIZONTAL;\n        config.max_speed_vertical = DEFAULT_MAX_SPEED_VERTICAL;\n        config.max_yaw_rate = DEFAULT_MAX_YAW_RATE;\n        config.max_yaw_acceleration = DEFAULT_MAX_YAW_ACCELERATION;\n        config.max_allowable_path_deviation = DEFAULT_MAX_ALLOWABLE_PATH_DEVIATION;\n        config.max_allowable_path_deviation_while_moving = DEFAULT_MAX_ALLOWABLE_PATH_DEVIATION_WHILE_MOVING;\n        config.max_allowable_path_deviation_while_stationary = DEFAULT_MAX_ALLOWABLE_PATH_DEVIATION_WHILE_STATIONARY;\n        config.max_allowable_path_deviation_while_moving_base_stationary = DEFAULT_MAX_ALLOWABLE_PATH_DEVIATION_WHILE_MOVING_BASE_STATIONARY;\n        config.max_allowable_path_deviation_while_moving_base_moving = DEFAULT_MAX_ALLOWABLE_PATH_DEVIATION_WHILE_MOVING_BASE_MOVING;\n        config.max_allowable_path_deviation_while_stationary_base_moving = DEFAULT_MAX_ALLOWABLE_PATH_DEVIATION_WHILE_STATIONARY_BASE_MOVING;\n        config.max_allowable_path_deviation_while_stationary_base_stationary = DEFAULT_MAX_ALLOWABLE_PATH_DEVIATION_WHILE_STATIONARY_BASE_STATIONARY;\n        config.max_allowable_path_angle_deviation = DEFAULT_MAX_ALLOWABLE_PATH_", "CodeBleu_score": 22.95732887299932}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup) {\n        if (restore_defaults) {\n            config.horizontal_acceleration_limit = DEFAULT_HORIZONTAL_ACCELERATION_LIMIT;\n            config.horizontal_deceleration_limit = DEFAULT_HORIZONTAL_DECELERATION_LIMIT;\n            config.horizontal_speed_limit = DEFAULT_HORIZONTAL_SPEED_LIMIT;\n            config.horizontal_acceleration_limit_yaw = DEFAULT_HORIZONTAL_ACCELERATION_LIMIT_YAW;\n            config.horizontal_deceleration_limit_yaw = DEFAULT_HORIZONTAL_DECELERATION_LIMIT_YAW;\n            config.horizontal_speed_limit_yaw = DEFAULT_HORIZONTAL_SPEED_LIMIT_YAW;\n            config.vertical_acceleration_limit = DEFAULT_VERTICAL_ACCELERATION_LIMIT;\n            config.vertical_deceleration_limit = DEFAULT_VERTICAL_DECELERATION_LIMIT;\n            config.vertical_speed_limit = DEFAULT_VERTICAL_SPEED_LIMIT;\n            config.vertical_acceleration_limit_yaw = DEFAULT_VERTICAL_ACCELERATION_LIMIT_YAW;\n            config.vertical_deceleration_limit_yaw = DEFAULT_VERTICAL_DECELERATION_LIMIT_YAW;\n            config.vertical_speed_limit_yaw = DEFAULT_VERTICAL_SPEED_LIMIT_YAW;\n            config.yaw_acceleration_limit = DEFAULT_YAW_ACCELERATION_LIMIT;\n            config.yaw_deceleration_limit = DEFAULT_YAW_DECELERATION_LIMIT;\n            config.yaw_speed_limit = DEFAULT_YAW_SPEED_LIMIT;\n            config.yaw_acceleration_limit_yaw = DEFAULT_YAW_ACCELERATION_LIMIT_YAW;\n            config.yaw", "CodeBleu_score": 20.562449279393984}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t//check the cost of the cell using the costmap\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n  //if the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = costmap_2d::NO_INFORMATION;\n    return false;\n  }\n\n  //if the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter\n  unsigned int new_dist = current_cell->target_dist + 1;\n  if (check_cell->target_dist == costmap_2d::NO_INFORMATION || new_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_dist;\n    check_cell->parent_x = current_cell->x;\n    check_cell->parent_y = current_cell->y;\n  }\n\n  //return true\n  return true;\n}", "CodeBleu_score": 69.92349462990782}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// check if the cell is an obstacle\n  if (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::LETHAL_OBSTACLE) {\n    // if so, set the target distance to the max distance and return false\n    check_cell->target_distance = std::numeric_limits<float>::infinity();\n    return false;\n  }\n\n  // calculate the distance to the current cell\n  float distance = hypot(current_cell->x - check_cell->x, current_cell->y - check_cell->y);\n\n  // check if the distance is smaller than the current target distance\n  if (distance < check_cell->target_distance) {\n    // if so, update the target distance and return true\n    check_cell->target_distance = distance;\n    return true;\n  }\n\n  // otherwise, return false\n  return false;\n}", "CodeBleu_score": 48.01514735436845}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// First check the cost of the cell using the costmap\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n  // If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = std::numeric_limits<double>::infinity();\n    return false;\n  }\n\n  // If the cell is not an obstacle, calculate a new target distance\n  double new_target_dist = current_cell->target_dist + 1.0;\n\n  // Update the cell's target distance if the new distance is shorter\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    check_cell->parent = current_cell;\n  }\n\n  // Return true\n  return true;\n}", "CodeBleu_score": 72.62438026386494}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  double cost = 0.0;\n  double footprint_cost = 0.0;\n  std::vector<geometry_msgs::Point> footprint_spec = footprint_spec_;\n\n  //if we have no footprint... we won't score the trajectory\n  if (footprint_spec.empty()) {\n    ROS_ERROR(\"The footprint_spec is empty, cannot score a trajectory\");\n    return -9.0;\n  }\n\n  //we'll assume that the trajectory is legal and we'll just check for collisions\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    footprint_cost = footprintCost(traj.getPoint(i).x, traj.getPoint(i).y, traj.getPoint(i).th, scale, footprint_spec, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 57.95376786720291}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble scale = 1.0;\n  double cost = 0.0;\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"The footprint spec is empty\");\n    return -9.0;\n  }\n  //we'll scale the footprint based on the speed of the trajectory\n  if (scale_footprint_) {\n    scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  }\n\n  //we'll calculate the cost of the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double x = traj.getPoint(i).x;\n    double y = traj.getPoint(i).y;\n    double th = traj.getPoint(i).th;\n\n    double footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint cost is negative, we'll return that immediately\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    //we'll sum the cost of the trajectory\n    if (sum_scores_) {\n      cost += footprint_cost;\n    }\n    //we'll take the maximum cost of the trajectory\n    else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 70.47214843955831}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  double cost = 0.0;\n  //if the footprint is empty, we won't score it\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"The footprint of the robot is empty, which means that it will be impossible to plan for it. Please fill out the footprint of your robot in the URDF/SRDF.\");\n    return -9.0;\n  }\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.getPoint(i).x, traj.getPoint(i).y, traj.getPoint(i).theta, scale, footprint_spec_, costmap_, world_model_);\n    //we'll return the first cost that's negative\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    }\n    else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 57.53991593177072}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t//scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  scaled_footprint.clear();\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point pt;\n    pt.x = scale * footprint_spec[i].x;\n    pt.y = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(pt);\n  }\n\n  //get the map coordinates of the robot\n  unsigned int mx, my;\n  double wx, wy;\n  if (!costmap->worldToMap(x, y, wx, wy)) {\n    //ROS_WARN(\"Robot footprint is off the map\");\n    return -7.0;\n  }\n  mx = (unsigned int) wx;\n  my = (unsigned int) wy;\n\n  //compute the footprint cost\n  double footprint_cost = world_model->footprintCost(scaled_footprint, mx, my, th);\n\n  //make sure that we're not in an unknown area\n  double cost = costmap->getCost(mx, my);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  else {\n    return std::max(cost, footprint_cost);\n  }\n}", "CodeBleu_score": 76.23011660899567}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t//check if the footprint is outside the map boundaries\n    if (!costmap->worldToMap(x, y, scaled_footprint)) {\n        return -7.0;\n    }\n\n    //check if the footprint is outside the map boundaries\n    if (!costmap->worldToMap(x, y, scaled_footprint)) {\n        return -7.0;\n    }\n\n    //scale the footprint\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        scaled_footprint[i].x = scaled_footprint[i].x * scale;\n        scaled_footprint[i].y = scaled_footprint[i].y * scale;\n    }\n\n    //compute the footprint cost\n    double footprint_cost = world_model->footprintCost(scaled_footprint, costmap);\n\n    //make sure that we're not in an unknown area\n    if (footprint_cost == costmap_2d::NO_INFORMATION) {\n        return -6.0;\n    }\n\n    //check if the cell is in the costmap bounds\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my)) {\n        return -7.0;\n    }\n\n    //check if the cell is in the costmap bounds\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my)) {\n        return -7.0;\n    }\n\n    //return the maximum of the footprint cost and the cost at the center of the footprint\n    return std::max(footprint_cost, static_cast<double>(costmap->getCost(mx, my)));\n}", "CodeBleu_score": 57.330898156956565}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t//scale the footprint\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        geometry_msgs::Point new_pt;\n        new_pt.x = scale * footprint_spec[i].x;\n        new_pt.y = scale * footprint_spec[i].y;\n        scaled_footprint.push_back(new_pt);\n    }\n\n    //rotate the footprint into the costmap frame\n    std::vector<geometry_msgs::Point> oriented_footprint;\n    if (!rotateFootprint(scaled_footprint, oriented_footprint, x, y, th)) {\n        return -7.0;\n    }\n\n    //check if any of the points are outside the bounds of the costmap\n    for (unsigned int i = 0; i < oriented_footprint.size(); ++i) {\n        if (!costmap->worldToMap(oriented_footprint[i].x, oriented_footprint[i].y, oriented_footprint[i].x, oriented_footprint[i].y)) {\n            return -7.0;\n        }\n    }\n\n    //compute the cost of the footprint\n    double footprint_cost = world_model->footprintCost(oriented_footprint, costmap);\n\n    //make sure we're not in an unknown area\n    if (footprint_cost == -1) {\n        return -6.0;\n    }\n\n    //get the cost of the cell underneath the robot\n    unsigned char cost;\n    costmap->getCost(x, y, cost);\n\n    //return the higher of the two costs\n    return std::max(footprint_cost, (double) cost);\n}", "CodeBleu_score": 69.86495839987936}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.73339564111626}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic_ != odom_topic) {\n    odom_topic_ = odom_topic;\n\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 52.34923301962302}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.73339564111626}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist_sq = (pos - prev).squaredNorm();\n  float angle = acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n\n  if (dist_sq > 0.01 || angle > 0.01) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 31.885773643689554}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist = (pos - prev).squaredNorm();\n  float angle = acos(pos.normalized().dot(prev.normalized()));\n\n  if (dist > 0.1) {\n    resetOscillationFlags();\n  }\n\n  if (angle > 0.1) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 33.04715978284183}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist = (pos - prev).squaredNorm();\n  float angle = acos(pos.normalized().dot(prev.normalized()));\n\n  // if the distance is greater than the threshold or the angle is greater than 15 degrees, reset the flags\n  if (dist > 0.001 || angle > 0.261799387) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 28.608323721697193}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy));\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy + 1));\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx, gy + 1));\n    }\n\n    //upper right\n    if(gx < width_ - 1 && gy < height_ - 1){", "CodeBleu_score": 43.70135926228376}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy));\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy + 1));\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx, gy + 1));\n    }\n\n    //upper right\n    if(gx < width_ - 1 && gy < height_ - 1", "CodeBleu_score": 43.70719548639481}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n    gridCoords(pt, gx, gy);\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy));\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy + 1));\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx, gy + 1));\n    }\n\n    //upper right\n    if(gx < width_ - 1 && gy < height_ - 1){", "CodeBleu_score": 43.70135926228376}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel;\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel(i) > vel(i)) {\n            if (sample_target_vel(i) - vel(i) > acclimits(i) * dt) {\n                new_vel(i) = vel(i) + acclimits(i) * dt;\n            } else {\n                new_vel(i) = sample_target_vel(i);\n            }\n        } else if (sample_target_vel(i) < vel(i)) {\n            if (vel(i) - sample_target_vel(i) > acclimits(i) * dt) {\n                new_vel(i) = vel(i) - acclimits(i) * dt;\n            } else {\n                new_vel(i) = sample_target_vel(i);\n            }\n        } else {\n            new_vel(i) = vel(i);\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 49.85715275631409}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel(i) > vel(i)) {\n            new_vel(i) = std::min(vel(i) + acclimits(i) * dt, sample_target_vel(i));\n        } else if (sample_target_vel(i) < vel(i)) {\n            new_vel(i) = std::max(vel(i) - acclimits(i) * dt, sample_target_vel(i));\n        } else {\n            new_vel(i) = vel(i);\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 60.96286021521562}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        new_vel(i) = vel(i) + std::min(std::max(sample_target_vel(i) - vel(i), -acclimits(i) * dt), acclimits(i) * dt);\n    }\n    return new_vel;\n}", "CodeBleu_score": 50.45675417442688}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble goal_x, goal_y;\n  double angle;\n  double angle_diff;\n  double angle_diff_abs;\n  double angle_diff_min = DBL_MAX;\n  bool goal_found = false;\n\n  for (int i = (int)global_plan_.size() - 1; i >= 0; i--) {\n    //Convert the current global plan point to cell coordinates\n    costmap_.worldToMap(global_plan_[i].x, global_plan_[i].y, goal_x, goal_y);\n\n    //Check if the current global plan point is in the same cell as the robot\n    if (goal_x == cell_x && goal_y == cell_y) {\n      goal_found = true;\n      break;\n    }\n\n    //Check if the current global plan point is in a cell that is not in an obstacle\n    if (!costmap_.getCost(goal_x, goal_y)) {\n      //Calculate the angle between the robot's current heading and the goal point\n      angle = atan2(global_plan_[i].y - y, global_plan_[i].x - x);\n      angle_diff = angles::shortest_angular_distance(heading, angle);\n      angle_diff_abs = fabs(angle_diff);\n\n      //If the angle difference is smaller than the current smallest angle difference, update the smallest angle difference\n      if (angle_diff_abs < angle_diff_min) {\n        angle_diff_min = angle_diff_abs;\n      }\n    }\n  }\n\n  if (goal_found) {\n    //Convert the goal cell coordinates to world coordinates\n    costmap_.mapToWorld(cell_x, cell_y, goal_x, goal_y);\n\n    //Calculate the angle between the robot's current heading and the goal point\n    angle = atan2(goal_y - y, goal_x - x);\n    angle_diff = angles::shortest_angular_distance(heading, angle);\n    angle_diff_abs = fabs(angle_diff);\n\n    //If the angle difference is smaller than the current smallest angle difference, update the smallest", "CodeBleu_score": 50.97810201804214}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  double goal_x = 0.0;\n  double goal_y = 0.0;\n  double goal_heading = 0.0;\n  int goal_cell_x = 0;\n  int goal_cell_y = 0;\n  int i = 0;\n  for (i = global_plan_.size() - 1; i >= 0; i--) {\n    goal_x = global_plan_[i].pose.position.x;\n    goal_y = global_plan_[i].pose.position.y;\n\n    // Convert the goal point's coordinates to cell coordinates\n    costmap_.worldToMap(goal_x, goal_y, goal_cell_x, goal_cell_y);\n\n    // Check if the goal point is within the map boundaries\n    if (goal_cell_x < 0 || goal_cell_x >= costmap_.getSizeInCellsX() || goal_cell_y < 0 || goal_cell_y >= costmap_.getSizeInCellsY()) {\n      continue;\n    }\n\n    // Check if the goal point is within the robot's footprint\n    if (!footprint_clear_) {\n      if (!footprint_->containsObstacle(goal_cell_x, goal_cell_y)) {\n        continue;\n      }\n    }\n\n    // Check if the goal point is in a clear cell\n    if (!costmap_.getCost(goal_cell_x, goal_cell_y)) {\n      continue;\n    }\n\n    // Check if the robot can see the goal point\n    if (lineCost(cell_x, goal_cell_x, cell_y, goal_cell_y) < 0) {\n      continue;\n    }\n\n    // Convert the goal point's cell coordinates to world coordinates\n    costmap_.mapToWorld(goal_cell_x, goal_cell_y, goal_x, goal_y);\n\n    // Calculate the heading to the goal point\n    goal_heading = atan2(goal_y - y,", "CodeBleu_score": 54.38561871728634}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = (int) global_plan_.size() - 1; i >= 0; --i) {\n    //convert the goal cell coordinates to world coordinates\n    double wx = costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y).x;\n    double wy = costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y).y;\n\n    //check if the robot has a clear line of sight to the goal point\n    if (lineCost(cell_x, global_plan_[i].x, cell_y, global_plan_[i].y) >= 0) {\n      //calculate the shortest angular difference between the current heading and the direction to the goal point\n      return fabs(angles::shortest_angular_distance(heading, atan2(wy - y, wx - x)));\n    }\n  }\n\n  //no valid point found\n  return DBL_MAX;\n}", "CodeBleu_score": 53.15124202982459}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Invalid trajectory: cost = %f, vx_samp = %f, vy_samp = %f, vtheta_samp = %f\",\n               cost, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 74.55490467530251}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if(cost >= 0.0) {\n        return true;\n    } else {\n        ROS_WARN(\"Trajectory invalid: vx: %f, vy: %f, vtheta: %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, cost);\n        return false;\n    }\n}", "CodeBleu_score": 83.46391524963975}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Trajectory is invalid, cost is %f\", cost);\n      ROS_WARN(\"vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 72.22907555070344}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  if (!invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the area to clear. This is probably not what you want.\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  clear(global_costmap_);\n  ROS_DEBUG(\"Clearing the global costmap took %.3lf ms\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n\n  if (affected_maps_ == AFFECTED_MAPS::GLOBAL_MAP || affected_maps_ == AFFECTED_MAPS::BOTH_MAPS) {\n    t0 = ros::WallTime::now();\n    global_costmap_->updateMap();\n    ROS_DEBUG(\"Updating the global costmap took %.3lf ms\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n  }\n\n  t0 = ros::WallTime::now();\n  clear(local_costmap_);\n  ROS_DEBUG(\"Clearing the local costmap took %.3lf ms\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n\n  if (affected_maps_ == AFFECTED_MAPS::LOCAL_MAP || affected_maps_ == AFFECTED_MAPS::BOTH_MAPS) {\n    t0 = ros::WallTime::now();\n    local_costmap_->updateMap();\n    ROS_DEBUG(\"Updating the local costmap took %.3lf ms\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n  }\n}", "CodeBleu_score": 62.63238247952976}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmap pointer must be set before this object can run\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside an area\");\n  } else {\n    ROS_WARN(\"Clearing outside an area\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if (affected_maps_ == CLEAR_ALL_COSTMAPS || affected_maps_ == CLEAR_GLOBAL_COSTMAP) {\n    clear(global_costmap_);\n    if (force_update_) {\n      global_costmap_->updateMap();\n    }\n    ROS_DEBUG(\"Global costmap clearing took %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (affected_maps_ == CLEAR_ALL_COSTMAPS || affected_maps_ == CLEAR_LOCAL_COSTMAP) {\n    clear(local_costmap_);\n    if (force_update_) {\n      local_costmap_->updateMap();\n    }\n    ROS_DEBUG(\"Local costmap clearing took %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n}", "CodeBleu_score": 61.057560697447755}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmaps must be set before this object can run\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"The clearing area is the area outside of the polygon. This is not the usual behavior of this plugin.\");\n  }\n\n  if (affected_maps_ == \"global\" || affected_maps_ == \"both\") {\n    ROS_DEBUG(\"Clearing the global costmap\");\n    ros::WallTime t0 = ros::WallTime::now();\n    clear(global_costmap_);\n    ROS_DEBUG(\"Clearing the global costmap took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (affected_maps_ == \"local\" || affected_maps_ == \"both\") {\n    ROS_DEBUG(\"Clearing the local costmap\");\n    ros::WallTime t0 = ros::WallTime::now();\n    clear(local_costmap_);\n    ROS_DEBUG(\"Clearing the local costmap took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (force_update_) {\n    if (affected_maps_ == \"global\" || affected_maps_ == \"both\") {\n      ROS_DEBUG(\"Updating the global costmap\");\n      ros::WallTime t0 = ros::WallTime::now();\n      global_costmap_->updateMap();\n      ROS_DEBUG(\"Updating the global costmap took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n    }\n\n    if (affected_maps_ == \"local\" || affected_maps_ == \"both\") {\n      ROS_DEBUG(\"Updating the local costmap\");\n      ros::WallTime t0 = ros::WallTime::now();\n      local_costmap_->updateMap", "CodeBleu_score": 61.817042546264425}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tPolygonOutlineCells poly_cells;\n\n  if (polygon.empty())\n    return;\n\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], poly_cells);\n  }\n\n  if (polygon.size() > 2) {\n    raytraceLine(polygon[polygon.size() - 1], polygon[0], poly_cells);\n  }\n\n  polygon_cells = poly_cells.cells;\n}", "CodeBleu_score": 57.094177485374445}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tpolygon_cells.clear();\n\n  if (polygon.empty())\n    return;\n\n  PolygonOutlineCells polygon_outline_cells(polygon_cells);\n\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i)\n    raytraceLine(polygon[i], polygon[i + 1], polygon_outline_cells);\n\n  if (polygon.front() != polygon.back())\n    raytraceLine(polygon.back(), polygon.front(), polygon_outline_cells);\n}", "CodeBleu_score": 54.55525341572449}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tPolygonOutlineCells poly_cells;\n    polygonOutlineCells(polygon, poly_cells);\n    polygon_cells.resize(poly_cells.size());\n    std::copy(poly_cells.begin(), poly_cells.end(), polygon_cells.begin());\n}", "CodeBleu_score": 23.23611656024267}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 64.70573755156508}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t//lock the costmap mutex\n  costmap_->getMutex()->lock();\n  //get the costmap resolution\n  double resolution = costmap_->getResolution();\n  //set the grid's header\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  //set the grid's size\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  //set the grid's origin\n  costmap_->mapToWorld(costmap_->getOriginX(), costmap_->getOriginY(), grid_.info.origin.position.x, grid_.info.origin.position.y);\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  //save the origin coordinates\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n  //resize the grid data\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  //populate the grid data\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = costmap_->getCharMap()[i] - '0';\n  }\n  //unlock the costmap mutex\n  costmap_->getMutex()->unlock();\n}", "CodeBleu_score": 62.22249343306693}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// Lock the costmap mutex\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  // Retrieve the resolution\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.header.stamp = ros::Time::now();\n\n  // Set the grid's resolution and size\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Set the origin position and orientation\n  costmap_->mapToWorld(0, 0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n\n  // Resize the grid data\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    grid_.data[i] = costmap_->getCharMap()[i] < 0 ? -1 : costmap_->getCharMap()[i];\n  }\n}", "CodeBleu_score": 65.02531596965426}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// lock the costmap mutex\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  // get the costmap resolution\n  double resolution = costmap_->getResolution();\n\n  // set the header information of the grid\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n\n  // set the size of the grid\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // convert the origin of the costmap to world coords\n  costmap_->mapToWorld(0, 0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n\n  // save the origin for later use\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n\n  // resize the grid to match the size of the costmap\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // fill the costmap with values from the character map\n  unsigned int index = 0;\n  for (unsigned int i = 0; i < costmap_->getSizeInCellsY(); ++i) {\n    for (unsigned int j = 0; j < costmap_->getSizeInCellsX(); ++j) {\n      // convert from costmap value to grid value\n      grid_.data[index] = costTranslationTable_[costmap_->getCharMap()[index]];\n      ++index;\n    }\n  }\n}", "CodeBleu_score": 64.82468090080425}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  std::vector<geometry_msgs::Point> new_footprint;\n  if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n    setUnpaddedRobotFootprint(new_footprint);\n  } else if (makeFootprintFromRadius(new_config.robot_radius, new_footprint)) {\n    setUnpaddedRobotFootprint(new_footprint);\n  } else {\n    ROS_ERROR(\"Invalid footprint specification: %s\", new_config.footprint.c_str());\n  }\n}", "CodeBleu_score": 70.07460361355868}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  if (new_config.footprint != old_config.footprint) {\n    std::vector<geometry_msgs::Point> points;\n    if (makeFootprintFromString(new_config.footprint, points)) {\n      setUnpaddedRobotFootprint(points);\n    } else {\n      ROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c_str());\n    }\n  } else {\n    std::vector<geometry_msgs::Point> points;\n    if (makeFootprintFromRadius(new_config.robot_radius, points)) {\n      setUnpaddedRobotFootprint(points);\n    } else {\n      ROS_ERROR(\"Invalid robot radius: %f\", new_config.robot_radius);\n    }\n  }\n}", "CodeBleu_score": 68.71527152436231}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// if the footprint and radius are the same, we don't need to do anything\n  if(old_config.footprint == new_config.footprint && old_config.robot_radius == new_config.robot_radius)\n    return;\n\n  std::vector<geometry_msgs::Point> points;\n  if(makeFootprintFromString(new_config.footprint, points)) {\n    setUnpaddedRobotFootprint(points);\n  } else {\n    ROS_ERROR(\"The footprint specified for the robot is not a polygon. The robot footprint will be set to a circle with radius %.2f.\",\n              new_config.robot_radius);\n    makeFootprintFromRadius(new_config.robot_radius, points);\n    setUnpaddedRobotFootprint(points);\n  }\n}", "CodeBleu_score": 57.15590053960145}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n    return;\n  }\n  reconfigureCB(config_, level_);\n}", "CodeBleu_score": 72.1285730390505}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n    return;\n  }\n\n  // check if the robot has moved\n  if (new_pose.pose.position.x != robot_pose_.pose.position.x ||\n      new_pose.pose.position.y != robot_pose_.pose.position.y ||\n      new_pose.pose.orientation.x != robot_pose_.pose.orientation.x ||\n      new_pose.pose.orientation.y != robot_pose_.pose.orientation.y ||\n      new_pose.pose.orientation.z != robot_pose_.pose.orientation.z ||\n      new_pose.pose.orientation.w != robot_pose_.pose.orientation.w) {\n    robot_pose_ = new_pose;\n    reconfigureCB(config_);\n  }\n}", "CodeBleu_score": 65.70060852271182}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n    return;\n  }\n  /*\n   * If the new pose is far enough from the last pose, reconfigure the costmap.\n   */\n  if (distance(new_pose.pose, last_pose_.pose) > reconfigure_threshold_) {\n    reconfigure();\n    last_pose_ = new_pose;\n  }\n}", "CodeBleu_score": 72.6660133272575}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\tif (stopped_) {\n    ROS_INFO(\"Starting the costmap\");\n    std::vector<boost::shared_ptr<Layer> > plugins = layered_costmap_->getPlugins();\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n      if (!plugins[i]->is_enabled()) {\n        plugins[i]->activate();\n      }\n    }\n    stopped_ = false;\n    stop_updates_ = false;\n  }\n\n  // wait for the costmap to be initialized and the map update thread to be active\n  while (ros::ok() && !is_initialized_ && !stop_updates_) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 60.94084510529822}, {"code": "void Costmap2DROS::start(){\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(layered_costmap_->getMutex()));\n  if (stopped_) {\n    ROS_DEBUG_NAMED(\"costmap\", \"Resuming the costmap\");\n    stopped_ = false;\n    std::vector<layered_costmap_->Plugin*> plugins = layered_costmap_->getPlugins();\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n      plugins[i]->activate();\n    }\n    stop_updates_ = false;\n    while (!layered_costmap_->isInitialized() || !map_update_thread_->isRunning()) {\n      lock.unlock();\n      r.sleep();\n      lock.lock();\n    }\n  }\n}", "CodeBleu_score": 47.23555065652778}, {"code": "void Costmap2DROS::start(){\n\tROS_INFO_NAMED(\"costmap\", \"Starting costmap2d\");\n  std::vector<layered_costmap_->getPlugins()> plugins = layered_costmap_->getPlugins();\n  for (unsigned int i = 0; i < plugins.size(); ++i) {\n    if (!plugins[i]->is_enabled_) {\n      plugins[i]->activate();\n      ROS_INFO_NAMED(\"costmap\", \"Activating plugin %s\", plugins[i]->getName().c_str());\n    }\n  }\n  stopped_ = false;\n  stop_updates_ = false;\n  ROS_INFO_NAMED(\"costmap\", \"Starting costmap2d, done\");\n}", "CodeBleu_score": 49.64006104194812}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_.toSec() > 0.0) {\n    ros::Time oldest_allowed_time = ros::Time::now() - observation_keep_time_;\n    for (ObservationList::iterator it = observation_list_.begin(); it != observation_list_.end(); ) {\n      if (it->header.stamp < oldest_allowed_time) {\n        it = observation_list_.erase(it);\n      } else {\n        ++it;\n      }\n    }\n  } else {\n    if (!observation_list_.empty()) {\n      observation_list_.erase(observation_list_.begin(), --observation_list_.end());\n    }\n  }\n}", "CodeBleu_score": 42.50643042236056}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0.0)) {\n    if (observation_list_.size() > 1) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n    }\n  } else {\n    ros::Time current_time = ros::Time::now();\n    for (ObservationList::iterator obs_it = observation_list_.begin(); obs_it != observation_list_.end(); ++obs_it) {\n      if ((current_time - (*obs_it)->header.stamp) > observation_keep_time_) {\n        observation_list_.erase(obs_it);\n      } else {\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 56.62452204324593}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0.0)) {\n    // only keep most recent observation\n    if (observation_list_.size() > 1) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n    }\n  } else {\n    // remove observations that are older than the specified time\n    ros::Time latest_time = ros::Time::now() - observation_keep_time_;\n    for (ObservationList::iterator obs_it = observation_list_.begin(); obs_it != observation_list_.end(); ++obs_it) {\n      if (obs_it->header.stamp < latest_time) {\n        observation_list_.erase(obs_it, observation_list_.end());\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 58.34770331717721}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// calculate the yaw angle at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // calculate the shortest angular distance between the start and end indices\n  double shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // calculate the incremental change in angle for each pose\n  double incremental_change_in_angle = shortest_angular_distance / (end_index - start_index);\n\n  // update the orientation of each pose in the specified range\n  for (int i = start_index; i < end_index; i++) {\n    // calculate the yaw angle of the current pose\n    double current_yaw = tf2::getYaw(path[i].pose.orientation);\n\n    // calculate the new yaw angle of the current pose\n    double new_yaw = current_yaw + incremental_change_in_angle;\n\n    // update the orientation of the current pose\n    set_angle(&path[i], new_yaw);\n  }\n}", "CodeBleu_score": 64.46319421932715}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// Calculate the yaw angle at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end indices\n  double shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Calculate the incremental change in angle for each pose\n  double incremental_angle = shortest_angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double angle = start_yaw + (i - start_index) * incremental_angle;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 71.8839875540645}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// Get the yaw angle of the start and end poses\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Compute the shortest angular distance between the start and end angles\n  double angle_change = angles::shortest_angular_distance(start_angle, end_angle);\n\n  // Compute the incremental change in angle for each pose in the path\n  double incremental_angle_change = angle_change / (end_index - start_index);\n\n  // Update the orientation of each pose in the path\n  for (int i = start_index; i < end_index; i++) {\n    double angle = start_angle + (i - start_index) * incremental_angle_change;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 66.4761861501329}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tgeometry_msgs::PoseStamped start, goal;\n  start.header.frame_id = \"map\";\n  start.pose = req.start;\n  goal.header.frame_id = \"map\";\n  goal.pose = req.goal;\n\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(start, goal, path);\n\n  resp.plan_found = success;\n  resp.path = path;\n\n  return true;\n}", "CodeBleu_score": 57.80566198160676}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tROS_DEBUG_NAMED(\"make_plan\", \"makePlanService: new request\");\n\n  //set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  //call makePlan to generate a path\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(req.start, req.goal, path);\n\n  //update the response with the success status and the generated path if a plan is found\n  resp.plan_found = success;\n  resp.path = path;\n\n  ROS_DEBUG_NAMED(\"make_plan\", \"makePlanService: returning with success [%s]\", success ? \"true\" : \"false\");\n\n  return true;\n}", "CodeBleu_score": 68.6048771464483}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tROS_INFO(\"makePlanService: received request\");\n\n  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(req.start, req.goal, path);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan_found = success;\n  if (success) {\n    resp.path = path;\n  }\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 86.47384448883845}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.getParam(\"planner_frequency\", planner_frequency);\n    private_nh.getParam(\"planner_patience\", planner_patience);\n    private_nh.getParam(\"planner_max_retries\", planner_max_retries);\n    private_nh.getParam(\"allow_unknown\", allow_unknown);\n    private_nh.getParam(\"publish_frequency\", publish_frequency);\n    private_nh.getParam(\"planner_max_time\", planner_max_time);\n    private_nh.getParam(\"planner_work_rate\", planner_work_rate);\n\n    make_plan_srv = private_nh.advertiseService(\"make_plan\",\n            &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1,\n            &PlannerWithCostmap::goalCallback, this);\n    plan_pub = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n\n    ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap: Initialized.\");\n}", "CodeBleu_score": 56.562544658317215}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.reset(new ros::NodeHandle(\"~\"));\n    private_nh->advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh->subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 62.88745628220415}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.reset(new ros::NodeHandle(\"~\"));\n    private_nh->advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh->subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 61.15615442316871}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t// check if the world coordinate is within the bounds of the costmap\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    return false;\n  }\n\n  // convert from world coordinates to map coordinates\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // check if the map coordinates are within the bounds of the costmap\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 50.202101700406075}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n  return (mx >= 0 && mx < costmap_->getSizeInCellsX() && my >= 0 && my < costmap_->getSizeInCellsY());\n}", "CodeBleu_score": 35.742782336650905}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t// check if the world coordinate is within the bounds of the costmap\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    ROS_WARN(\n        \"wx %.2f < costmap_->getOriginX() %.2f || wy %.2f < costmap_->getOriginY() %.2f\",\n        wx, costmap_->getOriginX(), wy, costmap_->getOriginY());\n    return false;\n  }\n\n  // convert world coordinates to map coordinates\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // check if the map coordinates are within the size limits of the costmap\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n    return true;\n  } else {\n    ROS_WARN(\n        \"mx %.2f < costmap_->getSizeInCellsX() %.2f || my %.2f < costmap_->getSizeInCellsY() %.2f\",\n        mx, costmap_->getSizeInCellsX(), my, costmap_->getSizeInCellsY());\n    return false;\n  }\n}", "CodeBleu_score": 48.257248652417026}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.header.frame_id = frame_id_;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 91.5378888286406}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.header.frame_id = frame_id_;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 91.5378888286406}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a Path message\n  nav_msgs::Path plan;\n  plan.header.stamp = ros::Time::now();\n  plan.header.frame_id = frame_id_;\n\n  // copy all points from the path into the message\n  plan.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); i++) {\n    plan.poses[i] = path[i];\n  }\n\n  // publish the plan\n  plan_pub_.publish(plan);\n}", "CodeBleu_score": 84.62026181201848}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal into action message and publishing.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 79.45590174724487}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Wrapping up goal message and publishing to action server\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 79.55096010646474}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Received goal in PoseStamped form\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 76.6231073696107}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tROS_INFO(\"Checking distance...\");\n  double sq_distance = getSqDistance();\n  if (sq_distance > sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough, removing speed limit...\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 72.32660173288936}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough from the speed limit. Removing speed limit.\");\n    distance_check_timer_.stop();\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n  }\n}", "CodeBleu_score": 60.90319315656794}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough. Removing speed limit.\");\n    distance_check_timer_.stop();\n    remove_limit_thread_->join();\n    delete remove_limit_thread_;\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n  }\n}", "CodeBleu_score": 51.928081275756675}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Get the current global pose of the robot\n  rm::PoseStamped globalPose;\n  if (!getRobotPose(globalPose)) {\n    ROS_ERROR(\"Could not get the current robot pose\");\n    return;\n  }\n\n  // Generate a path from the current pose to the goal pose\n  std::vector<rm::PoseStamped> path;\n  if (!makePlan(globalPose, *goal, path)) {\n    ROS_ERROR(\"Could not generate a plan to the goal pose\");\n    return;\n  }\n\n  // Publish the path\n  pathPub_.publish(path);\n}", "CodeBleu_score": 51.62751328994057}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tROS_INFO(\"NavfnWithCostmap::poseCallback: getRobotPose\");\n    rm::PoseStamped globalPose = cmap_->getRobotPose();\n    ROS_INFO(\"NavfnWithCostmap::poseCallback: makePlan\");\n    makePlan(globalPose, *goal, path_);\n}", "CodeBleu_score": 47.11851096213966}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\trm::PoseStamped global_pose;\n\tif (!cmap_->getRobotPose(global_pose)) {\n\t\tROS_WARN(\"Could not get robot pose\");\n\t\treturn;\n\t}\n\tmakePlan(global_pose, *goal, path_);\n}", "CodeBleu_score": 51.49936276861191}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a request for the param_set_client_\n\tmavros_msgs::ParamSet param_set_req;\n\n\t// Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n\tparam_set_req.request.param_id = param_set.param_id;\n\tparam_set_req.request.value.integer = param_set.value;\n\n\t// Send the request\n\tparam_set_client_.call(param_set_req);\n\n}", "CodeBleu_score": 59.92615336649164}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create the service request\n    mavros_msgs::ParamSet param_set_srv;\n\n    // Assign the parameter ID and value from the GimbalParamSet structure to the service request\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.real = param_set.value;\n\n    // Call the service\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 70.26811430483443}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a ParamSet request\n\tmavros_msgs::ParamSet param_set_srv;\n\n\t// Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value.integer = param_set.param_value;\n\n\t// Call the param_set_client_ to send the request\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 67.62141870327197}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\tint sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n    int n;\n    int len;\n    int i;\n    // Wait for a connection from the ground station\n    waitConnectionFromGroundStation(sock, serv_addr);\n    // Enter a loop to accept incoming connections, receive data, and process it\n    while (true) {\n        // Accept incoming connections\n        accept(sock, (struct sockaddr*)NULL, NULL);\n        // Receive data\n        n = recv(sock, buffer, 1024, 0);\n        // If data is received successfully, decode the message and publish it\n        if (n > 0) {\n            // Decode the message\n            len = decodeMsg(buffer, n);\n            // Publish the message\n            pubMsg(len);\n        }\n        // If the received message length is zero or less, log an error and close the socket\n        else if (n <= 0) {\n            perror(\"recv\");\n            close(sock);\n            exit(1);\n        }\n    }\n}", "CodeBleu_score": 42.077360229062286}, {"code": "void CommunicationBridge::serverFun(){\n\twaitConnectionFromGroundStation();\n  while (true) {\n    accept();\n    decodeMsg();\n    if (msgLength <= 0) {\n      perror(\"recv\");\n      ROS_ERROR(\"Received message length is %d\", msgLength);\n      close(sock);\n      exit(1);\n    }\n  }\n}", "CodeBleu_score": 16.40864044774873}, {"code": "void CommunicationBridge::serverFun(){\n\t// Wait for a connection from the ground station.\n\twaitConnectionFromGroundStation();\n\n\t// Enter a loop to handle further connections.\n\twhile (ros::ok()) {\n\n\t\t// Accept a connection from the ground station.\n\t\taccept();\n\n\t\t// Receive data from the ground station.\n\t\trecv();\n\n\t\t// If data was received successfully, decode it and publish it.\n\t\tif (msgLen > 0) {\n\t\t\tdecodeMsg();\n\t\t\tpubMsg();\n\t\t}\n\n\t\t// If data was not received successfully, log an error and close the socket.\n\t\telse {\n\t\t\tROS_ERROR(\"Received message length is zero or less.\");\n\t\t\tclose(sockfd);\n\t\t\texit(0);\n\t\t}\n\t}\n}", "CodeBleu_score": 13.658038995259714}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (!simulation_mode_) {\n        uav_basic_->uavCmdPub.publish(uav_cmd);\n    } else {\n        std::map<int, UAV_Basic *>::iterator it;\n        it = swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != swarm_control_simulation_.end()) {\n            (*it).second->uavCmdPub.publish(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 44.226621899280474}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (this->simulation_mode_) {\n        // Find the UAV in the swarm and publish the command\n        std::map<int, UAV*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != this->swarm_control_simulation_.end()) {\n            (*it).second->uavCmdPub.publish(uav_cmd);\n        }\n    } else {\n        // Publish the command to the UAV\n        this->uav_basic_->uavCmdPub.publish(uav_cmd);\n    }\n}", "CodeBleu_score": 53.743301685742}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (simulation_mode_) {\n        std::map<int, UAVBasic*>::iterator it = swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != swarm_control_simulation_.end()) {\n            (*it).second->uavCmdPub.publish(uav_cmd);\n        }\n    } else {\n        uav_basic_->uavCmdPub.publish(uav_cmd);\n    }\n}", "CodeBleu_score": 43.29030893006582}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"sudo reboot\");\n\t}\n\telse if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"sudo poweroff\");\n\t}\n\telse if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 60.48510318592807}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == REBOOTNX) {\n    system(\"reboot\");\n  } else if (mode_selection.use_mode == EXITNX) {\n    system(\"exit\");\n  } else if (mode_selection.use_mode == CREATEMODE) {\n    createMode(mode_selection.mode_name);\n  } else if (mode_selection.use_mode == DELETEMODE) {\n    deleteMode(mode_selection.mode_name);\n  }\n}", "CodeBleu_score": 51.110585554861196}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == REBOOTNX) {\n    system(\"sudo reboot\");\n  } else if (mode_selection.use_mode == EXITNX) {\n    system(\"sudo poweroff\");\n  } else if (mode_selection.use_mode == CREATEMODE) {\n    createMode(mode_selection.mode_name);\n  } else if (mode_selection.use_mode == DELETEMODE) {\n    deleteMode(mode_selection.mode_name);\n  }\n}", "CodeBleu_score": 51.35806262436391}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\tif (this->heartbeat_count == 0) {\n        this->heartbeat_count++;\n    } else if (this->heartbeat_count < this->heartbeat_attempts) {\n        this->heartbeat_count++;\n    } else {\n        this->heartbeat_count = 0;\n        if (this->vehicle_type == \"UAV\") {\n            ROS_ERROR(\"UAV heartbeat lost. Triggering UAV disconnect.\");\n            this->triggerUAV = true;\n            this->disconnect_flag = true;\n        } else if (this->vehicle_type == \"UGV\") {\n            ROS_ERROR(\"UGV heartbeat lost. Triggering UGV disconnect.\");\n            this->triggerUGV = true;\n            this->disconnect_flag = true;\n        } else if (this->vehicle_type == \"Swarm\") {\n            ROS_ERROR(\"Swarm heartbeat lost. Triggering Swarm disconnect.\");\n            this->triggerSwarmControl = true;\n            this->disconnect_flag = true;\n        }\n    }\n}", "CodeBleu_score": 26.544806731373043}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\tif (heartbeat_counter_ == 0) {\n        ROS_ERROR(\"Heartbeat lost. Disconnecting.\");\n        disconnect_flag_ = true;\n        triggerUAV();\n        triggerSwarmControl();\n        triggerUGV();\n    }\n    heartbeat_counter_ = 0;\n}", "CodeBleu_score": 13.553768445028917}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\tif (heartbeat_counter > max_heartbeat_misses) {\n        ROS_ERROR_STREAM(\"Heartbeat missed too many times, disconnecting\");\n        disconnect_flag = true;\n    }\n    if (heartbeat_counter > 0) {\n        heartbeat_counter--;\n    }\n}", "CodeBleu_score": 14.6195762889395}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// Extract the drone ID and trajectory data from the message\n    int drone_id = msg->drone_id;\n    int traj_num = msg->traj.size();\n\n    // For each trajectory, initialize a Bspline struct, set its attributes, and populate its knots, position points, and yaw points\n    for (int i = 0; i < traj_num; i++) {\n        Bspline bspline;\n        bspline.drone_id = drone_id;\n        bspline.traj_id = i;\n        bspline.start_time = msg->traj[i].start_time;\n        bspline.duration = msg->traj[i].duration;\n        bspline.knots.resize(msg->traj[i].knots.size());\n        bspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n        bspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots[j] = msg->traj[i].knots[j];\n        }\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n        }\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n        }\n\n        // Encode the MultiBsplines data and send it via TCP using the communication module\n        this->communication->encodeMsg(bspline);\n        this->communication->sendMsgByTcp(bspline);\n    }\n}", "CodeBleu_score": 65.19100627720704}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// ROS_INFO(\"multitrajSubTcpCb\");\n    // ROS_INFO(\"msg->traj.size: %d\", msg->traj.size);\n    // ROS_INFO(\"msg->traj[0].knots.size: %d\", msg->traj[0].knots.size);\n    // ROS_INFO(\"msg->traj[0].yaw_pts.size: %d\", msg->traj[0].yaw_pts.size);\n    // ROS_INFO(\"msg->traj[0].start_time.toSec(): %f\", msg->traj[0].start_time.toSec());\n    // ROS_INFO(\"msg->traj[0].pos_pts.size: %d\", msg->traj[0].pos_pts.size);\n\n    // if (msg->traj.size() == 0) {\n    //     ROS_INFO(\"msg->traj.size() == 0\");\n    //     return;\n    // }\n\n    // if (msg->traj[0].knots.size() == 0) {\n    //     ROS_INFO(\"msg->traj[0].knots.size() == 0\");\n    //     return;\n    // }\n\n    // if (msg->traj[0].yaw_pts.size() == 0) {\n    //     ROS_INFO(\"msg->traj[0].yaw_pts.size() == 0\");\n    //     return;\n    // }\n\n    // if (msg->traj[0].pos_pts.size() == 0) {\n    //     ROS_INFO(\"msg->traj[0].pos_pts.size() == 0\");\n    //     return;\n    // }\n\n    for (int i = 0; i < msg->traj.size(); i++) {\n        Bspline bspline;\n        bspline.drone_id = msg->traj[i].drone_id;\n        bspline.knots.push_back(msg->traj[i].knots[0]);\n        bspline.pos", "CodeBleu_score": 23.86344042557374}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tint drone_id;\n    int traj_id;\n    int num_trajs;\n    int num_knots;\n    int num_pos_pts;\n    int num_yaw_pts;\n    int start_time;\n    int end_time;\n    int duration;\n    int num_knots_total;\n    int num_pos_pts_total;\n    int num_yaw_pts_total;\n    int num_msgs;\n    int msg_id;\n    int msg_id_total;\n    int num_msgs_total;\n    int num_trajs_total;\n    int num_drones;\n    int num_drones_total;\n    int num_drones_recvd;\n    int num_drones_recvd_total;\n    int num_drones_recvd_prev;\n    int num_drones_recvd_prev_total;\n    int num_drones_recvd_prev_total_prev;\n    int num_drones_recvd_prev_total_prev_prev;\n    int num_drones_recvd_prev_total_prev_prev_prev;\n    int num_drones_recvd_prev_total_prev_prev_prev_prev;\n    int num_drones_recvd_prev_total_prev_prev_prev_prev_prev;\n    int num_drones_recvd_prev_total_prev_prev_prev_prev_prev_prev;\n    int num_drones_recvd_prev_total_prev_prev_prev_prev_prev_prev_prev;\n    int num_drones_recvd_prev_total_prev_prev_prev_prev_prev_prev_prev_prev;\n    int num_drones_recvd_prev_total_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n    int num_drones_recvd_prev_total_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n    int num_drones_recvd_prev_total_prev", "CodeBleu_score": 8.183386061628514}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\tpcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.encodePointCloud();\n\n\tstd::string compressed_data;\n\tstd::stringstream compressed_str;\n\toctree_compression.encodePointCloud();\n\toctree_compression.getCompressedData(compressed_data);\n\tcompressed_str << compressed_data;\n\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = msg.height;\n\tcompressed_msg.width = msg.width;\n\tcompressed_msg.fields = msg.fields;\n\tcompressed_msg.is_bigendian = msg.is_bigendian;\n\tcompressed_msg.point_step = msg.point_step;\n\tcompressed_msg.row_step = msg.row_step;\n\tcompressed_msg.is_dense = msg.is_dense;\n\tcompressed_msg.data.resize(compressed_str.str().size());\n\tstd::memcpy(&compressed_msg.data[0], &compressed_str.str()[0], compressed_str.str().size());\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 44.5012006208544}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    pcl::io::OctreePointCloudCompression<pcl::PointXYZ>* octree = new pcl::io::OctreePointCloudCompression<pcl::PointXYZ>();\n    octree->setInputCloud(cloud);\n    std::ostringstream compressed_data;\n    octree->encodePointCloud(compressed_data);\n\n    // Store the compressed data\n    std::vector<uint8_t> compressed_data_buffer;\n    compressed_data_buffer.resize(compressed_data.str().size());\n    std::memcpy(&compressed_data_buffer[0], compressed_data.str().data(), compressed_data.str().size());\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data_buffer.size();\n    compressed_msg.fields.resize(1);\n    compressed_msg.fields[0].name = \"data\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n    compressed_msg.fields[0].count = compressed_data_buffer.size();\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = compressed_data_buffer.size();\n    compressed_msg.row_step = compressed_data_buffer.size();\n    compressed_msg.is_dense = true;\n    compressed_msg.data = compressed_data_buffer;\n\n    // Release dynamically allocated memory\n    delete octree;\n\n    return compressed_msg;\n}", "CodeBleu_score": 53.874258755294235}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\tpcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create an octree-based point cloud compression object for point cloud data\n    pcl::io::OctreePointCloudCompression<pcl::PointXYZI> *octree = new pcl::io::OctreePointCloudCompression<pcl::PointXYZI>(0.005f);\n\n    // Set the input point cloud\n    octree->setInputCloud(cloud);\n\n    // Compress and generate compressed data\n    std::string compressed_data;\n    octree->encodePointCloud(compressed_data);\n\n    // Create a new PointCloud2 message\n    sensor_msgs::PointCloud2 compressed_msg;\n\n    // Store the compressed data in the new PointCloud2 message\n    compressed_msg.data.resize(compressed_data.size());\n    std::memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_data.size());\n\n    // Release dynamically allocated memory\n    delete octree;\n\n    return compressed_msg;\n}", "CodeBleu_score": 34.66015291769137}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].id == uav_state.id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 79.65248629548607}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].id == uav_state.id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 79.65248629548607}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n    if (this->multi_uav_state_.uav_state_all[i].id == uav_state.id) {\n      this->multi_uav_state_.uav_state_all[i] = uav_state;\n    }\n  }\n}", "CodeBleu_score": 77.92408899493235}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Publish the state of all UGVs\n    multi_ugv_state.header.stamp = ros::Time::now();\n    multi_ugv_state.header.frame_id = \"map\";\n    multi_ugv_state.ugv_state_all.clear();\n    multi_ugv_state.ugv_count = 0;\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n        ugv_state.ugv_id = m_multi_ugv_state.ugv_state_all[i].ugv_id;\n        ugv_state.ugv_battery = m_multi_ugv_state.ugv_state_all[i].ugv_battery;\n        ugv_state.ugv_position.x = m_multi_ugv_state.ugv_state_all[i].ugv_position.x;\n        ugv_state.ugv_position.y = m_multi_ugv_state.ugv_state_all[i].ugv_position.y;\n        ugv_state.ugv_position.z = m_multi_ugv_state.ugv_state_all[i].ugv_position.z;\n        ugv_state.ugv_velocity.x = m_multi_ugv_state.ugv_state_all[i].ugv_velocity.x;\n        ugv_state.ugv_velocity.y = m_multi_ugv_state.ugv_state_all[i].ugv_velocity.y;\n        ugv_state.ugv_velocity.z = m_multi_ugv_state.ugv_state_all[i].ugv_velocity.z;\n        ugv_state.ugv_attitude.x = m_multi_ugv_state.ugv_state_all[i].ugv_attitude.x;\n        ugv_state.ugv_attitude.y = m_multi_ugv_state.ugv_state_all[i].ugv", "CodeBleu_score": 44.468551104078934}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize message\n  swarm_msgs::MultiUGVState multi_ugv_state;\n\n  // Iterate through each UGV state\n  for (std::vector<struct UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n    // Initialize UGVState message\n    swarm_msgs::UGVState ugv_state;\n\n    // Populate UGVState message\n    ugv_state.ugv_id = it->ugv_id;\n    ugv_state.battery = it->battery;\n    ugv_state.position.x = it->position.x;\n    ugv_state.position.y = it->position.y;\n    ugv_state.position.z = it->position.z;\n    ugv_state.velocity.x = it->velocity.x;\n    ugv_state.velocity.y = it->velocity.y;\n    ugv_state.velocity.z = it->velocity.z;\n    ugv_state.attitude.x = it->attitude.x;\n    ugv_state.attitude.y = it->attitude.y;\n    ugv_state.attitude.z = it->attitude.z;\n    ugv_state.attitude.w = it->attitude.w;\n\n    // Increment UGV count\n    multi_ugv_state.ugv_count++;\n\n    // Add UGVState to MultiUGVState message\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n\n  // Publish MultiUGVState message\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 50.24961547577338}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize a MultiUGVState message\n  swarm_msgs::MultiUGVState multi_ugv_state;\n  // Iterate through each UGV state in the provided MultiUGVState structure\n  for (std::vector<UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n    // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n    swarm_msgs::UGVState ugv_state;\n    ugv_state.ugv_id = it->ugv_id;\n    ugv_state.battery = it->battery;\n    ugv_state.position.x = it->position.x;\n    ugv_state.position.y = it->position.y;\n    ugv_state.position.z = it->position.z;\n    ugv_state.velocity.x = it->velocity.x;\n    ugv_state.velocity.y = it->velocity.y;\n    ugv_state.velocity.z = it->velocity.z;\n    ugv_state.attitude.x = it->attitude.x;\n    ugv_state.attitude.y = it->attitude.y;\n    ugv_state.attitude.z = it->attitude.z;\n    ugv_state.attitude.w = it->attitude.w;\n    // Increment the UGV count and add each UGVState to the MultiUGVState message\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n  // Publish the assembled MultiUGVState message\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 47.68082002469415}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\n  gradient.setZero(q.cols(), q.rows());\n\n  for (int i = 0; i < q.cols(); i++) {\n    Eigen::Vector3d obj_prid;\n    double obj_radius;\n    double obj_clearance;\n    for (int j = 0; j < moving_objs_->getObjNums(); j++) {\n      moving_objs_->getObjInfo(j, obj_prid, obj_radius, obj_clearance);\n      Eigen::Vector3d obj_pred = moving_objs_->evaluateConstVel(obj_prid, ros::Time::now(), ros::Time::now() + ros::Duration(cps_.time[i]));\n      double dist = (cps_.points.col(i) - obj_pred).norm();\n      if (dist < obj_clearance) {\n        cost += pow((dist - obj_clearance), 2);\n        gradient.col(i) += 2 * (cps_.points.col(i) - obj_pred).normalized() * (dist - obj_clearance);\n      }\n    }\n  }\n}", "CodeBleu_score": 51.466700728883005}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// Iterate through each control point\n  for (int i = 0; i < q.cols(); ++i) {\n    // Compute the position of the control point\n    Eigen::Vector3d cp = q.col(i);\n\n    // Iterate through moving objects\n    for (int j = 0; j < moving_objs_->getObjNums(); ++j) {\n      // Compute the position of the object\n      Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(j, ros::Time::now().toSec());\n\n      // Compute the distance between the control point and the object\n      double dist = (cp - obj_prid).norm();\n\n      // If the distance is less than a specified clearance, update the cost and gradient\n      if (dist < clearance_) {\n        double grad_dist = (cp - obj_prid).normalized().dot(gradient.col(i));\n        cost += pow(dist - clearance_, 2);\n        gradient.col(i) += 2 * (dist - clearance_) * grad_dist * (cp - obj_prid).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 41.927458006896224}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\n  gradient.setZero(q.cols(), q.rows());\n\n  for (int i = 0; i < q.cols(); i++) {\n    // get the predicted position of the moving objects at the current control point\n    Eigen::Vector3d obj_prid;\n    moving_objs_->evaluateConstVel(q(0, i), q(1, i), q(2, i), q(3, i), obj_prid);\n\n    // calculate the distance error between the current control point and the predicted position of the moving objects\n    double dist_error = (cps_.points.col(i) - obj_prid).norm();\n    double dist_error_sq = dist_error * dist_error;\n\n    // if the distance is less than a specified clearance, update the cost and gradient\n    if (dist_error < moving_obj_clearance_) {\n      double cost_tmp = dist_error_sq / (2 * moving_obj_clearance_);\n      cost += cost_tmp;\n\n      Eigen::Vector3d grad_tmp = (cps_.points.col(i) - obj_prid).normalized() / moving_obj_clearance_;\n      gradient.col(i) = grad_tmp;\n    }\n  }\n}", "CodeBleu_score": 45.162221537575405}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\n  gradient.setZero(q.cols(), q.rows());\n\n  Eigen::Vector3d v;\n  Eigen::Vector3d v_ref;\n  Eigen::Vector3d v_ref_prev;\n  Eigen::Vector3d v_ref_next;\n  Eigen::Vector3d v_ref_next2;\n  Eigen::Vector3d v_ref_prev2;\n  Eigen::Vector3d v_ref_prev3;\n  Eigen::Vector3d v_ref_next3;\n\n  for (int i = 2; i < q.rows() - 2; ++i) {\n    v = (q.col(i + 1) - q.col(i - 1)) / 2.0;\n    v_ref = (ref_pts_[i] - ref_pts_[i - 2]) / 2.0;\n    v_ref_prev = (ref_pts_[i - 1] - ref_pts_[i - 3]) / 2.0;\n    v_ref_next = (ref_pts_[i + 1] - ref_pts_[i - 2]) / 2.0;\n    v_ref_next2 = (ref_pts_[i + 2] - ref_pts_[i - 2]) / 2.0;\n    v_ref_prev2 = (ref_pts_[i] - ref_pts_[i - 3]) / 2.0;\n    v_ref_prev3 = (ref_pts_[i - 1] - ref_pts_[i - 4]) / 2.0;\n    v_ref_next3 = (ref_pts_[i + 1] - ref_pts_[i - 3]) / 2.0;\n\n    cost += a2_ * v.dot(v) + b2_ * v.cross(v_ref).norm();\n\n    Eigen::Vector3d v_ref_prev_norm = v_ref_prev.normalized();\n    Eigen::Vector3d v_ref_next_norm = v_ref", "CodeBleu_score": 36.83337708021721}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\n    gradient.setZero(q.cols(), q.rows());\n\n    for (int i = 2; i < q.rows() - 2; i++) {\n        Eigen::Vector3d x = q.block<3, 1>(0, i);\n        Eigen::Vector3d v = (q.block<3, 1>(0, i) - q.block<3, 1>(0, i - 1)).normalized();\n        Eigen::Vector3d xcrossv = (x - ref_pts_[i - 2]).cross(v);\n        cost += a2 * (x - ref_pts_[i - 2]).squaredNorm() + b2 * xcrossv.squaredNorm();\n\n        Eigen::Matrix3d dv_dq = Eigen::Matrix3d::Zero();\n        Eigen::Matrix3d dxcrossv_dq = Eigen::Matrix3d::Zero();\n        Eigen::Matrix3d dx_dq = Eigen::Matrix3d::Zero();\n\n        Eigen::Vector3d dv = (q.block<3, 1>(0, i) - q.block<3, 1>(0, i - 1));\n        Eigen::Vector3d dx = (x - ref_pts_[i - 2]);\n\n        for (int j = 0; j < 3; j++) {\n            Eigen::Vector3d col_j = q.block<3, 1>(0, j);\n            dv_dq.col(j) = (col_j - q.block<3, 1>(0, j - 1)).normalized();\n            dx_dq.col(j) = col_j - ref_pts_[i - 2];\n        }\n\n        dxcrossv_dq = dv_dq.transpose() * dx.cross(v) + dv.cross(v) * dx_dq.transpose();\n        dx_dq = dx_dq.transpose();\n\n        Eigen::MatrixXd dcost_dq = 2 * a2 * dx_dq + 2 * b2 *", "CodeBleu_score": 40.527061951925766}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// initialize cost and gradient\n  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.cols(), q.rows());\n\n  // iterate through all control points\n  for (int i = 2; i < q.rows() - 2; ++i) {\n    // compute positional error vector\n    Eigen::Vector3d x = q.block<3, 1>(0, i) - ref_pts_[i];\n    // compute velocity vector\n    Eigen::Vector3d v = (ref_pts_[i] - ref_pts_[i - 2]).normalized();\n    // update cost\n    cost += a2_ * x.dot(x) + b2_ * x.cross(v).norm();\n    // update gradient\n    Eigen::Vector3d dx = 2.0 * a2_ * x;\n    Eigen::Vector3d dv = 2.0 * b2_ * x.cross(v);\n    gradient.block<3, 1>(0, i) += dx;\n    gradient.block<3, 1>(0, i - 2) -= dx;\n    gradient.block<3, 1>(3, i) += dv;\n    gradient.block<3, 1>(3, i - 2) -= dv;\n  }\n}", "CodeBleu_score": 38.86707604788071}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n  Eigen::VectorXd knot = jerk_traj.getKnot();\n\n  double jerk = 0.0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += ctrl_pts(j, i) * ctrl_pts(j, i) * (knot(i + 1) - knot(i));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 72.84817409332749}, {"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  double jerk = 0;\n  for (int i = 0; i < jerk_traj.getControlPoint().rows(); i++) {\n    for (int j = 0; j < jerk_traj.getControlPoint().cols(); j++) {\n      jerk += jerk_traj.getControlPoint()(i, j) * jerk_traj.getKnot().segment(i, 2).maxCoeff() -\n              jerk_traj.getControlPoint()(i, j) * jerk_traj.getKnot().segment(i, 2).minCoeff();\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 51.83692018607972}, {"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n  Eigen::VectorXd knot = jerk_traj.getKnot();\n\n  double jerk = 0.0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += pow(ctrl_pts(j, i), 2) * (knot(i + 1) - knot(i));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 69.83723350607883}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1.0;\n\n    return pos;\n}", "CodeBleu_score": 64.32370769035728}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tdouble x = (u - cx_) * depth / fx_;\n    double y = (v - cy_) * depth / fy_;\n    double z = depth;\n\n    Eigen::Vector4d pos(x, y, z, 1);\n\n    return pos;\n}", "CodeBleu_score": 53.80171972657892}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t// 4D position vector in the camera frame\n    Eigen::Vector4d pos;\n\n    // 2D pixel coordinates\n    double u_d = u;\n    double v_d = v;\n\n    // Depth\n    double depth_d = depth;\n\n    // 3D position vector in the camera frame\n    pos << (u_d - cx_) * depth_d / fx_, (v_d - cy_) * depth_d / fy_, depth_d, 1;\n\n    return pos;\n}", "CodeBleu_score": 41.95671184177407}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        int drone_id = std::stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (std::exception& e) {\n        ROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: Could not extract drone ID from odometry message child_frame_id: %s\", e.what());\n    }\n}", "CodeBleu_score": 53.79835111420552}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        int drone_id = std::stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (std::exception& e) {\n        std::cout << \"DroneDetector::rcvDroneXOdomCallback: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 60.65977282628744}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(1)));\n    } catch (const std::exception& e) {\n        ROS_WARN(\"DroneDetector::rcvDroneXOdomCallback: Could not extract drone ID from odometry message: %s\", e.what());\n    }\n}", "CodeBleu_score": 42.76123125706958}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// compute drone pose in camera frame\n  Eigen::Vector3d drone_pose_cam = true_pixel_to_drone_pose(drone_id, true_pixel);\n\n  // check for presence\n  if (check_drone_presence(drone_pose_cam)) {\n    // compute drone pose in world frame\n    Eigen::Vector3d drone_pose_world = cam_pose_to_world_pose(drone_pose_cam);\n\n    // compute drone pose error\n    Eigen::Vector3d drone_pose_err = compute_pose_error(drone_id, drone_pose_world);\n\n    // update debug result\n    update_debug_result(drone_id, drone_pose_world, drone_pose_err);\n\n    // publish pose error\n    publish_pose_error(drone_id, drone_pose_err);\n  } else {\n    // update debug result\n    update_debug_result(drone_id, Eigen::Vector3d(0, 0, 0), Eigen::Vector3d(0, 0, 0));\n  }\n}", "CodeBleu_score": 35.22900159675723}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Calculate true pose of drone in camera frame\n    Eigen::Matrix3f true_rotation = Eigen::AngleAxisf(drone_poses_[drone_id].z(), Eigen::Vector3f::UnitZ()).toRotationMatrix();\n    Eigen::Vector3f true_position = drone_poses_[drone_id].head<3>();\n    Eigen::Vector3f true_position_camera = true_rotation * true_position + drone_poses_[drone_id].tail<3>();\n    // Check for presence\n    if (true_pixel.x() > 0 && true_pixel.y() > 0) {\n        // Calculate pose error\n        Eigen::Vector3f error_position = true_position_camera - pixel_position_;\n        Eigen::Vector3f error_rotation = true_rotation * pixel_rotation_.conjugate();\n        Eigen::Vector3f error_euler = error_rotation.eulerAngles(2, 1, 0);\n        // Update debug result\n        debug_result_.drone_id = drone_id;\n        debug_result_.drone_found = true;\n        debug_result_.pixel_position = true_pixel;\n        debug_result_.pixel_position_valid = true;\n        debug_result_.pixel_position_error = error_position.head<2>();\n        debug_result_.pixel_rotation_error = error_euler.head<2>();\n        // Publish pose error\n        geometry_msgs::Vector3 position_error;\n        position_error.x = error_position.x();\n        position_error.y = error_position.y();\n        position_error.z = error_position.z();\n        geometry_msgs::Vector3 rotation_error;\n        rotation_error.x = error_euler.x();\n        rotation_error.y = error_euler.y();\n        rotation_error.z = error_euler.z();\n        drone_pose_err_pub_[drone_id].publish(position_error, rotation_error);\n    } else {\n        // Update", "CodeBleu_score": 37.877268591635335}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Compute the true pose of the drone in the camera frame\n  Eigen::Vector3d true_camera_pose = computeTruePose(drone_id, true_pixel);\n  // Check for the presence of the drone\n  bool found = checkForDrone(drone_id, true_camera_pose);\n  // If found, compute the pose error between the camera and world coordinates\n  if (found) {\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = computePoseError(drone_id, true_camera_pose);\n    // Update the debug result\n    updateDebugResult(drone_id, true_pixel, true_camera_pose, pose_error);\n    // Publish the pose error\n    drone_pose_err_pub_[drone_id].publish(pose_error);\n  }\n  // If not found, update the debug result to indicate failure\n  else {\n    updateDebugResult(drone_id, true_pixel, true_camera_pose, Eigen::Vector3d::Zero());\n  }\n}", "CodeBleu_score": 36.35716227424063}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}", "CodeBleu_score": 85.47463964174204}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 82.80084101934521}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 82.80084101934521}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// convert the start and end points to grid indices\n  if (!Coord2Index(start_pt, start_idx)) {\n    return false;\n  }\n  if (!Coord2Index(end_pt, end_idx)) {\n    return false;\n  }\n  // if the start or end point is inside an obstacle, iteratively adjust the point by moving it away from the other point until it is no longer in an obstacle\n  if (checkOccupancy(start_idx)) {\n    Vector3d direction = (end_pt - start_pt).normalized();\n    Vector3d new_start_pt = start_pt;\n    while (checkOccupancy(start_idx)) {\n      new_start_pt += direction;\n      if (!Coord2Index(new_start_pt, start_idx)) {\n        return false;\n      }\n    }\n    start_pt = new_start_pt;\n  }\n  if (checkOccupancy(end_idx)) {\n    Vector3d direction = (start_pt - end_pt).normalized();\n    Vector3d new_end_pt = end_pt;\n    while (checkOccupancy(end_idx)) {\n      new_end_pt += direction;\n      if (!Coord2Index(new_end_pt, end_idx)) {\n        return false;\n      }\n    }\n    end_pt = new_end_pt;\n  }\n  return true;\n}", "CodeBleu_score": 59.428408472933484}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\tif (!AdjustStartEndPoints(start_idx, end_idx)) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 20.327534106882727}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// convert to indices\n    start_idx = ConvertToIndex(start_pt);\n    end_idx = ConvertToIndex(end_pt);\n\n    // check if start or end point is inside an obstacle\n    if (CheckIfInsideObstacle(start_idx) || CheckIfInsideObstacle(end_idx)) {\n        // if so, adjust the points\n        if (!AdjustStartEndPoints(start_idx, end_idx)) {\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 27.00993314070952}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tEigen::Vector3d min_id = getIndex(min_pos);\n  Eigen::Vector3d max_id = getIndex(max_pos);\n  for (int x = min_id(0); x <= max_id(0); x++) {\n    for (int y = min_id(1); y <= max_id(1); y++) {\n      for (int z = min_id(2); z <= max_id(2); z++) {\n        Eigen::Vector3i id(x, y, z);\n        occupancy_buffer_inflate_(x, y, z) = 0;\n        distance_buffer_inflate_(x, y, z) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 64.11260649546688}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5206\u8fa8\u7387\n  const double resolution = resolution_;\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u539f\u70b9\n  const Eigen::Array3d origin = origin_.array();\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5bbd\u5ea6\n  const Eigen::Array3i buffer_size = buffer_size_.array();\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5360\u636e\u503c\n  const float occupied_thres = occupied_thres_;\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u81ea\u7531\u503c\n  const float free_thres = free_thres_;\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5360\u636e\u503c\n  const float lethal_thres = lethal_thres_;\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5360\u636e\u503c\n  const float min_distance = min_distance_;\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5360\u636e\u503c\n  const float max_distance = max_distance_;\n\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5360\u636e\u503c\n  const float* occupancy_buffer_inflate = occupancy_buffer_inflate_.data();\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u8ddd\u79bb\u503c\n  float* distance_buffer = distance_buffer_.data();\n\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5360\u636e\u503c\n  const int min_x_idx = getIndexFromCoordinateX(min_pos.x(), origin, resolution);\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5360\u636e\u503c\n  const int min_y_idx = getIndexFromCoordinateY(min_pos.y(), origin, resolution);\n  // \u83b7\u53d6\u5360\u636e\u6805\u683c\u5730\u56fe\u7684\u5360\u636e\u503c\n  const int min_z_idx = getIndexFromCoordinateZ(min_pos.z(), origin, resolution", "CodeBleu_score": 22.43132988482263}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tEigen::Vector3i min_id, max_id;\n  toAddress(min_pos, min_id);\n  toAddress(max_pos, max_id);\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.59287794109565}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff_vec = pt - camera_pt;\n\tEigen::Vector3d max_translation = max_ - camera_pt;\n\tEigen::Vector3d min_translation = min_ - camera_pt;\n\n\tEigen::Vector3d closest_pt = pt;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff_vec[i] > max_translation[i]) {\n\t\t\tclosest_pt[i] = max_[i];\n\t\t}\n\t\telse if (diff_vec[i] < min_translation[i]) {\n\t\t\tclosest_pt[i] = min_[i];\n\t\t}\n\t}\n\n\treturn closest_pt;\n}", "CodeBleu_score": 43.69484516323011}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d min_translation_coeff = diff.cwiseQuotient(diff.cwiseAbs());\n  Eigen::Vector3d max_translation_coeff = min_translation_coeff.cwiseAbs();\n\n  for (int i = 0; i < 3; ++i) {\n    if (min_translation_coeff(i) > 0) {\n      max_translation_coeff(i) = 1.0;\n    } else if (min_translation_coeff(i) < 0) {\n      max_translation_coeff(i) = -1.0;\n    } else {\n      max_translation_coeff(i) = 0.0;\n    }\n  }\n\n  Eigen::Vector3d translation_coeff = min_translation_coeff;\n  for (int i = 0; i < 3; ++i) {\n    if (max_translation_coeff(i) != 0.0) {\n      if (max_translation_coeff(i) > 0) {\n        translation_coeff(i) = std::min(translation_coeff(i), max_translation_coeff(i));\n      } else {\n        translation_coeff(i) = std::max(translation_coeff(i), max_translation_coeff(i));\n      }\n    }\n  }\n  return pt + diff.cwiseProduct(translation_coeff);\n}", "CodeBleu_score": 37.439834897763625}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t// The point is already in the map, no need to do anything\n  if (isInMap(pt)) {\n    return pt;\n  }\n\n  // The point is outside the map, and we need to find the closest point\n  Eigen::Vector3d diff = pt - camera_pt;\n\n  // Find the maximum and minimum translation coefficients along each axis\n  Eigen::Vector3d max_translation_coeffs(0, 0, 0);\n  Eigen::Vector3d min_translation_coeffs(0, 0, 0);\n  for (int i = 0; i < 3; i++) {\n    if (diff(i) > 0) {\n      max_translation_coeffs(i) = (map_max_ - camera_pt(i)) / diff(i);\n      min_translation_coeffs(i) = (map_min_ - camera_pt(i)) / diff(i);\n    } else if (diff(i) < 0) {\n      max_translation_coeffs(i) = (map_min_ - camera_pt(i)) / diff(i);\n      min_translation_coeffs(i) = (map_max_ - camera_pt(i)) / diff(i);\n    } else {\n      max_translation_coeffs(i) = std::numeric_limits<double>::max();\n      min_translation_coeffs(i) = std::numeric_limits<double>::lowest();\n    }\n  }\n\n  // Find the minimum positive scaling factor that keeps the point within map boundaries\n  Eigen::Vector3d translation_coeffs = max_translation_coeffs.cwiseMin(min_translation_coeffs);\n  double min_translation_coeff = translation_coeffs.minCoeff();\n\n  // Return the adjusted point near the boundary\n  return camera_pt + min_translation_coeff * diff;\n}", "CodeBleu_score": 41.71503379921842}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n  // Check if an update is needed.\n  if (!md_.update_occupancy_)\n    return;\n\n  // Project depth image into points.\n  PointCloud::Ptr cloud_ptr(new PointCloud);\n  projectDepthImage(cloud_ptr);\n\n  // Process points with raycasting.\n  raycastProcess(cloud_ptr);\n\n  // Clear and inflate local map.\n  if (md_.update_local_map_) {\n    clearAndInflateLocalMap();\n    md_.update_local_map_ = false;\n  }\n\n  // Handle timeout errors.\n  if (!md_.odom_ok_ && (ros::Time::now() - md_.last_odom_time_).toSec() > md_.timeout_odom_) {\n    ROS_ERROR(\"Timeout error: No odometry received for %f seconds. Stopping mapping.\", md_.timeout_odom_);\n    md_.mapping_active_ = false;\n    md_.odom_ok_ = true;\n  }\n  if (!md_.depth_ok_ && (ros::Time::now() - md_.last_depth_time_).toSec() > md_.timeout_depth_) {\n    ROS_ERROR(\"Timeout error: No depth image received for %f seconds. Stopping mapping.\", md_.timeout_depth_);\n    md_.mapping_active_ = false;\n    md_.depth_ok_ = true;\n  }\n\n  // Reset update flag.\n  md_.update_occupancy_ = false;\n}", "CodeBleu_score": 62.49756921912283}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // If an update is needed, update the map.\n  if (md_.update_map_) {\n    // Project the depth image into points.\n    PointCloud::Ptr cloud(new PointCloud);\n    projectDepthImage(cloud);\n\n    // Process the points with raycasting.\n    raycastProcess(cloud);\n\n    // Clear and inflate the local map.\n    clearAndInflateLocalMap();\n\n    // Set the update flag to false.\n    md_.update_map_ = false;\n  }\n\n  // Handle timeout errors for odometry or depth data.\n  if (ros::Time::now() - md_.last_odom_update_time_ > md_.max_odom_age_) {\n    ROS_ERROR(\"Odometry data is too old! (age = %f)\", (ros::Time::now() - md_.last_odom_update_time_).toSec());\n    md_.odom_ok_ = false;\n  }\n  if (ros::Time::now() - md_.last_depth_update_time_ > md_.max_depth_age_) {\n    ROS_ERROR(\"Depth data is too old! (age = %f)\", (ros::Time::now() - md_.last_depth_update_time_).toSec());\n    md_.depth_ok_ = false;\n  }\n}", "CodeBleu_score": 62.99333944380122}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\tif (map_updated_ && (ros::Time::now() - md_.last_occ_update_time_).toSec() >= md_.occ_update_period_) {\n    md_.last_occ_update_time_ = ros::Time::now();\n    // Project depth image into points and process them with raycasting\n    if (md_.depth_cam_active_) {\n      // Check if depth image has been updated\n      if (depth_image_updated_) {\n        depth_image_updated_ = false;\n        // Project depth image into points\n        std::vector<Eigen::Vector3d> points;\n        projectDepthImage(points);\n        // Process points with raycasting\n        raycastProcess(points);\n      }\n    }\n    // Clear and inflate local map if local map has been updated\n    if (local_map_updated_) {\n      local_map_updated_ = false;\n      clearAndInflateLocalMap();\n    }\n  }\n  // Check if odometry has been updated\n  if (odom_updated_) {\n    odom_updated_ = false;\n    if ((ros::Time::now() - md_.last_odom_update_time_).toSec() > md_.occ_timeout_) {\n      ROS_ERROR(\"Occupancy grid has not been updated for %f seconds due to no odometry data.\",\n                (ros::Time::now() - md_.last_odom_update_time_).toSec());\n      md_.occ_timeout_reached_ = true;\n    } else {\n      md_.occ_timeout_reached_ = false;\n    }\n  }\n  // Check if depth image has been updated\n  if (depth_image_updated_) {\n    depth_image_updated_ = false;\n    if ((ros::Time::now() - md_.last_depth_image_update_time_).toSec() > md_.occ_timeout_) {\n      ROS_ERROR(\"Occupancy grid has not been updated for %f seconds due to no depth image data.\",\n                (ros::Time::now() - md_.last_depth_image_update_time_).toSec());\n      md_.occ_timeout_reached_ = true", "CodeBleu_score": 54.98856197920773}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat avg_fmeasure = 0.f;\n\n    for (unsigned int i = 0; i < image_fns.size(); ++i)\n    {\n        Mat3b img = imread(image_fns[i]);\n\n        vector<Ellipse> ell_gt;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\n        vector<Ellipse> ell_dt;\n        _load_ellipse_DT(dt_fns[i], ell_dt, false);\n\n        float fmeasure = _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\n        avg_fmeasure += fmeasure;\n    }\n\n    avg_fmeasure /= float(image_fns.size());\n\n    return avg_fmeasure;\n}", "CodeBleu_score": 68.89924931866196}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat avg_fmeasure = 0.f;\n    unsigned n = image_fns.size();\n\n    for (unsigned i = 0; i < n; ++i)\n    {\n        // Load the image\n        Mat3b img = imread(image_fns[i]);\n\n        // Load the ground-truth ellipses\n        vector<Ellipse> ell_gt;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\n        // Load the detected ellipses\n        vector<Ellipse> ell_dt;\n        _load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\n        // Evaluate the detection performance\n        avg_fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n    }\n\n    return avg_fmeasure / float(n);\n}", "CodeBleu_score": 62.69347076318192}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat avg_fmeasure(0.f);\n    unsigned n_images = image_fns.size();\n\n    for (unsigned i = 0; i < n_images; ++i) {\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n\n        Mat3b img = imread(image_fns[i]);\n\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        avg_fmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n    }\n    return avg_fmeasure / float(n_images);\n}", "CodeBleu_score": 60.1077419632854}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a = atan2(foci[1] - y, foci[0] - x);\n    float b = atan2(foci[3] - y, foci[2] - x);\n    return angle_diff_signed(a, b);\n}", "CodeBleu_score": 21.632886892378302}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b;\n    float angle_a, angle_b;\n    float angle_diff;\n    if (foci == NULL) {\n        return 0;\n    }\n    a = foci[0];\n    b = foci[1];\n    angle_a = atan2(y - b, x - a);\n    angle_b = atan2(y - a, x - b);\n    angle_diff = angle_a - angle_b;\n    while (angle_diff <= -M_PI) angle_diff += M_2__PI;\n    while (angle_diff >   M_PI) angle_diff -= M_2__PI;\n    return angle_diff;\n}", "CodeBleu_score": 49.832594443700465}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a = atan2(y - foci[1], x - foci[0]);\n    float b = atan2(y - foci[3], x - foci[2]);\n    float angle = angle_diff_signed(a, b);\n    return angle;\n}", "CodeBleu_score": 33.758684617024926}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tif (start == end) {\n\t\treturn false;\n\t}\n\tif (start < end) {\n\t\tMIN = vp1[start].x;\n\t\tMAX = vp1[end].x;\n\t}\n\telse {\n\t\tMIN = vp1[end].x;\n\t\tMAX = vp1[start].x;\n\t}\n\tdouble integral = 0.0;\n\tfor (int i = start; i != end; i = (i + 1) % vp1.size()) {\n\t\tif (vp1[i].x > MIN && vp1[i].x < MAX) {\n\t\t\tif (start < end) {\n\t\t\t\tintegral += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y + vp1[i - 1].y);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tintegral += (vp1[i].x - vp1[(i + 1) % vp1.size()].x) * (vp1[i].y + vp1[(i + 1) % vp1.size()].y);\n\t\t\t}\n\t\t}\n\t}\n\tif (start < end) {\n\t\tif (integral > 0) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\tif (integral < 0) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 30.580856550301977}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tdouble min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        }\n        if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        }\n        if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n    }\n    double x_range = max_x - min_x;\n    double y_range = max_y - min_y;\n    double x_mid = min_x + x_range / 2;\n    double y_mid = min_y + y_range / 2;\n    double x_int_above = 0;\n    double x_int_below = 0;\n    double y_int_above = 0;\n    double y_int_below = 0;\n    double x_int_above_temp = 0;\n    double x_int_below_temp = 0;\n    double y_int_above_temp = 0;\n    double y_int_below_temp = 0;\n    double x_int_above_temp2 = 0;\n    double x_int_below_temp2 = 0;\n    double y_int_above_temp2 = 0;\n    double y_int_below_temp2 = 0;\n    for (int i = start + 1; i <= end; i++) {\n        if (vp1[i].x < x_mid) {\n            x_int_above_temp = vp1[i].x * vp1[i + 1].y;", "CodeBleu_score": 34.11798464514375}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint i;\n\tint j;\n\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tdouble dx;\n\tdouble dy;\n\tdouble x_mid;\n\tdouble y_mid;\n\n\t/*\n\t * Calculate the minimum and maximum x and y coordinates of the points in the section.\n\t */\n\tfor (i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the integral above and below the polygon section.\n\t */\n\tfor (i = start; i <= end; i++) {\n\t\tfor (j = start; j <= end; j++) {\n\t\t\tif (i == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vp1[i].y == vp1[j].y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vp1[i].x == vp1[j].x) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdx = vp1[j].x - vp1[i].x;\n\t\t\tdy = vp1[j].y - vp1[i].y;\n\t\t\tx_mid = (vp1[", "CodeBleu_score": 33.48900255497585}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tif (msg->detected_infos.size() == 0) {\n    ellipse_det.is_detected = false;\n    ellipse_det.num_lost = 0;\n    ellipse_det.num_regain = 0;\n    ellipse_det.sight_angle = 0.0;\n    return;\n  }\n  for (int i = 0; i < msg->detected_infos.size(); i++) {\n    if (msg->detected_infos[i].detected_objects.size() == 0) {\n      ellipse_det.is_detected = false;\n      ellipse_det.num_lost = 0;\n      ellipse_det.num_regain = 0;\n      ellipse_det.sight_angle = 0.0;\n      return;\n    }\n    for (int j = 0; j < msg->detected_infos[i].detected_objects.size(); j++) {\n      if (msg->detected_infos[i].detected_objects[j].name == \"T\") {\n        ellipse_det.num_regain++;\n        ellipse_det.num_lost = 0;\n        ellipse_det.is_detected = true;\n        ellipse_det.sight_angle = msg->detected_infos[i].detected_objects[j].pose.position.z;\n        break;\n      }\n    }\n  }\n  if (ellipse_det.num_lost > VISION_THRES) {\n    ellipse_det.is_detected = false;\n    ellipse_det.num_lost = 0;\n    ellipse_det.num_regain = 0;\n    ellipse_det.sight_angle = 0.0;\n  }\n  if (ellipse_det.num_regain > VISION_THRES) {\n    ellipse_det.is_detected = true;\n    ellipse_det.num_lost = 0;\n    ellipse_det.num_regain = 0;\n    ellipse_det.sight_angle =", "CodeBleu_score": 37.54145835026531}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tif (msg->detected_infos.size() > 0) {\n        for (int i = 0; i < msg->detected_infos.size(); i++) {\n            if (msg->detected_infos[i].name == \"T\") {\n                num_regain++;\n                num_lost = 0;\n            } else {\n                num_regain = 0;\n                num_lost++;\n            }\n            if (num_lost > VISION_THRES) {\n                is_detected = false;\n            }\n            if (num_regain > VISION_THRES) {\n                is_detected = true;\n            }\n            ellipse_det.position.x = msg->detected_infos[i].position.x;\n            ellipse_det.position.y = msg->detected_infos[i].position.y;\n            ellipse_det.position.z = msg->detected_infos[i].position.z;\n            ellipse_det.velocity.x = msg->detected_infos[i].velocity.x;\n            ellipse_det.velocity.y = msg->detected_infos[i].velocity.y;\n            ellipse_det.velocity.z = msg->detected_infos[i].velocity.z;\n            ellipse_det.attitude.x = msg->detected_infos[i].attitude.x;\n            ellipse_det.attitude.y = msg->detected_infos[i].attitude.y;\n            ellipse_det.attitude.z = msg->detected_infos[i].attitude.z;\n            ellipse_det.attitude.w = msg->detected_infos[i].attitude.w;\n            ellipse_det.size.x = msg->detected_infos[i].size.x;\n            ellipse_det.size.y = msg->detected_infos[i].size.y;\n            ellipse_det.size.z = msg->detected_infos[i].size.z;\n            ellipse_det.name = msg->detected", "CodeBleu_score": 55.16987629016894}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tif (msg->detected_infos.size() == 0) {\n        return;\n    }\n\n    int num_regain = 0;\n    int num_lost = 0;\n    for (int i = 0; i < msg->detected_infos.size(); i++) {\n        prometheus_msgs::DetectionInfo info = msg->detected_infos[i];\n        if (info.name == \"T\") {\n            num_regain++;\n        } else {\n            num_lost++;\n        }\n    }\n\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    } else if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n\n    ellipse_det.detected = is_detected;\n    ellipse_det.num_lost = num_lost;\n    ellipse_det.num_regain = num_regain;\n\n    double temp = ellipse_det.sight_angle[0];\n    ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n    ellipse_det.sight_angle[1] = temp;\n}", "CodeBleu_score": 65.27821764334259}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tEigen::Vector3d cur_pos_3d;\n  cur_pos_3d << cur_pos[0], cur_pos[1], 0.0;\n\n  if (Occupy_map_ptr->check_safety(cur_pos_3d, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 49.78170687420954}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tbool is_safe = true;\n  Eigen::Vector3d cur_pos_3d;\n  cur_pos_3d << cur_pos(0), cur_pos(1), 0;\n  double distance = Occupy_map_ptr->getDistance(cur_pos_3d);\n  if (distance < safe_distance) {\n    is_safe = false;\n  }\n\n  return is_safe;\n}", "CodeBleu_score": 48.50254088615692}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tdouble cur_x = cur_pos(0);\n  double cur_y = cur_pos(1);\n  double cur_z = cur_pos(2);\n\n  double cur_x_grid = cur_x / resolution;\n  double cur_y_grid = cur_y / resolution;\n  double cur_z_grid = cur_z / resolution;\n\n  int cur_x_cell = int(cur_x_grid);\n  int cur_y_cell = int(cur_y_grid);\n  int cur_z_cell = int(cur_z_grid);\n\n  double min_x = cur_x_grid - cur_x_cell;\n  double min_y = cur_y_grid - cur_y_cell;\n  double min_z = cur_z_grid - cur_z_cell;\n\n  if (cur_x_cell >= 0 && cur_y_cell >= 0 && cur_z_cell >= 0 && cur_x_cell < n_cell_ && cur_y_cell < n_cell_ &&\n      cur_z_cell < n_cell_) {\n    if (Occupy_map_ptr->getOccupancy(cur_x_cell, cur_y_cell, cur_z_cell) == 0) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 36.45391510255622}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\tpath_nodes_.push_back(end_node);\n    NodePtr current_node = end_node;\n    while (current_node->getParent() != nullptr) {\n        current_node = current_node->getParent();\n        path_nodes_.push_back(current_node);\n    }\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 62.628032627628386}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tpath_nodes_.push_back(end_node);\n\tNodePtr current_node = end_node->parent_;\n\twhile (current_node) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent_;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 53.01019102780159}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tpath_nodes_.push_back(end_node);\n\tNodePtr current_node = end_node->getParent();\n\twhile (current_node != start_node_) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->getParent();\n\t}\n\tpath_nodes_.push_back(start_node_);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 53.245211601756026}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\tstate_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    state_nei[id][3] = odom->twist.twist.linear.x;\n    state_nei[id][4] = odom->twist.twist.linear.y;\n    state_nei[id][5] = odom->twist.twist.linear.z;\n    state_nei[id][6] = odom->twist.twist.angular.x;\n    state_nei[id][7] = odom->twist.twist.angular.y;\n    state_nei[id][8] = odom->twist.twist.angular.z;\n\n    if (simulation_mode) {\n        if ((start_pos-state_nei[id]).norm() > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    }\n}", "CodeBleu_score": 60.44582374453372}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\tstate_nei[id][0] = odom->pose.pose.position.x;\n  state_nei[id][1] = odom->pose.pose.position.y;\n  state_nei[id][2] = odom->pose.pose.position.z;\n  if (simulation_mode) {\n    if ((start_pos-state_nei[id]).norm() > 5) {\n      get_nei_state[id] = false;\n    } else {\n      get_nei_state[id] = true;\n    }\n  }\n}", "CodeBleu_score": 51.12598535104442}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t// Update the state of a neighboring UGV based on its odometry data.\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n\n    // Check the distance from the start position and set the get_nei_state flag to false if the distance exceeds 5 meters.\n    if (simulation_mode) {\n        if ((start_pos - state_nei[id]).norm() > 5.0) {\n            get_nei_state[id] = false;\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n}", "CodeBleu_score": 54.29671688235938}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb\");\n\n    if (!odom_ready) {\n        return;\n    }\n\n    sensor_ready = true;\n    sensor_update_counter++;\n\n    if (sensor_update_counter > 4) {\n        sensor_update_counter = 0;\n\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n    }\n}", "CodeBleu_score": 62.321539991656614}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb\");\n\n    if (!odom_ready) {\n        return;\n    }\n\n    //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: odom_ready\");\n\n    sensor_ready = true;\n    sensor_update_count++;\n\n    //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready\");\n\n    if (sensor_update_count == 5) {\n        sensor_update_count = 0;\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n    }\n\n}", "CodeBleu_score": 63.56719623894176}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"Point cloud callback\");\n  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  sensor_update_counter++;\n  if (sensor_update_counter < 5) {\n    return;\n  }\n  sensor_update_counter = 0;\n  Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n}", "CodeBleu_score": 60.31335811336096}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_map_pcl);\n    inflate_point_cloud(global_map_pcl, global_map_pcl_inf);\n  }\n}", "CodeBleu_score": 51.00156825151151}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_pcl);\n    inflate_point_cloud(global_pcl, global_inflate_pcl);\n  }\n}", "CodeBleu_score": 51.070338112249495}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *globalmap);\n    inflate_point_cloud(globalmap, 0.02);\n  }\n}", "CodeBleu_score": 49.716945700517904}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::PointCloud<pcl::PointXYZ> cloud_odom;\n    pcl::PointCloud<pcl::PointXYZ> cloud_map;\n\n    projector_.projectLaser(*local_point, cloud);\n\n    if(!simulation_mode_) {\n        tf::Transform transform;\n        tf::poseMsgToTF(odom.pose.pose, transform);\n        pcl_ros::transformPointCloud(cloud, cloud_odom, transform);\n\n        local_map_merge_odom(cloud_odom, cloud_map);\n\n        cloud = cloud_map;\n    }\n\n    map_update_pcl(cloud);\n}", "CodeBleu_score": 50.77212697455102}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// Project laser scan into PointCloud2 format\n\tsensor_msgs::PointCloud2 cloud;\n\tprojector_.projectLaser(*local_point, cloud);\n\n\t// Convert to pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud_in;\n\tpcl::fromROSMsg(cloud, cloud_in);\n\n\t// If not in simulation mode, merge local map with odometry\n\tif (!simulation_mode_) {\n\t\t// Get odometry data\n\t\tdouble odom_x = odom.pose.pose.position.x;\n\t\tdouble odom_y = odom.pose.pose.position.y;\n\t\tdouble odom_z = odom.pose.pose.position.z;\n\t\tdouble odom_qx = odom.pose.pose.orientation.x;\n\t\tdouble odom_qy = odom.pose.pose.orientation.y;\n\t\tdouble odom_qz = odom.pose.pose.orientation.z;\n\t\tdouble odom_qw = odom.pose.pose.orientation.w;\n\n\t\t// Convert quaternion to euler angles\n\t\tdouble odom_yaw = atan2(2 * (odom_qw * odom_qz + odom_qx * odom_qy), 1 - 2 * (odom_qy * odom_qy + odom_qz * odom_qz));\n\n\t\t// Transform the local map into the global map\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_out;\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud_out_transformed;\n\t\tpcl::transformPointCloud(cloud_in, cloud_out, Eigen::Vector3f(odom_x, odom_y, odom_z), Eigen::Quaternionf(odom_w, odom_x, odom_y, odom_z));\n\n\t\t// Merge the local map with the global map\n\t\tlocal_map_merge_odom(cloud_out, cloud_out_transformed);", "CodeBleu_score": 42.811071502481624}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tif (simulation_mode_) {\n        // Transform the laser scan into a PointCloud2 format\n        sensor_msgs::PointCloud2 local_point_cloud;\n        projector_.projectLaser(*local_point, local_point_cloud);\n\n        // Transform the PointCloud2 into a pcl::PointCloud\n        pcl::PointCloud<pcl::PointXYZ> local_map;\n        pcl::fromROSMsg(local_point_cloud, local_map);\n\n        // Update the local map with the new laser scan\n        map_update(local_map);\n    } else {\n        // Transform the laser scan into a PointCloud2 format\n        sensor_msgs::PointCloud2 local_point_cloud;\n        projector_.transformLaserScanToPointCloud(\"base_link\", *local_point, local_point_cloud, listener_);\n\n        // Transform the PointCloud2 into a pcl::PointCloud\n        pcl::PointCloud<pcl::PointXYZ> local_map;\n        pcl::fromROSMsg(local_point_cloud, local_map);\n\n        // Merge the local map with the odometry data\n        tf::Transform odom_tf;\n        tf::poseMsgToTF(odom.pose.pose, odom_tf);\n        local_map_merge_odom(local_map, odom_tf);\n\n        // Update the local map with the new laser scan\n        map_update(local_map);\n    }\n}", "CodeBleu_score": 51.3516039321944}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tsensor_msgs::PointCloud2 global_pcl_msg, inflate_pcl_msg;\n  pcl::toROSMsg(*global_pcl_ptr, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n  pcl::toROSMsg(*inflate_pcl_ptr, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 55.32467600258975}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tsensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_pcl, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 64.74799756692668}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tpcl::PointCloud<pcl::PointXYZ> pcl_global;\n  pcl::PointCloud<pcl::PointXYZ> pcl_inflate;\n  pcl::PointXYZ pt;\n\n  // global_pcl_pub\n  for (int i = 0; i < 1000; i++) {\n    for (int j = 0; j < 1000; j++) {\n      if (occupancy_grid_[i][j] != 0) {\n        pt.x = (float)i / 10.0;\n        pt.y = (float)j / 10.0;\n        pt.z = 0.0;\n        pcl_global.push_back(pt);\n      }\n    }\n  }\n  pcl_global.header.frame_id = \"world\";\n  global_pcl_pub.publish(pcl_global);\n\n  // inflate_pcl_pub\n  for (int i = 0; i < 1000; i++) {\n    for (int j = 0; j < 1000; j++) {\n      if (occupancy_grid_inflate_[i][j] != 0) {\n        pt.x = (float)i / 10.0;\n        pt.y = (float)j / 10.0;\n        pt.z = 0.0;\n        pcl_inflate.push_back(pt);\n      }\n    }\n  }\n  pcl_inflate.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(pcl_inflate);\n}", "CodeBleu_score": 54.320770481626525}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// If odometry is ready, set the sensor_ready flag to true\n    if (odom_ready) {\n        sensor_ready = true;\n    }\n\n    // If sensor_ready flag is true, update the map with the new point cloud data and current UAV odometry\n    if (sensor_ready) {\n\n        // Update the A* algorithm's map with the new point cloud data and current UAV odometry\n        Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_odom);\n\n        // Set the sensor_ready flag to false\n        sensor_ready = false;\n    }\n}", "CodeBleu_score": 61.85724054812234}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// ROS_INFO(\"Got a pointcloud\");\n    if (!odom_ready) {\n        ROS_WARN(\"Odom not ready\");\n        return;\n    }\n    sensor_ready = true;\n    // ROS_INFO(\"Odom ready\");\n    // ROS_INFO(\"Processing pointcloud\");\n    // ROS_INFO(\"Map size: %d\", (int)Astar_ptr->Occupy_map_ptr->map_size_2d);\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, odom_current);\n    // ROS_INFO(\"Map size: %d\", (int)Astar_ptr->Occupy_map_ptr->map_size_2d);\n}", "CodeBleu_score": 77.55844585567955}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tROS_INFO_ONCE(\"GlobalPlanner: Got point cloud\");\n    if (!odom_ready) {\n        ROS_WARN_THROTTLE(1, \"GlobalPlanner: No odometry yet, skipping point cloud callback\");\n        return;\n    }\n    sensor_ready = true;\n\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n}", "CodeBleu_score": 64.75281110594976}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Update the phase of the gait\n    base_.updatePhase(rosTimeToChampTime(ros::Time::now()));\n\n    // Get the desired pose\n    auto target_pose = pose_command_.getPose();\n\n    // Get the desired velocity\n    auto target_velocity = velocity_command_.getVelocity();\n\n    // Calculate the target foot positions\n    base_.bodyController().calculateTargetPose(target_pose, target_velocity);\n\n    // Calculate the target joint positions\n    base_.legController().calculateTargetJoints();\n\n    // Get the target joint positions\n    float target_joints[12];\n    base_.legController().getTargetJoints(target_joints);\n\n    // Get the target foot positions\n    float target_feet[12];\n    base_.bodyController().getTargetFeet(target_feet);\n\n    // Get the current joint positions\n    float current_joints[12];\n    base_.legController().getCurrentJoints(current_joints);\n\n    // Get the current foot positions\n    float current_feet[12];\n    base_.bodyController().getCurrentFeet(current_feet);\n\n    // Get the current foot positions\n    float current_feet[12];\n    base_.bodyController().getCurrentFeet(current_feet);\n\n    // Get the current foot positions\n    float current_feet[12];\n    base_.bodyController().getCurrentFeet(current_feet);\n\n    // Get the current foot positions\n    float current_feet[12];\n    base_.bodyController().getCurrentFeet(current_feet);\n\n    // Get the current foot positions\n    float current_feet[12];\n    base_.bodyController().getCurrentFeet(current_feet);\n\n    // Get the current foot positions\n    float current_feet[12];\n    base_.bodyController().getCurrentFeet(current_feet);\n\n    // Get the current foot positions\n    float current_feet[12];\n    base_.bodyController().getCurrentFeet(current_feet);\n\n    // Get the", "CodeBleu_score": 41.38789972503412}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t//ROS_INFO(\"Control Loop\");\n  //ROS_INFO(\"Time: %f\", event.current_real.toSec());\n  //ROS_INFO(\"Time: %f\", event.last_real.toSec());\n  //ROS_INFO(\"Time: %f\", event.last_real.toSec() - event.current_real.toSec());\n  //ROS_INFO(\"Time: %f\", event.current_real.toSec() - event.last_real.toSec());\n\n  //ROS_INFO(\"Time: %f\", event.current_real.toSec() - event.last_real.toSec());\n  //ROS_INFO(\"Time: %f\", event.current_real.toSec());\n  //ROS_INFO(\"Time: %f\", event.last_real.toSec());\n  //ROS_INFO(\"Time: %f\", event.current_real.toSec() - event.last_real.toSec());\n\n  //ROS_INFO(\"Time: %f\", rosTimeToChampTime(event.current_real));\n  //ROS_INFO(\"Time: %f\", rosTimeToChampTime(event.last_real));\n  //ROS_INFO(\"Time: %f\", rosTimeToChampTime(event.current_real) - rosTimeToChampTime(event.last_real));\n  //ROS_INFO(\"Time: %f\", rosTimeToChampTime(event.current_real.toSec()));\n  //ROS_INFO(\"Time: %f\", rosTimeToChampTime(event.last_real.toSec()));\n  //ROS_INFO(\"Time: %f\", rosTimeToChampTime(event.current_real.toSec()) - rosTimeToChampTime(event.last_real.toSec()));\n\n  //ROS_INFO(\"Time: %f\", event.current_real.toSec());\n  //ROS_INFO(\"Time: %f\", event.last_real.toSec());\n  //ROS_INFO(\"Time: %f\", event.current_real.toSec() - event.last_real.toSec());\n\n  //ROS_INFO(\"Time:", "CodeBleu_score": 5.583872222222208}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get current time\n    ros::Time now = ros::Time::now();\n\n    // Get current phase\n    double current_phase = phase_manager_.getPhase(now.toNSec() / 1000ul);\n\n    // Get current pose\n    champ::Pose current_pose = kinematics_.inverse(base_.getLegsPositions());\n\n    // Get target pose\n    champ::Pose target_pose = pose_manager_.getPose(now.toNSec() / 1000ul);\n\n    // Get target pose\n    champ::Velocities target_velocities = velocity_manager_.getVelocities(now.toNSec() / 1000ul);\n\n    // Compute target foot positions\n    std::vector<champ::Point> target_feet_positions = body_controller_.poseCommand(current_pose, target_pose, current_phase);\n\n    // Compute target foot velocities\n    std::vector<champ::Velocity> target_feet_velocities = body_controller_.velocityCommand(current_pose, target_velocities, current_phase);\n\n    // Compute target joint positions\n    float target_joints[12];\n    for (size_t i = 0; i < 4; i++)\n    {\n        target_joints[3 * i] = target_feet_positions[i].x;\n        target_joints[3 * i + 1] = target_feet_positions[i].y;\n        target_joints[3 * i + 2] = target_feet_positions[i].z;\n    }\n\n    // Perform inverse kinematics\n    kinematics_.forward(target_joints);\n\n    // Get foot contacts\n    bool foot_contacts[4];\n    for (size_t i = 0; i < 4; i++)\n    {\n        foot_contacts[i] = base_.legs[i]->inContact();\n    }\n\n    // Publish joint positions\n    publishJoints_(target_joints);\n\n    // Publish foot contacts\n    publishFootContacts_(foot", "CodeBleu_score": 47.47067634347706}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (publish_foot_contacts_ && !in_gazebo_) {\n        quad_msgs::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n        contacts_msg.header.frame_id = base_link_frame_;\n        contacts_msg.contacts.resize(4);\n        for (int i = 0; i < 4; i++) {\n            contacts_msg.contacts[i].header.stamp = ros::Time::now();\n            contacts_msg.contacts[i].header.frame_id = base_link_frame_;\n            contacts_msg.contacts[i].contact_name = foot_contact_names_[i];\n            contacts_msg.contacts[i].in_contact = foot_contacts[i];\n        }\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}", "CodeBleu_score": 63.51249891990716}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (publish_foot_contacts_ && !gazebo_) {\n    quad_msgs::FootContacts contacts_msg;\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts.resize(4);\n      contacts_msg.contacts[i].contact = foot_contacts[i];\n      contacts_msg.contacts[i].header.stamp = ros::Time::now();\n      contacts_msg.contacts[i].header.frame_id = \"quad\";\n      foot_contacts_publisher_.publish(contacts_msg);\n    }\n  }\n}", "CodeBleu_score": 63.723059920882896}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_.getNumSubscribers() > 0 && !gazebo_) {\n\t\t/*\n\t\t * Create the ContactsStamped message\n\t\t */\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = \"odom\";\n\t\tcontacts_msg.contacts.resize(4);\n\t\t/*\n\t\t * Populate the message with the current gait phase of each leg\n\t\t */\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i].position.x = 0.0;\n\t\t\tcontacts_msg.contacts[i].position.y = 0.0;\n\t\t\tcontacts_msg.contacts[i].position.z = 0.0;\n\t\t\tcontacts_msg.contacts[i].normal.x = 0.0;\n\t\t\tcontacts_msg.contacts[i].normal.y = 0.0;\n\t\t\tcontacts_msg.contacts[i].normal.z = 0.0;\n\t\t\tcontacts_msg.contacts[i].depth = 0.0;\n\t\t\tcontacts_msg.contacts[i].contact_name = \"foot_\" + std::to_string(i);\n\t\t\tcontacts_msg.contacts[i].in_contact = foot_contacts[i];\n\t\t}\n\t\t/*\n\t\t * Publish the message\n\t\t */\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 46.67653206408043}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\tmsg = Joints()\n\tmsg.header.stamp = now()\n\tmsg.header.frame_id = \"base_link\"\n\tmsg.name = [\n\t\t\"joint_0\",\n\t\t\"joint_1\",\n\t\t\"joint_2\",\n\t\t\"joint_3\",\n\t\t\"joint_4\",\n\t\t\"joint_5\",\n\t\t\"joint_6\",\n\t\t\"joint_7\",\n\t\t\"joint_8\",\n\t\t\"joint_9\",\n\t\t\"joint_10\",\n\t\t\"joint_11\"\n\t]\n\tmsg.position = joints.position[0..11]\n\tpublish(msg, \"joints\")\n\ttraj = JointTrajectory()\n\ttraj.header.stamp = now()\n\ttraj.header.frame_id = \"base_link\"\n\ttraj.joint_names = [\n\t\t\"joint_0\",\n\t\t\"joint_1\",\n\t\t\"joint_2\",\n\t\t\"joint_3\",\n\t\t\"joint_4\",\n\t\t\"joint_5\",\n\t\t\"joint_6\",\n\t\t\"joint_7\",\n\t\t\"joint_8\",\n\t\t\"joint_9\",\n\t\t\"joint_10\",\n\t\t\"joint_11\"\n\t]\n\ttraj.points = [\n\t\tJointTrajectoryPoint(\n\t\t\tpositions: joints.position[0..11],\n\t\t\ttime_from_start: 0.5\n\t\t)\n\t]\n\tpublish(traj, \"joint_trajectory\")\n}", "CodeBleu_score": 32.60645182849059}, {"code": "def joints_cmd_callback(self, joints){\n\t// create minimal joints message\n\tvar minimal_joints = Joints()\n\tminimal_joints.name = joints.name[0:12]\n\tminimal_joints.position = joints.position[0:12]\n\n\t// publish minimal joints message\n\tself.publish('joints', minimal_joints)\n\n\t// create joint trajectory message\n\tvar trajectory = JointTrajectory()\n\ttrajectory.joint_names = joints.name[0:12]\n\tvar point = JointTrajectoryPoint()\n\tpoint.positions = joints.position[0:12]\n\tpoint.time_from_start = 1.0\n\ttrajectory.points = [point]\n\n\t// publish joint trajectory message\n\tself.publish('joint_trajectory', trajectory)\n}", "CodeBleu_score": 42.023128058424746}, {"code": "def joints_cmd_callback(self, joints){\n\t// Create a minimal joints message with the first 12 joint positions\n\t\tvar joints_msg = new JointState();\n\t\tjoints_msg.name = joints.name;\n\t\tjoints_msg.position = joints.position.slice(0, 12);\n\t\t\n\t\t// Publish the joints message\n\t\tself.publish(self.joints_topic, joints_msg);\n\t\t\n\t\t// Create a joint trajectory message with the same positions\n\t\tvar traj_msg = new JointTrajectory();\n\t\ttraj_msg.joint_names = joints.name;\n\t\tvar point = new JointTrajectoryPoint();\n\t\tpoint.positions = joints.position.slice(0, 12);\n\t\tpoint.time_from_start = self.traj_duration;\n\t\ttraj_msg.points = [point];\n\t\t\n\t\t// Publish the trajectory message\n\t\tself.publish(self.traj_topic, traj_msg);\n\t\t\n}", "CodeBleu_score": 39.68073965765359}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize all foot contacts to false\n    for (int i = 0; i < 4; i++) {\n        foot_contacts_[i] = false;\n    }\n    // For each contact in the message, check if it matches a foot link\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::string link1 = _msg->contact(i).collision1();\n        std::string link2 = _msg->contact(i).collision2();\n        std::size_t found1 = link1.find(foot_links_[0]);\n        std::size_t found2 = link2.find(foot_links_[0]);\n        if (found1 != std::string::npos || found2 != std::string::npos) {\n            foot_contacts_[0] = true;\n        }\n        found1 = link1.find(foot_links_[1]);\n        found2 = link2.find(foot_links_[1]);\n        if (found1 != std::string::npos || found2 != std::string::npos) {\n            foot_contacts_[1] = true;\n        }\n        found1 = link1.find(foot_links_[2]);\n        found2 = link2.find(foot_links_[2]);\n        if (found1 != std::string::npos || found2 != std::string::npos) {\n            foot_contacts_[2] = true;\n        }\n        found1 = link1.find(foot_links_[3]);\n        found2 = link2.find(foot_links_[3]);\n        if (found1 != std::string::npos || found2 != std::string::npos) {\n            foot_contacts_[3] = true;\n        }\n    }\n}", "CodeBleu_score": 55.709366054813394}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false\n  left_contact = false;\n  right_contact = false;\n\n  // For each contact in the message, split the collision1 and collision2 strings\n  // to identify the contact link.\n  // If a contact matches one of the foot links, set the corresponding foot contact\n  // state to true.\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    std::string collision1 = _msg->contact(i).collision1();\n    std::string collision2 = _msg->contact(i).collision2();\n    std::string link_name;\n\n    // Check if the collision1 string matches the left foot link\n    size_t pos = collision1.find(left_foot_link);\n    if (pos != std::string::npos) {\n      link_name = left_foot_link;\n    }\n\n    // Check if the collision2 string matches the left foot link\n    pos = collision2.find(left_foot_link);\n    if (pos != std::string::npos) {\n      link_name = left_foot_link;\n    }\n\n    // Check if the collision1 string matches the right foot link\n    pos = collision1.find(right_foot_link);\n    if (pos != std::string::npos) {\n      link_name = right_foot_link;\n    }\n\n    // Check if the collision2 string matches the right foot link\n    pos = collision2.find(right_foot_link);\n    if (pos != std::string::npos) {\n      link_name = right_foot_link;\n    }\n\n    // If a foot link was identified, set the appropriate foot contact state to\n    // true\n    if (link_name == left_foot_link) {\n      left_contact = true;\n    }\n    if (link_name == right_foot_link) {\n      right_contact = true;\n    }\n  }\n}", "CodeBleu_score": 41.607290383628936}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false\n  foot_contact_states_.left_contact = false;\n  foot_contact_states_.right_contact = false;\n  // Loop through all contacts\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    // Split the collision1 string by the slash character\n    std::vector<std::string> tokens;\n    boost::split(tokens, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n    // If the link name of collision1 matches the left foot link name\n    if (tokens.back() == \"foot_left\") {\n      // Set the left foot contact state to true\n      foot_contact_states_.left_contact = true;\n    }\n    // If the link name of collision1 matches the right foot link name\n    if (tokens.back() == \"foot_right\") {\n      // Set the right foot contact state to true\n      foot_contact_states_.right_contact = true;\n    }\n  }\n}", "CodeBleu_score": 41.69087441273515}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->size());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d thrust;\n  thrust = vehicle_parameters_.mass_ * acceleration;\n\n  Eigen::Vector3d thrust_projected_on_body_z_axis = thrust.dot(odometry_.orientation.toRotationMatrix().col(2)) * odometry_.orientation.toRotationMatrix().col(2);\n\n  Eigen::Vector3d thrust_projected_on_body_xy_axis = thrust - thrust_projected_on_body_z_axis;\n\n  Eigen::Vector3d thrust_projected_on_body_xy_axis_normalized = thrust_projected_on_body_xy_axis;\n  thrust_projected_on_body_xy_axis_normalized.normalize();\n\n  Eigen::Vector3d thrust_projected_on_body_xy_axis_normalized_scaled = thrust_projected_on_body_xy_axis_normalized * thrust_projected_on_body_xy_axis.norm();\n\n  Eigen::Vector3d thrust_projected_on_body_z_axis_normalized = thrust_projected_on_body_z_axis;\n  thrust_projected_on_body_z_axis_normalized.normalize();\n\n  Eigen::Vector3d thrust_projected_on_body_z_axis_normalized_scaled = thrust_projected_on_body_z_axis_normalized * thrust_projected_on_body_z_axis.norm();\n\n  Eigen::Vector3d combined_th", "CodeBleu_score": 54.07930493884382}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->size());\n    return;\n  }\n\n  // Compute desired acceleration and angular acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust_body = acceleration - odometry_.orientation.toRotationMatrix() * vehicle_parameters_.gravity_;\n  double thrust = thrust_body.dot(Eigen::Vector3d::UnitZ());\n\n  // Combine thrust and angular acceleration into a single vector.\n  Eigen::Vector3d thrust_and_angular_acceleration = thrust * Eigen::Vector3d::UnitZ() + angular_acceleration;\n\n  // Project thrust and angular acceleration onto rotor directions.\n  *rotor_velocities = thrust_and_angular_acceleration.transpose() * vehicle_parameters_.rotor_configuration_.inverse_rotor_mapping;\n\n  // Ensure non-negative values.\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->size()));\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 71.02752689096819}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  // Reset rotor velocities.\n  rotor_velocities->setZero();\n\n  if (!controller_active_) return;\n\n  // Compute desired acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  // Compute desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project onto body z-axis.\n  Eigen::Vector3d thrust = acceleration.dot(odometry_.orientation.toRotationMatrix().col(2)) * odometry_.orientation.toRotationMatrix().col(2);\n  Eigen::Vector3d torque = angular_acceleration.cross(odometry_.orientation.toRotationMatrix().col(2));\n\n  // Combine thrust and torque.\n  Eigen::Vector3d desired_acceleration = thrust + torque;\n\n  // Transform to rotor velocities.\n  *rotor_velocities = vehicle_parameters_.rotor_configuration_.rotor_velocity_direction\n      * (rotor_thrust_map_.inverse() * desired_acceleration);\n\n  // Ensure non-negative values.\n  for (int i = 0; i < rotor_velocities->rows(); i++)\n    (*rotor_velocities)[i] = std::max((*rotor_velocities)[i], 0.0);\n\n  // Limit the maximum rotor speed.\n  double max_rotor_speed = rotor_thrust_map_.maxCoeff();\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_veloc", "CodeBleu_score": 64.72570800558692}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n\n  // Compute position and velocity errors.\n  Eigen::Vector3d position_error =\n      command_.trajectory_point().position() - odometry_.position();\n\n  Eigen::Vector3d velocity_error =\n      command_.trajectory_point().velocity() -\n      odometry_.orientation().toRotationMatrix() * odometry_.linear_velocity();\n\n  // Compute the desired acceleration.\n  *acceleration =\n      position_error.cwiseProduct(params_.position_gain) +\n      velocity_error.cwiseProduct(params_.velocity_gain) +\n      command_.trajectory_point().acceleration();\n\n  // Adjust for mass, gravity, and the vehicle's acceleration.\n  *acceleration -=\n      odometry_.linear_acceleration() / params_.mass -\n      params_.gravity;\n}", "CodeBleu_score": 45.02005692812943}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n\n  const double current_time_sec = Clock::NowInSeconds();\n  const double dt = current_time_sec - timestamp_sec_;\n  timestamp_sec_ = current_time_sec;\n\n  // Vehicle related.\n  const auto& vehicle_param =\n      common::VehicleConfigHelper::Instance()->GetConfig().vehicle_param();\n  const double wheel_base = vehicle_param.wheel_base();\n  const double half_wheel_base = wheel_base / 2.0;\n  const double steer_ratio = vehicle_param.steer_ratio();\n  const double steer_single_direction_max_degree =\n      vehicle_param.max_steer_angle() * 180.0 / M_PI;\n\n  // Controller related.\n  const double ts = control_conf_->leadlag_controller_conf().ts();\n  const double alpha = control_conf_->leadlag_controller_conf().alpha();\n  const double beta = control_conf_->leadlag_controller_conf().beta();\n  const double max_acceleration =\n      common::math::Clamp(control_conf_->max_acceleration(),\n                          vehicle_param.max_acceleration() - 0.1,\n                          vehicle_param.max_deceleration() + 0.1);\n  const double max_deceleration =\n      common::math::Clamp(control_conf_->max_deceleration(),\n                          vehicle_param.max_deceleration() - 0.1,\n                          vehicle_param.max_acceleration() + 0.1);\n  const double max_steer_rate =\n      common::math::Clamp(control_conf_->max_steer_rate(),\n                          vehicle_param.max_steer_angle_rate() - 0.1,\n                          vehicle_param.max_steer_angle_rate() + 0.1);\n  const double max_steer_angle =\n      common::math::Clamp(control_conf_->max_steer_", "CodeBleu_score": 37.07002586767042}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// Transform vehicle velocity to world frame\n  Eigen::Vector3d vehicle_velocity_world;\n  vehicle_velocity_world =\n      vehicle_param_.rotation.toRotationMatrix() *\n      vehicle_state_.linear_velocity;\n\n  // Compute position and velocity errors\n  Eigen::Vector3d position_error;\n  position_error = vehicle_state_.position - command_.trajectory.position;\n\n  Eigen::Vector3d velocity_error;\n  velocity_error = vehicle_state_.linear_velocity - command_.trajectory.velocity;\n\n  // Compute desired acceleration\n  *acceleration = vehicle_param_.mass_inv *\n                  (command_.trajectory.acceleration +\n                   vehicle_param_.rotation.toRotationMatrix() *\n                       (command_.lateral_acceleration_limit *\n                            position_error.cwiseProduct(\n                                command_.lateral_acceleration_limit_multiplier) +\n                        command_.longitudinal_acceleration_limit *\n                            velocity_error.cwiseProduct(\n                                command_.longitudinal_acceleration_limit_multiplier)));\n  *acceleration += vehicle_param_.gravity_vector;\n}", "CodeBleu_score": 46.85688338064183}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // Check that the input parameters are valid\n  assert(attitude_setpoint_);\n  assert(thrust_);\n\n  // Resize the rotor velocities vector\n  rotor_velocities->resize(rotor_configuration_.rotors.size());\n\n  // Compute the desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // Compute the desired rotor velocities\n  Eigen::Vector3d rotor_velocities_desired = angular_acceleration.cwiseProduct(rotor_configuration_.inertia) + Eigen::Vector3d::Ones() * (*thrust_);\n  *rotor_velocities = rotor_velocities_desired.cwiseMax(Eigen::Vector3d::Ones());\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 50.615619912420925}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // Ensure the input and parameters are valid.\n  assert(attitude_.coeffs().allFinite());\n  assert(angular_acceleration_.allFinite());\n  assert(thrust_.allFinite());\n  assert(inertia_.allFinite());\n  assert(gain_attitude_.allFinite());\n  assert(gain_angular_rate_.allFinite());\n  assert(gain_thrust_.allFinite());\n  assert(rotor_configuration_.size() == 4);\n  assert(rotor_configuration_[0] == 1);\n  assert(rotor_configuration_[1] == 1);\n  assert(rotor_configuration_[2] == 1);\n  assert(rotor_configuration_[3] == 1);\n  assert(rotor_configuration_[4] == 1);\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(rotor_configuration_.size());\n\n  // Compute the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration;\n  ComputeDesiredAngularAcc(&desired_angular_acceleration);\n\n  // Combine the desired angular acceleration and thrust reference into a single vector.\n  Eigen::VectorXd desired_angular_acceleration_thrust(6);\n  desired_angular_acceleration_thrust.block<3, 1>(0, 0) = desired_angular_acceleration;\n  desired_angular_acceleration_thrust.block<3, 1>(3, 0) = thrust_;\n\n  // Compute the rotor velocities.\n  *rotor_velocities = inertia_.cwiseInverse() * desired_angular_acceleration_thrust;\n\n  // Ensure the rotor velocities are at least one.\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n\n  // Take the square", "CodeBleu_score": 51.34871143635296}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // check if the input is valid\n  if (attitude_.coeffs().hasNaN() || angular_acceleration_.hasNaN() || thrust_.hasNaN() ||\n      gain_attitude_.hasNaN() || gain_angular_rate_.hasNaN()) {\n    ROS_ERROR(\"An input to the attitude controller is NaN.\");\n    return;\n  }\n\n  // check if the parameters are valid\n  if (gain_attitude_.hasNaN() || gain_angular_rate_.hasNaN()) {\n    ROS_ERROR(\"An attitude controller parameter is invalid.\");\n    return;\n  }\n\n  // resize the rotor velocities vector\n  rotor_velocities->resize(rotor_count_);\n\n  // calculate the desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // combine the desired angular acceleration and thrust into a single vector\n  Eigen::VectorXd input(6);\n  input << angular_acceleration, thrust_;\n\n  // compute the rotor velocities\n  *rotor_velocities = rotor_matrix_ * input;\n\n  // ensure the rotor velocities are at least one\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_count_));\n\n  // take the square root of each component\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 55.40382222086222}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\ttry:\n        start_index = self.get_next_index(start_time)\n        end_index = self.get_next_index(end_time)\n    except Exception, e:\n        raise e\n    try:\n        copied_obj = copy.deepcopy(self)\n    except Exception, e:\n        raise e\n    try:\n        copied_obj.time = self.time[start_index:end_index]\n        copied_obj.value = self.value[start_index:end_index]\n        copied_obj.error = self.error[start_index:end_index]\n    except Exception, e:\n        raise e\n    return copied_obj\n\n", "CodeBleu_score": 52.71678270156309}, {"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in self.__dict__.keys():\n        if attr != 'time':\n            copied_obj.__setattr__(attr, copied_obj.__getattribute__(attr)[start_index:end_index])\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    return copied_obj", "CodeBleu_score": 60.413727756209326}, {"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in self.__dict__:\n        if attr != 'time':\n            copied_obj.__setattr__(attr, copied_obj.__getattribute__(attr)[start_index:end_index])\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    return copied_obj", "CodeBleu_score": 60.471683826055475}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tposition = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    yaw = euler_from_quaternion(quaternion)[2]\n    if not self.last_waypoint:\n        self.last_waypoint = (position, yaw)\n        return\n    if (position.x != self.last_waypoint[0].x or position.y != self.last_waypoint[0].y or position.z != self.last_waypoint[0].z or yaw != self.last_waypoint[1]):\n        self.last_waypoint = (position, yaw)\n        self.append_point(position)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)", "CodeBleu_score": 20.375800914597495}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tposition = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    euler = euler_from_quaternion(quaternion)\n    point = Point(position.x, position.y, position.z)\n    if self.last_waypoint is not None:\n        if point != self.last_waypoint.position or euler[2] != self.last_waypoint.yaw:\n            self.append_point(point)\n            self.yaw = numpy.append(self.yaw, euler[2])\n            self.append_times(msg_time, bag_time)\n    self.last_waypoint = waypoint_msg\n\n", "CodeBleu_score": 17.744934391785037}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tposition = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    yaw = euler_from_quaternion(quaternion)[2]\n    if not numpy.array_equal(self.last_position, position) or not numpy.array_equal(self.last_yaw, yaw):\n        self.append_point(position)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_position = position\n        self.last_yaw = yaw", "CodeBleu_score": 25.437371865440227}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == \"/imu/data\":\n        self.acc_x = numpy.append(self.acc_x, msg.linear_acceleration.x)\n        self.acc_y = numpy.append(self.acc_y, msg.linear_acceleration.y)\n        self.acc_z = numpy.append(self.acc_z, msg.linear_acceleration.z)\n        self.append_times(to_sec(msg.header.stamp), bag_time)\n\n", "CodeBleu_score": 33.76337584185547}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == self.imu_topic:\n        self.imu_acceleration.append_times(to_sec(msg.header.stamp), bag_time)\n        self.imu_acceleration.x = numpy.append(self.imu_acceleration.x, msg.linear_acceleration.x)\n        self.imu_acceleration.y = numpy.append(self.imu_acceleration.y, msg.linear_acceleration.y)\n        self.imu_acceleration.z = numpy.append(self.imu_acceleration.z, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 33.33609935700643}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == self.imu_topic_1:\n        self.imu_1_time.append_times(to_sec(msg.header.stamp), bag_time)\n        self.imu_1_x.append(msg.linear_acceleration.x)\n        self.imu_1_y.append(msg.linear_acceleration.y)\n        self.imu_1_z.append(msg.linear_acceleration.z)\n    elif topic == self.imu_topic_2:\n        self.imu_2_time.append_times(to_sec(msg.header.stamp), bag_time)\n        self.imu_2_x.append(msg.linear_acceleration.x)\n        self.imu_2_y.append(msg.linear_acceleration.y)\n        self.imu_2_z.append(msg.linear_acceleration.z)\n    elif topic == self.imu_topic_3:\n        self.imu_3_time.append_times(to_sec(msg.header.stamp), bag_time)\n        self.imu_3_x.append(msg.linear_acceleration.x)\n        self.imu_3_y.append(msg.linear_acceleration.y)\n        self.imu_3_z.append(msg.linear_acceleration.z)\n    elif topic == self.imu_topic_4:\n        self.imu_4_time.append_times(to_sec(msg.header.stamp), bag_time)\n        self.imu_4_x.append(msg.linear_acceleration.x)\n        self.imu_4_y.append(msg.linear_acceleration.y)\n        self.imu_4_z.append(msg.linear_acceleration.z)\n    elif topic == self.imu_topic_5:\n        self.imu_5_time.append_times(to_sec(msg.header.stamp), bag_time)\n        self.", "CodeBleu_score": 23.311248372505606}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\tfig = pyplot.figure(figsize=(16, 9))\n    fig.suptitle(f\"Acceleration data for {self.name}\", fontsize=20)\n    ax = fig.add_subplot(1, 1, 1)\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel.time, accel.x, label=f\"{accel.name} x\", color=colors[i])\n        ax.plot(accel.time, accel.y, label=f\"{accel.name} y\", color=colors[i])\n        ax.plot(accel.time, accel.z, label=f\"{accel.name} z\", color=colors[i])\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.ylabel(\"Acceleration (g)\")\n    pyplot.legend()\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        else:\n            plot_suffix = f\"_{plot_suffix}\"\n        pyplot.savefig(\n            f\"{self.plot_prefix}_accelerations{plot_suffix}.png\", bbox_inches=\"tight\"\n        )", "CodeBleu_score": 34.99167253089277}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\tfig = pyplot.figure(figsize=(12, 9))\n    fig.suptitle(\"Acceleration Data\", fontsize=20)\n    ax = fig.add_subplot(1, 1, 1)\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel.time, accel.x, color=\"red\", label=\"x\")\n        ax.plot(accel.time, accel.y, color=\"green\", label=\"y\")\n        ax.plot(accel.time, accel.z, color=\"blue\", label=\"z\")\n    pyplot.ylabel(\"Acceleration (g)\")\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    if self.save_plots:\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += str(plot_suffix)\n        pyplot.savefig(filename + \".png\")\n    pyplot.show()", "CodeBleu_score": 37.46074093362121}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\tfig = pyplot.figure()\n    fig.suptitle(self.get_title())\n    ax = fig.add_subplot(111)\n    for i, a_x in enumerate(self.accelerations):\n        a_x.plot(ax, \"x\", \"Acceleration X \" + str(i))\n        a_y.plot(ax, \"y\", \"Acceleration Y \" + str(i))\n        a_z.plot(ax, \"z\", \"Acceleration Z \" + str(i))\n    pyplot.ylabel(\"Acceleration (g)\")\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    if self.save_plots:\n        filename = self.get_filename(plot_suffix, \"accelerations\")\n        pyplot.savefig(filename)\n    pyplot.show()", "CodeBleu_score": 34.81840875966081}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\tfor index_one, index_two in enumerate(pose_indeces):\n        if index_one < index_two:\n            compare_two_xyz(self.pose_list[index_one], self.pose_list[index_two])\n\n", "CodeBleu_score": 19.510576613109126}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement compare_positions\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement the compare_positions function\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision_time in self.wrench:\n        if start_time <= collision_time <= end_time:\n            collision_times.append(collision_time)\n    return collision_times\n\n\n\n\n", "CodeBleu_score": 34.692306927427914}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None:\n            if start_time <= collision.time:\n                collision_times.append(collision.time)\n        elif end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 39.617578832002465}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 37.44896929207793}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n\n  // Compute the multiplier to convert the depth data to meters\n  float multiplier = 1000.0 / this->depth_scale;\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> data_vector_map(data,\n                                                                     width * height);\n\n  // Compute the RMS noise and the noise values\n  float rms_noise =\n      std::sqrt(this->noise_sigma * this->noise_sigma * multiplier * multiplier);\n  float noise = std::tan(this->noise_sigma * M_PI / 180.0) * multiplier;\n\n  // Apply the noise to the depth data\n  for (uint32_t i = 0; i < data_vector_map.size(); i++) {\n    if (this->InRange(data_vector_map(i))) {\n      data_vector_map(i) +=\n          multiplier *\n          (rms_noise *\n           (float)rand() / (float)RAND_MAX) *  // NOLINT(runtime/threadsafe_fn)\n          (float)rand() / (float)RAND_MAX;    // NOLINT(runtime/threadsafe_fn)\n      data_vector_map(i) +=\n          multiplier *\n          (noise * (float)rand() / (float)RAND_MAX -  // NOLINT(runtime/threadsafe_fn)\n           noise / 2.0);                             // NOLINT(runtime/threadsafe_fn)\n    } else {\n      data_vector_map(i) = 0.0;\n    }\n  }\n}", "CodeBleu_score": 40.73976796655158}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if the data pointer is null.\n  if (data == nullptr) {\n    return;\n  }\n  // Calculate the multiplier.\n  const float multiplier = 1.0f / (this->max_depth - this->min_depth);\n  // Map the data to an Eigen vector.\n  const Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> data_vector_map(\n      data, width * height);\n  // Compute the RMS noise.\n  const float rms_noise =\n      this->noise *\n      std::sqrt(this->dist * multiplier * (1.0f - multiplier) / width / height);\n  // Compute the noise values.\n  const Eigen::VectorXf noise =\n      (data_vector_map * 1000.0f).array().square() * rms_noise;\n  // For each pixel, add noise if the pixel value is in range, otherwise set the\n  // pixel to a bad point value.\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (this->InRange(data[i])) {\n      data[i] += noise(i);\n    } else {\n      data[i] = 0.0f;\n    }\n  }\n}", "CodeBleu_score": 57.135777884772885}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n  // Calculate multiplier\n  float multiplier = this->depth_units / (this->fx * this->baseline);\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> data_vector_map(data,\n                                                                     width * height);\n\n  // Compute RMS noise and noise values\n  float rms_noise = this->noise * multiplier;\n  float noise = rms_noise / sqrt(2.0);\n\n  // Apply noise to data\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (this->InRange(data_vector_map(i))) {\n      data_vector_map(i) += noise * tanf(data_vector_map(i) / multiplier) *\n                            (data_vector_map(i) * (data_vector_map(i) * 1000.0).array().square() -\n                             this->dist.array()).array().square().sqrt();\n    } else {\n      data_vector_map(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 56.27205020384727}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time.\n  ros::Time current_time = ros::Time::now();\n  // Convert the simulation time to ROS time.\n  current_time.sec = world_->SimTime().sec;\n  current_time.nsec = world_->SimTime().nsec;\n  // Write the trajectory message to the bag file.\n  bag_.write(bag_ns_ + \"/\" + bag_waypoint_topic_, current_time,\n             *trajectory_msg);\n}", "CodeBleu_score": 53.765435820431485}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\tros::Time sim_time = ros::Time(world_->SimTime().Double());\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, sim_time, *trajectory_msg);\n}", "CodeBleu_score": 48.11705671148137}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  ros::Time ros_time = ros::Time::now();\n  // Write the trajectory to the bag file\n  bag.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 46.26008155029197}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert simulation time to ROS time\n  ros::Time time_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities\n  mav_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.header.stamp = time_now;\n  rot_velocities_msg.header.frame_id = \"world\";\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n  // Iterate through the motor joints\n  for (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Get the rotational velocity\n    double rot_velocity = m->second->GetVelocity(0);\n\n    // Slow down the rotational velocity\n    rot_velocity = rot_velocity / rot_velocity_slowdown_;\n\n    // Assign the rotational velocity to the message\n    rot_velocities_msg.angular_velocities[m->second->GetScopedName()] = rot_velocity;\n  }\n\n  // Write the message to a bag file\n  motor_velocities_bag_.write(motor_topic_, time_now, rot_velocities_msg);\n}", "CodeBleu_score": 64.87407823569482}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert simulation time to ROS time\n  ros::Time time = ros::Time(now.sec, now.nsec);\n\n  // Prepare message\n  mav_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n  rot_velocities_msg.header.stamp = time;\n\n  // Iterate through joints\n  for (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Calculate slowed-down rotational velocities\n    double motor_velocity = m->second->GetVelocity(0);\n    double rot_velocity = motor_velocity / rotor_velocity_slowdown_;\n\n    // Assign to message\n    rot_velocities_msg.angular_velocities[m->second->GetIndex()] = rot_velocity;\n  }\n\n  // Write data to file\n  rot_velocities_bag_.write(motor_topic_, time, rot_velocities_msg);\n}", "CodeBleu_score": 64.53261036806333}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert simulation time to ROS time\n  ros::Time time_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare message for motor velocities\n  mav_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.header.stamp = time_now;\n  rot_velocities_msg.header.frame_id = \"actuators\";\n\n  // Iterate through the motor joints\n  for (auto m : motor_joints_) {\n    // Get the motor joint\n    physics::JointPtr joint = m->second;\n\n    // Get the rotational velocity\n    double rot_velocity = joint->GetVelocity(0);\n\n    // Slow down the rotational velocity\n    rot_velocity /= rotor_velocity_slowdown_sim_;\n\n    // Assign the rotational velocity to the message\n    rot_velocities_msg.angular_velocities.push_back(rot_velocity);\n  }\n\n  // Set the message timestamp\n  rot_velocities_msg.header.stamp = time_now;\n\n  // Write the data to the bag file\n  rot_velocities_bag_.write(motor_topic_, time_now, rot_velocities_msg);\n}", "CodeBleu_score": 50.798346635305414}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_printing_)\n    ROS_INFO(\"Got roll, pitch, yawrate, and thrust command\");\n\n  double roll_angle = NormalizedInputToAngle(aileron_,\n                                            roll_pitch_yawrate_thrust_msg->roll());\n  double pitch_angle = NormalizedInputToAngle(elevator_,\n                                             roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate = NormalizedInputToAngle(rudder_,\n                                          roll_pitch_yawrate_thrust_msg->yaw_rate());\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Set control surface deflections\n  aileron_.deflection = roll_angle;\n  elevator_.deflection = pitch_angle;\n  rudder_.deflection = yaw_rate;\n  throttle_ = throttle;\n}", "CodeBleu_score": 44.90321047843657}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_print_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert normalized input values to control surface angles.\n  double aileron_angle = NormalizedInputToAngle(aileron_,\n                                               roll_pitch_yawrate_thrust_msg->roll());\n  double elevator_angle = NormalizedInputToAngle(elevator_,\n                                                roll_pitch_yawrate_thrust_msg->pitch());\n  double rudder_angle = NormalizedInputToAngle(rudder_,\n                                              roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust().x;\n\n  // Set the control surface angles.\n  aileron_.control_surface_joint->SetAngle(0, aileron_angle);\n  elevator_.control_surface_joint->SetAngle(0, elevator_angle);\n  rudder_.control_surface_joint->SetAngle(0, rudder_angle);\n\n  // Set the throttle value.\n  propeller_.propeller_link->SetForce(ignition::math::Vector3d(0, 0,\n                                                              throttle * propeller_.max_force));\n}", "CodeBleu_score": 53.53801025696869}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_print_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert normalized input to control surface deflections.\n  double roll = NormalizedInputToAngle(ailerons_,\n                                      roll_pitch_yawrate_thrust_msg->roll());\n  double pitch = NormalizedInputToAngle(elevator_,\n                                       roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate = NormalizedInputToAngle(rudder_,\n                                          roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the control surface deflections.\n  ailerons_.control_surface->SetPosition(0, roll);\n  elevator_.control_surface->SetPosition(0, pitch);\n  rudder_.control_surface->SetPosition(0, yaw_rate);\n\n  // Set the throttle.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 58.73866963092459}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tif (!received_first_actuator_) {\n    // Listen to the first input reference from the MAV.\n    // This is done in order to properly initialize the input_offset_.\n    // This is a workaround for the fact that the very first reference\n    // message is often not correct.\n    // TODO: remove this workaround.\n    if (last_actuator_time_ > common::Time::Zero) {\n      double dt = (world_->SimTime() - last_actuator_time_).Double();\n      if (dt > 1.0) {\n        received_first_actuator_ = true;\n      }\n    }\n  }\n\n  // Check if there's data available to read.\n  struct pollfd fds[1];\n  fds[0].fd = _fd;\n  fds[0].events = POLLIN;\n  // Timeout in ms.\n  int ret = poll(fds, 1, _timeoutMs);\n\n  if (ret < 0) {\n    gzerr << \"poll error", "CodeBleu_score": 26.029932652088366}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tstruct timeval tv;\n  fd_set fds;\n  int ret;\n\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  FD_ZERO(&fds);\n  FD_SET(STDIN_FILENO, &fds);\n\n  ret = select(STDIN_FILENO + 1, &fds, NULL, NULL, &tv);\n\n  if (ret == -1) {\n    gzerr << \"Error in select() \" << strerror(errno) << \"\n\";\n  } else if (ret) {\n    uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n    ssize_t recv_len;\n    struct sockaddr_in srcaddr;\n    socklen_t addrlen = sizeof(srcaddr);\n\n    recv_len = recvfrom(\n        STDIN_FILENO, buf, MAVLINK_MAX_PACKET_LEN, 0,\n        (struct sockaddr*)&srcaddr, &addrlen);\n\n    if (recv_len > 0) {\n      // Reset the timeout for receiving\n      last_hil_message_time_ = world_->SimTime();\n\n      mavlink_message_t message;\n      mavlink_status_t status;\n\n      for (unsigned i = 0; i < recv_len; ++i) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &message, &status)) {\n          handle_message(&message);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 63.14218525020525}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tstruct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  // Initialize file descriptor set\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n\n  // Poll file descriptors\n  int ret = select(_fd + 1, &fds, nullptr, nullptr, &timeout);\n\n  if (ret == -1) {\n    gzerr << \"Failed to poll UDP socket\n\";\n  }\n\n  else if (ret > 0) {\n    if (FD_ISSET(_fd, &fds)) {\n      // Receive data from UDP socket\n      ssize_t recvlen = recvfrom(\n          _fd, recv_buf_, sizeof(recv_buf_), 0,\n          (struct sockaddr*)&srcaddr_, &srcaddr_len_);\n\n      if (recvlen > 0) {\n        // Handle message\n        mavlink_message_t msg;\n        mavlink_status_t status;\n\n        for (unsigned i = 0; i < recvlen; ++i) {\n          if (mavlink_parse_char(MAVLINK_COMM_0, recv_buf_[i], &msg, &status)) {\n            handle_message(&msg);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 66.66500426270537}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex_);\n  if (is_open_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 69.24387244151102}, {"code": "void GazeboMavlinkInterface::close() {\n\tboost::mutex::scoped_lock scoped_lock(mutex_);\n  if (is_open_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n    is_open_ = false;\n  }\n}", "CodeBleu_score": 65.5526303185864}, {"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex_);\n  if (is_open_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n    is_open_ = false;\n  }\n}", "CodeBleu_score": 67.23285106769647}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tignition::math::Vector3d p1, p2, v1, v2;\n    double x, y, z;\n    double x1, x2, y1, y2, z1, z2;\n\n    // Checks if the given position is out of bounds\n    if (position.X() < p1.X()) {\n        return v1;\n    } else if (position.X() > p2.X()) {\n        return v2;\n    }\n\n    // Calculates the interpolated value between two points\n    x1 = p1.X();\n    x2 = p2.X();\n    x = position.X();\n\n    y1 = p1.Y();\n    y2 = p2.Y();\n    y = position.Y();\n\n    z1 = p1.Z();\n    z2 = p2.Z();\n    z = position.Z();\n\n    v1 = ignition::math::Vector3d(x1, y1, z1);\n    v2 = ignition::math::Vector3d(x2, y2, z2);\n\n    return ignition::math::Vector3d((y - y1) / (y2 - y1) * (v2.X() - v1.X()) + v1.X(), (z - z1) / (z2 - z1) * (v2.Y() - v1.Y()) + v1.Y(), (x - x1) / (x2 - x1) * (v2.Z() - v1.Z()) + v1.Z());\n}", "CodeBleu_score": 35.81625710751277}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t// Calculate the interpolation factor\n    double interpolationFactor = (position - position1) / (position2 - position1);\n\n    // Calculate the interpolated value\n    ignition::math::Vector3d interpolatedValue = value1 * (1 - interpolationFactor) + value2 * interpolationFactor;\n\n    // Return the interpolated value\n    return interpolatedValue;\n}", "CodeBleu_score": 30.394629688959675}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x, y, z;\n\n    if (position.X() < x_values[0]) {\n        x = 0;\n    }\n    else if (position.X() > x_values[x_values.size() - 1]) {\n        x = 0;\n    }\n    else {\n        for (int i = 0; i < x_values.size() - 1; i++) {\n            if (position.X() >= x_values[i] && position.X() <= x_values[i + 1]) {\n                x = y_values[i] + (position.X() - x_values[i]) * (y_values[i + 1] - y_values[i]) / (x_values[i + 1] - x_values[i]);\n                break;\n            }\n        }\n    }\n\n    if (position.Y() < y_values[0]) {\n        y = 0;\n    }\n    else if (position.Y() > y_values[y_values.size() - 1]) {\n        y = 0;\n    }\n    else {\n        for (int i = 0; i < y_values.size() - 1; i++) {\n            if (position.Y() >= y_values[i] && position.Y() <= y_values[i + 1]) {\n                y = y_values[i] + (position.Y() - y_values[i]) * (y_values[i + 1] - y_values[i]) / (y_values[i + 1] - y_values[i]);\n                break;\n            }\n        }\n    }\n\n    if (position.Z() < z_values[0]) {\n        z = 0;\n    }\n    else if (position.Z() > z_values[z_values.size() - 1]) {\n        z = 0;\n    }\n    else {\n        for (int i = 0; i < z_values.size() - 1; i++) {\n            if (position.Z() >= z_values[i] && position.Z() <= z_values", "CodeBleu_score": 37.26926313537754}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\tif (this->dataPtr->loop)\n  {\n    // Wrap time to [0, duration].\n    this->dataPtr->timePos = std::fmod(_time, this->dataPtr->length);\n    if (this->dataPtr->timePos < 0)\n      this->dataPtr->timePos += this->dataPtr->length;\n  }\n  else\n  {\n    // Clamp time to [0, duration].\n    this->dataPtr->timePos = std::max(0.0, _time);\n    this->dataPtr->timePos = std::min(this->dataPtr->timePos,\n        this->dataPtr->length);\n  }\n\n  this->dataPtr->update = true;\n}", "CodeBleu_score": 49.918327615953544}, {"code": "void Animation::SetTime(double _time){\n\t// Set the time\n  this->dataPtr->timePos = _time;\n\n  // Wrap time if looping\n  if (this->dataPtr->loop)\n    this->dataPtr->timePos = fmod(this->dataPtr->timePos, this->Length());\n\n  // Clamp time if not looping\n  if (!this->dataPtr->loop)\n    this->dataPtr->timePos = ignition::math::clamp(this->dataPtr->timePos, 0.0,\n        this->Length());\n}", "CodeBleu_score": 36.78465994189056}, {"code": "void Animation::SetTime(double _time){\n\tif (!this->dataPtr->valid)\n    return;\n\n  this->dataPtr->timePos = _time;\n  if (this->dataPtr->loop) {\n    this->dataPtr->timePos =\n      fmod(this->dataPtr->timePos, this->Length());\n  } else {\n    if (this->dataPtr->timePos < 0)\n      this->dataPtr->timePos = 0;\n    else if (this->dataPtr->timePos > this->Length())\n      this->dataPtr->timePos = this->Length();\n  }\n  this->dataPtr->update = true;\n}", "CodeBleu_score": 45.889410015118315}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    target = self.construct_target(x=self.local_position.pose.position.x,\n                                   y=self.local_position.pose.position.y,\n                                   z=self.local_position.pose.position.z,\n                                   yaw=self.local_position.pose.orientation.yaw)\n    self.set_position_target_local_ned(target)\n    print(\"Vehicle type:\", self.vehicle_type, \"Vehicle ID:\", self.vehicle_id, \"Flight mode:\", self.flight_mode)\n\n", "CodeBleu_score": 53.572254802645226}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.local_position[0], y=self.local_position[1], z=self.local_position[2], yaw=self.local_position[3])\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 62.59644844934552}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.local_position.pose.position.x, y=self.local_position.pose.position.y, z=self.local_position.pose.position.z, yaw=self.local_position.pose.orientation.yaw)\n    self.set_position_target_local_ned(target_raw_pose)\n    print(self.vehicle_type + \" \" + self.vehicle_id + \" \" + self.flight_mode)\n\n", "CodeBleu_score": 61.46806355740555}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flight_mode_service(self.flight_mode)\n        if self.flight_mode == self.flight_mode_service.response.flight_mode:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode+\": FAILED\")\n            return False\n\n\n", "CodeBleu_score": 51.86799820890482}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":Flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 55.99734141397714}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\"%e)\n            return False", "CodeBleu_score": 52.77513418483326}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\tif (x > 0.02 or x < -0.02 or y > 0.02 or y < -0.02 or z > 0.02 or z < -0.02 or w > 0.005 or w < -0.005) and self.hover_flag == 1:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    elif (x <= 0.02 and x >= -0.02 and y <= 0.02 and y >= -0.02 and z <= 0.02 and z >= -0.02 and w <= 0.005 and w >= -0.005) and self.hover_flag == 0:\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 41.48148034551819}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    elif (self.hover_flag == 1 and self.flight_mode != \"HOVER\"):\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover()\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)", "CodeBleu_score": 51.70120746355271}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.flight_mode == \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.set_mode(\"OFFBOARD\")\n    else:\n        if abs(x) <= 0.02 and abs(y) <= 0.02 and abs(z) <= 0.02 and abs(w) <= 0.005:\n            self.hover_flag = 1\n            self.set_mode(\"HOVER\")\n            self.hover()\n\n", "CodeBleu_score": 60.65138960167747}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        yaw = q.yaw()\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw()\n    return yaw", "CodeBleu_score": 42.55278739119881}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n", "CodeBleu_score": 26.83026792740599}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 16.806809161752323}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target(x=self.local_position.pose.position.x,\n                                            y=self.local_position.pose.position.y,\n                                            z=self.local_position.pose.position.z,\n                                            yaw=self.local_position.pose.orientation.yaw)\n\n    self.target_motion_pub.publish(target_raw_pose)\n    print(self.vehicle_type, self.vehicle_id, \"hovering\")\n\n", "CodeBleu_score": 40.70966071108474}, {"code": "def hover(self)\n\tself.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target(self.local_position.pose.position.x, self.local_position.pose.position.y, self.local_position.pose.position.z, 0, 0, 0, 0, 0, 0, self.local_position.pose.orientation.yaw, 0)\n\n    self.set_position_target_local_ned(target_raw_pose)\n\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", self.flight_mode)", "CodeBleu_score": 35.760066163291384}, {"code": "def hover(self)\n\tself.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target(x=0, y=0, z=0, yaw=self.yaw)\n\n    self.set_target(target_raw_pose)\n\n    print(\"Vehicle Type: {}, Vehicle ID: {}, Flight Mode: {}\".format(self.vehicle_type, self.vehicle_id, self.flight_mode))\n\n", "CodeBleu_score": 32.17164817219872}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.vehicle_type + '_' + self.vehicle_id, self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException:\n            print(\"Failed to switch flight mode.\")\n            return False", "CodeBleu_score": 53.25172667437455}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False", "CodeBleu_score": 51.837409943558875}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Failed to switch to \" + self.flight_mode)\n            return False", "CodeBleu_score": 59.17313252593826}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.26923076876874}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()", "CodeBleu_score": 55.26923076876874}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()", "CodeBleu_score": 55.26923076876874}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t# If the message index matches the UAV ID, set the local_pose to the message.\n    if msg.index == i:\n        self.local_pose[i] = msg\n\n    # Depending on the GCS command, update the takeoff_target_pose and hover_target_pose.\n    if self.gcs_command[i] == \"takeoff\":\n        self.takeoff_target_pose[i] = self.local_pose[i]\n    elif self.gcs_command[i] == \"hover\":\n        self.hover_target_pose[i] = self.local_pose[i]\n\n    # Update the global_pose for the UAV, applying a bias to the position coordinates.\n    self.global_pose[i].header = self.local_pose[i].header\n    self.global_pose[i].pose.position.x = self.local_pose[i].pose.position.x + self.bias[i][0]\n    self.global_pose[i].pose.position.y = self.local_pose[i].pose.position.y + self.bias[i][1]\n    self.global_pose[i].pose.position.z = self.local_pose[i].pose.position.z + self.bias[i][2]\n    self.global_pose[i].pose.orientation = self.local_pose[i].pose.orientation\n\n\n\n\n", "CodeBleu_score": 31.50847773438581}, {"code": "def local_pose_callback(self, msg, i)\n\tif msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return\n    if msg.pose.pose.position.x == 0 and msg.pose.pose.position.y == 0:\n        return", "CodeBleu_score": 12.531846751370987}, {"code": "def local_pose_callback(self, msg, i)\n\t# Update local pose\n    if msg.id == i:\n        self.local_pose[i] = msg\n\n    # Update takeoff target pose\n    if msg.id == i and self.gcs_command[i] == 1:\n        self.takeoff_target_pose[i] = msg\n\n    # Update hover target pose\n    if msg.id == i and self.gcs_command[i] == 2:\n        self.hover_target_pose[i] = msg\n\n    # Update global pose\n    if msg.id == i:\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += self.global_pose_offset[i][0]\n        self.global_pose[i].pose.position.y += self.global_pose_offset[i][1]\n        self.global_pose[i].pose.position.z += self.global_pose_offset[i][2]\n\n\n\n\n", "CodeBleu_score": 38.95410932293563}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n\n\n\n\n", "CodeBleu_score": 61.889133687930844}, {"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.889133687930844}, {"code": "def takeoff_detection(self)\n\tif self.local_position[2] > 0.2 and self.arming_state.armed:\n        return True\n    else:\n        return False\n\n\n\n\n\n", "CodeBleu_score": 65.61048771074441}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t# Calculate the distance between each pair of UAVs in the original formation\n    # and the changed formation\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n    # Adjust the distances by subtracting them from 50\n    dist_matrix -= 50\n    # Convert the distances to integers\n    dist_matrix = dist_matrix.astype(int)\n    return dist_matrix", "CodeBleu_score": 25.78219330473542}, {"code": "def build_graph(self, orig_formation, change_formation)\n\torig_formation_points = np.array(orig_formation)\n    change_formation_points = np.array(change_formation)\n\n    orig_formation_distances = np.linalg.norm(orig_formation_points - orig_formation_points[:, None], axis=2)\n    change_formation_distances = np.linalg.norm(change_formation_points - change_formation_points[:, None], axis=2)\n\n    orig_formation_distances = np.int32(np.around(50 - orig_formation_distances))\n    change_formation_distances = np.int32(np.around(50 - change_formation_distances))\n\n    return orig_formation_distances, change_formation_distances\n\n\n\n\n\n", "CodeBleu_score": 11.165193336344501}, {"code": "def build_graph(self, orig_formation, change_formation)\n\torig_coords = self.get_coords(orig_formation)\n    change_coords = self.get_coords(change_formation)\n    dist_matrix = []\n    for i in range(len(orig_coords)):\n        row = []\n        for j in range(len(change_coords)):\n            row.append(int(50 - norm(orig_coords[i] - change_coords[j])))\n        dist_matrix.append(row)\n    return dist_matrix\n\n", "CodeBleu_score": 20.5933265132884}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False", "CodeBleu_score": 53.10314008215627}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\tself.match_right = [-1] * len(self.label_right)\n    for i in range(len(self.label_left)):\n        self.slack_right = [np.inf] * len(self.label_right)\n        while True:\n            self.visit_left = [False] * len(self.label_left)\n            self.visit_right = [False] * len(self.label_right)\n            if self.find_path(i):\n                break\n            else:\n                delta = np.inf\n                for j in range(len(self.label_right)):\n                    if not self.visit_right[j]:\n                        delta = min(delta, self.slack_right[j])\n                for k in range(len(self.label_left)):\n                    self.label_left[k] -= delta\n                for j in range(len(self.label_right)):\n                    self.label_right[j] += delta\n    return self.match_right", "CodeBleu_score": 39.33165185553081}, {"code": "def KM(self)\n\tfor i in range(len(self.adj_matrix)):\n        self.visit_left = [False for i in range(len(self.adj_matrix))]\n        self.visit_right = [False for i in range(len(self.adj_matrix[0]))]\n        self.slack_right = [0 for i in range(len(self.adj_matrix[0]))]\n        self.find_path(i)\n        if all(self.match_right):\n            return self.match_right\n        delta = min([self.slack_right[j] for j in range(len(self.adj_matrix[0])) if not self.visit_right[j]])\n        for i in range(len(self.adj_matrix)):\n            if self.visit_left[i]:\n                self.label_left[i] -= delta\n        for j in range(len(self.adj_matrix[0])):\n            if self.visit_right[j]:\n                self.label_right[j] += delta\n            else:\n                self.slack_right[j] -= delta", "CodeBleu_score": 33.775641339574804}, {"code": "def KM(self)\n\tfor i in range(self.n_left):\n        self.visit_left = [False] * self.n_left\n        self.visit_right = [False] * self.n_right\n        self.slack_right = [float('inf')] * self.n_right\n        if not self.find_path(i):\n            delta = min(self.slack_right)\n            self.label_left += delta\n            self.label_right -= delta\n    return self.match_right", "CodeBleu_score": 17.98030657447518}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\thsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)", "CodeBleu_score": 27.625016226204384}, {"code": "def yellow_dectection(image)\n\t# Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper boundaries for the yellow color\n    # Yellow is HSV color (0, 100, 100)\n    # HSV boundaries for yellow are:\n    # H: 20-38\n    # S: 100\n    # V: 100\n    lower = np.array([20, 100, 100])\n    upper = np.array([38, 255, 255])\n\n    # Create the mask\n    mask = cv2.inRange(hsv, lower, upper)\n\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 37.38764091244936}, {"code": "def yellow_dectection(image)\n\t#convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    #define range of yellow color in HSV\n    lower_yellow = np.array([20,100,100])\n    upper_yellow = np.array([30,255,255])\n    #Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    #Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask= mask)\n    return res\n", "CodeBleu_score": 28.41382097252164}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\tstd::map<uint64_t, StandaloneTagDescription>::iterator it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN_THROTTLE(10.0, \"TagDetector: Standalone tag description with ID %llu not found.\", id);\n    }\n    return false;\n  }\n  descriptionContainer = it->second;\n  return true;\n}", "CodeBleu_score": 48.308505609958694}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tstd::map<std::string, StandaloneTagDescription>::const_iterator it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN_THROTTLE(10.0, \"Standalone tag description with ID '%s' not found.\", id.c_str());\n    }\n    return false;\n  }\n  descriptionContainer = it->second;\n  return true;\n}", "CodeBleu_score": 44.816794542233495}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tStandaloneTagDescription descriptionContainer;\n\tif (standalone_tag_descriptions_.find(tag_id) != standalone_tag_descriptions_.end()) {\n\t\tdescriptionContainer = standalone_tag_descriptions_[tag_id];\n\t\treturn true;\n\t}\n\telse {\n\t\tif (printWarning) {\n\t\t\tROS_WARN_THROTTLE(10, \"Standalone tag description with ID %d not found.\", tag_id);\n\t\t}\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 35.28163796315271}]}
