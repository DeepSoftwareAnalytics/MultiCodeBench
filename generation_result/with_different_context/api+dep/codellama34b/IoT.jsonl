{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\twhile (next_desc->bDescriptorType != USB_DESC_TYPE_ENDPOINT) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t *) next_desc + next_desc->bLength);\n\t\tif (next_desc->bLength == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 43.97905130710464}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\twhile (next_desc->bDescriptorType != USB_DESC_TYPE_END_OF_CONF) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc\n\t\t\t\t+ next_desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 42.17325811710838}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\n\twhile (next_desc->bDescriptorType != USB_DESC_TYPE_ENDPOINT) {\n\t\tif (next_desc->bDescriptorType == desc_id)\n\t\t\treturn next_desc;\n\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t *) next_desc + next_desc->bLength);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 41.34477580281998}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t *ptr = (uint8_t *)udc_config_desc;\n\tptr += udc_config_desc->bLength;\n\tuint8_t iface_count = 0;\n\tuint8_t setting_count = 0;\n\n\twhile (ptr[0] != USB_DT_END) {\n\t\tif (ptr[0] == USB_DT_INTERFACE) {\n\t\t\tif (ptr[2] == iface_num) {\n\t\t\t\tif (setting_count == setting_num) {\n\t\t\t\t\tudc_iface_desc = (struct usb_interface_descriptor *)ptr;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tsetting_count++;\n\t\t\t}\n\t\t\tiface_count++;\n\t\t}\n\t\tptr += ptr[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 41.22652886020616}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tif (!udc_device.curr_config) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_device.curr_config->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t *curr_desc = (uint8_t *) udc_device.curr_config;\n\tuint8_t *end_desc = (uint8_t *) udc_device.curr_config + udc_device.curr_config->wTotalLength;\n\tuint8_t iface_num_curr = 0;\n\tuint8_t setting_num_curr = 0;\n\n\twhile (curr_desc < end_desc) {\n\t\tif (curr_desc[0] == USB_DT_INTERFACE) {\n\t\t\tiface_num_curr = curr_desc[2];\n\t\t\tsetting_num_curr = curr_desc[3];\n\t\t\tif (iface_num_curr == iface_num && setting_num_curr == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcurr_desc += curr_desc[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 39.44917982834452}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t// Verify that there is a valid configuration\n\tif (udc_curr_config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\t// Verify that the interface number is within bounds\n\tif (iface_num >= udc_curr_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor, and check each one to see if it matches the specified interface number and setting number\n\tuint8_t *desc_ptr = (uint8_t *)udc_curr_config_desc;\n\tuint8_t *desc_end = desc_ptr + udc_curr_config_desc->wTotalLength;\n\twhile (desc_ptr < desc_end) {\n\n\t\t// Check the descriptor type\n\t\tif (*desc_ptr == USB_DT_INTERFACE) {\n\n\t\t\t// Check if the interface number and setting number match the specified values\n\t\t\tif (((usb_interface_desc_t *)desc_ptr)->bInterfaceNumber == iface_num &&\n\t\t\t\t((usb_interface_desc_t *)desc_ptr)->bAlternateSetting == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\t\t// Move to the next descriptor\n\t\tdesc_ptr += ((usb_desc_t *)desc_ptr)->bLength;\n\n\t}\n\n\t// Return false if no matching interface descriptor was found\n\treturn false;\n\n}", "CodeBleu_score": 40.253087701930404}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\tif (udd_g_ctrlreq.req.wLength != 2) {\n\t\tudd_ep_control_stall();\n\t\treturn false;\n\t}\n\t// Fill status of endpoint\n\tudd_g_ctrlreq.payload[0] = 0;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex & USB_REQ_RECIPIENT_ENDPOINT)) {\n\t\tudd_g_ctrlreq.payload[0] = 1;\n\t}\n\tudd_g_ctrlreq.payload[1] = 0;\n\t// Send status\n\tudd_set_setup_payload(udd_g_ctrlreq.payload, 2);\n\treturn true;\n}", "CodeBleu_score": 34.144333919085035}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tif (udd_g_ctrlreq.req.wLength != 2) {\n\t\treturn false;\n\t}\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex & 0x7F)) {\n\t\tudd_g_ctrlreq.payload[0] = 1;\n\t} else {\n\t\tudd_g_ctrlreq.payload[0] = 0;\n\t}\n\tudd_g_ctrlreq.payload[1] = 0;\n\tudd_g_ctrlreq.req.wLength = 2;\n\treturn true;\n}", "CodeBleu_score": 36.4788636842588}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tif (udd_g_ctrlreq.req.wLength != 2) {\n\t\treturn false;\n\t}\n\tuint8_t ep_num = udd_g_ctrlreq.req.wIndex & USB_EP_ADDR_MASK;\n\tif (ep_num == 0) {\n\t\treturn false;\n\t}\n\tuint8_t ep_status = 0;\n\tif (udd_ep_is_halted(ep_num)) {\n\t\tep_status = 1;\n\t}\n\tudd_set_setup_payload(\n\t\t\t(uint8_t *) & ep_status, 2);\n\treturn true;\n}", "CodeBleu_score": 45.57844114755968}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\tbool status;\n\tuint8_t iface_num;\n\n\t// Check if the device is in a configured state\n\tif (USB_CONFIGURED != udc_device.state) {\n\t\tudd_stall_data(true);\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is valid\n\tiface_num = udc_req.wIndex & 0xFF;\n\tif (iface_num >= udc_num_interface) {\n\t\tudd_stall_data(true);\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\tudd_stall_data(true);\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(iface_num, udc_ptr_iface->bAlternateSetting)) {\n\t\tudd_stall_data(true);\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\tstatus = udc_ptr_iface->udi_api->setup(&udc_req);\n\tif (!status) {\n\t\tudd_stall_data(true);\n\t}\n\treturn status;\n}", "CodeBleu_score": 57.54335493364409}, {"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num = udc_setup_received.wIndex;\n\tuint8_t setting_num = udc_setup_received.wValue;\n\n\t// Check if device is configured\n\tif (USB_CONFIGURED != udc_device_state) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the request to the corresponding UDI handler\n\treturn udc_ptr_iface->udi_api->setup(&udc_setup_received);\n}", "CodeBleu_score": 54.83785303750195}, {"code": "static bool udc_req_iface(void){\n\t// Check the device is in configured state\n\tif (USB_ATTACHED != udc_device.state) {\n\t\treturn false;\n\t}\n\n\t// Check the interface number\n\tif (udc_setup_received.wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(udc_setup_received.wIndex, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(udc_setup_received.wIndex, udc_setup_received.wValue)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\treturn udi_api->setup();\n}", "CodeBleu_score": 41.704202179891205}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t// Initialize internal values\n  udi_msc_b_cbw_invalid_field = false;\n  udi_msc_b_sense_key = 0;\n  udi_msc_b_sense_code = 0;\n  udi_msc_b_sense_qualifier = 0;\n  udi_msc_b_thirteen_case_check = false;\n  udi_msc_b_read_run = false;\n  udi_msc_b_write_run = false;\n  udi_msc_b_abort_trans = false;\n  udi_msc_b_abort_req = false;\n  udi_msc_b_inquiry_run = false;\n  udi_msc_b_mode_sense_10_run = false;\n  udi_msc_b_mode_sense_6_run = false;\n  udi_msc_b_request_sense_run = false;\n  udi_msc_b_start_request_sense_run = false;\n  udi_msc_b_read_capacity_10_run = false;\n  udi_msc_b_read_format_capacity_run = false;\n  udi_msc_b_test_unit_ready_run = false;\n  udi_msc_b_prevent_allow_medium_removal_run = false;\n  udi_msc_b_read_10_run = false;\n  udi_msc_b_write_10_run = false;\n  udi_msc_b_mode_sense_6_run = false;\n  udi_msc_b_mode_sense_10_run = false;\n  udi_msc_b_inquiry_run = false;\n  udi_msc_b_request_sense_run = false;\n  udi_msc_b_read_capacity_10_run = false;\n  udi_msc_b_read_format_capacity_run = false", "CodeBleu_score": 32.929339963395236}, {"code": "bool udi_msc_enable(void){\n\t// Initialize internal values\n  udi_msc_b_cbw_invalid_field = false;\n  udi_msc_b_sense_key = UDI_MSC_SENSE_KEY_NO_SENSE;\n  udi_msc_b_sense_code = UDI_MSC_ASC_NO_ADDITIONAL_SENSE_INFORMATION;\n  udi_msc_b_sense_lun = 0;\n  udi_msc_b_sense_key_asc_res = 0;\n  udi_msc_b_sense_key_valid = false;\n  udi_msc_b_cbw_invalid_lun = false;\n  udi_msc_b_state = UDI_MSC_IDLE;\n  udi_msc_b_trans_req = false;\n  udi_msc_b_trans_running = false;\n  udi_msc_b_trans_status = UDI_MSC_TRANS_IDLE;\n  udi_msc_b_trans_lun = 0;\n  udi_msc_b_trans_size = 0;\n  udi_msc_b_trans_addr = 0;\n  udi_msc_b_trans_block = 0;\n  udi_msc_b_trans_nb_block = 0;\n  udi_msc_b_trans_flags = 0;\n  udi_msc_b_trans_dir = UDI_MSC_TRANS_DIR_IN;\n  udi_msc_b_cbw_signature = 0;\n  udi_msc_b_cbw_tag = 0;\n  udi_msc_b_cbw_data_trans_length = 0;\n  udi_msc_b_cbw_flags = 0;\n  udi_msc_b_cbw_lun = 0;\n  udi_msc_b_cbw_cdb_length = 0;\n  udi_msc_b_", "CodeBleu_score": 31.583188493967995}, {"code": "bool udi_msc_enable(void){\n\tudi_msc_b_cbw_invalid_field = false;\n  udi_msc_b_sense_key = 0;\n  udi_msc_b_sense_code = 0;\n  udi_msc_b_sense_qualifier = 0;\n  udi_msc_b_state = UDI_MSC_IDLE;\n  udi_msc_b_trans_req = false;\n  udi_msc_b_trans_status = UDI_MSC_TRANS_IDLE;\n  udi_msc_b_trans_value = 0;\n  udi_msc_b_trans_length = 0;\n  udi_msc_b_trans_load = false;\n  udi_msc_b_trans_direction = TRAFFIC_NOT_INITIALIZED;\n  udi_msc_b_cbw_status = UDI_MSC_CBW_IDLE;\n  udi_msc_b_sense_status = UDI_MSC_SENSE_IDLE;\n  udi_msc_b_data_trans_direction = TRAFFIC_NOT_INITIALIZED;\n  udi_msc_b_data_run_state = UDI_MSC_DATA_IDLE;\n  udi_msc_b_data_run_nb_trans = 0;\n  udi_msc_b_data_run_nb_byte = 0;\n  udi_msc_b_data_run_nb_byte_done = 0;\n  udi_msc_b_data_run_nb_byte_under = 0;\n  udi_msc_b_data_run_nb_byte_over = 0;\n  udi_msc_b_data_run_nb_byte_copied = 0;\n  udi_msc_b_data_run_over_under_run = false;\n  udi_msc_b_data_run_over_run = false;\n  udi_msc_b_data_run", "CodeBleu_score": 37.2517194652618}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDD_EP_TRANSFER_OK != status) {\n    // Wait a reset\n    udi_msc_reset_all();\n    return;\n  }\n  // Update sense data\n  udi_msc_clear_sense();\n  // Update CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  udi_msc_csw_process();\n}", "CodeBleu_score": 71.57502283970423}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDD_EP_TRANSFER_OK != status) {\n    // Wait a reset recovery\n    udi_msc_reset_all();\n    return;\n  }\n  // Update sense data\n  udi_msc_clear_sense();\n  // Update CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  udi_msc_csw_process();\n}", "CodeBleu_score": 71.57502283970423}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep);\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Wait a reset recovery\n    udi_msc_reset_all();\n    return;\n  }\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  udi_msc_csw_process();\n}", "CodeBleu_score": 80.34105342408884}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t// Check if data residue is not zero\n  if (udi_msc_csw.data_residue != 0) {\n    // Stall next request\n    udd_ep_set_halt(UDI_MSC_EP_IN);\n    udd_ep_set_halt(UDI_MSC_EP_OUT);\n  }\n\n  // Prepare CSW\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.data_residue = cpu_to_le32(udi_msc_csw.data_residue);\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 54.19458383778254}, {"code": "static void udi_msc_csw_process(void){\n\t// Fill CSW\n  udi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_data_trans_size);\n  udi_msc_csw.bCSWStatus = udi_msc_sense.bSenseKey;\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 55.560490095521686}, {"code": "static void udi_msc_csw_process(void){\n\t// Check if a stall has been requested\n  if (udi_msc_csw.bCSWStatus == UDI_MSC_CSW_STALL) {\n    // Stall the IN endpoint\n    udd_ep_set_halt(UDI_MSC_EP_IN);\n    // Stall the OUT endpoint\n    udd_ep_set_halt(UDI_MSC_EP_OUT);\n  }\n  // Check if a non-zero data residue is present\n  if (udi_msc_csw.dCSWDataResidue != 0) {\n    // Stall the appropriate endpoint\n    if (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION) {\n      // Stall the IN endpoint\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    } else {\n      // Stall the OUT endpoint\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    }\n  }\n  // Set the tag\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  // Convert the data residue to little-endian format\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n  // Send the CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 74.35381772067913}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n        // Cancel any pending resets\n        cancelReset();\n    } else {\n        // Check if the DTR rate is 1200\n        if (usb_cdc_line_rates[port] == 1200) {\n            // Schedule a reset\n            initiateReset();\n        }\n    }\n}", "CodeBleu_score": 31.805407251260544}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t// Update DTR status\n    usb_cdc_dtr_prev[port] = usb_cdc_dtr[port];\n    usb_cdc_dtr[port] = b_enable;\n\n    // Check if DTR rate is 1200\n    if (usb_cdc_dtr_rate[port] == 1200) {\n        // Check if DTR is disabled\n        if (b_enable == false) {\n            // Schedule a delayed system reset\n            initiateReset();\n        }\n        else {\n            // Cancel any scheduled reset\n            cancelReset();\n        }\n    }\n}", "CodeBleu_score": 47.01537588274151}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tstatic uint8_t dtr_rates[USB_NUM_PORTS];\n    static uint8_t dtr_rates_index[USB_NUM_PORTS];\n    static uint8_t dtr_rates_count[USB_NUM_PORTS];\n\n    if (b_enable) {\n        dtr_rates_count[port] = 0;\n    } else {\n        dtr_rates[port][dtr_rates_index[port]] = dtr_rates_count[port];\n        dtr_rates_count[port] = 0;\n        dtr_rates_index[port]++;\n        if (dtr_rates_index[port] == 10) {\n            dtr_rates_index[port] = 0;\n        }\n    }\n}", "CodeBleu_score": 33.09700477060435}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\tif (USB_SetupRequest.bmRequestType.Type == USB_SETUP_REQUEST_TYPE_VENDOR) {\n        if (USB_SetupRequest.bRequest == 0x04) {\n            if (USB_SetupRequest.wValue.Val == 0x0000) {\n                usb_ep0_tx_ptr = (uint8_t*) &USB_DeviceDescriptor;\n                usb_ep0_tx_data_size = sizeof(USB_DeviceDescriptor);\n                return true;\n            } else if (USB_SetupRequest.wValue.Val == 0x0001) {\n                usb_ep0_tx_ptr = (uint8_t*) &USB_ConfigurationDescriptor;\n                usb_ep0_tx_data_size = sizeof(USB_ConfigurationDescriptor);\n                return true;\n            } else if (USB_SetupRequest.wValue.Val == 0x0002) {\n                usb_ep0_tx_ptr = (uint8_t*) &USB_StringDescriptor_MSFT;\n                usb_ep0_tx_data_size = sizeof(USB_StringDescriptor_MSFT);\n                return true;\n            } else if (USB_SetupRequest.wValue.Val == 0x0003) {\n                usb_ep0_tx_ptr = (uint8_t*) &USB_StringDescriptor_MSFT_ExtendedCompatID;\n                usb_ep0_tx_data_size = sizeof(USB_StringDescriptor_MSFT_ExtendedCompatID);\n                return true;\n            } else if (USB_SetupRequest.wValue.Val == 0x0004) {\n                usb_ep0_tx_ptr = (uint8_t*) &USB_StringDescriptor_MSFT_ExtendedProperties;\n                usb_ep0_tx_data_size = sizeof(USB_StringDescriptor_MSFT_ExtendedProperties);\n                return true;\n            }\n        } else if (USB_SetupRequest.bRequest == 0x05) {\n            if (USB_SetupRequest.wValue.Val", "CodeBleu_score": 24.13056925421285}, {"code": "bool usb_task_other_requests(void){\n\tif (USB_bmRequestType == 0x21) {\n        if (USB_bRequest == 0x04) {\n            USB_payload_length = sizeof(USB_extended_properties_descriptor);\n            USB_payload_ptr = (uint8_t *) &USB_extended_properties_descriptor;\n            return true;\n        }\n        if (USB_bRequest == 0x05) {\n            USB_payload_length = sizeof(USB_microsoft_compatible_id_descriptor);\n            USB_payload_ptr = (uint8_t *) &USB_microsoft_compatible_id_descriptor;\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 20.92252134840291}, {"code": "bool usb_task_other_requests(void){\n\tif (usb_setup.bmRequestType == 0x21) {\n        if (usb_setup.wIndex == 0x04) {\n            usb_ep0_tx_ptr = &usb_string_desc_MS_CompatibleID[0];\n            usb_ep0_tx_len = usb_string_desc_MS_CompatibleID[0];\n            return true;\n        } else if (usb_setup.wIndex == 0x05) {\n            usb_ep0_tx_ptr = &usb_string_desc_MS_ExtendedProperties[0];\n            usb_ep0_tx_len = usb_string_desc_MS_ExtendedProperties[0];\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 14.307208842143094}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tif (nbyte == 0) {\n        return;\n    }\n\n    uint8_t i;\n    for (i = 0; i < nbyte - 1; i++) {\n        spiRec(buf + i);\n    }\n\n    SPI_PCS = 0;\n    SPI_DATA = 0xff;\n    while (!SPI_IF);\n    SPI_IF = 0;\n    buf[i] = SPI_DATA;\n    SPI_PCS = 1;\n}", "CodeBleu_score": 46.63123492472532}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tif (nbyte == 0) return;\n\t\n\twhile (nbyte > 1) {\n\t\tspiRec(buf++);\n\t\tnbyte--;\n\t}\n\t\n\tspiRec(buf);\n}", "CodeBleu_score": 27.02278580518306}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\tuint8_t dummy;\n\n\tif (nbyte == 0)\n\t\treturn;\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tdummy = 0xFF;\n\t\tspiSend(dummy);\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 48.88125038911774}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n\n    /* Get the address of the relocated interrupt vector table */\n    pfnISR_Handler *relocated_vector_table = get_relocated_table_addr();\n\n    /* Disable global interrupts to ensure atomic operation */\n    CRITICAL_SECTION_START\n\n    /* Get the current handler for the specified IRQ */\n    oldHandler = relocated_vector_table[irq];\n\n    /* Replace it with the new handler */\n    relocated_vector_table[irq] = newHandler;\n\n    /* Re-enable global interrupts */\n    CRITICAL_SECTION_END\n\n    /* Return the original ISR handler */\n    return oldHandler;\n}", "CodeBleu_score": 54.28653394843863}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n    CRITICAL_SECTION_START\n    get_relocated_table_addr\n    oldHandler = (pfnISR_Handler) relocated_table[irq];\n    relocated_table[irq] = (uint32_t) newHandler;\n    CRITICAL_SECTION_END\n    return oldHandler;\n}", "CodeBleu_score": 47.13069860352505}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n\n    CRITICAL_SECTION_START\n    get_relocated_table_addr\n    oldHandler = relocated_table[irq];\n    relocated_table[irq] = newHandler;\n    CRITICAL_SECTION_END\n\n    return oldHandler;\n}", "CodeBleu_score": 48.43957251726447}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\tif (udi_cdc_is_rx_ready())\n    return udi_cdc_getc();\n  else\n    return -1;\n}", "CodeBleu_score": 8.288762344246198}, {"code": "int MarlinSerialUSB::peek(){\n\tint c;\n  if (udi_cdc_is_rx_ready()) {\n    c = udi_cdc_getc();\n    if (emergency_parser.enabled) emergency_parser.update(c);\n  }\n  else c = -1;\n  return c;\n}", "CodeBleu_score": 40.58587168479008}, {"code": "int MarlinSerialUSB::peek(){\n\tint c;\n  if (usb_task_cdc_isenabled())\n    c = udi_cdc_getc();\n  else\n    c = -1;\n  return c;\n}", "CodeBleu_score": 30.22881929554807}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\tif (rx_buffer_index_read != rx_buffer_index_write) {\n    // There is a character available in the RX buffer\n    uint8_t ch = rx_buffer[rx_buffer_index_read];\n    rx_buffer_index_read = (rx_buffer_index_read + 1) % RX_BUFFER_SIZE;\n    return ch;\n  }\n\n  // Check if the USB CDC is enabled and configured\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  // Check if there are any bytes available to read from the PC\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  // Read the next character from the USB CDC\n  int16_t ch = udi_cdc_getc();\n  if (ch < 0) return -1;\n\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(ch);\n  #endif\n\n  return ch;\n}", "CodeBleu_score": 49.666608099826625}, {"code": "int MarlinSerialUSB::read(){\n\tint c;\n  if ((c = static_cast<MSerialT1*>(this)->peek()) >= 0) return c;\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  c = udi_cdc_getc();\n  if (c >= 0) emergency_parser.update(c);\n  return c;\n}", "CodeBleu_score": 46.7039022651775}, {"code": "int MarlinSerialUSB::read(){\n\tint c;\n  if ((c = static_cast<MSerialT1*>(this)->peek()) >= 0) return c;\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  c = udi_cdc_getc();\n  if (c >= 0) emergency_parser.update(c);\n  return c;\n}", "CodeBleu_score": 46.7039022651775}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\tif (rx_buffer_head == rx_buffer_tail) {\n    if (!usb_task_cdc_isenabled())\n      return 0;\n    return usb_cdc_available();\n  }\n  return (rx_buffer_tail + rx_buffer_size - rx_buffer_head) % rx_buffer_size;\n}", "CodeBleu_score": 34.973580767835834}, {"code": "int MarlinSerialUSB::available(){\n\tif (pending_rx_count) return pending_rx_count;\n  if (!usb_task_cdc_isenabled()) return 0;\n  return udi_cdc_is_rx_ready();\n}", "CodeBleu_score": 44.68479477849603}, {"code": "int MarlinSerialUSB::available(){\n\tif (rx_buffer_head == rx_buffer_tail) {\n    if (usb_task_cdc_isenabled())\n      return usb_cdc_available();\n    else\n      return 0;\n  }\n  return (rx_buffer_head - rx_buffer_tail) & (RX_BUFFER_SIZE - 1);\n}", "CodeBleu_score": 37.97095402995808}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tif (pos < 0) return false;\n  while (--size >= 0) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value++ = c;\n    crc16(crc, &c, 1);\n    ++pos;\n  }\n  return false;\n}", "CodeBleu_score": 65.65145214073478}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t// If position is invalid, return\n  if (pos < 0) return false;\n\n  // If size is invalid, return\n  if (size == 0) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos >= EEPROMSize) return false;\n\n  // If we were requested to read more bytes than the emulated range, fail now\n  if (size > EEPROMSize) return false;\n\n  // If we were requested to read more bytes than the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail now\n  if (pos + size > EEPROMSize) return false;\n\n  // If we were requested to read from a position outside of the emulated range, fail", "CodeBleu_score": 24.305014832924837}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t// If the data is being written, and we are reading the first byte,\n  //  reset the CRC value to zero.\n  if (writing && pos == 0) *crc = 0;\n\n  // Read the data\n  while (size--) {\n\n    // Read the data\n    uint8_t c = ee_Read(pos);\n\n    // If we are reading the data, and the EEPROM contains the default value\n    //  (0xFF), set the data to zero.\n    if (!writing && c == 0xFF) c = 0;\n\n    // If we are writing the data, update the CRC\n    if (writing) crc16(crc, &c, 1);\n\n    // If we are writing the data, and a pointer to the value buffer was provided,\n    //  store the data in the value buffer.\n    if (writing && value) *value++ = c;\n\n    // Increment the position\n    pos++;\n  }\n\n  // Return false to indicate that the operation is complete\n  return false;\n}", "CodeBleu_score": 61.361242346558996}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (pin == 0) return;\n  if (pin == 255) {\n    #if ENABLED(AUTOMATIC_CURRENT_CONTROL)\n      const uint16_t pwm_value = map(value, 0, 255, 0, 1023);\n      set_current_from_pwm(pwm_value);\n    #endif\n    return;\n  }\n\n  int8_t chan = get_pwm_channel(pin, freq, res);\n  if (chan >= 0) {\n    ledcWrite(chan, value);\n    return;\n  }\n\n  // No hardware PWM channel available. Use software PWM.\n  int8_t sw_chan = -1;\n  for (int8_t i = 0; i < NUM_PWM_SLOTS; i++) {\n    if (pwm_slots[i].pin == pin) {\n      sw_chan = i;\n      break;\n    }\n  }\n  if (sw_chan < 0) {\n    if (num_pwm_slots >= NUM_PWM_SLOTS) return;\n    sw_chan = num_pwm_slots++;\n    pwm_slots[sw_chan].pin = pin;\n    pwm_slots[sw_chan].value = 0;\n    pwm_slots[sw_chan].freq = freq;\n    pwm_slots[sw_chan].res = res;\n  }\n  pwm_slots[sw_chan].value = value;\n  if (pwm_slots[sw_chan].freq != freq) pwm_slots[sw_chan].freq = freq;\n  if (pwm_slots[sw_chan].res != res) pwm_slots[sw_chan].res = res;\n  pwm_slots[sw_chan].value = value;\n  if (pwm_slots[sw_chan].freq != freq) pwm_slots[sw_chan", "CodeBleu_score": 56.47675426070644}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (!WITHIN(pin, 0, NUM_DIGITAL_PINS)) return;\n  if (freq == 0) freq = PWM_FREQUENCY;\n  if (res == 0) res = 8;\n\n  // Hardware PWM\n  if (pin < MAX_PWM_IOPIN) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n\n  // Software PWM\n  if (value == 0) {\n    // Disable software PWM\n    if (pin_state[pin] == PIN_SW_PWM) {\n      pin_state[pin] = PIN_NONE;\n      sw_pwm_count--;\n    }\n  }\n  else {\n    // Enable software PWM\n    if (pin_state[pin] != PIN_SW_PWM) {\n      pin_state[pin] = PIN_SW_PWM;\n      sw_pwm_count++;\n      if (sw_pwm_count == 1) HAL_timer_start(PWM_TIMER_NUM, PWM_PRESCALER);\n    }\n    if (value == 255)\n      sw_pwm_pin_value[pin] = 0x7F;\n    else\n      sw_pwm_pin_value[pin] = (uint8_t)(value * 0x7F / 255);\n  }\n}", "CodeBleu_score": 55.484531409755974}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    const int8_t chan = get_pwm_channel(pin, freq, res);\n    if (chan >= 0) {\n      ledcWrite(chan, value);\n      return;\n    }\n  }\n  // Not a PWM pin. Just set the pin state\n  digitalWrite(pin, (value > PWM_LIMIT) ? HIGH : LOW);\n}", "CodeBleu_score": 28.740208919184262}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\tstatic_assert(COUNT(servo_delays) == NUM_SERVOS, \"SERVO_DELAYS must have NUM_SERVOS elements.\");\n\n  if (attach(pin)) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 52.74415336610224}, {"code": "void Servo::move(const int value){\n\tstatic_assert(COUNT(servo_delays) == NUM_SERVOS, \"SERVO_DELAY_ARRAY_SIZE is not equal to the number of servos!\");\n  if (attach(pin)) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 52.23296107688584}, {"code": "void Servo::move(const int value){\n\tstatic_assert(COUNT(servo_delays) == NUM_SERVOS, \"SERVO_DELAY_ARRAY_SIZE is not equal to the number of servos!\");\n\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 60.416767189840414}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t// static uint32_t sample_counter = 0;\n  // static uint32_t sample_counter_2 = 0;\n  // static uint32_t sample_counter_3 = 0;\n  // static uint32_t sample_counter_4 = 0;\n  // static uint32_t sample_counter_5 = 0;\n  // static uint32_t sample_counter_6 = 0;\n  // static uint32_t sample_counter_7 = 0;\n  // static uint32_t sample_counter_8 = 0;\n  // static uint32_t sample_counter_9 = 0;\n  // static uint32_t sample_counter_10 = 0;\n  // static uint32_t sample_counter_11 = 0;\n  // static uint32_t sample_counter_12 = 0;\n  // static uint32_t sample_counter_13 = 0;\n  // static uint32_t sample_counter_14 = 0;\n  // static uint32_t sample_counter_15 = 0;\n  // static uint32_t sample_counter_16 = 0;\n  // static uint32_t sample_counter_17 = 0;\n  // static uint32_t sample_counter_18 = 0;\n  // static uint32_t sample_counter_19 = 0;\n  // static uint32_t sample_counter_20 = 0;\n  // static uint32_t sample_counter_21 = 0;\n  // static uint32_t sample_counter_22 = 0;\n  // static uint32_t sample_counter_23 = 0;\n  // static uint32_t sample_counter_24 = 0;\n  // static uint32_t sample_counter_25 = 0;\n  // static uint32_t sample_counter_26 = 0;\n  // static uint32_t sample_counter_27 = 0;\n  // static uint32_t sample_", "CodeBleu_score": 0.6634925539934764}, {"code": "void i2s_push_sample(){\n\t// The following code is executed for each pin.\n  // The code is equivalent to the following:\n  // if (pwm[pin].duty > 0) {\n  //   if (pwm[pin].ticks == 0) {\n  //     pwm[pin].state = !pwm[pin].state;\n  //     pwm[pin].ticks = pwm[pin].duty;\n  //   } else {\n  //     pwm[pin].ticks--;\n  //   }\n  //   pwm[pin].port->ODR ^= (pwm[pin].state << pwm[pin].pin);\n  // }\n  // dma_buffer[dma_buffer_position++] = pwm[pin].port->ODR;\n  // if (dma_buffer_position >= DMA_BUFFER_LENGTH) {\n  //   dma_buffer_position = 0;\n  // }\n  //\n  // The code below is equivalent to the code above.\n  // The code below is a bit more efficient because it uses bitwise operations.\n  // It also uses the fact that the DMA buffer is located in the same memory space as the GPIO registers.\n  // This means that the code below can write the port data directly to the DMA buffer.\n  // It also means that the code below can read the port data directly from the DMA buffer.\n  // This means that the code below can read the port data directly from the DMA buffer.\n  // This means that the code below can read the port data directly from the DMA buffer.\n  // This means that the code below can read the port data directly from the DMA buffer.\n  // This means that the code below can read the port data directly from the DMA buffer.\n  // This means that the code below can read the port data directly from the DMA buffer.\n  // This means that the code below can read the port data directly from the DMA buffer.\n  // This means that the code below can read the port data directly from the DMA buffer.\n  // This means that the code below can read the port data directly from the DMA buffer.\n  // This means that", "CodeBleu_score": 0.6634925417067229}, {"code": "void i2s_push_sample(){\n\tstatic uint32_t i2s_buffer_pos = 0;\n\tstatic uint32_t i2s_buffer_pos_half = 0;\n\tstatic uint32_t i2s_buffer_pos_third = 0;\n\tstatic uint32_t i2s_buffer_pos_quarter = 0;\n\tstatic uint32_t i2s_buffer_pos_eighth = 0;\n\tstatic uint32_t i2s_buffer_pos_sixteenth = 0;\n\tstatic uint32_t i2s_buffer_pos_thirtysecond = 0;\n\tstatic uint32_t i2s_buffer_pos_sixtyfourth = 0;\n\tstatic uint32_t i2s_buffer_pos_onetwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_twotwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_fourtwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_eighttwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_sixteentwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_thirtytwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_fourtytwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_sixtytwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_eightytwentyeighth = 0;\n\tstatic uint32_t i2s_buffer_pos_onetwentyfourth = 0;\n\tstatic uint32_t i2s_buffer_pos_twotwentyfourth = 0;\n\tstatic uint32_t i2s_buffer_pos_threetwentyfourth = 0;\n\tstatic uint32_t i2s_buffer_pos_fourtwentyfourth = 0;", "CodeBleu_score": 2.7096275250357653}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t count;\n\n  if (timer_num < TIMER_NUM) {\n    if (timer_num == 0) {\n      count = timer0_get_counter_value();\n    } else if (timer_num == 1) {\n      count = timer1_get_counter_value();\n    } else if (timer_num == 2) {\n      count = timer2_get_counter_value();\n    }\n  }\n  return count;\n}", "CodeBleu_score": 33.18293284379925}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t timer_count;\n\tif (timer_num == 0) {\n\t\ttimer_count = TIMER0->TCNT;\n\t} else if (timer_num == 1) {\n\t\ttimer_count = TIMER1->TCNT;\n\t} else if (timer_num == 2) {\n\t\ttimer_count = TIMER2->TCNT;\n\t} else if (timer_num == 3) {\n\t\ttimer_count = TIMER3->TCNT;\n\t} else {\n\t\ttimer_count = 0;\n\t}\n\treturn timer_count;\n}", "CodeBleu_score": 31.93850921664617}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t count;\n  uint32_t timer_load_value;\n  uint32_t timer_current_value;\n  uint32_t timer_control_reg;\n  uint32_t timer_load_count;\n\n  /*\n   * Check if the timer number is valid.\n   */\n  if (timer_num >= TIMER_COUNT) {\n    return 0;\n  }\n\n  /*\n   * Read the timer configuration.\n   */\n  timer_load_value = timer_config[timer_num].timer_load_value;\n  timer_current_value = timer_config[timer_num].timer_current_value;\n  timer_control_reg = timer_config[timer_num].timer_control_reg;\n  timer_load_count = timer_config[timer_num].timer_load_count;\n\n  /*\n   * Check if the timer is running.\n   */\n  if ((timer_control_reg & TIMER_ENABLE) != 0) {\n    /*\n     * Calculate the current counter value.\n     */\n    count = timer_load_value - timer_current_value;\n  } else {\n    /*\n     * Return the counter value at the time the timer was stopped.\n     */\n    count = timer_load_value;\n  }\n\n  /*\n   * Return the current counter value.\n   */\n  return count;\n}", "CodeBleu_score": 41.865359780992264}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    const uint8_t c = eeprom_read_byte((uint8_t*)pos++);\n    if (writing) *value++ = c;\n    crc16(crc, &c, 1);\n  }\n  return false;\n}", "CodeBleu_score": 70.40909057704503}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    uint8_t c = eeprom_read_byte((uint8_t*)pos);\n    crc16(crc, &c, 1);\n    if (writing) value[i] = c;\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 73.86975789344484}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (uint16_t cnt = 0; cnt < size; cnt++) {\n    const uint8_t c = eeprom_read_byte((uint8_t*)pos);\n    crc16(crc, &c, 1);\n    if (writing) value[cnt] = c;\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 64.29473314203692}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(hsd);\n    CORE_ASSERT(src);\n\n    // Try to write the block.\n    for (uint8_t i = 0; i < SDCARD_WRITE_RETRY_COUNT; i++) {\n        if (HAL_SD_WriteBlocks(&hsd, (uint8_t *)src, block, 1, SDCARD_WRITE_TIMEOUT) == SD_OK) {\n            return true;\n        }\n    }\n\n    // If we reach this point, the write failed.\n    printf(\"Failed to write block %lu\n\", block);\n    return false;\n}", "CodeBleu_score": 36.33544055291901}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(sdio != NULL);\n    CORE_ASSERT(src != NULL);\n\n    bool success = false;\n    for (uint8_t i = 0; i < SDIO_WRITE_RETRIES; i++) {\n        if (sdio->WriteBlock(block, src)) {\n            success = true;\n            break;\n        }\n    }\n    if (!success) {\n        printf(\"SDIO_WriteBlock: Failed to write block %lu\n\", block);\n    }\n    return success;\n}", "CodeBleu_score": 38.30060377753771}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(sdioHandle != NULL);\n\tCORE_ASSERT(src != NULL);\n\t\n\tbool success = false;\n\tfor (uint8_t i = 0; i < SDIO_WRITE_RETRIES; i++) {\n\t\tif (HAL_SD_WriteBlocks(&sdioHandle, (uint8_t *)src, block, 1, 100) == HAL_OK) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!success) {\n\t\tprintf(\"SDIO_WriteBlock: Failed to write block %lu\n\", block);\n\t}\n\treturn success;\n}", "CodeBleu_score": 39.28406744300579}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_CHANNEL_0:\n      HAL_timer_init(TIMER_CHANNEL_0, frequency);\n      HAL_timer_enable_interrupt(TIMER_CHANNEL_0);\n      HAL_timer_set_callback_priority(TIMER_CHANNEL_0, 0);\n      break;\n    case TIMER_CHANNEL_1:\n      HAL_timer_init(TIMER_CHANNEL_1, frequency);\n      HAL_timer_enable_interrupt(TIMER_CHANNEL_1);\n      HAL_timer_set_callback_priority(TIMER_CHANNEL_1, 1);\n      break;\n    case TIMER_CHANNEL_2:\n      HAL_timer_init(TIMER_CHANNEL_2, frequency);\n      HAL_timer_enable_interrupt(TIMER_CHANNEL_2);\n      HAL_timer_set_callback_priority(TIMER_CHANNEL_2, 1);\n      break;\n    case TIMER_CHANNEL_3:\n      HAL_timer_init(TIMER_CHANNEL_3, frequency);\n      HAL_timer_enable_interrupt(TIMER_CHANNEL_3);\n      HAL_timer_set_callback_priority(TIMER_CHANNEL_3, 1);\n      break;\n    case TIMER_CHANNEL_4:\n      HAL_timer_init(TIMER_CHANNEL_4, frequency);\n      HAL_timer_enable_interrupt(TIMER_CHANNEL_4);\n      HAL_timer_set_callback_priority(TIMER_CHANNEL_4, 1);\n      break;\n    case TIMER_CHANNEL_5:\n      HAL_timer_init(TIMER_CHANNEL_5, frequency);\n      HAL_timer_enable_interrupt(T", "CodeBleu_score": 29.37891689288711}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tif (timer_num == TEMP_TIMER_NUM) {\n    TEMP_TIMER->start(frequency, TEMP_TIMER_PRESCALE);\n    TEMP_TIMER->setCallbackPriority(TEMP_TIMER_PRIORITY);\n  }\n  else if (timer_num == STEP_TIMER_NUM) {\n    STEP_TIMER->start(frequency, STEP_TIMER_PRESCALE);\n    STEP_TIMER->setCallbackPriority(STEP_TIMER_PRIORITY);\n  }\n  else {\n    CORE_DEBUG_PRINTF(\"Invalid timer channel\n\");\n    CORE_ASSERT_FAIL();\n  }\n}", "CodeBleu_score": 54.037964087153014}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_CHANNEL_0:\n      TIMERG0.hw_timer[TIMER_0].config.divider = TIMER_DIVIDER;\n      TIMERG0.hw_timer[TIMER_0].config.alarm_en = TIMER_ALARM_EN;\n      TIMERG0.hw_timer[TIMER_0].config.intr_type = TIMER_INTR_LEVEL;\n      TIMERG0.hw_timer[TIMER_0].config.counter_en = TIMER_START;\n      TIMERG0.hw_timer[TIMER_0].config.auto_reload = TIMER_AUTORELOAD_EN;\n      TIMERG0.hw_timer[TIMER_0].config.counter_dir = TIMER_COUNT_UP;\n      TIMERG0.hw_timer[TIMER_0].config.pause = TIMER_PAUSE;\n      TIMERG0.hw_timer[TIMER_0].config.reload = 0;\n      TIMERG0.hw_timer[TIMER_0].config.alarm_value = (TIMER_BASE_CLK / TIMER_DIVIDER) / frequency;\n      TIMERG0.int_ena.t0 = 1;\n      TIMERG0.hw_timer[TIMER_0].update = 1;\n      TIMERG0.int_clr_timers.t0 = 1;\n      timer_isr_register(0, (void (*)(void *))HAL_timer_isr, (void *)timer_num, ESP_INTR_FLAG_IRAM, NULL);\n      timer_isr_enable(0, TIMER_0);\n      timer_group_intr_enable(TIMER_GROUP_0, TIMER_INTR_T0);\n      timer_group_enable_intr(TIMER_GROUP_0);\n      break;\n    case TIMER_CHANNEL_1", "CodeBleu_score": 28.818269686971593}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\tif (!_file) {\n    _file = fopen(_filename, \"r+b\");\n    if (!_file) {\n      _file = fopen(_filename, \"w+b\");\n    }\n  }\n  if (!_file) {\n    return false;\n  }\n  memset(_buffer, 0xFF, _size);\n  fseek(_file, 0, SEEK_END);\n  size_t file_size = ftell(_file);\n  if (file_size < _size) {\n    fseek(_file, 0, SEEK_SET);\n    fwrite(_buffer, _size, 1, _file);\n    fflush(_file);\n  }\n  else {\n    fseek(_file, 0, SEEK_SET);\n    fread(_buffer, _size, 1, _file);\n  }\n  fclose(_file);\n  _file = nullptr;\n  return true;\n}", "CodeBleu_score": 46.41902740927414}, {"code": "bool PersistentStore::access_start(){\n\t// Open the file for reading and writing\n  file = fopen(filename, \"r+b\");\n  if (!file) {\n    // File does not exist, or cannot be opened\n    return false;\n  }\n\n  // Get the file size\n  fseek(file, 0, SEEK_END);\n  filesize = ftell(file);\n  fseek(file, 0, SEEK_SET);\n\n  // Initialize the buffer\n  memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\n  // If the file is smaller than the expected EEPROM size,\n  // fill the remainder of the buffer with the erase value.\n  if (filesize < EEPROM_SIZE) {\n    fclose(file);\n    file = NULL;\n    return true;\n  }\n\n  // Read the file into the buffer\n  fread(buffer, 1, EEPROM_SIZE, file);\n\n  // Close the file\n  fclose(file);\n  file = NULL;\n\n  return true;\n}", "CodeBleu_score": 41.54595327210047}, {"code": "bool PersistentStore::access_start(){\n\t// Open the file for reading and writing\n\tFILE* file = fopen(file_path, \"r+b\");\n\tif (file == NULL) {\n\t\t// If the file doesn't exist, attempt to create it\n\t\tfile = fopen(file_path, \"w+b\");\n\t\tif (file == NULL) {\n\t\t\t// If the file still doesn't exist, return false\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Get the file size\n\tfseek(file, 0, SEEK_END);\n\tlong file_size = ftell(file);\n\n\t// If the file is smaller than the EEPROM, fill the remainder with the erase value\n\tif (file_size < size) {\n\t\t// Seek to the end of the file\n\t\tfseek(file, 0, SEEK_END);\n\n\t\t// Calculate the number of bytes to write\n\t\tlong bytes_to_write = size - file_size;\n\n\t\t// Write the erase value to the file until it is filled\n\t\tfor (long i = 0; i < bytes_to_write; i++) {\n\t\t\tfputc(erase_value, file);\n\t\t}\n\t}\n\n\t// Read the file's contents into the buffer\n\tfseek(file, 0, SEEK_SET);\n\tfread(buffer, 1, size, file);\n\n\t// Close the file\n\tfclose(file);\n\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 44.30260109135628}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n    for (int i = 0; i < 8; i++) {\n        HAL_GPIO_STM32_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n        HAL_GPIO_STM32_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) >> 7);\n        HAL_GPIO_STM32_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n        r = r << 1;\n        if (HAL_GPIO_STM32_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n            r = r | 0x01;\n        }\n        b = b << 1;\n    }\n    delaySPIFunc();\n    return r;\n}", "CodeBleu_score": 43.92070905387603}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t i;\n\tuint8_t r = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tWRITE(SPI_SCK_PIN, 0);\n\t\tWRITE(SPI_MOSI_PIN, (b & 0x80) ? 1 : 0);\n\t\tWRITE(SPI_SCK_PIN, 1);\n\t\tr <<= 1;\n\t\tif (READ(SPI_MISO_PIN)) {\n\t\t\tr |= 1;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tdelaySPIFunc();\n\treturn r;\n}", "CodeBleu_score": 44.716891195425625}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n    for (uint8_t i = 0; i < 8; i++) {\n        // Set the clock low\n        digitalWrite(SPI_SCK, LOW);\n        // Write the MSB to the MOSI pin\n        digitalWrite(SPI_MOSI, (b & 0x80) ? HIGH : LOW);\n        // Toggle the clock high\n        digitalWrite(SPI_SCK, HIGH);\n        // Read the bit from the MISO pin\n        if (digitalRead(SPI_MISO) == HIGH) {\n            r |= (1 << 7);\n        }\n        // Shift to the left and move to the next bit\n        b <<= 1;\n        r <<= 1;\n    }\n    // Set the clock low\n    digitalWrite(SPI_SCK, LOW);\n    // Return the received byte\n    return r;\n}", "CodeBleu_score": 46.430311031373805}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 78.26394678944122}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 78.26394678944122}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\tuint32_t tmpregister;\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\ttmpregister = RCC->AHBENR;\n\tif (NewState != DISABLE) {\n\t\ttmpregister |= RCC_AHBPeriph;\n\t} else {\n\t\ttmpregister &= ~RCC_AHBPeriph;\n\t}\n\tRCC->AHBENR = tmpregister;\n}", "CodeBleu_score": 66.85775267025626}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t// Read byte\n  uint8_t b = obj->usart->DR;\n\n  // If RX buffer full\n  if (_rx_buffer_head + 1 == _rx_buffer_tail) return;\n\n  // Store data in buffer and advance head\n  _rx_buffer[_rx_buffer_head] = b;\n  _rx_buffer_head = (_rx_buffer_head + 1) % RX_BUFFER_SIZE;\n\n  // Update emergency parser\n  emergency_parser.update(b);\n}", "CodeBleu_score": 27.938768713770823}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c;\n  if (obj->uart->LCR & 0x10) { // 16950 or later UART\n    c = obj->uart->DLL;\n    if (obj->uart->LSR & 0x20) { // Parity error\n      obj->uart->SWE = 1; // Clear parity error\n      obj->uart->SWE = 0;\n      obj->uart->LCR &= ~0x10;\n      obj->uart->LCR |= 0x10;\n      return;\n    }\n  }\n  else {\n    c = obj->uart->RBR;\n  }\n  if (obj->uart->LSR & 0x20) { // Parity error\n    obj->uart->SWE = 1; // Clear parity error\n    obj->uart->SWE = 0;\n    obj->uart->LCR &= ~0x10;\n    obj->uart->LCR |= 0x10;\n    return;\n  }\n  if (obj->index == SERIAL_RX_BUFFER_SIZE) {\n    obj->index = 0;\n  }\n  obj->rx_buffer_head = (obj->rx_buffer_head + 1) & (SERIAL_RX_BUFFER_SIZE - 1);\n  obj->rx_buffer[obj->index] = c;\n  obj->index++;\n  emergency_parser.update(c);\n}", "CodeBleu_score": 39.263381864599275}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c;\n  if (obj->rx_buff.head == obj->rx_buff.tail) {\n    // Ring buffer overflow\n    return;\n  }\n  c = obj->rx_buff.buffer[obj->rx_buff.head];\n  if (obj->serial.config.parity == UART_PARITY_NONE) {\n    // If no parity error, read byte and store it in the ring buffer\n    if (obj->rx_buff.not_full) {\n      obj->rx_buff.buffer[obj->rx_buff.head] = obj->serial.dr;\n      if (++obj->rx_buff.head >= SERIAL_RX_BUFFER_SIZE) {\n        obj->rx_buff.head = 0;\n      }\n      if (obj->rx_buff.head == obj->rx_buff.tail) {\n        // Ring buffer overflow\n        obj->rx_buff.not_full = 0;\n      }\n    }\n  }\n  else {\n    // If parity error, read byte but don't store it in the ring buffer\n    obj->serial.dr;\n  }\n  if (obj->serial.config.data_bits == UART_DATA_BITS_9) {\n    // If 9-bit, read the 2nd byte\n    if (obj->rx_buff.not_full) {\n      obj->rx_buff.buffer[obj->rx_buff.head] = obj->serial.dr;\n      if (++obj->rx_buff.head >= SERIAL_RX_BUFFER_SIZE) {\n        obj->rx_buff.head = 0;\n      }\n      if (obj->rx_buff.head == obj->rx_buff.tail) {\n        // Ring buffer overflow\n        obj->rx_buff.not_full = 0;\n      }\n    }\n  }\n  // Update the emergency parser\n  emergency_parser.update(c);\n}", "CodeBleu_score": 33.74452207481493}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_instance[timer_num]->isInitialized() && !timer_instance[timer_num]->hasInterrupt()) {\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n      default:\n        break;\n    }\n  }\n}", "CodeBleu_score": 85.93755306294251}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_instance[timer_num]->isEnabled() && !timer_instance[timer_num]->hasInterrupt()) {\n    timer_instance[timer_num]->attachInterrupt(timer_num == MF_TIMER_STEP ? Step_Handler : Temp_Handler);\n  }\n}", "CodeBleu_score": 45.90077322458939}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_instance[timer_num] != nullptr && !timer_instance[timer_num]->hasInterrupt()) {\n    if (timer_num == MF_TIMER_STEP) {\n      timer_instance[timer_num]->attachInterrupt(Step_Handler);\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n      timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n    }\n  }\n}", "CodeBleu_score": 61.76253813265288}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\thashsep, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := len(s) - 1; i >= len(s)-len(sep); i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashsep && s[len(s)-n:] == sep {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && s[i:i+n] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 67.83452897357259}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\thashsep, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[len(s)-n+i])\n\t}\n\tif h == hashsep && Equal(s[len(s)-n:], sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && Equal(s[i:i+n], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 61.248259020981024}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\thashsep, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[len(s)-n+i])\n\t}\n\tif h == hashsep && Equal(s[len(s)-n:], sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && Equal(s[i:i+n], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 61.248259020981024}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.GetCount() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.347175063347336}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Available() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 47.944846672554604}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.185294207890394}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear the interrupt flag\n\ti2c.crReg.Set(i2c.crReg.Get() | (1 << 10))\n\t// Set the start condition, enable the I2C module, and transmit the address\n\ti2c.crReg.Set(i2c.crReg.Get() | (1 << 8) | (1 << 9))\n\t// Wait for the start condition to be transmitted\n\tfor i2c.crReg.HasBits(1 << 10) {\n\t}\n\t// Write the address to the bus\n\ti2c.writeByte(address << 1)\n}", "CodeBleu_score": 34.437861972713726}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\n\ti2c.crReg.Set(i2c.crReg.Clear(i2c.crReg.Get(), i2c.crReg.HasBits(i2c.crReg.Get(), i2c.crReg.I2CEN)).Set(i2c.crReg.START))\n\n\t// Wait for the start condition to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srReg.Get(), i2c.srReg.SB) {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed.\n\ti2c.writeByte(address<<1 | write)\n}", "CodeBleu_score": 36.181039974550266}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.crReg.SetBits(i2c.crReg.Mask(0x00000000))\n\ti2c.crReg.SetBits(i2c.crReg.Mask(0x00000001))\n\ti2c.crReg.SetBits(i2c.crReg.Mask(0x00000002))\n\ti2c.crReg.SetBits(i2c.crReg.Mask(0x00000004))\n\n\ti2c.writeByte(address << 1)\n}", "CodeBleu_score": 30.438803647736005}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif len < 0 || start < 0 || start+len > int64(f.BlockCount) {\n\t\treturn errors.New(\"invalid block range\")\n\t}\n\n\tstartAddr := f.FlashDataStart + uint32(start)*f.BlockSize\n\n\tnrf.NVMC.SetCONFIG_WEN(1)\n\twaitWhileFlashBusy()\n\tnrf.NVMC.ERASEPAGE.Set(startAddr)\n\tfor i := uint32(0); i < uint32(len); i++ {\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.ERASEPAGE.Set(startAddr + i*f.BlockSize)\n\t}\n\twaitWhileFlashBusy()\n\tnrf.NVMC.SetCONFIG_WEN(0)\n\n\treturn nil\n}", "CodeBleu_score": 45.583579706536085}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || len < 1 || start+len > f.BlockCount {\n\t\treturn errors.New(\"invalid block range\")\n\t}\n\n\t// calculate the start address\n\tstartAddr := f.Address + uint32(start)*f.BlockSize\n\n\t// wait for any ongoing flash operations to complete\n\twaitWhileFlashBusy()\n\n\t// configure the flash for erasing\n\tnrf.NVMC.SetCONFIG_WEN(1)\n\n\t// erase each block\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(startAddr + uint32(i)*f.BlockSize))\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// set the flash back to read mode\n\tnrf.NVMC.SetCONFIG_WEN(0)\n\n\treturn nil\n}", "CodeBleu_score": 43.22937634885247}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif len < 0 || start < 0 || start+len > int64(f.BlockCount) {\n\t\treturn errors.New(\"flash: invalid block range\")\n\t}\n\tstartAddr := uint32(f.BlockSize) * uint32(start)\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.SetCONFIG_WEN(1)\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.ERASEPAGE.Set(startAddr)\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetCONFIG_WEN(0)\n\t\tstartAddr += uint32(f.BlockSize)\n\t}\n\treturn nil\n}", "CodeBleu_score": 53.22315211085653}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tif off < 0 || off >= int64(f.Size()) {\n\t\treturn 0, errors.New(\"flash: out of bounds\")\n\t}\n\n\t// Calculate the start address for writing.\n\tstartAddress := f.BaseAddress + uintptr(off)\n\n\t// Pad the data to fit the write block size.\n\tp = f.pad(p)\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\t// Copy the data to the buffer.\n\t\tcopy(f.buffer[:], p[i:i+f.WriteBlockSize])\n\n\t\t// Write the data to the flash memory.\n\t\tfor j := 0; j < f.WriteBlockSize; j += 4 {\n\t\t\t*(*uint32)(unsafe.Pointer(startAddress + uintptr(i+j))) = binary.LittleEndian.Uint32(f.buffer[j:j+4])\n\t\t}\n\n\t\t// Wait for the flash memory to be ready.\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 48.09810997201623}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off > int64(f.Size()) {\n\t\treturn 0, errors.New(\"flash: out of bounds\")\n\t}\n\tif off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, errors.New(\"flash: out of bounds\")\n\t}\n\n\tstartAddr := uintptr(f.flashStart) + uintptr(off)\n\tpadded := make([]byte, f.WriteBlockSize)\n\tcopy(padded, p)\n\tfor i := len(p); i < f.WriteBlockSize; i++ {\n\t\tpadded[i] = f.pad\n\t}\n\n\tnrf.NVMC.SetCONFIG_WEN(true)\n\twaitWhileFlashBusy()\n\n\tfor i := 0; i < f.WriteBlockSize; i += 4 {\n\t\tbinary.LittleEndian.PutUint32((*uint32)(unsafe.Pointer(startAddr+uintptr(i))), *(*uint32)(unsafe.Pointer(&padded[i])))\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 42.54126236067678}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"flash: out of bounds\")\n\t}\n\taddr := f.BaseAddress + uintptr(off)\n\tp = f.pad(p, f.WriteBlockSize)\n\tnrf.NVMC.SetCONFIG_WEN(true)\n\tfor i := 0; i < len(p); i += int(f.WriteBlockSize) {\n\t\tbinary.LittleEndian.PutUint32(f.buf, *(*uint32)(unsafe.Pointer(&p[i])))\n\t\tcopy((*[4]byte)(unsafe.Pointer(addr+uintptr(i)))[:], f.buf[:])\n\t\twaitWhileFlashBusy()\n\t}\n\tnrf.NVMC.SetCONFIG_WEN(false)\n\treturn len(p), nil\n}", "CodeBleu_score": 36.22877129519731}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tvar err error\n\tvar dupFd syscallFd\n\tvar dir *syscall.Dir\n\n\tdupFd, err = syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\tif err != nil && err != syscall.EINTR {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\n\t\tif err == nil {\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 51.398746286714946}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor\n\tfdDup, _, err := syscallDup(fd)\n\tif err != nil {\n\t\treturn 0, fmt.Sprintf(\"Could not duplicate file descriptor %d\", fd), err\n\t}\n\t// Attempt to open the directory\n\tfor {\n\t\tdirPtr, err := syscallFdopendir(fdDup)\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsyscallClose(fdDup)\n\t\t\treturn 0, fmt.Sprintf(\"Could not open directory file descriptor %d\", fd), err\n\t\t}\n\t\treturn uintptr(dirPtr), \"\", nil\n\t}\n}", "CodeBleu_score": 44.20006962869338}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tvar err error\n\tvar dir uintptr\n\tvar errno syscall.Errno\n\n\t// Duplicate the file descriptor.\n\tfd, err = darwinDup(fd)\n\tif err != nil {\n\t\treturn 0, err.Error(), err\n\t}\n\n\t// Attempt to open the directory.\n\tfor {\n\t\tdir, errno = syscall.Fdopendir(int(fd))\n\t\tif errno == 0 {\n\t\t\tbreak\n\t\t} else if errno != syscall.EINTR {\n\t\t\tsyscall.Close(int(fd))\n\t\t\treturn 0, errno.Error(), errno\n\t\t}\n\t}\n\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 45.648068675663644}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\tconst esp_partition_t *running = esp_ota_get_running_partition();\n  esp_image_metadata_t data;\n  const esp_partition_pos_t running_pos = {\n    .offset = running->address,\n    .size = running->size,\n  };\n\n  if (esp_image_verify(ESP_IMAGE_VERIFY, &running_pos, &data) != ESP_OK) {\n    return 0;\n  }\n\n  if (response == FREE_SPACE) {\n    return running->size - data.image_len;\n  } else {\n    return data.image_len;\n  }\n}", "CodeBleu_score": 75.62526882021695}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tconst esp_partition_t* partition = esp_ota_get_running_partition();\n\tesp_image_metadata_t data;\n\tconst esp_err_t result = esp_image_verify(ESP_IMAGE_VERIFY, partition, &data);\n\tif (result != ESP_OK) {\n\t\treturn 0;\n\t}\n\treturn (response == sketchSize_t::freeSpace) ? partition->size - data.image_len : data.image_len;\n}", "CodeBleu_score": 45.13593056222716}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tconst esp_partition_t *running = esp_ota_get_running_partition();\n  esp_image_metadata_t data;\n  const esp_partition_pos_t running_pos = {\n    .offset = running->address,\n    .size = running->size,\n  };\n  esp_err_t err = esp_image_verify(ESP_IMAGE_VERIFY, &running_pos, &data);\n  if (err != ESP_OK) {\n    return 0;\n  }\n  return (response == FREE_SKETCH_SPACE) ? esp_partition_get_free_size(running) : data.image_len;\n}", "CodeBleu_score": 65.29800201422924}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_disk_buffer = calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk_buffer) {\n    log_e(\"Failed to allocate memory for disk buffer\");\n    return false;\n  }\n  fat_add_boot_sector(msc_disk_buffer, total_sectors, volume_label, serial_number, mcs_is_fat16);\n  fat_add_table(msc_disk_buffer, total_sectors, msc_table_sectors, mcs_is_fat16);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_disk_buffer, total_sectors, msc_run_partition->label, msc_run_partition->address, msc_run_partition->size);\n  }\n  return true;\n}", "CodeBleu_score": 37.517355628057864}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors == 0) {\n    log_e(\"No space for FAT\");\n    return false;\n  }\n  msc_disk_buffer = calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk_buffer) {\n    log_e(\"No memory for FAT\");\n    return false;\n  }\n  fat_add_boot_sector(msc_disk_buffer, total_sectors, volume_label, serial_number);\n  fat_add_table(msc_disk_buffer, total_sectors, msc_is_fat16);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_disk_buffer, total_sectors, msc_is_fat16, msc_run_partition->label, msc_run_partition->address, fw_size);\n  }\n  return true;\n}", "CodeBleu_score": 35.65248144734369}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_disk = calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (msc_disk == NULL) {\n    log_e(\"ERROR: Failed to allocate %u bytes for RAM disk\", total_sectors * DISK_SECTOR_SIZE);\n    return false;\n  }\n  fat_add_boot_sector(msc_disk, total_sectors, volume_label, serial_number, msc_is_fat16);\n  fat_add_table(msc_disk, total_sectors, msc_table_sectors, msc_is_fat16);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_disk, total_sectors, msc_run_partition->label, msc_run_partition->address, fw_size);\n  }\n  return true;\n}", "CodeBleu_score": 39.352142307883355}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err;\n\tsize_t sector_size = spi_flash_get_sector_size();\n\tif (offset % sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Write offset 0x%x not aligned to 0x%x\", offset, sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (offset + size > partition->size) {\n\t\tESP_LOGE(TAG, \"Write exceeds partition size (offset 0x%x + size 0x%x > 0x%x)\", offset, size, partition->size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\tif (offset == 0) {\n\t\terr = esp_partition_erase_range(partition, offset, size);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase partition\");\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write partition\");\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 56.349505711315764}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err;\n\tsize_t sector_size = partition->sector_size;\n\tuint32_t sector_mask = sector_size - 1;\n\n\tif (offset & sector_mask) {\n\t\tESP_LOGE(TAG, \"update write operation must be aligned with sector size %d\", sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (size & sector_mask) {\n\t\tESP_LOGE(TAG, \"update write size must be multiple of sector size %d\", sector_size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\n\tif (offset + size > partition->size) {\n\t\tESP_LOGE(TAG, \"update write exceeds partition size %d\", partition->size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\n\tif (offset != 0 && size != sector_size) {\n\t\terr = esp_partition_erase_range(partition, offset, sector_size);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"failed to erase partition %s sector at offset 0x%x\", partition->label, offset);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"failed to write partition %s at offset 0x%x\", partition->label, offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 52.83667002827359}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tif (offset % ESP_ROM_SPIFLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"write address is not multiple of 4096, write aborted\");\n        return ESP_FAIL;\n    }\n\n    if (esp_partition_erase_range(partition, offset, ESP_ROM_SPIFLASH_SEC_SIZE) != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to erase partition\");\n        return ESP_FAIL;\n    }\n\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 51.268475105067665}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t outlen = 0;\n  while (*in && outlen < maxlen) {\n    uint8_t c = hex_char_to_byte(*in++);\n    if (c <= 0x0f) {\n      uint8_t c2 = hex_char_to_byte(*in++);\n      if (c2 <= 0x0f) {\n        *out++ = (c << 4) | c2;\n        outlen++;\n      }\n    }\n  }\n  return outlen;\n}", "CodeBleu_score": 43.543278626916674}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t outlen = 0;\n  while (*in && outlen < maxlen) {\n    uint8_t v = hex_char_to_byte(*in++);\n    if (v < 0x10) {\n      v <<= 4;\n      v |= hex_char_to_byte(*in++);\n      *out++ = v;\n      outlen++;\n    }\n  }\n  return outlen;\n}", "CodeBleu_score": 40.35427090075805}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i;\n  size_t j;\n  for (i = 0, j = 0; in[i] && j < maxlen; i += 2) {\n    out[j] = hex_char_to_byte(in[i]) << 4 | hex_char_to_byte(in[i + 1]);\n    j++;\n  }\n  return j;\n}", "CodeBleu_score": 36.74566674169174}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tif (!_tx_sem || !_tx_buffer) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(_tx_sem, _timeout) == pdTRUE) {\n        int ret = xRingbufferGetCurFreeSize(_tx_buffer);\n        xSemaphoreGive(_tx_sem);\n        return ret;\n    }\n    return 0;\n}", "CodeBleu_score": 53.95778639632384}, {"code": "int HWCDC::availableForWrite(void){\n\tif (!_tx_sem || !_tx_ringbuf) return 0;\n\n  if (xSemaphoreTake(_tx_sem, _timeout) == pdTRUE) {\n    int ret = xRingbufferGetCurFreeSize(_tx_ringbuf);\n    xSemaphoreGive(_tx_sem);\n    return ret;\n  }\n\n  return 0;\n}", "CodeBleu_score": 48.53699799634414}, {"code": "int HWCDC::availableForWrite(void){\n\tint freeSize;\n  if (txRingBuffer == NULL || txSemaphore == NULL) {\n    return 0;\n  }\n  if (xSemaphoreTake(txSemaphore, portMAX_DELAY) == pdTRUE) {\n    freeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n    xSemaphoreGive(txSemaphore);\n    return freeSize;\n  }\n  return 0;\n}", "CodeBleu_score": 61.037738967683765}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnRxTimeout = onlyOnTimeout;\n  if (_onReceiveCB) {\n    uartSetRxFIFOFull(true);\n    _createEventTask();\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 29.15772882701251}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  if (function) {\n    if (onlyOnTimeout) {\n      _uart_config.rx_tout_flow_dis = 1;\n      _uart_config.rx_tout_flow_en = 0;\n    } else {\n      _uart_config.rx_tout_flow_dis = 0;\n      _uart_config.rx_tout_flow_en = 1;\n    }\n    _uart_config.rx_flow_thrhd = _rxTimeout;\n    _uart_config.rx_flow_en = 1;\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  } else {\n    _uart_config.rx_flow_en = 0;\n  }\n  uart_set_rx_timeout(&_uart_config);\n  uart_set_rx_full_threshold(_uart_nr, _rxBufferSize);\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 39.21567144231306}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB) {\n    uartSetRxFIFOFull(this, 1);\n    _createEventTask();\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 29.261463082826268}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char) c;\n    index++;\n  }\n  *buffer = '\\0';\n  return index;\n}", "CodeBleu_score": 89.59759126637353}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  *buffer = '\\0';\n  return index;\n}", "CodeBleu_score": 91.10460545573224}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  *buffer = '\\0';\n  return index;\n}", "CodeBleu_score": 91.10460545573224}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_v(\"Pin: %d, Frequency: %d, Duration: %d\", pin, frequency, duration);\n  if (is_pin_in_use(pin)) {\n    log_e(\"Pin %d is already in use. Stop the current tone first.\", pin);\n    return;\n  }\n  log_v(\"Pin %d is available\", pin);\n  init_tone(pin);\n  tone_msg_t msg = {\n    .pin = pin,\n    .frequency = frequency,\n    .duration = duration,\n  };\n  log_v(\"Sending start command to tone queue\");\n  xQueueSend(_tone_queue, &msg, portMAX_DELAY);\n}", "CodeBleu_score": 58.128238309600434}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_v(\"tone pin: %d, freq: %d, duration: %d\", pin, frequency, duration);\n  if (pin == 255) {\n    log_e(\"Pin 255 is not available on the ESP32\");\n    return;\n  }\n  if (_tone_pin == pin) {\n    log_e(\"Tone already playing on pin %d\", pin);\n    return;\n  }\n  if (_tone_init() == 0) {\n    log_e(\"Could not start tone\");\n    return;\n  }\n  _tone_pin = pin;\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.frequency = frequency;\n  msg.duration = duration;\n  msg.cmd = TONE_CMD_START;\n  if (xQueueSend(_tone_queue, &msg, 0) != pdTRUE) {\n    log_e(\"Could not send start command to tone queue\");\n    return;\n  }\n}", "CodeBleu_score": 51.500983602450646}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"tone pin=%d, freq=%d, duration=%d\", pin, frequency, duration);\n  if (pin_is_free(pin) == 0) {\n    log_e(\"Pin %d is already in use\", pin);\n    return;\n  }\n\n  if (tone_init() == 0) {\n    log_e(\"Could not initialize tone\");\n    return;\n  }\n\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.frequency = frequency;\n  msg.duration = duration;\n  msg.start = 1;\n  xQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 47.15232269386382}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_usb_started) {\n    _webUSB_enabled = enabled;\n    if (enabled) {\n      _usb_version = 0x0210;\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 45.01555979541052}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (enabled) {\n\t\tif (!_webUSB) {\n\t\t\t_webUSB = true;\n\t\t\tif (_usb_version < 0x0210) {\n\t\t\t\t_usb_version = 0x0210;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t_webUSB = false;\n\t}\n\treturn false;\n}", "CodeBleu_score": 47.26791458012853}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!usb_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      usb_version = 0x0210;\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 53.32457995933867}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\tuint8_t buffer[64];\n  uint32_t len = tud_cdc_n_read(buffer, sizeof(buffer));\n  if (len) {\n    if (xQueueSend(_rx_queue, buffer, 0) == pdFALSE) {\n      uint32_t dropped = len;\n      tud_cdc_n_read(buffer, sizeof(buffer));\n      while (len) {\n        tud_cdc_n_read(buffer, sizeof(buffer));\n        dropped += len;\n      }\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_cdc_n_write(buffer, 0);\n      tud_", "CodeBleu_score": 23.494560300321492}, {"code": "void USBCDC::_onRX(){\n\tuint8_t buf[64];\n  uint32_t count = 0;\n  uint32_t total = 0;\n  uint32_t dropped = 0;\n\n  while (true) {\n    uint32_t bytes = tud_cdc_n_read(buf, sizeof(buf));\n    if (bytes == 0) {\n      break;\n    }\n\n    total += bytes;\n    for (uint32_t i = 0; i < bytes; i++) {\n      if (xQueueSend(_rx_queue, &buf[i], 0) != pdTRUE) {\n        dropped++;\n      }\n    }\n  }\n\n  if (dropped > 0) {\n    log_e(\"Dropped %d bytes\", dropped);\n    tud_cdc_n_overflow(dropped);\n  }\n\n  if (total > 0) {\n    tud_cdc_n_receive(total);\n  }\n}", "CodeBleu_score": 34.180030821929485}, {"code": "void USBCDC::_onRX(){\n\tuint32_t len = 0;\n  uint8_t buf[64];\n  uint8_t overflow = 0;\n  do {\n    len = tud_cdc_n_read(0, buf, sizeof(buf));\n    for (uint32_t i = 0; i < len; i++) {\n      if (xQueueSend(_rx_queue, &buf[i], 0) != pdPASS) {\n        overflow++;\n      }\n    }\n  } while (len > 0);\n  if (overflow) {\n    log_e(\"USBCDC: Dropped %d bytes\", overflow);\n    tud_cdc_n_overflow(0, overflow);\n  }\n  if (len) {\n    tud_cdc_n_event(0, CDC_EVT_RX, len, 0);\n  }\n}", "CodeBleu_score": 29.44485403599435}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot found with name %s\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices := make([]*gobot.JSONDevice, len(robot.Devices()))\n\tfor i, device := range robot.Devices() {\n\t\tdevices[i] = device.(*gobot.JSONDevice)\n\t}\n\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 49.2615642756065}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot '%s' not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices := []*gobot.JSONDevice{}\n\trobot.Devices().Each(func(d gobot.Device) {\n\t\tdevices = append(devices, gobot.NewJSONDevice(d))\n\t})\n\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 57.76100866250759}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\trobot := req.URL.Query().Get(\":robot\")\n\tif robot == \"\" {\n\t\thttp.Error(res, \"Please specify a robot name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\ta.master.RLock()\n\tdefer a.master.RUnlock()\n\tif _, ok := a.master.Robots[robot]; !ok {\n\t\thttp.Error(res, \"No robot found with the specified name\", http.StatusNotFound)\n\t\treturn\n\t}\n\tdevices := map[string]interface{}{}\n\ta.master.Robots[robot].Devices().Each(func(d gobot.Device) {\n\t\tdevices[d.Name()] = gobot.NewJSONDevice(d)\n\t})\n\ta.writeJSON(devices, res)\n}", "CodeBleu_score": 49.552605688694996}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot '%s' not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tjson.NewEncoder(res).Encode(c)\n\t})\n}", "CodeBleu_score": 30.41992764846485}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\trobot := a.master.Robot(robotName)\n\n\tif robot == nil {\n\t\thttp.Error(res, \"No robot found with name \"+robotName, http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections := make([]map[string]interface{}, 0)\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\":   connection.Name(),\n\t\t\t\"params\": connection.Params(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 54.480767092622095}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot '%s' not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := []*gobot.JSONConnection{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, c.(*gobot.JSONConnection))\n\t})\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 52.88521658278405}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\n\tif device == nil {\n\t\ta.writeJSON(res, map[string]string{\"Error\": \"No device found with that name\"})\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\n\tif err := a.executeCommand(robot, device, command); err != nil {\n\t\ta.writeJSON(res, map[string]string{\"Error\": err.Error()})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, a.jsonDeviceFor(robot, device))\n}", "CodeBleu_score": 57.02768817748789}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\thttp.Error(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tif commander, ok := device.(gobot.Commander); ok {\n\t\tcommand := req.URL.Query().Get(\":command\")\n\t\tparams := req.URL.Query()[\"params\"]\n\n\t\tresponse, err := a.executeCommand(robot, commander, command, params)\n\t\tif err != nil {\n\t\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\ta.writeJSON(res, response)\n\t} else {\n\t\thttp.Error(res, \"Device is not a commander\", http.StatusBadRequest)\n\t}\n}", "CodeBleu_score": 53.029594087050555}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\n\tif device == nil {\n\t\ta.writeJSON(res, map[string]string{\"Error\": \"Device not found\"})\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\tparams := req.URL.Query()[\"params\"]\n\tresult, err := a.executeCommand(robot, device, command, params)\n\n\tif err != nil {\n\t\ta.writeJSON(res, map[string]string{\"Error\": err.Error()})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, map[string]interface{}{\n\t\t\"Command\": command,\n\t\t\"Params\":  params,\n\t\t\"Result\":  result,\n\t})\n}", "CodeBleu_score": 56.105302830793}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tgivenUser, givenPass, ok := req.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(givenUser), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(givenPass), []byte(password)) != 1 {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(res, req)\n\t}\n}", "CodeBleu_score": 58.59066196017954}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tgivenUser, givenPass, ok := req.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(givenUser), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(givenPass), []byte(password)) != 1 {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Handle request\n\t}\n}", "CodeBleu_score": 59.26238279844883}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(w, \"Authorized\", http.StatusOK)\n\t}\n}", "CodeBleu_score": 51.062645588752}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().HasAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"%s is not an analog sensor\", a.Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRead = scaled\n\ta.lastRaw = raw\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.350414182625315}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"sensor not connected\")\n\t}\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.sensorCfg.lastReading = scaled\n\ta.sensorCfg.lastRawReading = raw\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 52.44238044732514}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"sensor not connected\")\n\t}\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) / float64(a.sensorCfg.scale)\n\ta.sensorCfg.lastRawValue = raw\n\ta.sensorCfg.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 54.0626557890669}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(gobot.DefaultName(\"GroveSoundSensor\"))\n\treturn &GroveSoundSensorDriver{d}\n}", "CodeBleu_score": 33.89495248605514}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\ts := &GroveSoundSensorDriver{\n\t\tname:         gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tanalogReader: a,\n\t\tpin:          pin,\n\t\tsensor:       analog.NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\ts.sensor.SetName(s.Name())\n\n\treturn s\n}", "CodeBleu_score": 40.59852215823984}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\ts := &GroveSoundSensorDriver{\n\t\tname:    gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:     pin,\n\t\tscale:   DefaultGroveSoundSensorVoltageScale,\n\t\tsensor:  NewAnalogSensorDriver(a, pin, opts...),\n\t\tunits:   \"dB\",\n\t\tadcRes:  1024,\n\t\tadcRef:  5,\n\t}\n\n\ts.sensor.SetName(s.name)\n\n\treturn s\n}", "CodeBleu_score": 45.225718686252414}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t// Perform soft reset\n\terr := d.writeByteData(CommandReg, PCD_SoftReset)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait the required 1 ms delay\n\ttime.Sleep(1 * time.Millisecond)\n\n\t// Read the command register to check if the soft reset was successful\n\tcmdReg, err := d.readByteData(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the soft reset was successful, the command register should be 0x00\n\tif cmdReg != 0x00 {\n\t\treturn fmt.Errorf(\"Soft reset failed: 0x%02x\", cmdReg)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 71.20297536006734}, {"code": "func (d *MFRC522Common) softReset() error{\n\td.writeByteData(CommandReg, CommandRegSoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tif d.readByteData(CommandReg) != 0 {\n\t\treturn fmt.Errorf(\"Soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 27.882047078216242}, {"code": "func (d *MFRC522Common) softReset() error{\n\t// Send the Soft Reset command to the MFRC522\n\tif err := d.writeByteData(d.commandReg, d.resetCommand); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the command to complete\n\ttime.Sleep(d.softResetDelay)\n\n\t// Check the command register to see if the device is still in power-down mode\n\tif err := d.readByteData(d.commandReg, &d.buffer[0]); err != nil {\n\t\treturn err\n\t}\n\n\tif d.buffer[0]&0x01 == 0x01 {\n\t\treturn fmt.Errorf(\"MFRC522 soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 59.95516672695679}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Read the number of bytes stored in the FIFO\n\tn, err := d.readByteData(d.regFifoLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// If the number of bytes doesn't match the expected length, return an error\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"expected %v bytes, got %v\", len(backData), n)\n\t}\n\t// Read each byte from the FIFO into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(d.regFifoData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.readByteData(d.regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// Return the last bits received and any errors encountered\n\treturn lastBits & 0x07, nil\n}", "CodeBleu_score": 51.1108061836373}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tlength, err := d.readByteData(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif length != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"the number of bytes in the FIFO buffer (%d) does not match the length of the provided byte slice (%d)\", length, len(backData))\n\t}\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn d.readByteData(ControlReg)\n}", "CodeBleu_score": 48.23661243495106}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Read the number of bytes stored in the FIFO buffer\n\tn, err := d.readByteData(regFifoLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// If the number of bytes is different from the length of the byte slice, return an error\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: invalid number of bytes. Expected %d, got %d\", len(backData), n)\n\t}\n\t// Read each byte from the FIFO buffer into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(regFifoData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received\n\tn, err = d.readByteData(regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn n, nil\n}", "CodeBleu_score": 54.99132078512873}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\td.log.Println(\"Halting PICC\")\n\n\t// Halt command\n\thaltCmd := []byte{\n\t\td.CommandHalt,\n\t}\n\n\t// Calculate CRC for the halt command\n\thaltCmd = append(haltCmd, d.calculateCRC(haltCmd)...)\n\n\t// Send the halt command to the PICC\n\tif err := d.communicateWithPICC(haltCmd); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 32.16072465771391}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t// Log debug message\n\td.logger.Debug(\"Sending halt command to PICC.\")\n\n\t// Create halt command\n\thaltCommand := []uint8{d.CommandHalt1, d.CommandHalt2}\n\n\t// Calculate CRC for the halt command\n\thaltCommandCRC, err := d.calculateCRC(haltCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Append CRC to the halt command\n\thaltCommand = append(haltCommand, haltCommandCRC...)\n\n\t// Send the halt command to the PICC\n\terr = d.communicateWithPICC(haltCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Return nil if the PICC has been halted successfully\n\treturn nil\n}", "CodeBleu_score": 44.099674660169754}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\td.logger.Printf(\"Halting PICC\")\n\thaltCmd := []uint8{d.PICC_CMD_HLTA, 0}\n\td.calculateCRC(haltCmd)\n\tif _, err := d.dev.Write(haltCmd); err != nil {\n\t\treturn err\n\t}\n\tvar buf [5]byte\n\tif _, err := d.dev.Read(buf[:]); err != nil {\n\t\treturn err\n\t}\n\tif buf[0] != d.PICC_CMD_CT {\n\t\treturn fmt.Errorf(\"Expected PICC_CMD_CT (= %d), but got %d\", d.PICC_CMD_CT, buf[0])\n\t}\n\tif buf[1] != 0 {\n\t\treturn fmt.Errorf(\"Expected 0, but got %d\", buf[1])\n\t}\n\tif buf[2] != d.PICC_CMD_HLTA {\n\t\treturn fmt.Errorf(\"Expected PICC_CMD_HLTA (= %d), but got %d\", d.PICC_CMD_HLTA, buf[2])\n\t}\n\treturn nil\n}", "CodeBleu_score": 39.63976828088064}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Construct the read command.\n\t// The read command is 1 byte long:\n\t// ----------------------------------------------------------------------------------------------------------------------------------------------------------\n\t// | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 |\n\t// ----------------------------------------------------------------------------------------------------------------------------------------------------------\n\t// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n\t// ----------------------------------------------------------------------------------------------------------------------------------------------------------\n\t// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n\t// ----------------------------------------------------------------------------------------------------------------------------------------------------------\n\t// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |", "CodeBleu_score": 4.142776466261798}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Construct the read command\n\tvar cmd []byte\n\tcmd = append(cmd, d.PICC_READ)\n\tcmd = append(cmd, block)\n\t// Calculate CRC for the read command\n\tcmd = append(cmd, d.calculateCRC(cmd)...)\n\t// Conduct the read operation\n\tresp, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check if the response is valid\n\tif len(resp) != 17 {\n\t\treturn nil, errors.New(\"Invalid response\")\n\t}\n\t// Check if the response has a valid CRC\n\tif !d.verifyCRC(resp) {\n\t\treturn nil, errors.New(\"Invalid CRC\")\n\t}\n\t// Return the data\n\treturn resp[1 : len(resp)-2], nil\n}", "CodeBleu_score": 37.176221077596644}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// The read command structure is as follows:\n\t//\n\t// +------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+\n\t// | 0x30 | block address | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | CRC |\n\t// +------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+\n\t//\n\t// The block address is a 1-byte value that identifies the block to read.\n\t// The CRC is a 2-byte value that is the CRC16 of the command.\n\n\t// Construct the read command.\n\tvar readCommand = make([]byte, 12)\n\treadCommand[0] = 0x30\n\treadCommand[1] = block\n\n\t// Calculate the CRC for the read command.\n\tvar crc = d.calculateCRC(readCommand[0:2])\n\n\t// Append the CRC to the read command.\n\treadCommand[2] = byte(crc >> 8)\n\treadCommand[3] = byte(crc & 0xFF)\n\n\t// Communicate with the RFID card using the read command.\n\tvar response, err = d.communicateWithPICC(readCommand)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the response is not 16 bytes, then an error occurred.\n\tif len(response) != 16 {\n\t\treturn nil, errors.New(\"Invalid response from PICC\")\n\t}\n\n\t// If the response does not start with 0x00, then an error occurred.\n\tif response[0] != 0x00 {\n\t\treturn nil, errors.New(\"Invalid response from PICC\")\n\t}\n\n\t// The 16-byte response is the 16 bytes of data from the specified block.\n\treturn response[1:], nil\n}", "CodeBleu_score": 37.731967053857865}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Check if the answer buffer has at least 2 bytes of space.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\t// Clear specific bits in the collision register.\n\td.clearRegisterBitMask(CollReg, 0x80) // ValuesAfterColl\n\td.clearRegisterBitMask(CollReg, 0x40) // CollPosNotValid\n\t// Set the transmission to use only 7 bits of the last byte.\n\td.writeRegister(BitFramingReg, 0x07)\n\t// Transmit the request command.\n\terr := d.transceive(reqMode, []byte{}, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check if the response is valid.\n\tif answer[0]&0x01 == 1 || answer[0]&0x02 == 1 {\n\t\treturn fmt.Errorf(\"invalid response\")\n\t}\n\t// Check if the response is a cascade level.\n\tif answer[0]&0x04 == 1 {\n\t\treturn fmt.Errorf(\"cascade level\")\n\t}\n\t// Check if the response is an ACK.\n\tif answer[0]&0x08 == 1 {\n\t\treturn fmt.Errorf(\"ACK\")\n\t}\n\t// Check if the response is a NACK.\n\tif answer[0]&0x10 == 1 {\n\t\treturn fmt.Errorf(\"NACK\")\n\t}\n\t// Check if the response is a WUPA.\n\tif answer[0]&0x20 == 1 {\n\t\treturn fmt.Errorf(\"WUPA\")\n\t}\n\t// Check if the response is an error.\n\tif answer[0]&0x40 == 1 {\n\t\treturn fmt.Errorf(\"error\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.47366401249859}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\t// Clear the collision register\n\td.clearRegisterBitMask(CollReg, 0x80)\n\t// Set the transmission to use only 7 bits of the last byte\n\td.clearRegisterBitMask(TxModeReg, 0x80)\n\t// Send the request\n\tif err := d.transceive(reqMode, nil, answer); err != nil {\n\t\treturn err\n\t}\n\t// Check for errors in the response\n\tif answer[0]&0x10 != 0 {\n\t\treturn fmt.Errorf(\"PICC error: %d\", answer[0]&0x0F)\n\t}\n\t// Check if the PICC responded with the expected data\n\tif answer[0]&0x08 != 0 {\n\t\treturn fmt.Errorf(\"PICC error: %d\", answer[0]&0x0F)\n\t}\n\treturn nil\n}", "CodeBleu_score": 55.01938314957966}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Check if the answer buffer has at least 2 bytes of space\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too short\")\n\t}\n\t// Clear specific bits in the collision register\n\td.clearRegisterBitMask(CollReg, 0x80) // ValuesAfterColl\n\td.clearRegisterBitMask(CollReg, 0x40) // CollPosNotValid\n\t// Set transmission to use only 7 bits of the last byte\n\tif reqMode == Request || reqMode == WakeUp {\n\t\td.writeRegister(BitFramingReg, 0x07)\n\t}\n\t// Transmit the request\n\td.writeRegister(CommandReg, PCD_Transceive)\n\td.writeRegister(ModeReg, reqMode)\n\terr := d.communicateWithPICC(answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check if the PICC responded with a valid answer\n\tif len(answer) == 0 || answer[0]&0x01 == 1 || answer[0]&0x10 == 1 {\n\t\treturn fmt.Errorf(\"invalid answer\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.81293324905179}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\td.digitalWrite(d.stepPin, gpio.LOW)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, gpio.HIGH)\n\tif d.direction == CW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 46.04618586097791}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.stepNumber++\n\treturn nil\n}", "CodeBleu_score": 63.891170577093014}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t// Lock the mutex to ensure thread safety\n\td.valueMutex.Lock()\n\t// Sleep for the delay per step\n\ttime.Sleep(d.getDelayPerStep())\n\t// Perform the step\n\terr := d.digitalWrite(d.stepPin, gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Update the step number\n\tif d.direction == clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\t// Unlock the mutex\n\td.valueMutex.Unlock()\n\treturn nil\n}", "CodeBleu_score": 65.17300253879507}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\n\treturn nil\n}", "CodeBleu_score": 68.2114057082292}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\n\treturn nil\n}", "CodeBleu_score": 67.93800781673805}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 68.2114057082292}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp int64\n\treturn func(pin int, duration time.Duration, edge string, tick uint32, timestamp uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = int64(timestamp)\n\t\t} else if edge == \"falling\" {\n\t\t\td.durationChannel <- time.Duration(int64(timestamp) - startTimestamp)\n\t\t}\n\t}\n}", "CodeBleu_score": 37.62389470570835}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp time.Duration\n\treturn func(pin int, value time.Duration, edge string, tick uint32, timestamp uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = timestamp\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := timestamp - startTimestamp\n\t\t\td.durationChan <- duration\n\t\t\tstartTimestamp = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 53.561663786782}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, source string, count uint32, pinState uint32) {\n\t\tif pinState == 1 {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else {\n\t\t\tduration = time.Since(startTimestamp)\n\t\t\td.distanceChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 37.88614976776127}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\td.measureMutex.Unlock()\n\tdefer d.measureMutex.Unlock()\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\td.measureMutex.Unlock()\n\tdefer d.measureMutex.Unlock()\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\td.measureMutex.Unlock()\n\tdefer d.measureMutex.Unlock()\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\td.measureMutex.Unlock()\n\tdefer d.measureMutex.Unlock()\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\td.measureMutex.Unlock()\n\tdefer d.measureMutex.Unlock()\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\td.measureMutex.Unlock()\n\tdefer d.measureMutex.Unlock()\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\td.measureMutex.Unlock()\n\tdefer d.measureMutex.Unlock()\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\td.measureMutex.Unlock()\n\tdefer d.measureMutex.Unlock()\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()", "CodeBleu_score": 23.767394099425566}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\t// Wait for the sensor to measure the distance\n\tselect {\n\tcase <-d.measureTrigger:\n\t\treturn nil\n\tcase <-time.After(d.measureTimeout):\n\t\treturn errors.New(\"timeout waiting for measurement\")\n\t}\n}", "CodeBleu_score": 28.76780956181875}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\tselect {\n\tcase <-d.measureComplete:\n\t\td.measureTime = time.Since(d.measureStart)\n\t\treturn nil\n\tcase <-time.After(d.measureTimeout):\n\t\treturn fmt.Errorf(\"timeout waiting for measurement to complete\")\n\t}\n}", "CodeBleu_score": 41.628396724735055}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\ttoken = self.get_env_var(\"AUTH_TOKEN\")\n    if token:\n        return token\n    access_token = self.get_state_item(\"access_token\")\n    if access_token:\n        expires_at = self.get_state_item(\"expires_at\")\n        if expires_at is not None and expires_at > time.time():\n            return access_token\n        refresh_token = self.get_state_item(\"refresh_token\")\n        if refresh_token:\n            response = self.fetch_json_data(\n                \"POST\",\n                self.get_env_var(\"AUTH_URL\"),\n                json={\n                    \"refresh_token\": refresh_token,\n                    \"client_id\": self.get_env_var(\"CLIENT_ID\"),\n                    \"client_secret\": self.get_env_var(\"CLIENT_SECRET\"),\n                    \"grant_type\": \"refresh_token\",\n                },\n            )\n            access_token = response[\"access_token\"]\n            expires_in = response[\"expires_in\"]\n            expires_at = time.time() + expires_in\n            self.set_state_item(\"access_token\", access_token)\n            self.set_state_item(\"expires_at\", expires_at)\n            return access_token\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 44.906680500567575}, {"code": "def fetch_authentication_token(self)\n\t# Check if the token is available in the environment variables.\n    token = os.environ.get(\"AUTHENTICATION_TOKEN\")\n    if token:\n        return token\n    # Check if the token is available in the local state.\n    token = self.get_state_item(\"access_token\")\n    if token:\n        expiration_time = self.get_state_item(\"expiration_time\")\n        if expiration_time is None or expiration_time > time.time():\n            return token\n        # The access token is expired. Check if a refresh token is available.\n        refresh_token = self.get_state_item(\"refresh_token\")\n        if refresh_token:\n            # Attempt to fetch a new access token using the refresh token.\n            response = self.post(\n                \"/token\",\n                data={\n                    \"grant_type\": \"refresh_token\",\n                    \"refresh_token\": refresh_token,\n                    \"client_id\": self.client_id,\n                    \"client_secret\": self.client_secret,\n                },\n            )\n            # Update the local state with the new authentication data.\n            self.set_state_item(\"access_token\", response[\"access_token\"])\n            self.set_state_item(\"expiration_time\", response[\"expires_in\"])\n            self.set_state_item(\"refresh_token\", response[\"refresh_token\"])\n            return response[\"access_token\"]\n    # Raise an exception if all methods fail.\n    raise AccountNotAuthorized(\n        \"No authentication token available. \"\n        \"Please run 'account authorize' to authorize your account.\"\n    )\n\n", "CodeBleu_score": 45.00440510190433}, {"code": "def fetch_authentication_token(self)\n\ttry:\n        return os.environ[\"AUTH_TOKEN\"]\n    except KeyError:\n        pass\n\n    try:\n        token_data = self.get_state_item(\"token_data\")\n        if (\n            token_data\n            and time.time() < token_data[\"expires_at\"]\n            and token_data[\"access_token\"]\n        ):\n            return token_data[\"access_token\"]\n    except KeyError:\n        pass\n\n    try:\n        token_data = self.get_state_item(\"token_data\")\n        if token_data and token_data[\"refresh_token\"]:\n            token_data = self.refresh_access_token(token_data[\"refresh_token\"])\n            self.set_state_item(\"token_data\", token_data)\n            return token_data[\"access_token\"]\n    except KeyError:\n        pass\n\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 35.4029360596811}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\trefresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post_request(\"v1/logout\", {\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 46.73061560171563}, {"code": "def logout(self)\n\trefresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            method=\"POST\",\n            endpoint=\"/v1/logout\",\n            json_data={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 58.16848694933302}, {"code": "def logout(self)\n\trefresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            url=self.endpoints[\"logout\"],\n            headers={\"Authorization\": \"Bearer \" + refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 53.28427843857878}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\tused_packages = []\n    for pkg in self.packages:\n        if not pkg.is_optional:\n            pkg_info = {\n                'name': pkg.name,\n                'version': pkg.version,\n            }\n            if pkg.is_external:\n                pkg_info['source'] = pkg.source\n            used_packages.append(pkg_info)\n    return used_packages\n\n", "CodeBleu_score": 28.3387381517196}, {"code": "def dump_used_packages(self)\n\tresult = []\n    for package in self.pm.get_packages():\n        if package.is_optional():\n            continue\n        info = {\n            \"name\": package.name,\n            \"version\": package.version,\n        }\n        if package.is_external():\n            info[\"source\"] = package.source\n        result.append(info)\n    return result\n\n", "CodeBleu_score": 33.21851896703518}, {"code": "def dump_used_packages(self)\n\tresult = []\n    for name in self.get_used_packages():\n        pkg = self.get_package(name)\n        if not pkg.optional:\n            item = {'name': name, 'version': pkg.version}\n            if pkg.external:\n                item['source'] = pkg.source\n            result.append(item)\n    return result\n\n", "CodeBleu_score": 33.51172501140899}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tplatform = cls.get_platform_spec(env)\n    if not platform:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.project_env = env\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 25.509217882405732}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tplatform_spec = cls.get_platform_spec(env)\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.project_env = env\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 26.42998718481219}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\ttry:\n        platform = cls.get_platform_spec(env)\n    except configparser.Error as e:\n        raise UndefinedEnvPlatformError(env, str(e))\n    instance = cls(platform, autoinstall)\n    instance.set_project_env(env)\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 33.90624335480842}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 78.48483205243677}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 86.47260632095085}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 86.47260632095085}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.3181116932034}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        EnableTimerWakeUp(time_in_us);\n    } else {\n        DisableTimerWakeUp();\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 53.764952007675916}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.3181116932034}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n    int y = scroll_y;\n    tft.fillRect(0, y, tft.width(), tft.height() - y, color);\n    scroll_y += tft.fontHeight();\n    if (scroll_y >= tft.height() - tteBar) {\n      scroll_y = tteBar;\n    }\n    scrollAddress(scroll_y);\n    return y;\n  #endif\n}", "CodeBleu_score": 18.20940800778626}, {"code": "int Display::scroll_line(uint32_t color){\n\t// Store the current y-coordinate\n  int y = _y;\n  // Fill a rectangle at the current y-coordinate with the specified color\n  tft.fillRect(0, y, _width, _line_space, color);\n  // Increment the y-coordinate by the height of a text line\n  _y += _line_space;\n  // Wrap around if the y-coordinate exceeds the display boundaries minus the bottom fixed area\n  if (_y >= _height - _bottom_fixed_area) {\n    _y = _top_fixed_area;\n  }\n  // Use alternative top fixed area coordinates if a specific condition is met\n  if (_y == _top_fixed_area && tteBar) {\n    _y = _top_fixed_area_alt;\n  }\n  // Update the scroll address\n  scrollAddress(_y);\n  // Return the previous y-coordinate\n  return y;\n}", "CodeBleu_score": 24.436967354999677}, {"code": "int Display::scroll_line(uint32_t color){\n\tint y = scroll_y;\n  scroll_y += textsize*8;\n  if (scroll_y >= (tft.height() - bottom_fixed_area)) {\n    scroll_y = top_fixed_area;\n  }\n  tft.fillRect(0, y, tft.width(), textsize*8, color);\n  scrollAddress(scroll_y);\n  return y;\n}", "CodeBleu_score": 17.041892248067334}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t// wait for flipper input to get config index\n  this->startAP();\n\n  this->ssids = ssids;\n  this->access_points = access_points;\n\n  this->setHtml();\n\n  this->runServer = true;\n\n  return true;\n}", "CodeBleu_score": 53.803264101713324}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tif (ssids->size() == 0 || access_points->size() == 0) {\n    return false;\n  }\n\n  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setAP()) {\n    return false;\n  }\n\n  if (!this->setHTML()) {\n    return false;\n  }\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 56.66978759908592}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  // set HTML content\n  if (!this->setHtml()) {\n    return false;\n  }\n\n  // set access points\n  if (!this->setAP()) {\n    return false;\n  }\n\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 61.6317923640472}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n        this->flush_queue();\n    } else {\n        this->new_queue = new std::queue<std::string>();\n        this->text = \"\";\n        this->text_in = \"\";\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 25.372412051494635}, {"code": "void GpsInterface::enable_queue(){\n\t// If the queue is already enabled, ensure that the queue, text, and text_in are initialized.\n    if (this->queue_enabled_flag) {\n        this->flush_queue();\n        this->new_queue = false;\n    }\n\n    // If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true.\n    else {\n        this->flush_queue();\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 27.316835621352443}, {"code": "void GpsInterface::enable_queue(){\n\tif (this->queue_enabled_flag) {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t} else {\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 18.090497827855927}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\tif (this->queue != NULL) {\n        this->new_queue = new Queue<NMEASentence>();\n        delete this->queue;\n        this->queue = this->new_queue;\n        this->new_queue = NULL;\n    } else {\n        this->new_queue = new Queue<NMEASentence>();\n        this->queue = this->new_queue;\n        this->new_queue = NULL;\n    }\n}", "CodeBleu_score": 21.253808643386222}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (this->queue != nullptr) {\n        this->new_queue = new std::queue<std::string>();\n        delete this->queue;\n        this->queue = this->new_queue;\n    } else {\n        this->new_queue = new std::queue<std::string>();\n        this->queue = this->new_queue;\n    }\n}", "CodeBleu_score": 20.617618797366678}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t// If the queue exists and contains elements, create a new queue and delete the old one\n\tif(this->queue != NULL && !this->queue->empty()) {\n\t\tthis->new_queue = new std::queue<std::string>();\n\t\tdelete this->queue;\n\t\tthis->queue = this->new_queue;\n\t\tthis->new_queue = NULL;\n\t}\n\t// If the queue does not exist, create a new queue\n\telse if(this->queue == NULL) {\n\t\tthis->queue = new std::queue<std::string>();\n\t}\n}", "CodeBleu_score": 19.599367839599235}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t x, y;\n    uint16_t w = (area->x2 - area->x1 + 1);\n    uint16_t h = (area->y2 - area->y1 + 1);\n    uint16_t buf_w = w;\n    uint16_t buf_h = h;\n    uint16_t buf_size = buf_w * buf_h;\n    uint16_t x_act;\n    uint16_t y_act;\n    uint16_t x_min = area->x1;\n    uint16_t y_min = area->y1;\n    uint16_t x_max = area->x2;\n    uint16_t y_max = area->y2;\n    uint32_t size = w * h;\n    uint32_t size_left = size;\n\n    display_obj.tft.startWrite\n\n    display_obj.tft.setAddrWindow(x_min, y_min, x_max, y_max);\n\n    display_obj.tft.writeColor\n\n    display_obj.tft.endWrite\n\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 49.55361477827126}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t w = (area->x2 - area->x1 + 1);\n    uint16_t h = (area->y2 - area->y1 + 1);\n\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    display_obj.tft.writePixels(color_p, w * h);\n    display_obj.tft.endWrite();\n\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 48.99675819348713}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t w = (area->x2 - area->x1 + 1);\n    uint16_t h = (area->y2 - area->y1 + 1);\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    display_obj.tft.writePixels(color_p, w * h);\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 49.132014673597865}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t// Iterate through all nodes in the menu\n  for (int i = 0; i < menu->list->size; i++) {\n    // Print the node name with indentation\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\"  \");\n    }\n    Serial.println(menu->list->get(i)->name);\n    // If the node has children, show the submenu\n    if (menu->list->get(i)->hasChildren()) {\n      showMenuList(menu->list->get(i)->subMenu, layer + 1);\n    }\n  }\n  // Print a line break\n  Serial.println();\n}", "CodeBleu_score": 60.93447932177857}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tif (menu == NULL) {\n    return;\n  }\n  Menu * currentMenu = menu->getFirstChild();\n  while (currentMenu != NULL) {\n    for (int i = 0; i < layer; i++) {\n      Serial.print(\"  \");\n    }\n    Serial.println(currentMenu->getName());\n    showMenuList(currentMenu, layer + 1);\n    currentMenu = currentMenu->getNextSibling();\n  }\n}", "CodeBleu_score": 50.27786016865362}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tMenu * currentMenu = menu;\n  while (currentMenu != NULL) {\n    for (int i = 0; i < layer; i++) {\n      Serial.print(\"  \");\n    }\n    Serial.println(currentMenu->getName());\n    showMenuList(currentMenu->getList(), layer + 1);\n    currentMenu = currentMenu->getNext();\n  }\n}", "CodeBleu_score": 51.769114386467805}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\tSerial.println(\"Generating SSIDs...\");\n  int generated = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = randomSSID();\n    int channel = random(1, 14);\n    String mac = randomMAC();\n    ssids->add(new WiFiNetwork(ssid, channel, mac));\n    Serial.println(ssid);\n    generated++;\n  }\n  return generated;\n}", "CodeBleu_score": 37.7863160825156}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tSerial.println(F(\"Generating SSIDs...\"));\n  for (int i = 0; i < count; i++) {\n    char ssid[7];\n    for (int j = 0; j < 6; j++) {\n      ssid[j] = random(97, 123);\n    }\n    ssid[6] = '\\0';\n    int channel = random(1, 12);\n    String mac = generateMAC();\n    ssids->add(new SSID(ssid, channel, mac));\n    Serial.println(ssids->get(i)->toString());\n  }\n  return ssids->size();\n}", "CodeBleu_score": 43.15839068157121}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tif (count <= 0) {\n    return 0;\n  }\n  Serial.println(\"Generating SSIDs...\");\n  for (int i = 0; i < count; i++) {\n    String ssid = random(100000, 999999);\n    ssid = \"ESP\" + ssid;\n    int channel = random(1, 14);\n    String mac = randomMAC();\n    ssids->add(new SSID(ssid, mac, channel));\n    Serial.println(ssid);\n  }\n  return count;\n}", "CodeBleu_score": 39.00457381502679}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\ttoken = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 58.84444930080678}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\timport jwt\n    import datetime\n    import os\n\n    # Set the issued time (iat) to the current UTC time\n    iat = datetime.datetime.utcnow()\n\n    # Set the expiration time (exp) to one hour later\n    exp = iat + datetime.timedelta(hours=1)\n\n    # Set the audience (aud) field to the provided GCP project ID\n    aud = project_id\n\n    # Read the private key from the specified file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT\n    jwt_token = jwt.encode({\n        'iat': iat,\n        'exp': exp,\n        'aud': aud\n    }, private_key, algorithm=algorithm)\n\n    # Return the encoded JWT\n    return jwt_token\n\n", "CodeBleu_score": 55.45436211730318}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\ttoken = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    logger.debug('private_key is {0} and type is {1}'.format(private_key, type(private_key)))\n\n    logger.info('Creating JWT using {0} algorithm ...'.format(algorithm))\n\n    encoded_jwt = jwt.encode(token, private_key, algorithm=algorithm)\n\n    return encoded_jwt", "CodeBleu_score": 66.28830162608617}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        with tempfile.NamedTemporaryFile() as f:\n            preview_capture(f.name)\n            url = upload_file(f.name, args.bucket_name)\n            print('URL: {}'.format(url))\n            mqtt_publish(client, 'events', url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 47.90062640952175}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        print('Capturing preview image')\n        path = '/home/pi/Desktop/image.jpg'\n        preview_capture(path)\n        print('Uploading file')\n        url = upload_file(path, args.bucket_name)\n        print('Publishing URL')\n        publish_event(client, url)\n    else:\n        print('off')\n", "CodeBleu_score": 46.96952394202597}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        print('Capturing image')\n        path = '/home/pi/Desktop/image.jpg'\n        preview_capture(path)\n        print('Uploading image')\n        bucket_name = 'pi-camera-1553028133996'\n        url = upload_file(path, bucket_name)\n        print('Publishing URL')\n        mqtt_publish(client, 'events', url)\n        print('Finished!')\n    else:\n        print('off')\n\n", "CodeBleu_score": 46.95241781192196}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT example.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT Core registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT Core device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\", required=True, help=\"Path to private key file.\"\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root certificate from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", default=8883, help=\"MQTT bridge port.\"\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=20,\n        type=int,\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n    )\n    return parser.parse_args()\n\n", "CodeBleu_score": 39.85096435563649}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection example.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help='GCP cloud project name')\n    parser.add_argument('--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', required=True, help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root certificate from https://pki.google.com/roots.pem')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', choices=(8883, 443), default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--message_type', choices=('event', 'state'), default='event', help='Indicates whether the message to be published is a telemetry event or a device state message.')\n    parser.add_argument('--subscription_name', default='', help='Cloud Pub/Sub subscription name')\n    args = parser.parse_args()\n    return args", "CodeBleu_score": 44.24698545536707}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT device connection example.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--registry_id\", required=True, help=\"Cloud IoT Core registry id\")\n    parser.add_argument(\"--device_id\", required=True, help=\"Cloud IoT Core device id\")\n    parser.add_argument(\"--private_key_file\", required=True, help=\"Path to private key file.\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), default=\"RS256\", help=\"Encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\"--ca_certs\", default=\"roots.pem\", help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", choices=(8883, 443), default=8883, type=int, help=\"MQTT bridge port.\")\n    parser.add_argument(\"--jwt_expires_minutes\", default=20, type=int, help=\"Expiration time, in minutes, for JWT tokens.\")\n    return parser.parse_args()", "CodeBleu_score": 40.96691429176529}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t# Define the necessary API scopes\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    # Define the discovery URL\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    # Define the API version\n    api_version = 'v1'\n    # Load the service account credentials\n    credentials = ServiceAccountCredentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n    # Build the client\n    client = googleapiclient.discovery.build(\n        'cloudiot', api_version, discoveryServiceUrl=discovery_url,\n        credentials=credentials)\n    return client\n\n", "CodeBleu_score": 22.284528391287044}, {"code": "def get_client(service_account_json)\n\tscopes = ['https://www.googleapis.com/auth/cloud-platform']\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    credentials = ServiceAccountCredentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n    return build(serviceName='cloudiot', version='v1',\n                 discoveryServiceUrl=discovery_url,\n                 credentials=credentials, cache_discovery=False)\n\n", "CodeBleu_score": 19.8455386204088}, {"code": "def get_client(service_account_json)\n\t# Get the API scopes, version, and discovery URL\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    # Load the service account credentials\n    credentials = ServiceAccountCredentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n\n    # Build the client\n    client = googleapiclient.discovery.build(\n        \"cloudiot\", api_version, discoveryServiceUrl=discovery_url, credentials=credentials\n    )\n\n    return client", "CodeBleu_score": 21.47004457271272}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\tasn1_code = hash_method_to_asn1_code(hash_method)\n    if asn1_code is None:\n        raise ValueError('Invalid hash method')\n    padded_hash = _pad_for_signing(hash_value, priv_key.size)\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash)\n    return encrypted_signature", "CodeBleu_score": 28.5941695220155}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# Retrieve the ASN1 code for the hash method\n    try:\n        hash_asn1 = hash_method_to_asn1[hash_method]\n    except KeyError:\n        raise ValueError(\"Invalid hash method\")\n\n    # Concatenate the ASN1 code with the hash value\n    message = hash_asn1 + hash_value\n\n    # Pad the message for signing\n    padded_message = _pad_for_signing(message, priv_key.key_size)\n\n    # Encrypt the padded message using the private key\n    encrypted_signature = priv_key.blinded_encrypt(padded_message)\n\n    # Return the encrypted signature\n    return encrypted_signature\n\n", "CodeBleu_score": 38.312277508539324}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# Retrieve the ASN1 code for the hash method.\n    # Raise an error if the hash method is invalid.\n    if hash_method == 'sha256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'sha512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method.')\n\n    # Concatenate the ASN1 code with the hash value.\n    padded_hash = asn1_code + hash_value\n\n    # Pad the result for signing.\n    padded_hash = _pad_for_signing(padded_hash, priv_key.byte_size)\n\n    # Encrypt the padded hash using the private key.\n    signature = priv_key.blinded_encrypt(padded_hash)\n\n    # Return the encrypted signature as a byte block.\n    return signature\n\n", "CodeBleu_score": 30.619657474809532}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\tclearsig = decrypt_int(signature, pub_key)\n    method_name = _find_method_hash(clearsig)\n    digest = compute_hash(message, method_name)\n    padded_digest = _pad_for_signing(digest, byte_size(pub_key))\n    if padded_digest != clearsig:\n        raise VerificationError('Verification failed')\n    return method_name\n\n", "CodeBleu_score": 21.33981800225187}, {"code": "def verify(message, signature, pub_key)\n\tclearsig = decrypt_int(signature, pub_key)\n    method_name = _find_method_hash(clearsig)\n    method = HASH_METHODS[method_name]\n    hasher = method()\n    hasher.update(message)\n    expected_padded_hash = _pad_for_signing(hasher.digest(), method().digest_size)\n    if expected_padded_hash != clearsig:\n        raise VerificationError('Verification failed')\n    return method_name\n", "CodeBleu_score": 22.7832006097554}, {"code": "def verify(message, signature, pub_key)\n\tclearsig = decrypt_int(signature, pub_key)\n    method_name = find_method_hash(clearsig)\n    hash_method = HASH_METHODS[method_name]\n    hash_value = hash_method(message).digest()\n    expected_hash = pad_for_signing(hash_value, len(clearsig))\n    if expected_hash != clearsig:\n        raise VerificationError('Verification failed')\n    return method_name\n\n", "CodeBleu_score": 21.222140321858518}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\tdebug_printInfo(\"MQTT: Connecting...\");\n   uint32_t epoch = TIME_getEpoch();\n   if(epoch != 0) {\n      updateJWT(epoch);\n   }\n   MQTT_CLIENT_connect();\n   mqttSubscribe = 1;\n}", "CodeBleu_score": 23.45517553463286}, {"code": "static void connectMQTT(){\n\tdebug_printInfo(\"MQTT: Connecting to %s\", mqttServer);\n   time_t t = CRYPTO_CLIENT_getEpoch();\n   if (t != 0) {\n      updateJWT(t);\n   }\n   MQTT_CLIENT_connect(mqttServer, mqttPort, mqttClientId, mqttUsername, mqttPassword, mqttKeepAlive, mqttCleanSession, mqttUseSSL);\n   mqttSubscribe = 1;\n}", "CodeBleu_score": 42.54139447192292}, {"code": "static void connectMQTT(){\n\ttime_t t = time(NULL);\n   if (t > 0) {\n      updateJWT(t);\n   }\n   MQTT_CLIENT_connect(mqttBroker, mqttPort, mqttClientID, mqttUsername, mqttPassword, mqttKeepAlive, mqttCleanSession, mqttWillTopic, mqttWillMessage, mqttWillRetain, mqttWillQoS, mqttPublishTopic, mqttPublishMessage, mqttPublishRetain, mqttPublishQoS, mqttSubscribeTopic, mqttSubscribeQoS);\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 46.24599129858416}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t n = 0;\n\twhile (width--) {\n\t\tif (*str < '0' || *str > '9')\n\t\t\treturn str;\n\t\tn = n * 10 + *str++ - '0';\n\t}\n\t*num = n;\n\treturn str;\n}", "CodeBleu_score": 25.249851197508466}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9') {\n            return str - 1;\n        }\n        n = 10 * n + c - '0';\n    }\n    *num = n;\n    return str;\n}", "CodeBleu_score": 23.820827959287765}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t value = 0;\n    int i;\n\n    for(i = 0; i < width; i++) {\n        uint8_t c = *str;\n        if(c < '0' || c > '9')\n            return str;\n        value = value * 10 + (c - '0');\n        str++;\n    }\n\n    *num = value;\n    return str;\n}", "CodeBleu_score": 25.14722116674777}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    uint8_t cert_sn[32];\n    size_t cert_sn_size = 0;\n    uint8_t issue_date[DATEFMT_ISO8601_SEP] = { 0 };\n    uint8_t expire_date[DATEFMT_ISO8601_SEP] = { 0 };\n    atcacert_tm_utc_t issue_date_tm;\n    atcacert_tm_utc_t expire_date_tm;\n    size_t expire_years = 0;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Finish building the certificate\n    ret = atcacert_set_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_SIGNATURE], build_state->cert, build_state->cert_size, build_state->signature, build_state->signature_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Generate the certificate serial number\n    ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Get the certificate serial number\n    cert_sn_size = build_state->cert_def->std_cert_elements[STDCERT_CERT_SN].count;\n    ret = atcacert_get_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_CERT_SN], build_state->cert, build_state->cert_size, cert_sn, &cert_sn_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;", "CodeBleu_score": 61.68924450492737}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    atcacert_device_loc_t device_locs[16];\n    size_t device_locs_count = 0;\n    uint8_t issue_date_format = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[72];\n    size_t signature_size = 0;\n    size_t i;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->type == CERTTYPE_X509)\n    {\n        issue_date_format = build_state->cert_def->std_cert_elements[STDCERT_ISSUE_DATE].format;\n    }\n    else\n    {\n        issue_date_format = DATEFMT_ISO8601_SEP;\n    }\n\n    // Finish out any dynamic cert elements\n    if (build_state->cert_def->cert_sn_dev_loc.zone != DEVZONE_NONE)\n    {\n        ret = atcacert_get_device_locs(build_state->cert_def, device_locs, &device_locs_count);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        for (i = 0; i < device_locs_count; i++)\n        {\n            if (build_state->cert_def->cert_sn_dev_loc.zone == device_locs[i].zone\n                && build_state->cert_def->cert_sn_dev_loc.slot == device_locs[i].slot\n                && build_state->cert_def->cert_sn_dev_loc.is_genkey == device_locs[i].is_genkey)\n            {\n                break;\n            }\n        }\n        if (i == device_locs_count)\n        {\n            return ATCACERT_E_BAD_PARAMS; // SN device location wasn't found", "CodeBleu_score": 56.30992867164686}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    uint8_t issue_date_raw[DATEFMT_ISO8601_SEP_LEN];\n    atcacert_tm_utc_t issue_date;\n    uint8_t expire_years;\n    uint8_t enc_dates[7];\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_date_enc_iso8601_sep(build_state->issue_date, issue_date_raw);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n    ret = atcacert_date_dec_iso8601_sep(issue_date_raw, &issue_date);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    ret = atcacert_date_enc_compcert(&issue_date, build_state->expire_years, enc_dates);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    ret = atcacert_set_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_ISSUE_DATE], build_state->cert, build_state->cert_size, enc_dates, 3);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    ret = atcacert_set_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_EXPIRE_DATE], build_state->cert, build_state->cert_size, &enc_dates[3], 4);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    return atcacert_gen_cert_sn(build_state->cert_", "CodeBleu_score": 60.52006755337964}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                     ret = 0;\n  uint8_t                 tbs_digest[32];\n  uint8_t                 signature[64];\n  uint8_t                 public_key[64];\n  uint8_t                 is_verified = 0;\n  const atcacert_device_loc_t* ca_public_key_dev_loc = &cert_def->ca_cert_def->public_key_dev_loc;\n  atcacert_device_loc_t   tbs_digest_dev_loc;\n  atcacert_device_loc_t   signature_dev_loc;\n  atcacert_device_loc_t   public_key_dev_loc;\n\n  do {\n    // Check the inputs\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n      ret = ATCACERT_E_BAD_PARAMS;\n      BREAK(ret, \"Bad input parameters\");\n    }\n\n    // Get the TBS digest\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n      BREAK(ret, \"Unable to get TBS digest\");\n    }\n\n    // Get the signature\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n      BREAK(ret, \"Unable to get signature\");\n    }\n\n    // Get the public key\n    ret = atcacert_get_device_locs(cert_def, &tbs_digest_dev_loc, &signature_dev_loc, &public_key_dev_loc);\n    if (ret != ATCACERT_E_SUCCESS) {\n      BREAK(ret, \"Unable to get device locations\");\n    }\n\n    ret = atcab_read_pubkey(ca_public_key_dev_loc->zone, ca_public_key", "CodeBleu_score": 62.59054207404269}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    uint8_t public_key[72];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Retrieve the TBS digest and signature from the certificate\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Convert the CA public key into the format expected by the ATECC hardware\n    ret = atcacert_public_key_add_padding(ca_public_key, public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature using the CA public key\n    ret = atcab_verify_extern(tbs_digest, signature, public_key, NULL);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 83.97942897614668}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                 ret = 0;\n  uint8_t             tbs_digest[32];\n  const uint8_t*      signature = NULL;\n  size_t              signature_size = 0;\n  const uint8_t*      ca_public_key_x = NULL;\n  const uint8_t*      ca_public_key_y = NULL;\n  atcacert_device_loc_t ca_public_key_device_loc;\n\n  if (cert_def == NULL || cert == NULL || ca_public_key == NULL)\n    return ATCACERT_E_BAD_PARAMS;\n\n  ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n  if (ret != ATCACERT_E_SUCCESS)\n    return ret;\n\n  ret = atcacert_get_signature(cert_def, cert, cert_size, &signature, &signature_size);\n  if (ret != ATCACERT_E_SUCCESS)\n    return ret;\n\n  ret = atcacert_get_device_locs(cert_def,\n                                 ca_public_key,\n                                 ca_public_key_device_loc,\n                                 &ca_public_key_x,\n                                 &ca_public_key_y);\n  if (ret != ATCACERT_E_SUCCESS)\n    return ret;\n\n  ret = atcab_verify_extern(tbs_digest, signature, ca_public_key_device_loc);\n  if (ret != ATCACERT_E_SUCCESS)\n    return ret;\n\n  return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 68.47092503452016}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif (timer == NULL)\n    {\n        return false;\n    }\n\n    if (*list == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *listHead = *list;\n\n    while (listHead != NULL)\n    {\n        if (listHead->next == timer)\n        {\n            listHead->next = timer->next;\n            return true;\n        }\n        listHead = listHead->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 35.108883211676044}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t// NOTE: listHead must NOT equal NULL at this point.\n    // NOTE: timer must NOT equal NULL at this point.\n\n    timerStruct_t *current = *list;\n\n    if(current == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    while(current->next != NULL)\n    {\n        if(current->next == timer)\n        {\n            current->next = timer->next;\n            return true;\n        }\n        current = current->next;\n    }\n    return false;\n}", "CodeBleu_score": 27.21406746380426}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\ttimerStruct_t * volatile *current = list;\n    bool isDeleted = false;\n\n    while (*current != NULL)\n    {\n        if (*current == timer)\n        {\n            *current = timer->next;\n            isDeleted = true;\n        }\n        else\n        {\n            current = &((*current)->next);\n        }\n    }\n\n    return isDeleted;\n}", "CodeBleu_score": 28.87950286668741}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tint ret = BSD_SUCCESS;\n\t\n\tif(socket < 0 || socket >= MAX_SOCKET) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tif(gastrSockets[socket].bIsUsed == 1) {\n\t\tsint8 s8Ret = close(socket);\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR) {\n\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\t\n\treturn ret;\n}", "CodeBleu_score": 31.651496579555104}, {"code": "int BSD_close(int socket){\n\tint ret = 0;\n\tif (socket < 0 || socket >= MAX_SOCKET) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn -1;\n\t}\n\tif (gastrSockets[socket].bIsUsed == 1) {\n\t\tret = close(socket);\n\t\tif (ret == SOCK_ERR_NO_ERROR) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tbsd_setErrNo(EIO);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 21.41291939135022}, {"code": "int BSD_close(int socket){\n\tint ret = BSD_SUCCESS;\n\tif (socket < 0 || socket >= MAX_SOCKET) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\tif (gastrSockets[socket].bIsUsed == 1) {\n\t\tint8 ret = close(socket);\n\t\tif (ret != SOCK_ERR_NO_ERROR) {\n\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 31.776940252136722}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint result = listen(socket, backlog);\n\tif (result != SOCK_ERR_NO_ERROR) {\n\t\terrno = bsdErrorNumber;\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 20.8434983664998}, {"code": "int BSD_listen(int socket, int backlog){\n\tint ret;\n\t\n\tret = listen(socket, backlog);\n\tif (ret == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t} else {\n\t\tbsd_setErrNo(ret);\n\t\treturn BSD_ERROR;\n\t}\n}", "CodeBleu_score": 29.48611163186022}, {"code": "int BSD_listen(int socket, int backlog){\n\tint ret;\n\n\tret = listen(socket, backlog);\n\tif (ret != SOCK_ERR_NO_ERROR) {\n\t\tbsd_setErrNo(ret);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 26.907890984887278}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tsint8\t\t\t\t\t\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\tstruct sockaddr\t\t\t\t\t\t\tstrAddr;\n\tuint8\t\t\t\t\t\t\t\t\tu8AddrLen;\n\t\n\tif(socket < 0) {\n\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t} else {\n\t\tu8AddrLen = (uint8)*addrlen;\n\t\ts8Ret = accept(socket, &strAddr, &u8AddrLen);\n\t\tif(s8Ret == SOCK_ERR_NO_ERROR) {\n\t\t\tif(addr != NULL) {\n\t\t\t\tmemcpy(addr, &strAddr, u8AddrLen);\n\t\t\t\t*addrlen = u8AddrLen;\n\t\t\t}\n\t\t} else {\n\t\t\tbsd_setErrNo(s8Ret);\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 30.233392657381764}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint", "CodeBleu_score": 6.7284050411130805}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 12.182170557362593}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\tif (MQTT_CLIENT_isConnected()) {\n      debug_printError(\"MQTT: Already connected\");\n      return;\n   }\n   time_t epoch = time(NULL);\n   if (epoch < 0) {\n      debug_printError(\"MQTT: Invalid time\");\n      return;\n   }\n   updateJWT(epoch);\n   MQTT_CLIENT_connect(mqttBroker, mqttPort, mqttClientId, mqttUsername, mqttPassword, mqttKeepalive, mqttCleanSession, mqttWillTopic, mqttWillMessage, mqttWillQos, mqttWillRetain, mqttConnectedCb, mqttSubscribedCb, mqttPublishedCb, mqttDataCb);\n   debug_printInfo(\"MQTT: Connecting\");\n}", "CodeBleu_score": 46.59864689002118}, {"code": "static void connectMQTT(){\n\tdebug_printInfo(\"MQTT: Connecting to MQTT broker\");\n    uint32_t epoch = CRYPTO_CLIENT_getEpoch();\n    if (epoch > 0) {\n        updateJWT(epoch);\n        MQTT_CLIENT_connect(mqttBroker, mqttPort, mqttClientID, mqttUsername, mqttPassword, mqttKeepAlive, mqttCleanSession, mqttWillTopic, mqttWillMessage, mqttWillQoS, mqttWillRetain);\n        debug_printInfo(\"MQTT: MQTT connection started\");\n        mqttSubscribe = 1;\n    } else {\n        debug_printError(\"MQTT: Failed to get time from NTP server\");\n    }\n}", "CodeBleu_score": 43.4925293320072}, {"code": "static void connectMQTT(){\n\ttime_t t = time(NULL);\n   if (t < 0) {\n      debug_printError(\"MQTT: Failed to get time\");\n      return;\n   }\n   updateJWT(t);\n   MQTT_CLIENT_connect();\n}", "CodeBleu_score": 27.378463652789563}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tdebug_printInfo(\"CLOUD: Disconnecting from the cloud service\");\n\n   if (MQTT_GetConnectionState() == CONNECTED) {\n      mqttContext* connectionInfo = MQTT_GetClientConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n   }\n}", "CodeBleu_score": 66.87735119899739}, {"code": "void CLOUD_disconnect(void){\n\tif (cloudState == CONNECTED) {\n      debug_printError(\"CLOUD: Disconnecting...\");\n      mqttState = MQTT_Disconnect(&mqttContext);\n      cloudState = DISCONNECTED;\n   }\n}", "CodeBleu_score": 52.39581966632536}, {"code": "void CLOUD_disconnect(void){\n\tif (CLOUD_isConnected()) {\n      debug_printInfo(\"CLOUD: Disconnecting from the cloud service\");\n\n      mqttContext* mqttConnectionInfo = MQTT_GetClientConnectionInfo();\n      MQTT_Disconnect(mqttConnectionInfo);\n   }\n}", "CodeBleu_score": 28.167800324751713}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tbool ret = false;\n\tif (passed_wifi_creds) {\n\t\t// Connect to the Wi-Fi access point using the credentials provided\n\t\tif (M2M_SUCCESS == m2m_wifi_connect((char *)wifi_creds.ssid, strlen((char *)wifi_creds.ssid),\n\t\t\t\t\t\t\t\t\t\t\twifi_creds.auth_type, (void *)wifi_creds.password,\n\t\t\t\t\t\t\t\t\t\t\tM2M_WIFI_CH_ALL)) {\n\t\t\tret = true;\n\t\t} else {\n\t\t\t// Log an error message\n\t\t\tAT_LOG(\"wifi_connectToAp\", \"Wi-Fi connection failed\");\n\t\t\t// Update the networking error status\n\t\t\tnetworking_error = ERROR_WIFI_CONNECTION_FAILED;\n\t\t}\n\t} else {\n\t\t// Connect to the Wi-Fi access point using the default credentials\n\t\tif (M2M_SUCCESS == m2m_wifi_default_connect()) {\n\t\t\tret = true;\n\t\t} else {\n\t\t\t// Log an error message\n\t\t\tAT_LOG(\"wifi_connectToAp\", \"Wi-Fi connection failed\");\n\t\t\t// Update the networking error status\n\t\t\tnetworking_error = ERROR_WIFI_CONNECTION_FAILED;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 42.076915377864296}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tbool wifi_connected = false;\n\tif (passed_wifi_creds) {\n\t\t// Connect to the Wi-Fi access point using the new credentials.\n\t\t// If the connection fails, log an error message, update the networking error status, and return false.\n\t\tif (M2M_SUCCESS != m2m_wifi_connect((char *)wifi_ssid, strlen(wifi_ssid), M2M_WIFI_SEC_WPA_PSK, (void *)wifi_pass, M2M_WIFI_CH_ALL)) {\n\t\t\tprintf(\"main: failed to connect to the AP %s\\r\n\", wifi_ssid);\n\t\t\twifi_connected = false;\n\t\t}\n\t\telse {\n\t\t\tprintf(\"main: connecting to the AP %s\\r\n\", wifi_ssid);\n\t\t\twifi_connected = true;\n\t\t}\n\t}\n\telse {\n\t\t// Connect to the Wi-Fi access point using the default credentials.\n\t\t// If the connection fails, log an error message, update the networking error status, and return false.\n\t\tif (M2M_SUCCESS != m2m_wifi_default_connect()) {\n\t\t\tprintf(\"main: failed to connect to the default AP\\r\n\");\n\t\t\twifi_connected = false;\n\t\t}\n\t\telse {\n\t\t\tprintf(\"main: connecting to the default AP\\r\n\");\n\t\t\twifi_connected = true;\n\t\t}\n\t}\n\treturn wifi_connected;\n}", "CodeBleu_score": 41.100647147624734}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tif(passed_wifi_creds == 1) {\n\t\t// Connect to the Wi-Fi access point using the credentials provided by the user\n\t\t// If the connection fails, log an error message, update the networking error status, and return false\n\t\t// If the connection succeeds, return true\n\t\t\n\t\t// Get the SSID, authentication type, and password from the user\n\t\tchar ssid[M2M_MAX_SSID_LEN];\n\t\tuint8_t ssid_len = M2M_MAX_SSID_LEN;\n\t\tuint8_t sec_type;\n\t\tchar password[M2M_MAX_PSK_LEN];\n\t\tuint8_t password_len = M2M_MAX_PSK_LEN;\n\t\t\n\t\t// Read the SSID from the user\n\t\tprintf(\"Enter the SSID of the Wi-Fi access point: \");\n\t\tscanf(\"%s\", ssid);\n\t\t\n\t\t// Read the authentication type from the user\n\t\tprintf(\"Enter the authentication type (1 for Open, 2 for WEP, 3 for WPA, 4 for WPA2, 5 for WPA/WPA2): \");\n\t\tscanf(\"%hhu\", &sec_type);\n\t\t\n\t\t// Read the password from the user\n\t\tprintf(\"Enter the password of the Wi-Fi access point: \");\n\t\tscanf(\"%s\", password);\n\t\t\n\t\t// Connect to the Wi-Fi access point\n\t\tsint8 ret = m2m_wifi_connect(ssid, ssid_len, sec_type, password, M2M_WIFI_CH_ALL);\n\t\t\n\t\t// If the connection fails, log an error message, update the networking error status, and return false\n\t\tif(ret != M2M_SUCCESS) {\n\t\t\tprintf(\"Failed to connect to the Wi-Fi access point!\\r", "CodeBleu_score": 37.007637068219694}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tconst client = generateClient();\n    const response = await client.graphql(\n        `query {\n            listSensors {\n                sensorId\n                geo {\n                    latitude\n                    longitude\n                }\n            }\n        }`\n    );\n    console.log(response);\n    if (response.data.listSensors.length > 0) {\n        console.log(\"Retrieved sensors:\");\n        response.data.listSensors.forEach(sensor => {\n            const marker = document.createElement(\"div\");\n            marker.classList.add(\"marker\");\n            new mapboxgl.Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n            console.log(sensor);\n        });\n    }\n}", "CodeBleu_score": 53.351148578059515}, {"code": "async function DisplaySensors(map){\n\t// Generate a client\n    const client = generateClient();\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.graphql(`\n        query {\n            listSensors {\n                id\n                name\n                geo {\n                    longitude\n                    latitude\n                }\n            }\n        }\n    `);\n    // Log the API response\n    console.log(response);\n    // If the response contains data, log the retrieval of sensors and iterate through each sensor\n    if (response.data.listSensors.length > 0) {\n        console.log(`Retrieved ${response.data.listSensors.length} sensors.`);\n        response.data.listSensors.forEach((sensor) => {\n            // Create a marker for the sensor\n            const marker = document.createElement(\"div\");\n            marker.className = \"marker\";\n            marker.id = sensor.id;\n            new mapboxgl.Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 53.06762564958917}, {"code": "async function DisplaySensors(map){\n\t// Generate a client\n    const client = generateClient();\n\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.graphql(\n        `\n        query listSensors {\n            listSensors {\n                id\n                name\n                geo {\n                    latitude\n                    longitude\n                }\n                type\n                status\n            }\n        }\n        `\n    );\n\n    // Log the API response\n    console.log(response);\n\n    // If the response contains data, log the retrieval of sensors\n    if (response.data.listSensors.length > 0) {\n        console.log(\"Retrieved sensors:\");\n\n        // Iterate through each sensor\n        response.data.listSensors.forEach((sensor) => {\n            // Log the sensor\n            console.log(sensor);\n\n            // Create a marker\n            const marker = document.createElement(\"div\");\n            marker.className = \"marker\";\n\n            // Add the marker to the map\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 57.49675199827114}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tconst sensorMarker = document.createElement(\"div\");\n  sensorMarker.id = sensor.id;\n  sensorMarker.classList.add(\"sensor-marker\");\n  sensorMarker.style.backgroundColor = \"#000000\";\n  sensorMarker.style.border = \"1px solid #000000\";\n  return sensorMarker;\n}", "CodeBleu_score": 45.202822188000205}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.backgroundColor = sensor.color;\n    marker.style.border = \"2px solid black\";\n    return marker;\n}", "CodeBleu_score": 48.52498695955148}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = sensor.color;\n  marker.style.border = '1px solid black';\n  return marker;\n}", "CodeBleu_score": 45.18984013638897}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}.mfa_module\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to load mfa module %s: %s\",\n            module_name,\n            err,\n        )\n        raise HomeAssistantError(\n            f\"Unable to load mfa module {module_name}: {err}\"\n        ) from err\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module_name, module.REQUIREMENTS\n        )\n    return module\n\n", "CodeBleu_score": 51.19904136029858}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\n            \"Unable to import %s. Make sure requirements are installed\", module_path\n        )\n        raise\n    requirements = getattr(module, \"REQUIREMENTS\", [])\n    await requirements.async_process_requirements(hass)\n    return module\n\n", "CodeBleu_score": 32.19208486553734}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to import %s: %s\",\n            module_path,\n            err,\n        )\n        raise HomeAssistantError(f\"Unable to import {module_path}\") from err\n    if not hasattr(module, \"DEFAULT_CONFIG\"):\n        _LOGGER.error(\"MFA module %s does not have a DEFAULT_CONFIG\", module_path)\n        raise HomeAssistantError(f\"MFA module {module_path} has no DEFAULT_CONFIG\")\n    await requirements.async_process_requirements(\n        hass, module_path, module, \"mfa_modules\"\n    )\n    return module\n\n", "CodeBleu_score": 45.55214139785937}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data.get(\"pin\")\n    if not pin:\n        raise InvalidSetupData(\"pin not found\")\n\n    if not isinstance(pin, str):\n        raise InvalidSetupData(\"pin must be a string\")\n\n    if not pin.isdigit():\n        raise InvalidSetupData(\"pin must be a number\")\n\n    if len(pin) != 4:\n        raise InvalidSetupData(\"pin must be 4 digits\")\n\n    if user_id in self.data:\n        self.data[user_id] = {\"pin\": pin}\n        return\n\n    self.data.append({\"user_id\": user_id, \"pin\": pin})", "CodeBleu_score": 38.999662614068555}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data.get(\"pin\")\n    if not pin:\n        raise ValueError(\"PIN not found in setup data\")\n\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n\n    await self.async_save()\n\n    return {\"pin\": pin}", "CodeBleu_score": 34.026643964094525}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data.get(\"pin\")\n    if not pin:\n        raise InvalidPIN(\"No PIN provided.\")\n    if not isinstance(pin, str):\n        raise InvalidPIN(\"PIN must be a string.\")\n    if not pin.isdigit():\n        raise InvalidPIN(\"PIN must be a numeric string.\")\n    if len(pin) != 4:\n        raise InvalidPIN(\"PIN must be 4 digits long.\")\n    pin = int(pin)\n    if not 1000 <= pin <= 9999:\n        raise InvalidPIN(\"PIN must be between 1000 and 9999.\")\n    if self.data.get(user_id):\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    await self.async_save()\n    return {\"success\": True}\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 31.026761825902362}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\tasync with self._lock:\n        if self._data is not None:\n            return\n\n        self._data = await self._store.async_load() or {}\n\n        # Make sure that all settings are NotifySetting objects\n        for user_id, user_data in self._data.items():\n            if not isinstance(user_data, NotifySetting):\n                self._data[user_id] = NotifySetting(user_id, user_data)\n\n", "CodeBleu_score": 33.83636700315955}, {"code": "async def _async_load(self) -> None\n\tasync with self._lock:\n        if self._loaded:\n            return\n        if (data := await self._store.async_load()) is None:\n            data = {}\n        self._data = {\n            key: NotifySetting(self._hass, key, data.get(key, {}))\n            for key in self._hass.auth.auth_providers\n        }\n        self._loaded = True\n\n", "CodeBleu_score": 41.96919222741408}, {"code": "async def _async_load(self) -> None\n\tasync with self._lock:\n        if self._settings is not None:\n            return\n\n        data = await self._store.async_load()\n\n        if data is None:\n            data = {}\n\n        self._settings = {\n            user_id: NotifySetting(user_id, data.get(user_id, {}))\n            for user_id in self._hass.auth.async_get_users()\n        }\n\n        self._async_schedule_save()\n\n", "CodeBleu_score": 44.5018020114356}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self._async_load(user_id)\n    user_settings = self._user_settings.get(user_id)\n    if not user_settings:\n        return False\n    try:\n        return await self._hass.async_add_executor_job(\n            self._validate, user_settings, user_input\n        )\n    except vol.Invalid:\n        return False\n\n", "CodeBleu_score": 44.65403614485348}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self._async_load()\n    settings = self._settings.get(user_id)\n    if settings is None:\n        return False\n\n    return await self._hass.async_add_executor_job(\n        self._validate, settings, user_input\n    )\n\n", "CodeBleu_score": 43.11072697251811}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self.async_load(user_id)\n    settings = self.get_settings(user_id)\n    if not settings:\n        return False\n\n    # Verify OTP\n    otp = user_input.get(CONF_CODE)\n    if otp is None:\n        return False\n\n    otp = otp.strip()\n\n    if not self.async_check_code(settings, otp):\n        return False\n\n    return True\n\n", "CodeBleu_score": 46.18673519665625}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.async_get_entity(entity_id)\n    if entity_entry is None:\n        return None\n    device_id = entity_entry.device_id\n    if device_id is None:\n        return None\n    device_entry = perm_lookup.async_get_device(device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)", "CodeBleu_score": 59.45186409980292}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.entity_registry.async_get(entity_id)\n    if entity is None:\n        return None\n    device_id = entity.device_id\n    if device_id is None:\n        return None\n    device = perm_lookup.device_registry.async_get(device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)", "CodeBleu_score": 61.335449800341536}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.async_get_entity(entity_id)\n    if entity is None:\n        return None\n\n    device = perm_lookup.async_get_device(entity.device_id)\n    if device is None:\n        return None\n\n    area_id = device.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)", "CodeBleu_score": 54.27830985572816}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\treturn cast(PolicyType, _merge_policies(policies))\n\n", "CodeBleu_score": 7.399345002443108}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tpolicy: PolicyType = cast(PolicyType, {})\n    seen: set[str] = set()\n    for p in policies:\n        for cat in p:\n            if cat in seen:\n                continue\n            seen.add(cat)\n            policy[cat] = _merge_policies([p.get(cat) for p in policies])\n    return policy\n\n", "CodeBleu_score": 47.57353255078269}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\treturn cast(PolicyType, _merge_policies(policies))\n\n", "CodeBleu_score": 7.399345002443108}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to find the authentication provider module %s. Did you install the requirements?\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"Unable to find the authentication provider module {provider}\"\n        ) from err\n\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        _LOGGER.error(\n            \"The authentication provider module %s does not have a CONFIG_SCHEMA\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"The authentication provider module {provider} does not have a CONFIG_SCHEMA\"\n        )\n\n    return module\n\n", "CodeBleu_score": 37.75196378858938}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, f\"homeassistant.auth.{provider}\")\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to find the authentication provider module %s: %s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError(\n            f\"Unable to find the authentication provider module {provider}\"\n        ) from err\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        _LOGGER.error(\"The authentication provider module %s is invalid\", provider)\n        raise HomeAssistantError(f\"The authentication provider module {provider} is invalid\")\n    return module\n\n", "CodeBleu_score": 39.114092935856306}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, f\"homeassistant.auth.{provider}\")\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to find the authentication provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(f\"Unable to find the authentication provider {provider}\")\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        _LOGGER.error(\n            \"The authentication provider module %s does not have the required CONFIG_SCHEMA attribute\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"The authentication provider {provider} does not have the required CONFIG_SCHEMA attribute\"\n        )\n    if not hasattr(module, \"STORAGE_KEY\"):\n        _LOGGER.error(\n            \"The authentication provider module %s does not have the required STORAGE_KEY attribute\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"The authentication provider {provider} does not have the required STORAGE_KEY attribute\"\n        )\n    if not hasattr(module, \"STORAGE_VERSION\"):\n        _LOGGER.error(\n            \"The authentication provider module %s does not have the required STORAGE_VERSION attribute\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"The authentication provider {provider} does not have the required STORAGE_VERSION attribute\"\n        )\n    if not hasattr(module, \"STORAGE_KEY_CREDENTIALS\"):\n        _LOGGER.error(\n            \"The authentication provider module %s does not have the required STORAGE_KEY_CREDENTIALS attribute\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"The authentication provider {provider} does not have the required STORAGE_KEY_CREDENTIALS attribute\"\n        )\n    if not hasattr(module, \"STORAGE_VERSION_CREDENTIALS\"):\n        _LOGGER.error(\n            \"The authentication provider module %s does not have the required STORAGE_VERSION_CREDENTIALS attribute\",", "CodeBleu_score": 28.955318913403943}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\tnormalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == normalized_username:\n            password_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            else:\n                raise InvalidAuth()\n    bcrypt.checkpw(b\"\", dummy_hash)\n    raise InvalidAuth()", "CodeBleu_score": 38.14861799555128}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tnormalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if normalized_username == self.normalize_username(user.username):\n            if bcrypt.checkpw(password.encode(), base64.b64decode(user.password)):\n                return\n            else:\n                raise InvalidAuth()\n    bcrypt.checkpw(b\"\", dummy_hash)\n    raise InvalidAuth()", "CodeBleu_score": 35.53303296945761}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tnormalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == normalized_username:\n            password_hash = base64.b64decode(user.password)\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            else:\n                bcrypt.checkpw(b\"\", dummy_hash)\n                raise InvalidAuth()\n    bcrypt.checkpw(b\"\", dummy_hash)\n    raise InvalidAuth()", "CodeBleu_score": 37.7706515565545}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\tnormalized_username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == normalized_username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 29.184437484160046}, {"code": "def async_remove_auth(self, username: str) -> None\n\tusername = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user.username == username:\n            del self.users[index]\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 32.955740824632294}, {"code": "def async_remove_auth(self, username: str) -> None\n\tusername = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(\"user_not_found\")", "CodeBleu_score": 36.7997370512362}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.data[\"username\"])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 54.80424260236948}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self.async_initialize()\n\n    try:\n        self._data.pop(credentials.data[\"username\"])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 54.80424260236948}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif not self._data:\n        await self.async_initialize()\n\n    try:\n        self._data.pop(credentials.data[\"username\"])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 49.505889622228494}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            continue\n        joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 55.370457163941744}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not hasattr(thread, \"ident\"):\n            joined.add(thread)\n            continue\n        thread_timeout = timeout - (time.monotonic() - thread.start_time)\n        if thread_timeout > 0:\n            thread.join(thread_timeout)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            try:\n                async_raise(thread.ident, SystemExit)\n            except Exception:  # pylint: disable=broad-except\n                pass\n        else:\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 50.32328125714612}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        ident = thread.ident\n        if ident is None:\n            joined.add(thread)\n            continue\n        thread.join(timeout)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, ident)\n            continue\n        joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 51.528481803291484}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\tshutdown_timeout = 10\n    threads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()]\n    timeout = shutdown_timeout / len(threads)\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception:\n            _LOGGER.warning(f\"Failed to join thread {thread.name}\")", "CodeBleu_score": 39.15183174270491}, {"code": "def deadlock_safe_shutdown() -> None\n\t# Get all non-daemon, alive threads\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon\n    ]\n    # If there are no non-daemon, alive threads, return\n    if not threads:\n        return\n    # Calculate the timeout for each thread\n    timeout = SHUTDOWN_TIMEOUT / len(threads)\n    # Join each thread\n    for thread in threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\n                \"Failed to join thread: %s\",\n                thread.name,\n            )", "CodeBleu_score": 43.312537450421665}, {"code": "def deadlock_safe_shutdown() -> None\n\tshutdown_timeout = 10\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon and t.is_alive()]\n    for thread in threads:\n        timeout = shutdown_timeout / len(threads)\n        try:\n            thread.join(timeout)\n        except Exception as exception:\n            _LOGGER.warning(f\"Error joining thread {thread.name}: {exception}\")", "CodeBleu_score": 38.10964711436904}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif remaining_with_setup_started or self._remaining_with_setup_started:\n        self._async_dispatcher_send_internal(\n            self.SIGNAL_REMAINING_SETUPS, remaining_with_setup_started\n        )\n        self._remaining_with_setup_started = remaining_with_setup_started\n    else:\n        self._async_dispatcher_send_internal(self.SIGNAL_SETUPS_COMPLETED)\n        self._remaining_with_setup_started = {}", "CodeBleu_score": 42.22494745566131}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif remaining_with_setup_started or self._remaining_with_setup_started:\n        self._async_dispatcher_send_internal(\n            SIGNAL_SETUP_INTEGRATION_RETRY,\n            remaining_with_setup_started,\n        )\n        self._remaining_with_setup_started = remaining_with_setup_started\n    else:\n        self._remaining_with_setup_started = None", "CodeBleu_score": 54.159625998891315}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif remaining_with_setup_started or self._remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self.async_dispatcher_send_internal(\n            SIGNAL_SETUP_ATTEMPT_FINISHED,\n            self._remaining_with_setup_started,\n        )\n    else:\n        self._remaining_with_setup_started = None", "CodeBleu_score": 43.42093605444971}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t# If we're not validating specific integrations, read the current content of bluetooth.py\n    if not integrations:\n        bluetooth_path = config.cache_path / \"bluetooth.py\"\n        if bluetooth_path.is_file():\n            with open(bluetooth_path) as bluetooth_file:\n                bluetooth_content = bluetooth_file.read()\n        else:\n            bluetooth_content = \"\"\n\n    # Generate and validate the Bluetooth content\n    generated_content = generate_and_validate(integrations)\n\n    # If we're not validating specific integrations, check if the contents differ\n    if not integrations and bluetooth_content != generated_content:\n        config.add_error(\n            \"bluetooth\",\n            \"bluetooth.py is not up to date\",\n            \"Please run script/gen_requirements_all.py to update\",\n            bluetooth_path,\n        )\n\n    # Store the generated content in the configuration cache\n    bluetooth_path = config.cache_path / \"bluetooth.py\"\n    bluetooth_path.parent.mkdir(exist_ok=True)\n    with open(bluetooth_path, \"w\") as bluetooth_file:\n        bluetooth_file.write(generated_content)\n\n", "CodeBleu_score": 44.452569222164776}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tgenerated_content = generate_and_validate(integrations)\n    bluetooth_path = config.cache_path / \"bluetooth.py\"\n\n    if bluetooth_path.exists():\n        current_content = bluetooth_path.read_text()\n    else:\n        current_content = \"\"\n\n    if generated_content != current_content:\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            hint=f\"Run script {config.fixit_path} to update bluetooth.py\",\n        )", "CodeBleu_score": 40.98702034349079}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif not config.specific_integrations:\n        try:\n            with open(config.cache.path(\"bluetooth.py\"), encoding=\"utf-8\") as fp:\n                current_content = fp.read()\n        except FileNotFoundError:\n            current_content = \"\"\n\n        generated_content = generate_and_validate(integrations)\n\n        if current_content != generated_content:\n            config.add_error(\n                \"bluetooth.py is not up to date. Run script/gen_requirements_all.py\",\n                fixable=True,\n                type=Hint(\"bluetooth.py is not up to date\", \"https://developers.home-assistant.io/docs/en/development_configuration_cache.html#bluetooth-py\"),\n            )\n\n    else:\n        config.cache.write(\"bluetooth.py\", generate_and_validate(integrations))", "CodeBleu_score": 42.76145338246178}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\tresp := new(RefreshResp)\n\te := new(RefreshError)\n\n\tif _, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(refreshTokenURL); err != nil {\n\t\treturn err\n\t}\n\n\tif e.Error != \"\" {\n\t\tlogger.Info(e.ErrorDescription,\n\t\t\tzap.String(\"code\", e.Error),\n\t\t\tzap.String(\"request_id\", e.ErrorDescription),\n\t\t)\n\t\treturn fmt.Errorf(\"refresh token: %s\", e.ErrorDescription)\n\t}\n\n\td.AccessToken = resp.AccessToken\n\td.RefreshToken = resp.RefreshToken\n\n\treturn nil\n}", "CodeBleu_score": 67.31247813994027}, {"code": "func (d *Dropbox) refreshToken() error{\n\t// Set the logger.\n\tlogger := base.Logger()\n\t// Set the request.\n\treq := base.RestyClient.R().SetError(&base.Error)\n\t// Set the form data for the request.\n\treq.SetFormData(map[string]string{\n\t\t\"refresh_token\": d.RefreshToken,\n\t\t\"grant_type\":    \"refresh_token\",\n\t})\n\t// Set the basic auth for the request.\n\treq.SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret)\n\t// Set the headers for the request.\n\treq.SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t// Send the POST request.\n\tresp, e := req.Post(\"https://api.dropboxapi.com/oauth2/token\")\n\tif e != nil {\n\t\tlogger.Error(\"Dropbox refresh token error.\",\n\t\t\tzap.String(\"step\", \"refresh token\"),\n\t\t\tzap.String(\"error\", base.Error.Error()))\n\t\treturn base.Error\n\t}\n\t// Parse the JSON response.\n\tif e := json.Unmarshal(resp.Body(), &d.Token); e != nil {\n\t\tlogger.Error(\"Dropbox refresh token error.\",\n\t\t\tzap.String(\"step\", \"refresh token\"),\n\t\t\tzap.String(\"error\", e.Error()))\n\t\treturn e\n\t}\n\t// Log the success.\n\tlogger.Info(\"Dropbox refresh token success.\",\n\t\tzap.String(\"step\", \"refresh token\"),\n\t\tzap.Int(\"statusCode\", resp.StatusCode()))\n\treturn nil\n}", "CodeBleu_score": 49.77275138731623}, {"code": "func (d *Dropbox) refreshToken() error{\n\tresp := new(RefreshTokenResp)\n\te := new(RefreshTokenResp)\n\n\t_, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(refreshTokenURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif e.Error != \"\" {\n\t\tlogger.Info(e.ErrorDescription,\n\t\t\tzap.String(\"refresh_token\", d.RefreshToken),\n\t\t\tzap.String(\"app_key\", d.Addition.AppKey),\n\t\t\tzap.String(\"app_secret\", d.Addition.AppSecret),\n\t\t)\n\t\treturn fmt.Errorf(e.ErrorDescription)\n\t}\n\n\td.AccessToken = resp.AccessToken\n\n\treturn nil\n}", "CodeBleu_score": 69.68160693472481}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tif d.token.AccessToken == \"\" {\n\t\treturn nil, fmt.Errorf(\"no access token\")\n\t}\n\treq := d.restyClient.R().SetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tvar err error\n\tvar respBody []byte\n\tfor i := 0; i < 2; i++ {\n\t\tswitch method {\n\t\tcase \"GET\":\n\t\t\tresp, err = req.Get(url)\n\t\tcase \"POST\":\n\t\t\tresp, err = req.Post(url)\n\t\tcase \"PATCH\":\n\t\t\tresp, err = req.Patch(url)\n\t\tcase \"DELETE\":\n\t\t\tresp, err = req.Delete(url)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unsupported method %s\", method)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif resp.StatusCode() == 401 {\n\t\t\tif err = d.refreshToken(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treq.SetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\t\t} else {\n\t\t\trespBody = resp.Body()\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode() >= 400 {\n\t\treturn nil, fmt.Errorf(\"error %d: %s\", resp.StatusCode(), respBody)\n\t}\n\tif resp != nil {\n\t\tif resp.StatusCode() == 204 {\n\t\t\t// 204: No Content\n\t\t\treturn nil, nil\n\t\t}\n\t\tif resp.StatusCode() == 200 {\n\t\t\tif respBody != nil {\n\t\t\t\tif respBody[0] == '{' {", "CodeBleu_score": 55.593547925288334}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tif d.accessToken == \"\" {\n\t\treturn nil, errors.New(\"access token is empty\")\n\t}\n\n\trestyClient := base.RestyClient.R()\n\trestyClient.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\trestyClient.SetQueryParam(\"supportsAllDrives\", \"true\")\n\trestyClient.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\n\tif callback != nil {\n\t\tcallback(restyClient)\n\t}\n\n\tvar err error\n\tvar respBody []byte\n\tfor i := 0; i < 2; i++ {\n\t\tvar r *resty.Response\n\t\tr, err = restyClient.Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trespBody = r.Body()\n\t\tif r.IsError() {\n\t\t\tif r.StatusCode() == http.StatusUnauthorized {\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"%s: %s\", r.Status(), string(respBody))\n\t\t\t}\n\t\t} else {\n\t\t\tif resp != nil {\n\t\t\t\terr = json.Unmarshal(respBody, resp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn respBody, err\n}", "CodeBleu_score": 53.09618074691418}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\treq := d.restyClient.R()\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetHeader(\"Accept\", \"application/json\")\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\treq.SetError(&Error{})\n\treq.SetResult(&resp)\n\tvar err error\n\tvar respBody []byte\n\tfor i := 0; i < 2; i++ {\n\t\tif method == \"GET\" {\n\t\t\trespBody, err = req.Get(url)\n\t\t} else if method == \"POST\" {\n\t\t\trespBody, err = req.Post(url)\n\t\t} else if method == \"PATCH\" {\n\t\t\trespBody, err = req.Patch(url)\n\t\t} else if method == \"DELETE\" {\n\t\t\trespBody, err = req.Delete(url)\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"unsupported method: %s\", method)\n\t\t}\n\t\tif err != nil {\n\t\t\tif errResp, ok := err.(*Error); ok && errResp.Code == 401 {\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn respBody, err\n}", "CodeBleu_score": 55.95722849663194}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := int64(d.chunkSize)\n\tif stream.GetSize() < chunkSize {\n\t\tchunkSize = stream.GetSize()\n\t}\n\n\tfinish := int64(0)\n\tfor {\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\n\t\treq := d.request(ctx, \"PUT\", url, nil).\n\t\t\tSetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\tif err := req.SetContext(ctx).Do().Error(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfinish += chunkSize\n\t\tif finish+chunkSize > stream.GetSize() {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 61.21954620947384}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := int64(30 * 1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tif err := ctx.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif finish >= stream.GetSize() {\n\t\t\treturn nil\n\t\t}\n\t\tif stream.GetSize()-finish < chunkSize {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\treq := d.request(ctx, http.MethodPut, url, nil).\n\t\t\tSetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\tresp, err := req.SetContext(ctx).Send()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode != http.StatusResumeIncomplete {\n\t\t\treturn nil\n\t\t}\n\t\tfinish += chunkSize\n\t}\n}", "CodeBleu_score": 59.24562180708983}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := int64(30 * 1024 * 1024) // 30 MB\n\tfinish := int64(0)\n\tfor {\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tif finish >= stream.GetSize() {\n\t\t\treturn nil\n\t\t}\n\t\tif stream.GetSize()-finish < chunkSize {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\t_, err := d.request(ctx, &request{\n\t\t\tMethod:   \"PUT\",\n\t\t\tURL:      url,\n\t\t\tBody:     io.LimitReader(stream.GetReadCloser(), chunkSize),\n\t\t\tContext:  ctx,\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t}\n}", "CodeBleu_score": 65.61620096974441}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\tvar reqData struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&reqData); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\tif reqData.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(errors.New(\"mount point cannot be empty\")))\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(reqData.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusServiceUnavailable, common_err.GetMsg(err))\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(reqData.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusServiceUnavailable, common_err.GetMsg(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 40.53035802559521}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tmount_point := ctx.Bind(&storage.Storage{}).MountPoint\n\tif mount_point == \"\" {\n\t\treturn common_err.GetMsg(ctx, common_err.ErrBadRequest)\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(mount_point); err != nil {\n\t\treturn common_err.GetMsg(ctx, err)\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(mount_point); err != nil {\n\t\treturn common_err.GetMsg(ctx, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, \"successfully unmounted storage device\")\n}", "CodeBleu_score": 36.96987447107867}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar reqBody types.UmountStorageRequest\n\tif err := ctx.Bind(&reqBody); err != nil {\n\t\treturn common_err.GetMsg(ctx, common_err.ErrInvalidRequestBody)\n\t}\n\tif reqBody.MountPoint == \"\" {\n\t\treturn common_err.GetMsg(ctx, common_err.ErrInvalidRequestParams)\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(reqBody.MountPoint); err != nil {\n\t\treturn common_err.GetServiceError(ctx, err)\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(reqBody.MountPoint); err != nil {\n\t\treturn common_err.GetServiceError(ctx, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, types.SuccessResponse{Success: true})\n}", "CodeBleu_score": 40.857523595723336}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileDoesNotExist))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.80954776972845}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrNoPath))\n\t}\n\tif !file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\treturn ctx.File(path)\n}", "CodeBleu_score": 46.336401682618565}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.78814250136637}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"Success\")\n}", "CodeBleu_score": 57.42526286744762}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, make(map[string]string))\n}", "CodeBleu_score": 55.09625206058277}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 57.39102053298589}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running\n\tstartSendingMessages()\n\n\tfor {\n\t\t// Read messages from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// If the error is due to the WebSocket connection being closed,\n\t\t\t// remove the connection from the list of connections\n\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\tremoveConnection(ws)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 48.98886825585088}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running\n\tif !isSending {\n\t\tisSending = true\n\t\tgo SendMeg()\n\t}\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// If the error is due to the WebSocket connection being closed, remove the connection from the list of connections\n\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\tfor i, v := range connections {\n\t\t\t\t\tif v == ws {\n\t\t\t\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type and message\n\t\tfmt.Println(\"Message Type:\", msg[0])\n\t\tfmt.Println(\"Message:\", string(msg[1:]))\n\t}\n}", "CodeBleu_score": 45.29007243526688}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconnections = append(connections, ws)\n\tgo sendMessages(ws)\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"%s sent: %s\n\", ws.RemoteAddr(), string(msg))\n\t}\n\treturn nil\n}", "CodeBleu_score": 44.97819539813101}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get the drive model and architecture\n\tdriveModel, architecture := service.MyService.System().GetCpuInfo()\n\n\t// If the drive model and architecture are not empty, return the data\n\tif driveModel != \"\" && architecture != \"\" {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(http.StatusOK, \"Success\", driveModel, architecture))\n\t}\n\n\t// If the drive model and architecture are empty, return \"nil\"\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(http.StatusOK, \"Success\", nil, nil))\n}", "CodeBleu_score": 22.927167956923128}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get the drive model\n\tdriveModel, err := GetDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(ctx, err))\n\t}\n\n\t// Get the architecture\n\tarchitecture, err := GetArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(ctx, err))\n\t}\n\n\t// Get the CPU information\n\tcpuInfo, err := GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(ctx, err))\n\t}\n\n\t// Get the device tree\n\tdeviceTree, err := GetDeviceTree()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(ctx, err))\n\t}\n\n\t// Get the system hardware information\n\tsystemHardwareInfo := SystemHardwareInfo{\n\t\tDriveModel:    driveModel,\n\t\tArchitecture:  architecture,\n\t\tCpuInfo:       cpuInfo,\n\t\tDeviceTree:    deviceTree,\n\t}\n\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 23.089462663328813}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get the system drive model\n\tdriveModel, err := service.MyService.System().GetDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Get the system architecture\n\tarchitecture, err := service.MyService.System().GetArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Get the system CPU info\n\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Get the system device tree\n\tdeviceTree, err := service.MyService.System().GetDeviceTree()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Create a struct to hold the system hardware information\n\tsystemHardwareInfo := struct {\n\t\tDriveModel   string `json:\"drive_model\"`\n\t\tArchitecture string `json:\"architecture\"`\n\t\tCpuInfo      string `json:\"cpu_info\"`\n\t\tDeviceTree   string `json:\"device_tree\"`\n\t}{\n\t\tDriveModel:   driveModel,\n\t\tArchitecture: architecture,\n\t\tCpuInfo:      cpuInfo,\n\t\tDeviceTree:   deviceTree,\n\t}\n\n\t// Return the system hardware information as a JSON response\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 26.741268073736858}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t// Get the list of services\n\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a map to hold the categorized services\n\tservicesMap := make(map[bool]*[]string)\n\n\t// Create lists for running and not running services\n\tvar runningServices []string\n\tvar notRunningServices []string\n\n\t// Iterate through the services and categorize them\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif serviceRunning(service) {\n\t\t\t\trunningServices = append(runningServices, service)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, service)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add the running services to the map\n\tservicesMap[true] = &runningServices\n\n\t// Add the not running services to the map\n\tservicesMap[false] = &notRunningServices\n\n\t// Return the map\n\treturn servicesMap, nil\n}", "CodeBleu_score": 50.30896904605159}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 75.58647172190838}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := []string{}\n\tnotRunningServices := []string{}\n\n\tfor _, service := range services {\n\t\tif service.IsRunning {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 68.48818833947503}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tlogger := i.logger.With(zap.String(\"name\", name))\n\tlogger.Debug(\"Sending notification\")\n\tserializedMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to serialize message\", zap.Error(err))\n\t\treturn\n\t}\n\tresponse, err := i.messageBus.PublishEventWithResponse(name, serializedMessage)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to send notification\",\n\t\t\tzap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 39.994822113380515}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// Serialize the message values to JSON strings\n\tserialized := make(map[string]string)\n\tfor key, value := range message {\n\t\tserialized[key] = fmt.Sprintf(\"%v\", value)\n\t}\n\n\t// Publish the event to a message bus\n\tresponse, err := i.messageBus.PublishEventWithResponse(name, serialized)\n\tif err != nil {\n\t\ti.logger.Error(\"Failed to publish event\", zap.Error(err))\n\t} else if response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"Failed to publish event\",\n\t\t\tzap.String(\"responseStatus\", response.Status),\n\t\t\tzap.Any(\"responseBody\", response.Body))\n\t}\n}", "CodeBleu_score": 49.2381234785445}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tresponse, err := i.MessageBus.PublishEventWithResponse(i.Context, name, message)\n\tif err != nil {\n\t\ti.Logger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\ti.Logger.Error(\"failed to publish event\",\n\t\t\tzap.String(\"name\", name),\n\t\t\tzap.Any(\"message\", message),\n\t\t\tzap.String(\"status\", response.Status),\n\t\t\tzap.String(\"response\", string(response.Body)))\n\t}\n}", "CodeBleu_score": 38.31322179157762}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tmessageBusAddress := external.GetMessageBusAddress()\n\tclient := message_bus.NewClientWithResponses(messageBusAddress)\n\treturn client\n}", "CodeBleu_score": 14.616942129080218}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Retrieve the message bus address from the runtime path.\n\taddress := external.GetMessageBusAddress()\n\t// Create a new message bus client with responses.\n\tclient := message_bus.NewClientWithResponses(address)\n\t// Return the client.\n\treturn client\n}", "CodeBleu_score": 12.661096540256514}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Get the message bus address\n\taddr, err := c.GetMessageBusAddress()\n\tif err != nil {\n\t\taddr = fmt.Sprintf(\"http://%v\", err)\n\t}\n\n\t// Create a new client\n\treturn message_bus.NewClientWithResponses(addr)\n}", "CodeBleu_score": 30.541830232587042}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t// Get IP from the X-Forwarded-For header\n\tips := request.Header.Get(\"x-forwarded-for\")\n\tif ips == \"\" {\n\t\t// Get IP from the RemoteAddr header\n\t\tips = request.RemoteAddr\n\t}\n\n\t// Split the IPs by comma\n\tipList := strings.Split(ips, \",\")\n\n\t// Get the first IP\n\tip := strings.TrimSpace(ipList[0])\n\n\t// Convert IPv4-mapped IPv6 address to IPv4 address\n\tip = strings.Replace(ip, \"::ffff:\", \"\", -1)\n\n\t// Convert IPv6 loopback address to IPv4 loopback address\n\tip = strings.Replace(ip, \"::1\", \"127.0.0.1\", -1)\n\n\treturn ip\n}", "CodeBleu_score": 45.055426777289085}, {"code": "func GetIP(request *http.Request) string{\n\tvar ip string\n\tif ip = request.Header.Get(\"x-forwarded-for\"); ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 59.92943859286473}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \":\") {\n\t\tip = ip[0:strings.LastIndex(ip, \":\")]\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 67.12937782716952}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\tc.logger.Info(\"Generating system entry file\")\n\n\t// Define the path for the modules directory and the entry file\n\tmodulesDir := filepath.Join(c.cfg.Path, \"modules\")\n\tentryFile := filepath.Join(c.cfg.Path, \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif err := file.IsNotExistCreateFile(entryFile); err != nil {\n\t\tc.logger.Error(\"Error ensuring entry file exists\", zap.Error(err))\n\t}\n\n\t// Read the modules directory for entry.json files\n\tentries, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tc.logger.Error(\"Error reading modules directory\", zap.Error(err))\n\t}\n\n\t// Concatenate the contents of each entry.json file into a single JSON array\n\tvar entryJSON []byte\n\tfor _, entry := range entries {\n\t\tif !entry.IsDir() && strings.HasSuffix(entry.Name(), \"entry.json\") {\n\t\t\tentryPath := filepath.Join(modulesDir, entry.Name())\n\t\t\tentryBytes, err := os.ReadFile(entryPath)\n\t\t\tif err != nil {\n\t\t\t\tc.logger.Error(\"Error reading entry file\", zap.Error(err))\n\t\t\t}\n\t\t\tentryJSON = append(entryJSON, entryBytes...)\n\t\t}\n\t}\n\n\t// Write the entry JSON array to the entry file path\n\tif err := os.WriteFile(entryFile, entryJSON, 0644); err != nil {\n\t\tc.logger.Error(\"Error writing entry file\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 42.14619806517502}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tvar err error\n\tvar modulesPath = filepath.Join(c.config.Paths.Modules, \"*\")\n\tvar entryFilePath = filepath.Join(c.config.Paths.Modules, \"entry.json\")\n\n\tif !file.IsNotExistCreateFile(entryFilePath) {\n\t\tlogger.Error(\"Error creating entry file\", zap.Error(err))\n\t}\n\n\tvar modules []string\n\tvar modulesDir []os.FileInfo\n\n\tmodulesDir, err = os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"Error reading modules directory\", zap.Error(err))\n\t}\n\n\tfor _, module := range modulesDir {\n\t\tif module.IsDir() {\n\t\t\tmodules = append(modules, module.Name())\n\t\t}\n\t}\n\n\tvar entries []string\n\n\tfor _, module := range modules {\n\t\tvar modulePath = filepath.Join(c.config.Paths.Modules, module, \"entry.json\")\n\t\tvar entry []byte\n\n\t\tentry, err = os.ReadFile(modulePath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error reading module entry file\", zap.Error(err))\n\t\t}\n\n\t\tentries = append(entries, string(entry))\n\t}\n\n\tvar entriesJSON = \"[\" + strings.TrimRight(strings.Join(entries, \",\"), \",\") + \"]\"\n\n\terr = os.WriteFile(entryFilePath, []byte(entriesJSON), 0644)\n\tif err != nil {\n\t\tlogger.Error(\"Error writing entry file\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 47.30526851614717}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Define the path to the modules directory\n\tmodulesPath := filepath.Join(c.config.RootPath, \"modules\")\n\n\t// Define the path to the system entry file\n\tentryFilePath := filepath.Join(c.config.RootPath, \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif err := file.IsNotExistCreateFile(entryFilePath); err != nil {\n\t\tlogger.Error(err)\n\t}\n\n\t// Read the modules directory\n\tmodules, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t}\n\n\t// Initialize an empty JSON array\n\tvar entries []byte\n\n\t// For each module directory, read the entry.json file and append its contents to the entries JSON array\n\tfor _, module := range modules {\n\t\tif module.IsDir() {\n\t\t\tmodulePath := filepath.Join(modulesPath, module.Name())\n\t\t\tentryPath := filepath.Join(modulePath, \"entry.json\")\n\t\t\tentry, err := os.ReadFile(entryPath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t}\n\t\t\tentries = append(entries, entry...)\n\t\t}\n\t}\n\n\t// Write the entries JSON array to the system entry file\n\tif err := os.WriteFile(entryFilePath, entries, 0644); err != nil {\n\t\tlogger.Error(err)\n\t}\n}", "CodeBleu_score": 44.77557695897801}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnetworkNames, err := c.service.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"could not find matching network interface\")\n}", "CodeBleu_score": 65.56026274014029}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnetworkNames, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, networkName := range networkNames {\n\t\tfor _, i := range interfaces {\n\t\t\tif i.Name == networkName {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 65.2778395289152}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, networkName := range networkNames {\n\t\tfor _, i := range interfaces {\n\t\t\tif networkName == i.Name {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 64.6122350787796}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t iRet = TSC_SUCCESS;\n\tint32_t iRetTemp = TSC_SUCCESS;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tiRet = TSC_ERR_INVALID_ARG;\n\t\tTSC_LOG_ERROR_ARGS(\"Invalid argument passed to %s(); (pRequest = %p, pTscObj = %p)\", __FUNCTION__, pRequest, pTscObj);\n\t}\n\n\tif (iRet == TSC_SUCCESS) {\n\t\tiRetTemp = addRequestRef(pRequest);\n\t\tif (iRetTemp != TSC_SUCCESS) {\n\t\t\tiRet = iRetTemp;\n\t\t\tTSC_LOG_ERROR_ARGS(\"Failed to add reference to request object %p\", pRequest);\n\t\t}\n\t}\n\n\tif (iRet == TSC_SUCCESS) {\n\t\tiRetTemp = addTscRef(pTscObj);\n\t\tif (iRetTemp != TSC_SUCCESS) {\n\t\t\tiRet = iRetTemp;\n\t\t\tTSC_LOG_ERROR_ARGS(\"Failed to add reference to TSC object %p\", pTscObj);\n\t\t}\n\t}\n\n\tif (iRet == TSC_SUCCESS) {\n\t\tiRetTemp = atomic_add_fetch_32(&pTscObj->iRequestCount, 1);\n\t\tif (iRetTemp < 0) {\n\t\t\tiRet = TSC_ERR_REQUEST_COUNT;\n\t\t\tTSC_LOG_ERROR_ARGS(\"Failed to increment request count for TSC object %p\", pTscObj);\n\t\t}\n\t}\n\n\tif (iRet == TSC_SUCCESS) {\n\t\tif (pTscObj->pAppInfo != NULL) {\n\t\t\tiRetTemp = updateRequestSummary(pTscObj->pAppInfo, pRequest);\n\t\t\tif (iRetTemp != TSC_SUCCESS) {\n\t\t\t\tiRet = iRetTemp;\n\t\t\t\tTSC_LOG_ERROR_AR", "CodeBleu_score": 41.52920564742482}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t retCode = TSC_SUCCESS;\n\t\n\t// Add a reference to the request object\n\ttaosAddRef(pRequest);\n\t\n\t// Increment the request count for the associated TSC object\n\tatomic_add_fetch_64(&pTscObj->requestCount, 1);\n\t\n\t// If the TSC object has application information, update the application's request summary\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo->totalRequests++;\n\t\tatomic_add_fetch_32(&pTscObj->pAppInfo->currentRequests, 1);\n\t}\n\t\n\t// Log debug information about the new request\n\ttscDebug(\"%s: Registered request %p for TSC object %p\n\", __FUNCTION__, pRequest, pTscObj);\n\t\n\treturn retCode;\n}", "CodeBleu_score": 31.773091625267906}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n    if (pRequest == NULL || pTscObj == NULL) {\n        rc = EINVAL;\n        TSCObjDebug(pTscObj, \"Invalid parameters\");\n    } else {\n        TSCObjDebug(pTscObj, \"Registering request\");\n        /* Add a reference to the request object */\n        rc = taosAddRef(pRequest);\n        if (rc == 0) {\n            /* Increment the request count for the associated TSC object */\n            atomic_add_fetch_32(&pTscObj->requestCount, 1);\n            if (pTscObj->pAppInfo != NULL) {\n                /* Update the application's request summary */\n                pTscObj->pAppInfo->requestCount++;\n                pTscObj->pAppInfo->requestCurrentCount++;\n            }\n            TSCObjDebug(pTscObj, \"Registered request\");\n        } else {\n            TSCObjDebug(pTscObj, \"Failed to add reference to request\");\n        }\n    }\n    return rc;\n}", "CodeBleu_score": 38.18204435795868}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (pRequest == NULL || exceptDb == NULL) {\n        return false;\n    }\n\n    if (strcmp(pRequest->db, exceptDb) != 0) {\n        if (pRequest->dbs == NULL) {\n            return true;\n        }\n        int i = 0;\n        for (i = 0; i < pRequest->dbs_size; i++) {\n            if (strchr(pRequest->dbs[i], '.') != NULL) {\n                char *tmpDb = strchr(pRequest->dbs[i], '.') + 1;\n                if (strcmp(tmpDb, exceptDb) == 0) {\n                    return false;\n                }\n            } else {\n                if (strcmp(pRequest->dbs[i], exceptDb) == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 53.97587293494186}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tchar* db = pRequest->pPrimaryDb;\n\tif (db == NULL || strcmp(db, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < pRequest->nDbCount; i++) {\n\t\tdb = pRequest->ppDb[i];\n\t\tif (db != NULL && strcmp(db, exceptDb) == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 51.89438611618971}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (strcmp(pRequest->pStmt->database, exceptDb) != 0) {\n        if (pRequest->pStmt->database[0] != '\\0') {\n            int dbLen = strlen(pRequest->pStmt->database);\n            for (int i = 0; i < pRequest->dbNum; i++) {\n                if (strcmp(pRequest->pDb[i], exceptDb) == 0) {\n                    return false;\n                }\n                if (strcmp(pRequest->pDb[i], pRequest->pStmt->database) == 0) {\n                    return false;\n                }\n                if (pRequest->pDb[i][0] != '\\0' && strcmp(pRequest->pDb[i] + dbLen + 1, exceptDb) == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 46.614732857830276}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tif (code != NEED_REDIRECT_ERROR) {\n    return false;\n  }\n  switch (msgType) {\n    case TMSG_CLOSE:\n    case TMSG_CLOSE_ACK:\n    case TMSG_CLOSE_REPLY:\n    case TMSG_CLOSE_REPLY_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK_ACK:\n    case TMSG_CLOSE_REPLY_ACK_ACK_ACK_ACK", "CodeBleu_score": 33.18629580917505}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tif (code != NEED_REDIRECT_ERROR) {\n        return false;\n    }\n\n    switch (msgType) {\n        case TMSG_RPC:\n        case TMSG_RPC_HDR:\n        case TMSG_RPC_HDR_REPLY:\n        case TMSG_RPC_DATA:\n        case TMSG_RPC_DATA_REPLY:\n        case TMSG_RPC_DONE:\n        case TMSG_RPC_DONE_REPLY:\n        case TMSG_RPC_REPLY:\n        case TMSG_RPC_REPLY_REPLY:\n        case TMSG_RPC_ERROR:\n        case TMSG_RPC_ERROR_REPLY:\n        case TMSG_RPC_CANCEL:\n        case TMSG_RPC_CANCEL_REPLY:\n        case TMSG_RPC_CANCEL_ACK:\n        case TMSG_RPC_CANCEL_ACK_REPLY:\n        case TMSG_RPC_FORWARD:\n        case TMSG_RPC_FORWARD_REPLY:\n        case TMSG_RPC_FORWARD_DONE:\n        case TMSG_RPC_FORWARD_DONE_REPLY:\n        case TMSG_RPC_FORWARD_CANCEL:\n        case TMSG_RPC_FORWARD_CANCEL_REPLY:\n        case TMSG_RPC_FORWARD_CANCEL_ACK:\n        case TMSG_RPC_FORWARD_CANCEL_ACK_REPLY:\n            return false;\n        default:\n            return true;\n    }\n}", "CodeBleu_score": 35.98832459094615}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tswitch (code) {\n        case NEED_REDIRECT_ERROR:\n            if (msgType == RPC_CALL || msgType == RPC_CALL_ASYNC || msgType == RPC_CALL_ASYNC_NO_RET || msgType == RPC_CALL_NO_RET) {\n                return true;\n            }\n            break;\n    }\n    return false;\n}", "CodeBleu_score": 44.906717877611904}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\tif (pRequests == NULL) {\n        return;\n    }\n\n    int64_t *pRequestIDs = NULL;\n    int32_t *pRequestStatus = NULL;\n    int64_t rid = 0;\n    int32_t reqStatus = 0;\n    int32_t reqCount = 0;\n    int32_t i = 0;\n\n    reqCount = pRequests->count;\n    pRequestIDs = (int64_t *) pRequests->pKeys;\n    pRequestStatus = (int32_t *) pRequests->pValues;\n\n    for (i = 0; i < reqCount; i++) {\n        rid = pRequestIDs[i];\n        reqStatus = pRequestStatus[i];\n\n        if (reqStatus == REQ_STATUS_RUNNING) {\n            int32_t status = taos_stop_query(clientReqRefPool, rid);\n            if (status < 0) {\n                taosErrorReport(status, \"taos_stop_query\", NULL);\n            }\n        }\n\n        releaseRequest(rid);\n    }\n}", "CodeBleu_score": 40.08649783677638}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tif (pRequests) {\n\t\tint32_t i = 0;\n\t\tfor (i = 0; i < pRequests->size; i++) {\n\t\t\tif (pRequests->items[i] != NULL) {\n\t\t\t\tint64_t rid = pRequests->items[i];\n\t\t\t\tif (rid != 0) {\n\t\t\t\t\tint32_t res = 0;\n\t\t\t\t\tif ((res = acquireRequest(rid)) != 0) {\n\t\t\t\t\t\tif (res == rid) {\n\t\t\t\t\t\t\ttaos_stop_query(res);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treleaseRequest(rid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.3325089748774}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tint64_t rid;\n\tint32_t rc;\n\tint32_t i;\n\tfor (i = 0; i < pRequests->hashSize; i++) {\n\t\trid = pRequests->hash[i];\n\t\twhile (rid != 0) {\n\t\t\trc = acquireRequest(rid);\n\t\t\tif (rc == 0) {\n\t\t\t\ttaos_stop_query(rid);\n\t\t\t\treleaseRequest(rid);\n\t\t\t}\n\t\t\trid = pRequests->hash[i];\n\t\t}\n\t}\n}", "CodeBleu_score": 37.34161453723092}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\tif (!crashReport) {\n        return;\n    }\n\n    if (atomic_val_compare_exchange_32(&clientStop, 0, 1) == 0) {\n        return;\n    }\n\n    while (atomic_load_32(&clientStop) != 0) {\n        taosMsleep(100);\n    }\n}", "CodeBleu_score": 71.13098437058751}, {"code": "void tscStopCrashReport(){\n\tif (!tscCrashReportEnabled) {\n        return;\n    }\n\n    if (!atomic_val_compare_exchange_32(&clientStop, 0, 1)) {\n        tscDebug(\"tscStopCrashReport: crash report thread is already stopped\n\");\n        return;\n    }\n\n    while (atomic_load_32(&clientStop) != 0) {\n        tscMsleep(100);\n    }\n}", "CodeBleu_score": 72.44330517225643}, {"code": "void tscStopCrashReport(){\n\tif (!crashReporting) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&clientStop, 0, 1) != 0) {\n\t\ttscDebug(\"crash report thread already stopped\n\");\n\t\treturn;\n\t}\n\twhile (atomic_load_32(&clientStop) != 0) {\n\t\ttaosMsleep(100);\n\t}\n}", "CodeBleu_score": 78.8472794736314}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t", "CodeBleu_score": 4.465600046220226}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tstruct SViewMetaRsp *pViewMetaRsp;\n\tstruct SViewMeta *pViewMeta;\n\tint32_t ret;\n\tint32_t i;\n\n\tif(valueLen <= 0) {\n\t\treturn TAOS_SUCCESS;\n\t}\n\n\tpViewMetaRsp = (struct SViewMetaRsp *)value;\n\tret = tDeserializeSViewHbRsp(pViewMetaRsp, valueLen);\n\tif(ret != TAOS_SUCCESS) {\n\t\ttaosError(pCatalog->pTaos, \"Deserializing view metadata failed with error: %d\", ret);\n\t\ttFreeSViewMetaRsp(pViewMetaRsp);\n\t\treturn ret;\n\t}\n\n\tfor(i = 0; i < taosArrayGetSize(pViewMetaRsp->viewMeta); i++) {\n\t\tpViewMeta = (struct SViewMeta *)taosArrayGetP(pViewMetaRsp->viewMeta, i);\n\t\tif(pViewMeta->colCount == 0) {\n\t\t\tcatalogRemoveViewMeta(pCatalog, pViewMeta->viewName);\n\t\t} else {\n\t\t\tcatalogUpdateViewMeta(pCatalog, pViewMeta);\n\t\t}\n\t}\n\n\ttFreeSViewMetaRsp(pViewMetaRsp);\n\treturn TAOS_SUCCESS;\n}", "CodeBleu_score": 41.027416497665016}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t rc = 0;\n\tstruct SViewMeta *pViewMeta = NULL;\n\tstruct SViewMeta *pViewMetaArray = NULL;\n\tstruct SViewMeta *pViewMetaArrayEnd = NULL;\n\tstruct SViewMeta *pViewMetaArrayStart = NULL;\n\tstruct SViewMeta *pViewMetaTmp = NULL;\n\tstruct SViewMeta *pViewMetaTmp2 = NULL;\n\tstruct SViewMeta *pViewMetaTmp3 = NULL;\n\tstruct SViewMeta *pViewMetaTmp4 = NULL;\n\tstruct SViewMeta *pViewMetaTmp5 = NULL;\n\tstruct SViewMeta *pViewMetaTmp6 = NULL;\n\tstruct SViewMeta *pViewMetaTmp7 = NULL;\n\tstruct SViewMeta *pViewMetaTmp8 = NULL;\n\tstruct SViewMeta *pViewMetaTmp9 = NULL;\n\tstruct SViewMeta *pViewMetaTmp10 = NULL;\n\tstruct SViewMeta *pViewMetaTmp11 = NULL;\n\tstruct SViewMeta *pViewMetaTmp12 = NULL;\n\tstruct SViewMeta *pViewMetaTmp13 = NULL;\n\tstruct SViewMeta *pViewMetaTmp14 = NULL;\n\tstruct SViewMeta *pViewMetaTmp15 = NULL;\n\tstruct SViewMeta *pViewMetaTmp16 = NULL;\n\tstruct SViewMeta *pViewMetaTmp17 = NULL;\n\tstruct SViewMeta *pViewMetaTmp18 = NULL;\n\tstruct SViewMeta *pViewMetaTmp19 = NULL;\n\tstruct SViewMeta *pViewMetaTmp20 = NULL;\n\tstruct SViewMeta *pViewMetaTmp21 = NULL;\n\tstruct SViewMeta *pViewMetaTmp22 = NULL;\n\tstruct SViewMeta *pViewMetaTmp23 = NULL;\n\tstruct SViewMeta *pViewMetaTmp24 = NULL;\n\tstruct SViewMeta *pViewMetaTmp25 = NULL;\n\tstruct SViewMeta *pViewMetaTmp26 = NULL;\n\tstruct SViewMeta *pViewMetaT", "CodeBleu_score": 8.533160179151693}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tstruct callback_data *data = (struct callback_data *) callbackData;\n\n    data->contentLength = 0;\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 68.50513718147502}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3_put_object_callback_data *data = (S3_put_object_callback_data *) callbackData;\n\n    int64_t contentLength = 0;\n\n    if (properties) {\n        contentLength = properties->contentLength;\n    }\n\n    data->contentLength = contentLength;\n\n    return S3StatusOK;\n}", "CodeBleu_score": 53.531789344056335}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tstruct callback_data *data = (struct callback_data *) callbackData;\n\n    data->contentLength = properties->contentLength;\n\n    return S3StatusOK;\n}", "CodeBleu_score": 51.998183640563425}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tif (taosMulMkDir(tsCheckpointBackupDir, 0755) != 0) {\n    uError(\"[rsync] mkdir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupConf) != 0) {\n    uError(\"[rsync] generate conf error\");\n    return;\n  }\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4, \"rsync --daemon --config=%s\", tsCheckpointBackupConf);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start rsync error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 46.52727192868471}, {"code": "void startRsync(){\n\tif (taosMulMkDir(tsCheckpointBackupDir, 0777) == -1) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret == -1) {\n    uError(\"[rsync] start rsync error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync success, cmd:%s\", cmd);\n  }\n}", "CodeBleu_score": 69.36763819079272}, {"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync server\");\n  if (taosMulMkDir(tsCheckpointBackupDir, 0777) != 0) {\n    uError(\"[rsync] make dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate config file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4, \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start rsync server error\");\n  }\n}", "CodeBleu_score": 64.36831848571533}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n  if (dispatcher == null) {\n    throw new RuntimeException(\"Dispatcher with id '\" + dispatcherId + \"' is not registered.\");\n  }\n  dispatcher.shutdownNow();\n}", "CodeBleu_score": 65.23695261344484}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 66.34404860813447}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tif (dispatcherId == null) {\n        throw new IllegalArgumentException(\"Dispatcher id must not be null\");\n    }\n    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new IllegalStateException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 59.26041294468938}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId[] children = parent.getChildren();\n    if (children != null && children.length > 0) {\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                tell(child, msg, highPriority);\n            }\n        }\n    }\n}", "CodeBleu_score": 45.2143026231043}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tSet<TbActorId> children = parent.getChildren();\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(child -> {\n            if (highPriority) {\n                tellWithHighPriority(child, msg);\n            } else {\n                tell(child, msg);\n            }\n        });\n    }\n}", "CodeBleu_score": 50.55427301083051}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tMap<TbActorId, TbActorRef> children = childrenMap.get(parent);\n    if (children != null) {\n        children.entrySet().stream()\n                .filter(entry -> childFilter.test(entry.getKey()))\n                .forEach(entry -> {\n                    TbActorId childId = entry.getKey();\n                    TbActorRef childRef = entry.getValue();\n                    if (childRef == null) {\n                        log.warn(\"[{}] Failed to broadcast message to child actor [{}], since it is not registered!\", parent, childId);\n                    } else {\n                        if (highPriority) {\n                            childRef.tellWithHighPriority(msg);\n                        } else {\n                            childRef.tell(msg);\n                        }\n                    }\n                });\n    }\n}", "CodeBleu_score": 46.536371386740036}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    }", "CodeBleu_score": 28.377653473966113}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (ready.get() == READY) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else {\n            if (highPriority && msg.getMsgType().equals(ActorMsgType.RULE_NODE_UPDATED_MSG)) {\n                tryInit(0);\n            }\n            onTbActorStopped(msg);\n        }\n    }", "CodeBleu_score": 53.23777688309178}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    }", "CodeBleu_score": 28.377653473966113}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\tint processed = 0;\n    while (busy.get() == BUSY) {\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            if (processed > 0) {\n                log.trace(\"[{}] Mailbox processed {} messages\", selfId, processed);\n            }\n            busy.set(FREE);\n            break;\n        }\n        if (processed >= throughput) {\n            log.trace(\"[{}] Mailbox processed {} messages, throughput limit reached\", selfId, processed);\n            break;\n        }\n        if (highPriorityMsgs.isEmpty()) {\n            if (normalPriorityMsgs.isEmpty()) {\n                log.trace(\"[{}] Mailbox processed {} messages, both queues are empty\", selfId, processed);\n                break;\n            } else {\n                TbActorMsg msg = normalPriorityMsgs.poll();\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                    } catch (TbActorNotInitializedException e) {\n                        log.trace(\"[{}] Failed to process message: {}\", selfId, e.getMessage());\n                        stopReason = TbActorStopReason.NOT_INITIALIZED;\n                        destroy(e);\n                        break;\n                    } catch (Throwable t) {\n                        log.trace(\"[{}] Failed to process message: {}\", selfId, t.getMessage());\n                        onProcessFailure(msg, t);\n                    }\n                    processed++;\n                }\n            }\n        } else {\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg != null) {\n                try {\n                    actor.process(msg);\n                } catch (TbActorNotInitializedException e) {\n                    log.trace(\"[{}] Failed to process message: {}\", selfId, e.getMessage());\n                    stopReason = TbActorStopReason.NOT_INITIALIZED;\n                    destroy(e);\n                    break;\n                } catch (Throwable t) {\n                    log.trace(\"[{", "CodeBleu_score": 42.659767049305785}, {"code": "private void processMailbox(){\n\tlog.trace(\"[{}] Started processing mailbox\", selfId);\n    long startNs = System.nanoTime();\n    int processed = 0;\n    while (processed < getActorThroughput()) {\n        TbActorMsg msg = highPriorityMsgs.poll();\n        if (msg == null) {\n            msg = normalPriorityMsgs.poll();\n        }\n        if (msg == null) {\n            break;\n        }\n        try {\n            actor.process(msg);\n        } catch (TbActorNotInitializedException e) {\n            stopReason = TbActorStopReason.NOT_INITIALIZED;\n            destroy(e);\n            break;\n        } catch (Throwable t) {\n            log.trace(\"[{}] Failed to process message: {}\", selfId, t);\n            onProcessFailure(msg, t);\n        }\n        processed++;\n    }\n    if (processed < getActorThroughput()) {\n        busy.set(FREE);\n        if (!highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty()) {\n            dispatcher.getExecutor().execute(this::processMailbox);\n        }\n    }\n    long duration = System.nanoTime() - startNs;\n    if (duration > 500000000) {\n        log.trace(\"[{}] Mailbox processed in {} ms\", selfId, TimeUnit.NANOSECONDS.toMillis(duration));\n    }\n}", "CodeBleu_score": 49.61501019550263}, {"code": "private void processMailbox(){\n\tlong start = System.nanoTime();\n        int processed = 0;\n        while (processed < maxThroughputPerActor) {\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                break;\n            }\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg == null) {\n                msg = normalPriorityMsgs.poll();\n            }\n            if (msg == null) {\n                break;\n            }\n            try {\n                actor.process(msg);\n            } catch (TbActorNotInitializedException e) {\n                log.trace(\"[{}] Actor is not initialized: {}\", selfId, e.getMessage());\n                stopReason = TbActorStopReason.NOT_INITIALIZED;\n                destroy(e);\n                return;\n            } catch (Throwable e) {\n                log.trace(\"[{}] Failed to process message: {}\", selfId, e.getMessage());\n                try {\n                    actor.onProcessFailure(msg);\n                } catch (Throwable t) {\n                    log.trace(\"[{}] Failed to process failure: {}\", selfId, t.getMessage());\n                    stopReason = TbActorStopReason.FAILED;\n                    destroy(t);\n                    return;\n                }\n                if (actor.getProcessFailureStrategy() == TbActorFailureStrategy.STOP) {\n                    stopReason = TbActorStopReason.FAILED;\n                    destroy(e);\n                    return;\n                }\n            }\n            processed++;\n        }\n        long duration = System.nanoTime() - start;\n        if (processed > 0) {\n            log.trace(\"[{}] Processed {} messages in {} ms\", selfId, processed, TimeUnit.NANOSECONDS.toMillis(duration));\n        }\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            ready.set(READY);\n            busy.set(FREE);\n        } else {\n            dispatcher.getExecutor().execute(", "CodeBleu_score": 44.3476128560192}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.66735696636148}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.66735696636148}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    TenantProfileData tenantProfileData = tenantProfile.getProfileData();\n    TenantProfileConfiguration configuration = tenantProfileData.getConfiguration();\n    if (configuration == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = configuration.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitPolicy rateLimitPolicy = rateLimitConfiguration.getPolicy(api);\n    if (rateLimitPolicy == null) {\n        return true;\n    }\n    RateLimitPolicy.LimitLevel limitLevel = rateLimitPolicy.getLimitLevel();\n    if (limitLevel == null) {\n        return true;\n    }\n    if (limitLevel.equals(RateLimitPolicy.LimitLevel.TENANT)) {\n        return checkRateLimit(api, tenantId, tenantProfile, rateLimitPolicy, rateLimitConfiguration);\n    } else {\n        return checkRateLimit(api, tenantId, tenantProfile, rateLimitPolicy, rateLimitConfiguration, limitLevel);\n    }\n}", "CodeBleu_score": 45.89844259481746}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = getRateLimitConfiguration(api, tenantProfile);\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    boolean result = checkRateLimit(api, tenantId, level, rateLimitConfiguration);\n    if (!result) {\n        processRateLimitNotification(api, tenantId, rateLimitConfiguration);\n    }\n    return result;\n}", "CodeBleu_score": 38.50519449995786}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    TenantProfileData tenantProfileData = tenantProfile.getProfileData();\n    if (tenantProfileData == null) {\n        return true;\n    }\n    EntityLimits entityLimits = tenantProfileData.getLimits();\n    if (entityLimits == null) {\n        return true;\n    }\n    EntityTypeRateLimit entityRateLimit = entityLimits.get(api.getEntityType());\n    if (entityRateLimit == null) {\n        return true;\n    }\n    long limit = entityRateLimit.getLimit();\n    if (limit <= 0) {\n        return true;\n    }\n    long interval = entityRateLimit.getIntervalSec();\n    if (interval <= 0) {\n        return true;\n    }\n    String entityName = getEntityName(api, tenantId, level);\n    if (entityName == null) {\n        return true;\n    }\n    TenantRateLimit tenantRateLimit = get(tenantId, api, entityName);\n    if (tenantRateLimit == null) {\n        tenantRateLimit = build(tenantId, api, entityName, limit, interval);\n    }\n    boolean result = tenantRateLimit.checkAndUpdate(limit, interval);\n    if (!result) {\n        process(tenantId, api, entityName);\n    }\n    return result;\n}", "CodeBleu_score": 46.803871708484195}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = currentTimeMillis() - getValue();\n    for (Map.Entry<String, Long> entry : getEntrySet()) {\n        if (entry.getValue() < expirationTime) {\n            getRemoveIf().accept(entry);\n            trace(\"Evicted DTLS session \" + entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 39.92735395071368}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = currentTimeMillis() - inactivityTimeout;\n    trace(\"Evicting sessions older than {}\", expirationTime);\n    for (Map.Entry<String, DTLSServerSession> entry : sessions.entrySet()) {\n        DTLSServerSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            trace(\"Removing session {}\", entry.getKey());\n            sessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 40.43598923682662}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = currentTimeMillis() - getInactivityTimeout();\n    for (Map.Entry<String, DtlsSession> entry : getSessions().entrySet()) {\n        DtlsSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            trace(\"Removing session %s\", entry.getKey());\n            remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 44.695075153786746}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!timeseries.isEmpty()) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                result.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, value)));\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 48.24777577221327}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!timeseries.isEmpty()) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                result.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, value)));\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 48.24777577221327}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!timeseries.isEmpty()) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> value = entry.getValue();\n            if (value.size() == 1) {\n                result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.get(0).asText())));\n            } else if (value.size() == 2) {\n                long ts = value.get(0).asLong();\n                result.add(new BasicTsKvEntry(ts, new StringDataEntry(key, value.get(1).asText())));\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 45.081564523945}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tMap<String, String> map = new HashMap<>();\n    map.put(\"refreshToken\", this.refreshToken);\n    try {\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(authEndpoint, map, JsonNode.class);\n        setTokenInfo(currentTimeMillis(), response.getBody());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "CodeBleu_score": 47.59957524630093}, {"code": "public void refreshToken(){\n\tMap<String, Object> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", this.refreshToken);\n        ResponseEntity<JsonNode> responseEntity = postForEntity(this.authEndpoint, requestMap, JsonNode.class);\n        if (responseEntity.getStatusCode() == HttpStatus.OK) {\n            setTokenInfo(currentTimeMillis(), responseEntity.getBody());\n        } else {\n            throw new RuntimeException(\"Error refreshing token: \" + responseEntity.getBody());\n        }\n    }", "CodeBleu_score": 42.4656931924837}, {"code": "public void refreshToken(){\n\ttry {\n            Map<String, Object> requestMap = new HashMap<>();\n            requestMap.put(\"refreshToken\", refreshToken);\n            ResponseEntity<JsonNode> response = restTemplate.postForEntity(authUrl, requestMap, JsonNode.class);\n            setTokenInfo(currentTimeMillis(), response.getBody());\n        } catch (Exception e) {\n            log.error(\"Failed to refresh token\", e);\n        }\n    }", "CodeBleu_score": 48.396309631692006}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\ttry {\n            long ts = currentTimeMillis();\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", this.username);\n            loginRequest.put(\"password\", this.password);\n            ResponseEntity<JsonNode> response = postForEntity(this.baseUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n            setTokenInfo(ts, response.getBody());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "CodeBleu_score": 59.62587144903011}, {"code": " private void doLogin(){\n\tlong ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = postForEntity(getLoginUrl(), loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 68.52494061904436}, {"code": " private void doLogin(){\n\tlong ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        JsonNode loginResponse = postForEntity(loginUrl, loginRequest, JsonNode.class);\n        setTokenInfo(ts, loginResponse);\n    }", "CodeBleu_score": 60.272603734964925}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n            \"/api/device/{deviceId}\",\n            Device.class,\n            deviceId\n        );\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 64.49613956127077}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.ofNullable(\n                restTemplate.getForEntity(\n                        \"/api/device/{deviceId}\",\n                        Device.class,\n                        deviceId\n                ).getBody()\n        );\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    }\n}", "CodeBleu_score": 32.62827637086762}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n            \"/api/device/{deviceId}\",\n            Device.class,\n            deviceId\n        );\n\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 64.49613956127077}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\n                \"http://localhost:8080/api/device-with-credentials\",\n                request,\n                Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 65.16885401841186}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<Device> request = new HttpEntity<>(device);\n    try {\n        return Optional.ofNullable(restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class, credentials).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 46.35799314831135}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n        return ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 58.20700328728405}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n\t\ttarget[method] = (duration = 1000, callback = () => {}) => {\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new TypeError(`The callback argument must be a function.`)\n\t\t\t}\n\t\t\tconst signals = []\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tsignals.push(this[i][method](duration))\n\t\t\t}\n\t\t\tPromise.all(signals).then(callback)\n\t\t}\n\t})\n}", "CodeBleu_score": 35.49185963517778}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n\t\ttarget[method] = (duration, callback) => {\n\t\t\tif (!callback || typeof callback !== 'function') {\n\t\t\t\tcallback = () => {};\n\t\t\t}\n\t\t\tduration = duration || 1000;\n\t\t\tconst signals = [];\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tsignals.push(this[i][method]());\n\t\t\t}\n\t\t\tPromise.all(signals).then(() => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tcallback();\n\t\t\t\t}, duration);\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 37.890323256683786}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach((method) => {\n    target[method] = function (duration, callback) {\n      if (typeof duration === 'function') {\n        callback = duration\n        duration = 1000\n      }\n      if (typeof callback !== 'function') {\n        callback = () => {}\n      }\n      const signals = this.map((element) => {\n        return new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(element[method]())\n          }, duration)\n        })\n      })\n      Promise.all(signals).then(callback)\n    }\n  })\n}", "CodeBleu_score": 49.62233345865786}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n    int num_channels = 0;\n    int needed_buffer_size = 0;\n    int i;\n\n    for (i = 0; i < sequence->channels->len; i++) {\n        if (sequence->channels->list[i] < config->num_channels) {\n            num_channels++;\n        } else {\n            LOG_ERR(\"Channel %d is not valid\", sequence->channels->list[i]);\n            return -EINVAL;\n        }\n    }\n\n    needed_buffer_size = num_channels * sizeof(uint16_t);\n\n    if (sequence->options) {\n        needed_buffer_size *= (1 + sequence->options->extra_samplings);\n    }\n\n    if (sequence->buffer_size < needed_buffer_size) {\n        LOG_ERR(\"Provided buffer is too small (%d/%d)\",\n                sequence->buffer_size, needed_buffer_size);\n        return -ENOMEM;\n    }\n\n    return 0;\n}", "CodeBleu_score": 44.185734458233874}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channels = 0U;\n\tsize_t needed_buffer_size;\n\n\tfor (int i = 0; i < config->channel_count; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= 2U;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.739140413866345}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tint num_channels = 0;\n\tint buffer_size = 0;\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < sequence->channels->len; i++) {\n\t\tuint8_t channel_id = sequence->channels->list[i];\n\n\t\tif (channel_id >= config->channel_count) {\n\t\t\tLOG_ERR(\"Channel %d outside of supported range [0, %d)\",\n\t\t\t\tchannel_id, config->channel_count);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!(config->channel_mask & BIT(channel_id))) {\n\t\t\tLOG_ERR(\"Channel %d is not enabled\", channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnum_channels++;\n\t}\n\n\tbuffer_size = num_channels * sizeof(int32_t);\n\n\tif (sequence->options) {\n\t\tif (sequence->options->extra_samplings) {\n\t\t\tbuffer_size *= (1 + sequence->options->extra_samplings);\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Provided buffer of size %u is too small for %u channels\",\n\t\t\tsequence->buffer_size, num_channels);\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 36.33322354687562}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tint error;\n\n\tif (sequence->resolution != AD559X_RESOLUTION) {\n\t\tLOG_ERR(\"AD559x only supports 16-bit resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~BIT_MASK(AD559X_NUM_CHANNELS)) {\n\t\tLOG_ERR(\"AD559x channels mask is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terror = adc_context_wait_for_completion(&data->ctx);\n\n\treturn error;\n}", "CodeBleu_score": 62.41069512094428}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tint error;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"AD559x: unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"AD559x: oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"AD559x: calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\terror = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (error) {\n\t\tLOG_ERR(\"AD559x: unsufficient buffer size\");\n\t\treturn error;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terror = adc_context_wait_for_completion(&data->ctx);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.74388180893816}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tint error;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"AD559x: unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & ~BIT_MASK(config->num_channels)) {\n\t\tLOG_ERR(\"AD559x: unsupported channels 0x%x\", sequence->channels);\n\t\treturn -ENOTSUP;\n\t}\n\n\terror = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (error) {\n\t\tLOG_ERR(\"AD559x: unsufficient buffer size\");\n\t\treturn error;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terror = adc_context_wait_for_completion(&data->ctx);\n\n\treturn error;\n}", "CodeBleu_score": 66.301632072808}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tconst struct device *adc_dev = ctx->dev;\n\tstruct adc_nrfx_data *dev_data = get_dev_data(adc_dev);\n\n\tdev_data->repeat_buffer = ctx->sequence.buffer;\n\tdev_data->channels = ctx->sequence.channels;\n\tdev_data->repeat_size = ctx->sequence.buffer_size;\n\tdev_data->oversampling = ctx->sequence.oversampling;\n\n\tk_sem_give(&dev_data->acq_sem);\n}", "CodeBleu_score": 52.79157487798407}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tconst struct device *adc_dev = ctx->dev;\n    struct adc_nrfx_data *dev_data = get_dev_data(adc_dev);\n    struct adc_nrfx_channel_cfg *ch_cfg;\n    int i, err;\n\n    /* Release semaphore to indicate sampling is started */\n    k_sem_give(&dev_data->adc_sampling_done);\n\n    /* Setup channels */\n    for (i = 0; i < ctx->sequence.channels; i++) {\n        ch_cfg = &dev_data->channels[i];\n        err = adc_nrfx_channel_setup(adc_dev,\n                                     ctx->sequence.channels,\n                                     ch_cfg->input_cfg);\n        if (err) {\n            LOG_ERR(\"Setting up of channel failed with error %d\", err);\n            return;\n        }\n    }\n\n    /* Setup sequence */\n    err = adc_nrfx_sequence_setup(adc_dev, &ctx->sequence);\n    if (err) {\n        LOG_ERR(\"Setting up of sequence failed with error %d\", err);\n        return;\n    }\n\n    /* Setup buffer */\n    err = adc_nrfx_buffer_set(adc_dev, ctx->sequence.buffer,\n                              ctx->sequence.buffer_size);\n    if (err) {\n        LOG_ERR(\"Setting up of buffer failed with error %d\", err);\n        return;\n    }\n\n    /* Start sampling */\n    err = adc_nrfx_sample(adc_dev);\n    if (err) {\n        LOG_ERR(\"Sampling failed to start with error %d\", err);\n        return;\n    }\n}", "CodeBleu_score": 35.084018697414756}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_it8xxx2_data *data = CONTAINER_OF(ctx, struct adc_it8xxx2_data, ctx);\n    struct adc_it8xxx2_regs * const regs = ADC_IT8XXX2_REG_BASE;\n    const struct adc_it8xxx2_cfg * const config = DEV_CFG(data->dev);\n    int chan;\n\n    /*\n     * The ADC is configured to perform sampling on all channels, one at a time,\n     * and to repeat this sequence ADC_IT8XXX2_MAX_CHANNELS times.\n     */\n    for (chan = 0; chan < ADC_IT8XXX2_MAX_CHANNELS; chan++) {\n        if (data->acq_time[chan] != ADC_ACQ_TIME_UNDEFINED) {\n            regs->adc_vch_list[chan] =\n                (data->acq_time[chan] << ADC_IT8XXX2_VCH_LIST_VCH_DATARATE_POS) |\n                (chan << ADC_IT8XXX2_VCH_LIST_VCH_CHANNEL_POS) |\n                ADC_IT8XXX2_VCH_LIST_VCH_EN;\n        } else {\n            regs->adc_vch_list[chan] = 0;\n        }\n    }\n\n    /*\n     * The ADC is configured to convert the channels in the order in which they\n     * appear in the VCH_LIST register. The first channel to be converted is\n     * the one with the lowest number.\n     */\n    regs->adc_vch_ctrl = ADC_IT8XXX2_VCH_CTRL_VCH_EN;\n\n    /*\n     * The ADC is configured to convert channels ADC_IT8XXX2_MAX_CHANNELS\n     * times.\n     */\n    regs->adc_cfg = (regs->adc_cfg & ~ADC_IT8XXX2_CFG_ADC_MODE_MASK) |\n                    ADC_", "CodeBleu_score": 40.06281336223044}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->buffer;\n\t}\n}", "CodeBleu_score": 47.030926920428854}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t/* Retrieve the ADC data container from the context. */\n\tstruct adc_async_device *device = ctx->device;\n\tstruct adc_async_convert *convert = &device->convert;\n\n\t/* If repeat sampling is enabled, set the buffer pointer to the repeat buffer. */\n\tif (repeat_sampling) {\n\t\tconvert->buffer = convert->repeat_buffer;\n\t}\n}", "CodeBleu_score": 50.22260097360369}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tstruct adc_data_container *container = ctx->data_container;\n\tif (repeat_sampling) {\n\t\tcontainer = ctx->repeat_data_container;\n\t}\n\tcontainer->buffer_pointer = container->buffer;\n}", "CodeBleu_score": 47.08868653488808}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\twhile (ctx->channel_id < config->channel_map_size) {\n\t\t\tret = adc_ad559x_read_channel(data->dev, config->channel_map[ctx->channel_id], &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d (%d)\",\n\t\t\t\t\tconfig->channel_map[ctx->channel_id], ret);\n\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx->buffer[ctx->buffer_pos] = result;\n\t\t\tctx->buffer_pos += ctx->sequence.oversampling;\n\t\t\tctx->channel_id++;\n\t\t}\n\n\t\tadc_context_on_sampling_done(ctx, data->dev);\n\t}\n}", "CodeBleu_score": 50.63871556786953}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tuint8_t channel;\n\tuint16_t val;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->channels; channel++) {\n\t\t\tif (data->active_channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &val);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer[channel] = val;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, data->dev);\n\t}\n}", "CodeBleu_score": 58.187730889644776}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tuint8_t channel_mask;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tif (ctx->channels == 0) {\n\t\t\tLOG_ERR(\"No channels selected\");\n\t\t\tadc_context_complete(ctx, -EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchannel_mask = 0;\n\t\twhile (channel_mask < config->channel_map_size) {\n\t\t\tchannel = find_lsb_set(ctx->channels & ~channel_mask);\n\t\t\tchannel_mask |= BIT(channel);\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d (%d)\", channel, ret);\n\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tWRITE_BIT(data->buffer, channel, result);\n\t\t}\n\n\t\tadc_context_on_sampling_done(ctx, data->dev);\n\t}\n}", "CodeBleu_score": 54.77154948186585}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val;\n\tint rc;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\twhile (true) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (!(reg_val & ADS1112_REG_CONFIG_OS_MASK)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.48985502841947}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t config_reg = 0;\n\tint rc = 0;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\twhile (1) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif ((config_reg & ADS1112_CONFIG_STATUS_MASK) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 56.05413648263765}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tint rc;\n\tuint8_t reg_val;\n\tuint8_t ready_bit;\n\tuint8_t reg_addr = ADS1112_REG_CONFIG;\n\n\tk_sleep(K_USEC(ADS1112_READY_TIME));\n\n\twhile (1) {\n\t\trc = ads1112_read_reg(dev, reg_addr, &reg_val);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tready_bit = (reg_val & ADS1112_CONFIG_READY_MASK) >> ADS1112_CONFIG_READY_SHIFT;\n\t\tif (ready_bit == 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n}", "CodeBleu_score": 51.17499959612931}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tuint8_t num_channels = 0;\n\tuint8_t num_samplings = 0;\n\tuint8_t num_extra_samplings = 0;\n\tuint8_t required_buffer_size = 0;\n\n\t/*\n\t * Calculate the number of channels and samplings in the sequence\n\t */\n\tfor (uint8_t i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tnum_channels++;\n\t\t\tnum_samplings += sequence->options->extra_samplings + 1;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the number of extra samplings\n\t */\n\tif (sequence->options) {\n\t\tif (sequence->options->interval_us) {\n\t\t\tnum_extra_samplings = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the required buffer size\n\t */\n\trequired_buffer_size = num_channels * num_samplings * num_extra_samplings * sizeof(uint16_t);\n\n\t/*\n\t * Check if the buffer size is sufficient\n\t */\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"The buffer size is not sufficient. Required: %d, actual: %d\", required_buffer_size, sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.724653866771604}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tsize_t required_buffer_size;\n\n\trequired_buffer_size = ads1112_get_required_buffer_size(sequence);\n\tif (sequence->options & ADC_CALIBRATE) {\n\t\trequired_buffer_size *= 2;\n\t}\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\t\tsequence->buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.754791521991066}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tsize_t required_buffer_size;\n\n\trequired_buffer_size = ads1112_get_required_buffer_size(sequence);\n\n\tif (sequence->options) {\n\t\tif (sequence->options->extra_samplings) {\n\t\t\trequired_buffer_size *= (1 + sequence->options->extra_samplings);\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\t\tsequence->buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 62.03605965822442}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tstruct ads1112_config *config = dev->config;\n\tstruct ads1112_sequence_options *options = sequence->options;\n\tint result;\n\n\tresult = ads1112_validate_sequence(dev, sequence);\n\tif (result < 0) {\n\t\treturn result;\n\t}\n\n\tdata->sequence = sequence;\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_length = sequence->buffer_size / sizeof(uint16_t);\n\n\tif (options->start_read_cb) {\n\t\toptions->start_read_cb(dev, options->start_read_user_data);\n\t}\n\n\tresult = ads1112_start_read(dev, config, options);\n\n\tif (result < 0) {\n\t\tdata->buffer = NULL;\n\t\tdata->buffer_length = 0;\n\t\tdata->sequence = NULL;\n\t\treturn result;\n\t}\n\n\tif (wait) {\n\t\tresult = adc_context_wait_for_completion(&data->ctx, &data->sync);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 54.43305173098436}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint error;\n\n\terror = ads1112_validate_sequence(dev, sequence);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\tdata->seq_size = sequence->buffer_size;\n\n\tif (wait) {\n\t\treturn adc_context_wait_for_completion(&data->ctx, sequence);\n\t}\n\n\treturn adc_context_start_read(&data->ctx, sequence);\n}", "CodeBleu_score": 57.43562494906297}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->sequence = sequence;\n\n\terr = adc_context_start_read(&data->ctx, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (wait) {\n\t\terr = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 64.43273720880546}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\treturn audio_codec_apply_properties(dev, &prop);\n}", "CodeBleu_score": 66.63862744123028}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev = device_get_binding(argv[1]);\n\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn audio_codec_apply_properties(dev, &prop);\n}", "CodeBleu_score": 58.25965181689406}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\tstruct audio_codec_cfg cfg;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Could not get audio codec device binding\");\n\t\treturn -EINVAL;\n\t}\n\n\tcfg.dai_type = AUDIO_DAI_TYPE_I2S;\n\tcfg.dai_cfg.i2s.word_size = AUDIO_PCM_WIDTH_16_BITS;\n\tcfg.dai_cfg.i2s.channels = AUDIO_CHANNEL_STEREO;\n\tcfg.dai_cfg.i2s.format = AUDIO_PCM_FMT_I2S;\n\tcfg.dai_cfg.i2s.options = AUDIO_PCM_DRIVER_FIFO;\n\tcfg.dai_cfg.i2s.pcm_rate = 48000;\n\tcfg.dai_cfg.i2s.options = AUDIO_PCM_DRIVER_FIFO;\n\n\tret = audio_codec_configure(dev, &cfg);\n\tif (ret) {\n\t\tshell_error(sh, \"Could not apply audio codec properties (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.69402368435661}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\tint ret = 0;\n\tuint8_t i2s_cmd = 0;\n\tuint8_t i2s_state = 0;\n\tuint8_t i2s_next_state = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\ti2s_cmd = I2S_TRIGGER_START;\n\t\t\ti2s_state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t\ti2s_next_state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state for START trigger\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\ti2s_cmd = I2S_TRIGGER_STOP;\n\t\t\ti2s_state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t\ti2s_next_state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state for STOP trigger\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = i2s_trigger(config->i2s_dev, i2s_cmd, i2s_state);\n\tif (ret) {\n\t\tLOG_ERR(\"I2S trigger failed (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->state = i2s_next", "CodeBleu_score": 61.45796690344476}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_dev_data *data = dev->data;\n    struct mpxxdtyy_dev_config *config = dev->config;\n    int ret = 0;\n\n    if (cmd == DMIC_TRIGGER_START) {\n        if (data->state == MPXXDTYY_STATE_CONFIGURED) {\n            data->state = MPXXDTYY_STATE_ACTIVE;\n            ret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n            if (ret != 0) {\n                LOG_ERR(\"I2S trigger start failed: %d\", ret);\n                data->state = MPXXDTYY_STATE_CONFIGURED;\n            }\n        } else {\n            LOG_ERR(\"I2S trigger start failed: invalid state %d\", data->state);\n        }\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n        if (data->state == MPXXDTYY_STATE_ACTIVE) {\n            data->state = MPXXDTYY_STATE_CONFIGURED;\n            ret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n            if (ret != 0) {\n                LOG_ERR(\"I2S trigger stop failed: %d\", ret);\n                data->state = MPXXDTYY_STATE_ACTIVE;\n            }\n        } else {\n            LOG_ERR(\"I2S trigger stop failed: invalid state %d\", data->state);\n        }\n    } else {\n        LOG_ERR(\"I2S trigger failed: invalid command %d\", cmd);\n    }\n\n    return ret;\n}", "CodeBleu_score": 44.41403845798624}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_dev_data *data = dev->data;\n\tconst struct mpxxdtyy_dev_cfg *cfg = dev->config;\n\tint ret = 0;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state != MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device is not configured\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to start I2S device\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state != MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device is not active\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to stop I2S device\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t} else {\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.62681694908217}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_mode) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->blink_mode) {\n\t\tcmd |= AUXDISPLAY_HD44780_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, AUXDISPLAY_HD44780_DISPLAY_MODE_SET | cmd, config->mode);\n}", "CodeBleu_score": 74.49699279508583}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_BLINK_ON;\n\t}\n\n\tif (config->display_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->display_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 68.63469205347043}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd;\n\n\tcmd = AUXDISPLAY_HD44780_DISPLAY_MODE_SET |\n\t\t(enabled ? AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON : 0) |\n\t\t(data->cursor_on ? AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON : 0) |\n\t\t(data->blink_on ? AUXDISPLAY_HD44780_DISPLAY_MODE_BLINK_ON : 0);\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 43.861034692638626}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\n    if (config->busy_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_dt(config->busy_port, config->busy_pin);\n}", "CodeBleu_score": 71.72844988472174}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n    struct gpio_dt_spec busy_gpio = GPIO_DT_SPEC_GET_OR(config->busy_gpio, gpios, {0});\n\n    if (!busy_gpio.port) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_dt(&busy_gpio);\n}", "CodeBleu_score": 39.041572446239876}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n    if (config->busy_gpio_port < 0) {\n        return -ENOTSUP;\n    }\n    return gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 67.3327708810144}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n    uint8_t buffer[2];\n    int ret;\n\n    buffer[0] = SERLCD_SPECIAL_COMMAND_PREFIX;\n    buffer[1] = command;\n\n    ret = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n    k_sleep(K_MSEC(config->special_command_delay));\n\n    return ret;\n}", "CodeBleu_score": 71.43138177928996}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n    uint8_t buffer[2];\n    int ret;\n\n    buffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n    buffer[1] = (uint8_t)command;\n\n    ret = i2c_write_dt(&data->i2c, buffer, sizeof(buffer));\n    k_sleep(K_MSEC(data->config->command_delay_ms));\n\n    return ret;\n}", "CodeBleu_score": 56.56217454565733}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n    uint8_t command_buffer[2];\n    int ret;\n\n    command_buffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n    command_buffer[1] = command;\n\n    ret = i2c_write_dt(&data->i2c, command_buffer, sizeof(command_buffer));\n\n    k_sleep(K_MSEC(data->config->special_command_delay));\n\n    return ret;\n}", "CodeBleu_score": 55.193536541463374}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\tint ret;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (size > emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &emul_data->memory[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 51.79227153151365}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 71.27528961812195}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->memory + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 68.23738693417427}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *dev_data = dev->data;\n\tint rc;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\trc = memcpy(dev_data->data + offset, data, size);\n\n\treturn rc;\n}", "CodeBleu_score": 66.94330618698515}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\tint ret;\n\n\tif (size > emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(emul_data->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.15478790480611}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data_dev = dev->data;\n\tint rc;\n\n\tif (size > CONFIG_BIG_ENDIAN_EMUL_BBRAM_SIZE) {\n\t\tLOG_ERR(\"Write size too large: %d\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > CONFIG_BIG_ENDIAL_EMUL_BBRAM_SIZE) {\n\t\tLOG_ERR(\"Write out of bounds: %d\", offset + size);\n\t\treturn -EINVAL;\n\t}\n\n\trc = bbram_emul_check_invalid(dev);\n\tif (rc) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_dev->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 61.146045897480185}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 83.15234243972378}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 84.4872098343864}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"No device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 81.6752857862865}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct bt_hci_h4_dev *h4 = dev->data;\n\tint err;\n\tuint8_t *hdr = h4->rx_buf;\n\tsize_t len = h4->rx_len;\n\tsize_t read = 0;\n\n\twhile (len) {\n\t\tread = uart_fifo_read(h4->uart, hdr, len);\n\t\tif (read == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= read;\n\t\thdr += read;\n\t}\n\n\tif (len) {\n\t\tLOG_ERR(\"Failed to read full H:4 header\");\n\t}\n\n\th4->rx_len -= h4->rx_buf - hdr;\n\th4->rx_buf = hdr;\n}", "CodeBleu_score": 38.67212135008594}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct bt_hci_h4_dev *h4 = dev->data;\n\tint err, read;\n\tread = h4->rx_len;\n\terr = uart_fifo_read(h4->uart, h4->rx_buf, BT_HCI_H4_HDR_SIZE);\n\tif (err < 0) {\n\t\tLOG_ERR(\"Failed to read H:4 header (%d)\", err);\n\t\treturn;\n\t}\n\tread += err;\n\th4->rx_len = BT_HCI_H4_HDR_SIZE - read;\n}", "CodeBleu_score": 45.5981123340424}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct bt_hci_h4_dev_data_t * const dev_data = DEV_DATA(dev);\n\tuint8_t * const hdr = dev_data->rx_buf;\n\tsize_t read = dev_data->rx_len;\n\tint err;\n\tif (read == H4_HDR_SIZE) {\n\t\treturn;\n\t}\n\terr = uart_fifo_read(dev_data->uart_dev, hdr + read,\n\t\t\t     H4_HDR_SIZE - read);\n\tif (err < 0) {\n\t\tBT_ERR(\"Unable to read from UART (err %d)\", err);\n\t\treturn;\n\t}\n\tread += err;\n\tdev_data->rx_len = read;\n}", "CodeBleu_score": 45.07539180324483}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n\tsize_t read = 0;\n\tsize_t total = 0;\n\tint err;\n\n\twhile (len) {\n\t\tread = min(len, sizeof(buf));\n\t\terr = uart_fifo_read(uart, buf, read);\n\t\tif (err < 0) {\n\t\t\tLOG_ERR(\"Failed to discard %zu bytes (%d)\", len, err);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= read;\n\t\ttotal += read;\n\t}\n\n\treturn total;\n}", "CodeBleu_score": 48.16078048698286}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n\tsize_t read;\n\tint err;\n\twhile (len) {\n\t\tread = MIN(len, sizeof(buf));\n\t\terr = uart_fifo_read(uart, buf, read);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Failed to discard %zu bytes (%d)\", len, err);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= read;\n\t}\n\treturn read;\n}", "CodeBleu_score": 49.189976881692466}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t read;\n    int err;\n    if (len > 32) {\n        len = 32;\n    }\n    err = uart_fifo_read(uart, buf, len);\n    if (err) {\n        LOG_ERR(\"Unable to discard FIFO contents: %d\", err);\n        return 0;\n    }\n    read = uart_fifo_read(uart, buf, len);\n    if (read != len) {\n        LOG_ERR(\"Unable to discard FIFO contents: %d\", err);\n        return 0;\n    }\n    return read;\n}", "CodeBleu_score": 56.41394116022719}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tunsigned int i;\n    unsigned int hop = 0;\n    struct zbus_observer *obs;\n\n    spin_lock(&chan->lock);\n\n    for (i = 0; i < chan->n_observers; i++) {\n        obs = chan->observers[i];\n\n        if (obs->enabled && obs->priority < hop) {\n            hop = obs->priority;\n        }\n    }\n\n    chan->highest_observer_priority = hop;\n    spin_unlock(&chan->lock);\n}", "CodeBleu_score": 26.348484029737975}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tunsigned int hop = ZBUS_CHAN_HOP_MAX;\n\tstruct zbus_observer *obs;\n\n\t/* Lock the channel data */\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n\t/* Iterate through the observers */\n\tfor (obs = chan->observers; obs; obs = obs->next) {\n\t\t/* If the observer is enabled and has a lower priority than the current highest,\n\t\t * update the highest observer priority.\n\t\t */\n\t\tif (obs->enabled && obs->priority < hop) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\t/* Set the channel's highest observer priority to the determined value */\n\tchan->highest_priority = hop;\n\n\t/* Unlock the channel data */\n\tk_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 20.47291318341061}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tint i;\n    int hop = 0;\n    int priority;\n    struct zbus_observer *observer;\n\n    for (i = 0; i < CONFIG_ZBUS_CHANNEL_OBSERVER_COUNT; i++) {\n        observer = &chan->observers[i];\n        priority = observer->priority;\n\n        if (priority > hop && observer->enabled) {\n            hop = priority;\n        }\n    }\n\n    chan->highest_observer_priority = hop;\n}", "CodeBleu_score": 26.876368259732033}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tint16_t i = 0;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int16_t limit = _zbus_chan_observations_end_idx;\n\n\t\tfor (; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation_mask->enabled && obs == observation->obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 22.30662677439938}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tconst int limit = _zbus_chan_observations_end_idx;\n\n\tfor (int16_t i = _zbus_chan_observations_start_idx; i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\tif (observation->obs == obs && !observation_mask->enabled) {\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 21.08213360547278}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tconst int limit = _zbus_chan_observations_end_idx;\n\n\tfor (int16_t i = _zbus_chan_observations_start_idx; i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\tconst struct zbus_observer *obs_to_check = observation->obs;\n\n\t\tif (obs_to_check == obs && !observation_mask->enabled) {\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 20.558302993050308}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n\t__ASSERT_NO_MSG(obs != NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\n\tobs->prio = K_LOWEST_THREAD_PRIO;\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 51.640341649341146}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n\t__ASSERT_NO_MSG(obs != NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\n\tobs->prio = K_LOWEST_THREAD_PRIO;\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 49.853091336062256}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tK_SPINLOCK_KEY_DEFINE(key);\n\n\t_ZBUS_ASSERT(k_is_in_isr() == false);\n\t_ZBUS_ASSERT(obs != NULL);\n\n\tk_spinlock_key_get(&zbus_lock, &key);\n\tobs->prio = K_LOWEST_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spinlock_key_put(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 50.67639610519974}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"zbus_chan_notify: chan must not be NULL\");\n\n\ttimeout = k_is_in_isr() ? K_NO_WAIT : timeout;\n\n\tk_timepoint_t end_time = sys_timepoint_get();\n\n\tend_time = sys_timepoint_add(end_time, sys_timepoint_timeout(timeout));\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 52.829267745606536}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\ttimeout = k_timeout_adjust(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_get();\n\n\tsys_timepoint_add(&end_time, timeout);\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 52.03131329262219}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\ttimeout = sys_timeout_t_to_ms(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_get();\n\n\tif (timeout != K_NO_WAIT) {\n\t\tend_time = sys_timepoint_add(end_time, timeout, K_MSEC);\n\t}\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 56.401422760006184}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\tif (enable) {\n\t\t/* Enable the selected ETHERNET interrupts */\n\t\tETH->IER |= Int;\n\t} else {\n\t\t/* Disable the selected ETHERNET interrupts */\n\t\tETH->IER &= ~Int;\n\t}\n}", "CodeBleu_score": 23.745930144613993}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tif (Int & IS_ETH_INT_ABNORMAL) {\n\t\tif (enable) {\n\t\t\tETH->DMAIER |= (Int & IS_ETH_INT_ABNORMAL);\n\t\t} else {\n\t\t\tETH->DMAIER &= ~(Int & IS_ETH_INT_ABNORMAL);\n\t\t}\n\t}\n\n\tif (Int & IS_ETH_INT_NORMAL) {\n\t\tif (enable) {\n\t\t\tETH->DMAIER |= (Int & IS_ETH_INT_NORMAL);\n\t\t} else {\n\t\t\tETH->DMAIER &= ~(Int & IS_ETH_INT_NORMAL);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.22831887355474}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\n\tif (enable) {\n\t\tif (IS_ETH_INT_NORMAL(Int)) {\n\t\t\t/* Enable the normal interrupt */\n\t\t\tETH->DMAIER |= Int;\n\t\t} else {\n\t\t\t/* Enable the abnormal interrupt */\n\t\t\tETH->DMAIER |= (Int >> 16);\n\t\t}\n\t} else {\n\t\tif (IS_ETH_INT_NORMAL(Int)) {\n\t\t\t/* Disable the normal interrupt */\n\t\t\tETH->DMAIER &= ~Int;\n\t\t} else {\n\t\t\t/* Disable the abnormal interrupt */\n\t\t\tETH->DMAIER &= ~(Int >> 16);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.251633425056276}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n\n\t/* Get the current Tx descriptor address */\n\tpTxDesc = (ETH_TX_DESC *)ETH->DMATXDESCADDR;\n\n\t/* Check if the descriptor is owned by the device */\n\tif (pTxDesc->DMATXDESC_STAT & ETH_DMATXDESC_OWN) {\n\n\t\t/* Loop back to the beginning of the descriptor list */\n\t\tif (pTxDesc == &ETH_TX_DESC_BASE[ETH_TX_DESC_CNT - 1]) {\n\t\t\tpTxDesc = &ETH_TX_DESC_BASE[0];\n\t\t}\n\t\telse {\n\t\t\tpTxDesc++;\n\t\t}\n\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif (pTxDesc->DMATXDESC_STAT & ETH_DMATXDESC_OWN) {\n\n\t\t\t/* Loop back to the beginning of the descriptor list */\n\t\t\tif (pTxDesc == &ETH_TX_DESC_BASE[ETH_TX_DESC_CNT - 1]) {\n\t\t\t\tpTxDesc = &ETH_TX_DESC_BASE[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpTxDesc++;\n\t\t\t}\n\n\t\t\t/* Check if the descriptor is owned by the device */\n\t\t\tif (pTxDesc->DMATXDESC_STAT & ETH_DMATXDESC_OWN) {\n\n\t\t\t\t/* Loop back to the beginning of the descriptor list */\n\t\t\t\tif (pTxDesc == &ETH_TX_DESC_BASE[ETH_TX_DESC_CNT - 1]) {\n\t\t\t\t\tpTxDesc = &ETH_TX_DESC_BASE[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpTxDesc++;\n\t\t\t\t}\n\n\t\t\t\t/*", "CodeBleu_score": 40.725447892044144}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\t/* Get the current transmit descriptor address */\n\tpTxDesc = (ETH_TX_DESC *)(ETH->DMATXDESCADDR);\n\n\t/* Check if the descriptor is owned by the device */\n\tfor (i = 0; i < NUM_TX_DESCRIPTORS; i++) {\n\t\tif (pTxDesc->Status & TX_DESC_STATUS_OWN) {\n\t\t\t/* Increment the descriptor address to the next descriptor in the list */\n\t\t\tpTxDesc++;\n\n\t\t\t/* Check if the descriptor is the last descriptor in the list */\n\t\t\tif (pTxDesc == &TxDescList[NUM_TX_DESCRIPTORS]) {\n\t\t\t\t/* Wrap to the beginning of the descriptor list */\n\t\t\t\tpTxDesc = &TxDescList[0];\n\t\t\t}\n\t\t} else {\n\t\t\t/* Return the descriptor address */\n\t\t\treturn pTxDesc;\n\t\t}\n\t}\n\n\t/* Return 0 if no free descriptor is found */\n\treturn 0;\n}", "CodeBleu_score": 44.899357065083024}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n  uint32_t i;\n\n  pTxDesc = (ETH_TX_DESC *)(ETH_DMATxDescTab);\n  for (i = 0; i < ETH_TXBUFNB; i++) {\n    if ((pTxDesc->Status & ETH_DMATxDesc_OWN) == (uint32_t)RESET) {\n      return pTxDesc;\n    }\n    pTxDesc++;\n  }\n  return 0;\n}", "CodeBleu_score": 35.49506044483676}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t result = RT_EOK;\n\n    if (device == RT_NULL) {\n        LOG_E(\"The device is null\");\n        return -RT_ERROR;\n    }\n\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"The DAC output cannot be enabled\");\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 55.36558562721863}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tstruct cyp_dac_device *cyp_dac_device = (struct cyp_dac_device *)device;\n    rt_uint32_t cyp_dac_channel = 0;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_device->cyp_dac_base, cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"DAC channel %d enable failed.\", channel);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 59.45021150196117}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_uint32_t cyp_dac_channel = 0;\n    CY_ASSERT(device != NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"Failed to initialize DAC channel %d\", channel);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 55.74077495691502}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > IFX_FLASH_32K_END_ADDR) {\n        LOG_E(\"ifx_flash_read_32k: invalid argument.\");\n        return -1;\n    }\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n    return size;\n}", "CodeBleu_score": 43.14881985366562}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > FLASH_32K_END_ADDR) {\n        LOG_E(\"Reading out of flash memory range.\");\n        return -1;\n    }\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *((rt_uint8_t *)addr + i);\n    }\n    return size;\n}", "CodeBleu_score": 40.84761674142351}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > FLASH_END_ADDR) {\n        LOG_E(\"ERROR: Read operation exceeds flash memory's end address!\n\");\n        return -1;\n    }\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *) (FLASH_BASE_ADDR + addr + i);\n    }\n    return size;\n}", "CodeBleu_score": 43.11098507971661}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 32.0215024610336}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 32.0215024610336}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 32.0215024610336}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\trt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.164141391396628}, {"code": "void dfs_lock(void){\n\trt_err_t result;\n\n    result = rt_mutex_take(dfs_mutex, RT_WAITING_FOREVER);\n    RT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 14.164869784686068}, {"code": "void dfs_lock(void){\n\trt_mutex_take(dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.200900498294255}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            break;\n        }\n    }\n\n    if (fd >= fdt->maxfd)\n    {\n        fd = fd_slot_expand(fdt, fd);\n    }\n\n    return fd;\n}", "CodeBleu_score": 37.31914396688959}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint index;\n\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    return fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 33.27910362062003}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* expand the table */\n    return fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 28.48848496283538}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\tstatic const char *rt_errstr[] = {\n        \"EOK\",\n        \"EPERM\",\n        \"ENOENT\",\n        \"EIO\",\n        \"ENXIO\",\n        \"EINTR\",\n        \"EINVAL\",\n        \"ENOEXEC\",\n        \"EBADF\",\n        \"ECHILD\",\n        \"EAGAIN\",\n        \"ENOMEM\",\n        \"EACCES\",\n        \"EFAULT\",\n        \"EBUSY\",\n        \"EEXIST\",\n        \"EXDEV\",\n        \"ENODEV\",\n        \"ENOTDIR\",\n        \"EISDIR\",\n        \"EINVAL\",\n        \"ENFILE\",\n        \"EMFILE\",\n        \"ENOTTY\",\n        \"EFBIG\",\n        \"ENOSPC\",\n        \"ESPIPE\",\n        \"EROFS\",\n        \"EMLINK\",\n        \"EPIPE\",\n        \"EDOM\",\n        \"ERANGE\",\n        \"EDEADLK\",\n        \"ENAMETOOLONG\",\n        \"ENOLCK\",\n        \"ENOSYS\",\n        \"ENOTEMPTY\",\n        \"EILSEQ\",\n        \"STRUNCATE\",\n        \"EUNKNOWN\"\n    };\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    if (error > sizeof(rt_errstr) / sizeof(rt_errstr[0])) {\n        return \"EUNKNOWN\";\n    }\n\n    return rt_errstr[error];\n}", "CodeBleu_score": 28.1061867381602}, {"code": "const char *rt_strerror(rt_err_t error){\n\tint i;\n    static const char *rt_err_str[] = {\n        \"EOK\",\n        \"EPERM\",\n        \"ENOENT\",\n        \"EIO\",\n        \"ENXIO\",\n        \"E2BIG\",\n        \"ENOEXEC\",\n        \"EBADF\",\n        \"ECHILD\",\n        \"EAGAIN\",\n        \"ENOMEM\",\n        \"EACCES\",\n        \"EFAULT\",\n        \"ENOTBLK\",\n        \"EBUSY\",\n        \"EEXIST\",\n        \"EXDEV\",\n        \"ENODEV\",\n        \"ENOTDIR\",\n        \"EISDIR\",\n        \"EINVAL\",\n        \"ENFILE\",\n        \"EMFILE\",\n        \"ENOTTY\",\n        \"ETXTBSY\",\n        \"EFBIG\",\n        \"ENOSPC\",\n        \"ESPIPE\",\n        \"EROFS\",\n        \"EMLINK\",\n        \"EPIPE\",\n        \"EDOM\",\n        \"ERANGE\",\n        \"EDEADLK\",\n        \"ENAMETOOLONG\",\n        \"ENOLCK\",\n        \"ENOSYS\",\n        \"ENOTEMPTY\",\n        \"ELOOP\",\n        \"EWOULDBLOCK\",\n        \"ENOMSG\",\n        \"EIDRM\",\n        \"ECHRNG\",\n        \"EL2NSYNC\",\n        \"EL3HLT\",\n        \"EL3RST\",\n        \"ELNRNG\",\n        \"EUNATCH\",\n        \"ENOCSI\",\n        \"EL2HLT\",\n        \"EBADE\",\n        \"EBADR\",\n        \"EXFULL\",\n        \"ENOANO\",\n        \"EBADRQC\",\n        \"EBADSLT\",\n        \"EDEADLOCK\",\n        \"EBFONT\",\n        \"ENOSTR\",\n        \"ENODATA\",\n        \"ETIME\",\n        \"ENOSR\",\n        \"ENONET\",\n        \"ENOPKG\",\n        \"EREMOTE\",\n        \"ENOLINK\",\n        \"EAD", "CodeBleu_score": 5.90975139973794}, {"code": "const char *rt_strerror(rt_err_t error){\n\tint i;\n    int n = sizeof(rt_errlist) / sizeof(struct rt_strerror_def);\n\n    /* check if the error code is negative */\n    if (error < 0) {\n        /* make the error code positive */\n        error = -error;\n    }\n\n    /* iterate through the array of known error strings to find a match */\n    for (i = 0; i < n; i++) {\n        if (rt_errlist[i].err_code == error) {\n            return rt_errlist[i].err_str;\n        }\n    }\n\n    /* return \"EUNKNOW\" if no match was found */\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 65.39302132268558}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\tstruct rt_thread *tidle;\n    rt_base_t level;\n    rt_slist_t *list;\n    int i;\n\n    /* parameter check */\n    if (hook == RT_NULL)\n        return -RT_ERROR;\n\n    tidle = rt_thread_find(\"tidle\");\n    RT_ASSERT(tidle != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n\n    list = &(tidle->idle_hook_list);\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_slist_isempty(list)) {\n            rt_slist_init(list);\n        }\n\n        if (rt_slist_isempty(list)) {\n            rt_slist_insert(list, (rt_slist_t *)hook);\n            rt_hw_interrupt_enable(level);\n\n            return RT_EOK;\n        }\n\n        list = rt_slist_next(list);\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return -RT_EFULL;\n}", "CodeBleu_score": 46.936543811181075}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n  rt_thread_t tidle;\n  rt_uint8_t i;\n\n  result = RT_EOK;\n  tidle = rt_thread_idle_gethandler();\n\n  rt_spin_lock_irqsave(&tidle->spinlock);\n\n  for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n    if (tidle->idle_hook_list[i] == RT_NULL) {\n      tidle->idle_hook_list[i] = hook;\n      break;\n    }\n  }\n\n  if (i == RT_IDLE_HOOK_LIST_SIZE) {\n    result = -RT_EFULL;\n  }\n\n  rt_spin_unlock_irqrestore(&tidle->spinlock);\n\n  return result;\n}", "CodeBleu_score": 55.22762018388232}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n\trt_ubase_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_thread_idle_hook_list_available_slots() > 0) {\n\t\trt_thread_idle_hook_register(hook);\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 19.480058779744695}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_err_t result;\n    rt_thread_t tidle;\n    rt_uint8_t i;\n\n    tidle = rt_thread_idle_gethook();\n\n    rt_spin_lock_irqsave(&tidle->spinlock, result);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (tidle->idle_hook_list[i] == hook) {\n            tidle->idle_hook_list[i] = RT_NULL;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&tidle->spinlock, result);\n\n    return result;\n}", "CodeBleu_score": 57.76916759094512}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_err_t result;\n    rt_uint32_t level;\n    struct rt_idle_hook *idle_hook;\n\n    level = rt_hw_interrupt_disable();\n    idle_hook = rt_thread_idle_hook_list;\n    while (idle_hook != RT_NULL) {\n        if (idle_hook->hook == hook) {\n            idle_hook->hook = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n        idle_hook = idle_hook->next;\n    }\n    if (idle_hook == RT_NULL) {\n        result = -RT_ERROR;\n    }\n    rt_hw_interrupt_enable(level);\n    return result;\n}", "CodeBleu_score": 46.99596832596937}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_err_t result;\n    rt_ubase_t temp;\n    rt_ubase_t i;\n\n    /* disable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(temp);\n\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 72.87778409748282}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_ubase_t  level;\n    rt_thread_t thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* resume all suspended threads */\n    while (!rt_list_isempty(susp_list)) {\n        /* get next suspended thread */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        /* set error number */\n        thread->error = thread_error;\n        /*\n         * resume thread\n         * In function: \"rt_thread_resume\"\n         * It removes the thread from current scheduler list and inserts to ready list.\n         */\n        rt_thread_resume(thread);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.61570486237023}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_ubase_t level;\n    struct rt_thread *thread;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n\n    while (!rt_list_isempty(susp_list)) {\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        rt_susp_list_dequeue(thread);\n        thread->error = thread_error;\n        rt_thread_resume(thread);\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 38.17754263779358}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_ubase_t level;\n    rt_thread_t thread;\n\n    level = rt_hw_interrupt_disable();\n\n    /* resume all suspended threads */\n    while (!rt_list_isempty(susp_list)) {\n        /* get next suspended thread */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        /* set error number */\n        thread->error = thread_error;\n        /*\n         * resume thread\n         * In function: \"rt_thread_resume\"\n         * 1.remove thread from suspend list\n         * 2.mark thread as RT_THREAD_READY\n         * 3.add to ready list\n         */\n        rt_thread_resume(thread);\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 34.445439031948986}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t new_dev = RT_NULL;\n    rt_device_t old_dev = RT_NULL;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    old_dev = console_device;\n\n    if (console_device != RT_NULL) {\n        rt_device_close(console_device);\n    }\n\n    new_dev = rt_device_find(name);\n    if (new_dev != RT_NULL) {\n        if (rt_device_open(new_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n            new_dev = RT_NULL;\n        }\n    }\n\n    console_device = new_dev;\n\n    return old_dev;\n}", "CodeBleu_score": 65.3778991484702}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_device;\n    rt_device_t new_device;\n\n    /* save the current console device */\n    old_device = rt_console_get_device();\n\n    /* find the new console device */\n    new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* check whether the new console device is the same as the current one */\n    if (new_device != old_device) {\n        /* close the current console device if it exists */\n        if (old_device != RT_NULL) {\n            rt_device_close(old_device);\n        }\n\n        /* open the new console device with read/write and stream flags */\n        rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\n        /* set the new console device as the current console device */\n        rt_console_set_device(new_device);\n    }\n\n    return old_device;\n}", "CodeBleu_score": 68.73993653118625}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\tstruct rt_device *new_dev;\n    struct rt_device *old_dev;\n    rt_err_t result;\n\n    /* save current console device */\n    old_dev = console_device;\n\n    /* find new console device */\n    new_dev = rt_device_find(name);\n    if (new_dev == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* check whether is the same device */\n    if (new_dev == old_dev) {\n        return old_dev;\n    }\n\n    /* close old console device */\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    /* open new console device */\n    result = rt_device_open(new_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        return RT_NULL;\n    }\n\n    /* set new console device */\n    console_device = new_dev;\n\n    return old_dev;\n}", "CodeBleu_score": 61.4010448463722}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tstruct rt_object *object;\n    int count = 0;\n    struct rt_object_information *information;\n    rt_ubase_t level;\n\n    /* get object information */\n    information = rt_object_get_information(type);\n    RT_ASSERT(information != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    /* try to take spin lock */\n    if (rt_spin_lock(&(information->lock)) == RT_EOK) {\n        /* get the first object */\n        object = information->object_list.next;\n        /* iterate over them */\n        while (object != &(information->object_list)) {\n            count ++;\n            /* move to next */\n            object = object->next;\n        }\n\n        /* release spin lock */\n        rt_spin_unlock(&(information->lock));\n    }\n    rt_hw_interrupt_enable(level);\n\n    return count;\n}", "CodeBleu_score": 53.96177941350694}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tstruct rt_object *object;\n    int length = 0;\n\n    if (type >= RT_Object_Class_Unknown)\n        return 0;\n\n    rt_enter_critical();\n    object = object_table[type];\n    while (object) {\n        ++length;\n        object = object->next;\n    }\n    rt_exit_critical();\n\n    return length;\n}", "CodeBleu_score": 34.47092909336739}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tstruct rt_object *object;\n    struct rt_list_node *node;\n    int length = 0;\n\n    rt_enter_critical();\n    /* get the first object of the list */\n    node = (&rt_object_container[type].object_list).next;\n\n    /* iterate through the list */\n    while (node != &(rt_object_container[type].object_list)) {\n        /* get the object */\n        object = rt_list_entry(node, struct rt_object, list);\n        /* move to next */\n        node = node->next;\n\n        length ++;\n    }\n    rt_exit_critical();\n\n    return length;\n}", "CodeBleu_score": 39.10960552272}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\trt_base_t level;\n    struct rt_object *obj;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n    RT_ASSERT(rt_object_get_type(object) != RT_Object_Class_Unknown);\n\n    obj = (struct rt_object *)object;\n\n    level = rt_hw_interrupt_disable();\n\n    RT_OBJECT_HOOK_CALL(rt_object_delete_hook, (object));\n\n    rt_list_remove(&(obj->list));\n\n    /* unlock interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* set object type to unknown */\n    obj->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 60.57536477127757}, {"code": "void rt_object_detach(rt_object_t object){\n\tstruct rt_object *obj;\n    rt_list_t *list;\n    rt_uint8_t type;\n\n    obj = (struct rt_object *)object;\n    RT_ASSERT(obj != RT_NULL);\n\n    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (object));\n\n    type = obj->type & ~RT_Object_Class_Static;\n    list = &rt_object_container[type];\n\n    rt_enter_critical();\n    rt_list_remove(&(obj->list));\n    rt_exit_critical();\n\n    obj->type = RT_Object_Class_None;\n}", "CodeBleu_score": 40.69281813199683}, {"code": "void rt_object_detach(rt_object_t object){\n\trt_base_t level;\n    struct rt_object *obj;\n\n    obj = (struct rt_object *)object;\n\n    if (object == RT_NULL)\n        return;\n\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n    level = rt_hw_interrupt_disable();\n\n    rt_list_remove(&(obj->list));\n    rt_hw_interrupt_enable(level);\n\n    obj->type = RT_Object_Class_Null;\n}", "CodeBleu_score": 44.37762514874438}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result;\n    struct rt_object *object;\n\n    RT_ASSERT(obj != RT_NULL);\n    object = (struct rt_object *)obj;\n\n    if ((object->type & ~RT_Object_Class_Static) != RT_Object_Class_Custom) {\n        return -RT_ERROR;\n    }\n\n    if (object->refcount != 0) {\n        return -RT_EBUSY;\n    }\n\n    if (object->cleanup != RT_NULL) {\n        result = object->cleanup(object);\n    } else {\n        result = RT_EOK;\n    }\n\n    /* delete the object */\n    rt_object_delete(object);\n\n    return result;\n}", "CodeBleu_score": 50.67571512984739}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result;\n    if (obj == RT_NULL) {\n        return -RT_ERROR;\n    }\n    if (obj->type != RT_Object_Class_Custom) {\n        return -RT_ERROR;\n    }\n    if (obj->destroy != RT_NULL) {\n        result = obj->destroy(obj);\n    } else {\n        result = RT_EOK;\n    }\n    rt_object_delete(obj);\n    return result;\n}", "CodeBleu_score": 50.2897351887339}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result;\n    struct rt_object_information *information;\n\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    information = rt_object_get_information((enum rt_object_class_type)obj->type);\n    RT_ASSERT(information != RT_NULL);\n\n    if (information->destructor != RT_NULL) {\n        result = information->destructor(obj);\n    } else {\n        result = RT_EOK;\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 47.65584012909582}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n    rt_sched_lock_level_t slvl;\n\n    /* disable interrupt */\n    slvl = rt_sched_lock();\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* close the thread */\n    rt_thread_close(thread);\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* enable interrupt */\n    rt_sched_unlock(slvl);\n\n    /* switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 39.19807557194191}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* exit critical */\n    rt_exit_critical();\n\n    /* switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 63.68800825860068}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* defunct thread */\n    rt_thread_defunct_enqueue(thread);\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    /* switch to next task */\n    rt_schedule();\n}", "CodeBleu_score": 63.14408086258596}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\n    RT_ASSERT(parameter != RT_NULL);\n\n    thread = (struct rt_thread *)parameter;\n\n    rt_sched_lock();\n    /* remove thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert thread to ready list */\n    rt_sched_insert_thread(thread);\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 33.58998435842772}, {"code": "static void _thread_timeout(void *parameter){\n\trt_thread_t thread;\n\n    RT_ASSERT(parameter != RT_NULL);\n\n    thread = (rt_thread_t)parameter;\n\n    rt_sched_lock();\n\n    /* thread is not suspended */\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_sched_unlock();\n        return;\n    }\n\n    /* remove thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* insert to ready list */\n    rt_sched_insert_thread(thread);\n\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 45.103030517605134}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\n    thread = (struct rt_thread *)parameter;\n    RT_ASSERT(thread != RT_NULL);\n\n    rt_sched_lock();\n    if (rt_sched_thread_is_suspended(thread)) {\n        thread->error = -RT_ETIMEOUT;\n\n        rt_sched_remove_thread(thread);\n        rt_sched_insert_thread(thread);\n    }\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 53.42886212541234}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_base_t level;\n    rt_mutex_t mutex;\n\n    level = rt_hw_interrupt_disable();\n    rt_spin_lock(&(thread->spinlock));\n\n    /* remove thread from mutex's list */\n    if (thread->pending_object != RT_NULL) {\n        mutex = (rt_mutex_t) (thread->pending_object);\n        rt_list_remove(&(thread->tlist));\n        rt_list_remove(&(thread->pending_list));\n\n        /* wakeup the next thread */\n        if (!rt_list_isempty(&(mutex->waiting_list))) {\n            rt_thread_t thread;\n\n            /* get next thread */\n            thread = rt_list_entry(mutex->waiting_list.next,\n                                   struct rt_thread,\n                                   tlist);\n\n            /* resume it */\n            rt_thread_resume(thread);\n\n            rt_hw_interrupt_enable(level);\n\n            /* perform a schedule */\n            rt_schedule();\n\n            return;\n        }\n    }\n\n    /* release all mutexes */\n    while (!rt_list_isempty(&(thread->hold_mutex_list))) {\n        mutex = rt_list_entry(thread->hold_mutex_list.next,\n                              struct rt_mutex,\n                              hold_list);\n        rt_mutex_release(mutex);\n    }\n\n    rt_spin_unlock(&(thread->spinlock));\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 44.40917066789312}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_base_t level;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n    /* lock thread's spinlock */\n    rt_spin_lock(&(thread->spinlock));\n\n    /* detach thread from mutex */\n    if (thread->pending_object != RT_NULL) {\n        rt_list_remove(&(thread->tlist));\n        thread->pending_object = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->hold_mutex != RT_NULL) {\n        rt_mutex_release(thread->hold_mutex);\n    }\n\n    /* unlock the thread's spinlock */\n    rt_spin_unlock(&(thread->spinlock));\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 33.30134708529331}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_base_t level;\n    rt_object_t object;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* remove thread from mutex's list */\n    if (thread->wait_object != RT_NULL) {\n        rt_list_remove(&(thread->tlist));\n        rt_list_remove(&(thread->wlist));\n        thread->wait_object = RT_NULL;\n    }\n\n    /* release all mutexes */\n    while (!rt_list_isempty(&(thread->hold_mutex))) {\n        object = rt_list_entry(thread->hold_mutex.next, struct rt_object, list);\n        rt_mutex_release((rt_mutex_t)object);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 39.4944687849994}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_startup(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be started. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.39617981948279}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_startup(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.39617981948279}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread));\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_startup(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 52.40608793906729}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tif (!rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        struct rt_timer *timer;\n\n        timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,\n                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n        *timeout_tick = timer->timeout_tick;\n\n        return RT_EOK;\n    }\n\n    return -RT_ETIMEOUT;\n}", "CodeBleu_score": 91.12838175039411}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tif (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ERROR;\n    }\n    *timeout_tick = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, rt_timer_t, row[RT_TIMER_SKIP_LIST_LEVEL - 1])->timeout_tick;\n    return RT_EOK;\n}", "CodeBleu_score": 60.71902641098438}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tif (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ETIMEOUT;\n    }\n    *timeout_tick = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1])->timeout_tick;\n    return RT_EOK;\n}", "CodeBleu_score": 67.133816104027}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer != RT_NULL) {\n        _timer_init(timer, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 62.75805702108864}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\tstruct rt_timer *timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time >= 0);\n\n    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return timer;\n\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 79.63125474662162}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time >= 0);\n\n    /* allocate a object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 70.39931641236932}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\trec := httptest.NewRecorder()\n\thandler := a.router.ServeHTTP\n\tfor _, h := range a.handlers {\n\t\thandler = h(handler)\n\t}\n\thandler(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\tres.WriteHeader(rec.Code)\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 66.60335113792274}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\trec := httptest.NewRecorder()\n\thandler := a.router.ServeHTTP\n\tfor _, h := range a.handlers {\n\t\thandler = h(handler)\n\t}\n\thandler(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == 401 {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 67.42704714790517}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t// Create a new recorder to capture the response\n\trec := httptest.NewRecorder()\n\t// Process the request\n\thandler := a.router.ServeHTTP\n\tfor _, h := range a.handlers {\n\t\thandler = h.ServeHTTP(rec, req, handler)\n\t}\n\t// Copy the captured headers to the original response\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\t// Check for unauthorized status\n\tif rec.Code == 401 {\n\t\thttp.Error(res, \"Not Authorized\", 401)\n\t\treturn\n\t}\n\t// Forward the request to the router\n\thandler(res, req)\n}", "CodeBleu_score": 61.966616370052996}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.Assets.Open(path[1:])\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\n\tparts := strings.Split(path, \".\")\n\text := parts[len(parts)-1]\n\n\tres.Header().Set(\"Content-Type\", \"text/\"+ext)\n\n\t_, err = io.Copy(res, asset)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}", "CodeBleu_score": 56.20364484720554}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tpath := req.URL.Path\n\tasset, err := a.Assets.Open(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 404)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\tvar contentType string\n\tswitch {\n\tcase strings.HasSuffix(path, \".js\"):\n\t\tcontentType = \"text/javascript\"\n\tcase strings.HasSuffix(path, \".css\"):\n\t\tcontentType = \"text/css\"\n\tcase strings.HasSuffix(path, \".html\"):\n\t\tcontentType = \"text/html\"\n\tdefault:\n\t\tcontentType = \"application/octet-stream\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\t_, err = io.Copy(res, asset)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}", "CodeBleu_score": 56.79563542701196}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tpath := req.URL.Path\n\tasset, err := a.assets.Open(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdefer asset.Close()\n\tinfo, err := asset.Stat()\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", mime.TypeByExtension(filepath.Ext(path)))\n\tres.Header().Set(\"Content-Length\", strconv.FormatInt(info.Size(), 10))\n\tres.WriteHeader(http.StatusOK)\n\n\t_, err = io.Copy(res, asset)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}", "CodeBleu_score": 60.577769030806564}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(robotName)\n\tif robot != nil {\n\t\tconnections := make([]map[string]interface{}, 0)\n\t\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\t\"name\":   connection.Name(),\n\t\t\t\t\"params\": connection.Params(),\n\t\t\t})\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"error\": \"Could not find robot with name \" + robotName,\n\t\t})\n\t}\n}", "CodeBleu_score": 57.38265631160846}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot != nil {\n\t\tconnections := robot.Connections()\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot found with name %s\", robotName), http.StatusNotFound)\n\t}\n}", "CodeBleu_score": 31.750841574290867}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\n\tif robot != nil {\n\t\tconnections := robot.Connections()\n\t\tconnectionsJSON, _ := json.Marshal(connections)\n\t\tres.Write(connectionsJSON)\n\t} else {\n\t\tjson.NewEncoder(res).Encode(gobot.APIError{\n\t\t\tMessage: \"No robot found with name \" + robotName,\n\t\t})\n\t}\n}", "CodeBleu_score": 36.83551796639263}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tgivenUser, givenPass, ok := req.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(givenUser), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(givenPass), []byte(password)) != 1 {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 59.847057418812724}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tgivenUser, givenPass, ok := req.BasicAuth()\n\n\t\tif !ok || !secureCompare(givenUser, username) || !secureCompare(givenPass, password) {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(res, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// ...\n\t}\n}", "CodeBleu_score": 59.515692715330026}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.99223518336093}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - (slope * fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Round(slope*input + intercept))\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.87457512180078}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tscale := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - (float64(fromMin) * scale)\n\treturn func(input float64) (value int) {\n\t\tvalue = int((input * scale) + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 55.75277569164032}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tvar slope = (toMax - toMin) / (fromMax - fromMin)\n\tvar intercept = toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 46.16240432144721}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"not connected\")\n\t}\n\n\tif !a.Connection().HasAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.sensorCfg.raw = raw\n\ta.sensorCfg.scaled = a.sensorCfg.scale(raw)\n\n\treturn raw, a.sensorCfg.scaled, nil\n}", "CodeBleu_score": 58.230805283950524}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"The connection %s does not support analog read\", a.Connection().Name())\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.sensorCfg.raw = raw\n\ta.sensorCfg.scaled = float64(raw) * a.sensorCfg.scale\n\treturn a.sensorCfg.raw, a.sensorCfg.scaled, nil\n}", "CodeBleu_score": 61.41561881325772}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Not connected to a %s device\", a.Name())\n\t}\n\n\tif !a.Connection().AnalogRead(a.Pin()) {\n\t\treturn 0, 0, fmt.Errorf(\"%s connection does not support analog reading\", a.Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.sensorCfg.lastRawValue = raw\n\ta.sensorCfg.lastScaledValue = float64(raw) * a.sensorCfg.scale\n\treturn raw, a.sensorCfg.lastScaledValue, nil\n}", "CodeBleu_score": 58.10043550204915}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\tif x < fromMin {\n\t\t\tx = fromMin\n\t\t} else if x > fromMax {\n\t\t\tx = fromMax\n\t\t}\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 56.59895167650453}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn math.Min(toMax, math.Max(toMin, m*float64(x)+n))\n\t}\n}", "CodeBleu_score": 41.18168994397461}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\toutput := m*float64(input) + n\n\t\tif output < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif output > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn output\n\t}\n}", "CodeBleu_score": 68.93199145617704}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\n\td.Publish(d.Event(Data), d.Event(Error))\n\n\td.AddEvent(Vibration)\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), true)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{d}\n}", "CodeBleu_score": 48.23488646167448}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\n\td.Publish(d.Event(\"vibration\"), d.Event(\"data\"))\n\n\td.On(d.Event(\"data\"), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.AddEvent(\"vibration\")\n\t\t}\n\t})\n\n\treturn &GrovePiezoVibrationSensorDriver{d}\n}", "CodeBleu_score": 31.861487458349718}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(Error)\n\td.AddEvent(Data)\n\td.AddEvent(Vibration)\n\n\twork := func() {\n\t\tgobot.Every(d.Interval(), func() {\n\t\t\tdata, err := d.Read()\n\t\t\tif err != nil {\n\t\t\t\td.Publish(Error, err)\n\t\t\t} else {\n\t\t\t\td.Publish(Data, data)\n\t\t\t\tif data > 1000 {\n\t\t\t\t\td.Publish(Vibration, data)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\trobot := gobot.Robot{\n\t\tConnections: []gobot.Connection{a},\n\t\tDevices:     []gobot.Device{d},\n\t\tWork:        work,\n\t}\n\n\terr := robot.Start()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 46.34029163009025}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t// Calculate the tone period and tempo\n\ttonePeriod, tempo := d.calculateTonePeriod(hz)\n\t// Start the tone\n\td.On()\n\t// Start the tempo\n\tfor i := 0; i < int(duration/tempo); i++ {\n\t\t// Toggle the buzzer\n\t\td.Off()\n\t\ttime.Sleep(tonePeriod)\n\t\td.On()\n\t\ttime.Sleep(tonePeriod)\n\t}\n\t// End the tone\n\td.Off()\n\treturn nil\n}", "CodeBleu_score": 25.410253231146374}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz <= 0 {\n\t\treturn errors.New(\"Tone: invalid frequency\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"Tone: invalid duration\")\n\t}\n\n\tperiod := 1000000 / hz\n\ttoneOn := time.NewTicker(time.Duration(period) * time.Microsecond)\n\ttoneOff := time.NewTicker(time.Duration(period/2) * time.Microsecond)\n\tdefer toneOn.Stop()\n\tdefer toneOff.Stop()\n\n\td.On()\n\tdefer d.Off()\n\n\ttoneOnTime := time.Now()\n\ttoneOffTime := time.Now()\n\tfor time.Since(toneOnTime) < time.Duration(duration)*time.Millisecond {\n\t\tselect {\n\t\tcase <-toneOn.C:\n\t\t\td.Off()\n\t\t\ttoneOffTime = time.Now()\n\t\tcase <-toneOff.C:\n\t\t\td.On()\n\t\t\ttoneOnTime = time.Now()\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 33.39736863119171}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t// Calculate the tone period based on the given frequency\n\tperiod, err := d.CalculateTonePeriod(hz)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Calculate the tempo based on the buzzer's beats per minute\n\ttempo, err := d.CalculateTempo(d.bpm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo\n\tfor i := 0; i < int(duration/tempo); i++ {\n\t\td.On()\n\t\ttime.Sleep(period)\n\t\td.Off()\n\t\ttime.Sleep(period)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.13380135298358}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif !d.sleepPin.IsSet() {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.356331493121353}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif !d.sleepPin.Get() {\n\t\treturn errors.New(\"Sleep pin is not set, cannot sleep\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.18661101575479}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif !d.sleepPin.IsSet() {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 28.509839298388652}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Analog pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 48.78887614674757}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Not initialized\")\n\t}\n\n\tif val, ok := a.pins[id]; ok {\n\t\treturn val, nil\n\t}\n\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewPin := a.sys.NewAnalogPin(pin.Path)\n\ta.pins[id] = newPin\n\treturn newPin, nil\n}", "CodeBleu_score": 51.69024321371553}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\n\tif val, ok := a.pins[id]; ok {\n\t\treturn val, nil\n\t}\n\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin.SetPin(pin.Pin())\n\tpin.SetName(pin.Name())\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 53.1828771775109}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.GetDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\n\treturn nil\n}", "CodeBleu_score": 64.47616438970023}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = pin.Write(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 72.14772111971907}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.pin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 65.37844685301476}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"no pins connected\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn pin, nil\n\t}\n\tchip, line, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := sysfs.NewDigitalPin(chip, line)\n\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := pin.Initialize(); err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 59.63883253310084}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.DigitalPins()) == 0 {\n\t\treturn nil, fmt.Errorf(\"Not connected to any digital pins\")\n\t}\n\n\tfor _, option := range opts {\n\t\toption(a)\n\t}\n\n\tpin, err := a.Pin(id)\n\tif err != nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.NewDigitalPin(chip, line)\n\t\tpin.ApplyOptions(opts...)\n\t\tif err := pin.Initialize(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.AddPin(pin)\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 55.51606868526445}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif !a.connected {\n\t\treturn nil, errors.New(\"Not connected\")\n\t}\n\n\tif a.pinMap == nil {\n\t\ta.pinMap = make(map[string]gobot.DigitalPinner)\n\t}\n\n\tpin, ok := a.pinMap[id]\n\tif !ok {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = sysfs.NewDigitalPin(chip, line)\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := pin.Init(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pinMap[id] = pin\n\t} else {\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 58.01586566846749}]}
