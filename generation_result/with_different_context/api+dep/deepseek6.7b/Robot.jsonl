{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  // Get the list of required files from the specified folder\n  auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n  // Check if each file exists locally\n  for (const auto &file : required_files) {\n    if (download) {\n      // If the file doesn't exist, request it\n      if (!FileTransfer::FileExists(file)) {\n        log_info(\"Downloading file: {}\", file);\n        RequestFile(file);\n      } else {\n        // If the file exists, log that it's found in the cache\n        log_info(\"File found in cache: {}\", file);\n      }\n    }\n  }\n\n  // Return the list of required files\n  return required_files;\n}", "CodeBleu_score": 67.74359620764852}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Retrieve a list of required files from a specified folder\n    auto files = FileTransfer::GetFiles(folder);\n\n    // Check if each file exists locally\n    if (download) {\n        for (const auto &file : files) {\n            // Check if the file exists locally\n            if (!FileTransfer::FileExists(file)) {\n                // If the file does not exist, request it from the server\n                RequestFile(file);\n                // Log the download action\n                log_info(\"Downloading {}\", file);\n            } else {\n                // If the file exists, log that it is found in the cache\n                log_info(\"{} found in cache\", file);\n            }\n        }\n    }\n\n    // Return the list of required files\n    return files;\n}", "CodeBleu_score": 61.90654703003424}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    if (download) {\n        // Check if each file exists locally\n        for (const auto &file : required_files) {\n            // If the file exists, log that it is found in the cache\n            if (FileTransfer::FileExists(file)) {\n                log_info(\"File {} found in cache\", file);\n            } else {\n                // If the file is not found, request it and log the download action\n                RequestFile(file);\n                log_info(\"Downloading file {}\", file);\n            }\n        }\n    }\n    return required_files;\n}", "CodeBleu_score": 69.83101567798418}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SPRING_ARM ||\n      attachment_type == rpc::AttachmentType::SPRING_ARM_GHOST) {\n    geom::Vector3D translation = transform.location.GetSafeUnitVector();\n    if (translation.x != 0.0f || translation.y != 0.0f ||\n        translation.z != 0.0f) {\n      LOG(WARNING) << \"Invalid transformation for attachment type \"\n                   << static_cast<int>(attachment_type)\n                   << \": translation should be only in the 'z' axis.\";\n    }\n  }\n  return SpawnActorWithParentInternal(description, transform, parent,\n                                      attachment_type, socket_name);\n}", "CodeBleu_score": 46.82982512195867}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis.\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f &&\n        transform.location.z != 0.0f) {\n      // Issue a warning.\n      LOG_WARNING(\"Translation is only in the 'z' axis, which is not allowed \"\n                  \"for attachment type 'SpringArm' or 'SpringArmGhost'. \"\n                  \"Transformation is ignored.\");\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process.\n  return SpawnActorWithParentInternal(description, transform, parent,\n                                      attachment_type, socket_name);\n}", "CodeBleu_score": 44.16734407790679}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the attachment type is SpringArm or SpringArmGhost.\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis.\n    if (transform.location.x == 0 && transform.location.y == 0) {\n      // Issue a warning if necessary.\n      if (transform.location.z == 0) {\n        LOG(WARNING) << \"Invalid transformation: translation is only in the \"\n                        \"'z' axis\";\n      }\n      // Make the translation in the 'z' axis safe.\n      geom::Vector3D translation = transform.location;\n      translation.z = std::numeric_limits<float>::epsilon();\n      // Create a new transform with the safe translation.\n      geom::Transform safe_transform = transform;\n      safe_transform.location = translation;\n      // Call the internal function with the safe transform.\n      return SpawnActorWithParent(description, safe_transform, parent,\n                                  attachment_type, socket_name);\n    }\n  }\n  // Call the internal function.\n  return SpawnActorWithParent(description, transform, parent, attachment_type,\n                              socket_name);\n}", "CodeBleu_score": 54.450285148672336}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto _pimpl = static_cast<Pimpl *>(pimpl);\n  auto token_data = _pimpl->streaming_client.GetGBufferToken(\n      ActorId, GBufferId);\n  std::vector<unsigned char> token_data_vec(token_data.size());\n  std::memcpy(token_data_vec.data(), token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(\n      std::move(token_data_vec),\n      std::move(callback));\n}", "CodeBleu_score": 57.395357690785055}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  // Create a new instance of the GBufferTokenRequest class\n  auto request = std::make_shared<GBufferTokenRequest>(\n      std::move(ActorId), GBufferId);\n\n  // Create a new instance of the GBufferTokenResponse class\n  auto response = std::make_shared<GBufferTokenResponse>();\n\n  // Call the RPC function\n  _pimpl->CallAndWait<GBufferTokenResponse>(request, response);\n\n  // Copy the token data from the response\n  auto token_data = response->token_data;\n\n  // Create a new buffer with the token data\n  Buffer token_buffer;\n  token_buffer.resize(token_data.size());\n  std::memcpy(token_buffer.data(), token_data.data(), token_data.size());\n\n  // Subscribe to the streaming client using the token buffer and the callback\n  _pimpl->streaming_client.Subscribe(std::move(token_buffer), std::move(callback));\n}", "CodeBleu_score": 47.23515073929575}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto _pimpl = GetPimpl();\n  auto token_data = _pimpl->streaming_client.GetToken(ActorId, GBufferId);\n  std::vector<unsigned char> token_data_copy(token_data.size);\n  std::memcpy(token_data_copy.data(), token_data.data, token_data.size);\n  _pimpl->streaming_client.Subscribe(std::move(token_data_copy), callback);\n}", "CodeBleu_score": 58.54337810139132}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>();\n    if (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n      navigation = _walker_navigation.load();\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 54.034819034961814}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n  if (navigation == nullptr) {\n    std::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>();\n    navigation = _walker_navigation.compare_exchange_strong(navigation, new_navigation)\n        ? new_navigation\n        : _walker_navigation.load();\n  }\n  return navigation;\n}", "CodeBleu_score": 53.39990599036414}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>();\n        if (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n            navigation = _walker_navigation.load();\n        }\n    }\n    return navigation;\n}", "CodeBleu_score": 53.08789058958838}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetTimestamp() < frame) {\n    std::this_thread::yield();\n    auto now = std::chrono::system_clock::now();\n    if (now - start > timeout.to_chrono()) {\n      return false;\n    }\n  }\n  episode.GetTrafficManager()->Tick(frame);\n  return true;\n}", "CodeBleu_score": 46.68309612759101}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start_time = std::chrono::system_clock::now();\n  while (episode.GetState()->GetTimestamp() < frame) {\n    std::this_thread::yield();\n    auto now = std::chrono::system_clock::now();\n    if (now - start_time > timeout) {\n      return false;\n    }\n  }\n  TrafficManager::GetInstance().Tick();\n  return true;\n}", "CodeBleu_score": 42.23781154047301}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = system_clock::now();\n  auto end = start + timeout;\n  while (episode.GetState()->GetTimestamp() < frame) {\n    std::this_thread::yield();\n    if (system_clock::now() > end) {\n      return false;\n    }\n  }\n  TrafficManager::Tick();\n  return true;\n}", "CodeBleu_score": 38.93409232001191}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // Load the episode with the specified map name, reset settings, and map layers\n  _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Get the current episode ID\n  EpisodeID current_episode_id = GetCurrentEpisode().GetId();\n\n  // Set the timeout period for the episode connection\n  _client.SetTimeout(std::chrono::milliseconds(1000));\n\n  // Attempt to connect to the new episode within the timeout period\n  for (int i = 0; i < 100; i++) {\n    // Get the current episode ID again\n    EpisodeID new_episode_id = GetCurrentEpisode().GetId();\n\n    // If the episode ID has changed, return the episode object\n    if (new_episode_id != current_episode_id) {\n      return EpisodeProxy{shared_from_this()};\n    }\n\n    // Sleep for a short period of time before checking again\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  }\n\n  // If the episode ID has not changed after the timeout period, throw a runtime exception\n  throw_exception(\"Failed to connect to the new episode within the allowed attempts\");\n}", "CodeBleu_score": 48.881275146116586}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    auto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n    auto timeout = _client.GetTimeout();\n    auto attempts = timeout.milliseconds / 500;\n    for (auto i = 0; i < attempts; ++i) {\n      if (GetCurrentEpisode().GetId() != episode_id) {\n        return EpisodeProxy{shared_from_this()};\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(500));\n    }\n    throw_exception<std::runtime_error>(\"Failed to connect to episode within timeout\");\n  }", "CodeBleu_score": 50.61296308493362}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    GetReadyCurrentEpisode();\n\n    auto new_episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n    auto timeout = _client.GetTimeout();\n    auto start_time = std::chrono::steady_clock::now();\n    auto current_episode_id = GetCurrentEpisode().GetId();\n\n    while (new_episode_id != current_episode_id) {\n        if (std::chrono::steady_clock::now() - start_time > timeout) {\n            throw_exception(\"Failed to connect to the new episode within the allowed attempts\");\n        }\n        current_episode_id = GetCurrentEpisode().GetId();\n    }\n\n    return EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 50.71030023940703}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  // Get the walker associated with the controller.\n  Walker *walker = _episode->GetWalker(controller.GetId());\n\n  // Throw an exception if the walker is not found.\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n\n  // Assert that the episode is not null.\n  DEBUG_ASSERT(_episode != nullptr);\n\n  // Create navigation if it is missing.\n  _episode->CreateNavigationIfMissing();\n\n  // Register the walker with the controller's ID.\n  _episode->GetNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 56.58146332199174}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  DEBUG_ASSERT(episode != nullptr);\n\n  // Get the walker associated with the controller\n  Walker *walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n\n  // Create navigation if it is missing\n  if (episode->GetNavigation() == nullptr) {\n    episode->CreateNavigationIfMissing();\n  }\n\n  // Register the walker with the controller's ID\n  episode->GetNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 55.25951357408694}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    Walker *walker = _episode->GetWalker(controller.GetId());\n    if (!walker) {\n        throw std::runtime_error(\"Walker not found\");\n    }\n    DEBUG_ASSERT(_episode);\n    _episode->CreateNavigationIfMissing();\n    walker->RegisterAIController(controller);\n}", "CodeBleu_score": 46.95667115153005}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    // Get the current episode\n    auto episode = GetCurrentEpisode();\n\n    // Make the actor description\n    auto actor_desc = blueprint.MakeActorDescription(transform);\n\n    // Set the parent actor ID if provided\n    if (parent) {\n      actor_desc.parent_id = parent->GetId();\n    }\n\n    // Set the attachment type and socket name if provided\n    if (parent) {\n      actor_desc.attachment_type = attachment_type;\n      actor_desc.socket_name = socket_name;\n    }\n\n    // Spawn the actor\n    auto actor = episode->SpawnActor(actor_desc);\n\n    // Register the actor with the garbage collection policy\n    RegisterActor(actor, gc);\n\n    // Log the actor creation\n    log_debug(\"Spawned actor {} with blueprint {}\", actor->GetId(), blueprint.GetName());\n\n    return actor;\n  }", "CodeBleu_score": 43.059123001240074}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto actor = ActorFactory::MakeActor(blueprint, transform);\n  if (parent) {\n    actor->SetParent(parent, attachment_type, socket_name);\n  }\n  auto id = GetCurrentEpisode().RegisterActor(actor);\n  actor->SetId(id);\n  actor->SetEpisode(GetCurrentEpisode());\n  actor->SetGarbageCollectionPolicy(gc);\n  actor->SetGarbageCollectionCallback(\n      [this](const Actor &actor) {\n        this->GetCurrentEpisode().UnregisterActor(actor);\n      });\n  log_debug(\"spawned actor {}\", actor->GetDescription());\n  return actor;\n}", "CodeBleu_score": 42.13581460061906}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  DEBUG_ASSERT(IsReady());\n  auto actor = ActorFactory::MakeActor(blueprint, transform, parent,\n                                       attachment_type, socket_name);\n  if (!actor) {\n    return nullptr;\n  }\n  auto actor_id = _episode->RegisterActor(actor);\n  actor->SetId(actor_id);\n  if (gc == GarbageCollectionPolicy::NEVER) {\n    actor->SetGarbageCollectionPolicy(gc);\n  }\n  log_debug(\"SpawnActor: {}\", actor->GetDescription());\n  return actor;\n}", "CodeBleu_score": 40.00961212349747}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  // Ensure that the episode is valid.\n  if (!ep.IsValid()) {\n    throw std::runtime_error(\"Invalid episode\");\n  }\n\n  // Subscribe to the sensor's data stream.\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [this, sensor, callback](const msr::airlib::Vector<uint8_t> &data) {\n        // Deserialize the incoming data.\n        SharedPtr<sensor::SensorData> sensor_data =\n            sensor::Deserializer::Deserialize(data);\n\n        // Associate the sensor data with the current episode.\n        sensor_data->episode_id = ep.GetEpisodeId();\n\n        // Invoke the callback with the sensor data.\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 44.4311444923165}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(ep.IsValid());\n  _client.SubscribeToStream(sensor.GetActorDescription().GetStreamToken(),\n                            [this, callback, sensor](const msgs::MsgSharedPtr& msg) {\n                              auto data = sensor::Deserializer::Deserialize(msg);\n                              data->Associate(ep);\n                              callback(data);\n                            });\n}", "CodeBleu_score": 47.964465577494686}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(ep.IsValid(), \"Episode is not valid.\");\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [this, sensor, callback](const std::string &data) {\n        auto deserializer = sensor::Deserializer(data);\n        auto sensor_data = deserializer.Deserialize();\n        sensor_data->Associate(ep);\n        callback(std::move(sensor_data));\n      });\n}", "CodeBleu_score": 50.01468931530164}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n  // load walkers\n  std::vector<WalkerHandle> walkers = Load(episode);\n\n  // check if empty\n  if (walkers.empty())\n    return;\n\n  // get current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // check if walkers exist\n  CheckIfWalkerExist(walkers, *state);\n\n  // update vehicles in crowd\n  UpdateVehiclesInCrowd(episode, _show_debug);\n\n  // update crowd\n  _nav.UpdateCrowd();\n\n  // apply batch\n  std::vector<carla::rpc::ActorState> commands;\n  commands.reserve(walkers.size());\n  for (auto &&walker : walkers) {\n    // get transform\n    carla::geom::Transform transform = _nav.GetWalkerTransform(walker.walker);\n    // get speed\n    float speed = _nav.GetWalkerSpeed(walker.walker);\n    // apply to batch\n    commands.emplace_back(carla::rpc::ActorState{walker.walker, transform, speed});\n  }\n  // apply batch\n  _simulator.lock()->ApplyBatchSync(commands);\n\n  // check if any walker has been killed\n  for (auto &&walker : walkers) {\n    if (!_nav.IsWalkerAlive(walker.walker)) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n\n}", "CodeBleu_score": 52.29423642154719}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n    // load walkers\n    std::vector<WalkerHandle> walkers = Load(episode);\n\n    // check if empty\n    if (walkers.empty()) return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // check if walkers exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, _show_debug);\n\n    // update crowd\n    _nav.UpdateCrowd();\n\n    // get commands\n    std::vector<carla::rpc::WalkerCommand> commands;\n    commands.reserve(walkers.size());\n\n    // for each walker\n    for (auto &&walker : walkers) {\n      // get transform and speed\n      carla::geom::Transform transform = _nav.GetWalkerTransform(walker.walker);\n      float speed = _nav.GetWalkerSpeed(walker.walker);\n      // apply to batch\n      commands.emplace_back(carla::rpc::WalkerCommand{walker.walker, transform, speed});\n    }\n\n    // apply batch to simulator\n    _simulator.lock()->ApplyBatchSync(commands);\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      if (!_nav.IsWalkerAlive(walker.walker)) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 53.18123793491398}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  // load the walkers\n  Load(episode);\n  // check if the list is empty\n  if (_walkers.empty())\n    return;\n\n  // get the current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // check if any walkers have been killed\n  CheckIfWalkerExist(_walkers, *state);\n\n  // update the vehicles in the crowd\n  UpdateVehiclesInCrowd(episode, false);\n\n  // update the crowd\n  _nav.UpdateCrowd();\n\n  // get the commands\n  std::vector<carla::rpc::WalkerCommand> commands;\n  commands.reserve(_walkers.size());\n\n  // get the transform and speed for each walker\n  for (auto &&walker : _walkers) {\n    // get the transform\n    carla::geom::Transform transform = _nav.GetWalkerTransform(walker.walker);\n    // get the speed\n    float speed = _nav.GetWalkerSpeed(walker.walker);\n    // add the command\n    commands.emplace_back(carla::rpc::WalkerCommand{walker.walker, transform, speed});\n  }\n\n  // apply the commands\n  _simulator.lock()->ApplyBatchSync(commands);\n\n  // check if any walkers have been killed\n  for (auto &&walker : _walkers) {\n    // check if the walker is alive\n    if (!_nav.IsWalkerAlive(walker.walker)) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n}", "CodeBleu_score": 51.95613774835641}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(uid_);\n  description.set_id(id_);\n  description.attributes.reserve(_attributes.size());\n  for (const auto& attr : _attributes) {\n    description.attributes.push_back(attr.second);\n  }\n  return description;\n}", "CodeBleu_score": 68.07320242245261}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.set_uid(uid);\n    description.set_id(id);\n    description.attributes.reserve(_attributes.size());\n    for (auto const &[key, value] : _attributes) {\n        description.attributes.push_back(value.MakeAttributeDescription());\n    }\n    return description;\n}", "CodeBleu_score": 63.72134281992277}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.attributes.reserve(_attributes.size());\n  for (const auto& attribute : _attributes) {\n    auto* desc_attr = description.attributes.add_attribute();\n    desc_attr->set_key(attribute.first);\n    desc_attr->set_value(attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 62.45574888589363}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t    SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n    for (const auto& pair : blueprints_) {\n        if (pair.second.ContainsAttribute(name)) {\n            const Attribute& attribute = pair.second.GetAttribute(name);\n            if (attribute.GetValue() == value || attribute.GetRecommendedValues().contains(value)) {\n                result->AddBlueprint(pair.second);\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 44.52801594767835}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n  for (const auto& pair : blueprints_) {\n    if (pair.second.ContainsAttribute(name)) {\n      const Attribute& attribute = pair.second.GetAttribute(name);\n      if (attribute.GetValue() == value ||\n          attribute.GetRecommendedValues().contains(value)) {\n        result->AddBlueprint(pair.second);\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 42.960722211083905}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto& pair : blueprints) {\n    const Blueprint& blueprint = pair.second;\n    if (blueprint.ContainsAttribute(name)) {\n      const Attribute& attribute = blueprint.GetAttribute(name);\n      if (attribute.GetValue() == value || attribute.GetRecommendedValues().contains(value)) {\n        result->AddBlueprint(pair.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 44.58307789606935}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string file_path = path + \"/\" + carla::version + \"/\" + carla::FileSystem::ValidateFilePath(path);\n  std::ofstream out(file_path, std::ios::binary | std::ios::trunc);\n  if (out.good()) {\n    out.write(reinterpret_cast<const char*>(content.data()), content.size());\n    out.close();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 48.27946445401005}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string fullPath = baseFolder + \"/\" + path + \".\" + version;\n    if (!FileSystem::ValidateFilePath(fullPath)) {\n        return false;\n    }\n    std::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n    if (out.good()) {\n        out.write(reinterpret_cast<const char*>(&content[0]), content.size());\n        out.close();\n        return true;\n    }\n    out.close();\n    return false;\n}", "CodeBleu_score": 48.98135776396772}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string full_path = path + \"/\" + version;\n  if (!FileSystem::ValidateFilePath(full_path)) {\n    return false;\n  }\n  std::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n  if (!file.is_open()) {\n    return false;\n  }\n  file.write(reinterpret_cast<const char*>(content.data()), content.size());\n  file.close();\n  return true;\n}", "CodeBleu_score": 47.377427966220424}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    // Get the parent's bounding box location.\n    const geom::Location &location = transform.location;\n\n    // Compute the four corners of the bounding box.\n    const float yaw = transform.rotation.yaw;\n    const geom::Vector3<float> &extents = transform.extents;\n    const geom::Location c1 =\n        geom::Location::Rotate(yaw, {extents.x, extents.y, extents.z});\n    const geom::Location c2 =\n        geom::Location::Rotate(yaw, {-extents.x, extents.y, extents.z});\n    const geom::Location c3 =\n        geom::Location::Rotate(yaw, {-extents.x, -extents.y, extents.z});\n    const geom::Location c4 =\n        geom::Location::Rotate(yaw, {extents.x, -extents.y, extents.z});\n\n    // Return the bounding box.\n    return std::make_shared<const Bounds>(\n        frame,\n        location + c1,\n        location + c2,\n        location + c3,\n        location + c4);\n  }", "CodeBleu_score": 46.04097363529181}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const geom::Location location =\n        transform.location + parent_bounds_->GetLocation(frame);\n    const float yaw = transform.rotation.GetYaw();\n    const geom::Vector3<float> extent = parent_bounds_->GetExtent(frame);\n    const geom::Location p1 = geom::Location::Rotate(yaw, {extent.x, extent.y, 0.0f}) + location;\n    const geom::Location p2 = geom::Location::Rotate(yaw, {-extent.x, extent.y, 0.0f}) + location;\n    const geom::Location p3 = geom::Location::Rotate(yaw, {-extent.x, -extent.y, 0.0f}) + location;\n    const geom::Location p4 = geom::Location::Rotate(yaw, {extent.x, -extent.y, 0.0f}) + location;\n    return std::make_shared<Bounds>(frame, p1, p2, p3, p4);\n  }", "CodeBleu_score": 46.20329358815529}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  // Get the light states from the server\n  std::vector<LightState> lightStates = _episode.Lock()->QueryLightsStateToServer();\n\n  // Update the local light states and create new light objects if they do not\n  // already exist\n  for (const LightState& lightState : lightStates) {\n    Light* light = GetLight(lightState.GetName());\n    if (light == nullptr) {\n      light = new Light(lightState);\n      _lights[lightState.GetName()] = light;\n    } else {\n      light->SetState(lightState);\n    }\n  }\n}", "CodeBleu_score": 35.95070811246493}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> guard(_mutex);\n  LightState state;\n  if (_episode.Lock()->QueryLightsStateToServer(&state)) {\n    for (const auto& light_state : state.lights()) {\n      auto it = _lights.find(light_state.name());\n      if (it == _lights.end()) {\n        _lights[light_state.name()] = std::make_shared<Light>(light_state);\n      } else {\n        it->second->Update(light_state);\n      }\n    }\n  }\n}", "CodeBleu_score": 39.23863747069801}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    std::vector<LightState> lightStates;\n    _episode.Lock()->QueryLightsStateToServer(lightStates);\n    for (auto& lightState : lightStates) {\n        Light* light = nullptr;\n        auto it = _lights.find(lightState.GetLightId());\n        if (it == _lights.end()) {\n            light = new Light(lightState, _episode.Lock());\n            _lights.insert(std::make_pair(lightState.GetLightId(), light));\n        } else {\n            light = it->second;\n            light->SetLightState(lightState);\n        }\n    }\n}", "CodeBleu_score": 48.77438376289046}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (_lights_changes.empty()) {\n    return;\n  }\n  std::vector<std::pair<uint32_t, LightState>> message;\n  for (auto &[id, change] : _lights_changes) {\n    message.push_back(std::make_pair(id, change));\n  }\n  _lights_changes.clear();\n  _dirty = false;\n  _episode.Lock()->UpdateServerLightsState(message, discard_client);\n}", "CodeBleu_score": 37.19172781687456}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  if (_lights_changes.empty()) {\n    return;\n  }\n\n  std::vector<rpc::LightState> message;\n\n  for (const auto &light : _lights_changes) {\n    auto it_light = _lights.find(light.first);\n    if (it_light == _lights.end()) {\n      continue;\n    }\n\n    message.push_back(it_light->second.GetLocation());\n  }\n\n  if (message.empty()) {\n    return;\n  }\n\n  _episode.Lock()->UpdateServerLightsState(message);\n\n  _lights_changes.clear();\n\n  if (discard_client) {\n    _dirty = false;\n  }\n}", "CodeBleu_score": 52.53925767419177}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    // Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex> lock(_lights_mutex);\n\n    // Check if there are any changes\n    if (_lights_changes.empty()) {\n        return;\n    }\n\n    // Create a message containing the updated light states\n    std::vector<uint8_t> message;\n    for (auto& [id, light] : _lights) {\n        message.push_back(id);\n        message.push_back(light.GetState());\n        message.push_back(light.GetColor().r);\n        message.push_back(light.GetColor().g);\n        message.push_back(light.GetColor().b);\n        message.push_back(light.GetLocation().x);\n        message.push_back(light.GetLocation().y);\n        message.push_back(light.GetLocation().z);\n    }\n\n    // Send the message to the server\n    _episode.Lock()->SendMessageToServer(message);\n\n    // Clear the changes and reset the dirty flag\n    _lights_changes.clear();\n    _dirty = false;\n}", "CodeBleu_score": 39.33285237019731}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetActorDescription().id() != \"sensor.other.v2x_custom\") {\n    log_debug(\"Sensor ID is not sensor.other.v2x_custom\");\n    return;\n  }\n  log_warning(\"Sensor ID is sensor.other.v2x_custom\");\n  GetEpisode().Lock()->Send(GetDisplayId(), message);\n}", "CodeBleu_score": 60.02900571957917}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  log_debug(\"ServerSideSensor::Send\");\n  if (GetSensorId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"ServerSideSensor::Send: sensor id is not sensor.other.v2x_custom\");\n    return;\n  }\n  GetEpisode().Lock()->Send(GetSensorContext(), message);\n}", "CodeBleu_score": 57.97761660429723}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"Sensor is not a V2X sensor\");\n    return;\n  }\n  GetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 52.93016985674943}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    tm.RegisterVehicles(tm_port, this->id);\n  } else {\n    tm.UnregisterVehicles(tm_port, this->id);\n  }\n}", "CodeBleu_score": 49.339136657783925}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        tm.RegisterVehicles(tm_port, this);\n    } else {\n        tm.UnregisterVehicles(tm_port, this);\n    }\n}", "CodeBleu_score": 49.467119726895405}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\n}", "CodeBleu_score": 4.055752836348062}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t  // Get the walker actor\n  walker = GetActor();\n\n  // Add the walker actor to the navigation system\n  GetEpisode().Lock()->GetNavigation()->AddActor(walker.Get());\n\n  // Disable physics simulation and collisions for the walker actor\n  GetEpisode().Lock()->SetActorSimulatePhysics(walker.Get(), false);\n  GetEpisode().Lock()->SetActorCollisions(walker.Get(), false);\n}", "CodeBleu_score": 37.309812442206734}, {"code": "void WalkerAIController::Start(){\n\t\tWalkerAIController::walker = GetActor();\n\tWalkerAIController::GetEpisode().Lock()->RegisterAIController(WalkerAIController::walker, WalkerAIController::GetActor());\n\tWalkerAIController::GetEpisode().Lock()->GetNavigation()->AddWalker(WalkerAIController::walker, WalkerAIController::walker->GetLocation());\n\tWalkerAIController::walker->SetActorCollisions(false);\n\tWalkerAIController::walker->SetActorSimulatePhysics(false);\n}", "CodeBleu_score": 35.24499623725148}, {"code": "void WalkerAIController::Start(){\n\t  // Get the walker actor\n  walker = GetEpisode().Lock()->GetActor(walker_id);\n\n  // Add the walker actor to the navigation system\n  GetEpisode().Lock()->GetNavigation()->AddActor(walker, walker->GetLocation());\n\n  // Disable the physics simulation and collisions for the walker actor\n  GetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n  GetEpisode().Lock()->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 42.559145788836396}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = m_episode.Lock()->GetNavigation();\n  if (nav) {\n    auto walker = GetParent();\n    if (walker) {\n      if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n        log_warning(\"WalkerAIController::SetMaxSpeed: Unable to set max speed.\");\n      }\n    } else {\n      log_warning(\"WalkerAIController::SetMaxSpeed: Walker not found.\");\n    }\n  } else {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Navigation not found.\");\n  }\n}", "CodeBleu_score": 61.75405997433997}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto *nav = GetEpisode()->GetNavigation();\n  if (!nav) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: No navigation in episode.\");\n    return;\n  }\n  auto *walker = GetParent();\n  if (!walker) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Walker not found.\");\n    return;\n  }\n  if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Unable to set max speed.\");\n  }\n}", "CodeBleu_score": 53.86163040613634}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (!episode) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: WalkerAIController has no episode\");\n    return;\n  }\n\n  Walker* walker = GetEpisode().Lock()->GetNavigation()->GetWalker(GetId());\n  if (!walker) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: WalkerAIController has no walker\");\n    return;\n  }\n\n  if (!walker->SetMaxSpeed(max_speed)) {\n    log_warning(\"WalkerAIController::SetMaxSpeed: Failed to set walker max speed\");\n  }\n}", "CodeBleu_score": 50.48328515887622}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (const auto& waypoint : waypoints) {\n        if (waypoint.distance < distance) {\n            result.emplace_back(std::make_shared<Waypoint>(waypoint));\n        }\n    }\n    return result;\n}", "CodeBleu_score": 54.81574157616744}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n\n    for (auto& wp : waypoints) {\n        auto wp_ptr = _parent->GetMap().GetPrevious(wp, distance);\n        if (wp_ptr) {\n            result.emplace_back(std::make_shared<Waypoint>(wp_ptr, _parent));\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 66.58342597841234}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto const &waypoint : waypoints) {\n        result.emplace_back(std::make_shared<Waypoint>(_parent->GetMap().GetPrevious(waypoint, distance)));\n    }\n    return result;\n}", "CodeBleu_score": 65.2238836760636}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n\n  // Get all signals within the specified distance from the waypoint\n  std::set<SharedPtr<Signal>> added_signals;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  for (auto signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      // Create a new waypoint and landmark for the signal\n      SharedPtr<Waypoint> waypoint = MakeShared<Waypoint>();\n      waypoint->SetMap(&_parent->GetMap());\n      waypoint->SetSignal(signal);\n      SharedPtr<Landmark> landmark = MakeShared<Landmark>();\n      landmark->SetMap(&_parent->GetMap());\n      landmark->SetWaypoint(waypoint);\n      result.push_back(landmark);\n      added_signals.insert(signal);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 52.66258735282157}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::set<SharedPtr<Signal>> added_signals;\n  for (const auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    if (added_signals.count(signal) == 0) {\n      result.emplace_back(std::make_shared<Landmark>(signal));\n      added_signals.insert(signal);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 36.09622184753581}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  // Get all signals within the specified distance\n  std::set<SharedPtr<Signal>> added_signals;\n  for (const SharedPtr<Signal>& signal : GetSignalsInDistance(distance)) {\n    // Check if the signal has already been added\n    if (added_signals.count(signal)) {\n      continue;\n    }\n    added_signals.insert(signal);\n    // Create a new waypoint and landmark for the signal\n    SharedPtr<Waypoint> waypoint =\n        SharedPtr<Waypoint>(new Waypoint(signal->GetPosition()));\n    SharedPtr<Landmark> landmark =\n        SharedPtr<Landmark>(new Landmark(waypoint));\n    // Add the waypoint and landmark to the result\n    result.push_back(landmark);\n  }\n  return result;\n}", "CodeBleu_score": 46.5240860661309}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  time_duration local_timeout = timeout.milliseconds() == 0 ?\n      _episode.Lock()->GetNetworkingTimeout() : timeout;\n  if (settings.fixed_delta_seconds.has_value()) {\n    float fixed_delta_seconds = settings.fixed_delta_seconds.get();\n    uint64_t attempts = 0;\n    while (attempts < kMaxAttempts) {\n      time_duration time_to_sleep = time_duration::milliseconds(\n          static_cast<int64_t>(fixed_delta_seconds * 1000.0f));\n      _episode.Lock()->Tick(time_to_sleep);\n      WorldSnapshot curr_snapshot = _episode.Lock()->GetWorldSnapshot();\n      float delta_seconds = static_cast<float>(\n          (curr_snapshot.GetTimestamp() - _last_snapshot_timestamp).seconds());\n      if (std::abs(delta_seconds - fixed_delta_seconds) < std::numeric_limits<float>::epsilon()) {\n        break;\n      }\n      attempts++;\n    }\n    if (attempts >= kMaxAttempts) {\n      log_warning(\"Failed to set fixed delta time to {}\", fixed_delta_seconds);\n    }\n  }\n  return _episode.Lock()->SetEpisodeSettings(settings, local_timeout);\n}", "CodeBleu_score": 58.25293707422997}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n\n    auto new_settings = _episode.Lock()->ApplySettings(settings);\n\n    if (new_settings.fixed_delta_seconds.has_value()) {\n        // Check that the fixed delta time is correctly applied.\n        const float fixed_delta_seconds = new_settings.fixed_delta_seconds.get();\n        const float epsilon = std::numeric_limits<float>::epsilon();\n        const float max_error = 10.0f * epsilon;\n        const int num_attempts = 10;\n        int num_successes = 0;\n        for (int i = 0; i < num_attempts; i++) {\n            auto curr_snapshot = _episode.Lock()->GetSnapshot();\n            const float curr_fixed_delta_seconds = curr_snapshot.GetTimestamp().fixed_delta_seconds();\n            if (std::abs(fixed_delta_seconds - curr_fixed_delta_seconds) < max_error) {\n                num_successes++;\n            }\n            _episode.Lock()->Tick(local_timeout);\n        }\n        if (num_successes < num_attempts) {\n            log_warning(\"Fixed delta time setting was not correctly applied after {} attempts. \"\n                        \"Expected value: {}, actual value: {}\", num_attempts, fixed_delta_seconds,\n                        curr_snapshot.GetTimestamp().fixed_delta_seconds());\n        }\n    }\n\n    return new_settings.id;\n}", "CodeBleu_score": 55.89362390132282}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  time_duration local_timeout = timeout.milliseconds() == 0 ?\n      _episode.Lock()->GetNetworkingTimeout() : timeout;\n  auto new_settings = _episode.Lock()->ApplySettings(settings);\n  if (new_settings.fixed_delta_seconds.has_value()) {\n    float fixed_delta_seconds = new_settings.fixed_delta_seconds.get();\n    float accumulated_error = 0;\n    for (int i = 0; i < 10; i++) {\n      auto curr_snapshot = _episode.Lock()->GetSnapshot();\n      accumulated_error += std::abs(curr_snapshot.GetTimestamp().count() - fixed_delta_seconds);\n      _episode.Lock()->Tick(local_timeout);\n    }\n    float mean_error = accumulated_error / 10.0f;\n    if (mean_error > std::numeric_limits<float>::epsilon()) {\n      log_warning(\"Fixed delta time setting of {} was not applied successfully. Mean error was {}.\",\n                  fixed_delta_seconds, mean_error);\n    }\n  }\n  return new_settings.id;\n}", "CodeBleu_score": 59.20823162118247}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat distance = Distance2D(segment.first, segment.second, point);\n\tfloat squaredLength = DistanceSquared2D(segment.first, segment.second);\n\tif (squaredLength == 0) {\n\t\treturn std::make_pair(0.f, distance);\n\t}\n\tfloat t = Clamp(Dot2D(point - segment.first, segment.second - segment.first) / squaredLength, 0.f, 1.f);\n\treturn std::make_pair(t, distance - t * std::sqrt(squaredLength));\n}", "CodeBleu_score": 31.26474118499708}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float const & pointX,\n    float const & pointY,\n    float const & segmentStartX,\n    float const & segmentStartY,\n    float const & segmentEndX,\n    float const & segmentEndY\n}", "CodeBleu_score": 17.8473509107047}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat x0, float y0, float x1, float y1, float x2, float y2\n}", "CodeBleu_score": 6.604047760194037}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n\n    const auto initial_index = GetVerticesNum();\n    AddVertices(vertices);\n\n    for (size_t i = 2; i < vertices.size(); ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i - 1);\n      AddIndex(initial_index + i);\n    }\n  }", "CodeBleu_score": 56.68507838672026}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  DEBUG_ASSERT(vertices.size() >= 3);\n  index_type initial_index = GetVerticesNum();\n  AddVertices(vertices);\n  for (size_t i = 2; i < vertices.size(); ++i) {\n    AddIndex(initial_index);\n    AddIndex(initial_index + i - 1);\n    AddIndex(initial_index + i);\n  }\n}", "CodeBleu_score": 55.779752954806646}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n    size_t initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 2; i < vertices.size(); i++) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i - 1);\n      AddIndex(initial_index + i);\n    }\n  }", "CodeBleu_score": 55.88725363264822}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->empty()) {\n    log_error(\"Message is empty.\");\n    return;\n  }\n  boost::asio::post(\n      self->_strand,\n      [self = shared_from_this(), message]() {\n        if (self->_socket.is_open()) {\n          self->_deadline.expires_from_now(boost::posix_time::seconds(30));\n          boost::asio::async_write(\n              self->_socket,\n              message->GetBufferSequence(),\n              boost::asio::bind_executor(\n                  self->_strand,\n                  [self, message](boost::system::error_code ec, std::size_t) {\n                    self->handle_sent(ec, message);\n                  }));\n        }\n      });\n}", "CodeBleu_score": 34.867112537415906}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->empty()) {\n    log_error(\"attempting to write an empty message\");\n    return;\n  }\n  boost::asio::post(\n      self->_strand,\n      [self = shared_from_this(), message]() {\n        if (self->_socket.is_open()) {\n          self->_deadline.expires_from_now(boost::posix_time::seconds(5));\n          boost::asio::async_write(\n              self->_socket,\n              message->GetBufferSequence(),\n              [self, message](const boost::system::error_code &ec, size_t) {\n                if (ec) {\n                  log_error(\"error writing to socket: {}\", ec.message());\n                  self->CloseNow();\n                  return;\n                }\n                if (message->IsLast()) {\n                  self->CloseNow();\n                }\n              });\n        } else {\n          log_error(\"socket is not open\");\n        }\n      });\n}", "CodeBleu_score": 40.54584195280165}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message == nullptr) {\n    log_error(\"Trying to write a null message\");\n    return;\n  }\n  if (message->empty()) {\n    log_error(\"Trying to write an empty message\");\n    return;\n  }\n  boost::asio::post(self->_strand, [self, message]() {\n    if (self->_socket.is_open()) {\n      self->_deadline.expires_from_now(boost::posix_time::seconds(self->_timeout));\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, [self, message](boost::system::error_code ec, std::size_t) {\n            self->HandleSent(message, ec);\n          }));\n    } else {\n      self->HandleSent(message, boost::asio::error::operation_aborted);\n    }\n  });\n}", "CodeBleu_score": 41.77697801823837}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n\n  if (!ec) {\n    if (_socket.is_open()) {\n      boost::system::error_code ignored_ec;\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both,\n                       ignored_ec);\n      _socket.close(ignored_ec);\n    }\n\n    _on_closed();\n    log_debug(\"Session closed\");\n  }\n}", "CodeBleu_score": 71.93306816649913}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  log_debug(\"Closing session\");\n\n  if (ec) {\n    log_debug(\"Error closing socket: \" << ec.message());\n  }\n\n  if (ec || _socket.is_open()) {\n    _deadline.cancel();\n    if (_socket.is_open()) {\n      boost::system::error_code ignored_ec;\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n      _socket.close(ignored_ec);\n    }\n    _on_closed();\n    log_debug(\"Session closed\");\n  }\n}", "CodeBleu_score": 60.65596661375109}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n\n  if (!ec) {\n    // We need to be executing within a strand to perform async operations\n    // on the I/O objects in this session. Although not strictly necessary\n    // for single-threaded contexts, this example code is written to be\n    // thread-safe by default.\n    boost::asio::post(_strand, [this]() {\n      boost::system::error_code ec;\n\n      // Perform the socket shutdown. This is a request to the remote endpoint.\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n      // At this point the connection is closed gracefully\n\n      if (!ec) {\n        // No need to call close() here. We know we're not going to need\n        // it anymore.\n        _on_closed();\n      }\n    });\n  }\n\n  if (ec) {\n    log_debug(\"CloseNow: %s\", ec.message().c_str());\n  }\n}", "CodeBleu_score": 46.182264987281854}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    std::shared_ptr<Buffer> buffer = std::make_shared<Buffer>(msg);\n    log_info(\"Sending message: \" + msg);\n    _router->WriteToNext(buffer, Commands::YOU_ALIVE);\n\n    std::shared_ptr<Buffer> response = fut.get();\n    log_info(\"Response: \" + response->data);\n}", "CodeBleu_score": 46.189496232322}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    std::unique_ptr<Buffer> response = std::make_unique<Buffer>();\n    std::unique_ptr<Buffer> buffer = std::make_unique<Buffer>(msg.c_str(), msg.size());\n    log_info(\"Sending IsAlive\");\n    _router->WriteToNext(buffer->data(), buffer->size(), Command::YOU_ALIVE);\n    response = _router->ReadFromNext();\n    log_info(\"Received response from system: \" + std::string(response->data()));\n}", "CodeBleu_score": 50.13443671143951}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    std::shared_ptr<Buffer> buffer = std::make_shared<Buffer>(msg.c_str(), msg.size());\n    log_info(\"Sending message: \" << msg);\n    _router->WriteToNext(buffer, YOU_ALIVE);\n    std::shared_ptr<Buffer> response = fut.get();\n    log_info(\"Received message: \" << response->data);\n}", "CodeBleu_score": 46.531483357509074}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    bool found = false;\n    for (auto &server : _servers) {\n        if (server.second.sensor_ids.find(sensor_id) != server.second.sensor_ids.end()) {\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        log_error(\"Sensor %d not found on any server\", sensor_id);\n        return;\n    }\n    Buffer buffer;\n    buffer.Write<uint8_t>(CommandType::ENABLE_ROS);\n    buffer.Write<stream_id>(sensor_id);\n    auto fut = _router->WriteToOne(buffer);\n    auto response = fut.get();\n    if (response.error != Error::OK) {\n        log_error(\"Error sending ENABLE_ROS command: %s\", response.error.message().c_str());\n        return;\n    }\n    if (response.buffer.Read<uint8_t>() != CommandType::ENABLE_ROS) {\n        log_error(\"Unexpected response to ENABLE_ROS command\");\n        return;\n    }\n    if (response.buffer.Read<stream_id>() != sensor_id) {\n        log_error(\"Unexpected sensor ID in response to ENABLE_ROS command\");\n        return;\n    }\n    if (response.buffer.Read<uint8_t>() != 0) {\n        log_error(\"Error enabling ROS for sensor %d: %s\", sensor_id, response.buffer.Read<std::string>().c_str());\n        return;\n    }\n    log_info(\"Enabled ROS for sensor %d\", sensor_id);\n}", "CodeBleu_score": 48.02322666186702}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    // Check if the sensor has been activated on any secondary server\n    auto fut = _router->WriteToOne(\n        sensor_id,\n        reinterpret_cast<const char *>(&Command::ENABLE_ROS),\n        sizeof(Command::ENABLE_ROS)\n    );\n\n    // Wait for and process the server's response\n    auto response = fut.get();\n    if (response.buffer.data[0] == Command::ENABLE_ROS_ACK) {\n        // Extract the sensor ID from the response buffer\n        stream_id sensor_id = *reinterpret_cast<stream_id *>(&response.buffer.data[1]);\n\n        // Find the server that the sensor is activated on\n        auto it = _servers.find(sensor_id);\n        if (it == _servers.end()) {\n            log_error(\"Sensor %d not found on any server\", sensor_id);\n            return;\n        }\n\n        // Send the ENABLE_ROS command to the server\n        auto server = it->second;\n        server->SendEnableForROS(sensor_id);\n    } else {\n        log_error(\"Unexpected response: %d\", response.buffer.data[0]);\n    }\n}", "CodeBleu_score": 54.59684820985862}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    bool found = false;\n    for (auto &server : _servers) {\n        if (server.second.enabled_sensors.find(sensor_id) != server.second.enabled_sensors.end()) {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        log_error(\"Sensor %d not found on any server\", sensor_id);\n        return;\n    }\n\n    // Create a buffer with the sensor ID\n    Buffer buffer(sizeof(sensor_id));\n    memcpy(buffer.data, &sensor_id, sizeof(sensor_id));\n\n    // Send the ENABLE_ROS command to the server using the router\n    Router::Command command = {\n        .type = Router::CommandType::ENABLE_ROS,\n        .buffer = std::move(buffer)\n    };\n\n    auto fut = _router->WriteToOne(command);\n\n    // Wait for and process the server's response\n    Router::Response response = fut.get();\n    if (response.status == Router::ResponseStatus::OK) {\n        // Process the server's response\n    } else {\n        // Handle the error\n    }\n}", "CodeBleu_score": 53.175961668215635}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"token already exists for sensor \", sensor_id);\n    return it->second;\n  }\n\n  log_info(\"enabling sensor \", sensor_id, \" on secondary server\");\n  SendEnableSensor(sensor_id);\n  auto new_token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = new_token;\n  log_info(\"got a token for sensor \", sensor_id);\n  return new_token;\n}", "CodeBleu_score": 55.33651739441604}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"got a token from cache\");\n    return it->second;\n  }\n\n  token_type new_token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = new_token;\n  log_info(\"got a new token\");\n  return new_token;\n}", "CodeBleu_score": 48.58456420185385}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  log_info(\"PrimaryCommands::GetToken(\", sensor_id, \")\");\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"sensor \", sensor_id, \" already activated\");\n    return it->second;\n  }\n\n  log_debug(\"sensor \", sensor_id, \" not activated, enabling it\");\n  SendEnableSensor(sensor_id);\n  auto new_token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = new_token;\n  log_info(\"sensor \", sensor_id, \" activated\");\n  return new_token;\n}", "CodeBleu_score": 58.28264134167347}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.74225201289511}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.76847140907317}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.76847140907317}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    // Check if the system is ready and assert the crowd object is not null\n    if (!_ready) {\n        DEBUG_ASSERT(_crowd != nullptr);\n    }\n\n    // Search for the agent id in the walker and vehicle mappings\n    auto walker_it = _mapped_walkers_id.find(id);\n    if (walker_it != _mapped_walkers_id.end()) {\n        // Enter a critical section to safely remove the agent from the crowd\n        std::lock_guard<std::mutex> lock(_mutex);\n\n        // Remove the agent from the crowd\n        _crowd->removeAgent(walker_it->second);\n\n        // Update the walker manager\n        _walker_manager.RemoveWalker(walker_it->second);\n\n        // Remove the id from the mappings\n        _mapped_walkers_id.erase(walker_it);\n        _mapped_by_index.erase(walker_it->second);\n\n        return true;\n    }\n\n    auto vehicle_it = _mapped_vehicles_id.find(id);\n    if (vehicle_it != _mapped_vehicles_id.end()) {\n        // Enter a critical section to safely remove the agent from the crowd\n        std::lock_guard<std::mutex> lock(_mutex);\n\n        // Remove the agent from the crowd\n        _crowd->removeAgent(vehicle_it->second);\n\n        // Update the vehicle manager\n        _vehicle_manager.RemoveVehicle(vehicle_it->second);\n\n        // Remove the id from the mappings\n        _mapped_vehicles_id.erase(vehicle_it);\n        _mapped_by_index.erase(vehicle_it->second);\n\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 68.2929032769765}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  DEBUG_ASSERT(_crowd);\n\n  if (!_ready) {\n    return false;\n  }\n\n  // search for the id in the walker and vehicle mappings\n  auto walker_it = _mapped_walkers_id.find(id);\n  if (walker_it != _mapped_walkers_id.end()) {\n    // found a walker, remove it from the crowd\n    _crowd->removeAgent(walker_it->second);\n    // update the walker manager\n    _walker_manager.RemoveWalker(walker_it->second);\n    // remove the id from the mappings\n    _mapped_walkers_id.erase(walker_it);\n    _mapped_by_index.erase(walker_it->second);\n    return true;\n  }\n\n  auto vehicle_it = _mapped_vehicles_id.find(id);\n  if (vehicle_it != _mapped_vehicles_id.end()) {\n    // found a vehicle, remove it from the crowd\n    _crowd->removeAgent(vehicle_it->second);\n    // update the vehicle manager\n    _vehicle_manager.RemoveVehicle(vehicle_it->second);\n    // remove the id from the mappings\n    _mapped_vehicles_id.erase(vehicle_it);\n    _mapped_by_index.erase(vehicle_it->second);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 63.86278832111263}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    // check if system is ready\n    if (!_ready) {\n        return false;\n    }\n    // assert crowd object is not null\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // search for the agent id in the walker and vehicle mappings\n    auto walker_it = _mapped_walkers_id.find(id);\n    if (walker_it != _mapped_walkers_id.end()) {\n        // enter a critical section to safely remove the agent from the crowd\n        {\n            std::lock_guard<std::mutex> lock(_mutex);\n            // remove the agent from the crowd\n            _crowd->removeAgent(walker_it->second);\n        }\n        // update the walker manager\n        _walker_manager.RemoveWalker(walker_it->second);\n        // remove the id from the mappings\n        _mapped_walkers_id.erase(walker_it);\n        return true;\n    }\n    auto vehicle_it = _mapped_vehicles_id.find(id);\n    if (vehicle_it != _mapped_vehicles_id.end()) {\n        // enter a critical section to safely remove the agent from the crowd\n        {\n            std::lock_guard<std::mutic> lock(_mutex);\n            // remove the agent from the crowd\n            _crowd->removeAgent(vehicle_it->second);\n        }\n        // update the vehicle manager\n        _vehicle_manager.RemoveVehicle(vehicle_it->second);\n        // remove the id from the mappings\n        _mapped_vehicles_id.erase(vehicle_it);\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 73.65529863559581}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // get the list of currently mapped vehicles\n    std::set<ActorId> mapped_vehicles;\n    for (auto& it : _mapped_vehicles_id) {\n      mapped_vehicles.insert(it.first);\n    }\n\n    // update vehicles\n    for (auto& vehicle : vehicles) {\n      // check if this vehicle exists\n      auto it = mapped_vehicles.find(vehicle.id);\n      if (it != mapped_vehicles.end()) {\n        // update vehicle\n        if (!UpdateVehicle(vehicle)) {\n          logging::log(\"Vehicle agent not updated by some problem!\");\n          return false;\n        }\n        // mark as updated\n        mapped_vehicles.erase(it);\n      } else {\n        // add vehicle\n        if (!AddVehicle(vehicle)) {\n          logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n          return false;\n        }\n      }\n    }\n\n    // remove vehicles not updated\n    for (auto& it : mapped_vehicles) {\n      // remove vehicle\n      if (!RemoveAgent(it)) {\n        logging::log(\"Vehicle agent not removed by some problem!\");\n        return false;\n      }\n    }\n\n    return true;\n  }", "CodeBleu_score": 52.066119834774724}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto actor = _world->GetActor(id);\n  if (actor == nullptr) {\n    return false;\n  }\n  auto transform = actor->GetTransform();\n  auto location = transform.location;\n  auto actor_id = actor->GetId();\n  auto walker_id = _mapped_walkers_id.find(actor_id);\n  if (walker_id != _mapped_walkers_id.end()) {\n    return _crowd->HasVehicleNear(walker_id->second, distance, direction);\n  }\n  auto vehicle_id = _mapped_vehicles_id.find(actor_id);\n  if (vehicle_id != _mapped_vehicles_id.end()) {\n    return _crowd->HasVehicleNear(vehicle_id->second, distance, direction);\n  }\n  return false;\n}", "CodeBleu_score": 54.23118652673055}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  bool result = false;\n  {\n    std::lock_guard<std::mutex> lock(_mutex);\n    auto mapped_walkers_id = _mapped_walkers_id.find(id);\n    if (mapped_walkers_id != _mapped_walkers_id.end()) {\n      auto walker = mapped_walkers_id->second;\n      float squared_distance = distance * distance;\n      result = _crowd->hasVehicleNear(walker, squared_distance, direction);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 56.46612827230243}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  // Get the current route point for the walker\n  auto routePoint = info.GetCurrentRoutePoint();\n\n  // Create a WalkerEventVisitor with the current context\n  WalkerEventVisitor visitor(context);\n\n  // Use boost::variant2::visit to process the event at the current route point\n  return boost::variant2::visit(visitor, routePoint);\n}", "CodeBleu_score": 43.419479224668336}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  // Get the current route point.\n  RoutePoint *routePoint = info.GetRoutePoint();\n  // Create a WalkerEventVisitor with the current context.\n  WalkerEventVisitor visitor(*this, info, delta);\n  // Use boost::variant2::visit to process the event at the current route point.\n  return boost::variant2::visit(visitor, routePoint->event);\n}", "CodeBleu_score": 54.13893396698344}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  RoutePoint *rp = info.GetCurrentRoutePoint();\n  WalkerEventVisitor visitor(info, delta);\n  return boost::variant2::visit(visitor, rp->GetEvent());\n}", "CodeBleu_score": 46.15555778887308}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n    // Get road ID\n    const int road_id = road_node.attribute(\"id\").as_int();\n\n    // Get the lanes node\n    pugi::xml_node lanes_node = road_node.child(\"lanes\");\n\n    // Iterate through each lane section\n    for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n\n      // Get the s attribute\n      const double s = lane_section_node.attribute(\"s\").as_double();\n\n      // Get the left lane node\n      pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n\n      // Get the center lane node\n      pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n\n      // Get the right lane node\n      pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n      // Parse the left lane\n      ParseLanes(left_lane_node, s, road_id, map_builder);\n\n      // Parse the center lane\n      ParseLanes(center_lane_node, s, road_id, map_builder);\n\n      // Parse the right lane\n      ParseLanes(right_lane_node, s, road_id, map_builder);\n    }\n  }\n}", "CodeBleu_score": 62.97962612688237}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const int road_id = road_node.attribute(\"id\").as_int();\n    for (pugi::xml_node lane_section_node : road_node.children(\"lanes\")) {\n      const double s = lane_section_node.attribute(\"s\").as_double();\n      ParseLanes(lane_section_node, s, map_builder);\n    }\n  }\n}", "CodeBleu_score": 32.06370434551112}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.children(\"road\")) {\n    const int id = road_node.attribute(\"id\").as_int();\n    const std::string junction = road_node.attribute(\"junction\").value();\n\n    // Process each lane section within the lanes node\n    for (pugi::xml_node lane_section_node : road_node.children(\"laneSection\")) {\n      const double s = lane_section_node.attribute(\"s\").as_double();\n      const double length = lane_section_node.attribute(\"length\").as_double();\n\n      // Retrieve the left, center, and right lane nodes\n      pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n      pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n      pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n      // Parse the left lane node\n      ParseLanes(\n          left_lane_node,\n          map_builder,\n          id,\n          s,\n          length,\n          Lane::LanePosition::Left);\n\n      // Parse the center lane node\n      ParseLanes(\n          center_lane_node,\n          map_builder,\n          id,\n          s,\n          length,\n          Lane::LanePosition::Center);\n\n      // Parse the right lane node\n      ParseLanes(\n          right_lane_node,\n          map_builder,\n          id,\n          s,\n          length,\n          Lane::LanePosition::Right);\n    }\n  }\n}", "CodeBleu_score": 59.828520391680875}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.total_count_change == 1) {\n        matched_ = true;\n        first_match_ = true;\n        std::cout << \"CarlaListenerImpl::on_publication_matched: matched.\" << std::endl;\n    } else if (info.total_count_change == -1) {\n        matched_ = false;\n        std::cout << \"CarlaListenerImpl::on_publication_matched: unmatched.\" << std::endl;\n    } else {\n        std::cout << \"CarlaListenerImpl::on_publication_matched: invalid count change.\" << std::endl;\n    }\n}", "CodeBleu_score": 46.9163968464865}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    (void) writer;\n    (void) info;\n    if (info.total_count_change == 1) {\n        matched_count_++;\n        if (matched_count_ == 1) {\n            first_connection_ = true;\n        }\n    } else if (info.total_count_change == -1) {\n        matched_count_--;\n    } else {\n        efd_log_error(\"Invalid publication matched count change: %d\", info.total_count_change);\n    }\n}", "CodeBleu_score": 44.89379617208039}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n    if (info.current_count_change == 1) {\n        m_first_connection = true;\n        m_matched = true;\n    } else if (info.current_count_change == -1) {\n        m_matched = false;\n    } else {\n        std::cerr << \"CarlaListenerImpl::on_publication_matched: unexpected count_change \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 61.57967938578468}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        // New matching subscription\n        _matched_count++;\n        if (_matched_count == 1) {\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        // Subscription lost\n        _matched_count--;\n        if (_matched_count == 0) {\n            // No more subscriptions\n            _owner->DestroySubscriber();\n        }\n    } else {\n        // Invalid change count\n        _owner->LogError(\"Invalid subscription change count: \" + std::to_string(info.current_count_change));\n    }\n}", "CodeBleu_score": 64.01454233157945}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched\" << std::endl;\n    if (info.current_count_change == 1) {\n        _matched = info.total_count;\n        if (_matched == 1) {\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        _matched = info.total_count;\n        if (_matched == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: invalid count change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 72.92681840495725}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    _matched = info.total_count;\n    if (_matched == 1) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched = info.total_count;\n    if (_matched == 0) {\n      _owner->DestroySubscriber();\n    }\n  } else {\n    std::cout << \"ERROR: Subscription change is out of bounds\" << std::endl;\n  }\n}", "CodeBleu_score": 75.13087937647835}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* myData = (CarlaCollisionEvent*) data;\n    if(force_md5 || DynamicTypes::keyDirtyFlag(myData)) {\n        size_t current_aligned_position = myData->getCdrMemoryPosition();\n        resetMem(myData);\n        if(CarlaCollisionEventPubSubType::getCdrSerializedSize(myData) > CDR_MEMORY_BLOCK_SIZE) {\n            return false;    /* If the key exceed the CDR memory block size, it will throw OutOfMemoryException. */\n        }\n        unsigned int keyHash = 0;\n        if(CarlaCollisionEventPubSubType::getKeyHash(myData, &keyHash)) {\n            *handle = keyHash;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    DynamicTypes::KeyBuilder keyBuilder(\n        myData->getCdrMemoryPosition(),\n        myData->getCdrMemoryBlockLength());\n    if(keyBuilder.isKeyDefined()) {\n        *handle = keyBuilder.getKeyHash();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 37.37631638033757}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* myData = (CarlaCollisionEvent*)data;\n    if(force_md5 || DynamicType::getKeyMaxSerializedSizeInBytes < KEY_SERIALIZED_SIZE){\n        static unsigned char keyBuffer[KEY_SERIALIZED_SIZE];\n        unsigned char* p_keyStart = &keyBuffer[0];\n        p_keyStart += static_cast<unsigned int>(serializeToKey(myData, p_keyStart, force_md5));\n        *handle = createKeyFromBuffer(keyBuffer, KEY_SERIALIZED_SIZE);\n        return (p_keyStart - keyBuffer) == KEY_SERIALIZED_SIZE;\n    }else{\n        return createKey(*myData, *handle);\n    }\n}", "CodeBleu_score": 27.16373136543997}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n    try {\n        p_type->serialize(ser);\n        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n        return true;\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n}", "CodeBleu_score": 79.14888713363929}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    // Serialize encapsulation.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize the object.\n    try {\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = (uint32_t)ser.getSerializedDataLength();\n    return true;\n}", "CodeBleu_score": 84.33343306418476}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\n    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n    try {\n        p_type->serialize(ser);\n        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n        return true;\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n}", "CodeBleu_score": 81.52050579812176}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t  if (target_sysid != 0) {\n    return;\n  }\n  mavlink_msg_heartbeat_decode(msg, &target_heartbeat);\n  if (target_heartbeat.type != MAV_TYPE_GCS_SYSTEM_ID && target_heartbeat.type != MAV_TYPE_GCS_SUBSYSTEM_ID) {\n    return;\n  }\n  target_sysid = target_heartbeat.system_id;\n  tracker.gcs().request_datastream_position(target_sysid);\n  tracker.gcs().request_datastream_airpressure(target_sysid);\n  target_set = true;\n}", "CodeBleu_score": 38.569605211257475}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_sysid != 0) {\n        return;\n    }\n\n    if (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n        return;\n    }\n\n    mavlink_heartbeat_t hb;\n    mavlink_msg_heartbeat_decode(&msg, &hb);\n\n    if (hb.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    target_sysid = hb.autopilot;\n\n    mavlink_msg_request_data_stream_send(\n        GCS_MAVLINK::get_channel_for_system_id(target_sysid),\n        target_sysid,\n        GCS_MAVLINK::get_our_sysid(),\n        MAV_DATA_STREAM_POSITION,\n        10,\n        1);\n\n    mavlink_msg_request_data_stream_send(\n        GCS_MAVLINK::get_channel_for_system_id(target_sysid),\n        target_sysid,\n        GCS_MAVLINK::get_our_sysid(),\n        MAV_DATA_STREAM_EXTRA1,\n        10,\n        1);\n\n    target_set = true;\n}", "CodeBleu_score": 45.84518854452656}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_sysid != 0) {\n        return;\n    }\n\n    mavlink_msg_heartbeat_decode(msg, &heartbeat);\n    if (heartbeat.type != MAV_TYPE_GCS_SYSTEM_ID) {\n        return;\n    }\n\n    target_sysid = heartbeat.system_id;\n    tracker.gcs().request_datastream_position(target_sysid);\n    tracker.gcs().request_datastream_airpressure(target_sysid);\n    target_set = true;\n}", "CodeBleu_score": 36.54109763190618}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _barometer_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.41507448421682}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _baro_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.2567519064801}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _alt_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.4066070872933}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    switch (packet.param1) {\n        case 0:\n            if (tracker.disarm_servos()) {\n                return MAV_RESULT_ACCEPTED;\n            }\n            return MAV_RESULT_FAILED;\n        case 1:\n            if (tracker.arm_servos()) {\n                return MAV_RESULT_ACCEPTED;\n            }\n            return MAV_RESULT_FAILED;\n        default:\n            return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 55.154009123583926}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.target_component != MAV_COMP_ID_ALL) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    if (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n        if (packet.param1 > 1.0f) {\n            return MAV_RESULT_UNSUPPORTED;\n        }\n        if (packet.param1 <= 0.0f) {\n            tracker.disarm_servos();\n            return MAV_RESULT_ACCEPTED;\n        }\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 68.81361510713147}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 > 1.0f) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n    if (packet.param1 > 0.0f) {\n        // arm\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    // disarm\n    tracker.disarm_servos();\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 74.85405052001302}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    uint8_t num_gcs = GCS_MAVLINK::num_gcs();\n    for (uint8_t i = 0; i < num_gcs; i++) {\n        if (GCS_MAVLINK::have_payload_space(i)) {\n            mavlink_msg_request_data_stream_send(i, sysid, compid, MAV_DATA_STREAM_POSITION, 1, 10);\n        }\n    }\n}", "CodeBleu_score": 39.74362981519842}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i = 0; i < num_gcs; i++) {\n        if (gcs[i].available()) {\n            if (gcs[i].num_payload_space() >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n                mavlink_msg_request_data_stream_send(gcs[i].get_chan(), sysid, compid, MAV_DATA_STREAM_POSITION, 10, MAV_COMP_ID_ALL);\n            }\n        }\n    }\n}", "CodeBleu_score": 49.3352744019507}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    // Check if the GCS has a payload space for the data stream\n    for (uint8_t i = 0; i < num_gcs; i++) {\n        if (gcs[i].available() >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n            // Send the request to start the data stream on the GCS channel\n            mavlink_msg_request_data_stream_send(\n                gcs[i].get_channel(),\n                sysid,\n                compid,\n                MAV_DATA_STREAM_POSITION,\n                MAV_COMP_ID_TRACKER,\n                1000,\n                1\n            );\n            return;\n        }\n    }\n}", "CodeBleu_score": 54.972611935556195}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t  if (ahrs.cos_pitch() != 0.0f) {\n    ef_pitch = -asinf(ahrs.sin_roll() * ahrs.cos_pitch()) + pitch;\n    ef_yaw = -atan2f(ahrs.sin_pitch() * ahrs.cos_roll(), ahrs.cos_pitch()) + yaw;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 52.14099862273963}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AHRS* ahrs = AP::ahrs();\n    if (ahrs == nullptr) {\n        return false;\n    }\n    const float cos_pitch = ahrs->cos_pitch();\n    if (is_zero(cos_pitch)) {\n        return false;\n    }\n    ef_pitch = atanf(ahrs->sin_roll() * ahrs->cos_pitch() / cos_pitch);\n    ef_yaw = yaw - asinf(ahrs->sin_pitch() / cos_pitch);\n    return true;\n}", "CodeBleu_score": 57.394583594903295}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t  AP_AHRS &ahrs = AP_AHRS::get_singleton();\n  const float cos_pitch = ahrs.cos_pitch();\n  if (cos_pitch > 0.001f) {\n    const float sin_pitch = ahrs.sin_pitch();\n    const float sin_roll = ahrs.sin_roll();\n    const float cos_roll = ahrs.cos_roll();\n    ef_pitch = asin(sin_pitch * cos_roll + cos_pitch * sin_roll * sin(yaw));\n    ef_yaw = atan2(sin_roll * cos_pitch, cos_roll);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 47.62329193676096}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // get navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n\n    // get parameters\n    Parameters &g = tracker.g;\n\n    // calculate target yaw and pitch in centidegrees\n    float pitch = (nav_status.distance * 100.0f / g.distance_scale) + g.pitch_trim;\n    float yaw = nav_status.bearing + g.yaw_trim;\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // if the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly\n    if (nav_status.distance_valid || g.distance_min == 0) {\n        tracker.update_pitch_servo();\n        tracker.update_yaw_servo();\n    }\n}", "CodeBleu_score": 51.915191198892444}, {"code": "void Mode::update_auto(void){\n\t    // get target pitch and yaw in centidegrees\n    const AP_AHRS &ahrs = AP::ahrs();\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float target_pitch = nav_status.target_bearing_cd * 100.0f;\n    float target_yaw = wrap_180_cd(nav_status.target_bearing_cd * 100.0f + tracker.g.yaw_trim * 100.0f);\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error\n    calc_angle_error(target_pitch, target_yaw, direction_reversed);\n\n    // update pitch and yaw servos\n    tracker.update_yaw_servo();\n    tracker.update_pitch_servo();\n}", "CodeBleu_score": 38.45448456393684}, {"code": "void Mode::update_auto(void){\n\t    // get target pitch and yaw in centi-degrees\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float pitch = nav_status.target_pitch * 100.0f;\n    float yaw = nav_status.target_yaw * 100.0f;\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // if the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n    if (nav_status.target_distance_valid || tracker.g.min_distance == 0) {\n        tracker.update_yaw_servo();\n        tracker.update_pitch_servo();\n    }\n}", "CodeBleu_score": 41.196894332979376}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t  // Update the GPS\n  gps.update();\n\n  // Check if the last message time has changed\n  if (gps.last_message_time_ms != last_gps_message_time_ms) {\n    // Update the last message time\n    last_gps_message_time_ms = gps.last_message_time_ms;\n\n    // Check if the GPS status is at least 3D fix\n    if (gps.status >= 3) {\n      // Check if the location is valid\n      if (gps.location.is_valid()) {\n        // Check if the home location has been set\n        if (home_set == false) {\n          // Set the home location\n          set_home();\n        }\n      } else {\n        // Reset the countdown\n        ground_start_countdown = GROUND_START_COUNTDOWN;\n      }\n    }\n  }\n\n  // Check if the countdown has reached one\n  if (ground_start_countdown == 1) {\n    // Check if the home location has been set\n    if (home_set == false) {\n      // Set the home location\n      set_home();\n    }\n  }\n}", "CodeBleu_score": 39.019483476672185}, {"code": "void Tracker::update_GPS(void){\n\t  // Update the GPS\n  gps.update();\n\n  // Check if the last message time has changed and if the GPS status is at least 3D fix\n  if (gps.last_message_time_ms != last_gps_message_time_ms && gps.status >= 3) {\n    // Update the last message time\n    last_gps_message_time_ms = gps.last_message_time_ms;\n\n    // If the current location is valid\n    if (gps.location.is_valid()) {\n      // If the countdown is not set\n      if (ground_start_countdown == 0) {\n        // Set the countdown to 10 seconds\n        ground_start_countdown = 10;\n      }\n\n      // If the countdown reaches one\n      if (ground_start_countdown == 1) {\n        // Set the home location\n        set_home();\n      }\n    } else {\n      // Reset the countdown\n      ground_start_countdown = 0;\n    }\n  }\n}", "CodeBleu_score": 41.34765174232453}, {"code": "void Tracker::update_GPS(void){\n\t  // Update the GPS and check if the last message time has changed\n  if (gps.update()) {\n    // If the last message time has changed, check if the GPS status is at least 3D fix\n    if (gps.last_message_time_ms != last_message_time_ms) {\n      // If the GPS status is at least 3D fix, update the last message time\n      last_message_time_ms = gps.last_message_time_ms;\n      // Check if the GPS status is at least 3D fix\n      if (gps.location.is_valid) {\n        // If the GPS status is at least 3D fix, check if the ground start countdown has reached one\n        if (ground_start_countdown == 1) {\n          // If the ground start countdown has reached one, set the home location\n          set_home();\n          // Reset the ground start countdown\n          ground_start_countdown = 0;\n        }\n      } else {\n        // If the GPS status is not at least 3D fix, reset the ground start countdown\n        ground_start_countdown = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 36.85723978194666}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > 180.0) {\n        pitch = 180.0;\n    } else if (pitch < 0.0) {\n        pitch = 0.0;\n    }\n    const float servo_pitch = pitch * 0.01f * 180.0f;\n    SRV_Channels::set_output_scaled(SRV_Channel::k_pitch_control, servo_pitch);\n}", "CodeBleu_score": 16.5870453109206}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  if (pitch > 1.0f) {\n    pitch = 1.0f;\n  } else if (pitch < -1.0f) {\n    pitch = -1.0f;\n  }\n\n  if (pitch > 0.0f) {\n    SRV_Channels::set_output_scaled(SRV_Channel::k_pitch_onoff_servo, pitch);\n  } else {\n    SRV_Channels::set_output_scaled(SRV_Channel::k_pitch_onoff_servo, -pitch);\n  }\n}", "CodeBleu_score": 21.828760094114287}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch < 0.0f) {\n        pitch = 0.0f;\n    }\n    if (pitch > 1.0f) {\n        pitch = 1.0f;\n    }\n    SRV_Channels::set_output_scaled(SRV_Channel::k_pitch_control, pitch);\n}", "CodeBleu_score": 11.279997758965509}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call the base class's barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check the barometer reference and compare the barometer altitude with the inertial navigation altitude\n    if (hal.util->get_soft_armed() && hal.util->get_arm_mode() == AP_Arming::ARMING_CHECK_BARO) {\n        // get the barometer reference\n        float baro_reference = copter.get_baro_reference();\n\n        // get the barometer altitude\n        float baro_alt = copter.inertial_nav.get_altitude();\n\n        // get the inertial navigation altitude\n        float inertial_alt = copter.inertial_nav.get_position_z_up_cm();\n\n        // calculate the disparity between the barometer and inertial navigation altitudes\n        float disparity = fabsf(baro_alt - inertial_alt);\n\n        // if the disparity is too large, log a failure and return false\n        if (disparity > ARMING_CHECK_BARO_ALT_MAX_DISPARITY) {\n            AP_Notify::flags.baro_check_fail = true;\n            if (display_failure) {\n                AP_Notify::flags.armed_failed = true;\n                AP_Notify::flags.armed_failed_type = 1;\n            }\n            return false;\n        }\n    }\n\n    // return true if the barometer checks pass\n    return true;\n}", "CodeBleu_score": 54.168284420065646}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call base class's barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if barometer check is disabled, we're done here\n    if (!hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // check if baro reference is valid\n    if (!copter.inertial_nav.get_position_z_up_cm(copter.inertial_nav.get_position_z_up_cm())) {\n        if (display_failure) {\n            AP_Notify::flags.baro_bad = true;\n        }\n        return false;\n    }\n\n    // get altitude above home\n    float alt_above_home_cm;\n    if (!copter.inertial_nav.get_alt_above_home(alt_above_home_cm)) {\n        return false;\n    }\n\n    // get altitude above barometer\n    float alt_above_baro_cm;\n    if (!copter.inertial_nav.get_alt_above_baro(alt_above_baro_cm)) {\n        return false;\n    }\n\n    // calculate the difference\n    float diff_cm = fabsf(alt_above_baro_cm - alt_above_home_cm);\n\n    // check if the difference is too great\n    if (diff_cm > copter.aparm.baro_max_diff_cm) {\n        if (display_failure) {\n            AP_Notify::flags.baro_bad = true;\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 53.59198305904131}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call base class's barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if ARMING_CHECK_BARO is enabled, check the barometer reference and compare the barometer altitude with the inertial navigation altitude\n    if (AP_Arming::_flags.arming_check_baro) {\n        // get the barometer reference and the inertial navigation altitude\n        float baro_alt = copter.inertial_nav.get_altitude();\n        float baro_ref = copter.barometer.get_alt_ref();\n\n        // compute the difference between the barometer reference and the inertial navigation altitude\n        float diff = fabsf(baro_alt - baro_ref);\n\n        // if the difference is greater than the limit, log a failure and return false\n        if (diff > copter.g.arming_alt_error_max) {\n            if (display_failure) {\n                AP_Notify::flags.arming_check_baro_failed = true;\n            }\n            return false;\n        }\n    }\n\n    // all checks passed, return true\n    return true;\n}", "CodeBleu_score": 50.14839003804248}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if the terrain source is from a rangefinder, we don't need a database\n    if (copter.wp_nav->get_terrain_source() == AP_Terrain::SOURCE_RANGEFINDER) {\n        return false;\n    }\n\n    // if the terrain source is from the terrain database and the RTL altitude\n    // type is terrain, we do need a database\n    if ((copter.wp_nav->get_terrain_source() == AP_Terrain::SOURCE_TERRAIN) &&\n        (copter.mode_rtl.get_alt_type() == ModeRTL::ALT_TYPE_TERRAIN)) {\n        return true;\n    }\n\n    // defer to the base class implementation of terrain_database_required\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 73.54513346815297}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AC_Terrain::TerrainSource::TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (copter.mode_rtl.get_alt_type() == ModeRTL::AltType::ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 70.61737164421396}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if the terrain source is from a rangefinder, we don't need a terrain database\n    if (copter.wp_nav->get_terrain_source() == AC_TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n\n    // if the terrain source is from the terrain database and the RTL altitude type is terrain, we need a terrain database\n    if (copter.mode_rtl.get_alt_type() == RTL_ALT_TERRAIN) {\n        return true;\n    }\n\n    // defer to base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.485508261736086}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // set loop time for attitude, position, and motor controllers using the last loop time from the scheduler\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // run the low-level rate controllers that require only IMU data\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 49.51466761076095}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop time for rate controllers\n    attitude_control->rate_controller_run(scheduler.get_last_loop_time_us());\n}", "CodeBleu_score": 12.840460892471844}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop time for rate controllers\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 11.784195927124605}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if we are in a mission\n    if (!mission.state == AP_Mission::MISSION_RUNNING) {\n        return false;\n    }\n\n    // check if the old and new locations are the same\n    if (old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    // check if the altitude frames are the same\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 64.71286355244814}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (old_loc.same_loc_as(new_loc) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n        // exit if no change\n        return false;\n    }\n\n    if (!set_target_location(new_loc)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 60.6235322562643}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // exit immediately if we are not in guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // exit immediately if we are not in guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // check if the old location matches the new waypoint location\n    if (!old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    // check if the altitude frame of the old and new locations are the same\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    return mode_guided.set_destination(new_loc);\n}", "CodeBleu_score": 63.55070310085945}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AUX_SWITCH_HIGH) {\n        // set mode using set_mode method\n        copter.set_mode(mode, MODE_REASON_GCS_COMMAND);\n    } else if (copter.flightmode->mode_number == mode) {\n        // reset mode switch\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 59.57237234325075}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t", "CodeBleu_score": 6.660368524040123}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // check if the mode switch is in the HIGH position\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        // set mode\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else {\n        // check if the mode switch is in the MIDDLE position\n        if (ch_flag == AuxSwitchPos::MIDDLE) {\n            // check if the current flight mode matches the given mode\n            if (copter.flightmode->mode_number() == mode) {\n                // reset mode switch\n                rc().reset_mode_switch();\n            }\n        }\n    }\n}", "CodeBleu_score": 73.28246139405336}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // get roll and pitch trim values\n    float roll_trim = channel_roll->get_control_in() * ToRad;\n    float pitch_trim = channel_pitch->get_control_in() * ToRad;\n\n    // add them to the AHRS trim\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log the event\n    LOGGER_WRITE_EVENT(events.save_trim);\n\n    // send a confirmation message\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 68.11645841959262}, {"code": "void Copter::save_trim(){\n\t    float roll_in = channel_roll->get_control_in();\n    float pitch_in = channel_pitch->get_control_in();\n\n    LOGGER_WRITE_EVENT(LoggerEvent::TRIM_SAVED);\n\n    ahrs.add_trim(ToRad(roll_in), ToRad(pitch_in));\n\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 62.190603074794005}, {"code": "void Copter::save_trim(){\n\t    // get roll and pitch input\n    float roll_input = channel_roll->get_control_in();\n    float pitch_input = channel_pitch->get_control_in();\n\n    // convert to radians\n    float roll_rad = ToRad(roll_input);\n    float pitch_rad = ToRad(pitch_input);\n\n    // add to ahrs\n    ahrs.add_trim(roll_rad, pitch_rad);\n\n    // log event\n    LOGGER_WRITE_EVENT(events.save_trim);\n\n    // send message\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 60.88239880480324}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float yaw_angle = 0.0f;\n    Vector2f vel = copter.inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.xy().length_squared();\n    if (copter.position_ok() && speed_sq > 0.01f) {\n        yaw_angle = degrees(atan2f(vel.y, vel.x));\n    }\n    return yaw_angle;\n}", "CodeBleu_score": 58.924581714722926}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float yaw_angle = 0.0f;\n\n    // get velocity in NEU frame\n    const Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // if position is ok and we're moving\n    if (copter.position_ok() && vel.xy().length_squared() > 0.0f) {\n        // calculate yaw angle\n        yaw_angle = degrees(atan2f(vel.y, vel.x));\n    }\n\n    return yaw_angle;\n}", "CodeBleu_score": 48.36742118047878}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    Vector2f vel = inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.length_squared();\n    if (copter.position_ok() && speed_sq > 0.0001f) {\n        return degrees(atan2f(vel.y, vel.x));\n    }\n    return 0.0f;\n}", "CodeBleu_score": 39.341734910946464}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // if arming checks are disabled or the watchdog was armed,\n    // we can't check anything\n    if (checks_to_perform == 0 || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // if arming with the RUDDER method, we must be armed with the throttle\n    if (method == AP_Arming::Method::RUDDER) {\n        // check if rudder arming is disabled or if the throttle is not zero\n        if (get_rudder_arming_type() == RUDDER_ARMING_DISABLED || plane.get_throttle_input() != 0) {\n            return false;\n        }\n    }\n\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 48.13639667704117}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (!AP_Arming::arm_checks(method)) {\n        return false;\n    }\n\n    // check if rudder arming is disabled or throttle is not zero\n    if ((method == AP_Arming::Method::RUDDER) &&\n        (is_zero(get_rudder_arming_type()) || !plane.get_throttle_input())) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 37.20163741775844}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // if arming checks are disabled, we're done\n    if (!_arming_checks) {\n        return true;\n    }\n\n    // if the watchdog was armed, we're done\n    if (hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // check for arming method\n    switch (method) {\n\n    case AP_Arming::Method::RUDDER:\n        // check if rudder arming is disabled\n        if (!_rudder_arming) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Rudder arming disabled\");\n            return false;\n        }\n\n        // check if throttle is not zero\n        if (plane.get_throttle_input() != 0) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Throttle not zero\");\n            return false;\n        }\n\n        // fall-through\n\n    default:\n        // call parent class's arm_checks\n        return AP_Arming::arm_checks(method);\n    }\n}", "CodeBleu_score": 63.51453569364527}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (method == AP_Arming::Method::AUTO) {\n        // if we're in auto arming mode, we only arm if we're in the correct mode\n        if (plane.flightmode->has_manual_throttle() || plane.flightmode->has_manual_throttle_and_nav_throttle()) {\n            return false;\n        }\n    }\n\n    // if we're in auto arming mode, we only arm if we're in the correct mode\n    if (plane.flightmode->has_manual_throttle() || plane.flightmode->has_manual_throttle_and_nav_throttle()) {\n        return false;\n    }\n\n    // check if we're in a safe state to arm\n    if (do_arming_checks && !plane.g2.safety.pre_arm_checks(true)) {\n        return false;\n    }\n\n    // set the arming method\n    set_arming_method(method);\n\n    // update the home location\n    plane.update_home();\n\n    // set the home location in the AHRS system\n    plane.ahrs.set_home(plane.current_loc);\n\n    // update the current location\n    plane.update_current_loc();\n\n    // change the arm state\n    change_arm_state();\n\n    // set the delay arming flag\n    delay_arming = true;\n\n    // send a status text indicating that the throttle is armed\n    send_arm_disarm_statustext(true);\n\n    // return true to indicate that the arming process was successful\n    return true;\n}", "CodeBleu_score": 50.918601335554925}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // return immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // return immediately if arming checks are not required\n    if (!do_arming_checks) {\n        return arm_without_checks(method);\n    }\n\n    // check if arming checks should be skipped\n    if (skip_arming_checks()) {\n        return arm_without_checks(method);\n    }\n\n    // run arming checks\n    if (!arming_checks()) {\n        return false;\n    }\n\n    // if we got this far then arming checks have passed\n    return arm_without_checks(method);\n}", "CodeBleu_score": 41.879418237800714}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (method != AP_Arming::Method::AUTOMATIC) {\n        // manual arming, set the arming method and return\n        arming_method = method;\n        return true;\n    }\n\n    // automatic arming, perform checks\n    if (do_arming_checks) {\n        if (!AP_Arming::pre_arm_checks(hal.util->get_soft_armed())) {\n            return false;\n        }\n    }\n\n    // set arming method\n    arming_method = method;\n\n    // set the arming state to arming\n    set_arming_state(ARMING_STATE_ARMING);\n\n    // set the arming flag\n    set_arming(true);\n\n    // send arming status text\n    AP_Notify::flags.armed = true;\n\n    // return success\n    return true;\n}", "CodeBleu_score": 44.68249541360242}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if already armed, return true\n    if (is_armed()) {\n        return true;\n    }\n\n    // if no disarm button is configured, display failure message and return false\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_check = true;\n            AP_Notify::flags.check_failed = true;\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 68.7836390146631}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed()) {\n        return true;\n    }\n\n    if (!has_disarm_function) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_check = true;\n            AP_Notify::flags.arm_checks = true;\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.61122685145322}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if the vehicle is already armed, return true\n    if (is_armed()) {\n        return true;\n    }\n\n    // check if a disarm button is configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_check_failed = true;\n        }\n        return false;\n    }\n\n    // call the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.29796761867084}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x*ahrs.cos_yaw - y*ahrs.sin_yaw;\n    float ne_y = x*ahrs.sin_yaw + y*ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 70.04660597491264}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t  float yaw_angle_cd = packet.param1;\n  float yaw_rate_cds = packet.param2;\n  float look_ahead_time_s = packet.param3;\n  float yaw_angle_offset_cd = packet.param4;\n  float yaw_rate_offset_cds = packet.param5;\n  float look_ahead_time_offset_s = packet.param6;\n\n  // check if yaw angle and param4 are within acceptable ranges\n  if (!is_zero(yaw_angle_cd) && !is_equal(yaw_angle_offset_cd, 0.0f)) {\n    return MAV_RESULT_DENIED;\n  }\n\n  // set yaw heading using the provided parameters\n  _sub.set_auto_yaw_look_at_heading(yaw_angle_cd, yaw_rate_cds, look_ahead_time_s, yaw_angle_offset_cd, yaw_rate_offset_cds, look_ahead_time_offset_s);\n\n  return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 41.33849176958094}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // check if vehicle is in guided mode\n    if (!copter.mode_guided.enabled()) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check if vehicle is armed\n    if (!copter.motors->armed()) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // get current yaw heading\n    float yaw_heading = copter.attitude_control->get_yaw_rate_cds();\n\n    // get yaw angle\n    float angle_cd = packet.param1;\n\n    // get yaw rate\n    float rate_cds = packet.param2;\n\n    // check if angle and rate are within acceptable ranges\n    if (is_zero(angle_cd) && is_zero(rate_cds)) {\n        // set yaw heading to current heading\n        copter.guided_angle_yaw_cd = yaw_heading;\n    } else {\n        // set yaw heading to current heading plus angle\n        copter.guided_angle_yaw_cd = yaw_heading + angle_cd;\n    }\n\n    // set yaw rate\n    copter.guided_yaw_rate_cds = rate_cds;\n\n    // set yaw mode\n    copter.guided_mode = GUIDED_YAW;\n\n    // return success\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 29.075746614883013}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // check if the yaw angle and param4 values are within acceptable ranges\n    if (packet.param4 < 0 || packet.param4 > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set the yaw heading using the provided parameters\n    set_yaw_look_at_heading(packet.param4, packet.param5);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 35.41893068531533}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360_cd(wp_nav.get_wp_bearing_to_destination()) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 48.547246885015525}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    // if we are not in guided mode, return 0\n    if (control_mode != GUIDED && control_mode != AUTO) {\n        return 0;\n    }\n    // convert the waypoint bearing from -18000->18000 to 0->360 and then divides by 2\n    return wrap_360_cd(wp_bearing_cd) / 2;\n}", "CodeBleu_score": 36.7629031281314}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360_cd(wp_bearing_cd) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 40.591103488613754}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(id)) {\n        LogPacket pkt{LOG_PACKET_HEADER_INIT(id)};\n        pkt.time_us = AP_HAL::micros64();\n        pkt.data.log_int = value;\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 55.38758504429522}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(id)) {\n        struct log_Packet pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_PACKET_ID_DATA),\n            time_usec : AP_HAL::micros64(),\n            id : (uint8_t)id,\n            value : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 82.75044230224718}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (!should_log(id)) {\n        return;\n    }\n    struct log_Packet pkt = {\n        LOG_PACKET_HEADER_INIT(LOG_PACKET_ID_DATA),\n        static_cast<uint64_t>(AP_HAL::micros64()),\n        static_cast<uint16_t>(id),\n        static_cast<uint32_t>(value)\n    };\n    AP::can().write_log(pkt);\n}", "CodeBleu_score": 47.94536005348932}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    if (home_is_set() || !motors.armed) {\n        return;\n    }\n    set_home_to_current_location_inflight();\n}", "CodeBleu_score": 21.117985195990933}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (home_is_set() || !motors.armed) {\n        return;\n    }\n    set_home_to_current_location_inflight();\n}", "CodeBleu_score": 21.117985195990933}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (home_is_set()) {\n        return;\n    }\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 50.998738877422745}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    // if not armed set throttle to zero and exit immediately\n    if (!motors.armed()) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_angle_rates(channel_roll->norm_input(), channel_pitch->norm_input(), target_roll, target_pitch);\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, channel_yaw->norm_input());\n\n    // set motors to desired range\n    motors.set_forward(channel_forward->norm_input());\n    motors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 56.120369371009616}, {"code": "void ModeAcro::run(){\n\t    // if not armed or throttle down, go to pilot's manual throttle mode\n    if (!motors.armed() || !motors.get_desired_spool_state()) {\n        // set motors to full range\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n        // exit acro mode\n        set_mode_to_exit();\n        return;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(channel_roll->norm_input(), channel_pitch->norm_input(), target_roll, target_pitch, g.acro_deadzone.get());\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input());\n\n    // get pilot's desired throttle\n    float target_throttle = channel_throttle->norm_input();\n\n    // send the PIDs the target\n    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate);\n\n    // output pilot's throttle without angle boost\n    motors.set_throttle(target_throttle);\n\n    // calculate forward and lateral outputs\n    float lateral_out, forward_out;\n    get_pilot_desired_lateral_forward(channel_lateral->norm_input(), channel_forward->norm_input(), lateral_out, forward_out);\n\n    // send the PIDs the lateral and forward outputs\n    motors.set_lateral(lateral_out);\n    motors.set_forward(forward_out);\n}", "CodeBleu_score": 55.712956171627425}, {"code": "void ModeAcro::run(){\n\t    float target_roll, target_pitch, target_yaw_rate;\n    float pilot_throttle_scaled;\n    float pilot_desired_yaw_rate;\n\n    // if not armed or channel_roll->get_control_in() is zero, set throttle to zero and exit immediately\n    if (!motors.armed() || channel_roll->get_control_in() == 0.0f) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->relax_attitude_controllers();\n        pilot_throttle_scaled = 0.0f;\n        pilot_desired_yaw_rate = 0.0f;\n    } else {\n        // convert the input to the desired body frame rate\n        get_pilot_desired_angle_rates(channel_roll->norm_input(), channel_pitch->norm_input(), target_roll, target_pitch, pilot_desired_yaw_rate);\n\n        // get pilot's desired throttle\n        pilot_throttle_scaled = channel_throttle->norm_input();\n\n        // set motors to full range\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n        // run attitude controller\n        attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, pilot_desired_yaw_rate);\n    }\n\n    // set motors to desired throttle\n    motors.set_forward(pilot_throttle_scaled);\n    motors.set_lateral(channel_lateral->norm_input());\n    motors.set_yaw(pilot_desired_yaw_rate);\n}", "CodeBleu_score": 66.55070054173119}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t", "CodeBleu_score": 2.656653974022399}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set position controller to waypoint control\n    sub.pos_control.init_z_controller();\n    sub.pos_control.init_xy_controller();\n    sub.pos_control.set_alt_target_to_stopping_point_z();\n    sub.pos_control.set_desired_accel_z(-GRAVITY_MSS);\n\n    // set position controller's target to the stopping point\n    sub.wp_nav.set_wp_destination(sub.pos_control.get_pos_target_z());\n\n    // set yaw state to use the yaw passed in\n    sub.set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 40.62952057494205}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t", "CodeBleu_score": 2.656653974022399}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration limits\n    position_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise position and desired velocity\n    if (!wp_nav->reached_destination()) {\n        // if we are not at the destination point, use the WPNav approach target\n        Vector3f target_pos;\n        if (!wp_nav->get_wp_destination(target_pos)) {\n            return;\n        }\n        position_control->init_xy_controller(target_pos);\n    }\n\n    // initialise the vertical position controller\n    position_control->init_z_controller();\n\n    // set yaw state\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 55.86302129629731}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration limits\n    position_control->set_max_speed_accel_z(sub.guided_speed_down, sub.guided_speed_up, sub.pilot_velocity_z_max, sub.pilot_velocity_z_max);\n\n    // initialise horizontal speed controllers\n    position_control->init_xy_controller();\n\n    // initialise vertical speed controller\n    position_control->init_z_controller();\n\n    // set yaw state to user controlled\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 47.578379923609894}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration limits\n    position_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise position and desired velocity\n    position_control->init_xy_controller();\n    position_control->init_z_controller();\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 44.158043692630024}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we've timed out\n    if (millis() - guided_limit.start_time > GUIDED_LIMIT_TIMEOUT_MS) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Guided: Timed out\");\n        return true;\n    }\n\n    // check if we've moved too far\n    if (guided_limit.enabled &&\n        get_horizontal_distance_cm(guided_limit.start_pos, inertial_nav.get_position_neu_cm()) > GUIDED_LIMIT_DISTANCE_CM) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Guided: Distance limit breached\");\n        return true;\n    }\n\n    // check if we've reached/exceeded our limits\n    if (guided_limit.alt_min_cm > 0 && inertial_nav.get_altitude() < guided_limit.alt_min_cm) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Guided: Altitude too low\");\n        return true;\n    }\n    if (guided_limit.alt_max_cm > 0 && inertial_nav.get_altitude() > guided_limit.alt_max_cm) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Guided: Altitude too high\");\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 49.596298853811774}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // Check if we have timed out\n    if (millis() - guided_limit.start_time > GUIDED_TIMEOUT) {\n        gcs_send_text(MAV_SEVERITY_WARNING, \"GUIDED: Timed out\");\n        return true;\n    }\n\n    // Check if we have moved far enough\n    if (get_horizontal_distance_cm(guided_limit.start_pos.xy) > GUIDED_LIMIT_MAX_DISTANCE) {\n        gcs_send_text(MAV_SEVERITY_WARNING, \"GUIDED: Max distance reached\");\n        return true;\n    }\n\n    // Check if we have climbed too far\n    if (curr_pos.z < GUIDED_LIMIT_MIN_ALT) {\n        gcs_send_text(MAV_SEVERITY_WARNING, \"GUIDED: Altitude too low\");\n        return true;\n    }\n\n    // Check if we have descended too far\n    if (curr_pos.z > GUIDED_LIMIT_MAX_ALT) {\n        gcs_send_text(MAV_SEVERITY_WARNING, \"GUIDED: Altitude too high\");\n        return true;\n    }\n\n    // Check if we have reached the target position\n    if (is_zero(guided_limit.target_pos.xy) && is_zero(guided_limit.target_pos.z)) {\n        gcs_send_text(MAV_SEVERITY_WARNING, \"GUIDED: Target position reached\");\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 42.88375729027321}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have timed out\n    if (millis() - guided_limit.start_time > GUIDED_LIMIT_TIMEOUT_MS) {\n        return true;\n    }\n\n    // check if we have moved too far\n    if (is_zero(guided_limit.start_pos.xy)) {\n        // if we haven't started off with a valid position then we can't\n        // reliably determine if we have moved too far\n        return false;\n    }\n    const Vector2f curr_pos = inertial_nav.get_position_neu_cm();\n    if (get_horizontal_distance_cm(curr_pos, guided_limit.start_pos.xy) > GUIDED_LIMIT_DISTANCE_CM) {\n        return true;\n    }\n\n    // check if we are too high or too low\n    if (!is_zero(guided_limit.alt_min_cm) && curr_pos.z < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (!is_zero(guided_limit.alt_max_cm) && curr_pos.z > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // if we get this far we must be within limits\n    return false;\n}", "CodeBleu_score": 57.834120133065646}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    static uint32_t last_request_ms;\n    static bool pass;\n\n    if (motor_test_request_time_ms > last_request_ms) {\n        last_request_ms = motor_test_request_time_ms;\n        if (motor_test_request_time_ms < millis() - 2000) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n            pass = false;\n            AP::arming().disarm(AP_Arming::Method::MOTOR_TEST_FAIL);\n            hal.scheduler->delay(1000);\n            return false;\n        }\n    }\n\n    if (motor_test_request_time_ms < millis() - 2000 && pass) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 56.63208185837409}, {"code": "bool Sub::verify_motor_test(){\n\t    // Check if motor test requests are received at least every 2 Hz\n    if (millis() - _motor_test_last_request_ms > 500) {\n        // Send a timeout message\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        // Set the pass flag to false\n        _motor_test_pass = false;\n        // Disable the motor test\n        AP_Arming::motor_test_disarm();\n        // Disarm the system\n        AP::arming().disarm(AP_Arming::Method::MOTOR_TEST);\n        // Record the failure time\n        _motor_test_fail_time_ms = millis();\n        // Return false\n        return false;\n    }\n    // Return true\n    return true;\n}", "CodeBleu_score": 48.62096341881443}, {"code": "bool Sub::verify_motor_test(){\n\t    uint32_t now = AP_HAL::millis();\n    if (now - last_motor_test_request_ms > 2000) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"motor test request timeout\");\n        pass = false;\n        set_motor_test_state(AP_Motors::MOTORTEST_DISABLED);\n        AP::arming().disarm();\n        failure_time = now;\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 49.9666763013907}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  // get roll and pitch targets from wp_nav\n  float roll_target = wp_nav.get_roll();\n  float pitch_target = wp_nav.get_pitch();\n\n  // constrain target roll and pitch\n  roll_target = constrain_float(roll_target, -4500, 4500);\n  pitch_target = constrain_float(pitch_target, -4500, 4500);\n\n  // apply sine deadband to roll and pitch targets\n  roll_target -= sin_lookup(roll_target) * 0.01f * g.acro_deadzone;\n  pitch_target -= sin_lookup(pitch_target) * 0.01f * g.acro_deadzone;\n\n  // normalize the target roll and pitch angles\n  float roll_out, pitch_out;\n  wp_nav.nav_roll_pitch_from_accel(roll_target, pitch_target, roll_out, pitch_out);\n\n  // apply lateral and forward feed forward to targets\n  lateral_out = roll_out * 0.01f * g.acro_lf_speed;\n  forward_out = pitch_out * 0.01f * g.acro_ff_speed;\n}", "CodeBleu_score": 38.526580525234664}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // retrieve roll and pitch targets\n    float roll_target_cd = wp_nav.get_roll();\n    float pitch_target_cd = wp_nav.get_pitch();\n\n    // constrain target roll and pitch to the range of the vehicle's roll and pitch limits\n    roll_target_cd = constrain_float(roll_target_cd, -roll_limit_cd, roll_limit_cd);\n    pitch_target_cd = constrain_float(pitch_target_cd, -pitch_limit_cd, pitch_limit_cd);\n\n    // normalize the roll and pitch targets to the range of -1 to 1\n    lateral_out = -roll_target_cd / roll_limit_cd;\n    forward_out = pitch_target_cd / pitch_limit_cd;\n}", "CodeBleu_score": 43.52611447400121}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // retrieve roll and pitch targets from wp_nav\n    float roll_desired = wp_nav.get_roll();\n    float pitch_desired = wp_nav.get_pitch();\n\n    // constrain roll and pitch to the maximum absolute value\n    roll_desired = constrain_float(roll_desired, -roll_limit, roll_limit);\n    pitch_desired = constrain_float(pitch_desired, -pitch_limit, pitch_limit);\n\n    // normalize the roll and pitch\n    lateral_out = roll_desired * 100.0f;\n    forward_out = pitch_desired * 100.0f;\n}", "CodeBleu_score": 41.99427883461969}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t    if (depth_sensor_present) {\n        depth_sensor.update();\n        barometer.update();\n        if (depth_sensor.healthy() && barometer.healthy()) {\n            barometer.update_calibration(depth_sensor.altitude());\n        }\n    } else {\n        barometer.update();\n    }\n}", "CodeBleu_score": 51.25891916323112}, {"code": "void Sub::read_barometer(){\n\t    // update barometer data\n    barometer.update();\n\n    // if the altitude is above zero, update the barometer calibration\n    if (barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n\n    // if a depth sensor is present, update the sensor health status based on the barometer's health\n    if (depth_sensor_present) {\n        depth_sensor.set_healthy(barometer.healthy());\n    }\n}", "CodeBleu_score": 73.11735113400853}, {"code": "void Sub::read_barometer(){\n\t\n    barometer.update();\n\n    if (barometer.get_altitude() > 0.0f) {\n        barometer.update_calibration();\n    }\n\n    if (depth.healthy()) {\n        depth.set_healthy(barometer.healthy());\n    }\n}", "CodeBleu_score": 66.28378112591257}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    // if we don't have inertial navigation, we can't do a good job\n    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // if motors are disarmed, we can't do a good job\n    if (!motors.armed()) {\n        return false;\n    }\n\n    // if we're in constant position mode, we can't do a good job\n    if (inertial_nav.get_filter_status() >= InertialNav::CONST_POS) {\n        return false;\n    }\n\n    // if we're not using absolute positioning, we can't do a good job\n    if (!inertial_nav.get_control_position_enabled()) {\n        return false;\n    }\n\n    // if we're not using absolute velocity, we can't do a good job\n    if (!inertial_nav.get_control_velocity_enabled()) {\n        return false;\n    }\n\n    // if we're not using absolute acceleration, we can't do a good job\n    if (!inertial_nav.get_control_accel_enabled()) {\n        return false;\n    }\n\n    // if we're not using absolute heading, we can't do a good job\n    if (!inertial_nav.get_control_heading_enabled()) {\n        return false;\n    }\n\n    // if we're not using absolute yaw, we can't do a good job\n    if (!inertial_nav.get_control_yaw_enabled()) {\n        return false;\n    }\n\n    // we're good\n    return true;\n}", "CodeBleu_score": 56.352796633677386}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.have_inertial_nav) {\n        return false;\n    }\n    if (!motors.armed) {\n        return true;\n    }\n    return (ekf_origin_initialised && ekf_origin_position_ok() && !ekf_const_pos_mode);\n}", "CodeBleu_score": 22.69995428823492}, {"code": "bool Sub::ekf_position_ok(){\n\t    // check if we have inertial navigation\n    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // check if motors are disarmed\n    if (!motors.armed()) {\n        // if we are disarmed, we accept predicted horizontal position\n        return true;\n    }\n\n    // check if we have a good absolute position\n    if (!have_absolute_position()) {\n        return false;\n    }\n\n    // check if we are not in constant position mode\n    if (inertial_nav.get_filter_status().flags.pred_horiz_pos_good) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 38.15345620189991}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t", "CodeBleu_score": 1.9477481621875286}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we don't require position control, we're done\n    if (!rover.control_mode->requires_position()) {\n        return true;\n    }\n\n    // call parent GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the AHRS system is ready\n    if (!ahrs.pre_arm_check(display_failure)) {\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (rover.ekf_status() < 0) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    // ensure position estimate is valid\n    if (!rover.ekf_position_ok()) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    // passed all checks\n    return true;\n}", "CodeBleu_score": 51.9464045655271}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t", "CodeBleu_score": 1.9477481621875286}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n    if (!is_arming_complete()) {\n        return false;\n    }\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arm_disarm_statustext();\n\n    // set the SmartRTL home location\n    rover.g2.smart_rtl.set_home();\n\n    // initialize the simple mode heading\n    rover.mode_simple.init_heading();\n\n    // record the home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    return true;\n}", "CodeBleu_score": 71.73721135720955}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (!checkShouldCharge()) {\n            digitalWrite(CHARGE_ENABLE_PIN, LOW);\n            charging_enabled = false;\n            charging_disabled_at = millis();\n        }\n        else {\n            if (!charging_enabled) {\n                digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n                charging_enabled = true;\n            }\n        }\n    }\n    else {\n        if (charging_enabled) {\n            digitalWrite(CHARGE_ENABLE_PIN, LOW);\n            charging_enabled = false;\n        }\n        if (millis() - charging_disabled_at > DISCHARGING_DELAY) {\n            charging_allowed = true;\n        }\n    }\n}", "CodeBleu_score": 70.13772608892917}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (status_message.charging_enabled && !checkShouldCharge()) {\n            digitalWrite(CHARGE_ENABLE_PIN, LOW);\n            charging_disabled_time = millis();\n        } else if (!status_message.charging_enabled && millis() - charging_disabled_time > 10000) {\n            digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n        }\n    } else {\n        if (millis() - charging_disabled_time > 10000) {\n            digitalWrite(CHARGE_ENABLE_PIN, LOW);\n        }\n    }\n}", "CodeBleu_score": 55.71447143243231}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n            charging_enabled = true;\n            charging_disabled_time = 0;\n        } else {\n            digitalWrite(CHARGE_ENABLE_PIN, LOW);\n            charging_enabled = false;\n            charging_disabled_time = millis();\n        }\n    } else {\n        if (charging_enabled) {\n            digitalWrite(CHARGE_ENABLE_PIN, LOW);\n            charging_enabled = false;\n            charging_disabled_time = millis();\n        } else {\n            if (millis() - charging_disabled_time > 10000) {\n                charging_allowed = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 73.53255912903208}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  // Check if ROS is running\n  if (ros::isStarted()) {\n    // Check if the message size is at least 4 bytes\n    if (size >= 4) {\n      // Calculate the CRC for the message\n      uint16_t crc = CRC16.ccitt((uint8_t *)message, size - 2);\n      // Append the CRC to the message\n      ((uint8_t *)message)[size - 2] = crc >> 8;\n      ((uint8_t *)message)[size - 1] = crc & 0xFF;\n      // Send the message using packetSerial\n      packetSerial.sendMessage(message, size);\n    }\n  }\n}", "CodeBleu_score": 56.08635642233105}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros::isStarted()) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    uint8_t *msg = (uint8_t *)message;\n    msg[size] = (uint8_t)(crc >> 8);\n    msg[size + 1] = (uint8_t)(crc & 0xFF);\n    size += 2;\n    packetSerial.sendMessage(msg, size);\n  }\n}", "CodeBleu_score": 45.94369281823967}, {"code": "void sendMessage(void *message, size_t size){\n\t  // Check if ROS is running\n  if (ros::isStarted()) {\n    // Check if message size is at least 4 bytes\n    if (size >= 4) {\n      // Calculate CRC for message\n      uint16_t crc = CRC16.ccitt(message, size);\n      // Append CRC to message\n      memcpy((uint8_t*)message + size, &crc, 2);\n      size += 2;\n      // Send message using packetSerial\n      packetSerial.send(message, size);\n    }\n  }\n}", "CodeBleu_score": 41.83981103738979}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.flush();\n  if (myMP3.begin()) {\n    numSdTracks = myMP3.getNumTracks();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 43.19505722426639}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\t\n\t// if there are no sounds or if an MP3 is currently playing, return the number of active sounds\n\tif (active_sounds.size() == 0 || myMP3.isPlaying) {\n\t\treturn active_sounds.size();\n\t}\n\t\n\t// if an MP3 is not playing, retrieve and play the last sound from the active sounds list\n\tmyMP3.load(active_sounds.back());\n\tmyMP3.play();\n\tactive_sounds.pop_back();\n\t\n\t// return the updated number of active sounds\n\treturn active_sounds.size();\n}", "CodeBleu_score": 45.25033311732359}, {"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0 || myMP3.isPlaying) return active_sounds.size();\n    myMP3.play(active_sounds.back());\n    active_sounds.pop_back();\n    return active_sounds.size();\n}", "CodeBleu_score": 44.97274605476688}, {"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0 || myMP3.isPlaying()) {\n        return active_sounds.size();\n    }\n    else {\n        myMP3.play(active_sounds.back());\n        active_sounds.pop_back();\n        return active_sounds.size();\n    }\n}", "CodeBleu_score": 46.97142034837587}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  bool command_handled = true;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      // clean up any existing memory-mapped file\n      image_cleanup(camera);\n\n      // set up a new memory-mapped file\n      camera->mmap_file = r->mmap_file;\n      camera->mmap_file_size = r->mmap_file_size;\n      camera->mmap_file_offset = r->mmap_file_offset;\n      camera->mmap_file_size_remaining = r->mmap_file_size;\n      camera->mmap_file_offset_remaining = r->mmap_file_offset;\n      camera->mmap_file_size_to_write = r->mmap_file_size;\n      camera->mmap_file_offset_to_write = r->mmap_file_offset;\n      camera->mmap_file_size_to_read = r->mmap_file_size;\n      camera->mmap_file_offset_to_read = r->mmap_file_offset;\n      camera->mmap_file_size_to_read_remaining = r->mmap_file_size;\n      camera->mmap_file_offset_to_read_remaining = r->mmap_file_offset;\n      camera->mmap_file_size_to_write_remaining = r->mmap_file_size;\n      camera->mmap_file_offset_to_write_remaining = r->mmap_file_offset;\n\n      // set up a new image\n      image_setup(camera);\n\n      break;\n    }\n    default:\n      command_handled = false;\n  }\n\n  return command_handled;\n}", "CodeBleu_score": 53.08794787475005}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    image_cleanup(d);\n    image_setup(d);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 24.234479051954445}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    image_cleanup();\n    image_setup();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 18.52675618922363}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (d->camera) {\n    wb_mutex_lock(d->camera->mutex);\n    int h = d->camera->height;\n    wb_mutex_unlock(d->camera->mutex);\n    return h;\n  } else\n    return -1;\n}", "CodeBleu_score": 42.88821557317479}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  wb_mutex_lock(d->mutex);\n  if (d->camera)\n    height = d->camera->height;\n  wb_mutex_unlock(d->mutex);\n  return height;\n}", "CodeBleu_score": 44.939708326469884}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  wb_mutex_lock(robot_mutex);\n  if (d->camera_data)\n    height = d->camera_data->height;\n  wb_mutex_unlock(robot_mutex);\n  return height;\n}", "CodeBleu_score": 46.97563081035222}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int result;\n  wb_robot_mutex_lock();\n  WbDevice *device = wb_robot_get_device(tag);\n  if (device && device->type == WB_NODE_ACCELEROMETER) {\n    WbAccelerometer *accelerometer = (WbAccelerometer *)device;\n    result = accelerometer->sampling_period;\n  } else\n    wb_error(\"wb_accelerometer_get_sampling_period: invalid device tag (%d)\", tag);\n  wb_robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 52.08029359537696}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  wb_robot_mutex_lock();\n  WbDevice *device = wb_robot_get_device(tag);\n  if (device->nodeType != WB_NODE_ACCELEROMETER) {\n    wb_robot_mutex_unlock();\n    wb_error(\"wb_accelerometer_get_sampling_period: device tag is not an accelerometer\", tag);\n    return -1;\n  }\n  WbAccelerometer *accelerometer = (WbAccelerometer *)device->data;\n  int sampling_period = accelerometer->samplingPeriod;\n  wb_robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 50.90231497045846}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  wb_robot_mutex_lock(tag);\n  WbDevice *device = wb_robot_get_device(tag);\n  if (device->type != WB_NODE_ACCELEROMETER) {\n    wb_robot_mutex_unlock(tag);\n    fprintf(stderr, \"wb_accelerometer_get_sampling_period: Wrong device type (must be an accelerometer).\n\");\n    return -1;\n  }\n  int sampling_period = device->accelerometer->sampling_period;\n  wb_robot_mutex_unlock(tag);\n  return sampling_period;\n}", "CodeBleu_score": 47.52255987067105}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsStr = dms;\n    free(dms);\n    return dmsStr;\n}", "CodeBleu_score": 43.75778178223451}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString = string(dms);\n    free(dms);\n    return dmsString;\n}", "CodeBleu_score": 46.21528316158806}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result = string(dmsString);\n    free(dmsString);\n    return result;\n}", "CodeBleu_score": 47.70960511744335}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dImmersionGeom imm;\n  dImmersionData data;\n  dReal dist;\n  int result;\n\n  D_ASSERT (box);\n  D_ASSERT (box->body);\n  D_ASSERT (flags & dImmersionFlags_All);\n  D_ASSERT (immersion);\n\n  /* initialize immersion data */\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.flags = flags;\n\n  /* perform immersion checking */\n  result = dImmersionChecking (&data);\n\n  /* return result */\n  return result;\n}", "CodeBleu_score": 45.03189297503856}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dImmersionGeom immersionData;\n  dASSERT (box != NULL);\n  dASSERT (box->body != NULL);\n  dASSERT (flags == DX_IMMERSE_ALL || flags == DX_IMMERSE_NONE || flags == DX_IMMERSE_BODY);\n  dASSERT (immersion != NULL);\n  dASSERT (immersion->flags == DX_IMMERSE_ALL || immersion->flags == DX_IMMERSE_NONE || immersion->flags == DX_IMMERSE_BODY);\n  immersionData.box = box;\n  immersionData.fluidPlane = fluidPlane;\n  immersionData.immersion = immersion;\n  immersionData.flags = flags;\n  return dPerformImmersionChecking (&immersionData, dImmerseBoxCheck);\n}", "CodeBleu_score": 41.166860690277865}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dImmersionData data;\n  dImmersionGeom immersionGeom;\n  int result;\n\n  dASSERT(box != NULL);\n  dASSERT(box->body != NULL);\n  dASSERT(dImmersionFlagsValid(flags));\n\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.flags = flags;\n\n  if (immersion == NULL) {\n    immersion = &immersionGeom;\n  }\n\n  data.immersion = immersion;\n\n  dPerformImmersionChecking(&data);\n  result = data.immersion->result;\n\n  return result;\n}", "CodeBleu_score": 42.33927912611319}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, immersion, flags);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 19.389682608650677}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1, \"o1 is null\");\n  dUASSERT(o2, \"o2 is null\");\n  dUASSERT(immersion, \"immersion is null\");\n\n  if (o1->type != dBoxClass) {\n    dUASSERT(o1->type == dCapsuleClass, \"o1 is not a box or capsule\");\n    dUASSERT(o2->type == dBoxClass, \"o2 is not a box\");\n    return dImmerseBoxCapsule(o2, o1, flags, immersion);\n  }\n\n  dUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\n  sBoxImmersionData data(o1, o2, immersion, flags);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 36.666428954540415}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1->type == dBoxClass, \"o1 is not a box\");\n  dUASSERT(o2->type == dCapsuleClass, \"o2 is not a capsule\");\n\n  dImmerseBox( (dxBox *) o1, dGeomCapsuleGetImmersionPlane(o2), flags, immersion);\n}", "CodeBleu_score": 21.88660772205996}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n    // Integration limits\n    dReal z0 = zIOverR * m_capsule.m_radius;\n    dReal z1 = zIOverR * m_capsule.m_length;\n\n    // Integration step\n    dReal dz = (z1 - z0) / 1000.0;\n\n    // Integration data\n    sHemisphereIntegrationData data;\n    data.m_capsule = m_capsule;\n    data.m_zIOverR = zIOverR;\n    data.m_tanTheta0 = tanTheta0;\n\n    // Integrate the volume\n    dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(data, z0, z1, dz);\n\n    // Return the normalized volume\n    return volume / (m_capsule.m_length * M_PI * m_capsule.m_radius * m_capsule.m_radius);\n}", "CodeBleu_score": 46.00317761310366}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal z = zIOverR*radius;\n\tdReal tanTheta1 = sqrt(1.0 - z*z);\n\tdReal sinTheta0 = sqrt(1.0 - tanTheta0*tanTheta0);\n\n\tdReal dz = radius*0.5;\n\tdReal dz0 = dz*0.5;\n\n\tsHemisphereIntegrationData data0;\n\tdata0.radius = radius;\n\tdata0.zIOverR = zIOverR;\n\tdata0.tanTheta0 = tanTheta0;\n\tdata0.sinTheta0 = sinTheta0;\n\tdata0.sinTheta1 = sinTheta1;\n\tdata0.tanTheta1 = tanTheta1;\n\n\tdReal volume0 = simpson(data0, &sHemisphereIntegrationData::volumeIntegrand, 0.0, dz0, 100);\n\n\tsHemisphereIntegrationData data1;\n\tdata1.radius = radius;\n\tdata1.zIOverR = zIOverR;\n\tdata1.tanTheta0 = tanTheta0;\n\tdata1.sinTheta0 = sinTheta0;\n\tdata1.sinTheta1 = sinTheta1;\n\tdata1.tanTheta1 = tanTheta1;\n\n\tdReal volume1 = simpson(data1, &sHemisphereIntegrationData::volumeIntegrand, dz0, dz, 100);\n\n\treturn (volume0 + volume1);\n}", "CodeBleu_score": 42.92443856960973}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n    // Calculate the integration bounds for the hemisphere.\n    dReal zIOverRMinus = zIOverR - (dReal) 0.01;\n    dReal zIOverRPlus = zIOverR + (dReal) 0.01;\n\n    // Calculate the integration bounds for the capsule.\n    dReal tanTheta0Minus = tanTheta0 - (dReal) 0.01;\n    dReal tanTheta0Plus = tanTheta0 + (dReal) 0.01;\n\n    // Calculate the integration bounds for the sphere.\n    dReal sinTheta1Minus = sinTheta1 - (dReal) 0.01;\n    dReal sinTheta1Plus = sinTheta1 + (dReal) 0.01;\n\n    // Calculate the volume of the hemisphere.\n    dReal hemisphereVolume = (dReal) 1.0 / (dReal) 3.0 * (zIOverRPlus * zIOverRPlus * zIOverRPlus) * (dReal) M_PI;\n\n    // Calculate the volume of the capsule.\n    dReal capsuleVolume = (dReal) 1.0 / (dReal) 3.0 * (zIOverRPlus * zIOverRPlus * zIOverRPlus) * (dReal) M_PI * (tanTheta0Plus - tanTheta0Minus);\n\n    // Calculate the volume of the sphere.\n    dReal sphereVolume = (dReal) 1.0 / (dReal) 3.0 * (zIOverRPlus * zIOverRPlus * zIOverRPlus) * (dReal) M_PI * (sinTheta1Plus - sinTheta1Minus);\n\n    // Calculate the total volume.\n    dReal totalVolume = hemisphereVolume + capsuleVolume + sphereVolume;\n\n    // Return the normalized volume.\n    return totalVolume / hemisphereVolume;\n}", "CodeBleu_score": 36.69187524479285}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n\t// Simpson's rule\n\tdReal xBuoyancyCenter = 0.0;\n\tdReal xCenterOfMassIntegrand = 0.0;\n\tsHemisphereIntegrationData integrationData(this, zIOverR, tanTheta0, sinTheta1);\n\txBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(integrationData);\n\n\t// Scale by radius and adjust for volume\n\txBuoyancyCenter *= radius;\n\txBuoyancyCenter += volume * radius;\n\n\treturn xBuoyancyCenter;\n}", "CodeBleu_score": 50.200805870451745}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  sHemisphereIntegrationData data;\n  data.zIOverR = zIOverR;\n  data.tanTheta0 = tanTheta0;\n  data.sinTheta1 = sinTheta1;\n  data.volume = volume;\n  data.xBuoyancyCenter = 0.0;\n  simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(data);\n  return data.xBuoyancyCenter;\n}", "CodeBleu_score": 44.60802322676022}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    sHemisphereIntegrationData data(zIOverR, tanTheta0, sinTheta1, volume);\n    dReal result = Simpson(data, 0.0, 2.0 * M_PI, 1000);\n    return result;\n}", "CodeBleu_score": 24.7665483546954}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1 && o2, \"The two geoms must be valid\");\n  dUASSERT(o1->type == dCapsuleClass, \"The first geom must be a capsule\");\n  dUASSERT(o2->type == dTriMeshClass, \"The second geom must be a trimesh\");\n  dUASSERT(immersion, \"The immersion geom must be valid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 31.29247871228594}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This triangle mesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 33.970801976423445}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1->type == dCapsuleClass, \"o1 is not a capsule\");\n  dUASSERT(o2->type == dTriMeshClass, \"o2 is not a trimesh\");\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(static_cast<dxCapsule*>(o1), o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 27.65847337261661}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  int64_t sleep_duration_ms = getInput<int64_t>(\"duration\");\n\n  if (sleep_duration_ms <= 0) {\n    return SUCCESS;\n  }\n\n  setStatus(RUNNING);\n  timer_.add(std::chrono::milliseconds(sleep_duration_ms));\n  timer_.waitAsync(std::bind(&SleepNode::emitWakeUpSignal, this));\n  timer_waiting_ = true;\n  return RUNNING;\n}", "CodeBleu_score": 34.154389121628846}, {"code": "NodeStatus SleepNode::onStart(){\n\t  // Get the sleep duration in milliseconds from the input\n  std::chrono::milliseconds duration;\n  if (!getInput(\"duration\", duration)) {\n    return SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(RUNNING);\n\n  // Start a timer\n  timer_.add(duration);\n\n  // Set a callback to emit a wake-up signal when the timer expires\n  timer_.addCallback([this]() {\n    emitWakeUpSignal();\n  });\n\n  // Return SUCCESS\n  return SUCCESS;\n}", "CodeBleu_score": 32.36597500110221}, {"code": "NodeStatus SleepNode::onStart(){\n\t    if (!getInput(\"duration\", sleep_duration_)) {\n        return SUCCESS;\n    }\n    if (sleep_duration_ <= 0) {\n        return SUCCESS;\n    }\n    setStatus(RUNNING);\n    timer_.add(std::chrono::milliseconds(sleep_duration_));\n    timer_.setCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n    timer_waiting_ = true;\n    return SUCCESS;\n}", "CodeBleu_score": 37.05663838204831}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  // Get the entry from the blackboard\n  auto entry = config().blackboard->getEntry(config().entry_name);\n\n  // Check if the entry exists\n  if (!entry) {\n    return NodeStatus::FAILURE;\n  }\n\n  // Lock the entry's mutex\n  std::lock_guard<std::mutex> lock(entry->mutex);\n\n  // Check if the sequence ID has changed\n  if (entry->sequence_id != sequence_id_) {\n    // Update the stored sequence ID\n    sequence_id_ = entry->sequence_id;\n\n    // Return SUCCESS\n    return NodeStatus::SUCCESS;\n  }\n\n  // Return FAILURE\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 48.71099770724142}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  // Get the entry from the blackboard\n  Entry *entry = config().blackboard->getEntry(config().entry_name);\n  if (entry == nullptr) {\n    return NodeStatus::FAILURE;\n  }\n\n  // Lock the entry's mutex\n  std::unique_lock<std::mutex> lock(entry->mutex);\n\n  // Check if the entry's sequence ID has changed\n  if (entry->sequence_id != sequence_id_) {\n    // Update the stored sequence ID\n    sequence_id_ = entry->sequence_id;\n    return NodeStatus::SUCCESS;\n  }\n\n  // Entry's sequence ID has not changed\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 48.44030291941914}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Get the entry from the blackboard\n    Entry* entry = config().blackboard->getEntry(config().entry_name);\n\n    // Check if the entry exists\n    if (entry == nullptr) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the entry's mutex\n    entry->mutex.lock();\n\n    // Check if the entry's sequence ID has changed\n    if (entry->sequence_id != config().sequence_id) {\n        // Update the stored sequence ID\n        config().sequence_id = entry->sequence_id;\n        // Unlock the entry's mutex\n        entry->mutex.unlock();\n        // Return SUCCESS\n        return NodeStatus::SUCCESS;\n    }\n\n    // Unlock the entry's mutex\n    entry->mutex.unlock();\n    // Return FAILURE\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 43.53205082881439}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return static_cast<size_t>(std::max(success_threshold_ * children_nodes_.size(), 0.0));\n    } else {\n        return static_cast<size_t>(success_threshold_);\n    }\n}", "CodeBleu_score": 59.6459676763043}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return std::max(size_t(-success_threshold_), children_nodes_.size());\n    } else {\n        return success_threshold_;\n    }\n}", "CodeBleu_score": 60.29422269083224}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return std::max(static_cast<int>(children_nodes_.size()) + success_threshold_, 0);\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 56.931044174585296}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    auto now = std::chrono::system_clock::now();\n    if (_p->heartbeat_active && now - _p->heartbeat_last_time > std::chrono::milliseconds(1000)) {\n      _p->heartbeat_active = false;\n      enableAllHooks(false);\n    }\n  }\n}", "CodeBleu_score": 47.77385640926269}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  std::chrono::system_clock::time_point last_heartbeat_time;\n  bool heartbeat_active = false;\n  while (!_p->stop) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    if (last_heartbeat_time != _p->last_heartbeat_time) {\n      heartbeat_active = true;\n      last_heartbeat_time = _p->last_heartbeat_time;\n    }\n    if (heartbeat_active && _p->last_heartbeat_time == std::chrono::system_clock::time_point()) {\n      heartbeat_active = false;\n      enableAllHooks(false);\n    }\n    if (!heartbeat_active && _p->last_heartbeat_time != std::chrono::system_clock::time_point()) {\n      heartbeat_active = true;\n      enableAllHooks(true);\n    }\n  }\n}", "CodeBleu_score": 48.313314352756514}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    // Sleep for 10 milliseconds\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    // Get the current time\n    auto now = std::chrono::system_clock::now();\n\n    // Check if the heartbeat status has changed\n    if (now - _p->last_heartbeat_time > std::chrono::seconds(3)) {\n      // The heartbeat status has changed\n      // Enable or disable all breakpoints\n      enableAllHooks(false);\n    }\n  }\n}", "CodeBleu_score": 35.47953622463773}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> dump;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n  while (std::getline(ss, bb_name, ',')) {\n    auto it = _p->subtrees.find(bb_name);\n    if (it == _p->subtrees.end()) {\n      ROS_ERROR_STREAM(\"Blackboard '\" << bb_name << \"' not found\");\n      continue;\n    }\n    auto subtree = it->second.lock();\n    if (!subtree) {\n      ROS_ERROR_STREAM(\"Blackboard '\" << bb_name << \"' not found\");\n      continue;\n    }\n    nlohmann::json json_object;\n    if (subtree->exportToJSON(json_object)) {\n      std::string json_string = json_object.dump();\n      std::vector<uint8_t> json_data(json_string.begin(), json_string.end());\n      dump.insert(dump.end(), json_data.begin(), json_data.end());\n    }\n  }\n  return dump;\n}", "CodeBleu_score": 48.515318884967556}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  nlohmann::json json_obj;\n  std::istringstream iss(bb_list);\n  std::string bb_name;\n  while (std::getline(iss, bb_name, ',')) {\n    bt_blackboard::Blackboard::Ptr bb = blackboard_manager->getBlackboard(bb_name);\n    if (bb) {\n      bt_blackboard::Subtree::Ptr subtree = bb->getSubtree();\n      if (subtree) {\n        bt_blackboard::Subtree::Lock lock(subtree);\n        json_obj[bb_name] = ExportBlackboardToJSON(bb);\n      }\n    }\n  }\n  return json_obj.dump();\n}", "CodeBleu_score": 40.9583800522174}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> msgpack_dump;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n  while (std::getline(ss, bb_name, ',')) {\n    auto it = _p->subtrees.find(bb_name);\n    if (it != _p->subtrees.end()) {\n      auto subtree = it->second.lock();\n      if (subtree) {\n        auto bb = subtree->blackboard();\n        if (bb) {\n          nlohmann::json json_dump;\n          ExportBlackboardToJSON(bb, json_dump);\n          msgpack_dump.insert(msgpack_dump.end(), json_dump.dump().begin(), json_dump.dump().end());\n        }\n      }\n    }\n  }\n  return msgpack_dump;\n}", "CodeBleu_score": 53.063443312316004}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->wakeup.mutex);\n  if (hook->status != Monitor::Hook::Status::BREAKPOINT) {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 46.39652053543998}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->wakeup.mutex);\n  if (hook->status == Monitor::Hook::Status::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 46.49635455881083}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if (hook->mode != Mode::BREAKPOINT) {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 45.273291919679934}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    NodeStatus prev_status = status();\n\n    if (prev_status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n        std::async(std::launch::async, [this]() {\n            try {\n                NodeStatus status = tick_functor_(*this);\n                if (status != NodeStatus::IDLE) {\n                    setStatus(status);\n                }\n            } catch (const std::exception& ex) {\n                ROS_ERROR(\"Exception thrown in tick(): %s\", ex.what());\n                setStatus(NodeStatus::IDLE);\n            }\n        });\n    }\n\n    if (halt_requested_.load()) {\n        setStatus(NodeStatus::IDLE);\n    }\n\n    if (exception_ptr_) {\n        std::rethrow_exception(exception_ptr_);\n    }\n\n    return status();\n}", "CodeBleu_score": 50.31566294190857}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    std::future<void> future = std::async(std::launch::async, [this](){\n      try\n      {\n        tick_functor_(*this);\n      }\n      catch(...)\n      {\n        setStatus(NodeStatus::IDLE);\n        exception_ = std::current_exception();\n      }\n    });\n    future.wait();\n  }\n\n  if(!halt_requested_.load())\n  {\n    setStatus(NodeStatus::SUCCESS);\n  }\n  else\n  {\n    setStatus(NodeStatus::IDLE);\n  }\n\n  if(exception_)\n  {\n    std::rethrow_exception(exception_);\n  }\n\n  return status();\n}", "CodeBleu_score": 45.24950060543784}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    auto future = std::async(std::launch::async, [this]() {\n      try {\n        NodeStatus status = tick_functor_(*this);\n        if(status != NodeStatus::IDLE) {\n          halt_requested_.store(true);\n        }\n      } catch(...) {\n        halt_requested_.store(true);\n        exception_ = std::current_exception();\n      }\n    });\n    future.wait();\n  }\n\n  if(!halt_requested_.load()) {\n    setStatus(NodeStatus::SUCCESS);\n  }\n\n  if(exception_) {\n    std::rethrow_exception(exception_);\n    exception_ = nullptr;\n    setStatus(NodeStatus::IDLE);\n  }\n\n  return status();\n}", "CodeBleu_score": 49.38192101122031}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << \"---------------------\n\";\n\n  auto print_node = [&](const TreeNode* node, int depth) {\n    for (int i = 0; i < depth; ++i) {\n      stream << \"--\";\n    }\n    stream << node->name << std::endl;\n  };\n\n  std::function<void(const TreeNode*, int)> recursive_print;\n  recursive_print = [&](const TreeNode* node, int depth) {\n    print_node(node, depth);\n    if (const auto control = dynamic_cast<const ControlNode*>(node)) {\n      for (const auto& child : control->children) {\n        recursive_print(child, depth + 1);\n      }\n    } else if (const auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n      recursive_print(decorator->child, depth + 1);\n    }\n  };\n\n  recursive_print(root_node, 0);\n\n  stream << \"---------------------\n\";\n}", "CodeBleu_score": 51.67654134947498}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  // Separator lines\n  stream << \"---------------------\" << std::endl;\n  stream << \"Tree structure:\" << std::endl;\n  stream << \"---------------------\" << std::endl;\n\n  // Recursive lambda function to print the tree structure\n  std::function<void(const TreeNode*, int)> recursivePrint =\n      [&recursivePrint, &stream](const TreeNode* node, int depth) {\n        // Indent based on node depth\n        for (int i = 0; i < depth; ++i) {\n          stream << \"  \";\n        }\n\n        // Print node name\n        stream << node->name << std::endl;\n\n        // Recursively print children for ControlNode or child for DecoratorNode\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n          for (const auto& child : control->children) {\n            recursivePrint(child, depth + 1);\n          }\n        } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n          recursivePrint(decorator->child, depth + 1);\n        }\n      };\n\n  // Call the recursive function with the root node and depth 0\n  recursivePrint(root_node, 0);\n\n  // Separator lines\n  stream << \"---------------------\" << std::endl;\n}", "CodeBleu_score": 64.01733164340394}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << \"-----------------\n\";\n\n  auto print_tree_recursively = [&](const TreeNode* node, int depth) {\n    stream << std::string(depth, ' ') << node->name << \"\n\";\n\n    if (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n      for (const auto& child : control->children) {\n        print_tree_recursively(child.get(), depth + 1);\n      }\n    } else if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n      print_tree_recursively(decorator->child.get(), depth + 1);\n    }\n  };\n\n  print_tree_recursively(root_node, 0);\n\n  stream << \"-----------------\n\";\n}", "CodeBleu_score": 44.03051569998202}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 93.0591372626442}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if(!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for(const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 98.72900013105291}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if(!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for(const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 98.91607134913787}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    auto _p = getPrivateData();\n    auto it = _p->builders.find(manifest.id);\n    if (it != _p->builders.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory: registration ID already registered: \" + manifest.id);\n    }\n    _p->builders.insert(std::make_pair(manifest.id, builder));\n    _p->manifests.insert(std::make_pair(manifest.id, manifest));\n}", "CodeBleu_score": 58.556230363381836}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (_p->builders.find(manifest.registration_id) != _p->builders.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder(): \"\n                                    \"registration ID already exists: \" +\n                                    manifest.registration_id);\n    }\n    _p->builders.insert(std::make_pair(manifest.registration_id, builder));\n    _p->manifests.insert(std::make_pair(manifest.registration_id, manifest));\n}", "CodeBleu_score": 52.26921110638914}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (_p->builders.find(manifest.registrationID) != _p->builders.end()) {\n    throw BehaviorTreeException(\n        \"BehaviorTreeFactory::registerBuilder(): ID already registered: \" +\n        manifest.registrationID);\n  }\n  _p->manifests.insert(std::make_pair(manifest.registrationID, manifest));\n  _p->builders.insert(std::make_pair(manifest.registrationID, builder));\n}", "CodeBleu_score": 55.742112105155684}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = TreeNodeType::ACTION;\n  manifest.registration_ID = ID;\n  manifest.ports = ports;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 68.88119179566982}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const TreeNode& parent_node,\n                               const Blackboard::Ptr& blackboard,\n                               const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(tick_functor, std::move(config));\n  };\n\n  TreeNodeManifest manifest(TreeNodeType::ACTION, ID, std::move(ports));\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 53.65022114549593}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor, ports](const TreeNode& parent_node,\n                                       const std::string& name,\n                                       const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(\n        parent_node, name, tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = TreeNodeType::ACTION;\n  manifest.registration_ID = ID;\n  manifest.ports = ports;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 56.81626817739519}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backups;\n  backups.reserve(tree.subtrees.size());\n  for (auto& sub : tree.subtrees) {\n    auto bb = Blackboard::create();\n    sub->blackboard->cloneInto(bb);\n    backups.push_back(bb);\n  }\n  return backups;\n}", "CodeBleu_score": 65.02382040030295}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bbs;\n    bbs.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        auto bb = Blackboard::create();\n        subtree->blackboard->cloneInto(bb);\n        bbs.push_back(bb);\n    }\n    return bbs;\n}", "CodeBleu_score": 60.6248300746549}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        bb.push_back(sub->blackboard->cloneInto(Blackboard::create()));\n    }\n    return bb;\n}", "CodeBleu_score": 75.51013685249386}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if(executor.has_value()) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 87.68520515197964}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if(executor.has_value())\n  {\n    return executor.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error);\n  }\n}", "CodeBleu_score": 81.02848625718622}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if(executor.has_value()) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 87.68520515197964}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (handle) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    this->path = path;\n}", "CodeBleu_score": 52.073417352983256}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (handle) {\n        throw RuntimeError(\"Library is already loaded\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    this->path = path;\n}", "CodeBleu_score": 51.383746508141435}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex);\n    if (handle) {\n        throw RuntimeError(\"Library is already loaded\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    this->path = path;\n}", "CodeBleu_score": 52.16829714244333}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size < 3) {\n        return false;\n    }\n    str = str.strip();\n    if (stripped_pointer) {\n        *stripped_pointer = str.slice(1, -1);\n    }\n    return str.startsWith(\"{\") && str.endsWith(\"}\");\n}", "CodeBleu_score": 17.996885814827664}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size < 3) {\n        return false;\n    }\n    str = str.trim();\n    if (str[0] != '{' || str[str.size - 1] != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = str.substr(1, str.size - 2);\n    }\n    return true;\n}", "CodeBleu_score": 23.00246514462647}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size < 3) {\n    return false;\n  }\n  StringView stripped = str.strip();\n  if (stripped[0] != '{' || stripped[stripped.size - 1] != '}') {\n    return false;\n  }\n  if (stripped_pointer) {\n    *stripped_pointer = stripped.substring(1, stripped.size - 1);\n  }\n  return true;\n}", "CodeBleu_score": 23.65316432269728}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = pointCost(x0, y0);\n    if (line_cost < 0)\n      return line_cost;\n\n    LineIterator line(x0, y0, x1, y1);\n\n    double point_cost;\n    while (line.isValid()) {\n      point_cost = pointCost(line.getX(), line.getY());\n      if (point_cost < 0)\n        return point_cost;\n      line_cost = std::max(line_cost, point_cost);\n      line.advance();\n    }\n\n    return line_cost;\n  }", "CodeBleu_score": 58.22036753159255}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost;\n  line_iterator line(x0, y0, x1, y1);\n\n  //if the line is invalid, return -1\n  if(!line.isValid())\n    return -1;\n\n  //if the line is valid, iterate through each point on the line\n  while(line.isValid()) {\n    //calculate the point cost\n    point_cost = pointCost(line.getX(), line.getY());\n    //if the point cost is negative, return the point cost\n    if(point_cost < 0)\n      return point_cost;\n    //if the point cost is higher than the line cost, update the line cost\n    if(point_cost > line_cost)\n      line_cost = point_cost;\n    //advance to the next point on the line\n    line.advance();\n  }\n\n  //return the total line cost\n  return line_cost;\n}", "CodeBleu_score": 76.22426020556105}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = -1;\n  LineIterator line(x0, y0, x1, y1);\n  double point_cost;\n  for(unsigned int i = 0; i < line.getLength(); line.advance(), i++) {\n    point_cost = pointCost(line.getX(), line.getY());\n    if(point_cost < 0)\n      return point_cost;\n    line_cost = std::max(line_cost, point_cost);\n  }\n  return line_cost;\n}", "CodeBleu_score": 69.18089067642248}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n\n  // create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 89.37841922522855}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty()) {\n    ROS_WARN_NAMED(\"replan_server\", \"The plan is empty, not publishing.\");\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  for (size_t i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 79.96382314834486}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  // Create a nav_msgs::Path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  // Initialize the header of the message with the frame_id and timestamp from the first pose in the path\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Copy each pose from the input path to the path message\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // Publish the path message\n  pub.publish(gui_path);\n}", "CodeBleu_score": 83.07116028683727}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  double linear_velocity = sqrt(pow(base_odom.twist.twist.linear.x, 2) + pow(base_odom.twist.twist.linear.y, 2));\n  double angular_velocity = fabs(base_odom.twist.twist.angular.z);\n  return linear_velocity <= trans_stopped_velocity && angular_velocity <= rot_stopped_velocity;\n}", "CodeBleu_score": 57.932483601134145}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  if (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.z) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.angular.x) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.angular.y) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 69.28248809192166}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t    bool stopped = false;\n    if (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n        fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n        fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity) {\n      stopped = true;\n    }\n    return stopped;\n  }", "CodeBleu_score": 79.40617834308733}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    if (setup_) {\n        if (restore_defaults) {\n            config = default_limits_;\n        }\n        limits_mutex_.lock();\n        limits_ = config;\n        limits_mutex_.unlock();\n    } else {\n        default_limits_ = config;\n        setup_ = true;\n    }\n}", "CodeBleu_score": 61.16863245900345}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  // If setup is not done, we set up the default limits\n  if (!setup_) {\n    ROS_INFO(\"Setting up local planner limits for the first time\");\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  // If restore_defaults is requested, we set the current limits to default\n  if (restore_defaults) {\n    ROS_INFO(\"Resetting local planner limits to default\");\n    config = default_limits_;\n  }\n\n  // Lock the configuration mutex and update the current limits\n  boost::mutex::scoped_lock lock(config_mutex_);\n  current_limits_ = config;\n}", "CodeBleu_score": 63.0353687237043}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_) {\n    if (restore_defaults) {\n      config = default_limits_;\n    }\n\n    limits_mutex_.lock();\n    limits_ = config;\n    limits_mutex_.unlock();\n  } else {\n    default_limits_ = config;\n    setup_ = true;\n  }\n}", "CodeBleu_score": 62.7129668309022}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int check_cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (check_cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = costmap_2d::INSCIRCLE_INFLATE;\n    return false;\n  }\n  if (check_cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_distance = costmap_2d::INSCIRCLE_INFLATE;\n    return false;\n  }\n  double new_target_distance = current_cell->target_distance +\n    costmap_2d::INSCIRCLE_INFLATE;\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 58.204218250663665}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // check if the cell is an obstacle or has no information\n  if (check_cell->cost == costmap_2d::NO_INFORMATION) {\n    // set the cell's target distance to the maximum obstacle cost\n    check_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  } else if (check_cell->cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    // set the cell's target distance to the maximum obstacle cost\n    check_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  // calculate a new target distance\n  double new_target_dist = current_cell->target_dist + costmap.getCost(check_cell->x, check_cell->y);\n\n  // update the cell's target distance if the new distance is shorter\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n  }\n\n  return true;\n}", "CodeBleu_score": 68.30963554871319}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::NO_INFORMATION)\n    return false;\n\n  double new_target_dist = current_cell->target_dist + costmap.getResolution();\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 56.26768260792836}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //if we have no footprint... then we'll just return the cell cost at the goal point\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Attempting to score a trajectory with no footprint specified.  Do you have the footprint_spec configured in your cost function?\");\n    return -9.0;\n  }\n\n  //now we'll score each cell in the footprint\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.x_, traj.y_, traj.th_, scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 63.08696490559621}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  //initialize the cost of the trajectory\n  double cost = 0.0;\n\n  //initialize the scaling factor\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //if we have no footprint... then we'll just return the cost of the two points\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Attempting to score a trajectory with no footprint specified.  Do you have the footprint_spec configured in your cost function?\");\n    return -9.0;\n  }\n\n  //we will put all obstacle costs in this array\n  double obstacle_costs[traj.getPointsSize()];\n\n  //now we'll step through each point in the trajectory, calculate the footprint cost\n  //and add it to our cost value\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.x_[i], traj.y_[i], traj.th_[i], scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint cost is negative, we have an infeasible trajectory\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    //add the cost to our sum of costs\n    obstacle_costs[i] = footprint_cost;\n  }\n\n  //if we have sum_scores_ == true, we'll sum up all of the costs\n  if (sum_scores_) {\n    for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n      cost += obstacle_costs[i];\n    }\n  }\n  //otherwise, we'll take the maximum cost\n  else {\n    cost = *std::max_element(obstacle_costs, obstacle_costs + traj.getPointsSize());\n  }\n\n  //return the cost\n  return cost;\n}", "CodeBleu_score": 57.45599359274088}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Attempting to score a trajectory with an empty footprint.\");\n    return -9.0;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double x = traj.getPoint(i).x;\n    double y = traj.getPoint(i).y;\n    double th = traj.getPoint(i).th;\n\n    double footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 73.27067500660527}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    double cos_th = cos(th);\n    double sin_th = sin(th);\n\n    //scale the footprint\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        geometry_msgs::Point new_pt;\n        new_pt.x = x + (footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th) * scale;\n        new_pt.y = y + (footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th) * scale;\n        footprint_spec[i] = new_pt;\n    }\n\n    //compute the footprint cost\n    double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec);\n\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n\n    //check if the footprint is off the map\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my)) {\n        return -7.0;\n    }\n\n    //get the cell cost at the center point of the robot\n    unsigned int center_x, center_y;\n    costmap->worldToMap(x, y, center_x, center_y);\n    double cell_cost = costmap->getCost(center_x, center_y);\n\n    //return the max between the footprint cost and the cell cost\n    return std::max(cell_cost, footprint_cost);\n}", "CodeBleu_score": 69.36083546371738}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic == \"\") {\n      ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Shutting down odometry helper since odom topic is empty\");\n      odom_sub_.shutdown();\n    } else {\n      ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Subscribing to odometry topic %s\", odom_topic_.c_str());\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n  }\n}", "CodeBleu_score": 49.38697536563791}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  boost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      if (!odom_sub_) {\n        ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Creating odometry subscriber\");\n        odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n      } else {\n        ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Changing odometry topic to %s\", odom_topic_.c_str());\n        odom_sub_.shutdown();\n        odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n      }\n    } else {\n      ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Shutting down odometry subscriber\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 45.919326495243304}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic != \"\") {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 52.4506110351179}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  // Calculate the squared distance between the current and previous positions\n  float dist = (pos - prev).squaredNorm();\n\n  // If the squared distance exceeds a threshold, reset the oscillation flags\n  if (dist > dist_thresh_) {\n    resetOscillationFlags();\n  }\n\n  // Calculate the angular difference between the current and previous positions\n  float angle = acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n\n  // If the angular difference is greater than a set angle, reset the oscillation flags\n  if (angle > angle_thresh_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 37.47321922215064}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  float dist = (pos - prev).squaredNorm();\n  float ang = fabs(atan2(pos[1], pos[0]) - atan2(prev[1], prev[0]));\n  if (dist > sq_dist_thresh_ || ang > ang_thresh_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 42.29780384444136}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  Eigen::Vector3f diff = pos - prev;\n  float dist_sq = diff.squaredNorm();\n  float angle = std::atan2(diff[1], diff[0]);\n\n  if (dist_sq > dist_sq_threshold_ || std::abs(angle) > angle_threshold_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 39.03390584860924}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //if the point is outside the grid bounds, return\n  if(gx >= width_ || gy >= height_)\n    return;\n\n  //if the point is too close to its nearest neighbor, return\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //get the index of the grid cell\n  unsigned int cell_index = gridIndex(gx, gy);\n\n  //insert the point into the grid cell\n  cells_[cell_index].push_back(pt);\n}", "CodeBleu_score": 79.53016171345837}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    //get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //check to see if the point is within the bounds of the cell\n    if (pt.x < lower_left.x || pt.x > upper_right.x || pt.y < lower_left.y || pt.y > upper_right.y)\n      return;\n\n    //check to see if the point is too close to its nearest neighbor\n    double sq_dist = nearestNeighborDistance(pt);\n    if (sq_dist < sq_min_separation_)\n      return;\n\n    //calculate the grid index\n    unsigned int grid_index = gridIndex(gx, gy);\n\n    //insert the point into the grid\n    cells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 65.15551898480763}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  unsigned int gx, gy;\n  gridCoords(pt, gx, gy);\n\n  //check if the point is too close to its nearest neighbor\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //check if the point is within the bounds of the grid\n  if(gx >= width_ || gy >= height_)\n    return;\n\n  //get the grid index\n  unsigned int g_index = gridIndex(gx, gy);\n\n  //insert the point into the grid\n  cells_[g_index].push_back(pt);\n}", "CodeBleu_score": 76.8042693972364}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f vel_new = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            vel_new[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        } else if (sample_target_vel[i] < vel[i]) {\n            vel_new[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        } else {\n            vel_new[i] = sample_target_vel[i];\n        }\n    }\n    return vel_new;\n}", "CodeBleu_score": 72.9029076857101}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        } else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        } else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 78.01942408720538}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n    } else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n    } else {\n      new_vel[i] = vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 76.3323941565786}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  int goal_idx = global_plan_.size() - 1;\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    if (costmap_.getCost(global_plan_[i].x, global_plan_[i].y) == LETHAL_OBSTACLE) {\n      continue;\n    }\n\n    double goal_x, goal_y;\n    costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y, goal_x, goal_y);\n\n    // check if the line of sight between the robot's current cell and the goal point is clear\n    if (lineOfSight(cell_x, cell_y, goal_x, goal_y)) {\n      goal_idx = i;\n      break;\n    }\n  }\n\n  // if no valid point is found, return DBL_MAX\n  if (goal_idx == global_plan_.size() - 1) {\n    return DBL_MAX;\n  }\n\n  // convert the goal cell coordinates to world coordinates\n  double goal_x, goal_y;\n  costmap_.mapToWorld(global_plan_[goal_idx].x, global_plan_[goal_idx].y, goal_x, goal_y);\n\n  // calculate the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n  double diff = angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n  return fabs(diff);\n}", "CodeBleu_score": 58.7646409746861}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // find the farthest point on the path with a clear line of sight\n  // to the robot's current cell\n  int goal_index = -1;\n  double min_dist = DBL_MAX;\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    double px = global_plan_[i].pose.position.x;\n    double py = global_plan_[i].pose.position.y;\n    if (costmap_.getCost(px, py) == costmap_2d::FREE_SPACE) {\n      double dx = px - x;\n      double dy = py - y;\n      double dist = sqrt(dx * dx + dy * dy);\n      if (dist < min_dist) {\n        min_dist = dist;\n        goal_index = i;\n      }\n    }\n  }\n\n  if (goal_index == -1) {\n    return DBL_MAX;\n  }\n\n  // convert the goal cell coordinates to world coordinates\n  double goal_x, goal_y;\n  costmap_.mapToWorld(cell_x, cell_y, goal_x, goal_y);\n\n  // calculate the absolute value of the shortest angular distance\n  // between the current heading and the direction to the goal point\n  double dx = goal_x - x;\n  double dy = goal_y - y;\n  double goal_heading = atan2(dy, dx);\n  double diff = angles::shortest_angular_distance(heading, goal_heading);\n  return fabs(diff);\n}", "CodeBleu_score": 55.113527934304926}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    // Check if the trajectory is valid\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0.0) {\n      return true;\n    }\n    // If the trajectory is invalid, log a warning and return false\n    ROS_WARN(\"Trajectory invalid with cost: %.2f, x: %.2f, y: %.2f, theta: %.2f, vx: %.2f, vy: %.2f, vtheta: %.2f, vx_samp: %.2f, vy_samp: %.2f, vtheta_samp: %.2f\", cost, x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }", "CodeBleu_score": 69.80926789458113}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0) {\n      return true;\n    }\n\n    ROS_WARN(\"Invalid trajectory: (%.3f, %.3f, %.3f) -> (%.3f, %.3f, %.3f) with cost: %.3f\",\n             x, y, theta, vx, vy, vtheta, cost);\n    return false;\n  }", "CodeBleu_score": 72.23731306727821}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0)\n      return true;\n    ROS_WARN(\"Invalid trajectory (%.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f). Cost: %.2f\",\n             x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n  }", "CodeBleu_score": 72.35453159098614}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmaps passed in to the ClearCostmapRecovery object cannot be NULL. Do you want to load the costmaps from the \n\"\n              \"parameter server? If not, please initialize this object with a costmap2d ros object\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Area to clear is set to be cleared inside the area, not outside\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if (affected_maps_ & clearing_params::GlobalCostmap) {\n    clear(global_costmap_);\n    ROS_DEBUG(\"Time taken to clear global costmap: %.3f\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (affected_maps_ & clearing_params::LocalCostmap) {\n    clear(local_costmap_);\n    ROS_DEBUG(\"Time taken to clear local costmap: %.3f\", (ros::WallTime::now() - t0).toSec());\n  }\n}", "CodeBleu_score": 48.07777431718346}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if(!initialized_){\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if(!global_costmap_ || !local_costmap_){\n    ROS_ERROR(\"The costmaps passed in to the ClearCostmapRecovery object cannot be NULL. Do you want to use the costmap_2d::NullLayer?\");\n    return;\n  }\n\n  if(invert_area_to_clear_){\n    ROS_WARN(\"Clearing inside the area, not outside\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if(affected_maps_ == \"local\" || affected_maps_ == \"both\"){\n    clear(local_costmap_);\n    local_costmap_->updateMap();\n    ROS_DEBUG(\"Cleared local costmap in %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if(affected_maps_ == \"global\" || affected_maps_ == \"both\"){\n    clear(global_costmap_);\n    global_costmap_->updateMap();\n    ROS_DEBUG(\"Cleared global costmap in %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n}", "CodeBleu_score": 54.43306422390515}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed in to the ClearCostmapRecovery object cannot be NULL. Do you want to load the \"\n              \"costmap_2d ROS plugin?\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the area is not yet supported\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  clear(global_costmap_);\n  ROS_DEBUG(\"Clearing global map took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n\n  t0 = ros::WallTime::now();\n  clear(local_costmap_);\n  ROS_DEBUG(\"Clearing local map took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n\n  if (force_update_) {\n    t0 = ros::WallTime::now();\n    global_costmap_->updateMap();\n    ROS_DEBUG(\"Updating global map took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n\n    t0 = ros::WallTime::now();\n    local_costmap_->updateMap();\n    ROS_DEBUG(\"Updating local map took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n}", "CodeBleu_score": 58.47452241516372}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    // Initialize the PolygonOutlineCells object\n    PolygonOutlineCells outline_cells;\n\n    // Iterate through the polygon vertices\n    for (unsigned int i = 0; i < polygon.size(); ++i) {\n        // Get the current vertex\n        const MapLocation& p0 = polygon[i];\n\n        // Get the next vertex\n        const MapLocation& p1 = polygon[(i + 1) % polygon.size()];\n\n        // Use raytraceLine to gather cells between the current and next vertices\n        raytraceLine(p0, p1, outline_cells);\n    }\n\n    // If the polygon is not empty, close it by connecting the last point to the first\n    if (polygon.size() > 0) {\n        // Get the first and last vertices\n        const MapLocation& p0 = polygon[0];\n        const MapLocation& p1 = polygon[polygon.size() - 1];\n\n        // Use raytraceLine to gather cells between the first and last vertices\n        raytraceLine(p0, p1, outline_cells);\n    }\n\n    // Copy the cells from the PolygonOutlineCells object to the polygon_cells vector\n    polygon_cells.clear();\n    polygon_cells.reserve(outline_cells.size());\n    for (std::vector<MapLocation>::const_iterator it = outline_cells.begin(); it != outline_cells.end(); ++it) {\n        polygon_cells.push_back(*it);\n    }\n}", "CodeBleu_score": 50.351744061787706}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  // initialize the polygon cells\n  PolygonOutlineCells outline_cells;\n  // if the polygon is not empty, add the cells between the first and last points\n  if (!polygon.empty()) {\n    outline_cells.addCellsBetween(polygon.front(), polygon.back());\n  }\n  // iterate through the polygon vertices, adding cells between each consecutive pair of points\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    outline_cells.addCellsBetween(polygon[i], polygon[i + 1]);\n  }\n  // if the polygon is not empty, add the cells between the last point and the first\n  if (!polygon.empty()) {\n    outline_cells.addCellsBetween(polygon.back(), polygon.front());\n  }\n  // add the cells to the polygon cells vector\n  polygon_cells.insert(polygon_cells.end(), outline_cells.cells.begin(), outline_cells.cells.end());\n}", "CodeBleu_score": 54.43668347561734}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  polygon_cells.clear();\n  if (polygon.empty())\n    return;\n\n  PolygonOutlineCells outline_cells;\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], outline_cells);\n  }\n  raytraceLine(polygon.back(), polygon.front(), outline_cells);\n\n  polygon_cells.insert(polygon_cells.end(), outline_cells.cells.begin(), outline_cells.cells.end());\n}", "CodeBleu_score": 52.967181782399145}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  // Prepare the grid data\n  prepareGrid();\n\n  // Publish the prepared grid\n  pub.publish(grid_);\n}", "CodeBleu_score": 98.05533239138548}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.frame_id = costmap_->getBaseFrameID();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  unsigned int mx, my;\n  costmap_->getSizeInCellsX();\n  costmap_->getSizeInCellsY();\n  unsigned char* costmap = costmap_->getCharMap();\n  unsigned int index = 0;\n  for (unsigned int i = 0; i < grid_.info.height; ++i) {\n    for (unsigned int j = 0; j < grid_.info.width; ++j) {\n      costmap_->indexToCells(index, mx, my);\n      unsigned char value = costmap[index];\n      grid_.data[index] = costmap2d::translateTo255(value);\n      ++index;\n    }\n  }\n}", "CodeBleu_score": 73.12272245486228}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  // Retrieve the resolution\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header, resolution, width, and height\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin\n  double origin_x, origin_y;\n  costmap_->mapToWorld(0.0, 0.0, origin_x, origin_y);\n\n  // Set the origin's position and orientation\n  grid_.info.origin.position.x = origin_x;\n  grid_.info.origin.position.y = origin_y;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = origin_x;\n  origin_y_ = origin_y;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  unsigned char* char_map = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = char_map[i] ? 100 : 0;\n  }\n}", "CodeBleu_score": 73.50076333288385}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double origin_x, origin_y;\n  costmap_->mapToWorld(0, 0, origin_x, origin_y);\n  grid_.info.origin.position.x = origin_x;\n  grid_.info.origin.position.y = origin_y;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  origin_x_ = origin_x;\n  origin_y_ = origin_y;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n}", "CodeBleu_score": 58.59114370882344}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint && new_config.radius == old_config.radius)\n    return;\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> footprint;\n    if (readFootprintFromString(new_config.footprint, footprint)) {\n      setUnpaddedRobotFootprint(footprint);\n    } else {\n      ROS_ERROR(\"Could not parse footprint string '%s'\", new_config.footprint.c_str());\n    }\n  } else {\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.radius));\n  }\n}", "CodeBleu_score": 67.85706290892287}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint)\n    return;\n\n  if (!new_config.footprint.empty()) {\n    try {\n      std::vector<geometry_msgs::Point> points;\n      if (parseFootprintFromString(new_config.footprint, points)) {\n        setUnpaddedRobotFootprint(points);\n      }\n      else {\n        ROS_ERROR(\"Could not parse footprint string '%s' into a vector of points\", new_config.footprint.c_str());\n      }\n    }\n    catch (tf::TransformException& ex) {\n      ROS_ERROR(\"Error parsing transform exception: %s\n\", ex.what());\n    }\n  }\n  else {\n    // No footprint string was given, so we'll create one from the radius\n    std::vector<geometry_msgs::Point> points;\n    makeFootprintFromRadius(new_config.robot_radius, points);\n    setUnpaddedRobotFootprint(points);\n  }\n}", "CodeBleu_score": 56.22517686995846}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  std::vector<geometry_msgs::Point> new_footprint;\n  if (!new_config.footprint.empty()) {\n    if (!makeFootprintFromString(new_config.footprint, new_footprint)) {\n      ROS_ERROR(\"Error parsing footprint string '%s'\", new_config.footprint.c_str());\n      return;\n    }\n  } else {\n    ROS_INFO(\"No footprint given, using a circle with radius of %.2f\", new_config.robot_radius);\n    makeFootprintFromRadius(new_config.robot_radius, new_footprint);\n  }\n\n  setUnpaddedRobotFootprint(new_footprint);\n}", "CodeBleu_score": 65.83878064114626}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Could not get robot pose\");\n    return;\n  }\n  if (!initial_pose_received_) {\n    initial_pose_ = new_pose;\n    initial_pose_received_ = true;\n    ROS_INFO(\"Initial pose received\");\n  }\n\n  // check if the robot has moved far enough to warrant a costmap update\n  if (new_pose.header.frame_id != costmap_2d_->getBaseFrameID()) {\n    ROS_ERROR_THROTTLE(1.0, \"TF error in costmap_2d_ros: Costmap2DROS frame ID %s does not equal global frame ID %s\",\n                       costmap_2d_->getBaseFrameID().c_str(), new_pose.header.frame_id.c_str());\n    return;\n  }\n\n  // check if the robot has moved far enough to warrant a costmap update\n  double sq_dist = tf2::utils::sqrtd(new_pose.pose.position.x - last_pose_.pose.position.x) +\n                   tf2::utils::sqrtd(new_pose.pose.position.y - last_pose_.pose.position.y);\n  if (sq_dist > reset_distance_) {\n    ROS_DEBUG(\"Costmap2DROS: robot has moved %.3f m since last update, updating costmap\", sqrt(sq_dist));\n    last_pose_ = new_pose;\n    updateMap(new_pose);\n  }\n}", "CodeBleu_score": 65.89514801020182}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, canceling reconfiguration\");\n    return;\n  }\n\n  // update the global and local costmaps\n  if (!updateMap(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to update costmap, canceling reconfiguration\");\n    return;\n  }\n\n  // publish the new costmap\n  publishCostmap();\n}", "CodeBleu_score": 67.98383876077989}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    geometry_msgs::PoseStamped new_pose;\n    if (!getRobotPose(new_pose)) {\n        ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, canceling reconfiguration\");\n        return;\n    }\n\n    // Check if the robot has moved significantly\n    if (new_pose.header.frame_id != global_frame_ ||\n        !new_pose.header.stamp.isZero() &&\n            new_pose.header.stamp.toSec() - last_moved_time_.toSec() > transform_tolerance_) {\n        last_moved_time_ = new_pose.header.stamp;\n        last_moved_pose_ = new_pose;\n    }\n}", "CodeBleu_score": 64.620676589684}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    ROS_INFO(\"Starting costmap2DROS\");\n    // reactivate all the plugins\n    std::vector<boost::shared_ptr<Layer> >::iterator plugin = layered_costmap_->getPlugins()->begin();\n    for ( ; plugin != layered_costmap_->getPlugins()->end(); plugin++) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n\n  // wait for costmap to be initialized\n  while (!initialized_ && ros::ok()) {\n    ros::Duration(0.1).sleep();\n  }\n\n  // wait for the map update thread to become active\n  while (!layered_costmap_->isCurrent() && ros::ok()) {\n    ros::Duration(0.1).sleep();\n  }\n}", "CodeBleu_score": 60.69468481009578}, {"code": "void Costmap2DROS::start(){\n\t  std::vector<boost::shared_ptr<Layer> >::iterator plugin;\n  for (plugin = plugins_->begin(); plugin != plugins_->end(); ++plugin) {\n    if ((*plugin)->isStopped()) {\n      (*plugin)->activate();\n    }\n  }\n  stopped_ = false;\n  stop_updates_ = false;\n  while (!ros::ok() && !initialized_ && !map_update_thread_->isActive()) {\n    ros::Duration(0.1).sleep();\n  }\n}", "CodeBleu_score": 50.65617862268}, {"code": "void Costmap2DROS::start(){\n\t  // TODO: this should be done in a more elegant way\n  // but it's not clear what the best way is\n  // re-activate plugins\n  std::vector<boost::shared_ptr<Layer> >& plugins(*(layered_costmap_->getPlugins()));\n  for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins.begin(); plugin != plugins.end(); ++plugin) {\n    (*plugin)->activate();\n  }\n  // re-subscribe to topics\n  if (stopped_) {\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins.begin(); plugin != plugins.end(); ++plugin) {\n      (*plugin)->subscribe();\n    }\n    stopped_ = false;\n  }\n  // wait for costmap to be initialized\n  while (!initialized_) {\n    usleep(100000);\n  }\n  // wait for map update thread to be active\n  while (!layered_costmap_->isCurrent()) {\n    usleep(100000);\n  }\n}", "CodeBleu_score": 59.624500447817816}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == 0) {\n    observation_list_.erase(observation_list_.begin() + 1, observation_list_.end());\n  } else {\n    ros::Time now = ros::Time::now();\n    std::list<Observation>::iterator iter = observation_list_.begin();\n    while (iter != observation_list_.end()) {\n      if (now - iter->header.stamp > observation_keep_time_) {\n        iter = observation_list_.erase(iter);\n      } else {\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 45.46325398425726}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0)) {\n    observation_list_.erase(observation_list_.begin() + 1, observation_list_.end());\n  } else {\n    ros::Time now = ros::Time::now();\n    ros::Time cutoff_time = now - observation_keep_time_;\n    while (observation_list_.size() > 1 && observation_list_.front().header.stamp < cutoff_time) {\n      observation_list_.erase(observation_list_.begin());\n    }\n  }\n}", "CodeBleu_score": 41.47873691203954}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    observation_list_.erase(observation_list_.begin() + 1, observation_list_.end());\n  } else {\n    ros::Time now = ros::Time::now();\n    while (!observation_list_.empty() &&\n           (now - observation_list_.front().header.stamp) > observation_keep_time_) {\n      observation_list_.pop_front();\n    }\n  }\n}", "CodeBleu_score": 38.895084169071545}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Check if the path is empty or if the start and end indices are out of bounds\n  if (path.empty() || start_index < 0 || start_index >= path.size() || end_index < 0 || end_index >= path.size()) {\n    return;\n  }\n\n  // Calculate the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end yaw angles\n  double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Compute the incremental change in angle\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = start_yaw + increment * (i - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 69.49694794562198}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Get the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end angles\n  double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Calculate the incremental change in angle\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double yaw = start_yaw + (i - start_index) * increment;\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 70.88862994766028}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Calculate the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end yaw angles\n  double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Compute the incremental change in angle\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double yaw = start_yaw + increment * (i - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 72.73405683016037}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    ROS_INFO(\"makePlanService\");\n    geometry_msgs::PoseStamped start = req.start;\n    geometry_msgs::PoseStamped goal = req.goal;\n    start.header.frame_id = \"map\";\n    goal.header.frame_id = \"map\";\n    std::vector<geometry_msgs::PoseStamped> plan;\n    bool success = makePlan(start, goal, plan);\n    if (success) {\n        resp.plan = plan;\n    }\n    return true;\n}", "CodeBleu_score": 51.969096793503624}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    std::vector<geometry_msgs::PoseStamped> plan;\n    bool success = makePlan(req.start, req.goal, plan);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.poses.clear();\n    if (success) {\n        resp.plan.header.stamp = ros::Time::now();\n        resp.plan.header.frame_id = \"map\";\n        for (unsigned int i = 0; i < plan.size(); i++) {\n            resp.plan.poses.push_back(plan[i]);\n        }\n    }\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 65.11356452202823}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  std::vector<geometry_msgs::PoseStamped> plan;\n  bool success = makePlan(req.start, req.goal, plan);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan = plan;\n  resp.success = success;\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 72.03028359457674}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 64.72319019104005}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 69.4833654683534}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 64.72319019104005}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  // Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    ROS_WARN(\"worldToMap: wx, wy (%f, %f) is off the map\", wx, wy);\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n    ROS_WARN(\"worldToMap: wx, wy (%f, %f) is off the map\", wx, wy);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 48.44809710906127}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY())\n    return false;\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n    return true;\n\n  return false;\n}", "CodeBleu_score": 53.10293656183514}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY())\n    return false;\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n    return true;\n\n  return false;\n}", "CodeBleu_score": 53.10293656183514}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  // Check if the planner is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // Create a Path message and set its header\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Copy the poses from the input path to the Path message\n  gui_path.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // Publish the Path message\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 92.14460589829098}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  // make sure that the planner is initialized\n  if (!initialized_) {\n    ROS_ERROR(\n        \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 97.69909265969906}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  // Check if the planner is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // Create a Path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Copy the poses from the input path\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // Publish the Path message\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.3355739336173}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(ROS_NAME, \"Wrapping the received Pose -> MoveBaseAction\");\n\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 71.83666220509399}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received new goal\");\n\n  // create the action message and fill in the basic desired information\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n  action_goal.target_pose.header.stamp = ros::Time::now();\n\n  // publish the goal to the action server\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 58.11714758617062}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received new goal\");\n\n  // we'll create a new action goal to wrap our goal\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n\n  // publish the action goal\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.91834724444351}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance() > sq_limit_distance_) {\n    ROS_INFO(\"Moving far enough to remove speed limit\");\n    remove_limit_thread_->join();\n    delete remove_limit_thread_;\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 54.4143940272521}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  double sq_distance = getSqDistance();\n  if (sq_distance > sq_limit_distance_) {\n    ROS_INFO(\"Moved far enough, removing speed limit\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 84.80865704648312}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Distance check passed. Removing speed limit.\");\n    remove_limit_thread_->join();\n    delete remove_limit_thread_;\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 49.951402860934934}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current pose of the robot\n  geometry_msgs::PoseStamped current_pose;\n  if (!costmap_->getRobotPose(current_pose)) {\n    ROS_ERROR(\"Could not get current pose of the robot\");\n    return;\n  }\n\n  // Generate a path from the current pose to the goal pose\n  nav_msgs::Path path;\n  if (!makePlan(current_pose.pose.position, goal->pose.position, path)) {\n    ROS_ERROR(\"Could not generate path from current pose to goal pose\");\n    return;\n  }\n\n  // Publish the path\n  path_pub_.publish(path);\n}", "CodeBleu_score": 47.02830828965233}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    geometry_msgs::PoseStamped global_pose;\n    costmap_->getRobotPose(global_pose);\n\n    // Convert the goal pose to a PoseStamped message\n    geometry_msgs::PoseStamped goal_pose;\n    goal_pose.header.frame_id = \"map\";\n    goal_pose.header.stamp = ros::Time::now();\n    goal_pose.pose = goal->pose;\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> plan;\n    makePlan(global_pose, goal_pose, plan);\n\n    // Publish the path as a Path message\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = \"map\";\n    path_msg.header.stamp = ros::Time::now();\n    path_msg.poses = plan;\n    path_pub_.publish(path_msg);\n}", "CodeBleu_score": 48.36847809183687}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Retrieve the current global pose of the robot\n    geometry_msgs::PoseStamped global_pose;\n    if (!costmap_->getRobotPose(global_pose)) {\n        ROS_ERROR(\"Could not get robot pose\");\n        return;\n    }\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> plan;\n    if (!makePlan(global_pose, *goal, plan)) {\n        ROS_WARN(\"Could not find a path to goal\");\n        return;\n    }\n\n    // Publish the path as a Path message\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = global_pose.header.frame_id;\n    path_msg.header.stamp = ros::Time::now();\n    path_msg.poses = plan;\n    path_pub_.publish(path_msg);\n}", "CodeBleu_score": 51.35938120602943}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t  mavros_msgs::ParamSet param_set_srv;\n  param_set_srv.request.param_id = param_set.param_id;\n  param_set_srv.request.value.integer = param_set.value.integer;\n  param_set_srv.request.value.real = param_set.value.real;\n  param_set_srv.request.value.str = param_set.value.str;\n\n  if (this->param_set_client_.call(param_set_srv)) {\n    ROS_INFO(\"Gimbal Param Set Request sent\");\n  } else {\n    ROS_ERROR(\"Failed to call param set service\");\n  }\n}", "CodeBleu_score": 54.418727460391914}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create a ParamSet service request\n    mavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.integer = param_set.value.integer;\n\n    // Call the param_set_client_ to send the request\n    if (this->param_set_client_.call(param_set_srv)) {\n        ROS_INFO(\"Gimbal parameter set: %s = %d\", param_set.param_id.c_str(), param_set.value.integer);\n    } else {\n        ROS_ERROR(\"Failed to set gimbal parameter: %s\", param_set.param_id.c_str());\n    }\n}", "CodeBleu_score": 54.35312460061197}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t  param_set_client_.request.param_id = param_set.param_id;\n  param_set_client_.request.value = param_set.value;\n  param_set_client_.call(param_set_client_.request, param_set_client_.response);\n}", "CodeBleu_score": 51.868616698777956}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->simulation_mode_) {\n        if (this->swarm_control_simulation_.find(uav_cmd.uavID) != this->swarm_control_simulation_.end()) {\n            this->swarm_control_simulation_.find(uav_cmd.uavID)->second->uavCmdPub.publish(uav_cmd);\n        }\n    } else {\n        this->uav_basic_->uavCmdPub.publish(uav_cmd);\n    }\n}", "CodeBleu_score": 34.07155604851499}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->simulation_mode_) {\n        std::map<int, UAVBasic*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.id);\n        if (it != this->swarm_control_simulation_.end()) {\n            this->uav_basic_->uavCmdPub(uav_cmd);\n        }\n    } else {\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    }\n}", "CodeBleu_score": 49.25639795826244}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (simulation_mode_) {\n    // Find the corresponding UAV by ID from swarm_control_simulation_\n    std::map<int, UAVBasic*>::iterator it = swarm_control_simulation_.find(\n        uav_cmd.uav_id);\n    if (it != swarm_control_simulation_.end()) {\n      // Publish the command to the matching UAV\n      it->second->uavCmdPub(uav_cmd);\n    }\n  } else {\n    // Publish the command to a single UAV using uav_basic_\n    uav_basic_->uavCmdPub(uav_cmd);\n  }\n}", "CodeBleu_score": 39.650170840090766}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode) {\n        createMode();\n    } else {\n        deleteMode();\n    }\n\n    if (mode_selection.mode == REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.mode == EXITNX) {\n        system(\"exit\");\n    }\n}", "CodeBleu_score": 38.03602026704722}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode) {\n        if (mode_selection.mode == REBOOTNX) {\n            system(\"reboot\");\n        } else if (mode_selection.mode == EXITNX) {\n            system(\"exit\");\n        } else {\n            if (mode_selection.mode == CREATE) {\n                createMode();\n            } else {\n                deleteMode();\n            }\n        }\n    }\n}", "CodeBleu_score": 46.681919187879686}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.mode == \"REBOOTNX\") {\n        system(\"reboot\");\n    } else if (mode_selection.mode == \"EXITNX\") {\n        system(\"exit\");\n    } else if (mode_selection.mode == \"CREATE\") {\n        createMode(mode_selection);\n    } else if (mode_selection.mode == \"DELETE\") {\n        deleteMode(mode_selection);\n    }\n}", "CodeBleu_score": 63.87722688203409}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_status == true) {\n        heartbeat_count = 0;\n        heartbeat_status = false;\n    } else {\n        heartbeat_count++;\n        if (heartbeat_count >= HEARTBEAT_COUNT_THRESHOLD) {\n            ROS_ERROR(\"Heartbeat lost. Disconnecting from the vehicle.\");\n            disconnect_flag = true;\n            if (vehicle_type == \"swarm\") {\n                triggerSwarmControl();\n            } else if (vehicle_type == \"uav\") {\n                triggerUAV();\n            } else if (vehicle_type == \"ugv\") {\n                triggerUGV();\n            }\n        }\n    }\n}", "CodeBleu_score": 39.7904685777673}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    // Check if the heartbeat count has been unchanged for a certain number of attempts\n    if (heartbeat_count_ == heartbeat_attempts_) {\n        // Print an error message and trigger appropriate actions based on the type of vehicle\n        if (vehicle_type_ == \"swarm\") {\n            ROS_ERROR(\"Swarm heartbeat lost. Triggering swarm control.\");\n            triggerSwarmControl();\n        } else if (vehicle_type_ == \"uav\") {\n            ROS_ERROR(\"UAV heartbeat lost. Triggering UAV control.\");\n            triggerUAV();\n        } else if (vehicle_type_ == \"ugv\") {\n            ROS_ERROR(\"UGV heartbeat lost. Triggering UGV control.\");\n            triggerUGV();\n        }\n        // Set the disconnect flag to true\n        disconnect_flag_ = true;\n    } else {\n        // Increment the heartbeat count\n        heartbeat_count_++;\n    }\n}", "CodeBleu_score": 35.48159865175388}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  if (heartbeat_count_ == HEARTBEAT_MAX_ATTEMPTS) {\n    if (vehicle_type_ == VehicleType::SWARM) {\n      ROS_ERROR(\"Swarm heartbeat lost. Triggering swarm control.\");\n      triggerSwarmControl();\n    } else if (vehicle_type_ == VehicleType::UAV) {\n      ROS_ERROR(\"UAV heartbeat lost. Triggering UAV control.\");\n      triggerUAV();\n    } else if (vehicle_type_ == VehicleType::UGV) {\n      ROS_ERROR(\"UGV heartbeat lost. Triggering UGV control.\");\n      triggerUGV();\n    }\n    heartbeat_count_ = 0;\n  }\n}", "CodeBleu_score": 32.317513000557504}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    std::vector<Bspline> bsplines;\n    for (int i = 0; i < msg->traj.size(); i++) {\n        Bspline bspline;\n        bspline.id = msg->traj[i].id;\n        bspline.start_time = msg->traj[i].start_time.toSec();\n        bspline.end_time = msg->traj[i].end_time.toSec();\n        bspline.knots.resize(msg->traj[i].knots.size());\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots[j] = msg->traj[i].knots[j];\n        }\n        bspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts[j].x = msg->traj[i].pos_pts[j].x;\n            bspline.pos_pts[j].y = msg->traj[i].pos_pts[j].y;\n            bspline.pos_pts[j].z = msg->traj[i].pos_pts[j].z;\n        }\n        bspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n        }\n        bsplines.push_back(bspline);\n    }\n    this->communication->encodeMsg(bsplines);\n    this->communication->sendMsgByTcp();\n}", "CodeBleu_score": 72.30317393064338}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree compression technique\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression(0.01); // Adjust the resolution as needed\n    octree_compression.setInputCloud(cloud);\n    octree_compression.switchBuffers();\n\n    // Get the compressed data as a vector of bytes\n    std::vector<uint8_t> compressed_data;\n    octree_compression.getCompressedData(compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.size();\n    compressed_msg.fields.resize(1);\n    compressed_msg.fields[0].name = \"x\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;\n    compressed_msg.fields[0].count = 1;\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = 4;\n    compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n    compressed_msg.data.resize(compressed_msg.row_step);\n    std::memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_msg.data.size());\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    // Return the compressed PointCloud2 message\n    return compressed_msg;\n}", "CodeBleu_score": 48.53872796543768}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 86.38256457558022}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 86.38256457558022}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            return;\n        }\n    }\n}", "CodeBleu_score": 87.75243349850835}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    MultiUGVState multi_ugv_state;\n    int ugv_count = 0;\n    for (std::vector<UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n        UGVState ugv_state;\n        ugv_state.id = it->id;\n        ugv_state.battery = it->battery;\n        ugv_state.position = it->position;\n        ugv_state.velocity = it->velocity;\n        ugv_state.attitude = it->attitude;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n        ugv_count++;\n    }\n    multi_ugv_state.ugv_count = ugv_count;\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 40.526875877823066}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n    for (int i = 0; i < q.cols(); i++) {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(q.col(i), cps_.times[i]);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        if (dist < clearance_) {\n            double dist_err = dist - clearance_;\n            double dist_err_sq = dist_err * dist_err;\n            double dist_err_cu = dist_err_sq * dist_err;\n            double dist_err_sq_cu = dist_err_sq * dist_err_sq;\n            double dist_err_cu_cu = dist_err_cu * dist_err_cu;\n            cost += dist_err_cu;\n            gradient.col(i) = (cps_.points.col(i) - obj_prid).normalized() * (3 * dist_err_sq + 2 * dist_err_cu_cu);\n        }\n    }\n}", "CodeBleu_score": 50.08274209718474}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0;\n  gradient.setZero();\n  double a2 = 0.001;\n  double b2 = 0.001;\n  for (int i = 2; i < ref_pts_.size(); i++) {\n    Eigen::Vector3d v = (ref_pts_[i] - ref_pts_[i - 2]) / (2 * dt_);\n    Eigen::Vector3d x = (q.col(i) - q.col(i - 2)) / (2 * dt_);\n    Eigen::Vector3d xcrossv = x.cross(v);\n    double xdotv = x.dot(v);\n    cost += a2 * xdotv * xdotv + b2 * xcrossv.squaredNorm();\n    Eigen::MatrixXd col_gradient(3, 1);\n    col_gradient.row(0) = 2 * a2 * xdotv * x.transpose() + 2 * b2 * xcrossv.transpose() * v;\n    col_gradient.row(1) = 2 * a2 * xdotv * q.row(1).transpose() + 2 * b2 * xcrossv.transpose() * q.row(1);\n    col_gradient.row(2) = 2 * a2 * xdotv * q.row(2).transpose() + 2 * b2 * xcrossv.transpose() * q.row(2);\n    gradient.col(i) = col_gradient;\n  }\n}", "CodeBleu_score": 47.92440974747157}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n\n    for (int i = 2; i < q.rows(); i++) {\n        Eigen::Vector3d x = q.row(i) - q.row(i - 1);\n        Eigen::Vector3d v = (q.row(i) - q.row(i - 2)) / 2.0;\n\n        Eigen::Vector3d xcrossv = x.cross(v);\n        double xdotv = x.dot(v);\n\n        double a2 = 1.0 / (x.norm() * x.norm());\n        double b2 = 1.0 / (v.norm() * v.norm());\n\n        cost += a2 * xdotv * xdotv + b2 * xcrossv.norm() * xcrossv.norm();\n\n        Eigen::Vector3d grad_xdotv = 2.0 * a2 * xdotv * v;\n        Eigen::Vector3d grad_xcrossv = 2.0 * b2 * xcrossv.norm() * xcrossv;\n\n        gradient.row(i - 1) += grad_xdotv;\n        gradient.row(i) -= grad_xdotv;\n        gradient.row(i - 2) += grad_xcrossv;\n        gradient.row(i) -= grad_xcrossv;\n    }\n}", "CodeBleu_score": 45.31758826313186}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Initialize cost and gradient to zero\n  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  // Iterate through control points\n  for (int i = 2; i < q.rows() - 2; i++) {\n    // Compute reference points and velocity vectors\n    Eigen::Vector3d ref_pts_[3];\n    Eigen::Vector3d v;\n    for (int j = 0; j < 3; j++) {\n      ref_pts_[j] = ref_pts[i + j - 1];\n      v[j] = (q(i + j, j) - q(i + j - 2, j)) / (q(i + j, 0) - q(i + j - 2, 0));\n    }\n\n    // Compute positional error and its gradient\n    Eigen::Vector3d x = q.row(i).head(3).transpose() - ref_pts_[1];\n    Eigen::Matrix3d xcrossv = x.cross(v).asDiagonal();\n    Eigen::Matrix3d xcrossv_norm = xcrossv / (a2 * x.norm() + b2 * v.norm());\n\n    // Update cost and gradient\n    cost += x.dot(x);\n    gradient.row(i) += 2 * x.transpose();\n    gradient.block(i, 0, 1, 3) += 2 * xcrossv_norm * v.transpose();\n    gradient.block(i, 3, 1, 3) -= 2 * xcrossv_norm * v.transpose();\n  }\n}", "CodeBleu_score": 38.65704224747996}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  UniformBspline jerk_traj = getDerivative().getDerivative();\n  Eigen::VectorXd knot = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n  double jerk = 0.0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += pow(ctrl_pts(j, i), 2) * (knot(i + 1) - knot(i));\n    }\n  }\n  return jerk;\n}", "CodeBleu_score": 67.65726140837528}, {"code": "double UniformBspline::getJerk(){\n\t    /* calculate the third derivative */\n    UniformBspline jerk_traj = getDerivative().getDerivative();\n\n    /* get knot times and control points */\n    Eigen::VectorXd knot = jerk_traj.getKnot();\n    Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n    /* iterate through control points and dimensions */\n    double jerk = 0.0;\n    for (int i = 0; i < ctrl_pts.rows(); i++) {\n        for (int j = 0; j < ctrl_pts.cols(); j++) {\n            /* calculate the jerk */\n            jerk += ctrl_pts(i, j) * ctrl_pts(i, j) * (knot(i + 1) - knot(i));\n        }\n    }\n\n    return jerk;\n}", "CodeBleu_score": 69.98689258780098}, {"code": "double UniformBspline::getJerk(){\n\t    UniformBspline jerk_traj = getDerivative().getDerivative();\n    Eigen::VectorXd knot = jerk_traj.getKnot();\n    Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n    double jerk = 0;\n\n    for (int i = 0; i < ctrl_pts.cols(); i++) {\n        for (int j = 0; j < ctrl_pts.rows(); j++) {\n            jerk += pow(ctrl_pts(j, i), 2) * (knot(i + 1) - knot(i));\n        }\n    }\n\n    return jerk;\n}", "CodeBleu_score": 66.53871260642116}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1.0;\n    return pos;\n}", "CodeBleu_score": 50.05512292553293}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t  Eigen::Vector4d pos;\n  pos[0] = (u - cx_) * depth / fx_;\n  pos[1] = (v - cy_) * depth / fy_;\n  pos[2] = depth;\n  pos[3] = 1.0;\n  return pos;\n}", "CodeBleu_score": 64.31966458764637}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) / fx_ * depth;\n    pos[1] = (v - cy_) / fy_ * depth;\n    pos[2] = depth;\n    pos[3] = 1.0;\n    return pos;\n}", "CodeBleu_score": 55.98942652447525}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(1)));\n    } catch (std::exception& e) {\n        ROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n    }\n}", "CodeBleu_score": 42.62494850504764}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(5)));\n    } catch (std::exception& e) {\n        ROS_ERROR_STREAM(\"Exception caught: \" << e.what());\n    }\n}", "CodeBleu_score": 41.92987944404681}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(3)));\n    } catch (std::exception& e) {\n        ROS_ERROR(\"Exception: %s\", e.what());\n    }\n}", "CodeBleu_score": 41.26311864851262}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Calculate true pose of drone in camera frame\n    Eigen::Vector3d true_pose = cam_model_.pixelToCamera(true_pixel, 1.0);\n\n    // Check for drone presence\n    if (drone_pose_err_pub_[drone_id].getNumSubscribers() > 0) {\n        // Compute pose error between camera and world coordinates\n        Eigen::Vector3d pose_error = true_pose - drone_pose_[drone_id];\n\n        // Update debug result\n        debug_result_[drone_id].detected = true;\n        debug_result_[drone_id].pose_error = pose_error;\n\n        // Publish pose error\n        pose_error_msg_[drone_id].header.stamp = ros::Time::now();\n        pose_error_msg_[drone_id].pose_error = pose_error;\n        pose_error_pub_[drone_id].publish(pose_error_msg_[drone_id]);\n    } else {\n        // Update debug result to indicate failure\n        debug_result_[drone_id].detected = false;\n    }\n}", "CodeBleu_score": 41.639393986329935}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Get the camera pose\n    Eigen::Matrix4f camera_pose = camera_pose_[drone_id];\n\n    // Calculate the true pose of the drone in the camera frame\n    Eigen::Matrix4f true_pose = camera_pose * drone_pose_[drone_id];\n\n    // Check if the drone is present in the image\n    bool drone_present = checkDrone(true_pixel, true_pose);\n\n    // If the drone is present, calculate the pose error\n    if (drone_present) {\n        Eigen::Matrix4f camera_to_world = camera_pose.inverse();\n        Eigen::Matrix4f true_to_world = camera_to_world * true_pose;\n        Eigen::Matrix4f camera_to_true = true_to_world.inverse();\n        Eigen::Matrix4f pose_error = camera_to_true * camera_to_world;\n\n        // Update the debug result\n        debug_result_[drone_id].drone_present = true;\n        debug_result_[drone_id].pose_error = pose_error;\n\n        // Publish the pose error\n        drone_pose_err_pub_[drone_id].publish(pose_error);\n    } else {\n        // Update the debug result\n        debug_result_[drone_id].drone_present = false;\n    }\n}", "CodeBleu_score": 41.73999836298582}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = cam_model_.pixelToCamera(true_pixel, 1);\n    // Check for the presence of the drone in the camera frame\n    if (true_pose(2) > 0) {\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error = true_pose - cam_pose_;\n        // Update the debug result\n        debug_result_.found = true;\n        debug_result_.drone_id = drone_id;\n        debug_result_.pose_error = pose_error;\n        // Publish the pose error\n        drone_pose_err_pub_[drone_id].publish(pose_error);\n    } else {\n        // Update the debug result to indicate failure\n        debug_result_.found = false;\n    }\n}", "CodeBleu_score": 36.62599590155282}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t  vector<GridNodePtr> path;\n  path.push_back(current);\n  while (current->getParent() != nullptr) {\n    current = current->getParent();\n    path.push_back(current);\n  }\n  return path;\n}", "CodeBleu_score": 74.54004563787126}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 93.99751622940664}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->parent != nullptr) {\n        path.push_back(current->parent);\n        current = current->parent;\n    }\n    path.push_back(startNode);\n    return path;\n}", "CodeBleu_score": 73.23737612477952}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert start point to grid index\n  start_idx = Coord2Index(start_pt);\n  // Convert end point to grid index\n  end_idx = Coord2Index(end_pt);\n\n  // Check if start point is inside an obstacle\n  if (checkOccupancy(start_idx)) {\n    // Iteratively adjust start point until it is no longer inside an obstacle\n    while (checkOccupancy(start_idx)) {\n      // Move start point away from end point\n      start_idx += (end_idx - start_idx).normalized();\n      // Check if start point is still inside an obstacle\n      if (checkOccupancy(start_idx)) {\n        // If start point is still inside an obstacle, adjust it further\n        start_idx += (end_idx - start_idx).normalized();\n      }\n    }\n  }\n\n  // Check if end point is inside an obstacle\n  if (checkOccupancy(end_idx)) {\n    // Iteratively adjust end point until it is no longer inside an obstacle\n    while (checkOccupancy(end_idx)) {\n      // Move end point away from start point\n      end_idx += (start_idx - end_idx).normalized();\n      // Check if end point is still inside an obstacle\n      if (checkOccupancy(end_idx)) {\n        // If end point is still inside an obstacle, adjust it further\n        end_idx += (start_idx - end_idx).normalized();\n      }\n    }\n  }\n\n  // Check if start point is still inside an obstacle\n  if (checkOccupancy(start_idx)) {\n    // If start point is still inside an obstacle, return false\n    return false;\n  }\n\n  // Check if end point is still inside an obstacle\n  if (checkOccupancy(end_idx)) {\n    // If end point is still inside an obstacle, return false\n    return false;\n  }\n\n  // If both start and end points are not inside obstacles, return true\n  return true;\n}", "CodeBleu_score": 41.13341377537765}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert start point to index\n  Vector3i start_idx_temp;\n  if (!ConvertToIndex(start_pt, start_idx_temp)) {\n    return false;\n  }\n  // Convert end point to index\n  Vector3i end_idx_temp;\n  if (!ConvertToIndex(end_pt, end_idx_temp)) {\n    return false;\n  }\n  // Adjust start point if it is inside an obstacle\n  if (IsOccupied(start_idx_temp)) {\n    Vector3d start_pt_temp = start_pt;\n    while (IsOccupied(start_idx_temp)) {\n      start_pt_temp += (start_pt - start_pt_temp).normalized() * resolution_;\n      if (!ConvertToIndex(start_pt_temp, start_idx_temp)) {\n        return false;\n      }\n    }\n  }\n  // Adjust end point if it is inside an obstacle\n  if (IsOccupied(end_idx_temp)) {\n    Vector3d end_pt_temp = end_pt;\n    while (IsOccupied(end_idx_temp)) {\n      end_pt_temp += (end_pt - end_pt_temp).normalized() * resolution_;\n      if (!ConvertToIndex(end_pt_temp, end_idx_temp)) {\n        return false;\n      }\n    }\n  }\n  // Check if the start and end points are still inside the same obstacle\n  if (IsOccupied(start_idx_temp) && IsOccupied(end_idx_temp)) {\n    return false;\n  }\n  // Set the output indices\n  start_idx = start_idx_temp;\n  end_idx = end_idx_temp;\n  return true;\n}", "CodeBleu_score": 45.982847599283616}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    // Convert the start and end points to indices\n    start_idx = Coord2Index(start_pt);\n    end_idx = Coord2Index(end_pt);\n\n    // If the start point is inside an obstacle, adjust it until it is no longer inside an obstacle\n    if (IsInsideObstacle(start_idx)) {\n        while (IsInsideObstacle(start_idx)) {\n            start_idx += (end_idx - start_idx).normalized();\n        }\n    }\n\n    // If the end point is inside an obstacle, adjust it until it is no longer inside an obstacle\n    if (IsInsideObstacle(end_idx)) {\n        while (IsInsideObstacle(end_idx)) {\n            end_idx -= (end_idx - start_idx).normalized();\n        }\n    }\n\n    // If the start and end points are still inside obstacles, return false\n    if (IsInsideObstacle(start_idx) || IsInsideObstacle(end_idx)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 36.775782759073095}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // 1. convert the position to grid index\n  Eigen::Vector3i min_id, max_id;\n  min_id = coord2gridIndex(min_pos);\n  max_id = coord2gridIndex(max_pos);\n  // 2. reset the corresponding buffer elements\n  for (int x = min_id.x(); x <= max_id.x(); x++) {\n    for (int y = min_id.y(); y <= max_id.y(); y++) {\n      for (int z = min_id.z(); z <= max_id.z(); z++) {\n        Eigen::Vector3i curr_id;\n        curr_id << x, y, z;\n        if (isInflate(curr_id)) {\n          occupancy_buffer_inflate_.at(x, y, z) = 0;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 45.51932277190469}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    Eigen::Vector3d min_pos_inflate = min_pos - inflate_size_;\n    Eigen::Vector3d max_pos_inflate = max_pos + inflate_size_;\n    int min_id_inflate = coordToIndex(min_pos_inflate);\n    int max_id_inflate = coordToIndex(max_pos_inflate);\n\n    for (int id = min_id_inflate; id <= max_id_inflate; id++) {\n        occupancy_buffer_inflate_[id] = 0;\n    }\n}", "CodeBleu_score": 31.114602842351267}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  int min_id[3], max_id[3];\n  double min_pos_buffer[3], max_pos_buffer[3];\n  for (int d = 0; d < 3; d++) {\n    min_id[d] = std::max(\n        0, static_cast<int>((min_pos(d) - origin_pos_(d)) / resolution_));\n    max_id[d] = std::min(\n        static_cast<int>((max_pos(d) - origin_pos_(d)) / resolution_),\n        static_cast<int>(size_ - 1));\n    min_pos_buffer[d] = origin_pos_(d) + min_id[d] * resolution_;\n    max_pos_buffer[d] = origin_pos_(d) + (max_id[d] + 1) * resolution_;\n  }\n  for (int x = min_id[0]; x <= max_id[0]; x++) {\n    for (int y = min_id[1]; y <= max_id[1]; y++) {\n      for (int z = min_id[2]; z <= max_id[2]; z++) {\n        int index = getIndex(x, y, z);\n        occupancy_buffer_inflate_(index) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 38.242350269071714}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    double max_x_trans = (diff.x() > 0) ? std::ceil(diff.x() / map_resolution) : std::floor(diff.x() / map_resolution);\n    double max_y_trans = (diff.y() > 0) ? std::ceil(diff.y() / map_resolution) : std::floor(diff.y() / map_resolution);\n    double max_z_trans = (diff.z() > 0) ? std::ceil(diff.z() / map_resolution) : std::floor(diff.z() / map_resolution);\n\n    double min_x_trans = (diff.x() > 0) ? std::floor(diff.x() / map_resolution) : std::ceil(diff.x() / map_resolution);\n    double min_y_trans = (diff.y() > 0) ? std::floor(diff.y() / map_resolution) : std::ceil(diff.y() / map_resolution);\n    double min_z_trans = (diff.z() > 0) ? std::floor(diff.z() / map_resolution) : std::ceil(diff.z() / map_resolution);\n\n    double x_trans, y_trans, z_trans;\n    if (max_x_trans > 0) {\n        x_trans = max_x_trans * map_resolution;\n    } else {\n        x_trans = min_x_trans * map_resolution;\n    }\n    if (max_y_trans > 0) {\n        y_trans = max_y_trans * map_resolution;\n    } else {\n        y_trans = min_y_trans * map_resolution;\n    }\n    if (max_z_trans > 0) {\n        z_trans = max_z_trans * map_resolution;\n    } else {\n        z_trans = min_z_trans * map_resolution;\n    }\n\n    return Eigen::Vector3d(camera_pt.x() + x_trans, camera_pt.y() + y_trans, camera_pt.z() + z_trans);\n}", "CodeBleu_score": 37.25355467346031}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    // compute the difference vector between the point and the camera position\n    Eigen::Vector3d diff = pt - camera_pt;\n\n    // calculate the maximum and minimum translation coefficients along each axis\n    double max_trans = std::max(std::max(std::abs(diff[0]), std::abs(diff[1])), std::abs(diff[2]));\n    double min_trans = std::min(std::min(std::abs(diff[0]), std::abs(diff[1])), std::abs(diff[2]));\n\n    // iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    double scale = 1.0;\n    if (max_trans > map_size_ / 2.0) {\n        scale = map_size_ / 2.0 / max_trans;\n    } else if (min_trans < -map_size_ / 2.0) {\n        scale = -map_size_ / 2.0 / min_trans;\n    }\n\n    // return the adjusted point near the boundary\n    return camera_pt + diff * scale;\n}", "CodeBleu_score": 42.301359465201394}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // If an update is needed, project the depth image into points and process them with raycasting\n  if (md_.update_needed_) {\n    md_.update_needed_ = false;\n    projectDepthImage();\n    raycastProcess();\n    if (md_.local_map_updated_) {\n      clearAndInflateLocalMap();\n      md_.local_map_updated_ = false;\n    }\n  }\n\n  // Handle timeout errors for odometry or depth data and set relevant flags\n  if ((ros::Time::now() - md_.last_odom_time_).toSec() >\n      md_.odom_timeout_) {\n    ROS_ERROR(\"Odometry timeout. Resetting local map.\");\n    md_.local_map_.reset();\n    md_.local_map_updated_ = true;\n  }\n  if ((ros::Time::now() - md_.last_depth_time_).toSec() >\n      md_.depth_timeout_) {\n    ROS_ERROR(\"Depth image timeout. Resetting local map.\");\n    md_.local_map_.reset();\n    md_.local_map_updated_ = true;\n  }\n}", "CodeBleu_score": 64.13133330946958}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // If an update is needed, project depth image into points and process them with raycasting\n  if (md_.update_needed_) {\n    // Project depth image into points\n    projectDepthImage();\n\n    // Process points with raycasting\n    raycastProcess();\n\n    // If the local map has been updated, clear and inflate the local map\n    if (md_.local_map_updated_) {\n      clearAndInflateLocalMap();\n      md_.local_map_updated_ = false;\n    }\n\n    // If the local map has been cleared, set the local map clear flag\n    if (md_.local_map_cleared_) {\n      md_.local_map_cleared_ = false;\n    }\n  }\n\n  // Handle timeout errors for odometry or depth data and set relevant flags\n  if (md_.timeout_error_) {\n    md_.timeout_error_ = false;\n    md_.update_needed_ = true;\n    md_.local_map_updated_ = true;\n  }\n}", "CodeBleu_score": 47.04381019428698}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if update is needed\n  if (md_.update_needed_) {\n    // Project depth image into points\n    projectDepthImage();\n\n    // Process points with raycasting\n    raycastProcess();\n\n    // If local map has been updated, clear and inflate local map\n    if (md_.local_map_updated_) {\n      clearAndInflateLocalMap();\n    }\n\n    // Reset update needed flag\n    md_.update_needed_ = false;\n  }\n\n  // Handle timeout errors for odometry or depth data\n  if (md_.odom_timeout_ || md_.depth_timeout_) {\n    // Set relevant flags\n    md_.odom_timeout_ = false;\n    md_.depth_timeout_ = false;\n    md_.update_needed_ = true;\n  }\n}", "CodeBleu_score": 44.0349978324427}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    if (image_fns.size() != gt_fns.size() || image_fns.size() != dt_fns.size()) {\n        cout << \"Error: The number of image files, ground truth files, and detected files must be the same.\" << endl;\n        return 0.f;\n    }\n\n    float fmeasure = 0.f;\n\n    for (unsigned i = 0; i < image_fns.size(); ++i) {\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n        Mat3b img = imread(image_fns[i]);\n\n        if (img.empty()) {\n            cout << \"Error: Failed to load image file: \" << image_fns[i] << endl;\n            continue;\n        }\n\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        fmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n    }\n\n    return fmeasure / float(image_fns.size());\n}", "CodeBleu_score": 53.7528857900493}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    unsigned n = image_fns.size();\n    float sum_fmeasure = 0.f;\n\n    for (unsigned i = 0; i<n; ++i)\n    {\n        Mat3b img;\n        img = imread(image_fns[i]);\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        sum_fmeasure += fmeasure;\n    }\n\n    float avg_fmeasure = sum_fmeasure / float(n);\n    return avg_fmeasure;\n}", "CodeBleu_score": 54.203926846203366}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float fmeasure_sum = 0.f;\n    unsigned n = (unsigned)image_fns.size();\n\n    for (unsigned i = 0; i < n; ++i) {\n        Mat3b img = imread(image_fns[i]);\n        if (img.empty()) {\n            cout << \"Error opening: \" << image_fns[i] << endl;\n            continue;\n        }\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        fmeasure_sum += fmeasure;\n    }\n\n    return fmeasure_sum / float(n);\n}", "CodeBleu_score": 56.29986310409273}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t", "CodeBleu_score": 2.6118173022443996}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a = atan2(y, x);\n    float b = atan2(y, -x);\n    float c = angle_diff_signed(a, foci[0]);\n    float d = angle_diff_signed(b, foci[1]);\n    float e = angle_diff_signed(c, d);\n    return e;\n}", "CodeBleu_score": 30.007775343656373}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a = atan2(y, x);\n    float b = atan2(y, -x);\n    float c = angle_diff_signed(a, foci[0]);\n    float d = angle_diff_signed(b, foci[1]);\n    float e = angle_diff_signed(c, d);\n    return e;\n}", "CodeBleu_score": 30.007775343656373}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    int n = end - start + 1;\n    if (n < 3) {\n        return false;\n    }\n    // Compute the minimum and maximum x and y coordinates of the points in the section\n    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        }\n        if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        }\n        if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n    }\n    // Compute the integral above and below the polygon section\n    double integral_above = 0;\n    double integral_below = 0;\n    for (int i = start; i <= end; i++) {\n        int j = (i + 1) % n;\n        integral_above += (vp1[i].x + vp1[j].x) * (vp1[i].y - vp1[j].y);\n        integral_below += (vp1[i].x + vp1[j].x) * (vp1[i].y - vp1[j].y);\n    }\n    integral_above /= 2;\n    integral_below /= 2;\n    // Return true if the integral above is less than the integral below, false otherwise\n    return integral_above < integral_below;\n}", "CodeBleu_score": 42.21123174643494}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t  double min_x = vp1[start].x;\n  double max_x = vp1[start].x;\n  double min_y = vp1[start].y;\n  double max_y = vp1[start].y;\n  for (int i = start; i <= end; i++) {\n    if (vp1[i].x < min_x) min_x = vp1[i].x;\n    if (vp1[i].x > max_x) max_x = vp1[i].x;\n    if (vp1[i].y < min_y) min_y = vp1[i].y;\n    if (vp1[i].y > max_y) max_y = vp1[i].y;\n  }\n  double integral_above = 0;\n  double integral_below = 0;\n  for (int i = start; i <= end; i++) {\n    double x = vp1[i].x;\n    double y = vp1[i].y;\n    if (x >= min_x && x <= max_x && y >= min_y && y <= max_y) {\n      integral_above += vp1[i].z;\n      integral_below += vp1[i].z;\n    }\n  }\n  return integral_above < integral_below;\n}", "CodeBleu_score": 43.44991218038224}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  for (const auto &detection : msg->detections) {\n    if (detection.name == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_regain = 0;\n      num_lost++;\n    }\n    if (num_lost > VISION_THRES) {\n      is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n      is_detected = true;\n    }\n    ellipse_det = detection;\n    std::swap(ellipse_det.sight_angle.start, ellipse_det.sight_angle.end);\n  }\n}", "CodeBleu_score": 61.1859779857878}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  // Process each detection info\n  for (const auto &detection : msg->detections) {\n    if (detection.name == \"T\") {\n      // Increment num_regain and reset num_lost\n      num_regain++;\n      num_lost = 0;\n    } else {\n      // Reset num_regain and increment num_lost\n      num_regain = 0;\n      num_lost++;\n    }\n  }\n\n  // If num_lost exceeds VISION_THRES, set is_detected to false\n  if (num_lost > VISION_THRES) {\n    is_detected = false;\n  }\n\n  // If num_regain exceeds VISION_THRES, set is_detected to true\n  if (num_regain > VISION_THRES) {\n    is_detected = true;\n  }\n\n  // Swap the sight_angle values\n  for (auto &detection : msg->detections) {\n    std::swap(detection.sight_angle.x, detection.sight_angle.y);\n  }\n}", "CodeBleu_score": 57.30666037290008}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  // Iterate through each detection info\n  for (const auto &det_info : msg->detection_infos) {\n    // Update the ellipse_det variable\n    ellipse_det.name = det_info.name;\n    ellipse_det.pose = det_info.pose;\n    ellipse_det.size = det_info.size;\n    ellipse_det.confidence = det_info.confidence;\n    ellipse_det.velocity = det_info.velocity;\n    ellipse_det.is_detected = det_info.is_detected;\n    ellipse_det.sight_angle = det_info.sight_angle;\n\n    // Check if the detected object is named \"T\"\n    if (ellipse_det.name == \"T\") {\n      // Increment the num_regain counter\n      num_regain++;\n      // Reset num_lost\n      num_lost = 0;\n    } else {\n      // Reset num_regain\n      num_regain = 0;\n      // Increment num_lost\n      num_lost++;\n    }\n\n    // Check if num_lost exceeds VISION_THRES\n    if (num_lost > VISION_THRES) {\n      // Set is_detected to false\n      ellipse_det.is_detected = false;\n    }\n\n    // Check if num_regain exceeds VISION_THRES\n    if (num_regain > VISION_THRES) {\n      // Set is_detected to true\n      ellipse_det.is_detected = true;\n    }\n\n    // Swap the sight_angle values\n    std::swap(ellipse_det.sight_angle.horizontal, ellipse_det.sight_angle.vertical);\n  }\n}", "CodeBleu_score": 58.62400938677603}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t  if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 47.255358937534496}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 45.68302491297701}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    double x = cur_pos(0);\n    double y = cur_pos(1);\n    double z = cur_pos(2);\n    // check if the position is within the map\n    if (Occupy_map_ptr->is_within_map(x, y, z)) {\n        // check if the position is occupied\n        if (Occupy_map_ptr->is_occupied(x, y, z)) {\n            return false;\n        }\n        // check if the position is within the safety distance\n        if (Occupy_map_ptr->is_within_safe_distance(x, y, z, safe_distance)) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 42.152131758247634}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node->parent_ != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent_;\n    }\n    path_nodes_.push_back(current_node);\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 65.57108588383753}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node->parent != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    path_nodes_.push_back(current_node);\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 65.84051778789939}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr curr_node = end_node;\n    while (curr_node != nullptr) {\n        path_nodes_.push_back(curr_node);\n        curr_node = curr_node->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.21174893761912}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  state_nei[id].x = odom->pose.pose.position.x;\n  state_nei[id].y = odom->pose.pose.position.y;\n  state_nei[id].z = odom->pose.pose.position.z;\n  state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n  if (sim_mode) {\n    if ((start_pos-state_nei[id]).norm() > 5.0) {\n      get_nei_state = false;\n    } else {\n      get_nei_state = true;\n    }\n  } else {\n    get_nei_state = true;\n  }\n}", "CodeBleu_score": 47.045501967134385}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  // Update the state of the neighboring UGV\n  state_nei[id].pos = Eigen::Vector3d(odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n  state_nei[id].height = odom->pose.pose.position.z;\n\n  // Check if the UGV is too far from the start position in simulation mode\n  if (simulation_mode) {\n    if ((start_pos-state_nei[id].pos).norm() > 5.0) {\n      get_nei_state = false;\n    } else {\n      get_nei_state = true;\n    }\n  }\n}", "CodeBleu_score": 38.31385239529522}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    // Update state of neighboring UGV based on odometry data\n    state_nei[id].pos = Eigen::Vector3d(odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n    state_nei[id].height = odom->pose.pose.position.z;\n\n    // Check if distance from start position exceeds 5 meters\n    if (simulation_mode) {\n        if ((start_pos-state_nei[id].pos).norm() > 5) {\n            get_nei_state = false;\n        } else {\n            get_nei_state = true;\n        }\n    } else {\n        get_nei_state = true;\n    }\n}", "CodeBleu_score": 46.27713655690023}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  update_count++;\n  if (update_count % 5 == 0) {\n    update_count = 0;\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n  }\n}", "CodeBleu_score": 58.9285159249984}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready)\n    return;\n\n  sensor_ready = true;\n  update_count++;\n\n  if (update_count % 5 == 0) {\n    update_count = 0;\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n  }\n}", "CodeBleu_score": 49.066077939372136}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!sensor_ready)\n    return;\n\n  if (update_counter % 5 == 0) {\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n  }\n  update_counter++;\n}", "CodeBleu_score": 36.57036740020197}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl) {\n    get_gpcl = false;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud (new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*global_point, *global_cloud);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud_inflate (new pcl::PointCloud<pcl::PointXYZ>);\n    inflate_point_cloud(global_cloud, global_cloud_inflate);\n    global_map.insertPointCloud(*global_cloud_inflate, Eigen::Affine3f::Identity());\n  }\n}", "CodeBleu_score": 47.71349784924905}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_map_pcl);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr global_map_pcl_inf(new pcl::PointCloud<pcl::PointXYZ>);\n    inflate_point_cloud(global_map_pcl, global_map_pcl_inf);\n    global_map_pcl_inf->header = global_point->header;\n    global_map_pub.publish(global_map_pcl_inf);\n  }\n}", "CodeBleu_score": 52.21924283947875}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_map);\n    inflate_point_cloud(*global_map, *global_map_inflate, 0.05);\n  }\n}", "CodeBleu_score": 50.91690391200841}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  // Convert the laser scan message to a PointCloud2 format\n  sensor_msgs::PointCloud2 laser_scan_cloud;\n  projector_.projectLaser(*local_point, laser_scan_cloud);\n\n  // Convert the PointCloud2 format to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laser_scan_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(laser_scan_cloud, *laser_scan_cloud_pcl);\n\n  // Update the occupancy map using the laser scan data\n  update_map(laser_scan_cloud_pcl);\n\n  // If not in simulation mode, merge the local map with the provided odometry data\n  if (!simulation_mode_) {\n    // Update the map using the odometry information\n    update_map(odom);\n  }\n}", "CodeBleu_score": 53.78919261582521}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  // 1. project the laser scan into a PointCloud2 format\n  sensor_msgs::PointCloud2 local_cloud;\n  projector_.projectLaser(*local_point, local_cloud);\n  // 2. convert the PointCloud2 format to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr local_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(local_cloud, *local_cloud_ptr);\n  // 3. if not in simulation mode, merge the local map with the provided odometry data\n  if (!simulation_) {\n    // 3.1 get the current pose of the robot\n    tf::StampedTransform transform;\n    try {\n      listener_.lookupTransform(map_frame_, odom.header.frame_id, ros::Time(0), transform);\n    } catch (tf::TransformException &ex) {\n      ROS_ERROR(\"%s\", ex.what());\n      return;\n    }\n    // 3.2 convert the pose to a pcl::PointXYZ\n    pcl::PointXYZ current_pose;\n    current_pose.x = transform.getOrigin().x();\n    current_pose.y = transform.getOrigin().y();\n    current_pose.z = transform.getOrigin().z();\n    // 3.3 update the occupancy map\n    pcl::PointCloud<pcl::PointXYZ>::Ptr merged_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::transformPointCloud(*local_cloud_ptr, *merged_cloud_ptr, transform);\n    *local_cloud_ptr += *merged_cloud_ptr;\n    pcl::toROSMsg(*local_cloud_ptr, local_cloud);\n  }\n  // 4. publish the updated occupancy map\n  local_map_pub_.publish(local_cloud);\n}", "CodeBleu_score": 47.38011670709642}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  // publish global point cloud map\n  pcl::toROSMsg(global_pcl_map, global_pcl_pub.msg);\n  global_pcl_pub.msg.header.frame_id = \"world\";\n  global_pcl_pub.msg.header.stamp = ros::Time::now();\n  global_pcl_pub.publish();\n\n  // publish inflated point cloud\n  pcl::toROSMsg(inflate_pcl_map, inflate_pcl_pub.msg);\n  inflate_pcl_pub.msg.header.frame_id = \"world\";\n  inflate_pcl_pub.msg.header.stamp = ros::Time::now();\n  inflate_pcl_pub.publish();\n}", "CodeBleu_score": 38.6948566840061}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  pcl::toROSMsg(global_pcl, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  pcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 44.68497162270963}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  // publish point cloud data\n  pcl::toROSMsg(global_map, global_pcl_pub);\n  global_pcl_pub.header.frame_id = \"world\";\n  global_pcl_pub.header.stamp = ros::Time::now();\n  global_pcl_pub.header.seq++;\n  global_pcl_publisher.publish(global_pcl_pub);\n\n  // publish inflated point cloud data\n  pcl::toROSMsg(inflate_map, inflate_pcl_pub);\n  inflate_pcl_pub.header.frame_id = \"world\";\n  inflate_pcl_pub.header.stamp = ros::Time::now();\n  inflate_pcl_pub.header.seq++;\n  inflate_pcl_publisher.publish(inflate_pcl_pub);\n}", "CodeBleu_score": 45.67028323303969}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (sensor_ready) {\n        Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_odom_ptr);\n    }\n}", "CodeBleu_score": 49.11619203501937}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (sensor_ready) {\n    // Update the occupancy map using the new point cloud data and current UAV odometry\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, Astar_ptr->current_pose);\n  }\n}", "CodeBleu_score": 44.48411034431037}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n  // Get the current time\n  const champ::PhaseGenerator::Time time = rosTimeToChampTime(event.current_real);\n\n  // Get the desired pose\n  const champ::Pose2D pose = body_controller_.poseCommand(time);\n\n  // Calculate the target foot positions\n  champ::Pose2D target_foot_positions[4];\n  for (size_t i = 0; i < 4; i++) {\n    target_foot_positions[i] = base_.legs[i]->pose(time);\n  }\n\n  // Update the body controller\n  body_controller_.update(time, pose);\n\n  // Calculate the target joint positions\n  float target_joints[12];\n  for (size_t i = 0; i < 4; i++) {\n    const champ::Pose2D foot_position = target_foot_positions[i];\n    const champ::Pose2D target_foot_position = body_controller_.targetFootPosition(time, i);\n    const champ::Pose2D foot_error = foot_position - target_foot_position;\n    const champ::Pose2D joint_angles = kinematics_.inverse(foot_error);\n    target_joints[i * 3 + 0] = joint_angles.x;\n    target_joints[i * 3 + 1] = joint_angles.y;\n    target_joints[i * 3 + 2] = joint_angles.theta;\n  }\n\n  // Publish foot contact information\n  bool foot_contacts[4];\n  for (size_t i = 0; i < 4; i++) {\n    foot_contacts[i] = base_.legs[i]->isInContact();\n  }\n  publishFootContacts_(foot_contacts);\n\n  // Publish joint positions\n  publishJoints_(target_joints);\n}", "CodeBleu_score": 51.42466912425376}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Calculate target foot positions\n  champ::PhaseGenerator::Time time = rosTimeToChampTime(event.current_real);\n  champ::PhaseGenerator::Time dt = rosTimeToChampTime(event.current_real - event.last_real);\n  champ::Pose2D pose = body_controller_.poseCommand(time, dt);\n\n  // Compute velocity commands for the legs\n  champ::VelocityCommands velocity_commands = leg_controller_.velocityCommand(time, dt, pose);\n\n  // Compute target joint positions\n  float target_joints[12];\n  for (size_t i = 0; i < 4; i++) {\n    champ::Leg::JointPositions joint_positions = kinematics_.inverse(velocity_commands[i]);\n    for (size_t j = 0; j < 3; j++) {\n      target_joints[3 * i + j] = joint_positions[j];\n    }\n  }\n\n  // Publish foot contact information\n  bool foot_contacts[4];\n  for (size_t i = 0; i < 4; i++) {\n    foot_contacts[i] = base_.legs[i]->contact();\n  }\n  publishFootContacts_(foot_contacts);\n\n  // Publish joint positions\n  publishJoints_(target_joints);\n}", "CodeBleu_score": 51.19860809047228}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_ && !in_gazebo_) {\n    contacts_msg_.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      contacts_msg_.contacts[i].state = foot_contacts[i] ?\n                                        ContactState::CONTACT :\n                                        ContactState::NO_CONTACT;\n      contacts_msg_.contacts[i].gait_phase = base_.legs[i]->gait_phase;\n    }\n    foot_contacts_publisher_.publish(contacts_msg_);\n  }\n}", "CodeBleu_score": 53.8090512662601}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (enable_foot_contact_publishing_ && !is_gazebo_) {\n    ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.contacts.resize(4);\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].contact_state = foot_contacts[i];\n      contacts_msg.contacts[i].gait_phase = base_.legs[i]->gait_phase;\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 67.99537679856063}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publishing_enabled_ && !in_gazebo_) {\n    contacts_msg_.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      contacts_msg_.contacts[i].state = foot_contacts[i];\n      contacts_msg_.contacts[i].phase = base_.legs[i]->gait_phase;\n    }\n    foot_contacts_publisher_.publish(contacts_msg_);\n  }\n}", "CodeBleu_score": 58.42364259391349}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t  // Create a minimal joints message with the first 12 joint positions\n  joints_msg = Joints()\n  joints_msg.joints[0] = joints.joints[0]\n  joints_msg.joints[1] = joints.joints[1]\n  joints_msg.joints[2] = joints.joints[2]\n  joints_msg.joints[3] = joints.joints[3]\n  joints_msg.joints[4] = joints.joints[4]\n  joints_msg.joints[5] = joints.joints[5]\n  joints_msg.joints[6] = joints.joints[6]\n  joints_msg.joints[7] = joints.joints[7]\n  joints_msg.joints[8] = joints.joints[8]\n  joints_msg.joints[9] = joints.joints[9]\n  joints_msg.joints[10] = joints.joints[10]\n  joints_msg.joints[11] = joints.joints[11]\n\n  // Publish the minimal joints message\n  self.joints_pub.publish(joints_msg)\n\n  // Construct a joint trajectory message with the same positions and a specified duration\n  trajectory = JointTrajectory()\n  trajectory.joint_names = joints_msg.joints\n  trajectory.points[0].positions = joints_msg.joints\n  trajectory.points[0].time_from_start = rospy.Duration(1.0)\n\n  // Publish the joint trajectory message\n  self.joint_trajectory_pub.publish(trajectory)\n}", "CodeBleu_score": 33.52795469257279}, {"code": "def joints_cmd_callback(self, joints){\n\t  // Create a minimal joints message with the first 12 joint positions\n  minimal_joints_msg = JointState()\n  minimal_joints_msg.position = joints.position[0:12]\n  self.joints_pub.publish(minimal_joints_msg)\n\n  // Create a trajectory message with the same positions and a specified duration\n  trajectory_msg = JointTrajectory()\n  trajectory_msg.joint_names = joints.name[0:12]\n  trajectory_msg.points[0].positions = joints.position[0:12]\n  trajectory_msg.points[0].time_from_start = rospy.Duration(3.0)\n\n  # Publish the trajectory message\n  self.trajectory_pub.publish(trajectory_msg)\n}", "CodeBleu_score": 39.619971444149286}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message\n    joints_msg = JointState()\n    joints_msg.header = joints.header\n    joints_msg.name = joints.name[0:12]\n    joints_msg.position = joints.position[0:12]\n    joints_msg.velocity = joints.velocity[0:12]\n    joints_msg.effort = joints.effort[0:12]\n    self.joints_pub.publish(joints_msg)\n\n    # Create a joint trajectory message\n    traj = JointTrajectory()\n    traj.header = joints.header\n    traj.joint_names = joints.name[0:12]\n    traj.points = [JointTrajectoryPoint(positions=joints.position[0:12], time_from_start=Duration(secs=2))]\n    self.traj_pub.publish(traj)\n}", "CodeBleu_score": 40.21492516869272}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // Initialize foot contact states to false\n    foot_contact_state_ = {false, false, false, false};\n\n    // For each contact in the message, split the collision string to identify the contact link\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::string collision1 = _msg->contact(i).collision1();\n        std::string collision2 = _msg->contact(i).collision2();\n        // If a contact matches one of the foot links, set the corresponding foot contact state to true\n        if (collision1 == \"left_foot_link\" || collision1 == \"right_foot_link\") {\n            foot_contact_state_[0] = true;\n        } else if (collision1 == \"left_foot_link_2\" || collision1 == \"right_foot_link_2\") {\n            foot_contact_state_[1] = true;\n        } else if (collision1 == \"left_foot_link_3\" || collision1 == \"right_foot_link_3\") {\n            foot_contact_state_[2] = true;\n        } else if (collision1 == \"left_foot_link_4\" || collision1 == \"right_foot_link_4\") {\n            foot_contact_state_[3] = true;\n        }\n    }\n}", "CodeBleu_score": 37.65171140900358}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n  // Initialize foot contact states to false\n  foot_contact_states_.left_foot_contact_ = false;\n  foot_contact_states_.right_foot_contact_ = false;\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n\n    // Split the collision string to identify the contact link\n    std::vector<std::string> collision_names = split(_msg->contact(i).collision1(), '/');\n\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (collision_names[3] == \"left_foot_link\") {\n      foot_contact_states_.left_foot_contact_ = true;\n    } else if (collision_names[3] == \"right_foot_link\") {\n      foot_contact_states_.right_foot_contact_ = true;\n    }\n  }\n}", "CodeBleu_score": 40.52707475140236}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize foot contact states to false\n  foot_contact_states_[0] = false;\n  foot_contact_states_[1] = false;\n  foot_contact_states_[2] = false;\n  foot_contact_states_[3] = false;\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    // Split the collision string to identify the contact link\n    std::vector<std::string> collision_parts;\n    boost::split(collision_parts, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (collision_parts[2] == \"left_sole_link\") {\n      foot_contact_states_[0] = true;\n    } else if (collision_parts[2] == \"right_sole_link\") {\n      foot_contact_states_[1] = true;\n    } else if (collision_parts[2] == \"front_left_sole_link\") {\n      foot_contact_states_[2] = true;\n    } else if (collision_parts[2] == \"front_right_sole_link\") {\n      foot_contact_states_[3] = true;\n    }\n  }\n}", "CodeBleu_score": 42.81006891312544}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  if (!controller_active_) {\n    rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d thrust_body = odometry_.orientation.toRotationMatrix().transpose() * angular_acceleration + acceleration;\n\n  Eigen::VectorXd rotor_velocities_unbounded = thrust_to_rotor_velocities_matrix_ * thrust_body;\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  for (size_t i = 0; i < rotor_velocities->rows(); ++i) {\n    (*rotor_velocities)[i] = std::sqrt(std::max(0.0, rotor_velocities_unbounded[i]));\n  }\n}", "CodeBleu_score": 54.4375159169185}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  if (!controller_active_) {\n    rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d thrust = odometry_.orientation.toRotationMatrix() * (acceleration - vehicle_parameters_.gravity_ * Eigen::Vector3d::UnitZ());\n\n  Eigen::VectorXd rotor_velocities_unnormalized = rotor_velocities_matrix_ * (angular_acceleration + thrust);\n\n  // Ensure non-negative values.\n  rotor_velocities_unnormalized = rotor_velocities_unnormalized.cwiseMax(Eigen::VectorXd::Zero(rotor_velocities_unnormalized.size()));\n\n  // Take the square root of each component.\n  rotor_velocities->resize(rotor_velocities_unnormalized.size());\n  for (size_t i = 0; i < rotor_velocities_unnormalized.size(); ++i) {\n    (*rotor_velocities)[i] = sqrt(rotor_velocities_unnormalized[i]);\n  }\n}", "CodeBleu_score": 57.65298897095317}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  if (!controller_active_) {\n    rotor_velocities->setZero(vehicle_parameters_.rotor_configuration_.rotors.size());\n    return;\n  }\n\n  // Compute desired acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  // Compute desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z-axis.\n  Eigen::Vector3d thrust = odometry_.orientation.toRotationMatrix().transpose() * angular_acceleration + acceleration;\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::VectorXd angular_acceleration_thrust(6);\n  angular_acceleration_thrust << angular_acceleration, thrust;\n\n  // Compute rotor velocities.\n  Eigen::MatrixXd rotor_velocities_matrix = vehicle_parameters_.rotor_configuration_.rotors.size() == 4 ? kQuadXRotorVelocitiesMatrix : kHexaXRotorVelocitiesMatrix;\n  *rotor_velocities = rotor_velocities_matrix * angular_acceleration_thrust;\n\n  // Ensure non-negative values.\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(vehicle_parameters_.rotor_configuration_.rotors.size()));\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 63.6823288867389}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t    // Calculate the position error\n    Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n    // Transform the velocity to the world frame\n    Eigen::Vector3d velocity_world = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n    // Calculate the velocity error\n    Eigen::Vector3d velocity_error = command_trajectory_.velocity - velocity_world;\n\n    // Compute the desired acceleration\n    *acceleration = position_error.cwiseProduct(position_gains_) + velocity_error.cwiseProduct(velocity_gains_);\n\n    // Adjust for vehicle mass, gravity, and commanded acceleration\n    *acceleration += Eigen::Vector3d(0, 0, -9.81) * mass_ + command_trajectory_.acceleration;\n}", "CodeBleu_score": 42.102689706835115}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t    // Calculate the position error between the current odometry and the command trajectory\n    Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n    // Transform the vehicle's velocity to the world frame\n    Eigen::Vector3d velocity_in_world_frame = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n    // Calculate the velocity error between the current velocity and the command trajectory\n    Eigen::Vector3d velocity_error = command_trajectory_.velocity - velocity_in_world_frame;\n    // Compute the desired acceleration by combining the position and velocity errors\n    *acceleration = position_error.cwiseProduct(position_gains_) + velocity_error.cwiseProduct(velocity_gains_);\n    // Adjust for the vehicle's mass, gravity, and commanded acceleration\n    acceleration->z() += gravity_ + command_trajectory_.acceleration.z();\n}", "CodeBleu_score": 41.95592011364871}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Calculate position error\n  Eigen::Vector3d position_error = odometry_.position - trajectory_.position;\n\n  // Calculate velocity error\n  Eigen::Vector3d velocity_error = odometry_.orientation.toRotationMatrix() * odometry_.velocity - trajectory_.velocity;\n\n  // Calculate desired acceleration\n  *acceleration = position_error.cwiseProduct(position_gains_) + velocity_error.cwiseProduct(velocity_gains_) -\n                  odometry_.acceleration.cwiseProduct(mass_) - gravity_;\n\n  // Adjust for commanded acceleration\n  *acceleration += trajectory_.acceleration;\n}", "CodeBleu_score": 38.24430413805075}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  Eigen::Vector3d angular_acceleration_thrust;\n  ComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n  // get thrust from thrust reference\n  Eigen::Vector3d thrust = Eigen::Vector3d::UnitZ() * control_attitude_thrust_reference_(3);\n\n  // combine thrust and angular acceleration\n  Eigen::Vector4d angular_acceleration_thrust_combined = Eigen::Vector4d::Zero();\n  angular_acceleration_thrust_combined.head<3>() = angular_acceleration_thrust;\n  angular_acceleration_thrust_combined[3] = thrust[2];\n\n  // get rotor velocities\n  Eigen::VectorXd rotor_velocities_unclipped = rotor_velocities_matrix_ * angular_acceleration_thrust_combined;\n\n  // clip rotor velocities to be at least one\n  rotor_velocities->resize(rotor_velocities_unclipped.rows());\n  rotor_velocities->cwiseMax(rotor_velocities_unclipped);\n  rotor_velocities->cwiseMin(rotor_velocities->rows() * Eigen::VectorXd::Ones());\n\n  // square root of rotor velocities\n  rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 55.46156306273868}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  Eigen::Vector3d angular_acceleration_thrust = Eigen::Vector3d::Zero();\n  ComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n  Eigen::VectorXd angular_acceleration_thrust_vector(6);\n  angular_acceleration_thrust_vector << angular_acceleration_thrust, control_attitude_thrust_reference_(3);\n\n  Eigen::MatrixXd rotor_velocities_matrix(rotor_velocities->rows(), 6);\n  rotor_velocities_matrix <<\n    -1,  1,  1, -1,  1, -1,\n     1, -1,  1,  1, -1,  1,\n     1,  1, -1,  1,  1, -1,\n    -1, -1, -1,  1, -1,  1;\n\n  *rotor_velocities = rotor_velocities_matrix * angular_acceleration_thrust_vector;\n  rotor_velocities->resize(rotor_velocities->rows());\n  rotor_velocities->cwiseSqrt();\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n}", "CodeBleu_score": 58.02256336836802}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 3.965771277166072}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.data = copied_obj.data[start_index:end_index]\n    copied_obj.error = copied_obj.error[start_index:end_index]\n    return copied_obj\n\n", "CodeBleu_score": 35.87300848862446}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.data = copied_obj.data[start_index:end_index]\n    copied_obj.name = copied_obj.name + f\"({start_time}-{end_time})\"\n    return copied_obj\n\n", "CodeBleu_score": 36.37955776120857}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.value = copied_obj.value[start_index:end_index]\n    copied_obj.start_time = copied_obj.__getattribute__('start_time')\n    copied_obj.end_time = copied_obj.__getattribute__('end_time')\n    copied_obj.name = copied_obj.__getattribute__('name')\n    copied_obj.units = copied_obj.__getattribute__('units')\n    return copied_obj\n\n", "CodeBleu_score": 39.400706796153166}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    (roll, pitch, yaw) = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if not self.is_same_waypoint(point, yaw):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 22.105356972422744}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert the rotation to Euler angles\n    (roll, pitch, yaw) = euler_from_quaternion(\n        [rotation.x, rotation.y, rotation.z, rotation.w]\n    )\n\n    # Create a Point object to store the position\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if (\n        (self.last_waypoint is None)\n        or (\n            (self.last_waypoint.x != point.x)\n            or (self.last_waypoint.y != point.y)\n            or (self.last_waypoint.z != point.z)\n            or (self.last_waypoint.yaw != yaw)\n        )\n    ):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n\n        # Update the last waypoint\n        self.last_waypoint = point\n\n", "CodeBleu_score": 29.853829350413914}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object with the position and rotation data\n    point = Point(position.x, position.y, position.z, euler[2])\n\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None or self.last_point.is_different(point):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_times(msg_time, bag_time)\n\n        # Update the last point\n        self.last_point = point\n\n", "CodeBleu_score": 22.553778162836103}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n        self.append_times(to_sec(msg.header.stamp), bag_time)\n\n", "CodeBleu_score": 34.01728234527545}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.linear_acceleration_topic:\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        self.append_times(to_sec(msg.header.stamp), bag_time)\n\n", "CodeBleu_score": 33.0486703361682}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        msg_time = to_sec(msg.header.stamp)\n        self.append_times(msg_time, bag_time)\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 35.729745967874415}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration Data\")\n    ax = fig.add_subplot(111)\n    for i, a_x in enumerate(self.accelerations):\n        ax.plot(a_x.time, a_x.x, label=\"x\" + str(i))\n        ax.plot(a_x.time, a_x.y, label=\"y\" + str(i))\n        ax.plot(a_x.time, a_x.z, label=\"z\" + str(i))\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.legend()\n    if self.save_plots:\n        plot_filename = \"acceleration\"\n        if plot_suffix is not None:\n            plot_filename += \"_\" + plot_suffix\n        plot_filename += \".png\"\n        pyplot.savefig(plot_filename)\n\n\n\n", "CodeBleu_score": 42.41210755338376}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure(figsize=(10, 6))\n    fig.suptitle('Acceleration Data')\n    ax_x = fig.add_subplot(1, 3, 1)\n    ax_y = fig.add_subplot(1, 3, 2)\n    ax_z = fig.add_subplot(1, 3, 3)\n\n    for i, (label, data) in enumerate(self.accelerations.items()):\n        ax_x.plot(data[:, 0], label=label)\n        ax_y.plot(data[:, 1], label=label)\n        ax_z.plot(data[:, 2], label=label)\n\n    ax_x.set_xlabel('Time (s)')\n    ax_x.set_ylabel('Acceleration (m/s^2)')\n    ax_x.set_title('X-axis')\n    ax_x.legend()\n\n    ax_y.set_xlabel('Time (s)')\n    ax_y.set_ylabel('Acceleration (m/s^2)')\n    ax_y.set_title('Y-axis')\n    ax_y.legend()\n\n    ax_z.set_xlabel('Time (s)')\n    ax_z.set_ylabel('Acceleration (m/s^2)')\n    ax_z.set_title('Z-axis')\n    ax_z.legend()\n\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix is not None:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        pyplot.savefig(filename)\n\n    pyplot.show()\n\n", "CodeBleu_score": 34.36787855104997}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plot_accelerations:\n        fig = pyplot.figure()\n        fig.suptitle(\"Acceleration Data\")\n        ax_x = fig.add_subplot(2, 1, 1)\n        ax_y = fig.add_subplot(2, 1, 2)\n        ax_z = fig.add_subplot(2, 1, 2)\n        for i, (acceleration_data, color, label) in enumerate(zip(self.acceleration_data, self.acceleration_colors, self.acceleration_labels)):\n            ax_x.plot(acceleration_data[0], color=color, label=label)\n            ax_y.plot(acceleration_data[1], color=color, label=label)\n            ax_z.plot(acceleration_data[2], color=color, label=label)\n        ax_x.set_ylabel(\"X Acceleration\")\n        ax_y.set_ylabel(\"Y Acceleration\")\n        ax_z.set_ylabel(\"Z Acceleration\")\n        ax_x.set_xlabel(\"Time\")\n        ax_y.set_xlabel(\"Time\")\n        ax_z.set_xlabel(\"Time\")\n        ax_x.legend()\n        ax_y.legend()\n        ax_z.legend()\n        if self.save_plots:\n            filename = \"acceleration_data\"\n            if plot_suffix is not None:\n                filename += \"_\" + plot_suffix\n            filename += \".png\"\n            pyplot.savefig(filename)\n\n\n\n\n", "CodeBleu_score": 32.83518082002048}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: compare_positions requires at least two pose indices to compare\")\n        return\n    for i, pose_index in enumerate(pose_indeces):\n        for j in range(i + 1, len(pose_indeces)):\n            pose_index_two = pose_indeces[j]\n            compare_two_xyz(pose_index, pose_index_two)", "CodeBleu_score": 41.5863640340526}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is None or collision.time >= start_time:\n            if end_time is None or collision.time <= end_time:\n                collision_times.append(collision.time)\n    return collision_times\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 45.070823907899815}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None and end_time is None:\n            if collision.time >= start_time:\n                collision_times.append(collision.time)\n        elif start_time is None and end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 38.87373136487441}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= collision_time <= end_time:\n                collision_times.append(collision_time)\n        elif start_time is not None:\n            if start_time <= collision_time:\n                collision_times.append(collision_time)\n        elif end_time is not None:\n            if collision_time <= end_time:\n                collision_times.append(collision_time)\n        else:\n            collision_times.append(collision_time)\n    return collision_times", "CodeBleu_score": 36.548368148752594}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) return;\n\n  // Compute multiplier based on camera parameters\n  const float fx = this->fx;\n  const float fy = this->fy;\n  const float cx = this->cx;\n  const float cy = this->cy;\n  const float multiplier = tanf(this->fov_x / 2.0f) * fx;\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  // Compute RMS noise\n  const Eigen::VectorXf rms_noise =\n      (data_vector_map * 1000.0).array().square().sqrt() * this->rms_noise;\n\n  // Compute noise values\n  const Eigen::VectorXf noise = rms_noise.array().random();\n\n  // Add noise to data\n  for (int i = 0; i < width * height; ++i) {\n    if (this->InRange(data[i])) {\n      data[i] += noise[i];\n    } else {\n      data[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 61.364892306246624}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  const float multiplier =\n      this->depth_camera_parameters.GetMultiplier(width, height);\n\n  const Eigen::Map<const Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic>>\n      data_vector_map(data, width, height);\n\n  const Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic> rms_noise =\n      this->rms_noise.array().square();\n\n  const Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic> noise =\n      rms_noise *\n      Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic>::Random(width, height)\n          .array();\n\n  const Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic> depth_vector_map =\n      (data_vector_map * multiplier).array();\n\n  for (int i = 0; i < width * height; i++) {\n    if (this->InRange(depth_vector_map(i))) {\n      data[i] += noise(i);\n    } else {\n      data[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 55.42033846020908}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  const float fx = this->fx;\n  const float fy = this->fy;\n  const float cx = this->cx;\n  const float cy = this->cy;\n  const float min_depth = this->min_depth;\n  const float max_depth = this->max_depth;\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic>>\n      data_vector_map(data, height, width);\n\n  // Compute the RMS noise\n  const Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic> rms_noise =\n      this->rms_noise.array();\n\n  // Compute the noise values\n  const Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic> noise =\n      rms_noise * Eigen::Array<float, Eigen::Dynamic, Eigen::Dynamic>::Random(\n                      height, width);\n\n  // Add noise to the data\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      float depth = data_vector_map(i, j);\n      if (this->InRange(depth)) {\n        data_vector_map(i, j) = depth + noise(i, j);\n      } else {\n        data_vector_map(i, j) = this->bad_point_value;\n      }\n    }\n  }\n}", "CodeBleu_score": 42.908794957615825}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time current_time = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = writeBag(current_time, trajectory_msg);\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 60.75760163233747}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  gazebo::common::Time current_sim_time = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time current_ros_time = writeBag(current_sim_time);\n\n  // Write the trajectory message to the bag file\n  trajectory_publisher_.publish(trajectory_msg);\n}", "CodeBleu_score": 42.36511610799088}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time and convert it to ROS time\n  gazebo::common::Time sim_time = world_->SimTime();\n  ros::Time ros_time = ros::Time::fromSec(sim_time.Double());\n\n  // Write the trajectory message to a bag file using the specified namespace and waypoint topic\n  writeBag(ros_time, trajectory_msg, namespace_, waypoint_topic_);\n}", "CodeBleu_score": 52.72721117514298}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n  // Convert simulation time to ROS time\n  ros::Time ros_time(now.sec, now.nsec);\n\n  // Prepare message for actuator velocities\n  sensor_msgs::JointState rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_time;\n  rot_velocities_msg.header.frame_id = \"world\";\n  rot_velocities_msg.name.resize(motor_joints_.size());\n  rot_velocities_msg.velocity.resize(motor_joints_.size());\n\n  // Iterate through motor joints, calculate slowed-down rotational velocities, and assign them to the message\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); m++) {\n    // Get motor joint index\n    int motor_joint_index = m->second->GetIndex();\n\n    // Get motor joint velocity\n    double motor_joint_velocity = m->second->GetVelocity(0);\n\n    // Calculate slowed-down rotational velocity\n    double rotational_velocity = motor_joint_velocity * motor_velocity_scale_;\n\n    // Assign rotational velocity to message\n    rot_velocities_msg.name[motor_joint_index] = m->second->GetName();\n    rot_velocities_msg.velocity[motor_joint_index] = rotational_velocity;\n  }\n\n  // Set message timestamp\n  rot_velocities_msg.header.stamp = ros_time;\n\n  // Write data to bag file using specified namespace and motor topic\n  writeBag(rot_velocities_msg, motor_topic_, motor_namespace_);\n}", "CodeBleu_score": 56.10435541298375}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time::now();\n\n  // Prepare message for actuator velocities\n  sensor_msgs::JointState rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_time;\n  rot_velocities_msg.header.frame_id = \"world\";\n  rot_velocities_msg.name.resize(motor_joints_.size());\n  rot_velocities_msg.velocity.resize(motor_joints_.size());\n\n  // Iterate through motor joints\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Get the motor joint name\n    rot_velocities_msg.name[m - motor_joints_.begin()] = m->second->GetName();\n\n    // Get the motor joint velocity\n    double motor_velocity = m->second->GetVelocity(0);\n\n    // Calculate the slowed-down rotational velocity\n    double rot_velocity = motor_velocity * motor_joints_[m->first]->GetParam(\"velocity_ratio\");\n\n    // Assign the rotational velocity to the message\n    rot_velocities_msg.velocity[m - motor_joints_.begin()] = rot_velocity;\n  }\n\n  // Set the message timestamp\n  rot_velocities_msg.header.stamp = ros_time;\n\n  // Write the data to a bag file using the specified namespace and motor topic\n  bag_writer_.write(namespace_ + \"/\" + motor_topic_, rot_velocities_msg);\n}", "CodeBleu_score": 59.22031351052871}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time::fromBoost(now.Double());\n\n  // Prepare message for actuator velocities\n  sensor_msgs::JointState rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_time;\n  rot_velocities_msg.header.frame_id = \"world\";\n  rot_velocities_msg.name.resize(motor_joints_.size());\n  rot_velocities_msg.velocity.resize(motor_joints_.size());\n\n  // Iterate through motor joints and calculate slowed-down rotational velocities\n  int i = 0;\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m, ++i) {\n    double motor_velocity = m->second->GetVelocity(0);\n    double slowed_down_velocity = motor_velocity * motor_velocity_scale_;\n    rot_velocities_msg.name[i] = m->first;\n    rot_velocities_msg.velocity[i] = slowed_down_velocity;\n  }\n\n  // Set message timestamp and write data to bag file\n  rot_velocities_msg.header.stamp = ros_time;\n  motor_velocities_bag_.write(motor_velocities_topic_, ros_time, rot_velocities_msg);\n}", "CodeBleu_score": 53.507879287980565}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_printing_) {\n    ROS_INFO_STREAM(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\");\n  }\n\n  aileron_angle_ = NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll());\n  elevator_angle_ = NormalizedInputToAngle(elevator_, pitch_pitch_yawrate_thrust_msg->pitch());\n  rudder_angle_ = NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate());\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 38.77894782677225}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_print_) {\n    ROS_INFO(\"RollPitchYawrateThrustCallback\");\n  }\n  roll_pitch_yawrate_thrust_msg->roll() = NormalizedInputToAngle(\n      control_surfaces_.aileron_left, roll_pitch_yawrate_thrust_msg->roll());\n  roll_pitch_yawrate_thrust_msg->pitch() = NormalizedInputToAngle(\n      control_surfaces_.elevator, roll_pitch_yawrate_thrust_msg->pitch());\n  roll_pitch_yawrate_thrust_msg->yaw_rate() = NormalizedInputToAngle(\n      control_surfaces_.rudder, roll_pitch_yawrate_thrust_msg->yaw_rate());\n  roll_pitch_yawrate_thrust_msg->thrust() = NormalizedInputToThrust(\n      control_surfaces_.throttle, roll_pitch_yawrate_thrust_msg->thrust());\n}", "CodeBleu_score": 48.43850069508721}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_printing_) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control\n  // surface angles for ailerons, elevator, and rudder respectively.\n  ailerons_.angle = NormalizedInputToAngle(ailerons_,\n      roll_pitch_yawrate_thrust_msg->roll());\n  elevator_.angle = NormalizedInputToAngle(elevator_,\n      roll_pitch_yawrate_thrust_msg->pitch());\n  rudder_.angle = NormalizedInputToAngle(rudder_,\n      roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  throttle_.angle = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 45.73176283567414}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  if (!serial_enabled_) {\n    return;\n  }\n\n  if (!is_open()) {\n    gzerr << \"Serial port closed. \n\";\n    return;\n  }\n\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n\n  int ret = select(_fd + 1, &readfds, NULL, NULL, &tv);\n\n  if (ret == -1) {\n    gzerr << \"select error: \" << strerror(errno) << \"\n\";\n    return;\n  } else if (ret == 0) {\n    return;\n  }\n\n  char buf[1024];\n  ssize_t n = recvfrom(_fd, buf, sizeof(buf), 0, NULL, NULL);\n\n  if (n < 0) {\n    gzerr << \"recvfrom error: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  for (int i = 0; i < n; ++i) {\n    mavlink_parse_char(_fd, buf[i], &last_message_, &status_);\n\n    if (status_.msg_received) {\n      handle_message(&last_message_);\n      status_.msg_received = false;\n    }\n  }\n\n  if (serial_enabled_) {\n    do_write(false);\n  }\n}", "CodeBleu_score": 53.27080431518849}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Convert the timeout to a timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Perform a poll operation on the file descriptor\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n  int retval = select(_fd + 1, &readfds, NULL, NULL, &timeout);\n\n  // If data is available, receive the data and parse MAVLink messages\n  if (retval > 0) {\n    char buffer[1024];\n    ssize_t num_bytes = recvfrom(_fd, buffer, sizeof(buffer), 0, NULL, NULL);\n    if (num_bytes > 0) {\n      for (ssize_t i = 0; i < num_bytes; ++i) {\n        mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg_, &status_);\n        if (status_.msg_received) {\n          // Forward the message to the serial connection if enabled\n          if (serial_enabled_) {\n            send_mavlink_message(&msg_, 0);\n          }\n          // Handle the message\n          handle_message(&msg_);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 60.04074128946817}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Convert timeout to timeval.\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Set up pollfd.\n  struct pollfd pollFd;\n  pollFd.fd = _fd;\n  pollFd.events = POLLIN;\n\n  // Poll for data.\n  int retval = poll(&pollFd, 1, _timeoutMs);\n\n  // If no data was received, return.\n  if (retval == 0) {\n    return;\n  }\n\n  // If an error occurred, print an error message and return.\n  if (retval < 0) {\n    printf(\"Poll error: %s\n\", strerror(errno));\n    return;\n  }\n\n  // If data was received, read it into the buffer.\n  if (pollFd.revents & POLLIN) {\n    ssize_t len = recvfrom(\n        _fd, rx_buffer_, sizeof(rx_buffer_), 0, (struct sockaddr*)&srcaddr_,\n        &socklen_);\n\n    // If no data was received, return.\n    if (len <= 0) {\n      return;\n    }\n\n    // Parse the received data.\n    for (int i = 0; i < len; ++i) {\n      // If the current byte is the start of a new message, reset the parser.\n      if (mavlink_parse_char(MAVLINK_COMM_0, rx_buffer_[i], &rx_msg_, &rx_status_)) {\n        // Handle the received message.\n        handle_message(&rx_msg_);\n      }\n    }\n  }\n}", "CodeBleu_score": 59.721673820521694}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  if (is_open_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 69.03218824839581}, {"code": "void GazeboMavlinkInterface::close() {\n\t  boost::lock_guard<boost::mutex> lock(mutex_);\n  if (is_open()) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 69.65295508944565}, {"code": "void GazeboMavlinkInterface::close() {\n\t  boost::mutex::scoped_lock lock(mutex_);\n  if (is_open()) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 69.509770834103}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d point1, ignition::math::Vector3d point2,\n    ignition::math::Vector3d value1, ignition::math::Vector3d value2,\n    ignition::math::Vector3d position\n}", "CodeBleu_score": 18.133594775888913}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    const ignition::math::Vector3d &p1,\n    const ignition::math::Vector3d &p2,\n    const double &x\n}", "CodeBleu_score": 13.897655475427415}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t    // TODO: Implement this function\n}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t\n}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t  // Check if the time is different from the current time\n  if (!ignition::math::equal(_time, this->dataPtr->time))\n  {\n    // Update the time\n    this->dataPtr->time = _time;\n\n    // If looping is enabled, wrap the time within the animation length\n    if (this->dataPtr->loop)\n    {\n      this->dataPtr->time = ignition::math::clamp(\n          this->dataPtr->time, 0.0, this->dataPtr->length);\n    }\n    // If looping is disabled, clamp the time between 0 and the animation length\n    else\n    {\n      this->dataPtr->time = ignition::math::clamp(\n          this->dataPtr->time, 0.0, this->dataPtr->length);\n    }\n  }\n}", "CodeBleu_score": 51.15592392197238}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.set_target_raw_pose(target_raw_pose)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + self.flight_mode)", "CodeBleu_score": 42.43962845156739}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.vehicle.send_mavlink(target_raw_pose)\n    print(self.vehicle.vehicle_type, self.vehicle.vehicle_id, self.vehicle.flight_mode)\n\n", "CodeBleu_score": 43.36262715313509}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.send_target_pose(target_raw_pose)\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", self.flight_mode)\n\n", "CodeBleu_score": 43.003212216505965}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.set_flight_mode(self.vehicle_type,self.vehicle_id,self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch successful')\n            return True\n        except Exception as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch failed')\n            return False\n\n", "CodeBleu_score": 60.5459095987826}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.setFlightMode(self.vehicle_id, self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch success')\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch failure')\n            return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 61.56998288695546}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch successful')\n        return True\n    else:\n        try:\n            self.flightModeService.change_mode(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch successful')\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch failed')\n            return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 61.45243274729015}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x, y, z, w)\n    if self.hover_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n\n", "CodeBleu_score": 36.400778288928635}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag == 0:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    else:\n        if self.hold_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        else:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 74.71395374485898}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    elif self.hover_flag == 1 and self.hold_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    elif self.hover_flag == 1 and self.hold_flag == 1:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 77.34507910119223}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.hover_state = 0\n            self.hover_count = 0\n            self.hover_timer = 0\n            self.hover_timer_start = time.time()\n            self.hover_timer_end = time.time()\n            self.hover_timer_duration = 0\n            self.hover_timer_duration_start = time.time()\n            self.hover_timer_duration_end = time.time()\n            self.hover_timer_duration_duration = 0\n            self.hover_timer_duration_duration_start = time.time()\n            self.hover_timer_duration_duration_end = time.time()\n            self.hover_timer_duration_duration_duration = 0\n            self.hover_timer_duration_duration_duration_start = time.time()\n            self.hover_timer_duration_duration_duration_end = time.time()\n            self.hover_timer_duration_duration_duration_duration = 0\n            self.hover_timer_duration_duration_duration_duration_start = time.time()\n            self.hover_timer_duration_duration_duration_duration_end = time.time()\n            self.hover_timer_duration_duration_duration_duration_duration = 0\n            self.hover_timer_duration_duration_duration_duration_duration_start = time.time()\n            self.hover_timer_duration_duration_duration_duration_duration_end = time.time()\n            self.hover_timer_duration_duration_duration_duration_duration_duration = 0\n            self.hover_timer_duration_duration_duration_duration_duration_duration_start = time.time()\n            self.hover_timer_duration_duration_duration_duration_duration_duration_end = time.time()\n            self.hover_timer_duration_duration_duration_duration_duration_duration_duration = 0\n            self.hover_timer_duration_duration_duration_duration_duration_duration_duration_start = time.time()\n            self.hover_", "CodeBleu_score": 24.60720632043699}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.change_flight_mode(\"OFFBOARD\")\n            print(\"hover_state_transition: offboard\")\n        else:\n            self.hover_flag = 1\n            self.change_flight_mode(\"HOVER\")\n            print(\"hover_state_transition: hover\")\n            self.hover()\n    else:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.change_flight_mode(\"OFFBOARD\")\n            print(\"hover_state_transition: offboard\")\n        else:\n            self.hover_flag = 1\n            print(\"hover_state_transition: hover\")\n\n", "CodeBleu_score": 32.00376433402818}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != 'HOVER' and x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.hover_state_transition_flag = 1\n        self.flight_mode = 'OFFBOARD'\n    elif self.hover_flag == 0:\n        self.hover_flag = 1\n        self.hover_state_transition_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n\n", "CodeBleu_score": 50.50610034929801}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 27.52863807726429}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = math.atan2(2 * (q.w * q.z + q.x * q.y), 1 - 2 * (q.y * q.y + q.z * q.z))\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = math.atan2(2 * (q.w * q.z + q.x * q.y), 1 - 2 * (q.y * q.y + q.z * q.z))\n    return yaw", "CodeBleu_score": 38.91746963722946}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = self.coordinate_frame_map[\"BODY_FRAME\"]\n    self.motion_type = self.motion_type_map[\"HOLD\"]\n    target_raw_pose = self.construct_target(z=-0.5)\n    self.print_vehicle_type_and_id()\n    self.print_flight_mode()\n    self.send_target_raw_pose(target_raw_pose)\n\n", "CodeBleu_score": 15.417266857183412}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = self.vehicle.location.global_frame\n    self.motion_type = 0\n    target = self.construct_target(x=self.vehicle.location.global_relative_frame.lat, y=self.vehicle.location.global_relative_frame.lon, z=self.vehicle.location.global_relative_frame.alt, yaw=self.vehicle.attitude.yaw)\n    self.vehicle.simple_goto(target)\n    print(f\"Vehicle Type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight Mode: {self.vehicle.mode.name}\")\n\n", "CodeBleu_score": 39.198710443983664}, {"code": "def hover(self)\n\t\n    # Update the coordinate frame and motion type\n    self.coordinate_frame = mavutil.mavlink.MAV_FRAME_BODY_NED\n    self.motion_type = mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT\n\n    # Construct a target motion\n    target_pose = self.construct_target(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n\n    # Send the target motion to the vehicle\n    self.send_target_motion(target_pose)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", self.flight_mode)", "CodeBleu_score": 22.806266138184426}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        if self.flightModeService.set_flight_mode(self.vehicle_type, self.vehicle_id, self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(\"Switching flight mode of \" + self.vehicle_type + '_' + self.vehicle_id + \" failed\")\n            return False\n\n", "CodeBleu_score": 66.04589052629714}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.vehicle_type, self.vehicle_id, self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except Exception as e:\n            print(e)\n            return False\n\n", "CodeBleu_score": 63.15316633425523}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        self.hover = False\n        try:\n            self.flightModeService.setFlightMode(self.vehicle_type, self.vehicle_id, self.flight_mode)\n            self.flight_mode = self.flightModeService.getFlightMode(self.vehicle_type, self.vehicle_id)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except Exception as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + \"Flight Mode Switch Failed: \" + str(e))\n            return False\n\n", "CodeBleu_score": 59.06664077111547}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    # Update the local pose\n    if msg.id == i:\n        self.local_pose = msg\n    # Update the takeoff target pose\n    if self.gcs_command == \"takeoff\":\n        self.takeoff_target_pose = self.local_pose\n    # Update the hover target pose\n    if self.gcs_command == \"hover\":\n        self.hover_target_pose = self.local_pose\n    # Update the global pose\n    self.global_pose = copy.deepcopy(self.local_pose)\n    self.global_pose.position.x += self.bias[0]\n    self.global_pose.position.y += self.bias[1]\n    self.global_pose.position.z += self.bias[2]\n\n\n\n\n", "CodeBleu_score": 32.37117370989947}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.uav_id:\n        self.local_pose = msg\n\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = self.local_pose\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = self.local_pose\n\n        self.global_pose = copy.deepcopy(self.local_pose)\n        self.global_pose.position.x += self.bias_x\n        self.global_pose.position.y += self.bias_y\n        self.global_pose.position.z += self.bias_z\n\n", "CodeBleu_score": 31.74439790390785}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg\n        if self.gcs_command == \"TAKEOFF\":\n            self.takeoff_target_pose = msg\n        elif self.gcs_command == \"HOVER\":\n            self.hover_target_pose = msg\n        self.global_pose = copy.deepcopy(msg)\n        self.global_pose.position.x += self.bias[i][0]\n        self.global_pose.position.y += self.bias[i][1]\n        self.global_pose.position.z += self.bias[i][2]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 31.967579032752873}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 70.13649723325177}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 70.13649723325177}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 70.13649723325177}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # TODO: This function is not used in the code. It can be removed.\n    n = len(orig_formation)\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            dist_matrix[i][j] = int(np.linalg.norm(orig_formation[i] - change_formation[j]))\n    return dist_matrix\n\n", "CodeBleu_score": 22.877265798765453}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the Euclidean norm between UAVs in the original and changed formations\n    norm = np.linalg.norm(orig_formation - change_formation, axis=1)\n    # Adjust the distances by subtracting them from 50 and convert to integers\n    norm = (50 - norm).astype(int)\n    # Construct the distance matrix\n    distance_matrix = np.zeros((self.num_uavs, self.num_uavs))\n    for i in range(self.num_uavs):\n        for j in range(self.num_uavs):\n            distance_matrix[i, j] = norm[i]\n    # Return the distance matrix\n    return distance_matrix", "CodeBleu_score": 25.960164175527417}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    orig_distances = np.linalg.norm(orig_formation - orig_formation[:, np.newaxis], axis=2)\n    change_distances = np.linalg.norm(change_formation - change_formation[:, np.newaxis], axis=2)\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    orig_distances = (50 - orig_distances).astype(int)\n    change_distances = (50 - change_distances).astype(int)\n\n    # Return the distance matrix\n    return orig_distances, change_distances\n\n", "CodeBleu_score": 17.678238988798476}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.match_right = [-1] * self.n\n    self.label_left = [0] * self.n\n    self.label_right = [0] * self.n\n    self.slack_right = [float('inf')] * self.n\n    for i in range(self.n):\n        self.label_left[i] = -min(self.adj_matrix[i])\n    while True:\n        self.visit_left = [False] * self.n\n        self.visit_right = [False] * self.n\n        for i in range(self.n):\n            if self.match_right[i] == -1 and self.find_path(i):\n                break\n        else:\n            return self.match_right\n        slack_min = min(self.slack_right)\n        for i in range(self.n):\n            if self.visit_left[i]:\n                self.label_left[i] += slack_min\n            if self.visit_right[i]:\n                self.label_right[i] -= slack_min\n        for i in range(self.n):\n            self.slack_right[i] = float('inf')\n            for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n                if not self.visit_right[j]:\n                    gap = self.label_left[i] + self.label_right[j] - match_weight\n                    self.slack_right[j] = min(self.slack_right[j], gap)", "CodeBleu_score": 36.12723726876486}, {"code": "def KM(self)\n\t\n    self.label_left = numpy.zeros(self.num_left, dtype=int)\n    self.label_right = numpy.zeros(self.num_right, dtype=int)\n    self.match_right = -numpy.ones(self.num_right, dtype=int)\n    self.visit_left = numpy.zeros(self.num_left, dtype=bool)\n    self.visit_right = numpy.zeros(self.num_right, dtype=bool)\n    self.slack_right = numpy.ones(self.num_right, dtype=int) * numpy.inf\n    for i in range(self.num_left):\n        while True:\n            self.visit_left = numpy.zeros(self.num_left, dtype=bool)\n            self.visit_right = numpy.zeros(self.num_right, dtype=bool)\n            self.slack_right = numpy.ones(self.num_right, dtype=int) * numpy.inf\n            if self.find_path(i):\n                break\n            min_slack = min(self.slack_right)\n            self.label_left[self.visit_left] += min_slack\n            self.label_right[self.visit_right] -= min_slack\n        self.slack_right = numpy.ones(self.num_right, dtype=int) * numpy.inf\n    return self.match_right\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 29.617093546863437}, {"code": "def KM(self)\n\t\n    self.label_left = numpy.zeros(self.UAV_count)\n    self.label_right = numpy.zeros(self.UAV_count)\n    self.match_right = -numpy.ones(self.UAV_count)\n    self.slack_right = numpy.zeros(self.UAV_count)\n    self.visit_right = numpy.zeros(self.UAV_count)\n    for i in range(self.UAV_count):\n        while True:\n            self.visit_left = numpy.zeros(self.UAV_count)\n            self.visit_right = numpy.zeros(self.UAV_count)\n            self.slack_right = numpy.inf * numpy.ones(self.UAV_count)\n            if self.find_path(i):\n                break\n            self.label_right[self.match_right] += self.slack_right\n            self.label_right[self.match_right] -= numpy.min(self.slack_right)\n            self.label_left[i] -= numpy.min(self.slack_right)\n    return self.match_right\n\n", "CodeBleu_score": 28.8253957794276}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    \n    # Define the lower and upper bounds for yellow color in HSV color space\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    \n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    \n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n    \n    return result\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    masked = cv2.bitwise_and(image, image, mask=mask)\n    return masked\n\n", "CodeBleu_score": 28.282641463352476}, {"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 25.555609057231816}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t  // Check if the map contains the given ID\n  if (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n    // If the description is found, set the descriptionContainer to the tag's description\n    descriptionContainer = standalone_tag_descriptions_[id];\n    return true;\n  } else {\n    // If the description is not found and printWarning is true, log a warning message\n    if (printWarning) {\n      ROS_WARN_THROTTLE(1.0, \"TagDetector: Could not find standalone tag description for ID %d\", id);\n    }\n    return false;\n  }\n}", "CodeBleu_score": 32.96708850574246}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  // Check if the tag description is in the map\n  map<int, TagDescription>::iterator it = standalone_tag_descriptions_.find(tag_id);\n  if (it != standalone_tag_descriptions_.end()) {\n    // The tag description was found, set the descriptionContainer to the tag's description\n    descriptionContainer = it->second;\n    return true;\n  }\n\n  // The tag description was not found, log a warning if printWarning is true\n  if (printWarning) {\n    ROS_WARN_THROTTLE(1.0, \"Could not find standalone tag description for tag ID %d\", tag_id);\n  }\n  return false;\n}", "CodeBleu_score": 41.302271392622266}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    std::map<int, StandaloneTagDescription>::iterator it = standalone_tag_descriptions_.find(tag_id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (print_warning_) {\n            ROS_WARN_THROTTLE(1.0, \"Standalone tag description for ID %d not found.\", tag_id);\n        }\n        return false;\n    }\n    description_container = it->second;\n    return true;\n}", "CodeBleu_score": 46.09487082649066}]}
