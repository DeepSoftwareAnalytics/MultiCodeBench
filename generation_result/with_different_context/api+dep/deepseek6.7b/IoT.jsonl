{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * p_desc = desc;\n\tuint8_t desc_type;\n\n\twhile (p_desc != NULL) {\n\t\tdesc_type = p_desc->bDescriptorType;\n\t\tif (desc_type == desc_id) {\n\t\t\treturn p_desc;\n\t\t}\n\t\tp_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *)p_desc + p_desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 42.43911838818592}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\n\twhile (desc->bLength != 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *)desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 32.554193270666495}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *) desc;\n\twhile (1) {\n\t\tif ((desc_ptr[1] == desc_id) && (desc_ptr[0] < desc_ptr[2])) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\t\tif (desc_ptr[0] == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdesc_ptr += desc_ptr[0];\n\t}\n}", "CodeBleu_score": 28.992150671609433}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t  /*\n   * The function \"udc_update_iface_desc\" checks if a specified interface descriptor with a given setting number exists within the current USB configuration.\nIt first verifies that there is a valid configuration and that the interface number is within bounds.\nIt then iterates through the descriptors, starting from the beginning of the configuration descriptor, and checks each one to see if it matches the specified interface number and setting number.\nIf it finds a matching interface descriptor, it returns \"true\"; otherwise, it returns \"false\".\n   */\n  if (udc_get_conf_num() == 0) {\n    return false;\n  }\n  if (iface_num >= USB_IFACE_MAX) {\n    return false;\n  }\n  const struct usb_desc_iface_t *iface_desc = usb_get_iface_desc(iface_num);\n  if (iface_desc == NULL) {\n    return false;\n  }\n  const struct usb_desc_iface_t *desc =\n      usb_get_iface_desc(iface_num);\n  while (desc != NULL) {\n    if (desc->bInterfaceNumber == iface_num &&\n        desc->bAlternateSetting == setting_num) {\n      return true;\n    }\n    desc = usb_get_iface_desc_next(desc);\n  }\n  return false;\n}", "CodeBleu_score": 34.63792507993318}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t", "CodeBleu_score": 3.3394715816443945}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t  uint16_t ep_status;\n\n  /* Check if the request length matches the size of the endpoint status variable. */\n  if (req.wLength != sizeof(ep_status)) {\n    return false;\n  }\n\n  /* Determine the status of the specified endpoint. */\n  if (udd_ep_is_halted(req.wIndex)) {\n    ep_status = UD_EP_STS_HALTED;\n  } else {\n    ep_status = 0;\n  }\n\n  /* Set up the response payload with the endpoint status. */\n  udd_set_setup_payload(&ep_status, sizeof(ep_status));\n\n  return true;\n}", "CodeBleu_score": 47.399747411080185}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t  uint16_t req_len;\n  uint8_t ep_status;\n\n  req_len = udd_get_setup_payload_length();\n  if (req_len != sizeof(ep_status)) {\n    return false;\n  }\n\n  ep_status = udd_ep_is_halted(udd_get_setup_payload_endpoint());\n  udd_set_setup_payload(&ep_status, sizeof(ep_status));\n\n  return true;\n}", "CodeBleu_score": 33.0043530161652}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t", "CodeBleu_score": 1.917982802830473}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tiface_num = udc_setup_req.wValue.b[0];\n\tsetting_num = udc_setup_req.wValue.b[1];\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\treturn udi_api->setup(iface_num, setting_num);\n}", "CodeBleu_score": 62.049399980237354}, {"code": "static bool udc_req_iface(void){\n\t\tbool ret = false;\n\n\tif (udc_num_configuration) {\n\t\tif (udc_ptr_iface->bInterfaceNumber == udc_ptr_req->wIndex) {\n\t\t\tret = udi_api->setup(udc_ptr_req);\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 12.093063193558619}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t  // Initialize MSC state\n  udi_msc_state = UDI_MSC_STATE_CBW_WAIT;\n  // Initialize LUN state\n  udi_msc_lun_state = UDI_MSC_LUN_STATE_UNLOAD;\n  // Get number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n  // Check if there are any LUNs available\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n  // Unload the medium on each LUN\n  for (int i = 0; i < udi_msc_nb_lun; i++) {\n    mem_unload(i);\n  }\n  // Start MSC process\n  udi_msc_cbw_wait();\n  return true;\n}", "CodeBleu_score": 46.11827448298897}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t  // Initialization\n  udi_msc_cbw_received = false;\n  udi_msc_cbw_err = false;\n  udi_msc_cbw_err_code = 0;\n  udi_msc_cbw_err_lun = 0;\n  udi_msc_cbw_err_tag = 0;\n  udi_msc_cbw_err_sense_key = 0;\n  udi_msc_cbw_err_asc = 0;\n  udi_msc_cbw_err_ascq = 0;\n\n  // Get the number of LUNs\n  if (!get_nb_lun()) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  mem_unload();\n\n  // Start the MSC process\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 25.225902496333756}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_STATUS_OK) {\n    // Transfer failed\n    // wait for MSC reset\n    udi_msc_cbw_reset();\n    return;\n  }\n  // Transfer successful\n  // update sense data\n  udi_msc_sense_update(nb_sent);\n  // decrease CSW data residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 66.4352476209827}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_STATUS_OK) {\n    // Transfer not OK\n    // then wait for MSC reset\n    udi_msc_cbw.bCBWStatus = USB_CBW_STATUS_PHASE_ERROR;\n    udi_msc_sense_pass();\n    udi_msc_csw_process();\n    udi_msc_wait_reset();\n    return;\n  }\n  // Transfer OK\n  // then update sense data\n  udi_msc_sense_update(nb_sent);\n  // and decrease CSW data residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // and process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 65.22951258617577}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_STATUS_COMPLETED) {\n    // Transfer not completed\n    // then wait for MSC setup reset\n    udi_msc_cbw.dCBWDataResidue = 0;\n    udi_msc_cbw.dCBWLength = 0;\n    udi_msc_cbw_send();\n    return;\n  }\n  // Transfer completed\n  // then update sense data\n  udi_msc_sense_pass();\n  // decrease CSW data residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 69.48455045961279}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t  uint32_t data_residue = udi_msc_cbw.data_residue;\n  uint8_t *csw_ptr = (uint8_t *) & udi_msc_csw;\n  uint8_t *cbw_ptr = (uint8_t *) & udi_msc_cbw;\n\n  // check if there is a non-zero data residue\n  if (data_residue) {\n    // if there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint based on the direction of the CBW\n    udi_msc_stall_next_request();\n    // set CSW status to CSW_STATUS_PHASE_ERROR\n    csw_ptr[0] = CSW_STATUS_PHASE_ERROR;\n  } else {\n    // set CSW status to CSW_STATUS_PASSED\n    csw_ptr[0] = CSW_STATUS_PASSED;\n  }\n\n  // set CSW tag to CBW tag\n  csw_ptr[1] = cbw_ptr[1];\n  csw_ptr[2] = cbw_ptr[2];\n  csw_ptr[3] = cbw_ptr[3];\n  csw_ptr[4] = cbw_ptr[4];\n\n  // convert data residue to little-endian format\n  csw_ptr[5] = data_residue & 0xFF;\n  csw_ptr[6] = (data_residue >> 8) & 0xFF;\n  csw_ptr[7] = (data_residue >> 16) & 0xFF;\n  csw_ptr[8] = (data_residue >> 24) & 0xFF;\n\n  // send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 41.387207022944686}, {"code": "static void udi_msc_csw_process(void){\n\t  // if there is a non-zero data residue,\n  // stalls the next request from the USB host\n  // on the appropriate endpoint\n  // based on the direction of the CBW\n  if (udi_msc_cbw.data_residue) {\n    // stall the next request\n    // on the appropriate endpoint\n    // based on the direction of the CBW\n    if (udi_msc_cbw.direction == UDI_MSC_CBW_IN) {\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    } else {\n      udd_ep_stall(UDI_MSC_EP_IN);\n    }\n  }\n  // prepares the CSW\n  // by setting its tag and\n  // converting the data residue\n  // to little-endian format\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.data_residue = cpu_to_le32(udi_msc_cbw.data_residue);\n}", "CodeBleu_score": 58.997023586109165}, {"code": "static void udi_msc_csw_process(void){\n\t  // Prepare CSW\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.status = udi_msc_cbw.status;\n  udi_msc_csw.residue = udi_msc_cbw.residue;\n  udi_msc_csw.residue = cpu_to_le32(udi_msc_csw.residue);\n  udi_msc_csw_send();\n}", "CodeBleu_score": 48.784380712549755}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  if (b_enable) {\n    usb_task_cdc_dtr_status[port] = true;\n    cancelReset();\n  } else {\n    usb_task_cdc_dtr_status[port] = false;\n    if (usb_task_cdc_dtr_rate[port] == 1200) {\n      initiateReset();\n    }\n  }\n}", "CodeBleu_score": 37.79662448978583}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tusb_cdc_port_t *port_info = &usb_cdc_port[port];\n\tport_info->b_dtr = b_enable;\n\n\tif (port_info->b_dtr) {\n\t\tcancelReset();\n\t} else {\n\t\tif (port_info->dtr_rate == 1200) {\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 30.352743934520486}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  if (b_enable) {\n    usb_cdc_dtr_status[port] = true;\n    cancelReset();\n  } else {\n    usb_cdc_dtr_status[port] = false;\n    if (usb_cdc_dtr_rate[port] == 1200) {\n      initiateReset();\n    }\n  }\n}", "CodeBleu_score": 38.769470334214205}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t  switch (usb_setup.bRequest) {\n    case 0x04:\n      usb_setup.wValue = (uint16_t)((uint32_t)(&usb_id_descriptor) >> 16);\n      usb_setup.wLength = sizeof(usb_id_descriptor);\n      return true;\n    case 0x05:\n      usb_setup.wValue = (uint16_t)((uint32_t)(&usb_ext_prop_descriptor) >> 16);\n      usb_setup.wLength = sizeof(usb_ext_prop_descriptor);\n      return true;\n  }\n  return false;\n}", "CodeBleu_score": 11.565675125851719}, {"code": "bool usb_task_other_requests(void){\n\t  switch (request_type) {\n    case 0x04:\n      if (request_index == 0x04) {\n        // Set up pointers and sizes for ID descriptor\n        id_desc_ptr = (uint8_t *)&id_desc;\n        id_desc_size = sizeof(id_desc);\n        return true;\n      } else if (request_index == 0x05) {\n        // Set up pointers and sizes for extended properties descriptor\n        ep_desc_ptr = (uint8_t *)&ep_desc;\n        ep_desc_size = sizeof(ep_desc);\n        return true;\n      }\n      break;\n    case 0x05:\n      if (request_index == 0x04) {\n        // Set up pointers and sizes for ID descriptor\n        id_desc_ptr = (uint8_t *)&id_desc;\n        id_desc_size = sizeof(id_desc);\n        return true;\n      } else if (request_index == 0x05) {\n        // Set up pointers and sizes for extended properties descriptor\n        ep_desc_ptr = (uint8_t *)&ep_desc;\n        ep_desc_size = sizeof(ep_desc);\n        return true;\n      }\n      break;\n    default:\n      break;\n  }\n  return false;\n}", "CodeBleu_score": 34.99097826495642}, {"code": "bool usb_task_other_requests(void){\n\t  if (request.type == REQUEST_TYPE_CLASS) {\n    if (request.index == USB_OTHER_REQUEST_ID_DESCRIPTOR) {\n      usb_descriptor_id_other_setup();\n      return true;\n    } else if (request.index == USB_OTHER_REQUEST_EXTENDED_PROPERTIES_DESCRIPTOR) {\n      usb_descriptor_extended_properties_other_setup();\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 16.702386054109464}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) return;\n  uint8_t dummy = 0x00;\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    spiSend(dummy);\n    buf[i] = spiRec();\n  }\n  buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 51.56180497143236}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0)\n    return;\n  while (nbyte--) {\n    *buf = spiRec();\n    buf++;\n  }\n}", "CodeBleu_score": 23.22270706688568}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) return;\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    buf[i] = spiRec();\n  }\n  buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 51.14026270935119}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tuint32_t *pISRVectors = get_relocated_table_addr();\n\tpfnISR_Handler oldHandler = (pfnISR_Handler)pISRVectors[irq];\n\tpISRVectors[irq] = (uint32_t)newHandler;\n\treturn oldHandler;\n}", "CodeBleu_score": 51.59529727096406}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\n\tpfnISR_Handler originalHandler;\n\n\tCRITICAL_SECTION_START\n\n\t/* Retrieve the address of the relocated interrupt vector table */\n\tuint32_t *pui32RelocatedTable = get_relocated_table_addr();\n\n\t/* Disable global interrupts to ensure atomic operation */\n\tuint32_t ui32IntStatus = __get_PRIMASK();\n\t__disable_irq();\n\n\t/* Retrieve the current handler for the specified IRQ */\n\toriginalHandler = (pfnISR_Handler) pui32RelocatedTable[irq];\n\n\t/* Replace the current handler with the new handler */\n\tpui32RelocatedTable[irq] = (uint32_t) newHandler;\n\n\t/* Re-enable global interrupts */\n\t__set_PRIMASK(ui32IntStatus);\n\n\tCRITICAL_SECTION_END\n\n\treturn originalHandler;\n}", "CodeBleu_score": 48.158032065260926}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tuint32_t *pIntVectTable;\n\tpfnISR_Handler oldHandler;\n\n\tCRITICAL_SECTION_START\n\n\t/* Get the address of the relocated interrupt vector table */\n\tpIntVectTable = get_relocated_table_addr();\n\n\t/* Disable interrupts to ensure atomic operation */\n\t__disable_irq();\n\n\t/* Get the current handler for the specified IRQ */\n\toldHandler = (pfnISR_Handler)pIntVectTable[irq];\n\n\t/* Replace the handler with the new handler */\n\tpIntVectTable[irq] = (uint32_t)newHandler;\n\n\t/* Re-enable interrupts */\n\t__enable_irq();\n\n\tCRITICAL_SECTION_END\n\n\treturn oldHandler;\n}", "CodeBleu_score": 51.20687498791684}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (udi_cdc_is_rx_ready()) {\n    int c = udi_cdc_getc();\n    if (emergency_parser.update(c)) {\n      return emergency_parser.get();\n    }\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 32.44533991626405}, {"code": "int MarlinSerialUSB::peek(){\n\t    if (!udi_cdc_is_rx_ready()) {\n        return -1;\n    }\n    int ch = udi_cdc_getc();\n    if (emergency_parser.update(ch)) {\n        return emergency_parser.getch();\n    }\n    return ch;\n}", "CodeBleu_score": 35.963206772910326}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!udi_cdc_is_rx_ready())\n    return -1;\n  const int c = udi_cdc_getc();\n  if (emergency_parser.update(c))\n    return emergency_parser.getc();\n  return c;\n}", "CodeBleu_score": 38.304707603506486}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  if (emergency_parser.update()) {\n    return emergency_parser.read();\n  }\n  if (!udi_cdc_is_rx_ready()) {\n    return -1;\n  }\n  const uint8_t c = udi_cdc_getc();\n  if (c != -1) {\n    emergency_parser.parse(c);\n  }\n  return c;\n}", "CodeBleu_score": 45.89751818601883}, {"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n  if (emergency_parser.update()) {\n    c = emergency_parser.read();\n  } else if (udi_cdc_is_rx_ready()) {\n    if (udi_cdc_isenabled()) {\n      c = udi_cdc_getc();\n      if (c != -1) {\n        emergency_parser.update(c);\n      }\n    }\n  }\n  return c;\n}", "CodeBleu_score": 43.90733489183374}, {"code": "int MarlinSerialUSB::read(){\n\t  // Check for pending character\n  if (available()) {\n    return read_character();\n  }\n\n  // Check if USB CDC is enabled and configured\n  if (!udi_cdc_is_enabled()) {\n    return -1;\n  }\n  if (!udi_cdc_is_configured()) {\n    return -1;\n  }\n\n  // Check if there are any bytes available to read from the PC\n  if (!udi_cdc_is_rx_ready()) {\n    return -1;\n  }\n\n  // Read the byte\n  uint8_t c = udi_cdc_getc();\n\n  // Update emergency parser if enabled\n  if (emergency_parser.enabled) {\n    emergency_parser.update(c);\n  }\n\n  // Return the read character\n  return c;\n}", "CodeBleu_score": 43.77313472123643}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      return 1;\n    }\n  }\n  return 0;\n}", "CodeBleu_score": 23.860907698891214}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready()) {\n    return 1;\n  } else {\n    return 0;\n  }\n}", "CodeBleu_score": 26.024679665231876}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready()) {\n    return 1;\n  } else {\n    return 0;\n  }\n}", "CodeBleu_score": 26.024679665231876}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t v = ee_Read(pos, writing);\n    if (value) *value++ = v;\n    if (crc)   *crc = crc16_update(*crc, v);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 55.5699525271467}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  uint8_t b;\n  while (size--) {\n    b = ee_Read(pos++);\n    if (writing && value)\n      *value++ = b;\n    if (crc)\n      *crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)b) << 8));\n    for (uint8_t i = 0; i < 8; i++)\n      *crc = (uint16_t)((*crc & 0x8000) ? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n  }\n  return false;\n}", "CodeBleu_score": 45.48972840986066}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (pos < 0)\n    return false;\n  while (size--) {\n    uint8_t c = ee_Read(pos);\n    if (crc)\n      *crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)*value++) << 8));\n    if (writing)\n      *value++ = c;\n    pos++;\n  }\n  return true;\n}", "CodeBleu_score": 54.92698864377192}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n  if (WITHIN(pin, 1, MAX_IOPIN)) {\n    uint8_t pwm = value >> (res - 7);\n    if (pwm != pwm_state[pin]) {\n      pwm_state[pin] = pwm;\n      if (pwm_count == 0) {\n        HAL_timer_start();\n        pwm_count = 1;\n      }\n      if (pwm_count < PWM_MAX_COUNT) {\n        pwm_index[pwm_count] = pin;\n        pwm_count++;\n      }\n    }\n  }\n}", "CodeBleu_score": 54.19077482235409}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin == 0) return;\n\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n\n  if (value == 255) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n\n  // Search for existing PWM state\n  for (int i = 0; i < PWM_MAX_NUM; i++) {\n    if (pwmInfo[i].pin == pin) {\n      pwmInfo[i].value = value;\n      return;\n    }\n  }\n\n  // Allocate new PWM slot\n  for (int i = 0; i < PWM_MAX_NUM; i++) {\n    if (pwmInfo[i].pin == 0) {\n      pwmInfo[i].pin = pin;\n      pwmInfo[i].value = value;\n      pwmInfo[i].freq = freq;\n      pwmInfo[i].res = res;\n      pwmInfo[i].cid = get_pwm_channel(pin, freq, res);\n      return;\n    }\n  }\n}", "CodeBleu_score": 58.40758968571925}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    if (pwm_enabled) {\n      int8_t cid = get_pwm_channel(pin, freq, res);\n      if (cid >= 0) {\n        ledcWrite(cid, value);\n        return;\n      }\n    }\n  }\n  // Software PWM\n  uint8_t  chan = get_pwm_channel_software(pin);\n  if (chan >= 0) {\n    uint8_t  val = value;\n    if (val > 255) val = 255;\n    val = (val * 256 + pwm_res[chan] / 2) / pwm_res[chan];\n    if (val != pwm_val[chan]) {\n      pwm_val[chan] = val;\n      if (val > 0) {\n        if (pwm_timer == NULL) {\n          pwm_timer = HAL_timer_start(PWM_FREQUENCY, pwm_callback);\n          pwm_count = 0;\n        }\n        pwm_count++;\n      }\n      else if (pwm_count > 0) {\n        pwm_count--;\n        if (pwm_count == 0) {\n          HAL_timer_stop(pwm_timer);\n          pwm_timer = NULL;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 50.397186212003284}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_DELAY_ARRAY_LENGTH >= 4, \"SERVO_DELAY_ARRAY_LENGTH must be at least 4\");\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 42.78572568021772}, {"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_COUNT < sizeof(servo_delay), \"SERVO_COUNT must be less than the size of servo_delay\");\n  if (attach(pin)) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 50.51371981091959}, {"code": "void Servo::move(const int value){\n\t  // Verify the servo delay array length using a static assertion\n  static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUM_SERVOS, \"Invalid servo delay array length\");\n\n  // Attach the servo if it's not already attached\n  if (channel == -1) {\n    channel = attach();\n    if (channel == -1) return;\n  }\n\n  // Write the desired value to move the servo\n  write(value);\n\n  // Wait for a predefined delay specific to the servo channel\n  safe_delay(servo_delay[channel]);\n\n  // Detach the servo after the move if the DEACTIVATE_SERVOS_AFTER_MOVE condition is enabled\n  #if DEACTIVATE_SERVOS_AFTER_MOVE\n    detach();\n  #endif\n}", "CodeBleu_score": 54.38396292169204}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  uint16_t i;\n  uint16_t *dma_buffer = (uint16_t *) i2s_dma_buffer;\n  for (i = 0; i < i2s_pin_count; i++) {\n    if (i2s_pins[i].pwm_ticks_left == 0) {\n      i2s_pins[i].pwm_state = !i2s_pins[i].pwm_state;\n      i2s_pins[i].pwm_ticks_left = i2s_pins[i].pwm_ticks_high;\n    }\n    if (i2s_pins[i].pwm_state) {\n      i2s_pins[i].port_data |= i2s_pins[i].pin_mask;\n    } else {\n      i2s_pins[i].port_data &= ~i2s_pins[i].pin_mask;\n    }\n    i2s_pins[i].pwm_ticks_left--;\n    *dma_buffer++ = i2s_pins[i].port_data;\n  }\n  i2s_dma_buffer_pos += i2s_pin_count;\n}", "CodeBleu_score": 32.85184130624202}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}, {"code": "void i2s_push_sample(){\n\t    uint8_t i;\n    uint8_t port_data;\n    uint8_t pwm_state;\n    uint8_t pwm_tick;\n\n    // Loop through each pin\n    for (i = 0; i < NUM_PINS; i++) {\n        // Get the PWM state for the current pin\n        pwm_state = pwm_states[i];\n        // Get the PWM tick count for the current pin\n        pwm_tick = pwm_ticks[i];\n\n        // Check if the PWM tick count is zero\n        if (pwm_tick == 0) {\n            // Toggle the pin state between high and low based on its current state\n            if (pwm_state == PWM_HIGH) {\n                pwm_state = PWM_LOW;\n            } else {\n                pwm_state = PWM_HIGH;\n            }\n\n            // Set the tick count for the next transition\n            pwm_ticks[i] = pwm_periods[i];\n        } else {\n            // Decrement the PWM tick count\n            pwm_tick--;\n        }\n\n        // Update the PWM state for the current pin\n        pwm_states[i] = pwm_state;\n\n        // Get the current port data for the current pin\n        port_data = port_data_regs[i];\n\n        // Toggle the pin state in the port data based on the PWM state\n        if (pwm_state == PWM_HIGH) {\n            port_data |= (1 << i);\n        } else {\n            port_data &= ~(1 << i);\n        }\n\n        // Store the updated port data into the current position of the DMA buffer\n        dma_buffer[dma_buffer_pos] = port_data;\n\n        // Increment the buffer position\n        dma_buffer_pos++;\n    }\n}", "CodeBleu_score": 39.10688057553222}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  hal_timer_t timer_count;\n  hal_timer_config_t *timer_config;\n\n  timer_config = &hal_timer_config[timer_num];\n\n  timer_count = timer_config->timer_count;\n\n  return timer_count;\n}", "CodeBleu_score": 51.489951873702}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t ret_val;\n    ret_val = timer_get_counter_value(timer_num);\n    return ret_val;\n}", "CodeBleu_score": 31.467571903891567}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  hal_timer_t counter_value;\n  uint8_t timer_config;\n\n  timer_config = timer_get_config(timer_num);\n  if (timer_config & TIMER_CONFIG_MODE_MASK) {\n    counter_value = timer_get_count(timer_num);\n  } else {\n    counter_value = timer_get_count_16(timer_num);\n  }\n\n  return counter_value;\n}", "CodeBleu_score": 47.81323153370536}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint16_t c = 0;\n  for (size_t i = 0; i < size; i++) {\n    uint8_t b = EEPROM.read(pos++);\n    if (writing)\n      value[i] = b;\n    crc16(&c, &b, 1);\n  }\n  if (crc)\n    *crc = c;\n  return false;\n}", "CodeBleu_score": 64.16951892738298}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint16_t crc16 = 0;\n  uint8_t *ptr = value;\n  for (uint16_t i = 0; i < size; i++) {\n    uint8_t data = EEPROM.read(pos++);\n    if (writing)\n      *ptr++ = data;\n    crc16 = (uint16_t)(crc16 ^ (uint16_t)(((uint16_t)data) << 8));\n    for (uint8_t i = 0; i < 8; i++)\n      crc16 = (uint16_t)((crc16 & 0x8000) ? ((uint16_t)(crc16 << 1) ^ 0x1021) : (crc16 << 1));\n  }\n  if (crc)\n    *crc = crc16;\n  return false;\n}", "CodeBleu_score": 49.27594638599459}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint16_t crc16 = 0;\n  uint8_t *ptr = value;\n  for (size_t i = 0; i < size; i++) {\n    uint8_t v = EEPROM.read(pos++);\n    if (writing)\n      *ptr++ = v;\n    crc16 = (uint16_t)(crc16 ^ (uint16_t)(((uint16_t)v) << 8));\n    for (uint8_t i = 0; i < 8; i++)\n      crc16 = (uint16_t)((crc16 & 0x8000) ? ((uint16_t)(crc16 << 1) ^ 0x1021) : (crc16 << 1));\n  }\n  if (crc)\n    *crc = crc16;\n  return false;\n}", "CodeBleu_score": 51.34428049910797}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    CORE_ASSERT(sdio_handle, \"SDIO handle is null\");\n    CORE_ASSERT(src, \"Source pointer is null\");\n\n    WITH_RETRY(SDCARD_WriteBlocks(sdio_handle, block, 1, src), 5);\n}", "CodeBleu_score": 22.422233631175068}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    SDIO_HandleTypeDef *hsdio = SDIO_GetHandle();\n    CORE_ASSERT(hsdio && src);\n\n    bool ret = false;\n    for (uint8_t i = 0; i < WITH_RETRY; i++) {\n        if (SDCARD_WriteBlocks(hsdio, block, 1, (uint8_t *)src) == HAL_OK) {\n            ret = true;\n            break;\n        }\n    }\n\n    if (!ret) {\n        printf(\"SDIO_WriteBlock failed\n\");\n    }\n\n    return ret;\n}", "CodeBleu_score": 36.642148554933925}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    CORE_ASSERT(sdio_handle != NULL && src != NULL);\n    WITH_RETRY(SDCARD_WriteBlocks(sdio_handle, block, 1, src), SDIO_MAX_RETRIES);\n}", "CodeBleu_score": 18.670825264293942}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  if (timer_num == TEMPERATURE_TIMER) {\n    timer_num->setCallbackPriority(TEMPERATURE_TIMER_PRIORITY);\n    timer_num->start(frequency, TEMPERATURE_TIMER_PRESCALE);\n  } else if (timer_num == STEPPER_TIMER) {\n    timer_num->setCallbackPriority(STEPPER_TIMER_PRIORITY);\n    timer_num->start(frequency, STEPPER_TIMER_PRESCALE);\n  } else {\n    CORE_ASSERT_FAIL();\n  }\n}", "CodeBleu_score": 48.709780789233896}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_ASSERT_FAIL_IF(timer_num >= TIMER_CHANNEL_COUNT);\n    if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n        timer_num->start(frequency, TIMER_PRESCALE_TEMPERATURE);\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_TEMPERATURE);\n    } else if (timer_num == TIMER_CHANNEL_STEPPER) {\n        timer_num->start(frequency, TIMER_PRESCALE_STEPPER);\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_STEPPER);\n    }\n}", "CodeBleu_score": 47.62893030126448}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    // Check if the timer channel is valid\n    CORE_ASSERT_FAIL(timer_num < TIMER_CHANNEL_COUNT);\n\n    // Start the timer with the given frequency\n    timer_num->start(frequency);\n\n    // Set the callback priority for the timer\n    if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_TEMPERATURE);\n    } else if (timer_num == TIMER_CHANNEL_STEPPER) {\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_STEPPER);\n    }\n}", "CodeBleu_score": 39.37924288165402}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  if (!fopen(file_name, \"r+\")) {\n    fclose(file_name);\n    return false;\n  }\n\n  if (ftell(file_name) != EEPROM_SIZE) {\n    memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n    fwrite(buffer, EEPROM_SIZE, 1, file_name);\n  }\n\n  fread(buffer, EEPROM_SIZE, 1, file_name);\n  fclose(file_name);\n  return true;\n}", "CodeBleu_score": 27.380957534161592}, {"code": "bool PersistentStore::access_start(){\n\t  File file = SPIFFS.open(PERSISTENT_STORE_FILENAME, \"r\");\n  if (!file) {\n    return false;\n  }\n  if (file.size() < PERSISTENT_STORE_SIZE) {\n    memset(buffer, PERSISTENT_STORE_ERASE_VALUE, PERSISTENT_STORE_SIZE);\n  }\n  file.read(buffer, PERSISTENT_STORE_SIZE);\n  file.close();\n  return true;\n}", "CodeBleu_score": 20.816158726277767}, {"code": "bool PersistentStore::access_start(){\n\t  File f = SPIFFS.open(filename, \"r\");\n  if (!f) {\n    Serial.println(\"Failed to open file for reading\");\n    return false;\n  }\n\n  // Check the file size\n  if (f.size() < EEPROM_SIZE) {\n    // Fill the remaining bytes with a default erase value\n    memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n  }\n\n  // Read the file into the buffer\n  f.read(buffer, EEPROM_SIZE);\n  f.close();\n  return true;\n}", "CodeBleu_score": 21.361783760167533}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n  uint8_t i;\n  for (i = 0; i < 8; i++) {\n    if (b & 0x80) {\n      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);\n    } else {\n      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);\n    }\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_SET);\n    r <<= 1;\n    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14)) {\n      r |= 1;\n    }\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET);\n    b <<= 1;\n  }\n  delaySPIFunc();\n  return r;\n}", "CodeBleu_score": 43.57277243532632}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\n\tuint8_t i;\n\tuint8_t r = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\n\t\tdelaySPIFunc();\n\t\tWRITE;\n\t\tWRITE_HIGH;\n\t\tdelaySPIFunc();\n\t\tWRITE_LOW;\n\t\tdelaySPIFunc();\n\t\tREAD;\n\t\tr <<= 1;\n\t\tif (READ_HIGH) {\n\t\t\tr |= 1;\n\t\t}\n\t\tdelaySPIFunc();\n\n\t}\n\n\treturn r;\n}", "CodeBleu_score": 34.36456925646594}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t i;\n  uint8_t r = 0;\n  for (i = 0; i < 8; i++) {\n    GPIO_ResetBits(GPIOB, GPIO_Pin_13); // Set the clock pin low\n    if (b & 0x80) {\n      GPIO_SetBits(GPIOB, GPIO_Pin_15); // Write the most significant bit of the byte to the MOSI pin\n    } else {\n      GPIO_ResetBits(GPIOB, GPIO_Pin_15);\n    }\n    GPIO_SetBits(GPIOB, GPIO_Pin_13); // Toggle the clock pin high\n    if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12)) {\n      r |= 0x80; // Read the bit from the MISO pin and shift it into the received byte\n    }\n    b <<= 1; // Shift the byte left\n  }\n  delaySPIFunc(); // Introduce a small delay before returning the received byte\n  return r;\n}", "CodeBleu_score": 42.98297592511292}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= (uint32_t)(~(uint32_t)RCC_AHBPeriph);\n  }\n}", "CodeBleu_score": 77.44374258262798}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.69690496231567}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 84.07596204999733}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\n    // Check for parity error\n    if (obj->status & SERIAL_BUF_OVF) {\n        // Parity error, discard byte\n        obj->status &= ~SERIAL_BUF_OVF;\n        return;\n    }\n\n    // Read byte\n    uint8_t c = obj->getc();\n\n    // Check if there is space available in the buffer\n    if (obj->head == obj->tail) {\n        // No space available, discard byte\n        return;\n    }\n\n    // Store byte in buffer\n    obj->buffer[obj->head] = c;\n\n    // Calculate next buffer index\n    obj->head = (obj->head + 1) % SERIAL_RX_BUFFER_SIZE;\n\n    // Update emergency parser\n    emergency_parser.update(c);\n}", "CodeBleu_score": 45.5457556443327}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t    uint8_t data;\n    uint16_t next_index;\n\n    // Read the data from the serial port\n    data = obj->uart->rxbuf;\n\n    // Check if the parity error flag is set\n    if (obj->uart->ier & UART_IER_PARITY) {\n        // Clear the parity error flag\n        obj->uart->ier = UART_IER_PARITY;\n        // Set the parity error flag in the serial object\n        obj->parity_error = true;\n        // Return from the interrupt handler\n        return;\n    }\n\n    // Calculate the next index in the receive buffer\n    next_index = (obj->rx_head + 1) % obj->rx_buffer_size;\n\n    // Check if there is space in the receive buffer\n    if (next_index != obj->rx_tail) {\n        // Store the received data in the receive buffer\n        obj->rx_buffer[obj->rx_head] = data;\n        // Update the head pointer\n        obj->rx_head = next_index;\n    }\n\n    // Update the emergency parser with the received byte\n    if (obj->emergency_parser != NULL) {\n        obj->emergency_parser->update(data);\n    }\n}", "CodeBleu_score": 48.811027901224946}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // Get the serial object\n  MarlinSerial *uart = (MarlinSerial *)obj;\n\n  // Read the byte\n  uint8_t c = uart->read();\n\n  // Check if the byte is a valid character\n  if (c == SERIAL_NO_DATA) {\n    return;\n  }\n\n  // If the byte is a valid character, store it in the receive buffer\n  if (uart->_rx_buffer_head < uart->_rx_buffer_tail + SERIAL_RX_BUFFER_SIZE) {\n    uart->_rx_buffer[uart->_rx_buffer_head++] = c;\n  }\n\n  // Update the next buffer index\n  uart->_rx_buffer_head %= SERIAL_RX_BUFFER_SIZE;\n\n  // If the emergency parser is enabled, update it with the received byte\n  if (uart->emergency_parser.enabled) {\n    uart->emergency_parser.update(c);\n  }\n}", "CodeBleu_score": 36.09399409200048}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_instance[timer_num]->hasInterrupt) {\n    return;\n  }\n  if (!HAL_timer_initialized[timer_num]) {\n    return;\n  }\n  if (timer_num == MF_TIMER_STEP) {\n    timer_instance[timer_num]->attachInterrupt(Step_Handler);\n  }\n  if (timer_num == MF_TIMER_TEMP) {\n    timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n  }\n}", "CodeBleu_score": 58.47021684888446}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->hasInterrupt) {\n        switch (timer_num) {\n            case MF_TIMER_STEP:\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n                break;\n            case MF_TIMER_TEMP:\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n                break;\n        }\n        timer_instance[timer_num]->hasInterrupt = true;\n    }\n}", "CodeBleu_score": 81.67202248883406}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif(HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->hasInterrupt) {\n\t\tswitch(timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 70.77842552262564}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn, m := len(s), len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif n < m {\n\t\treturn -1\n\t}\n\tvar hash, pow uint32\n\thash, pow = HashStrRev(sep)\n\tsepHash := uint32(0)\n\tfor i := n - m; i < n; i++ {\n\t\tsepHash = sepHash*PrimeRK + uint32(s[i])\n\t}\n\tif sepHash == hash && s[n-m:n] == sep {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\tsepHash *= PrimeRK\n\t\tsepHash += uint32(s[i])\n\t\tsepHash -= pow * uint32(s[i+m])\n\t\tif sepHash == hash && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 50.50353683089575}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\thash, pow := HashStrRev(sep)\n\tfor i := len(s); i >= len(sep); i-- {\n\t\tif uint32(s[i-1])*pow == hash {\n\t\t\tif string(s[i-len(sep):i]) == string(sep) {\n\t\t\t\treturn i - len(sep)\n\t\t\t}\n\t\t}\n\t\tif i > len(sep) {\n\t\t\thash = hash*PrimeRK + uint32(s[i-len(sep)-1])\n\t\t\thash -= pow * uint32(s[i-1])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 37.17650802353823}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\thash, pow := HashStrRev(sep)\n\tn := len(s)\n\tsepLen := len(sep)\n\th := uint32(0)\n\tfor i := n - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t\tif i >= sepLen {\n\t\t\th -= pow * uint32(s[i-sepLen])\n\t\t}\n\t\tif h == hash && s[i-sepLen+1:i+1] == sep {\n\t\t\treturn i - sepLen + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 46.71897482880637}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t    interrupt.Disable()\n    if usbcdc.txBuffer.Get() > 0 {\n        usbcdc.SendUSBInPacket()\n    } else {\n        usbcdc.waitTxc = false\n    }\n    interrupt.Restore()\n}", "CodeBleu_score": 50.590993837753906}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t    interrupt.Disable()\n    if usbcdc.txBuffer.Get() {\n        usbcdc.SendUSBInPacket()\n    }\n    interrupt.Restore()\n}", "CodeBleu_score": 32.77488605799269}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\ttxc := usbcdc.txc\n\tif txc != 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txBuffer.Get())\n\t\tusbcdc.txc = 0\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 59.662276022926505}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(I2C_CR_STOP)\n\ti2c.crReg.SetBits(I2C_CR_START)\n\ti2c.waitForEvent(I2C_ISR_SB)\n\ti2c.drReg.Set(uint16(address << 1))\n\tif write {\n\t\ti2c.drReg.ClearBits(I2C_DR_RD)\n\t} else {\n\t\ti2c.drReg.SetBits(I2C_DR_RD)\n\t}\n\ti2c.waitForEvent(I2C_ISR_ADDR)\n}", "CodeBleu_score": 30.428857339833215}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.HasBits())\n\ti2c.crReg.Set(i2c.crReg.HasBits())\n\ti2c.crReg.Set(i2c.crReg.HasBits())\n\tfor i2c.crReg.HasBits() {\n\t}\n\ti2c.writeByte(address)\n\tif !write {\n\t\ti2c.crReg.Set(i2c.crReg.HasBits())\n\t}\n}", "CodeBleu_score": 39.45355685721458}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.HasBits)\n\ti2c.crReg.Set(i2c.crReg.HasBits)\n\ti2c.crReg.SetBits(i2c.crReg.HasBits)\n\tfor i2c.crReg.HasBits(i2c.crReg.HasBits) {\n\t}\n\ti2c.writeByte(address | (write ? 0 : 1))\n}", "CodeBleu_score": 33.89533754116781}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t    if len == 0 {\n        return nil\n    }\n\n    if start < 0 || len < 0 {\n        return ErrInvalid\n    }\n\n    if start >= f.BlockCount() {\n        return ErrInvalid\n    }\n\n    if start+len > f.BlockCount() {\n        return ErrInvalid\n    }\n\n    if len == 0 {\n        return nil\n    }\n\n    startAddr := f.BlockSize() * start\n\n    nrf.NVMC.SetCONFIG_WEN\n    waitWhileFlashBusy\n    nrf.NVMC.ERASEPAGE.Set\n    uint32\n    uintptr\n\n    for i := int64(0); i < len; i++ {\n        waitWhileFlashBusy\n    }\n\n    nrf.NVMC.SetCONFIG_WEN\n\n    return nil\n}", "CodeBleu_score": 41.00173136991799}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := f.FlashDataStart + uint32(start) * f.EraseBlockSize\n\tendAddr := startAddr + uint32(len) * f.EraseBlockSize\n\tfor addr := startAddr; addr < endAddr; addr += f.EraseBlockSize {\n\t\tnrf.NVMC.SetCONFIG_WEN\n\t\twaitWhileFlashBusy\n\t\tnrf.NVMC.ERASEPAGE.Set(addr)\n\t\twaitWhileFlashBusy\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\treturn nil\n}", "CodeBleu_score": 39.662585490298085}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t    f.EraseBlockSize\n    nrf.NVMC.SetCONFIG_WEN\n    waitWhileFlashBusy\n    nrf.NVMC.ERASEPAGE.Set\n    uint32\n    uintptr\n    return nil\n}", "CodeBleu_score": 19.902316080657485}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.size-off {\n\t\treturn 0, io.ErrShortWrite\n\t}\n\tstart := uint32(f.base) + uint32(off)\n\tpad := f.pad\n\tif len(p)%pad != 0 {\n\t\tp = append(p, make([]byte, pad-len(p)%pad)...)\n\t}\n\tn = len(p)\n\tnw := n\n\tfor nw > 0 {\n\t\taddr := start\n\t\tend := start + uint32(nw)\n\t\tnrf.NVMC.SetCONFIG_WEN(true)\n\t\twaitWhileFlashBusy()\n\t\tfor addr < end {\n\t\t\tnrf.FLASH.WriteAt(addr, (*uint32)(unsafe.Pointer(&p[addr-uint32(f.base)])))\n\t\t\twaitWhileFlashBusy()\n\t\t\taddr += 4\n\t\t}\n\t\tnw -= int(end - start)\n\t\tstart = end\n\t}\n\treturn n, nil\n}", "CodeBleu_score": 37.85676073605235}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar err error\n\tvar dir *syscall.Dir\n\n\tfd2, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fd2)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\n\treturn uintptr(fd2), \"\", nil\n}", "CodeBleu_score": 72.65722776802212}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar err error\n\tvar dirPtr uintptr\n\tvar dir *os.File\n\n\t// Duplicate the file descriptor\n\tnewFd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory using syscall.Fdopendir\n\tfor {\n\t\tdir, err = syscall.Fdopendir(newFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If an error occurred, close the duplicated file descriptor and return the error\n\tif err != nil {\n\t\tsyscall.Close(newFd)\n\t\treturn 0, \"\", err\n\t}\n\n\t// Otherwise, return the directory pointer and the duplicated file descriptor\n\tdirPtr = uintptr(unsafe.Pointer(dir))\n\treturn dirPtr, \"\", nil\n}", "CodeBleu_score": 69.8767948128034}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdupfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tvar dir *syscall.Dirent\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupfd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dupfd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\treturn uintptr(dupfd), \"\", nil\n}", "CodeBleu_score": 69.5529187029762}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  uint32_t result = 0;\n  esp_partition_t *running_partition = esp_ota_get_running_partition();\n  if (running_partition == NULL) {\n    return result;\n  }\n  if (response == SKETCH_FREE_SPACE) {\n    result = running_partition->size - running_partition->offset;\n  } else {\n    esp_app_desc_t app_desc;\n    if (esp_ota_get_partition_description(running_partition, &app_desc) == ESP_OK) {\n      result = app_desc.size;\n    }\n  }\n  return result;\n}", "CodeBleu_score": 48.78978527568903}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    esp_partition_t *runningPartition = esp_ota_get_running_partition();\n    if (runningPartition == NULL) {\n        return 0;\n    }\n\n    if (response == sketchSize_t::SKETCH_SIZE) {\n        return runningPartition->size;\n    }\n\n    esp_app_desc_t app_desc;\n    if (esp_ota_get_partition_description(runningPartition, &app_desc) == ESP_OK) {\n        return app_desc.size;\n    }\n\n    return 0;\n}", "CodeBleu_score": 41.03705732450445}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  esp_partition_iterator_t iterator = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_OTA_0, NULL);\n  esp_partition_t *partition = esp_partition_get(iterator);\n  esp_partition_iterator_release(iterator);\n  if (partition == NULL) {\n    return 0;\n  }\n  if (response == SKETCH_SIZE_FREE) {\n    return partition->size - partition->used_size;\n  } else {\n    return partition->used_size;\n  }\n}", "CodeBleu_score": 39.552439953868436}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t disk_sectors = msc_update_get_required_disk_sectors();\n  msc_update_disk = calloc(disk_sectors, DISK_SECTOR_SIZE);\n  if (!msc_update_disk) {\n    log_e(\"Failed to allocate RAM disk\");\n    return false;\n  }\n  fat_file_system_type fat_type = mcs_is_fat16 ? FAT16 : FAT12;\n  fat_add_boot_sector(msc_update_disk, disk_sectors, fat_type, volume_label, serial_number);\n  fat_add_table(msc_update_disk, disk_sectors, fat_type);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_update_disk, msc_run_partition, fat_type);\n  }\n  return true;\n}", "CodeBleu_score": 35.562409123162944}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % ESP_PARTITION_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Update write offset not aligned with flash sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n    if (partition->size - offset < size) {\n        ESP_LOGE(TAG, \"Update write size exceeds partition size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n    if (offset % ESP_PARTITION_SEC_SIZE == 0) {\n        esp_err_t err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase flash sector at offset 0x%08x\", offset);\n            return err;\n        }\n    }\n    esp_err_t err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to partition\");\n    }\n    return err;\n}", "CodeBleu_score": 51.385557135015034}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Offset is not aligned with sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase sector at offset %d, error=%d\", offset, err);\n        return err;\n    }\n\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 56.901740122419994}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    // Check if the offset is aligned with the flash sector size\n    if (offset % ESP_PARTITION_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Offset not aligned with flash sector size\");\n        return ESP_FAIL;\n    }\n\n    // Check if the size is a multiple of the flash sector size\n    if (size % ESP_PARTITION_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Size not a multiple of flash sector size\");\n        return ESP_FAIL;\n    }\n\n    // Check if the offset is within the partition\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"Offset + size exceeds partition size\");\n        return ESP_FAIL;\n    }\n\n    // Erase the sector if needed\n    if (offset % ESP_PARTITION_SEC_SIZE == 0) {\n        esp_err_t err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase sector: %s\", esp_err_to_name(err));\n            return err;\n        }\n    }\n\n    // Write the data to the partition\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 54.77667699355494}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t outlen = 0;\n  while (outlen < maxlen && *in) {\n    unsigned char c = hex_char_to_byte(*in++);\n    if (c < 0x10) {\n      out[outlen++] = c;\n    }\n  }\n  return outlen;\n}", "CodeBleu_score": 34.81120028200409}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t out_len = 0;\n  while (*in && out_len < maxlen) {\n    uint8_t c = hex_char_to_byte(*in++);\n    if (c < 0x10) {\n      out[out_len++] = c;\n    }\n  }\n  return out_len;\n}", "CodeBleu_score": 36.30264616424736}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t outlen = 0;\n  while (maxlen && *in) {\n    uint8_t hi = hex_char_to_byte(*in++);\n    if (hi > 0xf) continue;\n    uint8_t lo = hex_char_to_byte(*in++);\n    if (lo > 0xf) continue;\n    *out++ = (hi << 4) | lo;\n    maxlen--;\n    outlen++;\n  }\n  return outlen;\n}", "CodeBleu_score": 40.77119168735908}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t    if ((txRingBuffer == NULL) || (txLock == NULL)) {\n        return 0;\n    }\n    if (xSemaphoreTake(txLock, 1000) == pdTRUE) {\n        int ret = xRingbufferGetCurFreeSize(txRingBuffer);\n        xSemaphoreGive(txLock);\n        return ret;\n    }\n    return 0;\n}", "CodeBleu_score": 62.02159666203564}, {"code": "int HWCDC::availableForWrite(void){\n\t  int ret = 0;\n\n  if (lock != NULL && ringbuffer != NULL) {\n    if (xSemaphoreTake(lock, 1000) == pdTRUE) {\n      ret = xRingbufferGetCurFreeSize(ringbuffer);\n      xSemaphoreGive(lock);\n    }\n  }\n\n  return ret;\n}", "CodeBleu_score": 52.81203047708913}, {"code": "int HWCDC::availableForWrite(void){\n\t  int freeSize = 0;\n\n  if (NULL != tx_ringbuffer) {\n    if (NULL != tx_ringbuffer_lock) {\n      if (pdTRUE == xSemaphoreTake(tx_ringbuffer_lock, 1000)) {\n        freeSize = xRingbufferGetCurFreeSize(tx_ringbuffer);\n        xSemaphoreGive(tx_ringbuffer_lock);\n      }\n    }\n  }\n\n  return freeSize;\n}", "CodeBleu_score": 45.345887256543875}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  if (function == NULL) {\n    return;\n  }\n  HSERIAL_MUTEX_LOCK();\n  _onReceiveCB = function;\n  _rxTimeout = onlyOnTimeout;\n  uartSetRxFIFOFull(this, 1);\n  if (_eventTask == NULL) {\n    _createEventTask(NULL);\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 33.20793817753093}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _rxTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    uartSetRxFIFOFull(_uart_nr, 1);\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 37.71713158261242}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  if (function == NULL) {\n    log_e(\" -- Invalid Callback function\");\n    return;\n  }\n\n  HSERIAL_MUTEX_LOCK();\n  _onReceiveCB = function;\n  if (onlyOnTimeout) {\n    _rxTimeout = true;\n  }\n  if (_onReceiveCB != NULL) {\n    uartSetRxFIFOFull(this, 1);\n    _createEventTask();\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 47.03542541278981}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[index++] = (char)c;\n    if (c == terminator) {\n      break;\n    }\n  }\n  buffer[index] = '\\0';\n  return index;\n}", "CodeBleu_score": 80.27144012908549}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t i = 0;\n  while (i < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[i++] = (char)c;\n    if (c == terminator) {\n      break;\n    }\n  }\n  buffer[i] = 0;  // null terminate the string\n  return i;\n}", "CodeBleu_score": 77.13290190397353}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t i = 0;\n  while (i < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    *buffer++ = c;\n    i++;\n    if (c == terminator) {\n      break;\n    }\n  }\n  *buffer = 0;\n  return i;\n}", "CodeBleu_score": 75.64051136175772}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"Tone on pin %d, frequency %d, duration %ld\", pin, frequency, duration);\n\n  if (pin_available(pin)) {\n    tone_init();\n    tone_msg_t msg = {.type = TONE_START, .pin = pin, .frequency = frequency, .duration = duration};\n    xQueueSend(_tone_queue, &msg, 0);\n  } else {\n    log_e(\"Pin %d is in use\", pin);\n  }\n}", "CodeBleu_score": 52.200658612262664}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"Tone: pin=%d, freq=%d, duration=%ld\", pin, frequency, duration);\n\n  // Check if the pin is available or already in use\n  if (_tone_pins[pin] == TONE_PIN_FREE) {\n    // Initialize the tone and send a start command\n    _tone_pins[pin] = TONE_PIN_IN_USE;\n    tone_msg_t msg = {\n      .cmd = TONE_CMD_START,\n      .pin = pin,\n      .freq = frequency,\n      .dur = duration\n    };\n    if (xQueueSend(_tone_queue, &msg, 0) != pdTRUE) {\n      log_e(\"Could not send tone start command\");\n    }\n  } else {\n    // Log an error message instructing to stop the current tone on the pin first\n    log_e(\"Pin %d is in use. Stop the current tone first\", pin);\n  }\n}", "CodeBleu_score": 52.69200821847482}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"tone: pin=%d, frequency=%d, duration=%d\", pin, frequency, duration);\n  if (!is_pin_available(pin)) {\n    log_e(\"tone: pin %d is not available\", pin);\n    return;\n  }\n\n  tone_init();\n\n  tone_msg_t msg;\n  msg.cmd = TONE_START;\n  msg.pin = pin;\n  msg.frequency = frequency;\n  msg.duration = duration;\n\n  xQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 45.58270193780692}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (usb_started) {\n        if (enabled) {\n            if (usb_version < 0x0210) {\n                return false;\n            }\n            usb_webusb_enabled = true;\n        } else {\n            usb_webusb_enabled = false;\n        }\n    } else {\n        usb_webusb_enabled = enabled;\n    }\n    return true;\n}", "CodeBleu_score": 37.64898174450835}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (!started) {\n        webUSBEnabled = enabled;\n        return false;\n    }\n    if (enabled) {\n        if (usbVersion < 0x0210) {\n            return false;\n        }\n        usb_set_config(usbDevice, 1);\n        usb_set_interface(usbDevice, 0, 0);\n        usb_set_interface(usbDevice, 0, 1);\n    } else {\n        usb_set_config(usbDevice, 0);\n        usb_set_interface(usbDevice, 0, 0);\n    }\n    return true;\n}", "CodeBleu_score": 45.39949086246085}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  // If USB has not started, update the WebUSB enabled state and ensure the USB version is at least 0x0210 when enabling WebUSB.\n  if (!_started) {\n    _webUSBEnabled = enabled;\n    if (enabled && _usbVersion < 0x0210) {\n      _usbVersion = 0x0210;\n    }\n    return true;\n  }\n  // If USB has started, update the WebUSB enabled state.\n  _webUSBEnabled = enabled;\n  return false;\n}", "CodeBleu_score": 70.02563140362916}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t  int len = tud_cdc_n_read(0);\n  if (len > 0) {\n    if (len > RX_BUFFER_SIZE) {\n      len = RX_BUFFER_SIZE;\n    }\n    if (len > _rx_queue.size()) {\n      _rx_queue.postOverflow(len - _rx_queue.size());\n    }\n    int read = tud_cdc_n_read(0, _rx_buffer, len);\n    if (read == len) {\n      _rx_queue.postReceive(len);\n    } else {\n      _rx_queue.postOverflow(len - read);\n      log_e(\"USBCDC: Failed to read %d bytes\", len);\n    }\n  }\n}", "CodeBleu_score": 25.233469190733317}, {"code": "void USBCDC::_onRX(){\n\t    // Read data from the USB CDC device into a buffer\n    uint8_t buffer[64];\n    uint16_t len = tud_cdc_n_read(0, buffer, sizeof(buffer));\n    if (len > 0) {\n        // Attempt to send each byte of data to the receive queue\n        for (uint16_t i = 0; i < len; i++) {\n            if (xQueueSend(receiveQueue, &buffer[i], 0) != pdTRUE) {\n                // If the queue is full, post an overflow event with the number of dropped bytes\n                USBCDC::_overflowEvent(len - i);\n                log_e(\"USBCDC receive queue overflow\");\n                break;\n            }\n        }\n        // Post a receive event with the length of the received data\n        USBCDC::_receiveEvent(len);\n    }\n}", "CodeBleu_score": 24.64637845356121}, {"code": "void USBCDC::_onRX(){\n\t  if (tud_cdc_n_available(_interface)) {\n    uint8_t buffer[CDC_TX_BUFSIZE];\n    uint32_t count = tud_cdc_n_read(_interface, buffer, CDC_TX_BUFSIZE);\n    if (xQueueSend(_receiveQueue, buffer, 0) != pdTRUE) {\n      _overflowEvent.post(count);\n      log_e(\"USB CDC receive queue overflow\");\n    } else {\n      _receiveEvent.post(count);\n    }\n  }\n}", "CodeBleu_score": 19.604000723143912}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot found with name \" + robotName})\n\t\treturn\n\t}\n\n\tdevices := make(map[string]interface{})\n\trobot.Devices().Each(func(d interface{}) {\n\t\tdevices[d.(gobot.Device).Name()] = d\n\t})\n\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 38.93086815270196}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif a.master.Robot(name) == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + name})\n\t\treturn\n\t}\n\n\trobot := a.master.Robot(name)\n\tdevices := robot.Devices()\n\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 32.65080299591474}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot found with name \" + name})\n\t\treturn\n\t}\n\tdevices := []map[string]interface{}{}\n\trobot.Devices().Each(func(d interface{}) {\n\t\tdevices = append(devices, d.(map[string]interface{}))\n\t})\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 53.304926045973076}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, []byte(`{\"error\": \"no robot with name `+robotName+` found\"}`))\n\t\treturn\n\t}\n\n\tconnections := []interface{}{}\n\trobot.Connections().Each(func(conn gobot.Connection) {\n\t\tconnections = append(connections, conn)\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 44.664527563490246}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"no robot named %s found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\tconnectionsJSON := []map[string]interface{}{}\n\tconnections.Each(func(conn gobot.Connection) {\n\t\tconnectionsJSON = append(connectionsJSON, conn.JSON())\n\t})\n\ta.writeJSON(res, http.StatusOK, connectionsJSON)\n}", "CodeBleu_score": 53.42712114759935}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"error\": \"No robot with name \" + robotName + \" found\",\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := []interface{}{}\n\trobot.Connections().Each(func(c Connection) {\n\t\tconnections = append(connections, c.JSON())\n\t})\n\n\ta.writeJSON(res, map[string]interface{}{\n\t\t\"connections\": connections,\n\t})\n}", "CodeBleu_score": 56.20383899397303}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\n\td, err := a.jsonDeviceFor(robot, device)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, err.Error())\n\t\treturn\n\t}\n\n\terr = a.master.Robot(robot).\n\t\tDevice(device).(gobot.Commander).\n\t\tCommand(d.Command, d.Params)\n\tif err != nil {\n\t\ta.writeJSON(res, err.Error())\n\t\treturn\n\t}\n\n\ta.writeJSON(res, \"ok\")\n}", "CodeBleu_score": 56.03947564277851}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\n\td, err := a.master.Robot(robot).\n\t\tDevice(device)\n\tif err != nil {\n\t\ta.writeJSON(res, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\ta.executeCommand(res, d, command)\n}", "CodeBleu_score": 53.18595075659916}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\n\tif a.master.Robot(robot) == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\tif a.master.Robot(robot).Device(device) == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"device not found\"})\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\n\terr := a.master.Robot(robot).Device(device).(gobot.Commander).Command(command)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, map[string]string{\"status\": \"ok\"})\n}", "CodeBleu_score": 52.95457217998264}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.77802914682379}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\tuserColonPass := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(userColonPass) != 2 || userColonPass[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tuserColonPass = strings.SplitN(userColonPass[1], \":\", 2)\n\t\tif len(userColonPass) != 2 || !secureCompare(userColonPass[0], username) || !secureCompare(userColonPass[1], password) {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authorization succeeded\n\t}\n}", "CodeBleu_score": 50.56622074605737}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.70778540988229}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog read\", a.Connection().Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 53.60391532537852}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection not set\")\n\t}\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.16042470663452}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 53.61116670491185}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.Name = gobot.DefaultName\n\tg.Values = make([]interface{}, 1)\n\tg.Values[0] = uint16(0)\n\n\treturn g\n}", "CodeBleu_score": 48.344385030667524}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.Name = g.DefaultName\n\treturn g\n}", "CodeBleu_score": 47.44514686664314}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.Name = DefaultGroveSoundSensorName\n\treturn g\n}", "CodeBleu_score": 46.290162836721}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(15 * time.Millisecond)\n\tb, err := d.readByteData(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b&0x01 != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.705090452778016}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write the soft reset command to the command register.\n\td.writeByteData(CommandReg, SoftReset)\n\n\t// Wait for the initialization time.\n\ttime.Sleep(15 * time.Millisecond)\n\n\t// Read the command register to check the status.\n\tstatus, err := d.readByteData(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set.\n\tif status&0x01 != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.0128506824942}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(MFRC522_REG_COMMAND, MFRC522_PCD_SOFTRESET)\n\ttime.Sleep(150 * time.Millisecond)\n\tval, err := d.readByteData(MFRC522_REG_COMMAND)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif (val & 0x01) != 0x00 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.2953609129169}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check if the length of the backData slice matches the expected length\n\tif len(backData) != d.FIFOLevel {\n\t\treturn 0, fmt.Errorf(\"backData length (%d) does not match FIFO level (%d)\", len(backData), d.FIFOLevel)\n\t}\n\t// Read each byte from the FIFO into the backData slice\n\tfor i := 0; i < d.FIFOLevel; i++ {\n\t\tbackData[i] = d.readByteData(MFRC522_FIFO_DATA)\n\t}\n\t// Read the control register to get the last bits received\n\tlastBits := d.readByteData(MFRC522_CONTROL)\n\t// Return the last bits received along with any errors encountered\n\treturn lastBits, nil\n}", "CodeBleu_score": 26.645804520563587}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.readRegister(FIFODataReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"expected %d bytes, got %d\", len(backData), n)\n\t}\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tcontrol, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn control & 0x07, nil\n}", "CodeBleu_score": 47.2580078407544}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check the number of bytes available in the FIFO\n\tn, err := d.readRegister(FIFODataLength)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"readFifo: expected %d bytes, got %d\", len(backData), n)\n\t}\n\t// Read each byte from the FIFO into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(FIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received\n\tcontrol, err := d.readRegister(ControlRegister)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn control & 0x07, nil\n}", "CodeBleu_score": 51.24335240829188}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.log.Debug(\"piccHalt()\")\n\tcmd := []byte{0x50, 0x00, 0x00, 0x00}\n\td.calculateCRC(cmd)\n\tcmd = append(cmd, d.crcA, d.crcB)\n\t_, err := d.spi.Transfer(cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccHalt(): %s\", err)\n\t}\n\t_, err = d.spi.Transfer([]byte{0x00, 0x00, 0x00, 0x00})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccHalt(): %s\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 37.8725571807985}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debugPrintln(\"piccHalt\")\n\n\tcmd := []byte{MFRC522_PICC_HALT}\n\td.calculateCRC(cmd)\n\tcmd = append(cmd, d.crcResult...)\n\n\t_, err := d.communicateWithPICC(cmd, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccHalt: %s\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 30.741200572176773}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Println(\"piccHalt:\")\n\t}\n\n\tcmd := []uint8{0x50, 0x00}\n\td.calculateCRC(cmd)\n\tcmd = append(cmd, d.crcResult...)\n\n\terr := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccHalt: %v\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 33.51626983909003}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Construct the read command\n\tcommand := []byte{0xFF, 0xB0, 0x00, 0x00, 0x00}\n\tcommand[2] = block\n\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(command[1:])\n\n\t// Append the CRC to the command\n\tcommand = append(command, crc...)\n\n\t// Communicate with the RFID card using the command\n\tresponse, err := d.communicateWithPICC(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Extract the data from the response\n\tdata := response[1:]\n\n\treturn data, nil\n}", "CodeBleu_score": 32.06179752432471}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Construct the read command\n\tcmd := []byte{0xFF, 0xB0, 0x00, 0x00, 0x00}\n\tcmd[2] = block\n\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(cmd)\n\n\t// Append the CRC to the command\n\tcmd = append(cmd, crc...)\n\n\t// Communicate with the RFID card using the command\n\tresp, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is valid\n\tif len(resp) != 18 || resp[0] != 0x90 || resp[1] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"invalid response from RFID card\")\n\t}\n\n\t// Extract the data from the response\n\tdata := resp[6:16]\n\n\treturn data, nil\n}", "CodeBleu_score": 35.621344914634804}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := []byte{0x30, block}\n\td.calculateCRC(cmd)\n\tcmd = append(cmd, d.crcA, d.crcB)\n\n\tif _, err := d.communicateWithPICC(cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := make([]byte, 16)\n\t_, err := d.reader.Read(resp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}", "CodeBleu_score": 41.57657974190503}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\n\treqMode &= 0x1F // Bits 5 to 7 are reserved for future use and must be cleared.\n\treqMode |= (1 << 6) // Set the Cascade Level bit.\n\treqMode |= (1 << 5) // Set the PICC Command to REQA or WUPA.\n\n\t// Sanity check.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must be at least 2 bytes\")\n\t}\n\n\t// Clear the collision register.\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// The PICC Command is placed in the first byte of the transmission buffer.\n\td.writeRegister(FIFODataReg, reqMode)\n\n\t// Transceive the data in the FIFO.\n\t_, err := d.transceiveData(answer, FIFOLevelReg, 0x10, CascadeLevel)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 38.869823290283655}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tanswerLen := len(answer)\n\tif answerLen < 2 {\n\t\treturn fmt.Errorf(\"answer buffer is too small\")\n\t}\n\td.clearRegisterBitMask(0x04, 0x07)\n\tif reqMode == PiccRequestTypeA {\n\t\td.clearRegisterBitMask(0x04, 0x08)\n\t} else if reqMode == PiccRequestTypeB {\n\t\td.setRegisterBitMask(0x04, 0x08)\n\t}\n\tif reqMode == PiccRequestTypeA || reqMode == PiccRequestTypeB {\n\t\td.setRegisterBitMask(0x04, 0x04)\n\t}\n\tanswer[0] = 0x00\n\tanswer[1] = 0x00\n\t_, err := d.transceive(answer[:answerLen])\n\treturn err\n}", "CodeBleu_score": 42.16241329277188}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\treq := []byte{0x26, reqMode}\n\trespLen := len(answer)\n\tif respLen < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must be at least 2 bytes\")\n\t}\n\td.clearRegisterBitMask(0x0D, 0x07) // CRCPOLY=0x07 => x^8+x^2+x^1+1 => ISO 18092\n\td.setRegisterBitMask(0x0D, 0x40)   // CRCEN=1 => CRC enabled\n\td.setRegisterBitMask(0x0D, 0x30)   // TXLAST=1 => last transmission bit\n\tif reqMode == 0xA2 {\n\t\td.setRegisterBitMask(0x0D, 0x08) // TX1_RFEN=1 => tx last bit is RFEN\n\t}\n\tresp, err := d.transceive(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(resp) != 2 {\n\t\treturn fmt.Errorf(\"response should be 2 bytes, got %d\", len(resp))\n\t}\n\tanswer[0] = resp[0]\n\tanswer[1] = resp[1]\n\treturn nil\n}", "CodeBleu_score": 47.253029861336714}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\td.digitalWrite(d.stepPin, LOW)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, HIGH)\n\tif d.direction == CW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 43.410071020307}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.stepPin.DigitalWrite(gpio.Low)\n\ttime.Sleep(d.getDelayPerStep())\n\td.stepPin.DigitalWrite(gpio.High)\n\n\tif d.direction == DirectionCW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.670466333847024}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\td.digitalWrite(d.stepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, 1)\n\tif d.direction == FORWARD {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.398534141136814}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name())\n\treturn nil\n}", "CodeBleu_score": 68.11724870223819}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name())\n\treturn nil\n}", "CodeBleu_score": 68.11724870223819}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name())\n\n\treturn nil\n}", "CodeBleu_score": 82.50538494858158}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(pin int, t time.Duration, event string, value uint32, _ uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstartTimestamp = t\n\t\t} else if event == \"falling\" {\n\t\t\tduration := t.Sub(startTimestamp).Microseconds()\n\t\t\td.duration <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 45.7754822731929}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, edge string, value uint32, ticks uint32) {\n\t\tif edge == \"rising\" {\n\t\t\td.startTimestamp = ticks\n\t\t} else if edge == \"falling\" {\n\t\t\td.durationCh <- (ticks - d.startTimestamp).Microseconds()\n\t\t}\n\t}\n}", "CodeBleu_score": 38.78470328199277}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, eventName string, edge uint32, pud uint32) {\n\t\tif eventName == \"rising\" {\n\t\t\td.startTimestamp = time.Now()\n\t\t} else if eventName == \"falling\" {\n\t\t\td.durationChan <- time.Since(d.startTimestamp)\n\t\t}\n\t}\n}", "CodeBleu_score": 34.59709537742516}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.trigger.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trigger.Low()\n\n\tstartTime := time.Now()\n\ttimeout := time.After(1000 * time.Millisecond)\n\n\tfor {\n\t\tif d.echo.Read() == gpio.High {\n\t\t\tbreak\n\t\t}\n\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\tdefault:\n\t\t\ttime.Sleep(10 * time.Microsecond)\n\t\t}\n\t}\n\n\tendTime := time.Now()\n\telapsed := endTime.Sub(startTime)\n\n\td.measurement = elapsed.Microseconds()\n\n\treturn nil\n}", "CodeBleu_score": 48.39750263510347}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\ttime.AfterFunc(d.timeout, func() {\n\t\td.measureTimeout = true\n\t})\n\n\tfor {\n\t\tif d.measureTimeout {\n\t\t\treturn fmt.Errorf(\"measurement timeout\")\n\t\t}\n\n\t\tif d.measureComplete {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 40.168767471657155}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\ttime.AfterFunc(d.measureTimeout, func() {\n\t\td.measureComplete <- fmt.Errorf(\"measurement timeout\")\n\t})\n\n\tselect {\n\tcase err := <-d.measureComplete:\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\td.distance = d.measuredTime\n\t\treturn nil\n\t}\n}", "CodeBleu_score": 54.421930604546034}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\"TOKEN\")\n    if token:\n        return token\n    access_token = self.get_local_state_item(\"access_token\")\n    expires_at = self.get_local_state_item(\"expires_at\")\n    if access_token and expires_at and expires_at > time.time():\n        return access_token\n    refresh_token = self.get_local_state_item(\"refresh_token\")\n    if refresh_token:\n        self.fetch_refresh_token(refresh_token)\n        return self.get_local_state_item(\"access_token\")\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 29.159403715159947}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return self.fetch_authentication_token_from_env()\n    except AccountNotAuthorized:\n        pass\n\n    try:\n        return self.fetch_authentication_token_from_local_state()\n    except AccountNotAuthorized:\n        pass\n\n    try:\n        return self.fetch_authentication_token_from_refresh_token()\n    except AccountNotAuthorized:\n        pass\n\n    raise AccountNotAuthorized(\"Authentication token not found\")\n\n", "CodeBleu_score": 20.157684183976244}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.token:\n        return self.token\n    if self.refresh_token:\n        try:\n            return self.fetch_access_token_from_refresh_token()\n        except AccountError:\n            pass\n    if self.access_token:\n        if self.access_token_expiration_time > time.time():\n            return self.access_token\n        try:\n            return self.fetch_access_token_from_refresh_token()\n        except AccountError:\n            pass\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 16.92973610078013}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n    except AccountError:\n        pass\n    return True\n\n\n", "CodeBleu_score": 53.52645385417103}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n    except AccountError:\n        pass\n    return True\n\n\n\n\n", "CodeBleu_score": 53.52645385417103}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            headers={\"Content-Type\": \"application/json\"},\n            json={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 55.9423389390606}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.packages:\n        if pkg.is_optional():\n            continue\n        items = [pkg.name]\n        if pkg.version:\n            items.append(pkg.version)\n        if pkg.is_external():\n            items.append(pkg.source_url)\n        result.append(\" \".join(items))\n    return \"", "CodeBleu_score": 28.68864985959561}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.packages:\n        if pkg.is_optional():\n            continue\n        items = [pkg.name, pkg.version]\n        if pkg.is_external():\n            items.append(pkg.source_url)\n        result.append(items)\n    return result\n\n", "CodeBleu_score": 26.87380787300708}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if package.is_optional:\n            continue\n        items = [package.name]\n        if package.version:\n            items.append(package.version)\n        if package.source:\n            items.append(package.source)\n        result.append(\", \".join(items))\n    return result\n\n", "CodeBleu_score": 28.870938478685694}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = config.get(\"project\", \"platforms\", {}).get(env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n\n    p = cls(platform_spec, autoinstall=autoinstall)\n    p.set_project_env(env)\n    p.configure_project_packages(targets)\n    return p\n\n", "CodeBleu_score": 27.54673527501569}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls()\n    platform = config.get(\"envs\", env, \"platform\")\n    if not platform:\n        raise exception.UndefinedEnvPlatformError(env)\n    p.platform = platform\n    p.autoinstall = autoinstall\n    p.set_project_environment(env)\n    p.configure_project_packages(targets)\n    return p", "CodeBleu_score": 32.96028364483733}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform = config.get(\"env\", env)\n    except KeyError:\n        raise UndefinedEnvPlatformError(env)\n\n    p = cls(platform, autoinstall)\n    p.set_project_env(env)\n    p.configure_project_packages(targets)\n    return p\n\n", "CodeBleu_score": 38.232354617002215}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(AXP192_ADDRESS);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(AXP192_ADDRESS, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 67.23159437117269}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(AXP192_ADDRESS);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(AXP192_ADDRESS, Size);\n  while (Wire1.available()) {\n    *Buff++ = Wire1.read();\n  }\n}", "CodeBleu_score": 52.30816591298806}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(AXP192_I2C_ADDR);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(AXP192_I2C_ADDR, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 67.13980928094252}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        uint32_t time_in_ms = time_in_us / 1000;\n        Write32bit(0x32, time_in_ms);\n        esp_sleep_enable_timer_wakeup(time_in_us * 1000);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.74866332031047}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  #ifdef HAS_ILI9341\n    int y = vsp;\n    tft.fillRect(0, y, tft.width(), tft.textheight(), color);\n    y += tft.textheight();\n    if (y >= tft.height()-BOTTOM_FIXED_AREA) y -= tft.height()-BOTTOM_FIXED_AREA;\n    if (tteBar) y = TOP_FIXED_AREA_TTE;\n    scrollAddress(y);\n    return vsp;\n  #endif\n}", "CodeBleu_score": 17.914613095964377}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tft.get_y();\n  tft.fillRect(0, y, tft.width(), tft.height() - y, color);\n  y = (y + tft.font_height() + tft.font_baseline()) % (tft.height() - tft.bottom_fixed_area());\n  if (tteBar) {\n    y = (y + tft.top_fixed_area_alt()) % (tft.height() - tft.bottom_fixed_area());\n  }\n  scrollAddress(y);\n  return y;\n}", "CodeBleu_score": 17.620132204420997}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tteY;\n  tft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n  tteY += tft.fontHeight();\n  if (tteY >= tft.height() - tft.fontHeight()) {\n    tteY = 0;\n    if (tteBar) {\n      tteY = tft.fontHeight();\n    }\n  }\n  scrollAddress(tteY);\n  return y;\n}", "CodeBleu_score": 16.136680917680813}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // set access points\n  if (!this->setAP(ssids, access_points)) {\n    return false;\n  }\n\n  // set HTML content\n  if (!this->setHtml()) {\n    return false;\n  }\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 75.10211382154785}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setAP()) {\n    return false;\n  }\n\n  if (!this->setHtml()) {\n    return false;\n  }\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 61.493997265156075}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // set AP\n  this->setAP(ssids, access_points);\n\n  // set HTML\n  this->setHtml();\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 55.49103276207064}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t  if (this->queue_enabled_flag) {\n    if (this->queue == NULL) {\n      this->queue = xQueueCreate(this->queue_size, sizeof(char *));\n      this->text = (char *)malloc(this->queue_size);\n      this->text_in = (char *)malloc(this->queue_size);\n    }\n  } else {\n    this->flush_queue();\n    this->queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 28.785742688239473}, {"code": "void GpsInterface::enable_queue(){\n\t    if (queue_enabled_flag) {\n        if (text_in == NULL) {\n            text_in = new char[queue_length];\n        }\n        if (text == NULL) {\n            text = new char[queue_length];\n        }\n        if (queue == NULL) {\n            queue = new char[queue_length];\n        }\n    } else {\n        this->flush_queue();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 24.698200343977945}, {"code": "void GpsInterface::enable_queue(){\n\t    if (queue_enabled_flag == true) {\n        if (queue == NULL) {\n            queue = xQueueCreate(queue_size, sizeof(char));\n        }\n        if (text == NULL) {\n            text = (char *)malloc(sizeof(char) * text_size);\n        }\n        if (text_in == NULL) {\n            text_in = (char *)malloc(sizeof(char) * text_size);\n        }\n    } else {\n        flush_queue();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 13.400335410879865}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue) {\n    if (this->queue->size > 0) {\n      this->new_queue = xQueueCreate(this->queue->size, sizeof(char*));\n      vQueueDelete(this->queue);\n      this->queue = this->new_queue;\n      this->new_queue = NULL;\n    } else {\n      this->new_queue = xQueueCreate(10, sizeof(char*));\n      this->queue = this->new_queue;\n      this->new_queue = NULL;\n    }\n  } else {\n    this->new_queue = xQueueCreate(10, sizeof(char*));\n    this->queue = this->new_queue;\n    this->new_queue = NULL;\n  }\n}", "CodeBleu_score": 41.05773131322889}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        if (this->queue->size > 0) {\n            this->new_queue = new Queue<char*>();\n            delete this->queue;\n            this->queue = this->new_queue;\n        }\n    } else {\n        this->new_queue = new Queue<char*>();\n        this->queue = this->new_queue;\n    }\n}", "CodeBleu_score": 22.041306750141455}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue_nmea) {\n    if (this->queue_nmea->size()) {\n      this->new_queue_nmea = new Queue<char>(this->queue_nmea->size());\n      delete this->queue_nmea;\n      this->queue_nmea = this->new_queue_nmea;\n      this->new_queue_nmea = NULL;\n    }\n  } else {\n    this->queue_nmea = new Queue<char>(this->queue_nmea_size);\n  }\n}", "CodeBleu_score": 23.56895009700463}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    display_obj.tft.startWrite();\n    lv_disp_flush_ready(disp);\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        display_obj.tft.writeColor(color_p->full, true);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n  }", "CodeBleu_score": 67.71897975860259}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    display_obj.tft.startWrite();\n    lv_disp_flush_ready(disp);\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        lv_color_t color = color_p[y * LV_HOR_RES + x];\n        display_obj.tft.writeColor(color.full, true);\n      }\n    }\n    display_obj.tft.endWrite();\n  }", "CodeBleu_score": 68.00809233316379}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t  // Start a write operation\n  display_obj.tft.startWrite();\n\n  // Set the address window for the specified area\n  display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n  // Iterate through each pixel in the area\n  for (int y = area->y1; y <= area->y2; y++) {\n    for (int x = area->x1; x <= area->x2; x++) {\n      // Get the color of the current pixel from the color buffer\n      lv_color_t color = color_p[y * disp->hor_res + x];\n\n      // Write the color to the display\n      display_obj.tft.writeColor(color.full);\n    }\n  }\n\n  // End the write operation\n  display_obj.tft.endWrite();\n\n  // Notify that the display flush is complete\n  lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 68.80211137514098}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  Serial.print(F(\"List of menu items:\"));\n  Serial.println();\n  for (int i = 0; i < menu->list->size(); i++) {\n    for (int j = 0; j < layer; j++) {\n      Serial.print(F(\"  \"));\n    }\n    Serial.print(menu->list->get(i)->name);\n    Serial.println();\n  }\n  Serial.println();\n}", "CodeBleu_score": 67.44168977092215}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  for (int i = 0; i < menu->list->size; i++) {\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\"  \");\n    }\n    Serial.println(menu->list->get(i)->name);\n  }\n  Serial.println();\n}", "CodeBleu_score": 66.99464813498814}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  if (menu->list->size > 0) {\n    for (int i = 0; i < menu->list->size; i++) {\n      for (int j = 0; j < layer; j++) {\n        Serial.print(\"  \");\n      }\n      Serial.println(menu->list->get(i)->name);\n    }\n  }\n  Serial.println();\n}", "CodeBleu_score": 66.73615305533896}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  int generated = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += (char)random(65, 90);\n    }\n    int channel = random(1, 14);\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += String(random(0, 255), HEX);\n      if (j < 5) {\n        mac += \":\";\n      }\n    }\n    ssids->add(new SSID(ssid, channel, mac));\n    Serial.println(ssids->get(generated)->getSSID() + \" \" + ssids->get(generated)->getChannel() + \" \" + ssids->get(generated)->getMAC());\n    generated++;\n  }\n  return generated;\n}", "CodeBleu_score": 43.115628068471125}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  ssids = new List<String>();\n  Serial.println(\"Generating \" + String(count) + \" SSIDs...\");\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += char(random(97, 122));\n    }\n    ssids->add(ssid);\n    Serial.println(\"Generated SSID: \" + ssid);\n  }\n  return count;\n}", "CodeBleu_score": 40.508457358810546}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int ssidCount = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += char(random(65, 91));\n    }\n    int channel = random(1, 13);\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += String(random(0, 256), HEX);\n      if (j < 5) {\n        mac += \":\";\n      }\n    }\n    ssids->add(new SSID(ssid, channel, mac));\n    Serial.println(\"SSID: \" + ssid + \" Channel: \" + channel + \" MAC: \" + mac);\n    ssidCount++;\n  }\n  return ssidCount;\n}", "CodeBleu_score": 43.41557921497132}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Create a timestamp in seconds since the epoch.\n    now = datetime.datetime.utcnow()\n    # Add five minutes to the current time for the expiration time.\n    expires_in = now + datetime.timedelta(minutes=60)\n\n    # Prepare the payload with the claims.\n    payload = {\n        'iat': now,\n        'exp': expires_in,\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Use the private key to generate the JWT.\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n\n    return encoded_jwt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 55.843827118812015}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Create a JWT to establish an authenticated session to the Google API.\n    iat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(minutes=60)\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private_key_file {}'.format(\n        algorithm, private_key_file))\n\n    additional_headers = {\n        'kid': private_key_id\n    }\n\n    jwt = jwt.encode(\n        payload,\n        private_key,\n        algorithm=algorithm,\n        headers=additional_headers)\n\n    print('JWT created successfully')\n    return jwt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 63.254171999888}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Create a timestamp in UTC\n    iat = datetime.datetime.utcnow()\n    # Set the expiration time to one hour from now\n    exp = iat + datetime.timedelta(hours=1)\n\n    # Create a payload with the issued time, expiration time, and audience\n    payload = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": project_id\n    }\n\n    # Read the private key from the specified file\n    with open(private_key_file, \"rb\") as f:\n        private_key = f.read()\n\n    # Create the JWT using the specified algorithm\n    jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n\n    return jwt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 49.786560628721624}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        str(message.payload), message.topic, str(message.qos)))\n    if str(message.payload) == \"on\":\n        print(\"Capturing image\")\n        preview_capture('image.jpg')\n        print(\"Uploading image\")\n        url = upload_file('image.jpg', args.bucket_name)\n        print(\"Publishing image url\")\n        client.publish(\n            \"events/{}\".format(args.device_id),\n            payload=url,\n            qos=1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 43.424194534578305}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        preview_capture(PREVIEW_PATH)\n        url = upload_file(PREVIEW_PATH, BUCKET_NAME)\n        client.publish(EVENT_TOPIC, payload=url, qos=1)\n        print('Published \\'{}\\' to \\'{}\\''.format(url, EVENT_TOPIC))\n    else:\n        print('Received message with unknown payload: {}'.format(message.payload))\n\n", "CodeBleu_score": 35.612692671466704}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message from \\'{}\\' topic=\\'{}\\': {}'.format(\n        message.topic, message.qos, message.payload))\n    if message.payload == 'on':\n        path = '/tmp/capture.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        client.publish('events', payload='{}'.format(url), qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 31.75908147162009}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description='Google Cloud IoT MQTT device connection code example.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--subscription_name',\n        default='my-subscription',\n        help='Cloud IoT Core subscription name.')\n    parser.add_argument(\n        '--algorithm',\n        choices=['RS256'],\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to receive.')\n    parser.add_argument(\n        '--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument(\n        '--registry_id', default='my-registry', help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--device_id', default='my-device', help='Cloud IoT Core device id')\n    parser.add_argument(\n        '--private_key_file',\n        default='rsa_private.pem',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--client_email',\n        default='cloud-iot@PROJECT_ID.iam.gserviceaccount.com',\n        help='Service account email associated with the device.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help=('Expiration time, in minutes, for JWT tokens.'", "CodeBleu_score": 42.70446156693305}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection code.')\n    parser.add_argument('--project_id', required=False, default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n                        help='GCP cloud project name.')\n    parser.add_argument('--subscription_name', required=True,\n                        help='Cloud Pub/Sub subscription name.')\n    parser.add_argument('--registry_id', required=True,\n                        help='Cloud IoT registry id.')\n    parser.add_argument('--device_id', required=True,\n                        help='Cloud IoT device id.')\n    parser.add_argument('--private_key_file', required=True,\n                        help='Path to private key file.')\n    parser.add_argument('--algorithm', required=False,\n                        help='The encryption algorithm to use to generate the JWT.', choices=('RS256', 'ES256'), default='RS256')\n    parser.add_argument('--ca_certs', required=False,\n                        help='Path to root CA file.')\n    parser.add_argument('--num_messages', type=int, required=False,\n                        help='Number of messages to receive.', default=100)\n    parser.add_argument('--cloud_region', required=False,\n                        help='GCP cloud region', default='us-central1')\n    parser.add_argument('--jwt_expires_minutes', type=int, required=False,\n                        help='Expiration time, in minutes, for JWT tokens.', default=20)\n    parser.add_argument('--use_http', required=False,\n                        help='Use HTTP instead of MQTT for communication with IoT Core.', action='store_true')\n    parser.add_argument('--mqtt_bridge_hostname', required=False,\n                        help='MQTT bridge hostname.', default='mqtt.googleapis.com')\n    parser.add_argument('--mqtt_bridge_port',", "CodeBleu_score": 42.90583317778098}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection code.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--subscription',\n        default='projects/{}/subscriptions/{}'.format(\n            os.environ.get('GOOGLE_CLOUD_PROJECT'),\n            os.environ.get('SUBSCRIPTION_NAME')),\n        required=True,\n        help='Cloud IoT Core subscription name.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to receive.')\n    parser.add_argument(\n        '--cloud_region',\n        default=os.environ.get('CLOUD_REGION'),\n        help='GCP cloud region')\n    parser.add_argument(\n        '--registry_id',\n        default=os.environ.get('REGISTRY_ID'),\n        help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--device_id',\n        default=os.environ.get('DEVICE_ID'),\n        help='Cloud IoT Core device id')\n    parser.add_argument(\n        '--private_key_file',\n        default='rsa_private.pem',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--client_email',\n        default", "CodeBleu_score": 44.11351802901139}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Define the API scope for Cloud IoT Core\n    api_scope = 'https://www.googleapis.com/auth/cloud-platform'\n    # Define the API version and discovery URL for Cloud IoT Core\n    api_version = 'v1'\n    discovery_url = ('https://cloudiot.googleapis.com/$discovery/rest')\n    # Load the service account credentials from the JSON file\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    # Scope the credentials to the API scope\n    scoped_credentials = credentials.with_scopes([api_scope])\n    # Build the client using the scoped credentials and the discovery URL\n    return discovery.build('cloudiot', api_version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 36.5656424051411}, {"code": "def get_client(service_account_json)\n\t\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n    API_VERSION = 'v1'\n    DISCOVERY_URL = ('https://cloudiot.googleapis.com/$discovery/rest')\n\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(SCOPES)\n    http = scoped_credentials.authorize(httplib2.Http())\n    service = discovery.build('cloudiot', API_VERSION, http=http, discoveryServiceUrl=DISCOVERY_URL)\n    return service\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 43.998993004191746}, {"code": "def get_client(service_account_json)\n\t\n    # Define the API scopes to use\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    # Define the API version to use\n    api_version = 'v1'\n    # Define the API discovery URL\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    # Load the service account credentials from the JSON file\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n    # Build the client using the credentials and discovery URL\n    client = discovery.build('cloudiot', api_version, credentials=credentials, discoveryServiceUrl=discovery_url)\n    # Return the client\n    return client\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 22.204807315160203}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = hash_method.asn1_code\n    if asn1_code == b'':\n        raise ValueError('Invalid hash method')\n    message = b''.join([asn1_code, hash_value])\n    padded_message = _pad_for_signing(message, 256)\n    return priv_key.blinded_encrypt(padded_message)\n\n\n", "CodeBleu_score": 24.295217417065494}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    # Retrieve the ASN1 code for the hash method\n    asn1_code = _hash_method_to_asn1_code(hash_method)\n\n    # Check if the hash method is invalid\n    if asn1_code is None:\n        raise ValueError('invalid hash method: %s' % hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    block = asn1_code + hash_value\n\n    # Pad the result for signing\n    block = _pad_for_signing(block, 128)\n\n    # Encrypt the padded hash using the private key\n    encrypted_signature = priv_key.blinded_encrypt(block)\n\n    # Return the encrypted signature as a byte block\n    return encrypted_signature\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 32.867326131991135}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    # Retrieve the ASN1 code for the hash method\n    asn1_code = hash_method.asn1_code\n\n    # Raise an error if the hash method is invalid\n    if asn1_code is None:\n        raise ValueError('Unknown hash method: %s' % hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    hash_value_with_code = asn1_code + hash_value\n\n    # Pad the result for signing\n    padded_hash = _pad_for_signing(hash_value_with_code,\n                                   common.byte_size(priv_key.n))\n\n    # Encrypt the padded hash using the private key\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash)\n\n    # Return the encrypted signature as a byte block\n    return transform.int2bytes(encrypted_signature,\n                               common.byte_size(priv_key.n))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 43.3273092430277}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    signature = transform.bytes2int(signature)\n    clearsig = core.decrypt_int(signature, pub_key)\n    hashmethod = _find_method_hash(clearsig)\n    hash_ = compute_hash(message, hashmethod)\n    padded_hash = transform.int2bytes(clearsig, common.byte_size(hash_))\n    if padded_hash != hash_:\n        raise VerificationError('Verification failed')\n    return hashmethod", "CodeBleu_score": 20.781434379970516}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt the integer using the public key\n    clear_signature = core.decrypt_int(signature_int, pub_key)\n\n    # Find the hash method used\n    hash_method = _find_method_hash(clear_signature)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(message_hash, common.byte_size(signature))\n\n    # Compare the expected padded hash with the clear signature\n    if expected_padded_hash != clear_signature:\n        raise VerificationError('Verification failed')\n\n    return hash_method", "CodeBleu_score": 22.865593843079505}, {"code": "def verify(message, signature, pub_key)\n\t\n    clearsig = transform.bytes2int(signature)\n    decrypted = core.decrypt_int(clearsig, pub_key)\n    hashname = _find_method_hash(decrypted)\n    hash = compute_hash(message, hashname)\n    padded_hash = _pad_for_signing(hash, common.byte_size(signature))\n    if padded_hash != decrypted:\n        raise VerificationError('Verification failed')\n    return hashname\n", "CodeBleu_score": 22.055560517761386}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t    // Get current time\n    uint32_t epoch = time(NULL);\n    debug_printInfo(\"MQTT: Current time: %s\", ctime(&epoch));\n\n    // Update JWT\n    if (epoch > 0) {\n        updateJWT(epoch);\n    } else {\n        debug_printError(\"MQTT: Failed to retrieve time\");\n        return;\n    }\n\n    // Connect to MQTT client\n    if (MQTT_CLIENT_connect(mqttBroker, mqttPort, mqttClientId, mqttUsername, mqttPassword, mqttTopic, mqttPublishTopic, mqttSubscribeTopic, mqttPublishQoS, mqttSubscribeQoS, mqttKeepAliveInterval, mqttMaxInFlightMessages) == 0) {\n        debug_printInfo(\"MQTT: Connected to %s:%d\", mqttBroker, mqttPort);\n        mqttConnected = true;\n        mqttSubscribe = true;\n    } else {\n        debug_printError(\"MQTT: Failed to connect to %s:%d\", mqttBroker, mqttPort);\n        mqttConnected = false;\n        mqttSubscribe = false;\n    }\n}", "CodeBleu_score": 46.87326166999679}, {"code": "static void connectMQTT(){\n\t   uint32_t epoch = time(NULL);\n   if (epoch > 0) {\n      updateJWT(epoch);\n   }\n\n   if (MQTT_CLIENT_connect(mqttBroker, mqttPort, mqttTopic, cid, mqttPassword, MQTT_QOS_AT_MOST_ONCE, MQTT_KEEP_ALIVE_INTERVAL_SECONDS) != MQTT_CLIENT_SUCCESS) {\n      debug_printError(\"MQTT: Unable to connect to broker\");\n   }\n   else {\n      debug_printInfo(\"MQTT: Connected to broker\");\n      sendSubscribe = true;\n   }\n}", "CodeBleu_score": 54.633384018298756}, {"code": "static void connectMQTT(){\n\t   uint32_t epoch = time(NULL);\n   if (epoch > 0) {\n      updateJWT(epoch);\n      MQTT_CLIENT_connect();\n      mqtt_subscribe_flag = true;\n      debug_printInfo(\"MQTT: Attempting to connect to %s:%d\", mqttServer, mqttPort);\n   }\n}", "CodeBleu_score": 56.77684358493196}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t val = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (!isdigit(str[i])) {\n            return str;\n        }\n        val = val * 10 + (str[i] - '0');\n        if (val > 0xFFFFFFFF) {\n            return str;\n        }\n    }\n    *num = val;\n    return str + width;\n}", "CodeBleu_score": 30.10778823954713}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t  uint32_t value = 0;\n  int i;\n  for (i = 0; i < width; i++) {\n    if (!isdigit(str[i])) {\n      return str;\n    }\n    value = value * 10 + (str[i] - '0');\n    if (value > 0xFFFFFFFF) {\n      return str;\n    }\n  }\n  *num = value;\n  return str + i;\n}", "CodeBleu_score": 28.636272909068445}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        n = n * 10 + (str[i] - '0');\n    }\n    *num = n;\n    return str + i;\n}", "CodeBleu_score": 25.977155755659947}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    atcacert_get_signature(cert_def, cert, cert_size, signature);\n\n    return atcab_verify_extern(ca_public_key, tbs_digest, signature);\n}", "CodeBleu_score": 42.64779638665802}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    int ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    return atcab_verify_extern(ca_public_key, tbs_digest, signature);\n}", "CodeBleu_score": 62.23806191734037}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t  // Check for null parameters\n  if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n    return ATCA_BAD_PARAM;\n  }\n\n  // Get the digest of the certificate's to-be-signed (TBS) portion\n  uint8_t tbs_digest[32];\n  int     ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n  if (ret != ATCA_SUCCESS) {\n    return ret;\n  }\n\n  // Get the certificate's signature\n  uint8_t signature[64];\n  ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n  if (ret != ATCA_SUCCESS) {\n    return ret;\n  }\n\n  // Verify the TBS digest against the signature using the CA public key\n  ret = atcab_verify_extern(ca_public_key, tbs_digest, signature);\n  if (ret != ATCA_SUCCESS) {\n    return ret;\n  }\n\n  return ATCA_SUCCESS;\n}", "CodeBleu_score": 67.4893029618428}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if(list == NULL || timer == NULL)\n    {\n        return false;\n    }\n\n    if(*list == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *prev = *list;\n    while(prev->next != NULL)\n    {\n        if(prev->next == timer)\n        {\n            prev->next = timer->next;\n            return true;\n        }\n        prev = prev->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 33.43337105699664}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if (timer == NULL)\n        return false;\n\n    if (timer == *list)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *prev = *list;\n    while (prev->next != timer)\n    {\n        if (prev->next == NULL)\n            return false;\n        prev = prev->next;\n    }\n\n    prev->next = timer->next;\n    return true;\n}", "CodeBleu_score": 32.08101097109788}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t *volatile *prev = list;\n\n    while (*prev != timer)\n    {\n        prev = &(*prev)->next;\n    }\n\n    *prev = timer->next;\n\n    return true;\n}", "CodeBleu_score": 16.379338830841828}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t    int result = BSD_ERROR;\n    tstrSocket *pstrSocket = NULL;\n    sint8 s8Ret = SOCK_ERR_INVALID_ARG;\n\n    pstrSocket = getSocketInfo(socket);\n    if (pstrSocket != NULL) {\n        pstrSocket->bIsUsed = 0;\n        pstrSocket->u16SessionID = 0;\n        s8Ret = close(socket);\n        if (s8Ret == SOCK_ERR_NO_ERROR) {\n            result = BSD_SUCCESS;\n        } else {\n            bsd_setErrNo(BSD_EBADF);\n        }\n    } else {\n        bsd_setErrNo(BSD_EBADF);\n    }\n    return result;\n}", "CodeBleu_score": 39.50460732547006}, {"code": "int BSD_close(int socket){\n\t    int status;\n    tstrSocket *psocket = BSD_getSocketInfo(socket);\n    if (psocket == NULL) {\n        bsd_setErrNo(BSD_EBADF);\n        return BSD_ERROR;\n    }\n    status = close(socket);\n    if (status != BSD_SUCCESS) {\n        bsd_setErrNo(BSD_EBADF);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 34.27256248325929}, {"code": "int BSD_close(int socket){\n\t    int ret;\n    bsdErrno_t errorNumber;\n\n    bsd_getSocketInfo(socket);\n    if (bsdSocketInfo.state != NOT_A_SOCKET) {\n        bsdSocketInfo.state = NOT_A_SOCKET;\n        ret = close(socket);\n        if (ret == -1) {\n            errorNumber = errno;\n            bsd_setErrNo(errorNumber);\n            return BSD_ERROR;\n        }\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 37.07308143680784}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t", "CodeBleu_score": 4.893994777977414}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint\t\tiRet = BSD_ERROR;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\tsint8\ts8Ret = listen(socket, backlog);\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(s8Ret);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tiRet = BSD_SUCCESS;\n\t\t}\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(BSD_EBADF);\n\t}\n\treturn iRet;\n}", "CodeBleu_score": 29.569890416326572}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint\t\tiRet = BSD_ERROR;\n\tbsdErrno_t\tbsdErrorNumber;\n\n\tbsdErrorNumber = BSD_listen(socket, backlog);\n\tif (bsdErrorNumber != BSD_SUCCESS) {\n\t\tbsd_setErrNo(bsdErrorNumber);\n\t}\n\telse {\n\t\tiRet = BSD_SUCCESS;\n\t}\n\treturn iRet;\n}", "CodeBleu_score": 31.273285489027323}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret = BSD_SOCK_ERR_INVALID_ARG;\n\n    if (socket >= 0 && (gastrSockets[socket].bIsUsed == 1)) {\n        if (addr != NULL && addrlen != NULL) {\n            switch (addr->sa_family) {\n                case AF_INET: {\n                    struct sockaddr_in *sin = (struct sockaddr_in *) addr;\n                    ret = accept(socket, (struct sockaddr *) sin, addrlen);\n                    if (ret == SOCK_ERR_NO_ERROR) {\n                        ret = BSD_SOCK_ERR_NO_ERROR;\n                    } else {\n                        bsd_setErrNo(ret);\n                        ret = BSD_SOCK_ERR_ACCEPT;\n                    }\n                    break;\n                }\n                case AF_INET6: {\n                    struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) addr;\n                    ret = accept(socket, (struct sockaddr *) sin6, addrlen);\n                    if (ret == SOCK_ERR_NO_ERROR) {\n                        ret = BSD_SOCK_ERR_NO_ERROR;\n                    } else {\n                        bsd_setErrNo(ret);\n                        ret = BSD_SOCK_ERR_ACCEPT;\n                    }\n                    break;\n                }\n                default: {\n                    bsd_setErrNo(SOCK_ERR_INVALID_ARG);\n                    ret = BSD_SOCK_ERR_INVALID_ARG;\n                    break;\n                }\n            }\n        } else {\n            bsd_setErrNo(SOCK_ERR_INVALID_ARG);\n            ret = BSD_SOCK_ERR_INVALID_ARG;\n        }\n    } else {\n        bsd_setErrNo(SOCK_ERR_INVALID_ARG);\n        ret = BSD_SOCK_ERR_INVALID_ARG;\n    }\n    return ret;\n}", "CodeBleu_score": 42.47283259161141}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t   time_t t = time(NULL);\n   if (t != -1) {\n      uint32_t epoch = t + UNIX_OFFSET;\n      updateJWT(epoch);\n      if (mqttClient.connect(cid, mqttUsername, mqttPassword)) {\n         debug_printInfo(\"MQTT: Connected\");\n         mqttClient.publish(mqttTopic, \"{\\\"type\\\":\\\"connect\\\",\\\"data\\\":\\\"Connected\\\"}\");\n         mqttClient.subscribe(mqttTopic);\n         mqttClient.setCallback(mqttCallback);\n      }\n      else {\n         debug_printInfo(\"MQTT: Connection failed\");\n      }\n   }\n   else {\n      debug_printInfo(\"MQTT: Time not valid\");\n   }\n}", "CodeBleu_score": 45.890443566309514}, {"code": "static void connectMQTT(){\n\t  time_t t = time(NULL);\n  if (t < UNIX_OFFSET) {\n    debug_printError(\"Invalid time: %s\", ctime(&t));\n    return;\n  }\n\n  uint32_t epoch = t + UNIX_OFFSET;\n  updateJWT(epoch);\n\n  debug_printInfo(\"MQTT: Connecting to %s\", mqttServer);\n  MQTT_CLIENT_connect(mqttServer, mqttPort, 0, 0);\n  sendMQTTSubscribe = true;\n}", "CodeBleu_score": 49.013960728257025}, {"code": "static void connectMQTT(){\n\t    time_t now;\n    time(&now);\n    if (now < 0) {\n        debug_printError(\"MQTT: invalid time\");\n        return;\n    }\n    uint32_t epoch = now + UNIX_OFFSET;\n    updateJWT(epoch);\n    debug_printInfo(\"MQTT: Connecting to %s\", mqttServer);\n    MQTT_CLIENT_connect(mqttServer, mqttPort, cid, mqttTopic, mqttPassword);\n    sendSubscribe = true;\n}", "CodeBleu_score": 51.13272165460736}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t   if (mqttState == CONNECTED) {\n      mqttContext *connectionInfo = MQTT_GetClientConnectionInfo();\n\n      debug_printError(CLOUD_DISCONNECT_MSG);\n\n      MQTT_Disconnect(connectionInfo);\n   }\n}", "CodeBleu_score": 53.60071842960576}, {"code": "void CLOUD_disconnect(void){\n\t   mqttCurrentState = MQTT_Disconnect(&mqttContext);\n   debug_printError(MQTT_GetConnectionState());\n}", "CodeBleu_score": 22.500339628179223}, {"code": "void CLOUD_disconnect(void){\n\t   mqttCurrentState = MQTT_Disconnect(&mqttConnectionInfo);\n   debug_printError(\"Disconnected from cloud\");\n}", "CodeBleu_score": 19.293242496025194}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    if (passed_wifi_creds == 1) {\n        if (m2m_wifi_connect(ssid, strlen(ssid), M2M_WIFI_SEC_TYPE_WPA_WPA2_PSK, auth_info, 0) != M2M_SUCCESS) {\n            debug_printError(\"wifi_connectToAp: m2m_wifi_connect failed\");\n            networking_error = true;\n            return false;\n        }\n    } else {\n        if (m2m_wifi_default_connect() != M2M_SUCCESS) {\n            debug_printError(\"wifi_connectToAp: m2m_wifi_default_connect failed\");\n            networking_error = true;\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 42.98602213372972}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    if (passed_wifi_creds) {\n        // Connect to the Wi-Fi network using the passed credentials\n        if (m2m_wifi_connect(wifi_ssid, strlen(wifi_ssid), WIFI_SECURITY_WPA2_AES, wifi_password, 0) < 0) {\n            debug_printError(\"Failed to connect to Wi-Fi network\");\n            network_error_status = true;\n            return false;\n        }\n    } else {\n        // Connect to the Wi-Fi network using the default credentials\n        if (m2m_wifi_default_connect() < 0) {\n            debug_printError(\"Failed to connect to Wi-Fi network\");\n            network_error_status = true;\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 42.9671877214059}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    char ssid[32] = {0};\n    uint8_t ssid_len = 0;\n    uint8_t sec_type = 0;\n    uint8_t auth_info[64] = {0};\n    uint16_t channel = 0;\n    uint8_t ret = 0;\n    uint8_t i = 0;\n\n    if (passed_wifi_creds) {\n        ssid_len = strlen(wifi_ssid);\n        sec_type = wifi_sec_type;\n        if (sec_type == WIFI_SEC_TYPE_WPA_WPA2_PSK) {\n            strcpy(auth_info, wifi_pass);\n        }\n        channel = wifi_channel;\n    }\n\n    if (passed_wifi_creds) {\n        ret = m2m_wifi_connect(ssid, ssid_len, sec_type, auth_info, channel);\n    } else {\n        ret = m2m_wifi_default_connect();\n    }\n\n    if (ret != M2M_SUCCESS) {\n        debug_printError(\"wifi_connectToAp\", ret);\n        set_networking_error_status(NETWORKING_ERROR_STATUS_WIFI_CONNECT);\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 49.251311213497964}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t", "CodeBleu_score": 0.7730807380978455}, {"code": "async function DisplaySensors(map){\n\t  const client = generateClient()\n  const response = await client.graphql(CreateSensorMarker)\n  console.log(response)\n  if (response.data.listSensors) {\n    console.log(\"Retrieval of sensors\")\n    response.data.listSensors.forEach((sensor) => {\n      const marker = document.createElement(\"div\")\n      new Marker({element: marker})\n                        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                        .addTo(map)\n    })\n  }\n}", "CodeBleu_score": 55.35103652903837}, {"code": "async function DisplaySensors(map){\n\t  const client = generateClient();\n  const response = await client.graphql(CreateSensorMarker);\n  console.log(response);\n  if (response.data.listSensors) {\n    console.log(\"Retrieval of sensors\");\n    response.data.listSensors.forEach((sensor) => {\n      const marker = document.createElement(\"div\");\n      marker.className = \"marker\";\n      new Marker({ element: marker })\n        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n        .addTo(map);\n    });\n  }\n}", "CodeBleu_score": 55.882490120980165}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.backgroundColor = \"rgba(255, 0, 0, 0.5)\";\n    marker.style.border = \"1px solid black\";\n    marker.style.borderRadius = \"50%\";\n    marker.style.width = \"10px\";\n    marker.style.height = \"10px\";\n    marker.style.position = \"absolute\";\n    marker.style.left = \"50%\";\n    marker.style.top = \"50%\";\n    marker.style.transform = \"translate(-50%, -50%)\";\n    return marker;\n}", "CodeBleu_score": 42.30397928801119}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.backgroundColor = \"#000000\";\n    marker.style.border = \"2px solid #000000\";\n    return marker;\n}", "CodeBleu_score": 44.372130140399406}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.backgroundColor = \"rgba(255, 0, 0, 0.5)\";\n    marker.style.border = \"2px solid white\";\n    return marker;\n}", "CodeBleu_score": 45.64870040672492}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to load multi-factor authentication module %s: %s\",\n            module_path,\n            err,\n        )\n        raise HomeAssistantError(\n            \"Unable to load multi-factor authentication module\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not hass.config.skip_pip:\n            processed = hass.data.setdefault(DATA_PROCESSED_REQUIREMENTS, set())\n            if module_name not in processed:\n                requirements = getattr(module, \"REQUIREMENTS\")\n                requirements = requirements_async_process_requirements(\n                    hass, requirements\n                )\n                for requirement in requirements:\n                    await hass.async_add_executor_job(\n                        _install_requirement, hass, requirement\n                    )\n                processed.add(module_name)\n\n    return module\n\n", "CodeBleu_score": 52.30620846503731}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    module = await async_import_module(hass, module_path)\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    requirements = module.REQUIREMENTS\n    if hass.config.skip_pip:\n        return module\n\n    if not requirements:\n        return module\n\n    if module_name in requirements.async_process_requirements:\n        return module\n\n    requirements.async_process_requirements.add(module_name)\n    try:\n        await hass.async_add_executor_job(\n            requirements.process, hass, module_name, module_path\n        )\n    except Exception as exc:\n        _LOGGER.error(\n            \"Error processing requirements for %s: %s\", module_name, exc\n        )\n        raise HomeAssistantError(\n            \"Error processing requirements for %s\" % module_name\n        ) from exc\n\n    return module", "CodeBleu_score": 47.1844557602362}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Failed to import module '%s': %s\", module_path, err.msg\n        )\n        raise HomeAssistantError(\n            \"Failed to import module '%s': %s\" % (module_path, err.msg)\n        ) from err\n    if (\n        hasattr(module, \"REQUIREMENTS\")\n        and not hass.config.skip_pip\n        and not hass.data.get(DATA_REQUIREMENTS_PROCESSED, set()).__contains__(\n            module_name\n        )\n    ):\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, module_name\n        )\n        hass.data[DATA_REQUIREMENTS_PROCESSED].add(module_name)\n    return module", "CodeBleu_score": 46.620202360257935}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[CONF_PIN]\n    if user_id in self._data:\n        self._data[user_id] = pin\n    else:\n        self._data.append({CONF_USER_ID: user_id, CONF_PIN: pin})\n    return True\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 31.304187634428203}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not setup_data:\n        raise InvalidAuthData(\"No setup data provided\")\n    if not isinstance(setup_data, dict):\n        raise InvalidAuthData(\"Setup data must be a dictionary\")\n    if \"pin\" not in setup_data:\n        raise InvalidAuthData(\"PIN not provided\")\n    if not isinstance(setup_data[\"pin\"], str):\n        raise InvalidAuthData(\"PIN must be a string\")\n    if len(setup_data[\"pin\"]) != 6:\n        raise InvalidAuthData(\"PIN must be 6 digits\")\n    if not user_id:\n        raise InvalidAuthData(\"User ID not provided\")\n    if not isinstance(user_id, str):\n        raise InvalidAuthData(\"User ID must be a string\")\n    if not user_id.isalnum():\n        raise InvalidAuthData(\"User ID must be alphanumeric\")\n    if not user_id.isascii():\n        raise InvalidAuthData(\"User ID must be ASCII\")\n    if not user_id.islower():\n        raise InvalidAuthData(\"User ID must be lowercase\")\n    if not user_id.isprintable():\n        raise InvalidAuthData(\"User ID must be printable\")\n    if not user_id.isidentifier():\n        raise InvalidAuthData(\"User ID must be a valid identifier\")\n    if not user_id.isdecimal():\n        raise InvalidAuthData(\"User ID must be a decimal\")\n    if not user_id.isnumeric():\n        raise InvalidAuthData(\"User ID must be numeric\")\n    if not user_id.isdigit():\n        raise InvalidAuthData(\"User ID must be a digit\")\n    if not user_id.isascii():\n        raise InvalidAuthData(\"User ID must be ASCII\")\n    if not user_id.isalpha():\n        raise InvalidAuthData(\"User ID must be alphabetic\")\n    if not user_id.isalnum():\n        raise InvalidAuthData(\"User ID must be alphanumeric\")\n    if not user_id.isdecimal():\n        raise InvalidAuthData(\"User ID must be a decimal\")\n    if not user_id.isnumeric():\n        raise", "CodeBleu_score": 29.86937020071423}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[CONF_PIN]\n    if (entry := await self.async_get_entry(user_id)) is None:\n        self._data[user_id] = pin\n        self.async_create_entry(user_id, setup_data)\n    else:\n        self._data[user_id] = pin\n        self.async_update_entry(entry, setup_data)\n    return {}\n\n\n\n\n", "CodeBleu_score": 27.783506953926345}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        if not (data := await self._store.async_load()):\n            self._user_settings = {}\n            return\n\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id,\n                data[user_id].get(\"enabled\", True),\n                data[user_id].get(\"name\", UNDEFINED),\n                data[user_id].get(\"email\", UNDEFINED),\n                data[user_id].get(\"phone_number\", UNDEFINED),\n                data[user_id].get(\"message_limit\", UNDEFINED),\n                data[user_id].get(\"throttle\", UNDEFINED),\n            )\n            for user_id in data\n        }\n\n", "CodeBleu_score": 43.266485659717944}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n\n        if not (data := await self._store.async_load()):\n            self._data = {}\n            return\n\n        self._data = {\n            user_id: NotifySetting(\n                user_id,\n                data.get(user_id, {}).get(\"name\", user_id),\n                data.get(user_id, {}).get(\"language\", None),\n                data.get(user_id, {}).get(\"time_zone\", None),\n                data.get(user_id, {}).get(\"latitude\", None),\n                data.get(user_id, {}).get(\"longitude\", None),\n                data.get(user_id, {}).get(\"elevation\", None),\n                data.get(user_id, {}).get(\"radius\", None),\n                data.get(user_id, {}).get(\"currency\", None),\n                data.get(user_id, {}).get(\"country\", None),\n                data.get(user_id, {}).get(\"language\", None),\n                data.get(user_id, {}).get(\"time_zone\", None),\n                data.get(user_id, {}).get(\"latitude\", None),\n                data.get(user_id, {}).get(\"longitude\", None),\n                data.get(user_id, {}).get(\"elevation\", None),\n                data.get(user_id, {}).get(\"radius\", None),\n                data.get(user_id, {}).get(\"currency\", None),\n                data.get(user_id, {}).get(\"country\", None),\n                data.get(user_id, {}).get(\"language\", None),\n                data.get(user_id, {}).get(\"time_zone\", None),\n                data.get(user_id, {}).get(\"latitude\", None),\n                data.get(user_id, {}).get(\"longitude\", None),\n                data.get(user_id, {}).get(\"elevation\", None),\n                data.get(user_id, {}).get(\"radius\", None),\n                data.get", "CodeBleu_score": 22.887740210836284}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._store.async_load()\n        if not data:\n            self._user_settings = {}\n            return\n\n        self._user_settings = {\n            user: NotifySetting(\n                user,\n                data.get(user, {}).get(\"enabled\", True),\n                data.get(user, {}).get(\"message\", \"\"),\n            )\n            for user in data\n        }\n\n", "CodeBleu_score": 46.066781262207904}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n\n    settings = self._settings.get(user_id)\n    if settings is None:\n        return False\n\n    otp = user_input.get(CONF_OTP)\n    if otp is None:\n        return False\n\n    await async_add_executor_job(self._validate, otp, settings)\n    return True\n\n", "CodeBleu_score": 46.838498465652314}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load(user_id)\n    if not self._user_settings:\n        return False\n\n    return await async_add_executor_job(\n        self._user_settings.validate_otp, user_input.get(\"otp\")\n    )\n\n", "CodeBleu_score": 35.78603498139498}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user_settings(user_id)\n    settings = self.get_settings(user_id)\n    if not settings:\n        return False\n\n    return await self.hass.async_add_executor_job(\n        self.validate_otp, user_input.get(CONF_OTP), settings\n    )\n\n", "CodeBleu_score": 44.881519241891546}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    if not device_entry.area_id:\n        return None\n\n    area_id = device_entry.area_id\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 56.60292922750999}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)", "CodeBleu_score": 59.70125442276603}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.devices.get(entity.device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 57.559717143881485}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for key in p:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [p[key] for p in policies]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy\n\n", "CodeBleu_score": 52.04073876000037}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for source in policies:\n        if source is None:\n            continue\n\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in policies if isinstance(src, dict)]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy\n\n", "CodeBleu_score": 57.06995347400141}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n\n    for policy_ in policies:\n        for category, policy_category in policy_.items():\n            if category in seen:\n                continue\n            seen.add(category)\n\n            policy_sources = [policy_.get(category) for policy_ in policies]\n            policy[category] = _merge_policies(policy_sources)\n\n    return policy\n\n", "CodeBleu_score": 55.54142483209924}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = await async_import_module(hass, f\"auth_provider.{provider}\")\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a schema definition\"\n        )\n    if not hasattr(module, \"async_validate_config\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a validate_config function\"\n        )\n    if not hasattr(module, \"async_login_flow\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a login_flow function\"\n        )\n    if not hasattr(module, \"async_oauth_create_flow\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a oauth_create_flow function\"\n        )\n    if not hasattr(module, \"async_oauth_authorize_flow\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a oauth_authorize_flow function\"\n        )\n    if not hasattr(module, \"async_oauth_token_flow\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a oauth_token_flow function\"\n        )\n    if not hasattr(module, \"async_refresh_tokens\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a refresh_tokens function\"\n        )\n    if not hasattr(module, \"async_revoke_token\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a revoke_token function\"\n        )\n    if not hasattr(module, \"async_validate_login\"):\n        raise HomeAssistantError(\n            f\"auth_provider.{provider} does not have a validate_login function\"\n        )\n    if not hasattr(module, \"async_get_or_create_credentials\"):\n        raise HomeAssistant", "CodeBleu_score": 23.402740414108926}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = await async_import_module(hass, f\"homeassistant.auth.{provider}\")\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not requirements.async_process_requirements(\n        hass, module.REQUIREMENTS, processed\n    ):\n        _LOGGER.error(\n            \"Error while processing requirements for auth provider %s\", provider\n        )\n        raise HomeAssistantError(\n            f\"Error while processing requirements for auth provider {provider}\"\n        )\n    return module", "CodeBleu_score": 32.37159913999215}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"auth_provider.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.error(\n            \"Unable to load auth provider module for %s\",\n            provider,\n        )\n        raise HomeAssistantError(\n            f\"Unable to load auth provider module for {provider}\"\n        ) from None\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    requirements = module.REQUIREMENTS\n    if not requirements:\n        return module\n\n    if not hass.data.get(DATA_PROCESSED_REQUIREMENTS):\n        hass.data[DATA_PROCESSED_REQUIREMENTS] = set()\n    processed = hass.data[DATA_PROCESSED_REQUIREMENTS]\n    if processed.add(provider):\n        await requirements.async_process_requirements(hass)\n\n    return module", "CodeBleu_score": 51.22268214526502}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = {\"users\": []}\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data", "CodeBleu_score": 56.38042222988173}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password_hash\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n    raise InvalidAuth()\n\n", "CodeBleu_score": 32.32086167479682}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password_hash\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth\n    raise InvalidAuth", "CodeBleu_score": 36.766240112290234}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if not bcrypt.checkpw(password.encode(), user.password_hash.encode()):\n                raise InvalidAuth(\"Invalid username or password\")\n            return\n    raise InvalidAuth(\"Invalid username or password\")", "CodeBleu_score": 37.14129737545724}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == normalized_username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 29.48957709950361}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 29.89753697862173}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    if username in self.users:\n        self.users.pop(username)\n    else:\n        raise InvalidUser(\"user_not_found\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 25.7006858883171}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n\n    try:\n        self._data.pop(credentials.username)\n    except KeyError:\n        pass\n\n    await self.async_save()\n", "CodeBleu_score": 50.11066189779676}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except InvalidUser:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 47.5194388385599}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.username, None)\n        await self.async_save()\n    except Exception:\n        _LOGGER.exception(\"Error removing credentials\")", "CodeBleu_score": 45.624537974846646}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread.join(timeout)\n            if not thread.is_alive():\n                joined.add(thread)\n            elif thread.ident is None:\n                joined.add(thread)\n            elif log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n        else:\n            joined.add(thread)\n    for thread in threads - joined:\n        with contextlib.suppress(SystemExit):\n            async_raise(thread, SystemExit)\n    return joined\n\n", "CodeBleu_score": 48.92144601464115}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        thread_timeout = timeout\n        while thread.is_alive() and thread_timeout > 0:\n            thread_timeout -= 0.05\n            time.sleep(0.05)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            with contextlib.suppress(SystemExit):\n                async_raise(thread.ident, SystemExit)\n        joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 56.900517745785514}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        thread.join(timeout)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            thread.join()\n        joined.add(thread)\n    for thread in threads - joined:\n        try:\n            async_raise(thread.ident, SystemExit)\n        except (ValueError, SystemError):\n            pass\n    return joined\n\n", "CodeBleu_score": 54.986857634122856}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = threading.enumerate()\n    threads = [t for t in threads if not t.is_alive() or t.is_daemon() or t == threading.main_thread()]\n    if len(threads) > 1:\n        timeout = SHUTDOWN_TIMEOUT / (len(threads) - 1)\n        for thread in threads:\n            try:\n                thread.join(timeout=timeout)\n            except RuntimeError:\n                _LOGGER.warning(\"Failed to join thread %s\", thread.name)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 29.761626552018416}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Calculate the total timeout for the shutdown\n    total_timeout = _SHUTDOWN_TIMEOUT\n\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon and t.is_alive()]\n\n    # Calculate the timeout for each thread\n    timeout = total_timeout / len(threads)\n\n    # Join each thread within the calculated timeout and log a warning if joining fails\n    for t in threads:\n        t.join(timeout)\n        if not t.is_alive():\n            continue\n        _LOGGER.warning(\"Thread %s did not shut down within %s seconds, forcing shutdown\", t.name, timeout)\n        t.join()", "CodeBleu_score": 34.017481279962816}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Identify all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon and t.is_alive()]\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT_SECONDS / len(threads)\n    # Attempt to join each thread within the calculated timeout\n    for t in threads:\n        try:\n            t.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(f\"Failed to join thread {t.name}: {e}\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 30.4445673393167}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        async_dispatcher_send_internal(\n            self.hass,\n            f\"{DOMAIN}_{self.entry_id}_setup_started\",\n            remaining_with_setup_started,\n        )\n    self._previous_state = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 55.91715762093277}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        async_dispatcher_send_internal(\n            self.hass,\n            f\"{self._domain}_setup_remaining\",\n            remaining_with_setup_started,\n        )", "CodeBleu_score": 41.7830688063481}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._internal_flag:\n        async_dispatcher_send_internal(self.hass, SIGNAL_STATE_UPDATE)\n        self._internal_flag = bool(remaining_with_setup_started)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 53.39210801880414}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate and validate bluetooth.py content\n    generated_content = generate_and_validate(integrations)\n\n    # Read current content of bluetooth.py\n    try:\n        with open(\"bluetooth.py\", \"r\") as f:\n            current_content = f.read()\n    except FileNotFoundError:\n        current_content = \"\"\n\n    # Check if current content matches generated content\n    if current_content != generated_content:\n        # Add error to configuration and suggest fixing bluetooth.py\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            \"Fixable suggestion: Run 'python -m scripts.bluetooth' to generate bluetooth.py\",\n        )\n\n", "CodeBleu_score": 38.974095700539685}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    generated_content = generate_and_validate(integrations)\n\n    if config.cache.bluetooth != generated_content:\n        config.add_error(\n            \"bluetooth.py is not up to date. Run 'python -m script.bluetooth' to fix.\",\n            fixable=Fixable.FILE,\n            path=\"bluetooth.py\",\n        )\n\n", "CodeBleu_score": 30.712089927318814}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    config.add_error(\n        \"bluetooth\",\n        \"bluetooth.py is not up to date\",\n        \"Run `python -m homeassistant.scripts.check_bluetooth` to generate bluetooth.py\",\n        fixable=True,\n    )\n\n    if not config.fix:\n        return\n\n    generate_and_validate(integrations)\n\n", "CodeBleu_score": 28.502871894759895}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tlogger.Info(\"refresh token\")\n\tresp := struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int64  `json:\"expires_in\"`\n\t}{}\n\te := struct {\n\t\tError            string `json:\"error\"`\n\t\tErrorDescription string `json:\"error_description\"`\n\t\tErrorSummary     string `json:\"error_summary\"`\n\t}{}\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenEndpoint)\n\tif e.Error != \"\" {\n\t\tlogger.Error(e.Error, zap.String(\"error_description\", e.ErrorDescription), zap.String(\"error_summary\", e.ErrorSummary))\n\t\treturn fmt.Errorf(\"refresh token error: %s\", e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\td.TokenType = resp.TokenType\n\td.ExpiresIn = resp.ExpiresIn\n\treturn nil\n}", "CodeBleu_score": 56.20162020245934}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp TokenResponse\n\tvar e ErrorResponse\n\tlogger.Info(\"refresh token\", zap.String(\"refresh_token\", d.RefreshToken))\n\t_, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(TokenEndpoint)\n\tif err != nil {\n\t\tlogger.Error(\"refresh token error\", zap.Error(err))\n\t\treturn err\n\t}\n\tif e.Error != \"\" {\n\t\tlogger.Error(\"refresh token error\", zap.String(\"error\", e.Error))\n\t\treturn errors.New(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\tlogger.Info(\"refresh token success\", zap.String(\"access_token\", d.AccessToken))\n\treturn nil\n}", "CodeBleu_score": 67.20103635839912}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar (\n\t\tresp RefreshTokenResponse\n\t\te    error\n\t)\n\n\tlogger.Info(\"refresh token\")\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenEndpoint)\n\n\tif e != nil {\n\t\tlogger.Error(\"refresh token error\", zap.String(\"error\", e.Error()))\n\t\treturn e\n\t}\n\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 64.22663043776315}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.R().SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.accessToken))\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\treq.SetQueryParam(\"corpora\", \"allDrives\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tvar err error\n\tvar body []byte\n\treq.SetError(&err)\n\terr = req.Execute(method, url)\n\tif err != nil {\n\t\tif err.Error() == \"Unauthorized\" {\n\t\t\td.refreshToken()\n\t\t\tbody, err = d.request(url, method, callback, resp)\n\t\t}\n\t}\n\treturn body, err\n}", "CodeBleu_score": 55.608016801288215}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R().\n\t\tSetAuthToken(d.accessToken).\n\t\tSetQueryParam(\"supportsAllDrives\", \"true\").\n\t\tSetHeader(\"Accept\", \"application/json\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tresp, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %v\", err)\n\t}\n\n\tif resp.StatusCode() == 401 {\n\t\terr = d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to refresh token: %v\", err)\n\t\t}\n\n\t\treq.SetAuthToken(d.accessToken)\n\t\tresp, err = req.Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to execute request after refreshing token: %v\", err)\n\t\t}\n\t}\n\n\tif resp.StatusCode() != 200 {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode())\n\t}\n\n\treturn resp.Body(), nil\n}", "CodeBleu_score": 60.24367860648334}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tres, err := req.Execute(method, url)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error executing request: %v\", err)\n\t}\n\n\tif res.StatusCode() == 401 {\n\t\td.refreshToken()\n\n\t\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\t\tres, err = req.Execute(method, url)\n\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error executing request: %v\", err)\n\t\t}\n\t}\n\n\tif res.StatusCode() != 200 {\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d\", res.StatusCode())\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 63.10019024636673}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 10 // 10 MB\n\tfor finish := 0; finish < int(stream.GetSize()); finish += chunkSize {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\treq := d.request(url, \"PUT\")\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t\tif err := req.Send(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 53.33375892229187}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(1024 * 1024 * 10) // 10MB\n\tfinish := int64(0)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\treq := d.request.Clone().Put(url)\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t\tresp, err := d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif resp.StatusCode != http.StatusOK {\n\t\t\t\treturn fmt.Errorf(\"upload chunk failed: %s\", resp.Status)\n\t\t\t}\n\t\t\tfinish += chunkSize\n\t\t\tif finish >= stream.GetSize() {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.73642816869022}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(32 * 1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\treq := d.request.Clone().Put(url)\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t\tresp, err := req.Send()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif resp.StatusCode() != http.StatusOK {\n\t\t\t\treturn errors.New(\"upload failed\")\n\t\t\t}\n\t\t\tfinish += chunkSize\n\t\t\tif finish >= stream.GetSize() {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.5444080849277}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tstorage := new(Storage)\n\tif err := ctx.Bind(storage); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorParameter))\n\t}\n\tif storage.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorParameter))\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(storage.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrorService))\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(storage.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrorService))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success))\n}", "CodeBleu_score": 42.60121138090359}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tjson := make(map[string]interface{})\n\terr := ctx.Bind(&json)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorParameter))\n\t}\n\tmount_point := json[\"mount_point\"].(string)\n\tif mount_point == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorParameter))\n\t}\n\terr = service.MyService.Storage().UnmountStorage(mount_point)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorService))\n\t}\n\terr = service.MyService.Storage().DeleteConfigByName(mount_point)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrorService))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success))\n}", "CodeBleu_score": 47.478756459710134}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidRequestBody))\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidRequestBody))\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrUnmountStorageFailed))\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrDeleteConfigFailed))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrSuccess))\n}", "CodeBleu_score": 43.7464638743962}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"filePath\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_FILE_PATH_MISSING))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_FILE_NOT_EXIST))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 40.041135562997965}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"filePath\")\n\n\t// Check if the path is provided\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"message\": \"File path is required\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"message\": \"File not found\",\n\t\t})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 32.27198709745955}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_FILE_NOT_EXIST))\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_FILE_NOT_EXIST))\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.138962235285334}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the name parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// If binding fails, return a bad request error with the binding error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_INVALID_PARAMS))\n\t}\n\n\t// Send the notification using the name and message\n\terr := service.MyService.Notify().SendNotify(name, message)\n\tif err != nil {\n\t\t// If there is an error sending the notification, return an internal server error with the error message\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ERROR))\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS))\n}", "CodeBleu_score": 62.93839869676159}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the name parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Create a new message map to bind the request body to\n\tmessage := make(map[string]string)\n\n\t// Bind the request body to the message map\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// If binding fails, return a bad request error with the binding error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err.Error()))\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\t// If sending the notification fails, return an internal server error with the error message\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err.Error()))\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(\"success\"))\n}", "CodeBleu_score": 60.187163427973935}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ERROR_INVALID_PARAMS))\n\t}\n\tservice.MyService.Notify().SendNotify(name, message)\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS))\n}", "CodeBleu_score": 60.58807152721872}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader.CheckOrigin = func(r *http.Request) bool {\n\t\treturn true\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconnections = append(connections, ws)\n\tif !service.IsRunning {\n\t\tservice.Run()\n\t}\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(string(msg))\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.48715155460037}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconnections = append(connections, ws)\n\tgo service.SendMeg()\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(string(message))\n\t}\n}", "CodeBleu_score": 46.43433457194904}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader.CheckOrigin = func(r *http.Request) bool {\n\t\treturn true\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\tconnections = append(connections, ws)\n\tgo service.SendMeg()\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(string(msg))\n\t}\n}", "CodeBleu_score": 47.92266265971221}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS, service.MyService.System().GetDeviceTree()))\n}", "CodeBleu_score": 10.538121865765746}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tcpuInfo := service.MyService.System().GetCpuInfo()\n\tif cpuInfo == nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ERROR_CPU_INFO_NOT_FOUND))\n\t}\n\tdeviceTree := service.MyService.System().GetDeviceTree()\n\tdata := make(map[string]interface{})\n\tdata[\"cpu_info\"] = cpuInfo\n\tdata[\"device_tree\"] = deviceTree\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS, data))\n}", "CodeBleu_score": 33.19217821090661}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ERROR_SYSTEM_GET_CPU_INFO_FAILED))\n\t}\n\n\tdeviceTree, err := service.MyService.System().GetDeviceTree()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ERROR_SYSTEM_GET_DEVICE_TREE_FAILED))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS, map[string]interface{}{\n\t\t\"cpu_info\":    cpuInfo,\n\t\t\"device_tree\": deviceTree,\n\t}))\n}", "CodeBleu_score": 29.47038424239534}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif s.systemctl.IsRunning(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 62.19541823504278}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tstatus, err := s.systemctl.Status(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif status.ActiveState == \"active\" {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 61.37469445662895}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tstatus, err := systemctl.Status(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif status == \"running\" {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 61.90678927372559}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageStr, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to serialize message\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), &messagebus.Event{\n\t\tName: name,\n\t\tBody: messageStr,\n\t})\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\tif response.Status != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.String(\"status\", response.Status), zap.String(\"body\", response.Body))\n\t}\n}", "CodeBleu_score": 43.538101419244626}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Create a new context with a timeout of 10 seconds\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Serialize the message values to JSON strings\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to serialize message\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus\n\tresponse, err := i.messageBus.PublishEventWithResponse(ctx, &event.Event{\n\t\tName:    name,\n\t\tPayload: jsonMessage,\n\t})\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Check the response status code\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"response\", response.String()))\n\t}\n}", "CodeBleu_score": 41.63896833249734}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Create a context with a timeout of 10 seconds.\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Serialize the message values to JSON strings.\n\tmessageJson, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Error serializing message\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(ctx, &messagebus.Event{\n\t\tName: name,\n\t\tData: messageJson,\n\t})\n\tif err != nil {\n\t\tlogger.Error(\"Error publishing event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Check if the response status code is not OK.\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 42.83329364702618}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Create a new message bus client with responses\n\tclient, err := message_bus.NewClientWithResponses(c.runtimePath)\n\tif err != nil {\n\t\t// Set the server to a default error message\n\t\tclient.Server = \"error\"\n\t} else {\n\t\t// Set the server to the retrieved address\n\t\tclient.Server = c.messageBusAddress\n\t}\n\treturn client\n}", "CodeBleu_score": 34.138233405466664}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\taddress := c.GetMessageBusAddress()\n\n\tif address == \"\" {\n\t\treturn message_bus.NewClientWithResponses(\"\")\n\t}\n\n\treturn message_bus.NewClientWithResponses(address)\n}", "CodeBleu_score": 21.407094797431892}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\taddress, err := external.GetMessageBusAddress(c.RuntimePath)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tclient, err := message_bus.NewClientWithResponses(address)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\treturn client\n}", "CodeBleu_score": 36.12246326828986}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\txForwardedFor := request.Header.Get(\"x-forwarded-for\")\n\tif xForwardedFor != \"\" {\n\t\tips := strings.Split(xForwardedFor, \",\")\n\t\tfor i, ip := range ips {\n\t\t\tips[i] = strings.TrimSpace(ip)\n\t\t}\n\t\treturn ips[0]\n\t}\n\n\tremoteAddr := request.RemoteAddr\n\tif strings.HasPrefix(remoteAddr, \"[::1]\") {\n\t\treturn \"127.0.0.1\"\n\t}\n\tif strings.HasPrefix(remoteAddr, \"[::ffff:127.0.0.1]\") {\n\t\treturn \"127.0.0.1\"\n\t}\n\n\treturn strings.Split(remoteAddr, \":\")[0]\n}", "CodeBleu_score": 35.262877897604724}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\tif strings.Contains(ip, \"::ffff:127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 50.019559679835204}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\t// Convert loopback addresses to \"127.0.0.1\"\n\tif strings.HasPrefix(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.HasPrefix(ip, \"::ffff:127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\t// Split the IP address by comma and return the first IP\n\tipSplit := strings.Split(ip, \",\")\n\tif len(ipSplit) > 0 {\n\t\treturn ipSplit[0]\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 49.70501531688694}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tentryPath := filepath.Join(c.modulePath, \"entry.json\")\n\tentryFile, err := os.ReadFile(entryPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tfile, err := os.Create(entryPath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"error creating entry file\", zap.Error(err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\t_, err = file.WriteString(\"[]\")\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"error writing to entry file\", zap.Error(err))\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.Error(\"error reading entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\tmodules, err := os.ReadDir(c.modulePath)\n\tif err != nil {\n\t\tlogger.Error(\"error reading modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tvar entryData []byte\n\tfor _, module := range modules {\n\t\tmodulePath := filepath.Join(c.modulePath, module.Name())\n\t\tmoduleEntryPath := filepath.Join(modulePath, \"entry.json\")\n\t\tmoduleEntry, err := os.ReadFile(moduleEntryPath)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlogger.Error(\"error reading module entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tentryData = append(entryData, moduleEntry...)\n\t}\n\n\terr = os.WriteFile(entryPath, entryData, 0644)\n\tif err != nil {\n\t\tlogger.Error(\"error writing to entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 50.76919838342299}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.System().GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, netName := range netNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 66.43125860195886}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, networkName := range networkNames {\n\t\tfor _, interface := range interfaces {\n\t\t\tif interface.Name == networkName {\n\t\t\t\treturn interface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 61.36884939849565}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworks, err := c.System().GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, network := range networks {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == network.Name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 62.633001653217605}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t status = TSDB_CODE_SUCCESS;\n\n  if (pRequest == NULL || pTscObj == NULL) {\n    status = TSDB_CODE_INVALID_ARGUMENTS;\n  } else {\n    atomic_add_fetch_64(&pRequest->refCount, 1);\n    atomic_add_fetch_64(&pTscObj->requestCount, 1);\n\n    if (pTscObj->appInfo != NULL) {\n      atomic_add_fetch_64(&pTscObj->appInfo->totalRequestCount, 1);\n      atomic_add_fetch_64(&pTscObj->appInfo->currentRequestCount, 1);\n    }\n\n    if (pTscObj->debugInfo != NULL) {\n      pTscObj->debugInfo->debugLevel = TSDB_DEBUG_LEVEL_TRACE;\n      pTscObj->debugInfo->debugFlag = TSDB_DEBUG_FLAG_REQUEST;\n\n      tscDebug(pTscObj->debugInfo, \"Register request: %p\", pRequest);\n    }\n  }\n\n  return status;\n}", "CodeBleu_score": 46.91861614398114}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t retCode = TSDB_CODE_SUCCESS;\n\n  if (pRequest == NULL || pTscObj == NULL) {\n    return TSDB_CODE_INVALID_ARGUMENTS;\n  }\n\n  atomic_add_fetch_64(&pTscObj->refCount, 1);\n  atomic_add_fetch_64(&pTscObj->requestCount, 1);\n\n  if (pTscObj->appInfo != NULL) {\n    atomic_add_fetch_64(&pTscObj->appInfo->requestCount, 1);\n    atomic_add_fetch_64(&pTscObj->appInfo->currentRequestCount, 1);\n  }\n\n  tscDebug(\"register request: %p, tsc: %p\", pRequest, pTscObj);\n\n  return retCode;\n}", "CodeBleu_score": 38.1448790552006}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t code;\n\n  if (pRequest == NULL) {\n    return TAOS_CODE_INVALID_ARGUMENT;\n  }\n\n  if (pTscObj == NULL) {\n    return TAOS_CODE_INVALID_ARGUMENT;\n  }\n\n  code = addRef(pRequest);\n  if (code != TAOS_CODE_SUCCESS) {\n    return code;\n  }\n\n  atomic_add_fetch_64(&pTscObj->requestCount, 1);\n\n  if (pTscObj->appInfo != NULL) {\n    atomic_add_fetch_64(&pTscObj->appInfo->totalRequestCount, 1);\n    atomic_add_fetch_64(&pTscObj->appInfo->currentRequestCount, 1);\n  }\n\n  tscDebug(\"request %p added to tsc %p\", pRequest, pTscObj);\n\n  return TAOS_CODE_SUCCESS;\n}", "CodeBleu_score": 48.835853732322754}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->dbName == NULL) {\n    return true;\n  }\n\n  if (strcmp(pRequest->dbName, exceptDb) != 0) {\n    char *dbName = pRequest->dbName;\n    while (dbName != NULL) {\n      if (strcmp(dbName, exceptDb) == 0) {\n        return false;\n      }\n      char *p = strchr(dbName, '.');\n      if (p == NULL) {\n        break;\n      }\n      dbName = p + 1;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 58.31683592385731}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->db != NULL) {\n    if (strcmp(pRequest->db, exceptDb) == 0) {\n      return false;\n    }\n  }\n\n  for (int i = 0; i < taosArrayGetSize(pRequest->dbs); ++i) {\n    char *db = (char *)taosArrayGet(pRequest->dbs, i);\n    char *p = strchr(db, '.');\n    if (p != NULL) {\n      db = p + 1;\n    }\n\n    if (strcmp(db, exceptDb) == 0) {\n      return false;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 75.52114135567803}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest == NULL || exceptDb == NULL) {\n    return false;\n  }\n\n  if (strcmp(pRequest->db, exceptDb) != 0) {\n    for (int i = 0; i < pRequest->numOfDbs; ++i) {\n      char *db = pRequest->dbs[i];\n      if (db != NULL) {\n        char *pos = strchr(db, '.');\n        if (pos != NULL) {\n          db = pos + 1;\n        }\n\n        if (strcmp(db, exceptDb) == 0) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 68.92613495683197}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code != ERROR_CODE_NONE) {\n        if (msgType != MSG_TYPE_RPC_REQ && msgType != MSG_TYPE_RPC_REQ_ACK && msgType != MSG_TYPE_RPC_REQ_NACK && msgType != MSG_TYPE_RPC_REQ_REDIRECT) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 42.415298930036144}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  if (code != 0) {\n    if (msgType == TMSG_RPC_REQ) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 23.93020728827622}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == NEED_REDIRECT_ERROR && msgType != MSG_TYPE_REDIRECT && msgType != MSG_TYPE_REDIRECT_REPLY && msgType != MSG_TYPE_REDIRECT_REPLY_ACK && msgType != MSG_TYPE_REDIRECT_REPLY_NACK) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 35.4459081233392}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t  TAOS_REQ_HASH_ITER *pReqIter;\n  TAOS_REQ_HASH_ITER *pReqIterNext;\n\n  pReqIter = taosHashIterate(pRequests);\n  while (pReqIter) {\n    int64_t rid = pReqIter->rid;\n    TAOS_REQ *pReq = acquireRequest(rid);\n    if (pReq) {\n      taos_stop_query(pReq);\n      releaseRequest(rid);\n    }\n\n    pReqIterNext = pReqIter->next;\n    taosHashIterateFree(pRequests, pReqIter);\n    pReqIter = pReqIterNext;\n  }\n}", "CodeBleu_score": 43.48799076916565}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  int64_t rid;\n  taos_request_t *pReq;\n  SHashObjIter iter;\n  SHashObjIterInit(&iter, pRequests);\n\n  while (SHashObjIterNext(&iter, &rid, (void **)&pReq)) {\n    if (pReq->isQueryValid) {\n      taos_stop_query(pReq->handle);\n    }\n\n    releaseRequest(rid);\n  }\n}", "CodeBleu_score": 39.88415643960649}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  if (pRequests == NULL) {\n    return;\n  }\n\n  int64_t rid;\n  taosHashIterate(pRequests, rid, {\n    if (rid > 0) {\n      int32_t ret = taos_stop_query(rid);\n      if (ret != 0) {\n        printf(\"taos_stop_query failed. ret: %d\n\", ret);\n      }\n      releaseRequest(rid);\n    }\n  });\n}", "CodeBleu_score": 25.887584307950746}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if (!g_crashReport) {\n        return;\n    }\n\n    int expected = 0;\n    int desired = 1;\n    while (!atomic_val_compare_exchange_32(&g_clientStop, &expected, desired)) {\n        TAOS_LOG_INFO(\"Crash report thread is already stopped\");\n        return;\n    }\n\n    while (atomic_load_32(&g_clientStop) == 1) {\n        tscMsleep(10);\n    }\n}", "CodeBleu_score": 65.60576019961881}, {"code": "void tscStopCrashReport(){\n\t  if (!g_enableCrashReport) {\n    return;\n  }\n\n  if (atomic_val_compare_exchange_32(&g_clientStop, 0, 1) == 0) {\n    tscPrint(TSC_LOG_INFO, \"Crash report thread already stopped\");\n    return;\n  }\n\n  while (atomic_load_32(&g_clientStop) == 1) {\n    tscMsleep(100);\n  }\n}", "CodeBleu_score": 73.13404413502809}, {"code": "void tscStopCrashReport(){\n\t    if (g_crashReport == 0) {\n        return;\n    }\n\n    if (atomic_val_compare_exchange_32(&g_clientStop, 1, 0) == 0) {\n        tscPrint(LOG_INFO, \"Crash report thread is already stopped\");\n        return;\n    }\n\n    while (g_clientStop != 0) {\n        taosMsleep(10);\n    }\n}", "CodeBleu_score": 53.52754010185862}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  TAOS_SViewMetaRsp *pViewMetaRsp;\n  TAOS_SViewMeta *pViewMeta;\n  int32_t i;\n\n  if (valueLen == 0) {\n    return 0;\n  }\n\n  pViewMetaRsp = (TAOS_SViewMetaRsp *)value;\n  if (pViewMetaRsp->numOfViews == 0) {\n    return 0;\n  }\n\n  for (i = 0; i < pViewMetaRsp->numOfViews; ++i) {\n    pViewMeta = &pViewMetaRsp->views[i];\n    if (pViewMeta->numOfCols == 0) {\n      catalogRemoveViewMeta(pCatalog, pViewMeta->dbName, pViewMeta->viewName);\n    } else {\n      catalogUpdateViewMeta(pCatalog, pViewMeta);\n    }\n  }\n\n  tFreeSViewMetaRsp(pViewMetaRsp);\n\n  return 0;\n}", "CodeBleu_score": 33.91815086465709}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3UInt64 contentLength = 0;\n    S3Status status = S3StatusOK;\n\n    if (properties != NULL) {\n        if (properties->contentLength > 0) {\n            contentLength = properties->contentLength;\n        }\n    }\n\n    if (callbackData != NULL) {\n        S3PutObjectContext *context = (S3PutObjectContext *) callbackData;\n        if (context->contentLength < contentLength) {\n            context->contentLength = contentLength;\n        }\n    }\n\n    return status;\n}", "CodeBleu_score": 54.38397841757181}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t", "CodeBleu_score": 7.827202749180444}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    if (properties->contentLength > 0) {\n        *(uint64_t *)callbackData = properties->contentLength;\n    } else {\n        *(uint64_t *)callbackData = 0;\n    }\n    return S3StatusOK;\n}", "CodeBleu_score": 69.2714482939873}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t  uDebug(\"[rsync] start rsync\");\n  if (taosMulMkDir(tsCheckpointBackupDir, 0777) != 0) {\n    uError(\"[rsync] mkdir %s error,\", tsCheckpointBackupDir);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate config file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n\n  uDebug(\"[rsync] start rsync:%s\", cmd);\n  if (system(cmd) == 0) {\n    uDebug(\"[rsync] start rsync success\");\n  } else {\n    uError(\"[rsync] start rsync error\");\n  }\n}", "CodeBleu_score": 45.15144735418279}, {"code": "void startRsync(){\n\t  if (taosMulMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%s%s\", tsCheckpointBackupDir, \"rsyncd.conf\");\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, confDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n  uDebug(\"[rsync] command:%s\", command);\n  int32_t ret = system(command);\n  if (ret != 0) {\n    uError(\"[rsync] start rsync error, command:%s,\" ERRNO_ERR_FORMAT, command, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 65.41145344075234}, {"code": "void startRsync(){\n\t  if (taosMulMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] mkdir %s error,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \"%s%s\", tsCheckpointBackupDir, \"rsyncd.conf\");\n  if (generateConfigFile(confDir) != 0) return;\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n\n  int32_t ret = system(cmd);\n  if (ret != 0) {\n    uError(\"[rsync] start rsync server error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync server success\");\n  }\n}", "CodeBleu_score": 71.83977609745682}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found\");\n    }\n}", "CodeBleu_score": 81.55539773259935}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered\");\n    }\n    dispatcher.getExecutor().shutdownNow();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 65.4478954533549}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new IllegalArgumentException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n}", "CodeBleu_score": 80.28722119561317}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    // Retrieve the children of the parent actor from the map\n    List<TbActorId> children = getChildren(parent);\n\n    // Filter the children based on the provided predicate\n    List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n\n    // Send the message to each filtered child actor\n    for (TbActorId child : filteredChildren) {\n        try {\n            tell(child, msg, highPriority);\n        } catch (TbActorNotRegisteredException e) {\n            warn(\"Child actor not registered: \" + child);\n        }\n    }\n}", "CodeBleu_score": 55.988162156053555}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    List<TbActorId> children = get(parent).getChildren();\n    if (children == null) {\n        return;\n    }\n    for (TbActorId child : children) {\n        if (childFilter.test(child)) {\n            if (tell(child, msg, highPriority)) {\n                continue;\n            }\n            warn(\"Could not send message to child actor: \" + child);\n        }\n    }\n}", "CodeBleu_score": 50.04182576824502}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    // Retrieve the children of the parent actor from the map\n    List<TbActorId> children = get(parent);\n\n    // Filter the children based on the provided predicate\n    List<TbActorId> filteredChildren = children.stream()\n            .filter(childFilter)\n            .collect(Collectors.toList());\n\n    // Send the message to each filtered child actor\n    filteredChildren.forEach(child -> {\n        try {\n            tell(child, msg, highPriority);\n        } catch (TbActorNotFoundException e) {\n            warn(e);\n        }\n    });\n}", "CodeBleu_score": 56.17270227622504}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (!destruction.get()) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else if (highPriority && msg.getType() == RULE_NODE_UPDATED_MSG) {\n            log.debug(\"[{}] Reinitialize actor\", selfId);\n            tryInit(0);\n        } else {\n            log.debug(\"[{}] Actor is stopping, notify message\", selfId);\n            msg.onActorStopped();\n        }\n    }", "CodeBleu_score": 53.20460899884559}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (ready.get() != READY) {\n            log.trace(\"[{}] MessageBox is not ready, msg: {}\", selfId, msg);\n            msg.onTbActorStopped();\n            return;\n        }\n        if (msg.getMsgType() == RULE_NODE_UPDATED_MSG && highPriority && !reinit) {\n            log.trace(\"[{}] Reinitialize actor on high priority RULE_NODE_UPDATED_MSG\", selfId);\n            reinit = true;\n            dispatcher.getExecutor().execute(() -> tryInit(1));\n            return;\n        }\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    }", "CodeBleu_score": 53.485678106540625}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (ready.get() == READY) {\n            if (destructionInProgress.get() == READY) {\n                if (highPriority && msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n                    log.debug(\"[{}] Re-initialize actor\", selfId);\n                    tryInit(2);\n                } else {\n                    msg.onTbActorStopped();\n                }\n            } else {\n                if (highPriority) {\n                    highPriorityMsgs.add(msg);\n                } else {\n                    normalPriorityMsgs.add(msg);\n                }\n                tryProcessQueue(true);\n            }\n        } else {\n            log.trace(\"[{}] MessageBox is not ready, new msg: {}\", selfId, msg);\n        }\n    }", "CodeBleu_score": 62.70508435332075}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t        try {\n            log.trace(\"[{}] Processing mailbox\", selfId);\n            while (true) {\n                TbActorMessage msg = null;\n                if (!highPriorityMsgs.isEmpty()) {\n                    msg = highPriorityMsgs.poll();\n                } else if (!normalPriorityMsgs.isEmpty()) {\n                    msg = normalPriorityMsgs.poll();\n                } else {\n                    break;\n                }\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                    } catch (Throwable t) {\n                        if (t instanceof TbActorInitializationException) {\n                            log.warn(\"[{}] Actor initialization failed: {}\", selfId, t);\n                            stopReason = TbActorStopReason.INITIALIZATION_FAILED;\n                            destroy(t);\n                            return;\n                        } else {\n                            log.warn(\"[{}] Actor processing failed: {}\", selfId, t);\n                            if (actor.getProcessFailureStrategy() == TbActorProcessFailureStrategy.STOP_ACTOR) {\n                                stopReason = TbActorStopReason.PROCESSING_FAILED;\n                                destroy(t);\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n            ready.set(READY);\n            log.trace(\"[{}] Mailbox processed\", selfId);\n            if (!destroyInProgress.get()) {\n                tryProcessQueue(false);\n            }\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n        }\n    }", "CodeBleu_score": 41.232710261179264}, {"code": "private void processMailbox(){\n\t        if (busy.compareAndSet(BUSY, FREE)) {\n            try {\n                if (highPriorityMsgs.size() > 0) {\n                    processMessages(highPriorityMsgs, true);\n                }\n                if (normalPriorityMsgs.size() > 0) {\n                    processMessages(normalPriorityMsgs, false);\n                }\n            } catch (TbActorInitFailureException e) {\n                log.warn(\"[{}] Actor init failure: {}\", selfId, e);\n                stopReason = TbActorStopReason.INIT_FAILURE;\n                destroy(e);\n            } catch (Throwable e) {\n                log.warn(\"[{}] Actor process failure: {}\", selfId, e);\n                if (actor.getProcessFailureStrategy() == TbActorProcessFailureStrategy.STOP) {\n                    stopReason = TbActorStopReason.PROCESS_FAILURE;\n                    destroy(e);\n                } else {\n                    log.warn(\"[{}] Actor process failure strategy is {}, not stopping\", selfId, actor.getProcessFailureStrategy());\n                }\n            } finally {\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    ready.set(READY);\n                    tryProcessQueue(false);\n                } else {\n                    tryProcessQueue(true);\n                }\n            }\n        } else {\n            log.warn(\"[{}] MessageBox is not busy\", selfId);\n        }\n    }", "CodeBleu_score": 31.721951818641298}, {"code": "private void processMailbox(){\n\t        if (ready.get() == READY) {\n            while (!highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty()) {\n                if (highPriorityMsgs.isEmpty()) {\n                    processNormalPriorityMsgs();\n                } else {\n                    processHighPriorityMsgs();\n                }\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    ready.set(FREE);\n                    if (busy.compareAndSet(BUSY, FREE)) {\n                        dispatcher.getExecutor().execute(this::processMailbox);\n                    } else {\n                        log.trace(\"[{}] MessageBox is busy\", selfId);\n                    }\n                }\n            }\n        } else {\n            log.trace(\"[{}] MessageBox is not ready\", selfId);\n        }\n    }", "CodeBleu_score": 27.957288582896524}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.85357591640158}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.85357591640158}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.85357591640158}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    LimitLevelEntityName limitLevelEntityName = api.getLimitLevelEntityName();\n    Map<String, LimitLevel> limitLevelMap = tenantProfile.getLimitLevelMap();\n    LimitLevel limitLevel = limitLevelMap.get(limitLevelEntityName.name());\n    if (limitLevel == null) {\n        return true;\n    }\n    return checkRateLimit(api, tenantId, limitLevel);\n}", "CodeBleu_score": 41.77586840740544}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitResult rateLimitResult = rateLimit.checkRateLimit(level);\n    if (rateLimitResult.isExceeded()) {\n        processRateLimitNotification(rateLimitResult);\n    }\n    return rateLimitResult.isExceeded();\n}", "CodeBleu_score": 43.955311022593705}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = profile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitConfiguration.LimitLevelEntityName limitLevelEntityName = rateLimitConfiguration.getLimitLevelEntityName();\n    if (limitLevelEntityName == null) {\n        return true;\n    }\n    Map<String, Object> map = map(limitLevelEntityName, level);\n    RateLimit rateLimit = rateLimitConfiguration.getRateLimit(map);\n    if (rateLimit == null) {\n        return true;\n    }\n    boolean exceeded = rateLimit.isExceeded();\n    if (exceeded) {\n        builder().tenantId(tenantId).api(api).limitLevel(limitLevel).build().process();\n    }\n    return !exceeded;\n}", "CodeBleu_score": 46.61572066153908}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = currentTimeMillis() - getInactivityTimeout();\n    for (Map.Entry<String, DTLSSession> entry : getSessions().entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            trace(\"Removing DTLS session: \" + entry.getKey());\n            getSessions().remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 46.91548246612874}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = currentTimeMillis() - getInactivityTimeout();\n    for (Map.Entry<String, DTLSSession> entry : getDTLSSessions().entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            trace(\"Removing DTLS session with ID: \" + entry.getKey());\n            getDTLSSessions().remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 47.13688795876928}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<DTLSClientSession, Long> entry : sessions.entrySet()) {\n        if (entry.getValue() < expirationTime) {\n            sessions.remove(entry.getKey());\n            logger.trace(\"Removed DTLS session: \" + entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 45.215342987608366}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return timeseries.entrySet().stream()\n                .flatMap(entry -> entry.getValue().stream()\n                        .map(value -> new TsKvEntry(entry.getKey(), parseValue(entry.getKey(), value))))\n                .collect(Collectors.toList());\n    }", "CodeBleu_score": 27.08157012387813}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries.isEmpty()) {\n            return emptyList();\n        } else {\n            return timeseries.entrySet().stream()\n                    .flatMap(entry -> entry.getValue().stream()\n                            .map(value -> new TsKvEntry(entry.getKey(), parseValue(entry.getKey(), value))))\n                    .collect(toList());\n        }\n    }", "CodeBleu_score": 27.392138291161327}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return timeseries.entrySet().stream()\n                .flatMap(entry -> entry.getValue().stream().map(value -> parseValue(entry.getKey(), value)))\n                .map(TsKvEntry::new)\n                .collect(Collectors.toList());\n    }", "CodeBleu_score": 25.15609360923301}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t        Map<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", this.refreshToken);\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<Map<String, String>> request = new HttpEntity<>(requestMap, headers);\n        ResponseEntity<JsonNode> response = this.restTemplate.postForEntity(this.authUrl, request, JsonNode.class);\n        if (response.getStatusCode() == HttpStatus.OK) {\n            this.setTokenInfo(System.currentTimeMillis(), response.getBody());\n        } else {\n            throw new RuntimeException(\"Refresh token failed: \" + response.getStatusCode());\n        }\n    }", "CodeBleu_score": 45.962760062902795}, {"code": "public void refreshToken(){\n\t        Map<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", refreshToken);\n        HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(request, createHeaders());\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(authEndpoint, requestEntity, JsonNode.class);\n        setTokenInfo(currentTimeMillis(), response.getBody());\n    }", "CodeBleu_score": 53.28464898733165}, {"code": "public void refreshToken(){\n\t        Map<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", refreshToken);\n        HttpEntity<Map<String, String>> request = new HttpEntity<>(requestMap);\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(authUrl + \"/auth/refresh\", request, JsonNode.class);\n        setTokenInfo(currentTimeMillis(), response.getBody());\n    }", "CodeBleu_score": 57.56205691505982}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t        long ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        ResponseEntity<JsonNode> response = postForEntity(this.authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 62.3526850924809}, {"code": " private void doLogin(){\n\t        long ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = postForEntity(loginUrl, loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 65.3132209471939}, {"code": " private void doLogin(){\n\t        long ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = postForEntity(\"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 66.21404587637815}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n                \"http://localhost:8080/api/device/{deviceId}\",\n                Device.class,\n                deviceId.getId());\n\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return Optional.of(response.getBody());\n        } else {\n            return Optional.empty();\n        }\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 68.01104791567722}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n                \"/api/device/{deviceId}\",\n                Device.class,\n                deviceId.getId()\n        );\n\n        if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n\n        throw e;\n    }\n}", "CodeBleu_score": 63.590788734072476}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n                \"/api/device/{deviceId}\",\n                Device.class,\n                deviceId.getId()\n        );\n\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return Optional.ofNullable(response.getBody());\n        } else {\n            return Optional.empty();\n        }\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (Exception e) {\n        throw e;\n    }\n}", "CodeBleu_score": 61.31700526284634}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n        if (response.getStatusCode() == HttpStatus.CREATED) {\n            return Optional.ofNullable(response.getBody());\n        } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(\"Unexpected response status: \" + response.getStatusCode());\n        }\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 57.8261717325907}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    ResponseEntity<Device> response = restTemplate.postForEntity(DEVICE_WITH_CREDENTIALS_ENDPOINT, request, Device.class);\n    if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n        return Optional.empty();\n    } else {\n        return Optional.of(response.getBody());\n    }\n}", "CodeBleu_score": 53.0166511405878}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n        ResponseEntity<Device> response = restTemplate.postForEntity(API_URL + \"/device-with-credentials\", request, Device.class);\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (Exception e) {\n        throw e;\n    }\n}", "CodeBleu_score": 56.957125705562504}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}, {"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}, {"code": "device(addr){\n\t  const bound = {};\n\n  /* keys from prototype */\n  Object.keys(LedControl.prototype).forEach(key => {\n    bound[key] = this[key].bind(this, addr);\n  });\n\n  /* functions from interface */\n  Object.getOwnPropertyNames(this).forEach(key => {\n    if (this[key] && typeof this[key] === \"function\") {\n      bound[key] = this[key].bind(this, addr);\n    }\n  });\n  return bound;\n}", "CodeBleu_score": 99.81793301349097}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  for (const method of methods) {\n    target[method] = (duration, callback) => {\n      const promises = [];\n      for (let i = 0; i < this.length; i++) {\n        promises.push(new Promise(resolve => {\n          this[i][method] = (...args) => {\n            setTimeout(() => {\n              resolve(this[i][method](...args));\n            }, duration || 1000);\n          };\n        }));\n      }\n      Promise.all(promises).then(callback);\n    };\n  }\n}", "CodeBleu_score": 35.68775138028328}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = function(duration = 1000, callback) {\n            const signals = [];\n            for (let i = 0; i < this.length; i++) {\n                signals.push(new Promise((resolve) => {\n                    this[i][method]((err, result) => {\n                        resolve(result);\n                    });\n                }));\n            }\n            Promise.all(signals).then(() => {\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            });\n        };\n    });\n}", "CodeBleu_score": 43.9466918267773}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = function (duration = 1000, callback) {\n            const signals = [];\n            for (let i = 0; i < this.length; i++) {\n                signals.push(new Promise(resolve => {\n                    this[i][method] = (...args) => {\n                        resolve(this[i][method](...args));\n                    };\n                }));\n            }\n            Promise.all(signals).then(() => {\n                callback && callback();\n            });\n        };\n    });\n}", "CodeBleu_score": 41.90373854674798}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\n    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.78937640651824}, {"code": "listen(){\n\t\n    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.78937640651824}, {"code": "listen(){\n\t\n    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.78937640651824}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct ad559x_data *data = dev->data;\n\tint i;\n\tuint32_t n_channels = 0;\n\tuint32_t buffer_size = 0;\n\n\t/* Calculate the number of active channels */\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->options & (1 << i)) {\n\t\t\tn_channels++;\n\t\t}\n\t}\n\n\t/* Calculate the needed buffer size */\n\tbuffer_size = n_channels * sequence->buffer_max_size;\n\n\t/* Check if the provided buffer size is insufficient */\n\tif (buffer_size > data->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.974219072859356}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t num_channels;\n\n\tif (sequence->options & ADC_OPTION_CHANNEL_MASK) {\n\t\tnum_channels = BIT_COUNT(sequence->options & ADC_OPTION_CHANNEL_MASK);\n\t} else {\n\t\tnum_channels = data->channels_num;\n\t}\n\n\tif (sequence->resolution > data->resolution) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_channels > data->channels_num) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < (sizeof(uint16_t) * num_channels)) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 57.77055074749855}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tuint32_t num_channels;\n\tuint32_t buffer_size;\n\n\tnum_channels = adc_ad559x_get_num_channels(dev);\n\tbuffer_size = adc_ad559x_get_buffer_size(dev);\n\n\tif (num_channels == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (buffer_size < num_channels * sizeof(uint16_t)) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.92001784485194}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\n\tif (sequence->resolution != ADC_RESOLUTION_12_BIT) {\n\t\tLOG_ERR(\"Invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > data->channels) {\n\t\tLOG_ERR(\"Invalid channels %d\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (adc_ad559x_validate_buffer_size(dev, sequence)) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->resolution = sequence->resolution;\n\n\tadc_context_start_read(dev, sequence);\n\tadc_context_wait_for_completion(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 65.25353938998383}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution != ADC_RESOLUTION_12_BIT) {\n\t\tLOG_ERR(\"Invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (channels == 0 || channels > ADC_AD559X_MAX_CHANNELS) {\n\t\tLOG_ERR(\"Invalid channels %d\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tadc_context_set_buffer(dev, sequence->buffer, sequence->buffer_size);\n\tadc_context_start_read(dev);\n\tadc_context_wait_for_completion(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 65.87499086911428}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    int ret;\n    uint8_t channels;\n    uint8_t resolution;\n\n    /* Check if the resolution of the ADC sequence matches the expected resolution */\n    resolution = adc_ad559x_get_resolution(dev);\n    if (resolution != sequence->resolution) {\n        LOG_ERR(\"ADC resolution mismatch\");\n        return -EINVAL;\n    }\n\n    /* Check if the specified channels are valid */\n    channels = POPCOUNT(sequence->channels);\n    if (channels > adc_ad559x_get_num_channels(dev)) {\n        LOG_ERR(\"Invalid channel(s)\");\n        return -EINVAL;\n    }\n\n    /* Validate the buffer size for the ADC read */\n    ret = adc_ad559x_validate_buffer_size(dev, sequence);\n    if (ret != 0) {\n        LOG_ERR(\"Insufficient buffer size\");\n        return ret;\n    }\n\n    /* Set the buffer and start the ADC read context */\n    adc_context_set_buffer(dev, sequence->buffer, sequence->buffer_size);\n    adc_context_start_read(dev, sequence);\n\n    /* Wait for the read operation to complete */\n    ret = adc_context_wait_for_completion(dev);\n    if (ret != 0) {\n        LOG_ERR(\"ADC read failed\");\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 59.750918195041706}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n\n    /* Initialize the channels to be sampled. */\n    adc_channels_set(data, ctx->channels, ctx->channels_count);\n\n    /* Initialize the repeat buffer with the data buffer. */\n    adc_repeat_buffer_init(data, ctx->data_buffer, ctx->data_buffer_size);\n\n    /* Release the semaphore to signal the start of sampling. */\n    k_sem_give(&data->sem);\n}", "CodeBleu_score": 46.066314635731246}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t  if (repeat_sampling) {\n    ctx->data = &ctx->repeat_buffer;\n  }\n}", "CodeBleu_score": 30.886046943351786}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t  if (repeat_sampling) {\n    ctx->adc_data_container.buffer = ctx->repeat_buffer;\n  } else {\n    ctx->adc_data_container.buffer = ctx->buffer;\n  }\n}", "CodeBleu_score": 47.47264028205539}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t  if (repeat_sampling) {\n    ctx->adc_data_container.buffer_pointer = ctx->repeat_buffer;\n  }\n}", "CodeBleu_score": 44.265225388386014}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    while (true) {\n        k_sem_take(&data->sem, K_FOREVER);\n        for (int i = 0; i < data->channels_num; i++) {\n            uint16_t result;\n            int ret = adc_ad559x_read_channel(data->dev, data->channels[i], &result);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to read channel %d: %d\", data->channels[i], ret);\n                adc_context_complete(data->ctx);\n                return;\n            }\n            data->results[i] = result;\n        }\n        adc_context_on_sampling_done(data->ctx);\n    }\n}", "CodeBleu_score": 48.45320214603275}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tfor (size_t i = 0; i < data->channels_num; i++) {\n\t\t\tuint16_t val;\n\t\t\tint ret;\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, data->channels[i], &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %u: %d\", data->channels[i], ret);\n\t\t\t\tadc_context_complete(data->ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->results[i] = val;\n\t\t}\n\n\t\tadc_context_on_sampling_done(data->ctx);\n\t}\n}", "CodeBleu_score": 47.810545620136736}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t  while (true) {\n    k_sem_take(&data->sem, K_FOREVER);\n    for (uint8_t i = 0; i < data->config->channel_mask; i++) {\n      if (data->config->channel_mask & BIT(i)) {\n        uint16_t result;\n        int ret = adc_ad559x_read_channel(data->dev, i, &result);\n        if (ret < 0) {\n          LOG_ERR(\"Failed to read channel %d: %d\", i, ret);\n          adc_context_complete(data->ctx);\n          return;\n        }\n        data->results[i] = result;\n      }\n    }\n    adc_context_on_sampling_done(data->ctx);\n  }\n}", "CodeBleu_score": 52.30385692644103}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\n\tuint8_t reg_val;\n\tint rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val & ADS1112_REG_CONFIG_OS_MASK)) {\n\t\tk_sleep(K_USEC(config->ready_time));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.273381679534445}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val;\n\tint rc;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val & ADS1112_CONFIG_OS)) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 61.77707613932346}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val;\n\tint rc;\n\n\tk_sleep(config->ready_time);\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val & ADS1112_REG_CONFIG_OS)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.2706581612226}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  int ret;\n  int buffer_size;\n  int required_buffer_size;\n  int extra_samplings;\n  int extra_samplings_multiplier;\n\n  extra_samplings = sequence->options & ADS1112_SEQUENCE_OPTION_EXTRA_SAMPLINGS;\n  extra_samplings_multiplier = extra_samplings + 1;\n  required_buffer_size = sequence->length * extra_samplings_multiplier;\n  buffer_size = sequence->buffer_length;\n\n  if (buffer_size < required_buffer_size) {\n    LOG_ERR(\"Buffer size is too small (%d < %d)\", buffer_size, required_buffer_size);\n    ret = -ENOMEM;\n    goto error;\n  }\n\n  ret = 0;\n\nerror:\n  return ret;\n}", "CodeBleu_score": 38.59390749008035}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.778215576071295}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.778215576071295}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = adc_context_start_read(dev, sequence, wait);\n\n\treturn ret;\n}", "CodeBleu_score": 55.59380860244143}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = adc_context_start_read(dev, sequence, wait);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.21915209976249}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = adc_context_start_read(dev);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(dev);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 60.07390662028354}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct device *dev;\n    int ret;\n\n    if (argc < 2) {\n        shell_error(sh, \"Missing device name\");\n        return -ENODEV;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device not found: %s\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(dev);\n    if (ret) {\n        shell_error(sh, \"Failed to apply properties: %d\", ret);\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 57.781599739684744}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct device *device;\n    int ret;\n\n    if (argc != 2) {\n        shell_error(sh, \"Usage: apply_prop <device>\");\n        return -ENODEV;\n    }\n\n    device = device_get_binding(argv[1]);\n    if (device == NULL) {\n        shell_error(sh, \"Device not found: %s\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(device);\n    if (ret != 0) {\n        shell_error(sh, \"Failed to apply properties: %d\", ret);\n        return ret;\n    }\n\n    shell_print(sh, \"Properties applied successfully.\");\n    return 0;\n}", "CodeBleu_score": 50.9826115099453}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\tint ret;\n\n\tif (argc != 1) {\n\t\tshell_error(sh, \"Usage: apply_prop <device_name>\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[0]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found: %s\", argv[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret != 0) {\n\t\tshell_error(sh, \"Failed to apply properties: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.09400961456884}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_data *data = dev->data;\n    int ret;\n\n    if (cmd == DMIC_TRIGGER_START) {\n        /* Set the I2S command to start the DAC */\n        data->i2s_cmd = MPXXDYY_I2S_CMD_START;\n        /* Set the device state to configured */\n        data->state = MPXXDYY_STATE_CONFIGURED;\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n        /* Set the I2S command to stop the DAC */\n        data->i2s_cmd = MPXXDYY_I2S_CMD_STOP;\n        /* Set the device state to active */\n        data->state = MPXXDYY_STATE_ACTIVE;\n    } else {\n        /* Invalid command */\n        return -EINVAL;\n    }\n\n    /* Send the I2S command */\n    ret = mpxxdtyy_i2s_send_cmd(dev, data->i2s_cmd);\n    if (ret) {\n        /* Failed to send the I2S command */\n        LOG_ERR(\"Failed to send I2S command: %d\", ret);\n        return ret;\n    }\n\n    /* Update the device state */\n    data->state = MPXXDYY_STATE_CONFIGURED;\n\n    return 0;\n}", "CodeBleu_score": 41.605948657362234}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t  struct mpxxdtyy_data *data = dev->data;\n  int ret;\n\n  if (cmd == DMIC_TRIGGER_START) {\n    if (data->state == MPXXDYY_STATE_CONFIGURED) {\n      ret = mpxxdtyy_i2s_cmd(dev, MPXXDYY_I2S_CMD_START);\n      if (ret) {\n        LOG_ERR(\"Failed to send I2S start command (%d)\", ret);\n        return ret;\n      }\n      data->state = MPXXDYY_STATE_ACTIVE;\n    }\n  } else if (cmd == DMIC_TRIGGER_STOP) {\n    if (data->state == MPXXDYY_STATE_ACTIVE) {\n      ret = mpxxdtyy_i2s_cmd(dev, MPXXDYY_I2S_CMD_STOP);\n      if (ret) {\n        LOG_ERR(\"Failed to send I2S stop command (%d)\", ret);\n        return ret;\n      }\n      data->state = MPXXDYY_STATE_CONFIGURED;\n    }\n  } else {\n    LOG_ERR(\"Invalid DMIC trigger command (%d)\", cmd);\n    return -EINVAL;\n  }\n\n  return 0;\n}", "CodeBleu_score": 44.53875882165688}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t  struct mpxxdtyy_dev_data *dev_data = dev->data;\n  int ret;\n\n  switch (cmd) {\n    case DMIC_TRIGGER_START:\n      if (dev_data->state == MPXXDTYY_STATE_CONFIGURED) {\n        ret = mpxxdtyy_send_i2c_command(dev, MPXXDTYY_I2S_START);\n        if (ret == 0) {\n          dev_data->state = MPXXDTYY_STATE_ACTIVE;\n        }\n      } else {\n        LOG_ERR(\"Invalid state transition: %d -> %d\", dev_data->state, MPXXDTYY_STATE_ACTIVE);\n        ret = -EINVAL;\n      }\n      break;\n    case DMIC_TRIGGER_STOP:\n      if (dev_data->state == MPXXDTYY_STATE_ACTIVE) {\n        ret = mpxxdtyy_send_i2c_command(dev, MPXXDTYY_I2S_STOP);\n        if (ret == 0) {\n          dev_data->state = MPXXDTYY_STATE_CONFIGURED;\n        }\n      } else {\n        LOG_ERR(\"Invalid state transition: %d -> %d\", dev_data->state, MPXXDTYY_STATE_CONFIGURED);\n        ret = -EINVAL;\n      }\n      break;\n    default:\n      LOG_ERR(\"Invalid trigger command: %d\", cmd);\n      ret = -EINVAL;\n      break;\n  }\n\n  return ret;\n}", "CodeBleu_score": 54.52184971443017}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = config->display_mode;\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= BIT(1);\n\t}\n\n\tif (config->blink_enabled) {\n\t\tcmd |= BIT(0);\n\t}\n\n\tif (enabled) {\n\t\tcmd |= BIT(2);\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 51.67430377621371}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CMD;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CMD_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CMD_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CMD_CURSOR_BLINK_ON;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_8_BIT) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CMD_8_BIT_MODE;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->display_mode);\n}", "CodeBleu_score": 66.77347023648964}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_data *data = dev->data;\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_ON;\n\t}\n\n\tif (data->blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_BLINK_ON;\n\t}\n\n\tif (data->cursor_position) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_MOVE_RIGHT;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 73.7416046171695}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    struct auxdisplay_itron_data *data = dev->data;\n    int ret;\n    uint32_t pin_config;\n\n    if (!data->busy_gpio_port) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get_raw(data->busy_gpio_port, data->busy_gpio_pin);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return (ret != data->busy_gpio_active_state);\n}", "CodeBleu_score": 53.22829830848049}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t  const struct auxdisplay_itron_config *config = dev->config;\n  if (config->busy_gpio_port == NULL) {\n    return -ENOTSUP;\n  }\n  return gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 71.86866323166787}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *cfg = dev->config;\n\n    if (cfg->busy_gpio_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_dt(cfg->busy_gpio_port, cfg->busy_gpio_pin);\n}", "CodeBleu_score": 66.85289210163232}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *cfg = dev->config;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = cfg->special_command_prefix;\n\tbuffer[1] = command;\n\n\treturn i2c_write_dt(&cfg->i2c, buffer, sizeof(buffer));\n}", "CodeBleu_score": 58.98301932116017}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t", "CodeBleu_score": 9.039500874140998}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tstruct auxdisplay_serlcd_config *cfg = dev->config;\n\n\tuint8_t buf[2];\n\n\tbuf[0] = cfg->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write_dt(&cfg->i2c, buf, sizeof(buf));\n}", "CodeBleu_score": 52.82256028929847}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &bbram_data->memory[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 51.072702670806756}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (size == 0 || offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->memory + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 72.14293633899675}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -ENODEV;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 72.65773414346583}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_p = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > data_p->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data_p->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.34835367324214}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data_->memory + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.40769765191835}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_p = dev->data;\n\n\tif (size > BBRAM_EMUL_MAX_WRITE_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif ((offset + size) > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&data_p->memory[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 53.82680422461732}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device path\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 81.10232243106923}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tARG_UNUSED(argc);\n\tARG_UNUSED(argv);\n\n\tif (bbram_dev == NULL) {\n\t\tshell_error(sh, \"Invalid argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(CONFIG_BBRAM_DEV_NAME);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.3014157457048}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device parameter\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found: %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_init(*bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Device initialization failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 71.44934808159967}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t  struct h4_uart_data *uart_data = dev->data;\n  uint8_t *hdr_buf = uart_data->hdr_buf;\n  uint32_t rx_bytes = uart_data->rx_bytes;\n  uint32_t remaining_bytes = uart_data->remaining_bytes;\n  uint32_t bytes_read;\n\n  if (likely(remaining_bytes)) {\n    bytes_read = uart_fifo_read(dev, hdr_buf + rx_bytes, remaining_bytes);\n\n    if (unlikely(!bytes_read)) {\n      LOG_ERR(\"Failed to read from UART FIFO\");\n    } else {\n      remaining_bytes -= bytes_read;\n      rx_bytes += bytes_read;\n    }\n  }\n\n  uart_data->rx_bytes = rx_bytes;\n  uart_data->remaining_bytes = remaining_bytes;\n}", "CodeBleu_score": 44.250696166484694}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t  struct h4_data *data = dev->data;\n  uint8_t *hdr = data->hdr;\n  uint32_t bytes_read = data->bytes_read;\n  uint32_t bytes_remaining = data->bytes_remaining;\n  uint32_t bytes_to_read = bytes_remaining - bytes_read;\n  uint32_t ret;\n\n  if (bytes_to_read > 0) {\n    ret = uart_fifo_read(dev, hdr + bytes_read, bytes_to_read);\n    if (ret != bytes_to_read) {\n      LOG_ERR(\"Failed to read header data from UART FIFO\");\n    } else {\n      bytes_read += ret;\n      bytes_remaining -= ret;\n    }\n  }\n\n  data->bytes_read = bytes_read;\n  data->bytes_remaining = bytes_remaining;\n}", "CodeBleu_score": 45.408774695295314}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t  struct h4_uart_data *data = dev->data;\n  uint32_t num_bytes_read;\n  uint32_t num_bytes_remaining;\n  int ret;\n\n  num_bytes_read = uart_fifo_read(data->uart, data->hdr_buf,\n                                  H4_HDR_LEN - data->hdr_bytes_read);\n  if (num_bytes_read == 0) {\n    LOG_ERR(\"UART FIFO read failed\");\n    return;\n  }\n\n  data->hdr_bytes_read += num_bytes_read;\n  num_bytes_remaining = H4_HDR_LEN - data->hdr_bytes_read;\n\n  if (num_bytes_remaining == 0) {\n    data->hdr_bytes_read = 0;\n    data->hdr_buf_ready = true;\n  }\n}", "CodeBleu_score": 45.88778800912723}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  uint8_t buf[33];\n  size_t ret = 0;\n  size_t read;\n\n  while (len > 0) {\n    read = uart_fifo_read(uart, buf, min(len, sizeof(buf)));\n    if (read == 0) {\n      LOG_ERR(\"Failed to read from FIFO\");\n      return 0;\n    }\n    len -= read;\n    ret += read;\n  }\n\n  return ret;\n}", "CodeBleu_score": 44.232769043591034}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t ret, n;\n\n    ret = 0;\n    while (len) {\n        n = unlikely(len < 33) ? len : 33;\n        if (uart_fifo_read(uart, buf, n) != n) {\n            LOG_ERR(\"Failed to read from UART\");\n            return 0;\n        }\n        ret += n;\n        len -= n;\n    }\n\n    return ret;\n}", "CodeBleu_score": 46.20402927636121}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  size_t rc;\n  uint8_t buf[33];\n\n  if (len > sizeof(buf)) {\n    len = sizeof(buf);\n  }\n\n  rc = uart_fifo_read(uart, buf, len);\n  if (rc != len) {\n    LOG_ERR(\"uart_fifo_read() failed (%d)\", rc);\n  }\n\n  return rc;\n}", "CodeBleu_score": 53.14299733853593}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t  unsigned int highest_hop = 0;\n  struct zbus_observer *obs;\n  struct zbus_channel_data *data;\n  unsigned int hop;\n  unsigned int i;\n\n  data = chan->data;\n\n  spin_lock(&data->lock);\n  for (i = 0; i < data->n_observers; i++) {\n    obs = data->observers[i];\n    if (!obs->enabled)\n      continue;\n    hop = obs->hop;\n    if (hop > highest_hop)\n      highest_hop = hop;\n  }\n  chan->highest_hop = highest_hop;\n  spin_unlock(&data->lock);\n}", "CodeBleu_score": 33.03188930972373}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    u32_t hop = 0;\n    u32_t i;\n\n    K_SPINLOCK(&chan->lock);\n    for (i = 0; i < chan->observers_count; i++) {\n        struct zbus_observer *obs = chan->observers[i];\n\n        if (obs->enabled && obs->priority > hop) {\n            hop = obs->priority;\n        }\n    }\n    chan->hop = hop;\n    K_SPINUNLOCK(&chan->lock);\n}", "CodeBleu_score": 23.76788585848862}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t  unsigned int highest_hop;\n  struct zbus_channel_data *chan_data;\n  struct zbus_observer *observer;\n  struct zbus_observer_data *observer_data;\n  unsigned int hop;\n\n  chan_data = chan->data;\n  K_SPINLOCK_KEY_SAVE(chan_data->lock, lock_key);\n  highest_hop = 0;\n  for (observer = chan_data->observers; observer; observer = observer->next) {\n    observer_data = observer->data;\n    if (observer_data->enabled) {\n      hop = observer_data->hop;\n      if (hop > highest_hop) {\n        highest_hop = hop;\n      }\n    }\n  }\n  chan_data->highest_hop = highest_hop;\n  K_SPINLOCK_KEY_RESTORE(chan_data->lock, lock_key);\n}", "CodeBleu_score": 37.90769715805807}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tSTRUCT_SECTION_FOREACH(zbus_channel) {\n\t\tstruct zbus_channel_observation *observation;\n\t\tstruct zbus_channel_observation_mask *observation_mask;\n\n\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\tfor (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 20.16009058494033}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tSTRUCT_SECTION_FOREACH(zbus_channel) {\n\t\tconst struct zbus_channel *chan = &channel;\n\t\tif (chan->data->highest_observer_priority > obs->data->priority) {\n\t\t\tcontinue;\n\t\t}\n\t\tchan_update_hop(chan);\n\t}\n}", "CodeBleu_score": 25.6620738625415}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\t__ASSERT(obs != NULL, \"observer must be not NULL\");\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_channels_end_idx;\n\n\t\tfor (int16_t i = _zbus_channels_start_idx; i < limit; ++i) {\n\t\t\tstruct zbus_channel *chan;\n\n\t\t\tSTRUCT_SECTION_GET(zbus_channel, i, &chan);\n\n\t\t\t__ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\t\t\tif (chan->data->highest_observer_priority > obs->data->priority) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.846413992279725}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_ISR_ASSERT();\n\tZBUS_ASSERT(obs != NULL);\n\n\tK_SPINLOCK_KEY_SAVE(key, &obs->lock);\n\n\tobs->priority = sys_get_idle_thread_prio();\n\tupdate_all_channels_hop(obs);\n\n\tK_SPINLOCK_KEY_RESTORE(key, &obs->lock);\n\n\treturn 0;\n}", "CodeBleu_score": 48.92279864022973}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_SPINLOCK\n\tk_is_in_isr();\n\t_ZBUS_ASSERT(obs != NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tobs->priority = sys_get_idle_thread_prio();\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 24.509350006688525}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_SPINLOCK\n\tk_is_in_isr\n\t_ZBUS_ASSERT\n\n\tobs->priority = sys_get_idle_thread_prio_threshold();\n\tupdate_all_channels_hop(obs);\n\n\treturn 0;\n}", "CodeBleu_score": 17.89371105330159}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\tint prio = 0;\n\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n#if defined(CONFIG_ZBUS_PRIORITY_BOOST)\n\tif (k_is_in_isr()) {\n\t\ttimeout = sys_timepoint_timeout(end_time);\n\t}\n#endif /* CONFIG_ZBUS_PRIORITY_BOOST */\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 54.34569295729024}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\tint prio = 0;\n\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tif (k_is_in_isr()) {\n\t\tend_time = sys_timepoint_calc_isr(timeout);\n\t}\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 53.29631817871305}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 47.98107929111259}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  /* Check the parameters */\n  assert_param(IS_ETH_INT(Int));\n\n  /* Check if the interrupt is normal or abnormal */\n  if (Int & 0x00000001) {\n    if (enable != DISABLE) {\n      /* Enable the normal interrupt */\n      ETH->INTEN |= ETH_INTEN_NORMAL;\n    } else {\n      /* Disable the normal interrupt */\n      ETH->INTEN &= ~ETH_INTEN_NORMAL;\n    }\n  } else {\n    if (enable != DISABLE) {\n      /* Enable the abnormal interrupt */\n      ETH->INTEN |= ETH_INTEN_ABNORMAL;\n    } else {\n      /* Disable the abnormal interrupt */\n      ETH->INTEN &= ~ETH_INTEN_ABNORMAL;\n    }\n  }\n}", "CodeBleu_score": 35.030269458462335}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t", "CodeBleu_score": 2.546149641071209}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *tx_desc;\n    ETH_TX_DESC *tx_desc_start;\n    uint32_t tx_desc_addr;\n    uint32_t tx_desc_addr_next;\n    uint32_t tx_desc_addr_start;\n\n    /* Get the current transmit descriptor address. */\n    tx_desc_addr = ETH_TX_DESC_ADDR;\n\n    /* Check if the descriptor is owned by the device. */\n    tx_desc = (ETH_TX_DESC *)tx_desc_addr;\n    if (tx_desc->tx_desc_owner != ETH_DESC_OWNER_DEVICE) {\n        /* The descriptor is not owned by the device. */\n        return 0;\n    }\n\n    /* The descriptor is owned by the device. */\n    return tx_desc;\n}", "CodeBleu_score": 50.97072165387348}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t  ETH_TX_DESC *txDesc;\n  uint32_t txDescAddr = ETH->TX_DESC_ADDR;\n  uint32_t txDescAddrNext;\n\n  // Check if the current transmit descriptor is owned by the device\n  if (ETH->TX_DESC_OWN & (1 << (txDescAddr & 0x1F))) {\n    // The current transmit descriptor is owned by the device, so return it\n    return (ETH_TX_DESC *)txDescAddr;\n  }\n\n  // Search for a free transmit descriptor\n  txDescAddrNext = txDescAddr + 1;\n  do {\n    // Check if the next transmit descriptor is owned by the device\n    if (ETH->TX_DESC_OWN & (1 << (txDescAddrNext & 0x1F))) {\n      // The next transmit descriptor is owned by the device, so continue to the next descriptor\n      txDescAddrNext = (txDescAddrNext + 1) & 0x1F;\n    } else {\n      // The next transmit descriptor is not owned by the device, so return it\n      return (ETH_TX_DESC *)txDescAddrNext;\n    }\n  } while (txDescAddrNext != txDescAddr);\n\n  // No free transmit descriptor was found, so return 0\n  return 0;\n}", "CodeBleu_score": 51.246824525462856}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t result = RT_EOK;\n    rt_uint32_t cyp_dac_channel = 0;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(device->parent.config, cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable failed\");\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 58.5142869947316}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"DAC output enable failed\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 58.99271097096099}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t result = RT_EOK;\n    rt_uint32_t cyp_dac_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(device->parent.config.base, cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"DAC output enable failed\");\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 60.08885620279365}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > FLASH_END_ADDR) {\n        LOG_E(\"ifx_flash_read_32k: read exceeds flash memory end address\");\n        return -1;\n    }\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *((rt_uint8_t *)(addr + i));\n    }\n    return size;\n}", "CodeBleu_score": 43.93973853993022}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint32_t end_addr = addr + size;\n\n    if (end_addr > IFX_FLASH_END_ADDR) {\n        LOG_E(\"ifx_flash_read_32k: address out of range: 0x%08X, size: %d\", addr, size);\n        return -EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = ifx_flash_read_byte(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 51.66536722930477}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    if (addr + size > IFX_FLASH_SIZE) {\n        LOG_E(\"ifx_flash_read_32k: addr: %d, size: %d, addr + size: %d, IFX_FLASH_SIZE: %d\n\", addr, size, addr + size, IFX_FLASH_SIZE);\n        return -EINVAL;\n    }\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(IFX_FLASH_BASE_ADDR + addr + i);\n    }\n    return size;\n}", "CodeBleu_score": 56.04631813824687}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->user_data;\n    return cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 29.319262412054087}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t  RT_ASSERT(timer != RT_NULL);\n  cyhal_timer_t *obj = (cyhal_timer_t *)timer->user_data;\n  return cyhal_timer_read(obj);\n}", "CodeBleu_score": 27.047498589986052}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 29.114912051891924}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\twhile (rt_mutex_take(dfs_mutex, RT_WAITING_FOREVER) != RT_EOK) {\n\t\tRT_ASSERT(0);\n\t}\n}", "CodeBleu_score": 28.788303581592277}, {"code": "void dfs_lock(void){\n\t    int ret;\n    do {\n        ret = rt_mutex_take(DFS_MUTEX, RT_WAITING_FOREVER);\n    } while (ret != RT_EOK);\n}", "CodeBleu_score": 14.307447430668265}, {"code": "void dfs_lock(void){\n\t\twhile (1) {\n\t\trt_mutex_take(dfs_mutex, RT_WAITING_FOREVER);\n\t\tif (rt_mutex_is_taken(dfs_mutex)) {\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 20.7656470791001}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            return fd;\n        }\n    }\n\n    return fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 30.32863696647713}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n\n    if (startfd < 0)\n    {\n        startfd = 0;\n    }\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            return fd;\n        }\n    }\n    return fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 35.706983094481174}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd = -1;\n    int index;\n\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            fd = index;\n            break;\n        }\n    }\n\n    if (fd == -1) {\n        fd = fd_slot_expand(fdt, index);\n    }\n\n    return fd;\n}", "CodeBleu_score": 38.471018022996994}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < RT_ERR_NUM; i++) {\n        if (error == rt_errno[i].err_code) {\n            return rt_errno[i].err_str;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 55.59009537475368}, {"code": "const char *rt_strerror(rt_err_t error){\n\t  if (error < 0) {\n    error = -error;\n  }\n  for (int i = 0; i < RT_ERR_NUM; i++) {\n    if (error == rt_error_table[i].error) {\n      return rt_error_table[i].str;\n    }\n  }\n  return \"EUNKNOW\";\n}", "CodeBleu_score": 52.50866143411981}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < RT_ERR_MAX; i++) {\n        if (rt_err_table[i].code == error) {\n            return rt_err_table[i].string;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 56.632280725558246}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t i;\n    rt_base_t result;\n\n    rt_spin_lock(&rt_thread_idle_lock);\n\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_MAX_NUM; i++) {\n        if (rt_thread_idle_hooks[i] == RT_NULL) {\n            rt_thread_idle_hooks[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock(&rt_thread_idle_lock);\n\n    return result;\n}", "CodeBleu_score": 61.39640731994241}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t index;\n\n    /* lock the spinlock */\n    rt_spin_lock(&rt_thread_idle_hook_lock);\n\n    /* iterate through the idle hook list */\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_MAX_NUM; index++) {\n        /* check if the slot is empty */\n        if (rt_thread_idle_hook_table[index] == RT_NULL) {\n            /* assign the hook to the slot */\n            rt_thread_idle_hook_table[index] = hook;\n\n            /* release the spinlock */\n            rt_spin_unlock(&rt_thread_idle_hook_lock);\n\n            /* return a success code */\n            return RT_EOK;\n        }\n    }\n\n    /* release the spinlock */\n    rt_spin_unlock(&rt_thread_idle_hook_lock);\n\n    /* return an error code */\n    return -RT_EFULL;\n}", "CodeBleu_score": 52.57825055927023}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t i;\n    rt_base_t result;\n    rt_base_t lock;\n\n    /* lock the spinlock */\n    lock = rt_hw_spin_lock();\n\n    /* iterate through the idle hook list */\n    for (i = 0; i < RT_IDLE_HOOK_MAX_NUM; i++) {\n        /* check if the current slot is empty */\n        if (rt_idle_hook_list[i] == RT_NULL) {\n            /* assign the hook to the current slot */\n            rt_idle_hook_list[i] = hook;\n            /* release the spinlock */\n            rt_hw_spin_unlock(lock);\n            /* return a success code */\n            return RT_EOK;\n        }\n    }\n\n    /* release the spinlock */\n    rt_hw_spin_unlock(lock);\n    /* return an error code */\n    return -RT_EFULL;\n}", "CodeBleu_score": 59.26281195742567}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t index;\n    rt_base_t *p;\n\n    rt_spin_lock(&rt_thread_idle_lock);\n\n    for (index = 0, p = rt_thread_idle_hooks; index < RT_THREAD_IDLE_MAX_HOOKS; index++, p++) {\n        if (*p == hook) {\n            *p = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    if (index == RT_THREAD_IDLE_MAX_HOOKS) {\n        result = -RT_ERROR;\n    }\n\n    rt_spin_unlock(&rt_thread_idle_lock);\n\n    return result;\n}", "CodeBleu_score": 53.42536853124062}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_uint32_t level;\n\n    /* lock */\n    level = rt_hw_interrupt_disable();\n\n    /* find the hook */\n    rt_list_t *node = rt_list_next(&(rt_thread_idle.hook_list));\n    while (node != &(rt_thread_idle.hook_list)) {\n        if (node->item == hook) {\n            /* remove the node */\n            rt_list_remove(node);\n            result = RT_EOK;\n            break;\n        }\n        node = rt_list_next(node);\n    }\n\n    /* unlock */\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 43.25441063934255}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t i;\n\n    rt_spin_lock(&rt_thread_idle_lock);\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_NUM; i++) {\n        if (rt_thread_idle_hook_table[i] == hook) {\n            rt_thread_idle_hook_table[i] = NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n    rt_spin_unlock(&rt_thread_idle_lock);\n\n    return result;\n}", "CodeBleu_score": 60.69331760805111}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t *thread;\n    rt_err_t result = RT_EOK;\n\n    /* lock the scheduler */\n    rt_scheduler_lock();\n\n    /* resume all suspended threads in the list */\n    while (susp_list->next != susp_list) {\n        thread = rt_list_entry(susp_list->next, rt_thread_t, susp_list);\n        result = rt_susp_list_dequeue(thread, thread_error);\n        if (result != RT_EOK) {\n            break;\n        }\n    }\n\n    /* unlock the scheduler */\n    rt_scheduler_unlock();\n\n    return result;\n}", "CodeBleu_score": 42.88747748084718}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_base_t level;\n\trt_thread_t thread;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = (rt_thread_t)rt_list_entry(susp_list->next, struct rt_thread, susp_list);\n\n\t\trt_list_remove(&thread->susp_list);\n\n\t\trt_thread_resume(thread);\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.364682976704984}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_base_t level;\n    rt_list_t *node;\n    rt_thread_t *thread;\n    rt_err_t result = RT_EOK;\n\n    level = rt_hw_interrupt_disable();\n\n    while ((node = rt_list_next(susp_list)) != RT_NULL) {\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n        if (thread->state == RT_THREAD_SUSPEND) {\n            rt_list_remove(&thread->tlist);\n            thread->state = RT_THREAD_READY;\n            thread->error = thread_error;\n            rt_schedule();\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 28.905042518386804}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t dev, old;\n    rt_err_t result;\n\n    old = rt_console_get_device();\n\n    /* find the new device */\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        return old;\n    }\n\n    /* check if it is the same as the current device */\n    if (dev == old) {\n        return old;\n    }\n\n    /* close the current device */\n    if (old != RT_NULL) {\n        rt_device_close(old);\n    }\n\n    /* open the new device with read/write and stream flags */\n    result = rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        return old;\n    }\n\n    /* set it as the new console device */\n    rt_console_set_device(dev);\n\n    return old;\n}", "CodeBleu_score": 55.64848545376739}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_dev, dev;\n\n    /* save the current console device */\n    old_dev = rt_console_get_device();\n\n    /* find the new device by its name */\n    dev = rt_device_find(name);\n\n    /* check if it is the same as the current device */\n    if (dev == old_dev)\n        return old_dev;\n\n    /* close the current console device if it exists */\n    if (old_dev)\n        rt_device_close(old_dev);\n\n    /* open the new console device with read/write and stream flags */\n    if (dev) {\n        rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    }\n\n    /* set it as the new console device */\n    rt_console_set_device(dev);\n\n    return old_dev;\n}", "CodeBleu_score": 51.45457242348096}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t dev, old_dev;\n    rt_err_t result;\n\n    old_dev = rt_console_get_device();\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        return old_dev;\n    }\n\n    result = rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        return old_dev;\n    }\n\n    rt_console_set_device(dev);\n    return old_dev;\n}", "CodeBleu_score": 50.35255697416022}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *info = NULL;\n    rt_spinlock_irqsave(&rt_object_lock);\n    info = rt_object_get_information(type);\n    if (info) {\n        struct rt_object *object = info->object_list;\n        while (object) {\n            count++;\n            object = object->next;\n        }\n    }\n    rt_spin_unlock_irqrestore(&rt_object_lock);\n    return count;\n}", "CodeBleu_score": 40.28721635811692}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_class *class;\n    struct rt_object *object;\n    int count = 0;\n\n    class = rt_object_get_class(type);\n    if (class == RT_NULL)\n        return 0;\n\n    rt_spin_lock_irqsave(&class->lock, rt_flags);\n    rt_list_for_each(object, &class->list) {\n        count++;\n    }\n    rt_spin_unlock_irqrestore(&class->lock, rt_flags);\n\n    return count;\n}", "CodeBleu_score": 50.534045845290265}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_class *class;\n    struct rt_object_list *list;\n    int count = 0;\n\n    if (type < 0 || type >= RT_OBJECT_CLASS_TYPE_MAX) {\n        return -RT_EINVAL;\n    }\n\n    class = rt_object_class_table[type];\n    if (class == NULL) {\n        return -RT_EINVAL;\n    }\n\n    rt_spin_lock_irqsave(&class->lock, &class->irq_flag);\n    rt_list_for_each(list, &class->list) {\n        count++;\n    }\n    rt_spin_unlock_irqrestore(&class->lock, class->irq_flag);\n\n    return count;\n}", "CodeBleu_score": 51.51961985079204}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    rt_object_info_t *info;\n\n    RT_ASSERT(object != RT_NULL);\n    RT_OBJECT_HOOK_CALL(object, detach);\n\n    info = (rt_object_info_t *)object;\n    rt_spin_lock_irqsave(&info->lock, level);\n\n    rt_list_remove(&(info->list));\n\n    rt_spin_unlock_irqrestore(&info->lock, level);\n\n    info->type = 0;\n}", "CodeBleu_score": 40.041293318013295}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n\n    RT_ASSERT(object != RT_NULL);\n\n    RT_OBJECT_HOOK_CALL(object, detach);\n\n    rt_base_t_get_and_set_interrupt_state(&level);\n\n    rt_object_information_t *information = rt_object_get_information(object);\n\n    rt_list_remove(&(information->list));\n\n    rt_base_t_set_interrupt_state(level);\n\n    information->type = 0;\n}", "CodeBleu_score": 30.439944559187847}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    rt_object_info_t *object_info;\n    RT_ASSERT(object != RT_NULL);\n    object_info = rt_object_get_information(object);\n    rt_spin_lock_irqsave(&object_info->lock, level);\n    rt_object_hook_call(object, RT_OBJECT_HOOK_DETACH);\n    rt_list_remove(&(object_info->list_node));\n    rt_spin_unlock_irqrestore(&object_info->lock, level);\n    object_info->type = 0;\n}", "CodeBleu_score": 42.69071219805637}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n    struct rt_custom_object *custom_obj;\n\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n    custom_obj = (struct rt_custom_object *)obj;\n\n    result = RT_EOK;\n    if (custom_obj->destroy != RT_NULL) {\n        result = custom_obj->destroy(custom_obj);\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 56.08205511877898}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n    rt_object_t object;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n    object = (rt_object_t)obj;\n\n    /* call destroy method */\n    if (object->destroy != RT_NULL) {\n        result = object->destroy(object);\n    } else {\n        result = RT_EOK;\n    }\n\n    /* delete object */\n    rt_object_delete(object);\n\n    return result;\n}", "CodeBleu_score": 48.27818346215391}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n    if (obj->destroy != RT_NULL) {\n        result = obj->destroy(obj);\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 47.58528133532836}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    thread = rt_thread_self();\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* exit critical section */\n    rt_exit_critical_safe();\n\n    /* schedule */\n    rt_schedule();\n}", "CodeBleu_score": 64.76145226418797}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread = rt_thread_self();\n    rt_thread_t next_thread;\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* exit critical section */\n    rt_exit_critical_safe();\n\n    /* get next thread */\n    next_thread = rt_schedule();\n\n    /* switch to next thread */\n    rt_switch_to(next_thread);\n}", "CodeBleu_score": 66.91442597665281}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    thread = rt_thread_self();\n    rt_exit_critical_safe();\n    rt_thread_close(thread);\n    rt_thread_defunct_enqueue(thread);\n    rt_schedule();\n}", "CodeBleu_score": 61.23185611181181}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread;\n    rt_base_t timeout;\n\n    RT_ASSERT(parameter);\n\n    thread = (rt_thread_t)parameter;\n\n    if (thread == RT_NULL) {\n        return;\n    }\n\n    timeout = rt_thread_get_timeout(thread);\n\n    if (timeout == RT_WAITING_FOREVER) {\n        return;\n    }\n\n    rt_sched_lock();\n\n    if (rt_sched_thread_is_suspended(thread) != RT_EOK) {\n        rt_sched_unlock();\n        return;\n    }\n\n    rt_thread_set_errno(thread, -ETIMEDOUT);\n    rt_list_remove(&(thread->tlist));\n    rt_sched_insert_thread(thread, RT_THREAD_LIST_READY);\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 41.98379059341981}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread;\n\n    /* check parameter */\n    RT_ASSERT(parameter);\n\n    /* get thread object */\n    thread = (rt_thread_t)parameter;\n\n    /* check object type */\n    if (rt_object_get_type(thread) != RT_Object_Class_Thread) {\n        return;\n    }\n\n    /* lock scheduler */\n    rt_sched_lock();\n\n    /* check thread status */\n    if (thread->status != RT_THREAD_STATUS_SUSPEND) {\n        goto _exit;\n    }\n\n    /* set error number */\n    thread->error = RT_EOK;\n\n    /* remove thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert thread to ready list */\n    rt_sched_insert_thread(thread, RT_THREAD_PRIORITY_MAX);\n\n    /* unlock scheduler */\n    rt_sched_unlock_n_resched();\n\n_exit:\n    return;\n}", "CodeBleu_score": 43.18284829144312}, {"code": "static void _thread_timeout(void *parameter){\n\t  rt_thread_t thread = (rt_thread_t)parameter;\n\n  /* parameter check */\n  RT_ASSERT(thread != RT_NULL);\n\n  /* lock the scheduler */\n  rt_sched_lock();\n\n  /* check the thread status */\n  RT_ASSERT(rt_thread_is_suspended(thread));\n\n  /* set the thread error number */\n  thread->error = RT_ERROR_TIMEOUT;\n\n  /* remove the thread from the suspend list */\n  rt_list_remove(&(thread->tlist));\n\n  /* insert the thread into the ready list */\n  rt_sched_insert_thread(thread, RT_THREAD_READY);\n\n  /* unlock the scheduler */\n  rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 41.793757797596484}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t", "CodeBleu_score": 1.5259533266411016}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t  rt_base_t level;\n  rt_mutex_t mutex;\n  rt_list_t *node;\n\n  /* lock the thread spinlock */\n  level = rt_spin_lock_irqsave();\n\n  /* get the thread mutex list */\n  mutex = thread->mutex;\n\n  /* if the thread is waiting on a mutex */\n  if (mutex != RT_NULL) {\n    /* remove the thread from the mutex waiting list */\n    rt_list_for_each_safe(node, &mutex->wait_list, entry) {\n      if (rt_list_entry(node, struct rt_mutex_wait, entry) == thread) {\n        rt_list_remove(node);\n        break;\n      }\n    }\n\n    /* clear the pending object */\n    mutex->pending = RT_NULL;\n\n    /* release all mutexes the thread has taken */\n    _thread_release_mutex(thread);\n  }\n\n  /* restore the spinlock state */\n  rt_spin_unlock_irqrestore(level);\n}", "CodeBleu_score": 43.20238559413617}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_list_t *list;\n    rt_thread_t thread_to_detach;\n\n    /* lock the thread's spinlock */\n    level = rt_spin_lock_irqsave();\n\n    /* check if the thread is waiting on a mutex */\n    if (thread->wait_mutex != RT_NULL) {\n        /* remove the thread from the mutex's waiting list */\n        list = thread->wait_mutex->wait_list;\n        thread_to_detach = rt_list_entry(list, struct rt_thread, wait_mutex);\n        rt_list_remove(list);\n\n        /* clear the pending object */\n        thread->wait_mutex->pending_object = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    rt_mutex_release(thread->mutex);\n\n    /* restore the spinlock state */\n    rt_spin_unlock_irqrestore(level);\n}", "CodeBleu_score": 39.04059906545334}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    /* check thread state */\n    if (thread->state != RT_Thread_State_Init)\n    {\n        rt_sched_unlock(slvl);\n        return -RT_EINVAL;\n    }\n\n    /* reset thread state */\n    thread->state = RT_Thread_State_Suspended;\n\n    /* reset thread priority */\n    rt_thread_priority_reset(thread);\n\n    /* set thread stack pointer */\n    rt_thread_stack_set(thread);\n\n    /* set thread priority attributes */\n    rt_thread_priority_set(thread);\n\n    /* resume thread */\n    error = rt_thread_resume(thread);\n\n    if (error != RT_EOK)\n    {\n        rt_sched_unlock(slvl);\n        return error;\n    }\n\n    /* trigger scheduler */\n    if (rt_sched_is_enabled())\n    {\n        rt_sched_unlock_n_resched(slvl);\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return RT_EOK;\n}", "CodeBleu_score": 50.42576216596504}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->init_flag == RT_THREAD_INIT);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* log thread name and priority */\n    LOG_D(\"thread: %s, priority: %d\", thread->parent.name, thread->current_priority);\n\n    /* calculate thread priority attributes */\n    rt_thread_priority_calc(thread);\n\n    /* reset thread state to suspended */\n    thread->init_flag = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_sched_lock(&slvl);\n    error = rt_sched_thread_startup(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 54.01343623500973}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->state == RT_Thread_State_Inactive);\n\n    LOG_D(\"thread startup: %s, prio: %d\", thread->parent.name, thread->init_prio);\n\n    /* set thread priority */\n    thread->prio = thread->init_prio;\n\n    /* calculate thread priority attributes */\n    rt_thread_prio_calc(thread);\n\n    /* reset thread state */\n    thread->state = RT_Thread_State_Suspended;\n\n    /* resume thread */\n    rt_sched_lock(&slvl);\n    error = rt_sched_thread_startup(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 52.98580504945454}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *timer_entry;\n    rt_base_t level;\n\n    /* get the highest level of the timer skip list */\n    level = rt_list_get_highest_level(timer_list);\n\n    /* check if the highest level of the timer skip list is not empty */\n    if (level > 0) {\n        /* get the first timer entry */\n        timer_entry = rt_list_first(timer_list[level]);\n\n        /* set the provided timeout tick to the timer's timeout value */\n        *timeout_tick = rt_list_entry(timer_entry, struct rt_timer_node, node)->timeout;\n\n        /* return RT_EOK */\n        return RT_EOK;\n    }\n\n    /* return an error code */\n    return -RT_ERROR;\n}", "CodeBleu_score": 43.64455448638443}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *timer_list_head;\n    rt_timer_t *timer;\n    rt_tick_t tick;\n\n    /* find the first timer list head which is not empty */\n    for (int i = 0; i < RT_TIMER_MAX_LEVEL; i++) {\n        timer_list_head = &timer_list[i];\n        if (!rt_list_isempty(timer_list_head)) {\n            /* get the first timer entry */\n            timer = rt_list_entry(timer_list_head->next, rt_timer_t, list[i]);\n            tick = timer->timeout;\n\n            /* set the timeout tick */\n            *timeout_tick = tick;\n            return RT_EOK;\n        }\n    }\n\n    /* no timer is found */\n    return -RT_ERROR;\n}", "CodeBleu_score": 38.66178750902819}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *head;\n    rt_list_t *next;\n    struct rt_timer *timer;\n    rt_tick_t ticks;\n\n    /* get the head of the timer list */\n    head = timer_list;\n\n    /* check if the timer list is empty */\n    if (rt_list_isempty(head)) {\n        return RT_ERROR;\n    }\n\n    /* get the first timer entry */\n    next = head->next;\n\n    /* get the timer */\n    timer = rt_list_entry(next, struct rt_timer, node);\n\n    /* get the timeout value of the timer */\n    ticks = timer->timeout;\n\n    /* set the timeout tick */\n    *timeout_tick = ticks;\n\n    /* return success */\n    return RT_EOK;\n}", "CodeBleu_score": 47.81007000215447}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time <= RT_TIMER_MAX_DELAY);\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer);\n    if (timer == RT_NULL) return RT_NULL;\n\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* set timer name */\n    rt_object_set_name((rt_object_t)timer, name);\n\n    return timer;\n}", "CodeBleu_score": 66.26284288224342}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* check the arguments */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time != 0);\n\n    /* allocate a timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize the timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 76.88218364352373}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time <= RT_TIMER_MAX_DELTA_TICK);\n\n    /* allocate timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer);\n    if (timer == RT_NULL) return RT_NULL;\n\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* set timer name */\n    rt_object_set_name(&(timer->parent), name);\n\n    return timer;\n}", "CodeBleu_score": 66.08142269655734}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.handler.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 63.78095539663596}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\thandler := http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\ta.router.ServeHTTP(rec, req)\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t})\n\thandler.ServeHTTP(res, req)\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", rec.Code)\n\t\treturn\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 64.08340791379442}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 76.62963690977166}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\n\tasset, err := a.assets.Get(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tparts := strings.Split(path, \".\")\n\text := parts[len(parts)-1]\n\n\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tres.Write(asset)\n}", "CodeBleu_score": 47.44595165322491}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := strings.Split(req.URL.Path, \"/\")\n\tif len(path) < 2 {\n\t\thttp.Error(res, \"404 not found.\", http.StatusNotFound)\n\t\treturn\n\t}\n\tasset, err := a.assets.Get(path[1])\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", asset.Header.Get(\"Content-Type\"))\n\tres.Write(asset.Content)\n}", "CodeBleu_score": 46.001166108334026}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.assets.Get(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 404)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tres.Write(asset)\n}", "CodeBleu_score": 30.207945987083427}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 29.747120305740193}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot found with name: \" + name})\n\t\treturn\n\t}\n\n\tconnections := []Connection{}\n\trobot.Connections().Each(func(conn Connection) {\n\t\tconnections = append(connections, conn)\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 44.09033026044026}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tconnectionsJSON := []interface{}{}\n\tconnections.Each(func(conn gobot.Connection) {\n\t\tconnectionsJSON = append(connectionsJSON, conn)\n\t})\n\n\ta.writeJSON(res, connectionsJSON)\n}", "CodeBleu_score": 47.33413261439728}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.77802914682379}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Continue with the actual request.\n\t}\n}", "CodeBleu_score": 49.77802914682379}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tuser, pass, ok := req.BasicAuth()\n\t\tif ok && secureCompare(username, user) && secureCompare(password, pass) {\n\t\t\treturn\n\t\t}\n\t\tres.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 68.13555507065469}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tscale := float64(toRange) / float64(fromRange)\n\toffset := toMin - int(fromMin * scale)\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input * scale) + offset\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.96924974619573}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromMin := fromMin\n\tfromMax := fromMax\n\ttoMin := toMin\n\ttoMax := toMax\n\t\n\tslope := float64(toMax - toMin) / float64(fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\t\n\treturn func(input float64) (value int) {\n\t\tvalue := int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 51.79477241908963}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\n\tscale := float64(toMax-toMin) / float64(fromMax-fromMin)\n\toffset := float64(toMin) - (fromMin * scale)\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input * scale + offset)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.807313537680486}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.sensorCfg.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 56.436728821389394}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\n\trawValue, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.sensorCfg.scale(float64(rawValue))\n\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 63.15107356878129}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.sensorCfg.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 56.16537183751992}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\t\n\t\n\n\t\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\n\t\n\treturn func(x int) float64 {\n\t\ty := m*float64(x) + n\n\t\tif y < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif y > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn y\n\t}\n}", "CodeBleu_score": 65.64250704478198}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tdeltaFrom := float64(fromMax - fromMin)\n\tdeltaTo := toMax - toMin\n\n\treturn func(input int) float64 {\n\t\tinputFloat := float64(input)\n\t\tinputScaled := (inputFloat - float64(fromMin)) / deltaFrom\n\t\toutput := inputScaled * deltaTo + toMin\n\t\treturn output\n\t}\n}", "CodeBleu_score": 55.023516308648205}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\n    // Calculate the slope (m) and intercept (n) for the linear transformation\n    m := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n    n := toMin - m*float64(fromMin)\n\n    // Return the scaling function\n    return func(input int) float64 {\n        return m*float64(input) + n\n    }\n}", "CodeBleu_score": 57.53251488648912}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: gpio.NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(d.Event)\n\n\td.On(d.Event(\"data\"), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(\"vibration\"), true)\n\t\t}\n\t})\n\n\tif err := d.Halt(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 51.48280324025699}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(d.Event(\"vibration\"))\n\n\td.On(d.Event(\"data\"), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(\"vibration\"), data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 45.87776383842246}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(d.Event)\n\td.On(d.Event, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event, data)\n\t\t}\n\t})\n\tif err := d.SetDataHandler(d.handleData); err != nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 56.54986702048513}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := time.Duration(float64(time.Second) / hz)\n\ttempo := time.Duration(float64(time.Minute) / (d.bpm * 4))\n\td.On()\n\tfor i := time.Duration(0); i < duration*time.Second; i += period {\n\t\ttime.Sleep(tempo)\n\t\td.Off()\n\t\ttime.Sleep(tempo)\n\t}\n\td.Off()\n\treturn nil\n}", "CodeBleu_score": 32.73102728058692}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\n\tperiod := (1 / hz) * 60 * 1000 * 1000\n\n\td.On()\n\n\tfor i := 0; i < int(duration*1000); i += int(period) {\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.91169914591424}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.Pin == noPin {\n\t\treturn ErrBadPin\n\t}\n\tif hz < 0 || hz > 20000 {\n\t\treturn fmt.Errorf(\"tone: invalid frequency %v\", hz)\n\t}\n\tif duration < 0 || duration > 10000 {\n\t\treturn fmt.Errorf(\"tone: invalid duration %v\", duration)\n\t}\n\n\tperiod := time.Duration(float64(time.Second) / hz)\n\td.On(period)\n\ttime.Sleep(time.Duration(duration) * time.Millisecond)\n\td.Off()\n\treturn nil\n}", "CodeBleu_score": 38.3078990106679}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\tif d.isRunning() {\n\t\td.stop()\n\t}\n\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 34.19434432011484}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not configured\")\n\t}\n\n\td.stopIfRunning()\n\n\td.digitalWrite(d.sleepPin, false)\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 32.46218744026996}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.528340806641403}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor pins map is nil\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, params := a.translate(id)\n\tif path == \"\" {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor could not find pin for: \" + id)\n\t}\n\tpin := a.sys.NewAnalogPin(path, params...)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 45.41851320688688}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map not initialized\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 56.586132796486524}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, params := a.translate(id)\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 41.55224180062175}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 64.50419399718643}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 64.66698910261657}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.WithPinDirectionOutput(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 66.50902858598684}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.connected {\n\t\treturn nil, fmt.Errorf(\"adaptor must be connected to pins\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin != nil {\n\t\tpin.ApplyOptions(opts...)\n\t\treturn pin, nil\n\t}\n\n\tchip, line, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin = a.sys.NewDigitalPin(chip, line)\n\tif err := a.initialize(pin); err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin.ApplyOptions(opts...)\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 58.583288152483405}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.connected {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor must be connected to use pins\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\tpin.ApplyOptions(opts...)\n\t\treturn pin, nil\n\t}\n\n\tchip, line, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin = a.sys.NewDigitalPin(chip, line)\n\ta.initialize(pin)\n\tpin.ApplyOptions(opts...)\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 52.32974408484844}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connection == nil {\n\t\treturn nil, fmt.Errorf(\"digital pin %s is not connected to an adaptor\", id)\n\t}\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\tpin.ApplyOptions(opts...)\n\t\treturn pin, nil\n\t}\n\n\tchip, line, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin = a.sys.NewDigitalPin(chip, line)\n\tpin.ApplyOptions(opts...)\n\n\tif err := a.initialize(pin); err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 61.69977588680096}]}
