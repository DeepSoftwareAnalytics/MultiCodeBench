{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t", "CodeBleu_score": 8.781990752468507}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = FileTransfer::GetFiles(folder);\n\tfor (auto &file : files) {\n\t\tif (download) {\n\t\t\tif (FileTransfer::FileExists(file)) {\n\t\t\t\tlog_info << \"File \" << file << \" is already in the cache.\" << std::endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog_info << \"File \" << file << \" is not in the cache, requesting from server...\" << std::endl;\n\t\t\t\tRequestFile(file);\n\t\t\t}\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\treturn requiredFiles;\n}", "CodeBleu_score": 49.95117831416284}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\tstd::vector<std::string> required_files;\n// Iterate through each file in the folder\nfor (const auto &file : FileTransfer::GetFiles(folder)) {\n// Check if the file exists locally\nif (!FileTransfer::FileExists(file)) {\n// If the file doesn't exist, request it from the server and log the download action\nif (download) {\n_pimpl->CallAndWait<std::vector<uint8_t>>(\"request_file\", file);\nlog_info(\"Downloading \" + file);\n} else {\nlog_info(\"File \" + file + \" not found\");\n}\n} else {\nlog_info(\"File \" + file + \" found in cache\");\n}\n// Add the file to the list of required files\nrequired_files.push_back(file);\n}\nreturn required_files;\n}", "CodeBleu_score": 55.02944995888473}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n//  auto spawn_actor_with_parent_task = [this, description, transform, parent, attachment_type, socket_name]() {\n//    return _pimpl->Call<rpc::Actor>\n//        (rpc::RpcMethod::SpawnActorWithParent,\n//         description,\n//         transform,\n//         parent,\n//         attachment_type,\n//         socket_name);\n//  };\n//\n//  return _pimpl->CallAndWait(spawn_actor_with_parent_task);\n}", "CodeBleu_score": 8.495909444103484}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\t// TODO: Check validity of transform\n\trpc::ActorId actor_id = SpawnActor(description, transform);\n\tAttachActorToParent(actor_id, parent, attachment_type, socket_name);\n\treturn actor_id;\n}", "CodeBleu_score": 23.751875738869526}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\trpc::Actor actor = _pimpl->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n\treturn actor;\n}", "CodeBleu_score": 26.51003580744371}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// Get the token for the G-buffer.\n\tauto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(ActorId, GBufferId, rpc::GetGBufferToken);\n\t// Copy the token data.\n\tstd::vector<unsigned char> token_data_copy(token_data.size());\n\tstd::memcpy(token_data_copy.data(), token_data.data, token_data.size());\n\t// Subscribe to the streaming client using the provided callback function.\n\t_pimpl->streaming_client.Subscribe(std::move(token_data_copy), std::move(callback));\n}", "CodeBleu_score": 62.618169452886676}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// TODO: Implement this function.\n\t// Get the token for the G-buffer\n\tauto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(ActorId, GBufferId, rpc::GBufferToken);\n\t// Copy the token data into a buffer\n\tstd::vector<unsigned char> token_buffer(token_data.size());\n\tstd::memcpy(token_buffer.data(), token_data.data, token_data.size);\n\t// Subscribe to the streaming client using the provided callback function\n\t_pimpl->streaming_client.Subscribe(token_buffer, callback);\n}", "CodeBleu_score": 62.72115081179586}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\tauto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\n      rpc::Method::SubscribeToGBuffer,\n      ActorId,\n      GBufferId);\n\n\tstd::memcpy(_pimpl->streaming_client.token, token_data.data(), token_data.size());\n\t_pimpl->streaming_client.Subscribe(std::move(callback));\n}", "CodeBleu_score": 61.39510096317711}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t", "CodeBleu_score": 7.276206331150749}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> _walker_navigation = nullptr;\n\tstd::atomic_bool _walker_navigation_is_null = true;\n\twhile (_walker_navigation_is_null) {\n\t\t_walker_navigation = GetWalkerNavigation();\n\t\tif (_walker_navigation == nullptr) {\n\t\t\t_walker_navigation = std::make_shared<WalkerNavigation>();\n\t\t\t_walker_navigation_is_null = false;\n\t\t}\n\t\telse {\n\t\t\t_walker_navigation_is_null = false;\n\t\t}\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 41.19503457165604}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation;\n\twhile (!navigation) {\n\t\tnavigation = _walker_navigation.load();\n\t\tif (!navigation) {\n\t\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t\t\tif (!_walker_navigation.compare_exchange(navigation, nullptr)) {\n\t\t\t\tnavigation = _walker_navigation.load();\n\t\t\t}\n\t\t}\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 49.374423866296794}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::system_clock::now();\n\twhile (episode.GetState()->GetFrame() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (std::chrono::system_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tepisode.GetState()->GetTrafficManager()->Tick();\n\treturn true;\n}", "CodeBleu_score": 40.23698135623156}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (frame > episode.GetState()->GetFrame()) {\n\t\tstd::this_thread::yield();\n\t}\n\tif (std::chrono::system_clock::now() > episode.GetState()->GetTimestamp() + timeout.to_chrono()) {\n\t\treturn false;\n\t}\n\tcarla::traffic_manager::TrafficManager::Tick();\n\treturn true;\n}", "CodeBleu_score": 30.135442720164075}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::system_clock::now();\n\twhile (episode.GetState()->GetFrame() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start).count() > timeout.to_chrono()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tepisode.GetTrafficManager()->Tick();\n\treturn true;\n}", "CodeBleu_score": 46.399959164422924}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\trpc::EpisodeId episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\tEpisodeProxy episode{shared_from_this()};\n\tepisode.GetReady(episode_id);\n\treturn episode;\n}", "CodeBleu_score": 23.82007132896069}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tif (map_name == \"\") {\n\t\tthrow std::runtime_error(\"Map name cannot be empty\");\n\t}\n\tEpisodeProxy episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\t_episode = episode;\n\treturn episode;\n}", "CodeBleu_score": 20.25832679105461}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode = GetCurrentEpisode();\n\tif (episode.GetId()!= 0) {\n\t\t_client.Disconnect();\n\t\t_client.Connect();\n\t}\n\t_client.LoadEpisode(map_name, reset_settings, map_layers);\n\tGetReadyCurrentEpisode();\n\treturn episode;\n}", "CodeBleu_score": 28.635824609861782}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tassert(_episode!= nullptr);\n\tauto walker = GetWalker(controller.GetDisplayId());\n\tassert(walker!= nullptr);\n\tif (walker->GetId() == controller.GetId()) {\n\t\tthrow std::runtime_error(\"The walker and controller have the same ID\");\n\t}\n\tif (walker->GetParent()!= nullptr) {\n\t\tthrow std::runtime_error(\"The walker is already registered with a controller\");\n\t}\n\tauto nav = _episode->CreateNavigationIfMissing(walker->GetPosition());\n\twalker->RegisterWalker(controller.GetId(), nav);\n}", "CodeBleu_score": 53.539733531397374}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// TODO: Implement this function\n\tstd::string walkerId = controller.GetId();\n\tWalker *walker = GetWalker(walkerId);\n\tassert(walker!= nullptr);\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\tEpisode *episode = walker->GetEpisode();\n\tassert(episode!= nullptr);\n\tif (episode == nullptr) {\n\t\tthrow std::runtime_error(\"Episode not found\");\n\t}\n\tNavigation *nav = episode->CreateNavigationIfMissing();\n\tnav->RegisterWalker(walkerId);\n}", "CodeBleu_score": 52.17673362925327}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller\n\tWalker *walker = GetWalker(controller.GetDisplayId());\n\n\t// Throw an exception if the walker is not found\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found for controller\");\n\t}\n\n\t// Assert that the episode is not null\n\tassert(episode!= nullptr);\n\n\t// Create navigation if it is missing\n\tNavigation *nav = episode->CreateNavigationIfMissing();\n\n\t// Register the walker with the controller's ID\n\tnav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 57.45356250933188}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#if defined(DEBUG)\n    if (parent!= nullptr) {\n      DEBUG_ASSERT(parent->GetEpisode() == GetCurrentEpisode());\n    }\n#endif\n    if (parent!= nullptr) {\n      return SpawnActorWithParent(blueprint, transform, parent, attachment_type, gc, socket_name);\n    } else {\n      return SpawnActorWithoutParent(blueprint, transform, gc);\n    }\n  }", "CodeBleu_score": 32.388714926095574}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef DEBUG_ASSERT\n  DEBUG_ASSERT(sensor.GetEpisode()!= nullptr);\n#endif\n  auto &ep = *sensor.GetEpisode();\n  auto &client = ep.GetClient();\n  auto stream_token = sensor.GetActorDescription().GetStreamToken();\n  client.SubscribeToStream(stream_token, std::move(callback));\n}", "CodeBleu_score": 44.26147336519421}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\t// Check that the episode is valid.\n\tif (!IsEpisodeValid()) {\n\t\tthrow std::runtime_error(\"Cannot subscribe to sensor: Episode is invalid.\");\n\t}\n\n\t// Subscribe to the sensor's data stream using the client's SubscribeToStream method.\n\tauto stream_token = sensor.GetActorDescription().GetStreamToken();\n\tauto cb = std::make_shared<Callback>(callback);\n\tauto ep = GetEpisode();\n\tep->TryLock();\n\tauto client = GetClient();\n\tclient->SubscribeToStream(stream_token, [ep, cb](sensor::SensorDataPtr sensor_data) {\n\t\t// Deserialize the incoming data and associate it with the current episode.\n\t\tauto data = std::make_shared<sensor::SensorData>(ep, sensor_data);\n\t\t// Invoke the provided callback with the sensor data.\n\t\tcb->callback(data);\n\t});\n}", "CodeBleu_score": 49.99591307597536}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef DEBUG_ASSERT\n  DEBUG_ASSERT(sensor.GetEpisode()!= nullptr, \"Sensor must be part of an episode.\");\n#endif\n\n  // Subscribe to the sensor's data stream\n  auto &client = GetClient();\n  auto stream_token = sensor.GetActorDescription().GetStreamToken();\n  client.SubscribeToStream(stream_token, [callback, sensor](const sensor::SensorData &data) {\n    auto sensor_data = sensor::Deserializer::Deserialize(data);\n    sensor_data->SetSensor(&sensor);\n    callback(sensor_data);\n  });\n}", "CodeBleu_score": 47.89064123794719}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// load walkers\nstd::vector<WalkerHandle> walkers;\n_simulator.lock()->GetWalkerList(walkers);\n\n// check if list is empty\nif (walkers.empty())\n  return;\n\n// get current state\nstd::shared_ptr<const EpisodeState> state = episode->GetState();\n\n// remove any walkers that no longer exist\nCheckIfWalkerExist(walkers, *state);\n\n// update vehicles in crowd\nUpdateVehiclesInCrowd(episode, false);\n\n// update the crowd\n_nav.UpdateCrowd();\n\n// for each walker\nfor (auto &&walker : walkers) {\n  // get the transform\n  const carla::geom::Transform &transform = walker.walker.transform;\n  // get the speed\n  float speed = walker.walker.speed;\n\n  // apply the states in a batch\n  _simulator.lock()->ApplyBatchSync(transform, speed);\n\n  // check if walker is dead\n  if (_simulator.lock()->IsActorDead(walker.walker)) {\n    // remove from the crowd\n    _nav.RemoveAgent(walker.walker);\n    // destroy the controller\n    _simulator.lock()->DestroyActor(walker.controller);\n    // unregister from list\n    UnregisterWalker(walker.walker, walker.controller);\n  }\n}\n\n}", "CodeBleu_score": 43.73496627981308}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// load walkers\nstd::vector<WalkerHandle> walkers = Load(episode);\n// check if empty\nif (walkers.empty()) return;\n\n// get current state\nstd::shared_ptr<const EpisodeState> state = episode->GetState();\n// remove any walkers that no longer exist\nCheckIfWalkerExist(walkers, *state);\n\n// update the vehicles in the crowd\nUpdateVehiclesInCrowd(episode, false);\n// update the crowd\n_nav.UpdateCrowd();\n\n// get the current state\nstate = episode->GetState();\n\n// apply batch sync\n_simulator.lock()->ApplyBatchSync();\n\n// get the walkers\nfor (auto &&walker : walkers) {\n  // get the walker transform\n  carla::geom::Location transform = _nav.GetWalkerTransform(walker.walker);\n  // get the walker speed\n  float speed = _nav.GetWalkerSpeed(walker.walker);\n  // set the state\n  _simulator.lock()->SetActorState(walker.walker, transform, speed);\n  // set the controller\n  _simulator.lock()->SetActorState(walker.controller, transform, speed);\n}\n\n// check if any walker is dead\nfor (auto &&walker : walkers) {\n  // check if dead\n  if (!_nav.IsWalkerAlive(walker.walker)) {\n    // remove from the crowd\n    _nav.RemoveAgent(walker.walker);\n    // destroy the controller\n    _simulator.lock()->DestroyActor(walker.controller);\n    // unregister from list\n    UnregisterWalker(walker.walker, walker.controller);\n  }\n}\n\n}", "CodeBleu_score": 49.94894587821831}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t//    std::cout << \"WalkerNavigation::Tick\" << std::endl;\n    // get the walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n    // check if empty\n    if (walkers.empty()) return;\n\n    // get the current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n    // remove any walkers that no longer exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, _show_debug);\n\n    // for each walker\n    for (auto &&walker : walkers) {\n      // get the transform\n      carla::geom::Location transform = walker.walker->transform.location;\n      // get the speed\n      float speed = walker.walker->speed;\n      // apply in batch\n      _simulator.lock()->ApplyBatchSync(walker.controller, transform, speed);\n    }\n\n    // check if any walker is dead\n    for (auto &&walker : walkers) {\n      // check if dead\n      if (walker.walker->is_dead) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 43.875957116887356}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_id(id);\n\tdescription.set_uid(uid);\n\tdescription.attributes.reserve(attributes.size());\n\tfor (auto const& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute.MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 63.47453129449694}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.9808456489869}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(GetUID());\n\tdescription.set_id(GetID());\n\tdescription.mutable_attributes()->Reserve(attributes.size());\n\tfor (auto& attribute : attributes) {\n\t\tdescription.mutable_attributes()->AddAllocated(attribute.MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 56.80847681779694}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tif (pair.second.GetAttribute(name) == value || pair.second.GetAttribute(name).Contains(value)) {\n\t\t\t\tresult->AddBlueprint(pair.first, pair.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 34.40145089435911}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto& pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tif (pair.second.GetValue(name) == value || pair.second.GetRecommendedValues(name).Contains(value)) {\n\t\t\t\tresult->blueprints.emplace(pair.first, pair.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 36.8540245197082}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\tfor (auto& pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tif (pair.second.GetAttribute(name) == value || pair.second.GetRecommendedValues(name).Contains(value)) {\n\t\t\t\tresult->AddBlueprint(pair.first, pair.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 34.5777220803024}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = base_path + \"/\" + version + \"/\" + path;\n\tif (!carla::FileSystem::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<char*>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 48.3363897417796}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = path + \"/\" + this->GetVersionFolder();\n\tif (!carla::FileSystem::ValidateFilePath(fullPath)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(fullPath.c_str(), std::ios::binary | std::ios::trunc);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<const char*>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 47.20110343003625}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = baseFolder + \"/\" + path;\n\tif (!carla::FileSystem::ValidateFilePath(fullPath)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<const char *>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 48.22940051810082}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n//    const auto parent_bounds = parent_->GetBounds(frame);\n//    const auto location = parent_bounds->location + transform.location;\n//    const auto yaw = transform.rotation.yaw();\n//    const auto extents = parent_bounds->extents;\n//    const auto corners = geom::Location::Rotate(yaw, extents);\n//    return std::make_shared<Bounds>(frame, location, corners);\n    return nullptr;\n  }", "CodeBleu_score": 6.7348535309838615}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n//    const auto location = geom::Location::Add(parent_bounds->location(), transform.location());\n    const auto location = geom::Location::Add(parent_bounds->location(), transform.location());\n\n    const auto yaw = transform.rotation().yaw();\n    const auto extents = parent_bounds->extents();\n    const auto x = extents.x() * std::cos(yaw) - extents.y() * std::sin(yaw);\n    const auto y = extents.x() * std::sin(yaw) + extents.y() * std::cos(yaw);\n\n    return std::make_shared<const Bounds>(frame, location, x, y);\n  }", "CodeBleu_score": 43.13103008940518}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::unique_lock<std::mutex> lock(_episode.Lock()->GetLightManagerMutex());\n\tstd::vector<LightState> lightStates = _episode.Lock()->QueryLightsStateToServer();\n\tlock.unlock();\n\n\tfor (auto lightState : lightStates) {\n\t\tstd::unique_lock<std::mutex> lock(_lightsMutex);\n\t\tauto it = _lights.find(lightState.GetID());\n\t\tif (it == _lights.end()) {\n\t\t\t_lights[lightState.GetID()] = new Light(lightState);\n\t\t} else {\n\t\t\tit->second->Update(lightState);\n\t\t}\n\t}\n}", "CodeBleu_score": 46.368316780406744}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_episode.Lock()->GetLightManagerMutex());\n\tstd::vector<LightState> lightStates = _episode.Lock()->QueryLightsStateToServer();\n\t_lights.clear();\n\tfor (LightState lightState : lightStates) {\n\t\tif (_lights.find(lightState.GetLightId()) == _lights.end()) {\n\t\t\t_lights.insert(std::pair<int, Light>(lightState.GetLightId(), Light(lightState.GetLightId())));\n\t\t}\n\t\t_lights.at(lightState.GetLightId()).UpdateState(lightState);\n\t}\n}", "CodeBleu_score": 39.92962260336227}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\t_episode.Lock();\n\n\t// Query the server for the current light states\n\tLightState lightState = _episode.Lock()->QueryLightsStateToServer();\n\n\t// Update the local light states\n\t_episode.Lock()->UpdateLightsState(lightState);\n\n\t// Unlock the mutex\n\t_episode.Unlock();\n\n\t// Create new light objects if they do not already exist in the _lights map\n\tfor (auto& lightState : lightState.lightStates) {\n\t\tif (_lights.find(lightState.id) == _lights.end()) {\n\t\t\t_lights[lightState.id] = new Light(lightState);\n\t\t}\n\t}\n}", "CodeBleu_score": 28.627291179345733}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::unique_lock<std::mutex> lock(_episode.Lock());\n\tif (!_lights_changes.empty()) {\n\t\tstd::vector<rpc::Color> message;\n\t\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); it_light++) {\n\t\t\tif (_lights_changes.find(it_light->first)!= _lights_changes.end()) {\n\t\t\t\tmessage.push_back(it_light->second.GetLocation());\n\t\t\t}\n\t\t}\n\t\t_episode.UpdateServerLightsState(message);\n\t\t_lights_changes.clear();\n\t\t_lights_dirty = false;\n\t}\n\tif (discard_client) {\n\t\t_client_light_dirty = false;\n\t}\n}", "CodeBleu_score": 43.92155690602811}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_episode.Lock());\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\tstd::vector<rpc::Color> message;\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); it_light++) {\n\t\tif (_lights_changes.find(it_light->first)!= _lights_changes.end()) {\n\t\t\tmessage.push_back(it_light->second.GetLocation());\n\t\t}\n\t}\n\tif (message.size() > 0) {\n\t\trpc::Message msg(rpc::MessageType::LIGHTS_UPDATE);\n\t\tmsg.push_back(message);\n\t\t_episode.GetLocation()->GetServer()->SendMessage(msg, discard_client);\n\t}\n\t_lights_changes.clear();\n\t_dirty = false;\n}", "CodeBleu_score": 48.61207351573746}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_episode.Lock());\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\tstd::vector<rpc::Color> message;\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); ++it_light) {\n\t\tif (_lights_changes.find(it_light->first)!= _lights_changes.end()) {\n\t\t\tmessage.push_back(it_light->second.GetLocation());\n\t\t}\n\t}\n\tif (discard_client) {\n\t\t_episode.GetLocation()->UpdateServerLightsState(message);\n\t} else {\n\t\t_episode.GetLocation()->UpdateServerLightsState(message);\n\t}\n\t_lights_changes.clear();\n\t_lights_dirty = false;\n}", "CodeBleu_score": 44.550465382873085}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"This sensor's ID is not \\\"sensor.other.v2x_custom\\\". It will not send a message.\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message, GetContext());\n}", "CodeBleu_score": 51.41585766340635}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetID()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"Sensor ID is not'sensor.other.v2x_custom' - cannot send message to episode.\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 52.97019508447471}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetEpisode().Lock()->GetSensorId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"This sensor is not the correct type. It should be sensor.other.v2x_custom.\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 53.50029799062121}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (tm.RegisterVehicles(this, tm_port)) {\n\t\t\tm_autopilot_enabled = true;\n\t\t}\n\t} else {\n\t\tif (tm.UnregisterVehicles(this)) {\n\t\t\tm_autopilot_enabled = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.680424443049944}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(shared_from_this());\n\t} else {\n\t\ttm.UnregisterVehicles(shared_from_this());\n\t}\n}", "CodeBleu_score": 48.2133010300425}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(this);\n\t} else {\n\t\ttm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 32.64858071138209}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\twalker = GetOwner();\n\twalker->GetNavigationSystem()->RegisterAgentForNavMeshPathfinding(walker);\n\twalker->SetActorLocation(GetEpisode().Lock()->GetWalkerLocation());\n\twalker->SetActorHiddenInGame(true);\n\twalker->SetActorEnableCollision(false);\n\twalker->SetActorEnablePhysics(false);\n}", "CodeBleu_score": 31.671091844557854}, {"code": "void WalkerAIController::Start(){\n\t\twalker = GetActor();\n\tGetEpisode().Lock()->RegisterAIController(this);\n\twalker->GetLocation();\n\tGetEpisode().Lock()->GetNavigation().Add(walker);\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 43.03779929460987}, {"code": "void WalkerAIController::Start(){\n\t\tGetEpisode().Lock()->RegisterAIController(this);\n\twalker = GetOwner();\n\tGetEpisode().Lock()->GetNavigation().Add(walker, walker->GetLocation());\n\twalker->SetActorSimulatePhysics(false);\n\twalker->SetActorCollisions(false);\n}", "CodeBleu_score": 37.49333622642451}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (GetEpisode()!= nullptr) {\n\t\tauto nav = GetEpisode()->GetNavigation();\n\t\tif (nav!= nullptr) {\n\t\t\tauto parent = GetParent();\n\t\t\tif (parent!= nullptr) {\n\t\t\t\tnav->SetWalkerMaxSpeed(parent, max_speed);\n\t\t\t} else {\n\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed - Could not find parent walker.\");\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed - Could not find navigation.\");\n\t\t}\n\t} else {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed - Could not find episode.\");\n\t}\n}", "CodeBleu_score": 55.339638019182544}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the navigation instance from the current episode\n\tNavigation* nav = GetEpisode().Lock()->GetNavigation();\n\n\t// Check if the navigation instance is valid\n\tif (nav!= nullptr) {\n\t\t// Get the parent walker\n\t\tWalker* walker = GetParent();\n\n\t\t// Check if the walker is valid\n\t\tif (walker!= nullptr) {\n\t\t\t// Attempt to set the walker's maximum speed using the navigation instance\n\t\t\tif (!walker->SetMaxSpeed(max_speed, nav)) {\n\t\t\t\tlog_warning(\"Failed to set walker's maximum speed using navigation instance.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog_warning(\"Failed to find walker.\");\n\t\t}\n\t}\n\telse {\n\t\tlog_warning(\"Failed to find navigation instance.\");\n\t}\n}", "CodeBleu_score": 57.60190499590784}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (!nav) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Navigation is not valid.\");\n\t\treturn;\n\t}\n\tauto walker = GetParent();\n\tif (!walker) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Walker is not valid.\");\n\t\treturn;\n\t}\n\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to set walker max speed.\");\n\t}\n}", "CodeBleu_score": 59.26861568480144}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(distance).size());\n\tfor (auto &it : _parent->GetMap().GetPrevious(distance)) {\n\t\tresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, it)));\n\t}\n\treturn result;\n}", "CodeBleu_score": 56.60776972753254}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(this, distance).size());\n\tfor (auto& waypoint : _parent->GetMap().GetPrevious(this, distance)) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 54.74314105288215}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(distance).size());\n\tfor (auto& wp : _parent->GetMap().GetPrevious(distance)) {\n\t\tresult.emplace_back(new Waypoint(_parent, wp));\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.90143378188896}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tstd::set<SharedPtr<Signal>> added_signals;\n\tfor (const SharedPtr<Signal>& signal : signals) {\n\t\tif (added_signals.count(signal) == 0) {\n\t\t\tSharedPtr<Landmark> landmark = signal->GetLandmark();\n\t\t\tif (landmark) {\n\t\t\t\tresult.emplace_back(landmark);\n\t\t\t\tadded_signals.insert(signal);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 43.56370890432122}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tstd::set<SharedPtr<Signal>> added_signals;\n\tfor (auto signal : signals) {\n\t\tif (added_signals.count(signal) == 0) {\n\t\t\tSharedPtr<Landmark> landmark = signal->GetLandmark();\n\t\t\tresult.emplace_back(landmark);\n\t\t\tadded_signals.insert(signal);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 42.32852049739731}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\n\tstd::vector<SharedPtr<Landmark>> landmarks = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto landmark : landmarks) {\n\t\tif (std::find(result.begin(), result.end(), landmark) == result.end()) {\n\t\t\tresult.emplace_back(landmark);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 31.884831002838926}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t// TODO: Implement this function.\n\t// TODO: If the setting is not correctly applied after a number of attempts, a warning is logged.\n\t// TODO: If the settings include a fixed delta time, it attempts to verify the accuracy of this setting over a series of ticks.\n\t// TODO: Set a local timeout based on the provided timeout or the episode's networking timeout.\n\t// TODO: Apply the provided episode settings to the world.\n\t// TODO: Return the identifier of the applied settings.\n\treturn 0;\n}", "CodeBleu_score": 3.2297002042048955}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t//    if (settings.fixed_delta_seconds.has_value()) {\n//        float fixed_delta_seconds = settings.fixed_delta_seconds.get();\n//        float curr_delta_seconds = _episode.Lock()->GetFixedDeltaSeconds();\n//        if (abs(fixed_delta_seconds - curr_delta_seconds) > std::numeric_limits<float>::epsilon) {\n//            log_warning(\"Fixed delta seconds {} does not match current value of {}. Will not apply settings.\", fixed_delta_seconds, curr_delta_seconds);\n//            return 0;\n//        }\n//    }\n//\n//    _episode.Lock()->SetEpisodeSettings(settings);\n//    return _episode.Lock()->GetEpisodeSettingsId();\n//  }", "CodeBleu_score": 3.171605579650036}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0? _episode.Lock()->GetNetworkingTimeout() : timeout;\n\tif (settings.fixed_delta_seconds.has_value()) {\n\t\ttime_duration delta_time = *settings.fixed_delta_seconds.get();\n\t\tfloat accuracy = 0.0;\n\t\tuint64_t attempts = 0;\n\t\twhile (accuracy < 1.0 && attempts < 10) {\n\t\t\tattempts++;\n\t\t\tuint64_t start_tick = GetTick();\n\t\t\tApplySettings(settings);\n\t\t\tuint64_t end_tick = GetTick();\n\t\t\tfloat delta = (end_tick - start_tick) / 1000.0f;\n\t\t\taccuracy = delta_time.count() / delta;\n\t\t}\n\t\tif (accuracy < 1.0) {\n\t\t\tlog_warning(\"World::ApplySettings: Failed to apply fixed delta time setting correctly after {} attempts. Delta time: {}ms, Accuracy: {}.\", attempts, delta_time.count(), accuracy);\n\t\t}\n\t}\n\t_episode.Lock()->SetEpisodeSettings(settings);\n\treturn _episode.Lock()->GetSettingsId();\n}", "CodeBleu_score": 52.28090296479044}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat x0, float y0, float x1, float y1, float x, float y\n\tfloat dx = x1 - x0, float dy = y1 - y0\n\tfloat t = dx * dx + dy * dy\n\tif (t == 0) {\n\t\treturn std::make_pair(Distance2D(x, y, x0, y0), Distance2D(x, y, x1, y1))\n\t}\n\tt = (x - x0) * dx + (y - y0) * dy\n\tif (t <= 0) {\n\t\treturn std::make_pair(Distance2D(x, y, x0, y0), Distance2D(x, y, x0, y0))\n\t}\n\tif (t >= t) {\n\t\treturn std::make_pair(Distance2D(x, y, x1, y1), Distance2D(x, y, x1, y1))\n\t}\n\tfloat t = t / t\n\treturn std::make_pair(Distance2D(x, y, x0 + t * dx, y0 + t * dy), Distance2D(x, y, x0 + t * dx, y0 + t * dy))\n}", "CodeBleu_score": 38.93900078072755}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat DistanceSegmentToPoint (float x, float y, float x1, float y1, float x2, float y2) {\n\t\tfloat dx = x2 - x1;\n\t\tfloat dy = y2 - y1;\n\t\tfloat length = std::sqrt (dx * dx + dy * dy);\n\t\tif (length == 0.0f) {\n\t\t\treturn std::make_pair (std::sqrt ((x - x1) * (x - x1) + (y - y1) * (y - y1)), std::sqrt ((x - x2) * (x - x2) + (y - y2) * (y - y2)));\n\t\t}\n\t\tfloat t = ((x - x1) * dx + (y - y1) * dy) / length;\n\t\tif (t < 0.0f) {\n\t\t\treturn std::make_pair (std::sqrt ((x - x1) * (x - x1) + (y - y1) * (y - y1)), std::sqrt ((x - x2) * (x - x2) + (y - y2) * (y - y2)));\n\t\t}\n\t\tif (t > 1.0f) {\n\t\t\treturn std::make_pair (std::sqrt ((x - x2) * (x - x2) + (y - y2) * (y - y2)), std::sqrt ((x - x1) * (x - x1) + (y - y1) * (y - y1)));\n\t\t}\n\t\tfloat projectionX = x1 + t * dx;\n\t\tfloat projectionY = y1 + t * dy;\n\t\treturn std::make_pair (std::sqrt ((x - projectionX) * (x - projectionX) + (y - projectionY) * (y - projectionY)), std::sqrt ((x - x1) * (x - x1) + (y - y1) * (y - y1)));\n\t}\n}", "CodeBleu_score": 36.617547194107836}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT\n(vertices.size\n()\n>\n3\n)\nAddIndex\n(\nvertices\n[\n0\n]\n)\nAddIndex\n(\nvertices\n[\n1\n]\n)\nAddIndex\n(\nvertices\n[\n2\n]\n)\nfor\n(\nsize_t\ni\n=\n3\n;\ni\n<\nvertices\n.\nsize\n(\n)\n;\n+\n+\ni\n)\n{\nAddIndex\n(\nvertices\n[\ni\n]\n)\nAddIndex\n(\nvertices\n[\ni\n-\n1\n]\n)\nAddIndex\n(\nvertices\n[\ni\n-\n2\n]\n)\n}\n}", "CodeBleu_score": 32.62513855663413}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT\n(vertices.size\n()\n>\n2\n)\n;\nindex_type\ninitial\n=\n_vertices\n.\nsize\n(\n)\n;\nAddVertices\n(\nvertices\n)\n;\nindex_type\ni\n=\ninitial\n;\nfor\n(\nsize_t\nj\n=\n1\n;\nj\n<\nvertices\n.\nsize\n(\n)\n-\n1\n;\nj\n+\n+\n)\n{\nAddIndex\n(\ni\n)\n;\nAddIndex\n(\ni\n+\n1\n)\n;\nAddIndex\n(\ni\n+\nj\n+\n1\n)\n;\ni\n+\n+\n;\n}\n}", "CodeBleu_score": 48.91508003292241}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT\n(vertices.size\n()\n>\n2\n);\n\nindex_type initial_index = _vertices.size();\nAddVertices(vertices);\n\nfor\n(size_t i = 1; i < vertices.size\n()\n-\n1\n;\ni\n+\n+\n)\n{\nAddIndex(initial_index);\nAddIndex(initial_index + i);\nAddIndex(initial_index + i + 1);\n}\n}", "CodeBleu_score": 46.83227774712542}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message);\n\tDEBUG_ASSERT(message->IsValid());\n\tboost::asio::post(\n\t\t_strand,\n\t\t[this, message]() {\n\t\t\tif (_socket.is_open()) {\n\t\t\t\t_deadline.expires_from_now(boost::posix_time::seconds(10));\n\t\t\t\tboost::asio::async_write(\n\t\t\t\t\t_socket,\n\t\t\t\t\tmessage->GetBufferSequence(),\n\t\t\t\t\tboost::asio::bind_executor(\n\t\t\t\t\t\t_strand,\n\t\t\t\t\t\t[this, message](const boost::system::error_code& ec, std::size_t) {\n\t\t\t\t\t\t\t_deadline.expires_at(boost::posix_time::pos_infin);\n\t\t\t\t\t\t\tif (ec) {\n\t\t\t\t\t\t\t\tlog_error(\"Failed to write to socket: {}\", ec.message());\n\t\t\t\t\t\t\t\tCloseNow();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlog_error(\"Failed to write to socket: socket is closed\");\n\t\t\t\tCloseNow();\n\t\t\t}\n\t\t}\n\t);\n}", "CodeBleu_score": 37.494167201927006}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\t// Check if the message is valid.\n\tif (!message) {\n\t\tlog_error(\"Invalid message\");\n\t\treturn;\n\t}\n\n\t// Post a lambda to the strand.\n\tboost::asio::post(\n\t\t_strand,\n\t\t[this, message]() {\n\t\t\t// Check if the socket is open.\n\t\t\tif (!_socket.is_open()) {\n\t\t\t\tlog_error(\"Socket is not open\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set a deadline.\n\t\t\t_deadline.expires_from_now(boost::posix_time::seconds(10));\n\n\t\t\t// Initiate an asynchronous write.\n\t\t\tboost::asio::async_write(\n\t\t\t\t_socket,\n\t\t\t\tmessage->GetBufferSequence(),\n\t\t\t\t[this, message](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n\t\t\t\t\t// Handle the result.\n\t\t\t\t\tif (ec) {\n\t\t\t\t\t\tlog_error(\"Failed to write message: \", ec.message());\n\t\t\t\t\t\tCloseNow();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle the sent message.\n\t\t\t\t\tHandleSent(message, bytes_transferred);\n\t\t\t\t});\n\t\t});\n}", "CodeBleu_score": 33.86030920526609}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t", "CodeBleu_score": 3.648604678563731}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!_socket.is_open()) {\n\t\treturn;\n\t}\n\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\tif (!ec) {\n\t\t_socket.close(ec);\n\t}\n\t_on_closed(ec);\n\tlog_debug(\"Session closed.\");\n}", "CodeBleu_score": 47.97913289706236}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!_socket.is_open()) {\n\t\tlog_debug(\"Socket is already closed\");\n\t\treturn;\n\t}\n\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t_socket.close();\n\t_on_closed(ec);\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 53.39996352563874}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!_socket.is_open()) {\n\t\treturn;\n\t}\n\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);\n\tif (!ec) {\n\t\t_socket.close(ec);\n\t}\n\tif (!ec) {\n\t\t_on_closed();\n\t\tlog_debug(\"Session closed\");\n\t}\n}", "CodeBleu_score": 48.87532869762203}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create buffer from message\n\tstd::string msg = \"Are you alive?\";\n\tstd::vector<char> buffer(msg.begin(), msg.end());\n\t// Log the sending action\n\tlog_info(\"Sending message: \" << msg);\n\t// Write buffer to the next router\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\t// Wait for and log the response from the system\n\tstd::string response = _router->ReadFromNext();\n\tlog_info(\"Received message: \" << response);\n}", "CodeBleu_score": 47.80244246094739}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tstd::vector<char> buffer(msg.size() + 1);\n\tstd::copy(msg.begin(), msg.end(), buffer.begin());\n\tbuffer.push_back('\\0');\n\tlog_info(\"Sending message: %s\", msg.c_str());\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\tlog_info(\"Waiting for response...\");\n\tstd::unique_ptr<Message> response = _router->ReadFromNext();\n\tlog_info(\"Response: %s\", response->c_str());\n}", "CodeBleu_score": 50.05961926584139}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tstd::string buffer = msg;\n\tlog_info(\"Sending: %s\", buffer.c_str());\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\tlog_info(\"Waiting for response\");\n\tstd::future<std::string> fut = _router->ReadFromNext();\n\tstd::string response = fut.get();\n\tlog_info(\"Received: %s\", response.c_str());\n}", "CodeBleu_score": 49.73619654028204}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tstd::unique_lock<std::mutex> lock(_mutex);\n\tif (sensor_id == 0) {\n\t\tlog_error(\"Invalid sensor ID\");\n\t\treturn;\n\t}\n\tauto it = _servers.find(sensor_id);\n\tif (it!= _servers.end()) {\n\t\tstd::vector<uint8_t> buffer(sizeof(uint32_t));\n\t\tuint32_t* p = reinterpret_cast<uint32_t*>(buffer.data());\n\t\t*p = sensor_id;\n\t\tstd::future<void> fut = _router->WriteToOne(it->second, buffer);\n\t\t_router->ReadFromOne(it->second, buffer);\n\t\tfut.get();\n\t\tlog_info(\"Sent ENABLE_ROS to %s\", it->second.c_str());\n\t} else {\n\t\tlog_error(\"Sensor ID %d not found on any server\", sensor_id);\n\t}\n}", "CodeBleu_score": 54.74558356487811}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tauto fut = _router->WriteToOne(sensor_id, ENABLE_ROS);\n\tauto response = fut.get();\n\tif (response.buffer.data[0]!= 0) {\n\t\tlog_error(\"Could not enable ROS on sensor %u\", sensor_id);\n\t}\n}", "CodeBleu_score": 26.95522511798166}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Create the buffer to send to the router\n\tBuffer buffer;\n\tbuffer.data.resize(1);\n\tbuffer.data[0] = sensor_id;\n\tbuffer.size = 1;\n\n\t// Send the ENABLE_ROS command to the router\n\tstd::future<bool> fut = _router->WriteToOne(buffer);\n\n\t// Wait for the response from the router\n\tbool response = fut.get();\n\n\t// Check if the sensor was found on any server\n\tif (response) {\n\t\tlog_info(\"Sensor %d was found on one or more secondary servers.\", sensor_id);\n\t}\n\telse {\n\t\tlog_error(\"Sensor %d was not found on any secondary servers.\", sensor_id);\n\t}\n}", "CodeBleu_score": 41.18229663561659}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t#ifdef CARLA_USE_CUDA\n  if (_tokens.find(sensor_id)!= _tokens.end()) {\n    log_info(\"sensor \", sensor_id, \" is already enabled, returning existing token\");\n    return _tokens.find(sensor_id)->second;\n  }\n  auto token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = token;\n  _sensor_ids[token.get_stream_id()] = sensor_id;\n  log_info(\"sensor \", sensor_id, \" is enabled, returning new token\");\n  return token;\n#else\n  log_warn(\"cannot retrieve a token, CUDA is not enabled\");\n  return token_type();\n#endif\n}", "CodeBleu_score": 49.538922838017875}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t//  log_debug(\"getting token for sensor \", sensor_id);\n  auto it = _tokens.find(sensor_id);\n  if (it!= _tokens.end()) {\n    log_debug(\"sensor \", sensor_id, \" is already activated\");\n    return it->second;\n  }\n\n  auto server_id = _router->GetNextServer();\n  log_debug(\"enabling sensor \", sensor_id, \" on server \", server_id);\n  auto token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = token;\n  log_debug(\"sensor \", sensor_id, \" is now activated\");\n  return token;\n}", "CodeBleu_score": 62.43220128699786}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tauto it = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\tlog_debug(\"sensor \", sensor_id, \" is already activated, returning existing token\");\n\t\treturn it->second;\n\t}\n\tlog_debug(\"sensor \", sensor_id, \" is not activated, enabling sensor on secondary server\");\n\tauto new_token = SendGetToken(sensor_id);\n\t_tokens[sensor_id] = new_token;\n\tlog_debug(\"sensor \", sensor_id, \" is now activated, returning new token\");\n\treturn new_token;\n}", "CodeBleu_score": 53.324993885573726}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\nstd::istream_iterator<uint8_t> start(f), end;\n\n// read the whole file\nf.open(filename, std::ios::binary);\nif (!f.is_open()) {\nreturn false;\n}\nstd::vector<uint8_t> content(start, end);\nf.close();\n\n// parse the content\nreturn Load(std::move(content));\n}", "CodeBleu_score": 96.41415633097596}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// Check if the system is ready and assert the crowd object is not null.\n\tif (!IsReady()) {\n\t\tassert(false);\n\t\treturn false;\n\t}\n\tassert(m_crowd);\n\n\t// Search for the agent id in the walker and vehicle mappings.\n\tauto walker_iter = _mapped_walkers_id.find(id);\n\tauto vehicle_iter = _mapped_vehicles_id.find(id);\n\n\t// If found, enter a critical section to safely remove the agent from the crowd, update the walker or vehicle manager, and remove the id from the mappings.\n\tif (walker_iter!= _mapped_walkers_id.end() || vehicle_iter!= _mapped_vehicles_id.end()) {\n\t\t// Enter a critical section to safely remove the agent from the crowd.\n\t\tstd::lock_guard<std::mutex> lock(_crowd_mutex);\n\n\t\t// Update the walker or vehicle manager.\n\t\tif (walker_iter!= _mapped_walkers_id.end()) {\n\t\t\t_walker_manager.RemoveWalker(walker_iter->second);\n\t\t}\n\t\telse if (vehicle_iter!= _mapped_vehicles_id.end()) {\n\t\t\t_vehicle_manager.RemoveVehicle(vehicle_iter->second);\n\t\t}\n\n\t\t// Remove the id from the mappings.\n\t\t_mapped_walkers_id.erase(walker_iter);\n\t\t_mapped_vehicles_id.erase(vehicle_iter);\n\t\t_mapped_by_index.erase(id);\n\n\t\treturn true;\n\t}\n\n\t// If not found, return false.\n\treturn false;\n}", "CodeBleu_score": 55.95212740365799}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// Check if the system is ready\n\tif (!_is_ready) {\n\t\treturn false;\n\t}\n\n\t// Check if the crowd object is null\n\tif (_crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Check if the agent id is valid\n\tif (id == INVALID_ACTOR_ID) {\n\t\treturn false;\n\t}\n\n\t// Enter critical section\n\t_crowd->Lock();\n\n\t// Search for the agent id in the walker and vehicle mappings\n\tWalkerId walker_id = _mapped_walkers_id.find(id);\n\tVehicleId vehicle_id = _mapped_vehicles_id.find(id);\n\n\t// If the agent id is found in the walker mapping, remove it from the walker manager and erase it from the mappings\n\tif (walker_id!= INVALID_WALKER_ID) {\n\t\t_walker_manager->RemoveWalker(walker_id);\n\t\t_mapped_walkers_id.erase(walker_id);\n\t\t_mapped_by_index.erase(walker_id);\n\t}\n\n\t// If the agent id is found in the vehicle mapping, remove it from the vehicle manager and erase it from the mappings\n\tif (vehicle_id!= INVALID_VEHICLE_ID) {\n\t\t_vehicle_manager->RemoveVehicle(vehicle_id);\n\t\t_mapped_vehicles_id.erase(vehicle_id);\n\t\t_mapped_by_index.erase(vehicle_id);\n\t}\n\n\t// Leave critical section\n\t_crowd->Unlock();\n\n\treturn true;\n}", "CodeBleu_score": 46.49800059235049}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// Check if the system is ready\n\tif (!is_ready_) {\n\t\treturn false;\n\t}\n\n\t// Check if the crowd object is null\n\tif (crowd_ == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Search for the agent id in the walker and vehicle mappings\n\tstd::lock_guard<std::mutex> lock(mutex_);\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\n\t// If the agent is found, remove it from the crowd and update the walker or vehicle manager\n\tif (walker_it!= _mapped_walkers_id.end()) {\n\t\t_walker_manager->RemoveWalker(walker_it->second);\n\t\t_mapped_walkers_id.erase(walker_it);\n\t}\n\telse if (vehicle_it!= _mapped_vehicles_id.end()) {\n\t\t_crowd->removeAgent(vehicle_it->second);\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t}\n\telse {\n\t\treturn false;\n\t}\n\n\t// Remove the id from the mappings\n\t_mapped_by_index.erase(id);\n\n\treturn true;\n}", "CodeBleu_score": 53.61243494646673}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\t// get the set of currently mapped vehicles\n\tstd::set<ActorId> mapped_vehicles;\n\tfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); it++) {\n\t\tmapped_vehicles.insert(it->first);\n\t}\n\n\t// add or update vehicles\n\tfor (auto it = vehicles.begin(); it!= vehicles.end(); it++) {\n\t\t// check if this vehicle is mapped\n\t\tif (mapped_vehicles.find(it->id)!= mapped_vehicles.end()) {\n\t\t\t// this vehicle is mapped, mark as updated\n\t\t\tmapped_vehicles.erase(it->id);\n\t\t} else {\n\t\t\t// this vehicle is not mapped, add it\n\t\t\tAddOrUpdateVehicle(*it);\n\t\t}\n\t}\n\n\t// remove vehicles not mapped\n\tfor (auto it = mapped_vehicles.begin(); it!= mapped_vehicles.end(); it++) {\n\t\tRemoveAgent(*it);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 45.1931968070627}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\t// get the set of existing vehicles\n\tstd::set<ActorId> existing_vehicles;\n\t{\n\t\t// critical section, force single thread running this\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\tfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\n\t\t\texisting_vehicles.insert(it->first);\n\t\t}\n\t}\n\n\t// add or update vehicles\n\tfor (auto it = vehicles.begin(); it!= vehicles.end(); ++it) {\n\t\t// check if this vehicle exists\n\t\tauto existing = existing_vehicles.find(it->id);\n\t\tif (existing!= existing_vehicles.end()) {\n\t\t\t// this vehicle exists, add or update it\n\t\t\tAddOrUpdateVehicle(*it);\n\t\t}\n\t\telse {\n\t\t\t// this vehicle does not exist, add it\n\t\t\tAddOrUpdateVehicle(*it);\n\t\t}\n\t}\n\n\t// remove vehicles\n\tfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\n\t\t// check if this vehicle exists\n\t\tauto existing = existing_vehicles.find(it->first);\n\t\tif (existing == existing_vehicles.end()) {\n\t\t\t// this vehicle does not exist, remove it\n\t\t\tRemoveAgent(it->first);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 41.864211192564966}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\t// get the list of existing vehicles\n\tstd::set<ActorId> existing_vehicles;\n\t{\n\t\t// critical section, force single thread running this\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\tfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\n\t\t\texisting_vehicles.insert(it->first);\n\t\t}\n\t}\n\n\t// add or update vehicles\n\tfor (auto vehicle : vehicles) {\n\t\tif (existing_vehicles.find(vehicle.id)!= existing_vehicles.end()) {\n\t\t\t// update\n\t\t\tAddOrUpdateVehicle(vehicle);\n\t\t} else {\n\t\t\t// add\n\t\t\tAddOrUpdateVehicle(vehicle);\n\t\t}\n\t}\n\n\t// remove vehicles\n\tfor (auto id : existing_vehicles) {\n\t\tif (vehicles.find(id) == vehicles.end()) {\n\t\t\t// remove\n\t\t\tRemoveAgent(id);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 45.92744792963225}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto _mapped_walkers_id = _mapped_walkers.find(id);\n\tauto _mapped_vehicles_id = _mapped_vehicles.find(id);\n\tif (_mapped_walkers_id!= _mapped_walkers_id.end()) {\n\t\tauto _walker = _mapped_walkers_id->second;\n\t\tif (_walker->HasVehicleNear(distance, direction)) {\n\t\t\treturn true;\n\t\t}\n\t} else if (_mapped_vehicles_id!= _mapped_vehicles_id.end()) {\n\t\tauto _vehicle = _mapped_vehicles_id->second;\n\t\tif (_vehicle->HasVehicleNear(distance, direction)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 51.542695582739384}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerEventVisitor visitor(info, delta);\n\tEventResult result = boost::variant2::visit(visitor, info.route.back().event);\n\treturn result;\n}", "CodeBleu_score": 41.890091324268674}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerEventVisitor visitor(info, delta);\n\treturn boost::variant2::visit(visitor, info.events[info.currentRoutePoint]);\n}", "CodeBleu_score": 41.223519208899404}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerInfo::WalkerRoutePoint &routePoint = info.routePoints[info.currentRoutePoint];\n\tWalkerEventVisitor visitor(id, info, delta);\n\treturn boost::variant2::visit(visitor, routePoint.event);\n}", "CodeBleu_score": 50.911078505433636}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node\n  for (pugi::xml_node road_node : xml.children(\"road\")) {\n\n    // Get road ID\n    const int road_id = road_node.attribute(\"id\").as_int();\n\n    // Get road s offset\n    const double s = road_node.attribute(\"s\").as_double();\n\n    // Get road lanes node\n    pugi::xml_node lanes_node = road_node.child(\"lanes\");\n\n    // Process each lane section within the lanes node\n    ParseLanes(road_id, s, lanes_node, map_builder);\n  }\n}", "CodeBleu_score": 33.16861528209985}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const int road_id = road_node.attribute(\"id\").as_int();\n    road::Road *road = map_builder.GetRoad(road_id);\n\n    // Iterate through each lane node\n    for (pugi::xml_node lane_node : road_node.children(\"lanes\")) {\n      const double s = lane_node.attribute(\"s\").as_double();\n      ParseLanes(lane_node, road, s, map_builder);\n    }\n  }\n}", "CodeBleu_score": 36.73435738573849}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * Iterate through each road node in the XML document\n */\n  for (pugi::xml_node road_node : xml.child(\"Map\").children(\"road\")) {\n\n    road::RoadId road_id = road_node.attribute(\"id\").as_int();\n\n    road::Road *road = map_builder.GetRoad(road_id);\n\n    // Iterate through each lane section in the road node\n    for (pugi::xml_node lane_section_node : road_node.children(\"lanes\")) {\n\n      double s = 0.0;\n      if (lane_section_node.attribute(\"s\")) {\n        s = lane_section_node.attribute(\"s\").as_double();\n      }\n\n      // Parse left lane\n      if (lane_section_node.child(\"left\")) {\n        ParseLanes(lane_section_node.child(\"left\"), road, s, map_builder);\n      }\n\n      // Parse center lane\n      if (lane_section_node.child(\"center\")) {\n        ParseLanes(lane_section_node.child(\"center\"), road, s, map_builder);\n      }\n\n      // Parse right lane\n      if (lane_section_node.child(\"right\")) {\n        ParseLanes(lane_section_node.child(\"right\"), road, s, map_builder);\n      }\n    }\n  }\n}", "CodeBleu_score": 55.11255339914734}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.get_status() == efd::PublicationMatchedStatus::MATCHED) {\n\t\tif (m_matched_publications.find(writer) == m_matched_publications.end()) {\n\t\t\tm_matched_publications[writer] = 0;\n\t\t}\n\t\tm_matched_publications[writer] += 1;\n\t\tif (m_matched_publications[writer] == 1) {\n\t\t\tm_first_connection_publications[writer] = true;\n\t\t}\n\t}\n\telse if (info.get_status() == efd::PublicationMatchedStatus::UNMATCHED) {\n\t\tif (m_matched_publications.find(writer)!= m_matched_publications.end()) {\n\t\t\tm_matched_publications[writer] -= 1;\n\t\t}\n\t\tif (m_matched_publications[writer] < 0) {\n\t\t\tlog_error(\"Publication matched count went below zero!\");\n\t\t}\n\t}\n\telse {\n\t\tlog_error(\"Unexpected publication matched status: %d\", info.get_status());\n\t}\n}", "CodeBleu_score": 42.70041303071284}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\t// Update the listener's state based on changes in publication matching.\n\tif (info.get_status() == efd::PublicationMatchedStatus::MATCHED) {\n\t\t// If a new match is detected, it sets the matched count and marks the first connection.\n\t\tif (info.get_matched_count() > 0) {\n\t\t\tif (m_matched_count == 0) {\n\t\t\t\tm_matched_count = info.get_matched_count();\n\t\t\t\tm_first_connection = true;\n\t\t\t}\n\t\t\t// If a match is lost, it updates the matched count.\n\t\t\telse {\n\t\t\t\tm_matched_count = info.get_matched_count();\n\t\t\t}\n\t\t}\n\t\t// For invalid count changes, it logs an error message.\n\t\telse {\n\t\t\tLOG_ERROR(\"Publication matched count is invalid.\");\n\t\t}\n\t}\n\t// If the publication is unmatched, it sets the matched count to 0.\n\telse {\n\t\tm_matched_count = 0;\n\t}\n}", "CodeBleu_score": 46.75737301847852}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.get_status() == efd::PublicationMatchedStatus::MATCHED) {\n\t\tm_matched_count++;\n\t\tif (m_matched_count == 1) {\n\t\t\tm_first_connection = true;\n\t\t}\n\t}\n\telse {\n\t\tm_matched_count--;\n\t\tif (m_matched_count < 0) {\n\t\t\tlog(EFD_LOG_ERROR, \"Publication matched count is negative!\");\n\t\t}\n\t}\n}", "CodeBleu_score": 34.89766563881853}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\t// Update the matched count\n\tif (info.is_new_subscription()) {\n\t\tmatched_count++;\n\t\tfirst_connected = true;\n\t}\n\telse if (info.is_old_subscription()) {\n\t\tmatched_count--;\n\t}\n\telse {\n\t\tLOG_ERROR(\"Invalid subscription change count.\");\n\t}\n}", "CodeBleu_score": 32.93528686629956}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\t// This function is called when a new subscription is matched.\n\t// It updates the matched count and sets the first_connected flag.\n\t// If the change count is invalid, it logs an error message.\n\t// If a subscription is unmatched, it updates the matched count and destroys the subscriber if there are no remaining matches.\n\n\t// If the subscription is matched, update the matched count and set the first_connected flag.\n\tif (info.status == efd::SubscriptionMatchedStatus::MATCHED) {\n\t\tmatched_count_++;\n\t\tfirst_connected_ = true;\n\t}\n\t// If the subscription is unmatched, update the matched count and destroy the subscriber if there are no remaining matches.\n\telse if (info.status == efd::SubscriptionMatchedStatus::UNMATCHED) {\n\t\tmatched_count_--;\n\t\tif (matched_count_ == 0) {\n\t\t\tDestroySubscriber();\n\t\t}\n\t}\n\t// If the change count is invalid, log an error message.\n\telse {\n\t\tLOG4CXX_ERROR(logger_, \"Invalid change count for subscription: \" << info.status);\n\t}\n}", "CodeBleu_score": 46.483991259995875}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.get_status() == efd::SubscriptionMatchedStatus::MATCHED) {\n\t\t// If a new subscription is matched, it updates the matched count and sets the first_connected flag.\n\t\tmatched_count++;\n\t\tfirst_connected = true;\n\t} else if (info.get_status() == efd::SubscriptionMatchedStatus::UNMATCHED) {\n\t\t// If a subscription is unmatched, it updates the matched count and destroys the subscriber if there are no remaining matches.\n\t\tmatched_count--;\n\t\tif (matched_count == 0) {\n\t\t\t// If the change count is invalid, it logs an error message.\n\t\t\tif (first_connected) {\n\t\t\t\t// Destroy the subscriber if there are no remaining matches.\n\t\t\t\tdelete this;\n\t\t\t} else {\n\t\t\t\t// Log an error message.\n\t\t\t\tEFD_ERROR(\"CarlaSubscriberListenerImpl::on_subscription_matched: Invalid subscription change count.\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Log an error message.\n\t\tEFD_ERROR(\"CarlaSubscriberListenerImpl::on_subscription_matched: Invalid subscription status.\");\n\t}\n}", "CodeBleu_score": 42.13005330635704}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\nif (p_type->key_defined) {\nreturn false;\n}\n\nbool cdr_serialize = false;\nif (p_type->key_defined) {\ncdr_serialize = true;\n}\n\nif (force_md5 || cdr_serialize) {\nunsigned char* key = (unsigned char*)(&p_type->key);\nunsigned int key_size = getKeyMaxCdrSerializedSize();\nif (key_size > 16) {\nreturn false;\n}\n\nstd::string md5_string;\nfor (unsigned int i = 0; i < key_size; ++i) {\nmd5_string += (char) key[i];\n}\n\nif (!m_md5.init()) {\nreturn false;\n}\n\nm_md5.update(md5_string.c_str(), md5_string.size());\n\nm_md5.finalize();\nfor (unsigned int i = 0; i < 16; ++i) {\nhandle->key[i] = m_md5.digest[i];\n}\n} else {\nmemcpy(handle->key, p_type->key, 16);\n}\n\nreturn true;\n}", "CodeBleu_score": 58.38855900649964}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\tif (p_type->key_defined) {\n\t\treturn false;\n\t}\n\n\tCarlaCollisionEventPubSubType p_type_data;\n\tp_type_data.serialize(p_type, handle);\n\tif (force_md5 || p_type_data.getKeyMaxCdrSerializedSize() > 0) {\n\t\tm_md5.init();\n\t\tm_md5.update((const unsigned char*) &p_type_data, p_type_data.getKeyMaxCdrSerializedSize());\n\t\tm_md5.finalize();\n\t\tfor (unsigned int i = 0; i < 16; ++i) {\n\t\t\thandle->key.value[i] = m_md5.digest[i];\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.73583560784812}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Initialize fastbuffer\n    FastBuffer fastbuffer(FASTBUFFER_MAX_SIZE);\n\n    // Serialize encapsulation\n    CarlaEgoVehicleControlPubSubType_serialize_encapsulation(payload, &fastbuffer);\n\n    // Serialize payload\n    size_t size;\n    if (CarlaEgoVehicleControlPubSubType_serialize(p_type, &fastbuffer, &size)) {\n        payload->length = size;\n        payload->data = fastbuffer.serialize();\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 45.151345366941584}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t", "CodeBleu_score": 2.5978767707221393}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t", "CodeBleu_score": 2.5978767707221393}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Check if the target has been set\n\tif (tracker.g.sysid_target!= 0) {\n\t\treturn;\n\t}\n\n\t// Decode the message\n\tmavlink_heartbeat_t hb;\n\tmavlink_msg_heartbeat_decode(&msg, &hb);\n\n\t// Exit if the message is not one that should be tracked\n\tif (hb.type!= MAV_TYPE_GCS && hb.type!= MAV_TYPE_ONBOARD_CONTROLLER) {\n\t\treturn;\n\t}\n\n\t// Set the sysid\n\ttracker.g.sysid_target = hb.sysid;\n\n\t// Request position and air pressure data streams\n\ttracker.gcs().request_datastream_position(tracker.g.sysid_target);\n\ttracker.gcs().request_datastream_airpressure(tracker.g.sysid_target);\n\n\t// Flag that the target has been set\n\ttracker.g.sysid_target_set = true;\n}", "CodeBleu_score": 47.526672713401815}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (mavlink_target_sysid!= 0) {\n\t\treturn;\n\t}\n\n\tmavlink_msg_heartbeat_decode(&msg, &mavlink_heartbeat);\n\tif (mavlink_heartbeat.type!= MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\n\tmavlink_target_sysid = mavlink_heartbeat.sysid;\n\n\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, mavlink_target_sysid, MAV_DATA_STREAM_POSITION, 1, 10);\n\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, mavlink_target_sysid, MAV_DATA_STREAM_AIRPRESSURE, 1, 10);\n\n\tmavlink_target_set = true;\n}", "CodeBleu_score": 33.7914754886949}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Check if the target has been set\n\tif (mavlink_target_sysid!= 0) {\n\t\treturn;\n\t}\n\n\t// Decode the message\n\tmavlink_msg_heartbeat_decode(&msg, &mavlink_heartbeat);\n\n\t// Check if the message is one that should be tracked\n\tif (mavlink_heartbeat.type!= MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\n\t// Set the target\n\tmavlink_target_sysid = mavlink_heartbeat.sysid;\n\tmavlink_target_compid = mavlink_heartbeat.compid;\n\n\t// Request position and air pressure data streams from the target\n\ttracker.gcs().request_datastream_position(mavlink_target_sysid, MAV_DATA_STREAM_POSITION);\n\ttracker.gcs().request_datastream_airpressure(mavlink_target_sysid, MAV_DATA_STREAM_AIR_PRESSURE);\n\n\t// Flag that the target has been set\n\tmavlink_target_set = true;\n}", "CodeBleu_score": 39.53695259703647}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\t// If the result is MAV_RESULT_ACCEPTED, set a flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_barometer_altitude_calibration_needed = true;\n\t}\n\n\t// Return the result of the base class handler\n\treturn result;\n}", "CodeBleu_score": 53.71398121730127}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call base class handler\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t// set flag to indicate that altitude calibration is needed on the next barometer update\n\t\t_barometer_altitude_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 65.8071502716092}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 64.63061997462259}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// Check if the command is for servos\n\tif (packet.target_system!= this->get_system_id()) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\tif (packet.target_component!= this->get_component_id()) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is for this tracker\n\tif (packet.command!= MAV_CMD_COMPONENT_ARM_DISARM) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is for this tracker\n\tif (packet.param1 == 1.0f) {\n\t\t// Arm the servos\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\telse if (packet.param1 == 0.0f) {\n\t\t// Disarm the servos\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\telse {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 63.409843396167574}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tmavlink_command_ack_t command_ack;\n\tmavlink_message_t message;\n\tmavlink_status_t status;\n\n\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\tcommand_ack.command = packet.command;\n\t\tcommand_ack.result = MAV_RESULT_ACCEPTED;\n\t\tmavlink_msg_command_ack_encode(tracker.system_id, tracker.component_id, &message, &command_ack);\n\t\tmavlink_msg_to_send_buffer(tracker.send_buf, &message);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\ttracker.disarm_servos();\n\t\tcommand_ack.command = packet.command;\n\t\tcommand_ack.result = MAV_RESULT_ACCEPTED;\n\t\tmavlink_msg_command_ack_encode(tracker.system_id, tracker.component_id, &message, &command_ack);\n\t\tmavlink_msg_to_send_buffer(tracker.send_buf, &message);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\tcommand_ack.command = packet.command;\n\t\tcommand_ack.result = MAV_RESULT_UNSUPPORTED;\n\t\tmavlink_msg_command_ack_encode(tracker.system_id, tracker.component_id, &message, &command_ack);\n\t\tmavlink_msg_to_send_buffer(tracker.send_buf, &message);\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 47.96035825496554}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tmavlink_message_t msg;\n\tmavlink_msg_command_int_encode(MAVLINK_SYSTEM_ID, MAVLINK_COMP_ID_GCS, &msg, &packet);\n\tmavlink_status_t status;\n\tmavlink_status_decode(&msg, &status);\n\tmavlink_command_int_t command;\n\tmavlink_msg_command_int_decode(&msg, &command);\n\n\tif (command.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (command.param1 == 0.0) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 58.91236714845106}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over the available GCS channels and check for available payload space\n\tfor (int i = 0; i < num_gcs; i++) {\n\t\t// Check if the channel is available\n\t\tif (gcs_channels[i].available()) {\n\t\t\t// Check if there is available payload space\n\t\t\tif (gcs_channels[i].payload_space() > 0) {\n\t\t\t\t// Send a request to start the data stream on the corresponding channel with the specified update rate\n\t\t\t\tmavlink_msg_request_data_stream_send(gcs_channels[i].get_channel(), sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\t\t// Update the channel's payload space usage\n\t\t\t\tgcs_channels[i].update_payload_space(-1);\n\t\t\t\t// Break out of the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.125928916655866}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over the available GCS channels\n\tfor (int i = 0; i < MAX_NUM_GCS; i++) {\n\t\t// Check if the GCS channel is available\n\t\tif (gcs_channels[i].available) {\n\t\t\t// Check if there is enough payload space\n\t\t\tif (gcs_channels[i].payload_space > 0) {\n\t\t\t\t// Send the request to start the data stream on the corresponding channel with the specified update rate\n\t\t\t\tmavlink_msg_request_data_stream_send(gcs_channels[i].mavlink_channel, sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\t\t// Decrement the payload space\n\t\t\t\tgcs_channels[i].payload_space--;\n\t\t\t\t// Increment the number of GCS channels with available payload space\n\t\t\t\tnum_gcs--;\n\t\t\t\t// Return\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.399759609363876}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i = 0; i < num_gcs; i++) {\n\t\tif (gcs[i].available_payload_space() >= sizeof(mavlink_msg_request_data_stream_t)) {\n\t\t\tmavlink_msg_request_data_stream_send(gcs[i].get_channel(), sysid, compid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.89093991852254}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAP::ahrs ahrs = AHRS::get_instance();\n\tif (ahrs.cos_pitch == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = ahrs.cos_pitch * pitch + ahrs.sin_pitch * yaw;\n\tef_yaw = ahrs.cos_roll * yaw - ahrs.sin_roll * pitch;\n\treturn true;\n}", "CodeBleu_score": 53.66647757738079}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAP::ahrs& ahrs = AP::get_ahrs();\n\tif (ahrs.cos_pitch!= 0.0f) {\n\t\tef_pitch = asin(ahrs.sin_pitch * ahrs.cos_roll - ahrs.sin_roll * ahrs.cos_pitch * ahrs.sin_yaw);\n\t\tef_yaw = atan2(ahrs.cos_pitch * ahrs.sin_yaw, ahrs.cos_roll * ahrs.cos_yaw - ahrs.sin_roll * ahrs.sin_yaw * ahrs.sin_pitch);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 37.378685050195685}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = atan2(ahrs.cos_pitch * ahrs.sin_roll, ahrs.cos_roll);\n\tef_yaw = atan2(ahrs.sin_pitch * ahrs.cos_roll, ahrs.cos_pitch * ahrs.cos_roll);\n\treturn true;\n}", "CodeBleu_score": 36.65321489299535}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// update tracker yaw and pitch servos\n    Parameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float yaw_target = nav_status.bearing + g.yaw_trim;\n    float pitch_target = nav_status.pitch;\n\n    // if the target distance is valid or no minimum distance is set,\n    // update the pitch and yaw servos accordingly\n    if (nav_status.target_distance > g.target_distance_min || g.target_distance_min == 0) {\n        float yaw_angle_error;\n        float pitch_angle_error;\n        if (get_ef_yaw_direction()) {\n            yaw_angle_error = -yaw_angle_error;\n        }\n        calc_angle_error(pitch_target, yaw_target, get_ef_yaw_direction());\n        nav_status.yaw_servo_target = constrain_float(nav_status.yaw_servo_target + nav_status.angle_error_yaw, g.yaw_servo_min, g.yaw_servo_max);\n        nav_status.pitch_servo_target = constrain_float(nav_status.pitch_servo_target + nav_status.angle_error_pitch, g.pitch_servo_min, g.pitch_servo_max);\n    }\n}", "CodeBleu_score": 50.30461001914786}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t\t// get target distance in centimeters\n\tParameters &g = tracker.g;\n\tfloat target_distance = tracker.get_target_distance();\n\n\t// get the current yaw and pitch\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tfloat ahrs_pitch = ahrs.pitch_sensor;\n\tint32_t ahrs_yaw_cd = wrap_180_cd(ahrs.yaw_sensor);\n\n\t// get the current target bearing\n\tstruct Tracker::NavStatus &nav_status = tracker.nav_status;\n\tfloat target_bearing = nav_status.bearing;\n\n\t// calculate the target yaw and pitch\n\tfloat target_yaw = wrap_180_cd(target_bearing * 100.0f);\n\tfloat target_pitch = (target_distance - g.distance_min) * g.pitch_range / (g.distance_max - g.distance_min);\n\n\t// check if the direction is reversed\n\tbool direction_reversed = get_ef_yaw_direction();\n\n\t// calculate the angle error\n\tcalc_angle_error(target_pitch, target_yaw, direction_reversed);\n\n\t// update the tracker's yaw and pitch\n\ttracker.update_yaw_servo(target_yaw);\n\ttracker.update_pitch_servo(target_pitch);\n}", "CodeBleu_score": 53.19264658064513}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= last_message_time_ms) {\n\t\tlast_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (countdown == 0) {\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\thome_location = gps.location;\n\t\t\t\t\thome_location_set = true;\n\t\t\t\t\tcountdown = 3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcountdown--;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.51671698681543}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= last_gps_message_time_ms) {\n\t\tlast_gps_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (gps.location.is_valid()) {\n\t\t\t\thome_location = gps.location;\n\t\t\t\thome_location_set = true;\n\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t\t}\n\t\t} else {\n\t\t\tground_start_countdown = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 31.923202101273258}, {"code": "void Tracker::update_GPS(void){\n\t\t// update the GPS\n\tgps.update();\n\n\t// check if the last message time has changed\n\tif (gps.last_message_time_ms!= last_message_time_ms) {\n\t\tlast_message_time_ms = gps.last_message_time_ms;\n\n\t\t// check if the GPS status is at least 3D fix\n\t\tif (gps.status >= GPS_FIX_3D) {\n\t\t\t// check if the countdown is active\n\t\t\tif (countdown > 0) {\n\t\t\t\t// check if the current location is valid\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\t// set the home location\n\t\t\t\t\tset_home();\n\t\t\t\t} else {\n\t\t\t\t\t// reset the countdown\n\t\t\t\t\tcountdown = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.51116198997687}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\t//pitch_onoff_servo.write(pitch);\n\t}\n}", "CodeBleu_score": 8.107772738481499}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool retval = true;\n\tretval = AP_Arming::barometer_checks(display_failure);\n\tif (retval && (AP_Arming::get_enabled(AP_Arming::ARMING_CHECK_BARO))) {\n\t\tfloat baro_alt = _baro.get_altitude_cm();\n\t\tfloat inertial_alt = _inertial_nav.get_altitude_cm();\n\t\tfloat baro_alt_ref = _baro.get_altitude_cm_ref();\n\t\tfloat inertial_alt_ref = _inertial_nav.get_altitude_cm_ref();\n\t\tfloat disparity = fabsf(baro_alt - inertial_alt);\n\t\tfloat disparity_ref = fabsf(baro_alt_ref - inertial_alt_ref);\n\t\tif (disparity > disparity_ref) {\n\t\t\tretval = false;\n\t\t\tif (display_failure) {\n\t\t\t\t_failure_log.log_failure(AP_Arming::ARMING_CHECK_BARO, disparity, disparity_ref);\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}", "CodeBleu_score": 44.209373514414565}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool ret = true;\n\n\tif (AP_Arming_Copter::barometer_checks_base(display_failure)) {\n\t\tif (ARMED_FLAG(ARMED_FLAG_BARO_CHECK) &&!in_transition()) {\n\t\t\t// check the barometer reference\n\t\t\tif (get_baro_reference() < 0.0f) {\n\t\t\t\t// if the barometer reference is negative, it means that the user has not set a barometer reference\n\t\t\t\t// so we don't need to check anything\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check the barometer altitude against the inertial navigation altitude\n\t\t\tif (fabsf(get_baro_reference() - get_inertial_nav_altitude()) > 100.0f) {\n\t\t\t\t// barometer altitude is not close enough to inertial navigation altitude\n\t\t\t\t// so we have a problem\n\t\t\t\tif (display_failure) {\n\t\t\t\t\t// log a failure\n\t\t\t\t\t_log_failure(AP_Arming::BARO_CHECK_FAIL, \"Barometer altitude error\");\n\t\t\t\t}\n\n\t\t\t\t// return false\n\t\t\t\tret = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 33.28441370372858}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool result = AP_Arming::barometer_checks(display_failure);\n\n\tif (result && (AP_Arming::get_arming_flags() & ARMING_CHECK_BARO)) {\n\t\t// check the barometer altitude against the inertial navigation altitude\n\t\t// if the barometer altitude is too high, it may indicate that the barometer is not connected\n\t\t// or that it is not being used properly\n\t\t// in this case, we do not want to arm the copter\n\t\tif (fabsf(get_baro_altitude_cm() - get_inertial_nav_altitude_cm()) > ARMED_BARO_ALTITUDE_DISPARITY_CM) {\n\t\t\tif (display_failure) {\n\t\t\t\tLOG_ERROR(\"Barometer altitude disparity too high\");\n\t\t\t\tLOG_ERROR(\"Barometer altitude: %f cm\", get_baro_altitude_cm());\n\t\t\t\tLOG_ERROR(\"Inertial navigation altitude: %f cm\", get_inertial_nav_altitude_cm());\n\t\t\t\tLOG_ERROR(\"Disparity: %f cm\", fabsf(get_baro_altitude_cm() - get_inertial_nav_altitude_cm()));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 42.88481346972948}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_terrain_source == TerrainSource::RANGEFINDER) {\n\t\treturn false;\n\t}\n\tif (_terrain_source == TerrainSource::TERRAIN_DATABASE && _alt_type == AltitudeType::TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming_Copter::terrain_database_required();\n}", "CodeBleu_score": 50.80390064295055}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == TerrainSource::RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (copter.mode_rtl.get_alt_type() == AltitudeType::TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 59.53199935625613}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_terrain_source == TERRAIN_SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (_terrain_source == TERRAIN_SOURCE_DATABASE && _alt_type == AP_ALTITUDE_TYPE_TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming_Copter::terrain_database_required();\n}", "CodeBleu_score": 49.60338939114703}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// set loop time for rate controllers\n\tattitude_control->rate_controller_run(AP::scheduler().get_last_loop_time_s());\n\tpos_control->rate_controller_run(AP::scheduler().get_last_loop_time_s());\n\tmotors->rate_controller_run(AP::scheduler().get_last_loop_time_s());\n}", "CodeBleu_score": 38.47234287664217}, {"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time for the attitude and position controllers.\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// Run the low-level rate controllers that require only IMU data.\n\tattitude_control->rate_controller_run();\n\n\t// Run the position controller that requires both IMU and GPS data.\n\tpos_control->run();\n}", "CodeBleu_score": 43.969064650452715}, {"code": "void Copter::run_rate_controller(){\n\t\t//set loop time for rate controllers\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tposition_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t//run low-level rate controllers\n\tattitude_control->rate_controller_run();\n\tposition_control->rate_controller_run();\n\tmotors->rate_controller_run();\n}", "CodeBleu_score": 44.419086666511575}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// retrieve the next waypoint location\n\tLocation next_loc = flightmode->get_wp();\n\t// check if the old location matches this waypoint\n\tif (!old_loc.same_loc_as(next_loc)) {\n\t\treturn false;\n\t}\n\t// check if the altitude frames of the old and new locations are the same\n\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\t// set the new location as the target\n\tset_target_location(new_loc);\n\treturn true;\n}", "CodeBleu_score": 65.40514307861318}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// check if the new location is the same as the old one\n\tif (old_loc.same_loc_as(new_loc)) {\n\t\treturn false;\n\t}\n\n\t// check if the altitude frames are the same\n\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\tset_target_location(new_loc);\n\treturn true;\n}", "CodeBleu_score": 54.305128080974754}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// get next waypoint location\n\tLocation next_loc = flightmode->get_wp();\n\n\t// check if old location matches next waypoint location\n\tif (!old_loc.same_loc_as(next_loc)) {\n\t\treturn false;\n\t}\n\n\t// check if altitude frames of old and new locations are the same\n\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set new location as target\n\tset_target_location(new_loc);\n\n\treturn true;\n}", "CodeBleu_score": 65.40514307861318}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (copter.set_mode(mode)) {\n\t\t\tcopter.flightmode->mode_number = mode;\n\t\t}\n\t} else {\n\t\tif (copter.flightmode->mode_number == mode) {\n\t\t\tcopter.reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 49.59913186227365}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (copter.set_mode(mode)) {\n\t\t\t// do nothing\n\t\t} else {\n\t\t\t// do nothing\n\t\t}\n\t} else if (ch_flag == AuxSwitchPos::LOW) {\n\t\tif (copter.flightmode->mode_number == mode) {\n\t\t\tcopter.rc().reset_mode_switch();\n\t\t} else {\n\t\t\t// do nothing\n\t\t}\n\t} else {\n\t\t// do nothing\n\t}\n}", "CodeBleu_score": 50.240795131794556}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tcopter.set_mode(mode);\n\t} else if (ch_flag == AuxSwitchPos::LOW) {\n\t\tif (copter.flightmode->mode_number == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 59.05744956977931}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// calculate the trim values from the control inputs of the roll and pitch channels\n\tfloat trim_roll = (channel_roll->get_control_in() - 1500) * 0.001f;\n\tfloat trim_pitch = (channel_pitch->get_control_in() - 1500) * 0.001f;\n\n\t// convert the trim values to radians\n\ttrim_roll = ToRad(trim_roll);\n\ttrim_pitch = ToRad(trim_pitch);\n\n\t// add the trim values to the AHRS trim\n\tahrs.add_trim(trim_roll, trim_pitch);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(MAV_SEVERITY_INFO, \"Trim saved\");\n\n\t// send a confirmation message with MAV_SEVERITY_INFO\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 57.72070063882353}, {"code": "void Copter::save_trim(){\n\t\tfloat roll_trim, pitch_trim;\n\troll_trim = channel_roll->get_control_in() * ToRad;\n\tpitch_trim = channel_pitch->get_control_in() * ToRad;\n\tahrs.add_trim(roll_trim, pitch_trim);\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Saved trim values\");\n\tLOGGER_WRITE_EVENT\n}", "CodeBleu_score": 55.72645821840601}, {"code": "void Copter::save_trim(){\n\t\t// calculate trim values from control inputs\n\tfloat trim_roll = (channel_roll->get_control_in() - 1500) * 0.0015f;\n\tfloat trim_pitch = (channel_roll->get_control_in() - 1500) * 0.0015f;\n\n\t// convert trim values to radians\n\ttrim_roll = ToRad(trim_roll);\n\ttrim_pitch = ToRad(trim_pitch);\n\n\t// add trim values to the AHRS\n\tahrs.add_trim(trim_roll, trim_pitch);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(LOGGER_EVENT_ID_SAVE_TRIM);\n\n\t// send a confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim values saved\");\n}", "CodeBleu_score": 53.84766644364797}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (copter.position_ok && vel.xy().length_squared > 0.000001f) {\n\t\tfloat speed_squared = vel.xy().length_squared;\n\t\tfloat yaw_angle = atan2f(vel.y, vel.x) * 180.0f / M_PI;\n\t\tif (yaw_angle > 180.0f) {\n\t\t\tyaw_angle -= 360.0f;\n\t\t}\n\t\tif (yaw_angle < -180.0f) {\n\t\t\tyaw_angle += 360.0f;\n\t\t}\n\t\treturn yaw_angle;\n\t}\n\treturn 0.0f;\n}", "CodeBleu_score": 32.682055692301184}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity.\n\tconst auto vel = copter.inertial_nav.get_velocity_neu_cms();\n\n\t// Calculate the speed squared.\n\tconst auto speed_squared = vel.xy().length_squared;\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components.\n\tif (copter.position_ok && speed_squared > 0.01f) {\n\t\tlook_ahead_yaw = atan2f(vel.x, vel.y);\n\t}\n\n\t// Return the computed look-ahead yaw angle.\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 48.908155268867844}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (!copter.position_ok) {\n\t\treturn 0.0f;\n\t}\n\tconst float speed_squared = vel.xy().length_squared;\n\tif (speed_squared > 0.01f) {\n\t\tconst float yaw_angle = atan2f(vel.z, vel.xy().length);\n\t\treturn yaw_angle;\n\t}\n\treturn 0.0f;\n}", "CodeBleu_score": 32.798993766795434}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// RUDDER method\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (gcs.is_rudder_arming_disabled()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (plane.get_throttle_input() == 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// WATCHDOG method\n\tif (method == AP_Arming::WATCHDOG) {\n\t\tif (!gcs().is_watchdog_armed()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// PX4 method\n\tif (method == AP_Arming::PX4) {\n\t\tif (gcs().is_px4_arming_disabled()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.26777729752947}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (gcs().is_rudder_arming_disabled() || plane.get_throttle_input() == 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (hal.util->was_watchdog_armed()) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 41.08309239800162}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::Method::RUDDER) {\n\t\tif (get_rudder_arming_type() == AP_Rudder::RudderArmType::DISABLED) {\n\t\t\treturn false;\n\t\t}\n\t\tif (plane.get_throttle_input()!= 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (hal.util->was_watchdog_armed) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 46.5632353022284}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool success = false;\n\tif (do_arming_checks) {\n\t\tif (check_arming_conditions()) {\n\t\t\tsuccess = true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tsuccess = true;\n\t}\n\n\tif (success) {\n\t\tupdate_home();\n\t\tahrs.set_home();\n\t\tupdate_current_loc();\n\t\tchange_arm_state();\n\t\tdelay_arming = true;\n\t\tsend_arm_disarm_statustext(true);\n\t}\n\treturn success;\n}", "CodeBleu_score": 42.984139800820884}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool success = false;\n\tif (do_arming_checks &&!check_arming_checks()) {\n\t\treturn false;\n\t}\n\tif (method == AP_Arming::METHOD_AUTO) {\n\t\tsuccess = auto_arm();\n\t} else if (method == AP_Arming::METHOD_MANUAL) {\n\t\tsuccess = manual_arm();\n\t}\n\tif (success) {\n\t\tupdate_home();\n\t\tplane.ahrs.set_home();\n\t\tupdate_current_loc();\n\t\tchange_arm_state();\n\t\tset_delay_armed();\n\t\tsend_arm_disarm_statustext();\n\t}\n\treturn success;\n}", "CodeBleu_score": 42.57311407431392}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t", "CodeBleu_score": 4.868891087689006}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t", "CodeBleu_score": 4.868891087689006}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::Instance()->printf_P(PSTR(\"No disarm button configured\"));\n\t\t}\n\t\treturn false;\n\t}\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 68.3013494370469}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n\tfloat ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 64.97989391078337}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n\tfloat ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 64.97989391078337}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tfloat temp_y = y;\n\tx = temp_x * ahrs.cos_yaw - temp_y * ahrs.sin_yaw;\n\ty = temp_x * ahrs.sin_yaw + temp_y * ahrs.cos_yaw;\n}", "CodeBleu_score": 41.99278487632115}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 3.5541344618719917}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 3.5541344618719917}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 3.5541344618719917}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\t// TODO: implement high_latency_tgt_heading\n\treturn 0;\n}", "CodeBleu_score": 7.913621370383008}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tuint8_t ret_val;\n\tif (this->control_mode == MAV_MODE_AUTO || this->control_mode == MAV_MODE_GUIDED) {\n\t\tret_val = (uint8_t) (this->tgt_bearing / 2);\n\t} else {\n\t\tret_val = 0;\n\t}\n\treturn ret_val;\n}", "CodeBleu_score": 41.18701070073991}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO_ARMED) {\n\t\treturn (uint8_t) (wrap_360_cd(wp_bearing_to_destination()) / 2);\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 19.34345139300029}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tLogPacketHeader header = LOG_PACKET_HEADER_INIT;\n\t\theader.id = id;\n\t\theader.time = AP_HAL::micros64();\n\t\tlogger.WriteCriticalBlock(header, &value, sizeof(value));\n\t}\n}", "CodeBleu_score": 41.76832563500974}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\t// Create the packet.\n\t// TODO: Check if the packet is too large.\n\tuint8_t packet[LOG_PACKET_SIZE];\n\tLOG_PACKET_HEADER_INIT(packet, id, LOG_DATA_ID);\n\tpacket[LOG_PACKET_DATA_OFFSET] = (value >> 24) & 0xFF;\n\tpacket[LOG_PACKET_DATA_OFFSET + 1] = (value >> 16) & 0xFF;\n\tpacket[LOG_PACKET_DATA_OFFSET + 2] = (value >> 8) & 0xFF;\n\tpacket[LOG_PACKET_DATA_OFFSET + 3] = value & 0xFF;\n\t// Write the packet.\n\tlogger.WriteCriticalBlock(packet, LOG_PACKET_SIZE);\n}", "CodeBleu_score": 33.82934178694267}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tlogger.WriteCriticalBlock(\n\t\t\t\t(uint32_t) (AP_HAL::micros64() - start_time),\n\t\t\t\tid, value);\n\t}\n}", "CodeBleu_score": 23.72126956721922}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (!ahrs.home_is_set) {\n\t\tif (motors.armed) {\n\t\t\tset_home_to_current_location_inflight();\n\t\t} else {\n\t\t\tset_home_to_current_location(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 32.15025121893823}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 26.761743893740185}, {"code": "void Sub::update_home_from_EKF(){\n\t\t// update home if not already set\n\tif (!ahrs.home_is_set) {\n\t\t// update home if motors are armed\n\t\tif (motors.armed) {\n\t\t\tset_home_to_current_location_inflight();\n\t\t} else {\n\t\t\t// update home if EKF location is valid\n\t\t\tLocation temp_loc;\n\t\t\tif (ahrs.get_location(temp_loc)) {\n\t\t\t\tset_home(temp_loc, false);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 31.4837709442268}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tattitude_control->relax_attitude_controllers();\n\t\tmotors.set_throttle_out(0.0);\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\treturn;\n\t}\n\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\tattitude_control->input_rate_bf_roll_pitch_yaw = get_pilot_desired_angle_rates();\n\tattitude_control->run();\n\tmotors.set_lateral(channel_lateral->norm_input);\n\tmotors.set_forward(channel_forward->norm_input);\n\tmotors.set_throttle_out(channel_throttle->norm_input);\n\tmotors.set_yaw(channel_yaw->norm_input);\n}", "CodeBleu_score": 38.40322759864837}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tattitude_control->relax_attitude_controllers();\n\t\tattitude_control->set_throttle_out(0.0);\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\treturn;\n\t}\n\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\tattitude_control->input_rate_bf_roll_pitch_yaw(channel_roll->get_control_in(), channel_pitch->get_control_in(), channel_yaw->get_control_in());\n\tattitude_control->run();\n\tmotors.set_forward(channel_throttle->norm_input);\n\tmotors.set_lateral(channel_lateral->norm_input);\n}", "CodeBleu_score": 38.35202504633225}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle_out(0);\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\tattitude_control->set_throttle_out(channel_throttle->norm_input);\n\tattitude_control->set_lateral(channel_lateral->norm_input);\n\tattitude_control->set_roll(channel_roll->norm_input);\n\tattitude_control->set_pitch(channel_pitch->norm_input);\n\tattitude_control->set_yaw(channel_yaw->norm_input);\n}", "CodeBleu_score": 35.74061754937611}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set the mode to position control\n\tset_mode(MODE_POSCTL);\n\n\t// set the stopping point\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\n\t// initialize the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n\n\t// initialize the yaw\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(true));\n}", "CodeBleu_score": 35.4640887035987}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// reset the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n\n\t// set the destination to the stopping point\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\n\t// set the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 38.257983203699304}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set to position control mode\n\tsub.control_mode = POSITION_CONTROL;\n\t// set the destination\n\tsub.wp_nav.set_wp_destination(sub.stopping_point);\n\t// initialize the yaw\n\tsub.auto_yaw_mode = get_default_auto_yaw_mode(false);\n\tsub.wp_nav.init_yaw();\n}", "CodeBleu_score": 38.90086215527749}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t", "CodeBleu_score": 2.0063663692733846}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set guided mode to velocity controller\n\tset_mode(MODE_GUIDED);\n\n\t// initialize vertical maximum speeds and acceleration\n\tposition_control->init_xy_controller();\n\tposition_control->set_max_speed_accel_z(sub.max_speed_z, sub.max_accel_z);\n\n\t// initialize vertical and horizontal velocity controllers\n\tposition_control->init_z_controller();\n\tposition_control->init_xy_controller();\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 44.80669304087665}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical speed limits\n\tsub.max_speed_dn = sub.pilot_speed_dn;\n\tsub.max_speed_up = sub.pilot_speed_up;\n\n\t// initialize vertical acceleration limits\n\tsub.max_accel_dn = sub.pilot_accel_dn;\n\tsub.max_accel_up = sub.pilot_accel_up;\n\n\t// initialize horizontal speed limits\n\tsub.max_speed_forward = sub.pilot_speed_forward;\n\tsub.max_speed_back = sub.pilot_speed_back;\n\tsub.max_speed_left = sub.pilot_speed_left;\n\tsub.max_speed_right = sub.pilot_speed_right;\n\n\t// initialize horizontal acceleration limits\n\tsub.max_accel_forward = sub.pilot_accel_forward;\n\tsub.max_accel_back = sub.pilot_accel_back;\n\tsub.max_accel_left = sub.pilot_accel_left;\n\tsub.max_accel_right = sub.pilot_accel_right;\n\n\t// initialize vertical controller\n\tposition_control->init_xy_controller(sub.max_speed_forward, sub.max_speed_back, sub.max_speed_left, sub.max_speed_right,\n\t\t\tsub.max_accel_forward, sub.max_accel_back, sub.max_accel_left, sub.max_accel_right, sub.max_speed_dn,\n\t\t\tsub.max_speed_up, sub.max_accel_dn, sub.max_accel_up);\n\n\t// initialize horizontal controller\n\tposition_control->init_z_controller(sub.max_speed_dn, sub.max_speed_up, sub.max_accel_dn, sub.max_accel_up);\n\n\t// set the auto-yaw mode to hold\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 29.32236002980762}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if timeout has been exceeded\n\tif (AP_HAL::millis() - last_guided_start_time > guided_timeout_ms) {\n\t\t// Timeout has been exceeded\n\t\treturn true;\n\t}\n\n\t// Check if altitude is below minimum\n\tif (curr_pos.z < guided_limit.start_pos.z - guided_limit.min_altitude_m) {\n\t\t// Altitude is below minimum\n\t\treturn true;\n\t}\n\n\t// Check if altitude is above maximum\n\tif (curr_pos.z > guided_limit.start_pos.z + guided_limit.max_altitude_m) {\n\t\t// Altitude is above maximum\n\t\treturn true;\n\t}\n\n\t// Check if horizontal distance moved exceeds limit\n\tif (get_horizontal_distance_cm() > guided_limit.max_horizontal_distance_cm) {\n\t\t// Horizontal distance moved exceeds limit\n\t\treturn true;\n\t}\n\n\t// No limits have been exceeded\n\treturn false;\n}", "CodeBleu_score": 33.86779663926195}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool guided_limit_reached = false;\n\n\t// Check if guided mode should be terminated due to timeout\n\tif (AP_HAL::millis() - guided_start_time > guided_timeout) {\n\t\tguided_limit_reached = true;\n\t}\n\n\t// Check if guided mode should be terminated due to altitude limit\n\tif (inertial_nav.get_position_neu_cm().z < guided_limit.min_alt_cm || inertial_nav.get_position_neu_cm().z > guided_limit.max_alt_cm) {\n\t\tguided_limit_reached = true;\n\t}\n\n\t// Check if guided mode should be terminated due to horizontal distance limit\n\tif (get_horizontal_distance_cm() > guided_limit.max_horizontal_distance_cm) {\n\t\tguided_limit_reached = true;\n\t}\n\n\treturn guided_limit_reached;\n}", "CodeBleu_score": 31.054275321244074}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check for timeout\n\tif (AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout) {\n\t\treturn true;\n\t}\n\n\t// Check for minimum altitude\n\tif (get_altitude_cm() < guided_limit.min_alt) {\n\t\treturn true;\n\t}\n\n\t// Check for maximum altitude\n\tif (get_altitude_cm() > guided_limit.max_alt) {\n\t\treturn true;\n\t}\n\n\t// Check for horizontal distance\n\tif (get_horizontal_distance_cm() > guided_limit.max_dist) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 32.8347504421816}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tif (AP_HAL::millis() - last_motor_test_time > 5000) {\n\t\tgcs.send_text(MAV_SEVERITY_INFO, \"Motor test timeout\");\n\t\tAP::arming().disarm();\n\t\tlast_motor_test_time = AP_HAL::millis();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.38852037484372}, {"code": "bool Sub::verify_motor_test(){\n\t\t// check if the motor test is enabled\n\tif (!motor_test_enabled)\n\t\treturn true;\n\n\t// check if the motor test is running\n\tif (!motor_test_running)\n\t\treturn false;\n\n\t// check if the motor test requests are received at least every 2 Hz\n\tif (AP_HAL::millis() - motor_test_last_request > 500) {\n\t\t// send a timeout message\n\t\tgcs.send_text(MAV_SEVERITY_INFO, \"Motor test timeout\");\n\n\t\t// set the pass flag to false\n\t\tmotor_test_pass = false;\n\n\t\t// disable the motor test\n\t\tmotor_test_enabled = false;\n\n\t\t// disarm the system\n\t\tAP::arming().disarm();\n\n\t\t// record the failure time\n\t\tmotor_test_failure_time = AP_HAL::millis();\n\n\t\t// return false\n\t\treturn false;\n\t}\n\n\t// return true\n\treturn true;\n}", "CodeBleu_score": 54.58902766869964}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (AP_HAL::millis() - last_motor_test_request > 2000) {\n\t\t// timeout\n\t\tgcs_send_text(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n\t\tAP::arming().disarm();\n\t\tlast_motor_test_request = AP_HAL::millis();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.640780114735044}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.get_roll();\n\tfloat pitch_target = wp_nav.get_pitch();\n\n\t// Constrain roll and pitch targets to a maximum angle range\n\troll_target = constrain_int16(roll_target, -max_roll_target, max_roll_target);\n\tpitch_target = constrain_int16(pitch_target, -max_pitch_target, max_pitch_target);\n\n\t// Normalize roll and pitch targets\n\troll_target = (roll_target + max_roll_target) / (2 * max_roll_target);\n\tpitch_target = (pitch_target + max_pitch_target) / (2 * max_pitch_target);\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 42.09146759170755}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_in = wp_nav.get_roll();\n\tfloat pitch_in = wp_nav.get_pitch();\n\tfloat roll_out = 0;\n\tfloat pitch_out = 0;\n\tfloat pitch_max = 10;\n\tfloat roll_max = 10;\n\tfloat pitch_min = -10;\n\tfloat roll_min = -10;\n\tfloat roll_norm = 0;\n\tfloat pitch_norm = 0;\n\troll_out = constrain_int16(roll_in, roll_min, roll_max);\n\tpitch_out = constrain_int16(pitch_in, pitch_min, pitch_max);\n\troll_norm = roll_out / roll_max;\n\tpitch_norm = pitch_out / pitch_max;\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 36.41486642278717}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_in = wp_nav.get_roll();\n\tfloat pitch_in = wp_nav.get_pitch();\n\t//constrain_int16(roll_in, -max_roll, max_roll);\n\t//constrain_int16(pitch_in, -max_pitch, max_pitch);\n\tconstrain_float(roll_in, -max_roll, max_roll);\n\tconstrain_float(pitch_in, -max_pitch, max_pitch);\n\tlateral_out = roll_in / max_roll;\n\tforward_out = pitch_in / max_pitch;\n}", "CodeBleu_score": 37.969643145979155}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor.healthy()) {\n\t\tdepth_sensor.update_health();\n\t}\n}", "CodeBleu_score": 50.34890119825779}, {"code": "void Sub::read_barometer(){\n\t\tbarometer.update();\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor.healthy()) {\n\t\tdepth_sensor.update();\n\t\tdepth_sensor.update_health();\n\t}\n}", "CodeBleu_score": 60.71565324726501}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.healthy) {\n\t\tbarometer.update();\n\t\tif (barometer.altitude > 0) {\n\t\t\tbarometer.update_calibration();\n\t\t}\n\t\tif (depth_sensor) {\n\t\t\tdepth_sensor.update();\n\t\t\tif (depth_sensor.healthy) {\n\t\t\t\tdepth_sensor.update_health();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 64.06250933331992}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\treturn ahrs.have_inertial_nav && motors.armed &&!ahrs.in_air &&!ahrs.in_ground_mode;\n}", "CodeBleu_score": 22.301234415232564}, {"code": "bool Sub::ekf_position_ok(){\n\t\treturn (ahrs.have_inertial_nav && motors.armed) || (ahrs.have_inertial_nav &&!motors.armed && ahrs.get_relative_alt() < 1000) ||!ahrs.have_inertial_nav;\n}", "CodeBleu_score": 33.742251314816805}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\tif (params.ekf2_position_mode == EKF2_POSITION_MODE_PRED) {\n\t\treturn true;\n\t}\n\n\tif (ekf2_in_position_mode()) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 19.75255728861404}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// check if the AHRS system is ready\n\tif (!ahrs.is_ready()) {\n\t\tif (display_failure) {\n\t\t\t// display failure\n\t\t\tcheck_failed = true;\n\t\t\tcheck_failed_msg = \"AHRS not ready\";\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check EKF failsafe\n\tif (ekf_failsafe_active) {\n\t\tif (display_failure) {\n\t\t\t// display failure\n\t\t\tcheck_failed = true;\n\t\t\tcheck_failed_msg = \"EKF failsafe active\";\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if position is valid\n\tif (!ekf_position_ok) {\n\t\tif (display_failure) {\n\t\t\t// display failure\n\t\t\tcheck_failed = true;\n\t\t\tcheck_failed_msg = \"Position estimate invalid\";\n\t\t}\n\t\treturn false;\n\t}\n\n\t// if we get here, all checks passed\n\treturn true;\n}", "CodeBleu_score": 31.788714408004203}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!rover.control_mode->requires_position &&!rover.control_mode->requires_velocity) {\n\t\treturn true;\n\t}\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (!ahrs.is_ready()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::instance()->printf_P(PSTR(\"AHRS not ready\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\tif (rover.ekf_position_ok) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::instance()->printf_P(PSTR(\"EKF position not valid\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 45.998878701938835}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (rover.control_mode->requires_position || rover.control_mode->requires_velocity) {\n\t\t// if we require position or velocity, we must have a GPS fix\n\t\tif (!AP_GPS::gps_checks(display_failure)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if we require position or velocity, we must have an AHRS\n\tif (rover.control_mode->requires_position || rover.control_mode->requires_velocity) {\n\t\tif (!AP_AHRS::ahrs_checks(display_failure)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if we require position or velocity, we must have a valid EKF position\n\tif (rover.control_mode->requires_position || rover.control_mode->requires_velocity) {\n\t\tif (!rover.ekf_position_ok) {\n\t\t\tif (display_failure) {\n\t\t\t\tcheck_failed = true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 34.79362901911033}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t#ifdef DEBUG_CHARGE\n    Serial.print(\"updateChargingEnabled: \");\n    Serial.print(status_message.charging_allowed);\n    Serial.print(\" \");\n    Serial.print(status_message.charging_enabled);\n    Serial.print(\" \");\n    Serial.print(status_message.charging_current);\n    Serial.print(\" \");\n    Serial.println(status_message.v_charge);\n#endif\n    if (status_message.charging_allowed) {\n        if (!status_message.charging_enabled) {\n            Serial.println(\"Enabling charging\");\n            digitalWrite(CHARGE_PIN, HIGH);\n            status_message.charging_enabled = true;\n            status_message.charging_enabled_time = millis();\n        }\n    } else {\n        if (status_message.charging_enabled) {\n            Serial.println(\"Disabling charging\");\n            digitalWrite(CHARGE_PIN, LOW);\n            status_message.charging_enabled = false;\n            status_message.charging_disabled_time = millis();\n        }\n    }\n}", "CodeBleu_score": 41.5022969058114}, {"code": "void updateChargingEnabled(){\n\t\tif (status_message.charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tenableCharging();\n\t\t} else {\n\t\t\tdisableCharging();\n\t\t}\n\t} else {\n\t\tif (millis() - charging_enabled_time > 10000) {\n\t\t\tenableCharging();\n\t\t}\n\t}\n}", "CodeBleu_score": 16.03916215508894}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tenableCharging();\n\t\t} else {\n\t\t\tdisableCharging();\n\t\t}\n\t} else {\n\t\tif (millis() - charging_enabled_time > CHARGING_RETRY_DELAY) {\n\t\t\tif (checkShouldCharge()) {\n\t\t\t\tenableCharging();\n\t\t\t} else {\n\t\t\t\tdisableCharging();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 27.303888107415613}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::master::check() && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tuint8_t *messageWithCrc = (uint8_t*) malloc(size + 2);\n\t\tmemcpy(messageWithCrc, message, size);\n\t\tmessageWithCrc[size] = (uint8_t) (crc >> 8);\n\t\tmessageWithCrc[size + 1] = (uint8_t) (crc & 0xFF);\n\t\tpacketSerial.send(messageWithCrc, size + 2);\n\t\tfree(messageWithCrc);\n\t}\n}", "CodeBleu_score": 48.21294522199591}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok()) {\n\t\tif (size >= 4) {\n\t\t\tuint8_t *messageWithCRC = (uint8_t*) malloc(size + 2);\n\t\t\tuint16_t crc = CRC16.ccitt((uint8_t*) message, size);\n\t\t\tmemcpy(messageWithCRC, message, size);\n\t\t\tmessageWithCRC[size] = (uint8_t) (crc & 0x00FF);\n\t\t\tmessageWithCRC[size + 1] = (uint8_t) (crc >> 8);\n\t\t\tpacketSerial.send(messageWithCRC, size + 2);\n\t\t\tfree(messageWithCRC);\n\t\t}\n\t}\n}", "CodeBleu_score": 50.90282429358102}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isStarted()) {\n\t\tif (size >= 4) {\n\t\t\tuint16_t crc = CRC16.ccitt((uint8_t *) message, size);\n\t\t\tuint8_t *messageWithCrc = (uint8_t *) malloc(size + 2);\n\t\t\tmemcpy(messageWithCrc, message, size);\n\t\t\tmessageWithCrc[size] = (uint8_t) (crc >> 8);\n\t\t\tmessageWithCrc[size + 1] = (uint8_t) (crc & 0xFF);\n\t\t\tpacketSerial.send(messageWithCrc, size + 2);\n\t\t\tfree(messageWithCrc);\n\t\t}\n\t}\n}", "CodeBleu_score": 55.10986054615068}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\treturn active_sounds.size();\n\t} else if (isPlaying()) {\n\t\treturn active_sounds.size();\n\t} else {\n\t\tactive_sounds.back()->play();\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 39.95093184138691}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\treturn 0;\n\t} else if (isPlaying) {\n\t\treturn active_sounds.size();\n\t} else {\n\t\t// Play the last sound in the list\n\t\tisPlaying = true;\n\t\tactive_sounds.back()->play();\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.96643863725615}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (isPlaying) {\n\t\treturn active_sounds.size();\n\t}\n\tactive_sounds.pop_back();\n\tisPlaying = true;\n\treturn active_sounds.size();\n}", "CodeBleu_score": 39.896240228737824}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    wb_abstract_camera_cleanup(d);\n    wb_abstract_camera_setup(d, r);\n    return true;\n  }\n#endif\n  d->command_handled = false;\n  return false;\n}", "CodeBleu_score": 25.868599175327585}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (d->camera_memory_mapped_file) {\n      if (d->camera_memory_mapped_file->memory_mapped_file)\n        UnmapViewOfFile(d->camera_memory_mapped_file->memory_mapped_file);\n      free(d->camera_memory_mapped_file);\n      d->camera_memory_mapped_file = NULL;\n    }\n    if (r->data_size == 0) {\n      d->command_handled = false;\n      return false;\n    }\n    if (d->camera_memory_mapped_file)\n      free(d->camera_memory_mapped_file);\n    d->camera_memory_mapped_file = (WbCameraMemoryMappedFile *)malloc(sizeof(WbCameraMemoryMappedFile));\n    d->camera_memory_mapped_file->memory_mapped_file = NULL;\n    d->camera_memory_mapped_file->memory_mapped_file_size = r->data_size;\n    d->camera_memory_mapped_file->memory_mapped_file_name = (char *)malloc(r->data_size + 1);\n    memcpy(d->camera_memory_mapped_file->memory_mapped_file_name, r->data, r->data_size);\n    d->camera_memory_mapped_file->memory_mapped_file_name[r->data_size] = '\\0';\n    d->camera_memory_mapped_file->memory_mapped_file = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, r->data_size, d->camera_memory_mapped_file->memory_mapped_file_name);\n    if (d->camera_memory_mapped_file->memory_mapped_file == NULL) {\n      d->command_handled = false;\n      return false;\n    }\n    d->command_handled = true;\n    return true;\n  }\n#endif\n\n  d->command_handled = false;\n  return false;\n}", "CodeBleu_score": 37.794584166717286}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *c = (WbAbstractCamera *)d;\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE: {\n\t\t\tif (c->memory_mapped_file) {\n\t\t\t\tdelete c->memory_mapped_file;\n\t\t\t\tc->memory_mapped_file = NULL;\n\t\t\t}\n\n\t\t\tif (r->get_data_size() == 0) {\n\t\t\t\tc->memory_mapped_file = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tc->memory_mapped_file = new WbMemoryMappedFile(r->get_data(), r->get_data_size());\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tc->command_handled = false;\n\t\t\treturn false;\n\t}\n\n\tc->command_handled = true;\n\treturn true;\n}", "CodeBleu_score": 46.948168684626964}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height = -1;\n\trobot_mutex_lock();\n\tif (d->type == WB_CAMERA) {\n\t\theight = ((WbCamera *)d)->height;\n\t}\n\trobot_mutex_unlock();\n\treturn height;\n}", "CodeBleu_score": 51.378484993328264}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tif (!d)\n\t\treturn -1;\n\tif (d->abstract_camera)\n\t\treturn d->abstract_camera->height;\n\treturn -1;\n}", "CodeBleu_score": 9.21686026079898}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef _WIN32\n  if (d->abstract_camera) {\n    return d->abstract_camera->height;\n  } else {\n    return -1;\n  }\n#else\n  int height;\n  robot_mutex_lock(d->abstract_camera_mutex);\n  if (d->abstract_camera) {\n    height = d->abstract_camera->height;\n  } else {\n    height = -1;\n  }\n  robot_mutex_unlock(d->abstract_camera_mutex);\n  return height;\n#endif\n}", "CodeBleu_score": 38.4413636732808}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = 0;\n\tRobot *robot = robot_mutex_lock();\n\tAccelerometer *accelerometer = accelerometer_get_struct(robot, tag);\n\tif (accelerometer == NULL) {\n\t\tprintf(\"Error: accelerometer %d does not exist.\n\", tag);\n\t\treturn 0;\n\t}\n\tsampling_period = accelerometer->sampling_period;\n\trobot_mutex_unlock(robot);\n\treturn sampling_period;\n}", "CodeBleu_score": 57.91600731907947}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG\n  printf(\"Entering wb_accelerometer_get_sampling_period\n\");\n#endif\n  int sampling_period;\n  WbAccelerometerStruct *accelerometer_struct;\n  WbDeviceStruct *device_struct;\n  int device_index;\n\n  device_index = wb_robot_get_device_index(tag);\n  if (device_index == -1) {\n    fprintf(stderr, \"Error: accelerometer %d does not exist\n\", tag);\n    return 0;\n  }\n  device_struct = wb_robot_get_device_struct(device_index);\n  accelerometer_struct = (WbAccelerometerStruct *) device_struct->custom_struct;\n  if (accelerometer_struct == NULL) {\n    fprintf(stderr, \"Error: accelerometer %d is not a valid accelerometer\n\", tag);\n    return 0;\n  }\n  robot_mutex_lock();\n  sampling_period = accelerometer_struct->sampling_period;\n  robot_mutex_unlock();\n#ifdef DEBUG\n  printf(\"Leaving wb_accelerometer_get_sampling_period\n\");\n#endif\n  return sampling_period;\n}", "CodeBleu_score": 46.703493831945785}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tRobotMutexLock\n\tAccelerometerStruct *accelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer == NULL) {\n\t\tprintf(\"Error: accelerometer_get_sampling_period: invalid device tag\n\");\n\t\treturn 0;\n\t}\n\tsampling_period = accelerometer->sampling_period;\n\tRobotMutexUnlock\n\treturn sampling_period;\n}", "CodeBleu_score": 23.190855999162967}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *result = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms(result);\n\tfree(result);\n\treturn dms;\n}", "CodeBleu_score": 38.348527263286094}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsStringCopy = dmsString;\n\tfree(dmsString);\n\treturn dmsStringCopy;\n}", "CodeBleu_score": 45.08436534693037}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = dms;\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 41.90011620056393}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box!= NULL, \"dImmerseBox: box is NULL\");\ndUASSERT (fluidPlane!= NULL, \"dImmerseBox: fluidPlane is NULL\");\ndUASSERT (immersion!= NULL, \"dImmerseBox: immersion is NULL\");\ndUASSERT (box->body!= NULL, \"dImmerseBox: box has no body\");\ndUASSERT (dBoxCheckFlags (flags), \"dImmerseBox: invalid flags\");\n\ndBoxImmersionData data;\ndata.box = box;\ndata.fluidPlane = fluidPlane;\ndata.immersion = immersion;\ndata.flags = flags;\n\nreturn dPerformImmersionChecking (&data);\n}", "CodeBleu_score": 43.752220133431265}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(o2->type == dCapsuleClass, \"This function can only be used with capsules\");\n\n\tsCapsuleImmersionData data(o1, o2, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 26.263165987961823}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData data;\n\tdata.zIOverR = zIOverR;\n\tdata.tanTheta0 = tanTheta0;\n\tdata.sinTheta1 = sinTheta1;\n\tdata.volume = volume;\n\tdReal x = sSimpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>::integrate(data);\n\treturn x * radius * (1.0 - 2.0 * zIOverR) + volume;\n}", "CodeBleu_score": 48.114163521573616}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData data;\n\tdata.zIOverR = zIOverR;\n\tdata.tanTheta0 = tanTheta0;\n\tdata.sinTheta1 = sinTheta1;\n\tdata.volume = volume;\n\tdReal x = dSimpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(data);\n\treturn x * radius + volume;\n}", "CodeBleu_score": 49.29715293352375}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 4.191970305576363}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT(o1->type == dCapsuleClass, \"dImmerseCapsuleTrimesh: o1 is not a capsule\");\n\tdUASSERT(o2->type == dTriMeshClass, \"dImmerseCapsuleTrimesh: o2 is not a trimesh\");\n\n\tconst dxCapsule *capsule = (const dxCapsule *) o1;\n\tconst dxTriMesh *trimesh = (const dxTriMesh *) o2;\n\n\tdUASSERT(capsule->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(trimesh->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsCapsuleImmersionData data(capsule, trimesh, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 33.85711281787852}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 4.191970305576363}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// TODO: Implement this function.\n\t// The function should return SUCCESS if the sleep duration is valid and non-negative, or else FAILURE.\n\t// If the sleep duration is valid, the node should set the status to RUNNING, and start the timer.\n\t// The callback should emit a wake-up signal when the timer expires.\n\t// If the timer is aborted, the timer_waiting_ flag should be reset.\n\n\t// TODO: Add your implementation here.\n\tif(config_param_.sleep_duration_ms < 0) {\n\t\treturn FAILURE;\n\t} else {\n\t\tsetStatus(RUNNING);\n\t\ttimer_.start(config_param_.sleep_duration_ms);\n\t\ttimer_.add(std::bind(&SleepNode::emitWakeUpSignal, this));\n\t\treturn SUCCESS;\n\t}\n}", "CodeBleu_score": 16.94628867763157}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tstd::string\n\tduration_param_name\n\t;\n\tdouble\n\tduration\n\t;\n\tif (!get_parameter(duration_param_name, duration)) {\n\t\treturn SUCCESS;\n\t}\n\tif (duration <= 0.0) {\n\t\treturn SUCCESS;\n\t}\n\tsetStatus(RUNNING);\n\ttimer_.start(duration);\n\ttimer_.add(std::bind(&SleepNode::emitWakeUpSignal, this));\n\treturn SUCCESS;\n}", "CodeBleu_score": 28.813028619089824}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tint64_t sleep_duration_ms = 0;\n\tif (getParam(\"sleep_duration\", sleep_duration_ms)) {\n\t\tif (sleep_duration_ms > 0) {\n\t\t\tsetStatus(RUNNING);\n\t\t\ttimer_.start(sleep_duration_ms);\n\t\t\ttimer_.setCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n\t\t\ttimer_waiting_ = false;\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\treturn SUCCESS;\n}", "CodeBleu_score": 32.273735752516174}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (config().blackboard->getEntry(config().entryName, config().entry)) {\n\t\tif (config().blackboard->getEntrySequenceId(config().entryName)!= config().sequenceId) {\n\t\t\tconfig().sequenceId = config().blackboard->getEntrySequenceId(config().entryName);\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 23.51468393343645}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t", "CodeBleu_score": 3.7010066864531876}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tNodeStatus status = NodeStatus::FAILURE;\n\n\t// Get the entry from the blackboard\n\tstd::shared_ptr<Entry> entry = _config().blackboard->getEntry(_entryName);\n\n\t// If the entry is found, lock its mutex\n\tif (entry!= nullptr) {\n\t\tstd::unique_lock<std::mutex> lock(entry->mutex);\n\n\t\t// If the entry has been updated, update the stored sequence ID and return SUCCESS\n\t\tif (entry->sequenceID!= _storedSequenceID) {\n\t\t\t_storedSequenceID = entry->sequenceID;\n\t\t\tstatus = NodeStatus::SUCCESS;\n\t\t}\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 39.71286898346883}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (successThreshold_ < 0) {\n\t\tsize_t threshold = std::max(1, static_cast<size_t>(successThreshold_ * children_nodes_.size()));\n\t\treturn threshold;\n\t} else {\n\t\treturn successThreshold_;\n\t}\n}", "CodeBleu_score": 54.136896804755544}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (successThreshold_ < 0) {\n\t\tsize_t result = 0;\n\t\tfor (const auto& child : children_nodes_) {\n\t\t\tresult += child->successThreshold();\n\t\t}\n\t\treturn result;\n\t}\n\treturn successThreshold_;\n}", "CodeBleu_score": 38.82702424799107}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (successThreshold_ < 0) {\n\t\treturn children_nodes_.size() - successThreshold_;\n\t} else {\n\t\treturn successThreshold_;\n\t}\n}", "CodeBleu_score": 52.749800252124565}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\t//std::cout << \"heartbeatLoop\" << std::endl;\n\t\tstd::unique_lock<std::mutex> lk(_p->mutex);\n\t\tif (_p->last_heartbeat_time == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto now = std::chrono::system_clock::now();\n\t\tauto diff = now - _p->last_heartbeat_time;\n\t\tauto diff_ms = std::chrono::duration_cast<std::chrono::milliseconds>(diff).count();\n\t\tif (diff_ms > _p->heartbeat_timeout) {\n\t\t\t_p->last_heartbeat_time = 0;\n\t\t\tenableAllHooks(false);\n\t\t} else {\n\t\t\t_p->last_heartbeat_time = now;\n\t\t\tenableAllHooks(true);\n\t\t}\n\t}\n}", "CodeBleu_score": 46.84247484302651}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (_running) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\t\tif (_p->heartbeat_status!= _p->last_heartbeat_status) {\n\t\t\t_p->last_heartbeat_status = _p->heartbeat_status;\n\t\t\tenableAllHooks(_p->heartbeat_status);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.748648300276248}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\t//std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(heartbeat_mutex);\n\t\tif(heartbeat_status!= _p->heartbeat_status) {\n\t\t\theartbeat_status = _p->heartbeat_status;\n\t\t\tenableAllHooks(heartbeat_status);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.91170321078995}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t", "CodeBleu_score": 5.780157160879095}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> mp_dump;\n\tstd::vector<std::string> blackboards;\n\tBT::splitString(bb_list, blackboards, \",\");\n\tfor (const std::string& bb : blackboards) {\n\t\tif (subtrees.find(bb)!= subtrees.end()) {\n\t\t\tstd::unique_lock<std::mutex> lock(subtrees[bb]->mutex);\n\t\t\tif (subtrees[bb]->valid) {\n\t\t\t\tnlohmann::json json_bb;\n\t\t\t\tExportBlackboardToJSON(subtrees[bb]->blackboard, json_bb);\n\t\t\t\tmp_dump.insert(mp_dump.end(), nlohmann::json::to_msgpack(json_bb).begin(), nlohmann::json::to_msgpack(json_bb).end());\n\t\t\t}\n\t\t}\n\t}\n\treturn mp_dump;\n}", "CodeBleu_score": 45.65299946653495}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> bb_dump;\n\tstd::vector<std::string> bb_names;\n\tBT::splitString(bb_list, bb_names, \",\");\n\tfor (auto& bb_name : bb_names) {\n\t\tstd::shared_ptr<BT::Blackboard> bb;\n\t\tif (_p->subtrees.find(bb_name)!= _p->subtrees.end()) {\n\t\t\tbb = _p->subtrees[bb_name];\n\t\t\tif (bb->lock()) {\n\t\t\t\tnlohmann::json bb_json;\n\t\t\t\tExportBlackboardToJSON(bb, bb_json);\n\t\t\t\tbb_dump.insert(bb_dump.end(), bb_json.dump().begin(), bb_json.dump().end());\n\t\t\t\tbb->unlock();\n\t\t\t}\n\t\t}\n\t}\n\treturn bb_dump;\n}", "CodeBleu_score": 50.56337574211241}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto bk_it = hooks->find(node_uid);\n\tif (bk_it == hooks->end()) {\n\t\treturn false;\n\t}\n\tauto hook = bk_it->second;\n\tif (hook->status!= Hook::Status::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->status = Hook::Status::READY;\n\thook->result = result;\n\thook->remove = remove;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 53.09504708033208}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t", "CodeBleu_score": 2.38136349673286}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t", "CodeBleu_score": 2.38136349673286}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n\tif(prev_status == NodeStatus::IDLE)\n\t{\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\n\tNodeStatus status = NodeStatus::IDLE;\n\ttry {\n\t\tstatus = tick_functor_(*this);\n\t} catch (const std::exception& e) {\n\t\tsetStatus(NodeStatus::IDLE);\n\t\tROS_ERROR_STREAM(\"ThreadedAction: \" << e.what());\n\t} catch (...) {\n\t\tsetStatus(NodeStatus::IDLE);\n\t\tROS_ERROR_STREAM(\"ThreadedAction: Unknown exception\");\n\t}\n\n\tif(status!= prev_status)\n\t{\n\t\tsetStatus(status);\n\t}\n\treturn status;\n}", "CodeBleu_score": 39.579784340598756}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n\tif(prev_status == NodeStatus::IDLE)\n\t{\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\n\tNodeStatus status = tick_functor_(*this);\n\tif(status!= prev_status)\n\t{\n\t\tsetStatus(status);\n\t}\n\treturn status;\n}", "CodeBleu_score": 24.753303246604908}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tf (status() == NodeStatus::IDLE) {\nsetStatus(NodeStatus::RUNNING);\nhalt_requested_.store(false);\nauto thread = std::async(std::launch::async, [this]() {\ntry {\ntick_functor_(*this);\n} catch (std::exception& e) {\nstd::cerr << \"Exception in tick functor: \" << e.what() << std::endl;\nsetStatus(NodeStatus::IDLE);\n} catch (...) {\nstd::cerr << \"Unknown exception in tick functor\" << std::endl;\nsetStatus(NodeStatus::IDLE);\n}\nif (halt_requested_.load()) {\nsetStatus(NodeStatus::IDLE);\n}\n});\n}\nNodeStatus status = status();\nif (status!= NodeStatus::IDLE) {\nif (stored_exception_) {\ntry {\nstd::rethrow_exception(stored_exception_);\n} catch (std::exception& e) {\nstd::cerr << \"Exception in stored exception: \" << e.what() << std::endl;\n} catch (...) {\nstd::cerr << \"Unknown exception in stored exception\" << std::endl;\n}\n}\nstored_exception_ = nullptr;\n}\nreturn status;\n}", "CodeBleu_score": 51.97030472194341}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t//Print the tree structure starting from the root_node\n\t//Define a recursive lambda function to handle the printing\n\tauto print = [&](const TreeNode* node, int depth) {\n\t\t//Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\t//Print the node's name\n\t\tstream << node->name << std::endl;\n\t\t//Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tconst auto& children = dynamic_cast<const BT::ControlNode*>(node)->children;\n\t\t\tfor (const auto& child : children) {\n\t\t\t\tprint(child, depth + 1);\n\t\t\t}\n\t\t} else if (dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tconst auto& child = dynamic_cast<const BT::DecoratorNode*>(node)->child;\n\t\t\tprint(child, depth + 1);\n\t\t}\n\t};\n\t//Begin and end with separator lines\n\tstream << \"---------------------------------------\" << std::endl;\n\tprint(root_node, 0);\n\tstream << \"---------------------------------------\" << std::endl;\n}", "CodeBleu_score": 50.91513663698872}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tauto print = [&stream, &print](const TreeNode* node) {\n\t\tstream << std::string(node->depth() * 3,'') << node->name() << std::endl;\n\t\tif (dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tfor (auto child : dynamic_cast<const BT::ControlNode*>(node)->children()) {\n\t\t\t\tprint(child);\n\t\t\t}\n\t\t} else if (dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tprint(dynamic_cast<const BT::DecoratorNode*>(node)->child());\n\t\t}\n\t};\n\tprint(root_node);\n\tstream << std::string((root_node->depth() + 1) * 3, '-') << std::endl;\n}", "CodeBleu_score": 35.750577740982514}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\t// The lambda function to be used in the recursive call\n\tauto printNode = [=](int depth) {\n\t\t// Print the node's name\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\tstream << root_node->name << std::endl;\n\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (dynamic_cast<const BT::ControlNode*>(root_node)!= nullptr) {\n\t\t\tauto control = dynamic_cast<const BT::ControlNode*>(root_node);\n\t\t\tfor (auto& child : control->children) {\n\t\t\t\tprintNode(depth + 1);\n\t\t\t}\n\t\t} else if (dynamic_cast<const BT::DecoratorNode*>(root_node)!= nullptr) {\n\t\t\tauto decorator = dynamic_cast<const BT::DecoratorNode*>(root_node);\n\t\t\tprintNode(depth + 1);\n\t\t}\n\t};\n\n\t// Print the separator lines\n\tstream << \"--------------------------------------------------\" << std::endl;\n\tprintNode(0);\n\tstream << \"--------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 47.423035783987025}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\n}", "CodeBleu_score": 7.736551633910178}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\n}", "CodeBleu_score": 7.736551633910178}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\t// TODO: Implement this function\n}", "CodeBleu_score": 7.736551633910178}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.registration_id)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"Builder with the same registration ID already registered\");\n\t}\n\t_p->builders.insert(std::make_pair(manifest.registration_id, builder));\n\t_p->manifests.insert(std::make_pair(manifest.registration_id, manifest));\n}", "CodeBleu_score": 53.10988734273403}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.registrationId)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(std::string(\"The builder with ID \") + manifest.registrationId + \" is already registered\");\n\t}\n\t_p->builders.insert(std::make_pair(manifest.registrationId, builder));\n\t_p->manifests.insert(std::make_pair(manifest.registrationId, manifest));\n}", "CodeBleu_score": 54.28407654729366}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.registration_id)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"NodeBuilder with ID \" + manifest.registration_id +\n\t\t\t\" already registered.\");\n\t}\n\t_p->builders.insert(std::make_pair(manifest.registration_id, builder));\n\t_p->manifests.insert(std::make_pair(manifest.registration_id, manifest));\n}", "CodeBleu_score": 53.97979542820938}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tegisterBuilder(TreeNodeManifest(ID, SimpleActionNode::type_name(), ports),\n                [tick_functor](const std::string& name, const NodeConfiguration& config) {\n                  return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n                });\n}", "CodeBleu_score": 56.40498767849519}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tegisterBuilder(TreeNodeManifest(ID, SimpleActionNode::static_type_info, ports),\n                [tick_functor](const std::string& ID,\n                               const std::vector<std::string>& ports) {\n                  return std::make_unique<SimpleActionNode>(ID, tick_functor, ports);\n                });\n}", "CodeBleu_score": 43.6789370212551}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tegisterBuilder(TreeNodeManifest(ID, SimpleActionNode::type_name(), ports),\n[tick_functor](const std::string& name, const BT::NodeConfiguration& config) {\n  return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n});\n}", "CodeBleu_score": 50.474731674425556}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tbb.back()->cloneInto(subtree->blackboard);\n\t}\n\treturn bb;\n}", "CodeBleu_score": 72.5133244607394}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tbb.back()->cloneInto(subtree->blackboard);\n\t}\n\treturn bb;\n}", "CodeBleu_score": 72.5133244607394}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto& subtree : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tsubtree->blackboard->cloneInto(bb.back());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 71.95545293537735}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor.has_value()) {\n\t\treturn executor.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.51038004251092}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\treturn ParseScript(script)(env);\n}", "CodeBleu_score": 23.883290906960614}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\treturn ParseScript(script)(env);\n}", "CodeBleu_score": 23.883290906960614}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tif (loaded) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: library already loaded\");\n\t}\n\tstd::unique_lock<std::mutex> lock(mutex);\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(\"SharedLibrary::load: \" + std::string(dlerror()));\n\t}\n\tloaded = true;\n\tpath_ = path;\n}", "CodeBleu_score": 51.95818015114404}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (loaded)\n\t\tthrow RuntimeError(\"Library already loaded\");\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle)\n\t\tthrow RuntimeError(dlerror());\n\tloaded = true;\n\tpath_ = path;\n}", "CodeBleu_score": 49.189690357667786}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library is already loaded\");\n\t}\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded = true;\n\tthis->path = path;\n}", "CodeBleu_score": 51.079764583594255}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tstr = str.trim();\n\n\tif (str.size < 3 || str[0]!= '{' || str[str.size - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer!= nullptr) {\n\t\t*stripped_pointer = str.substring(1, str.size - 1);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 20.773681203972323}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.front()!= '{' || stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 24.784307350347873}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tstr = str.strip();\n\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tif (str.front()!= '{') {\n\t\treturn false;\n\t}\n\tif (str.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 23.451504738544635}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0;\n\t//initialize the line iterator\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\t//iterate through each point on the line\n\tfor(int i = 0; i < line.size(); i++, line.advance()) {\n\t\t//get the point cost\n\t\tdouble point_cost = pointCost(line.getX(), line.getY());\n\t\t//if the point cost is negative, return the point cost immediately\n\t\tif(point_cost < 0)\n\t\t\treturn point_cost;\n\t\t//otherwise, update the line cost if the point cost is higher\n\t\telse\n\t\t\tcost = std::max(cost, point_cost);\n\t}\n\t//return the total line cost\n\treturn cost;\n}", "CodeBleu_score": 55.282163521914576}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t", "CodeBleu_score": 4.037265882870389}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble totalCost = 0;\n\tdouble cost;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor(int i = 0; i < line.size(); ++i, line.advance()) {\n\t\tcost = pointCost(line.getX(), line.getY());\n\t\tif(cost < 0)\n\t\t\treturn cost;\n\t\ttotalCost = std::max(totalCost, cost);\n\t}\n\treturn totalCost;\n}", "CodeBleu_score": 54.990295906997865}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Received empty plan.\");\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path[0].header.frame_id;\n\tgui_path.header.stamp = ros::Time::now();\n\tfor (std::size_t i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i].pose;\n\t}\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 72.05510399967649}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty())\n\t\treturn;\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path.front().header.frame_id;\n\tmsg.header.stamp = path.front().header.stamp;\n\tfor (const auto& pose : path)\n\t\tmsg.poses.push_back(pose.pose);\n\tpub.publish(msg);\n}", "CodeBleu_score": 44.565221417052534}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty()) {\n\t\tROS_WARN(\"The received path is empty.\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Publishing plan.\");\n\tnav_msgs::Path path_msg;\n\tpath_msg.poses.resize(path.size());\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\tfor(int i = 0; i < path.size(); i++) {\n\t\tpath_msg.poses[i] = path[i].pose;\n\t}\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 63.08899150772811}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t", "CodeBleu_score": 7.6923076923076925}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// TODO: Implement this function\n\t//return true;\n\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\tif (fabs(rot_vel) <= rot_stopped_velocity && fabs(trans_vel) <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.40126584661024}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\tif (rot_vel <= rot_stopped_velocity && trans_vel <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 51.224339259813014}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup) {\n\t\tif (restore_defaults) {\n\t\t\tconfig.resetToDefault();\n\t\t}\n\t\telse {\n\t\t\tconfig.update(config);\n\t\t}\n\t\tconfig_mutex.lock();\n\t\tlimits = config;\n\t\tconfig_mutex.unlock();\n\t}\n}", "CodeBleu_score": 35.51182785819794}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (!setup) {\n\t\tROS_INFO(\"LocalPlannerUtil::reconfigureCB: setup flag is not set. Setting up limits with provided configuration.\");\n\t\tlimits = config;\n\t\tsetup = true;\n\t} else {\n\t\tif (restore_defaults) {\n\t\t\tROS_INFO(\"LocalPlannerUtil::reconfigureCB: Restoring default limits.\");\n\t\t\tlimits = default_limits;\n\t\t} else {\n\t\t\tROS_INFO(\"LocalPlannerUtil::reconfigureCB: Updating limits with provided configuration.\");\n\t\t\tlimits.max_vel_x = config.max_vel_x;\n\t\t\tlimits.min_vel_x = config.min_vel_x;\n\t\t\tlimits.max_vel_y = config.max_vel_y;\n\t\t\tlimits.min_vel_y = config.min_vel_y;\n\t\t\tlimits.max_vel_theta = config.max_vel_theta;\n\t\t\tlimits.min_vel_theta = config.min_vel_theta;\n\t\t\tlimits.max_acc_x = config.max_acc_x;\n\t\t\tlimits.min_acc_x = config.min_acc_x;\n\t\t\tlimits.max_acc_y = config.max_acc_y;\n\t\t\tlimits.min_acc_y = config.min_acc_y;\n\t\t\tlimits.max_acc_theta = config.max_acc_theta;\n\t\t\tlimits.min_acc_theta = config.min_acc_theta;\n\t\t\tlimits.max_jerk_x = config.max_jerk_x;\n\t\t\tlimits.min_jerk_x = config.min_jerk_x;\n\t\t\tlimits.max_jerk_y = config.max_jerk_y;\n\t\t\tlimits.min_jerk_y = config.min_jerk_y;\n\t\t\tlimits.max_jerk_theta = config.max_jerk_theta;\n\t\t\tlimits.min_jerk_theta = config.min_jerk_theta;\n\t\t}\n\t}\n\tlock.lock();\n\tlimits_mutex.lock();\n\tlimits = limits;\n\tlimits_mutex.unlock();\n\tlock.unlock();\n}", "CodeBleu_score": 37.83985073971604}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t//if the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false\n\tif (costmap.getCost(check_cell->x, check_cell->y) >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\tcheck_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n\t\treturn false;\n\t}\n\n\t//calculate a new target distance and update the cell's target distance if the new distance is shorter\n\tdouble new_target_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 53.97857708233421}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t", "CodeBleu_score": 6.181338956123423}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// if the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false\n\tif (check_cell->cost == costmap.getCost(check_cell->x, check_cell->y) || check_cell->cost == costmap.getCost(check_cell->x, check_cell->y) == costmap.getCost(check_cell->x, check_cell->y) + 1) {\n\t\tcheck_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y) + 1;\n\t\treturn false;\n\t}\n\n\t// calculate a new target distance\n\tint new_target_distance = current_cell->target_distance + 1;\n\n\t// update the cell's target distance if the new distance is shorter\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\t// otherwise, return false\n\treturn false;\n}", "CodeBleu_score": 50.72442982089444}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n\tdouble scale = 1.0;\n\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"Footprint specification is empty!\");\n\t\treturn -9.0;\n\t}\n\n\t//get the scaling factor based on the speed of the robot\n\tscale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n\t//score each footprint point\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble x = traj.getPoint(i).x;\n\t\tdouble y = traj.getPoint(i).y;\n\t\tdouble th = traj.getPoint(i).theta;\n\t\tcost += footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\t}\n\n\t//if we're not summing the scores, we take the maximum\n\tif (!sum_scores_) {\n\t\tcost = std::max(cost, -10.0);\n\t}\n\treturn cost;\n}", "CodeBleu_score": 58.552290542066245}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0;\n\tdouble scale = 1.0;\n\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"Footprint specification is empty\");\n\t\treturn -9.0;\n\t}\n\n\t//initialize the cost based on the speed of the robot\n\tscale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n\t//check if we're going to hit something\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble x = traj.getPoint(i).x;\n\t\tdouble y = traj.getPoint(i).y;\n\t\tdouble th = traj.getPoint(i).theta;\n\n\t\tdouble footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 70.51985613446061}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t// scale the footprint points by the given scale factor\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tscaled_footprint.resize(footprint_spec.size());\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tscaled_footprint[i].x = footprint_spec[i].x * scale;\n\t\tscaled_footprint[i].y = footprint_spec[i].y * scale;\n\t}\n\n\t// compute the footprint cost using the world model\n\tdouble footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n\n\t// if the footprint cost is negative, return -6.0\n\tif (footprint_cost < 0) {\n\t\treturn -6.0;\n\t}\n\n\t// if the position is off the map, return -7.0\n\tif (!costmap->isWithinBounds(x, y)) {\n\t\treturn -7.0;\n\t}\n\n\t// otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n\treturn std::max(footprint_cost, costmap->getCost(x, y));\n}", "CodeBleu_score": 61.13625447515665}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t//double cost = 0.0;\n\t//double max_cost = -std::numeric_limits<double>::max();\n\t//double footprint_cost;\n\t//double cell_cost;\n\t//double scale_factor = 1.0;\n\t//std::vector<geometry_msgs::Point> scaled_footprint;\n\t//std::vector<geometry_msgs::Point> footprint;\n\t//footprint_spec.clear();\n\t//scaled_footprint.clear();\n\t//footprint.clear();\n\t//footprint = costmap->getRobotFootprint();\n\t//footprint_cost = costmap->getCost(x, y);\n\t//if (footprint_cost < 0) {\n\t\t//return -6.0;\n\t//}\n\t//if (costmap->isPositionValid(x, y)) {\n\t\t//scale_factor = costmap->getResolution() * scale;\n\t\t//scaled_footprint = scaleFootprint(footprint, scale_factor);\n\t\t//cell_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n\t\t//max_cost = std::max(footprint_cost, cell_cost);\n\t\t//return max_cost;\n\t//}\n\t//else {\n\t\t//return -7.0;\n\t//}\n\t//return cost;\n}", "CodeBleu_score": 8.490178557284024}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t//scale the footprint points by the scale factor\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point point;\n    point.x = footprint_spec[i].x * scale;\n    point.y = footprint_spec[i].y * scale;\n    scaled_footprint.push_back(point);\n  }\n\n  //compute the footprint cost using the world model\n  double footprint_cost = world_model->footprintCost(scaled_footprint, x, y, th);\n\n  //if the footprint cost is negative, return -6.0\n  if (footprint_cost < 0)\n    return -6.0;\n\n  //if the position is off the map, return -7.0\n  if (!costmap->worldToMap(x, y, mx, my))\n    return -7.0;\n\n  //otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n  return std::max(footprint_cost, costmap->getCost(mx, my));\n}", "CodeBleu_score": 63.555547427849305}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tROS_INFO_ONCE(\"odom_topic received!\");\n\t//if the new topic is not empty, we subscribe to the new topic\n\tif (!odom_topic.empty()) {\n\t\todom_sub_ = node_handle_.subscribe<nav_msgs::Odometry> (odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t}\n\t//if the new topic is empty, we unsubscribe from the current topic\n\telse {\n\t\todom_sub_.shutdown();\n\t}\n}", "CodeBleu_score": 33.032577727396905}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tROS_DEBUG_NAMED(\"dwa_local_planner\",\"In the setOdomTopic function with odom_topic: %s\",odom_topic.c_str());\n\tif(odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif(odom_topic_!= \"\") {\n\t\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry> (odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t\tROS_DEBUG_NAMED(\"dwa_local_planner\",\"Subscribed to new odometry topic: %s\",odom_topic_.c_str());\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t\tROS_DEBUG_NAMED(\"dwa_local_planner\",\"Unsubscribed from odometry topic\");\n\t\t}\n\t}\n}", "CodeBleu_score": 44.25163297050815}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In the setOdomTopic function with topic: %s\", odom_topic.c_str());\n\n  if (odom_topic!= odom_topic_) {\n    if (odom_topic.empty()) {\n      odom_sub_.shutdown();\n      odom_topic_ = odom_topic;\n    } else {\n      odom_sub_ = node_handle_.subscribe<nav_msgs::Odometry>\n        (odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n      odom_topic_ = odom_topic;\n    }\n  }\n}", "CodeBleu_score": 45.84935358488667}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tresetOscillationFlags();\n\tfloat squared_distance = (pos - prev).squaredNorm();\n\tfloat angular_difference = fabs(angleDiff(pos, prev));\n\tif (squared_distance > squared_oscillation_distance_threshold_ || angular_difference > oscillation_angle_threshold_) {\n\t\tstrafe_pos_only_ = false;\n\t\tstrafe_neg_only_ = false;\n\t\tstrafing_pos_ = false;\n\t\tstrafing_neg_ = false;\n\n\t\trot_pos_only_ = false;\n\t\trot_neg_only_ = false;\n\t\trotating_pos_ = false;\n\t\trotating_neg_ = false;\n\n\t\tforward_pos_only_ = false;\n\t\tforward_neg_only_ = false;\n\t\tforward_pos_ = false;\n\t\tforward_neg_ = false;\n\t}\n}", "CodeBleu_score": 27.356402621095828}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat distance_squared = (pos - prev).squaredNorm();\n\tfloat angle = fabs(angle_between(pos, prev));\n\n\t// If the distance is too big, reset the oscillation flags\n\tif (distance_squared > squared_distance_threshold_) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n\n\t// If the angle is too big, reset the oscillation flags\n\tif (angle > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n\n\t// Reset the oscillation flags based on the current position\n\tif (pos(0) > prev(0)) {\n\t\tstrafe_pos_only_ = true;\n\t\tstrafing_pos_ = true;\n\t} else if (pos(0) < prev(0)) {\n\t\tstrafe_neg_only_ = true;\n\t\tstrafing_neg_ = true;\n\t}\n\n\tif (pos(1) > prev(1)) {\n\t\trot_pos_only_ = true;\n\t\trotating_pos_ = true;\n\t} else if (pos(1) < prev(1)) {\n\t\trot_neg_only_ = true;\n\t\trotating_neg_ = true;\n\t}\n\n\tif (pos(2) > prev(2)) {\n\t\tforward_pos_only_ = true;\n\t\tforward_pos_ = true;\n\t} else if (pos(2) < prev(2)) {\n\t\tforward_neg_only_ = true;\n\t\tforward_neg_ = true;\n\t}\n}", "CodeBleu_score": 30.13151599166335}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat squared_dist = (pos - prev).squaredNorm();\n\tfloat angle_diff = fabs(atan2(pos.y() - prev.y(), pos.x() - prev.x()) - prev_angle_);\n\tif (squared_dist > squared_dist_threshold_ || angle_diff > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 34.48706947353915}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\tgridCoords(pt, gx, gy);\n\n\t//check if the point is too close to its nearest neighbor\n\tdouble sq_dist = nearestNeighborDistance(pt);\n\tif(sq_dist < sq_min_separation_)\n\t\treturn;\n\n\t//check if the point is outside the grid bounds\n\tif(gx >= width_ || gy >= height_)\n\t\treturn;\n\n\t//calculate the grid index\n\tunsigned int grid_index = gy * width_ + gx;\n\n\t//insert the point into the grid\n\tcells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 63.97531509689437}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//check if the point is in the grid bounds\n\tif(gx < 0 || gx >= width_ || gy < 0 || gy >= height_)\n\t\treturn;\n\n\t//check if the point is too close to its nearest neighbor\n\tif(sq_distance(pt, nearestNeighbor(pt)) < sq_min_separation_)\n\t\treturn;\n\n\t//calculate the grid index and insert the point\n\tunsigned int pt_index = gridIndex(gx, gy);\n\tcells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 77.7637975867632}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tunsigned int gx, gy;\n\tgridCoords(pt, gx, gy);\n\n\tif (gx >= width_ || gy >= height_ || sq_distance(pt, nearestNeighbor(pt)) < sq_min_separation_)\n\t\treturn;\n\n\tunsigned int pt_index = gy * width_ + gx;\n\n\t//insert the point into the cell\n\tcells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 70.52570265782123}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tif (sample_target_vel[i] - vel[i] > acclimits[i] * dt) {\n\t\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t\t} else {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t}\n\t\t} else if (sample_target_vel[i] < vel[i]) {\n\t\t\tif (vel[i] - sample_target_vel[i] > acclimits[i] * dt) {\n\t\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t\t} else {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t}\n\t\t} else {\n\t\t\tnew_vel[i] = vel[i];\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 70.22330280127194}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tnew_vel[i] = std::min(std::max(vel[i] + dt * acclimits[i], sample_target_vel[i]), acclimits[i]);\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 52.4455450439193}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t//    std::cout << \"SimpleTrajectoryGenerator::computeNewVelocities\" << std::endl;\n    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        } else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        } else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 78.05741499245308}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = 0.0;\n\tint index = 0;\n\tdouble dx, dy;\n\tdouble angle_to_point;\n\tbool found_valid_point = false;\n\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Check if the cell is clear of obstacles\n\t\tif (costmap_.isCellClear(global_plan_[i].x, global_plan_[i].y)) {\n\t\t\tdx = x - global_plan_[i].x;\n\t\t\tdy = y - global_plan_[i].y;\n\t\t\tangle_to_point = angles::normalize_angle(\n\t\t\t\t\tatan2(dy, dx) - heading);\n\t\t\tif (angle_to_point < M_PI / 2.0) {\n\t\t\t\tfound_valid_point = true;\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (found_valid_point) {\n\t\t// Convert goal cell coordinates to world coordinates\n\t\tdouble wx, wy;\n\t\tcostmap_.mapToWorld(global_plan_[index].x, global_plan_[index].y,\n\t\t\t\twx, wy);\n\t\tdiff = fabs(angles::shortest_angular_distance(heading,\n\t\t\t\tangles::normalize_angle(atan2(wy - y, wx - x))));\n\t} else {\n\t\tdiff = DBL_MAX;\n\t}\n\n\treturn diff;\n}", "CodeBleu_score": 48.70010195317375}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = 0.0;\n\tdouble goal_x, goal_y;\n\tdouble dist = 0.0;\n\tint i;\n\tint goal_x_cell, goal_y_cell;\n\n\t// find the farthest point in the global plan that is visible from the current position\n\tfor (i = global_plan_.size() - 1; i >= 0; --i) {\n\t\tgoal_x_cell = global_plan_[i].x;\n\t\tgoal_y_cell = global_plan_[i].y;\n\n\t\t// convert the goal cell coordinates to world coordinates\n\t\tcostmap_.mapToWorld(goal_x_cell, goal_y_cell, goal_x, goal_y);\n\n\t\t// check if the goal point is in the current cell's line of sight\n\t\tif (lineOfSight(x, y, goal_x, goal_y, heading)) {\n\t\t\tdist = hypot(goal_x - x, goal_y - y);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// if a valid point was found, calculate the heading difference\n\tif (i >= 0) {\n\t\tdiff = angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n\t\treturn fabs(diff);\n\t}\n\n\t// if no valid point was found, return a large value\n\treturn DBL_MAX;\n}", "CodeBleu_score": 55.59596567491176}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//   ROS_DEBUG(\"headingDiff: %f %f %f %f\", cell_x, cell_y, x, y);\n  double max_heading_diff = 0.0;\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    double dx = global_plan_[i].pose.position.x - x;\n    double dy = global_plan_[i].pose.position.y - y;\n    double dheading = angles::shortest_angular_distance(heading, atan2(dy, dx));\n    if (dheading < max_heading_diff) {\n      break;\n    }\n    if (dheading < 0.05) {\n      double dx_map = costmap_.mapToWorld(cell_x, cell_y).x - x;\n      double dy_map = costmap_.mapToWorld(cell_x, cell_y).y - y;\n      double dheading_map = angles::shortest_angular_distance(heading, atan2(dy_map, dx_map));\n      if (dheading_map < 0.05) {\n        return dheading;\n      }\n    }\n    max_heading_diff = dheading;\n  }\n  return DBL_MAX;\n}", "CodeBleu_score": 52.87291075022258}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//    ROS_WARN_STREAM(\"TrajectoryPlanner::checkTrajectory: x = \" << x << \", y = \" << y << \", theta = \" << theta << \", vx = \" << vx << \", vy = \" << vy << \", vtheta = \" << vtheta << \", vx_samp = \" << vx_samp << \", vy_samp = \" << vy_samp << \", vtheta_samp = \" << vtheta_samp);\n\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN_STREAM(\"TrajectoryPlanner::checkTrajectory: cost = \" << cost << \", vx = \" << vx << \", vy = \" << vy << \", vtheta = \" << vtheta << \", vx_samp = \" << vx_samp << \", vy_samp = \" << vy_samp << \", vtheta_samp = \" << vtheta_samp);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 66.3681208679457}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//    ROS_WARN(\"checkTrajectory: %f, %f, %f, %f, %f, %f, %f, %f, %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0.0) {\n      ROS_WARN(\"Trajectory planner reports a negative cost (%f) for velocities (%f, %f, %f) and accelerations (%f, %f, %f).\",\n               cost, vx_samp, vy_samp, vtheta_samp, acc_lim_x_, acc_lim_y_, acc_lim_theta_);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 68.28364837026065}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//    ROS_WARN(\"checkTrajectory: x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0) {\n      return true;\n    } else {\n      ROS_WARN(\"Trajectory rejected: cost = %f, vx_samp = %f, vy_samp = %f, vtheta_samp = %f\", cost, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n  }", "CodeBleu_score": 77.21303706841391}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tos::WallTime t0 = ros::WallTime::now();\n\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This recovery behavior must be initialized before it may be run\n\"\n\t\t\t\t\t\t\"Please call clear_costmap_recovery/initialize on the parameter server\");\n\t\treturn;\n\t}\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\n\t\t\t\t\"This recovery behavior must have a valid global costmap\n\"\n\t\t\t\t\t\t\"Please set the global_costmap parameter to the name of your global costmap\");\n\t\treturn;\n\t}\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\n\t\t\t\t\"This recovery behavior must have a valid local costmap\n\"\n\t\t\t\t\t\t\"Please set the local_costmap parameter to the name of your local costmap\");\n\t\treturn;\n\t}\n\tif (clear_area_) {\n\t\tROS_WARN(\n\t\t\t\t\"This recovery behavior is clearing the area specified by the local costmap\");\n\t}\n\tif (clear_area_ &&!clear_area_outside_) {\n\t\tROS_WARN(\n\t\t\t\t\"This recovery behavior is clearing the area specified by the local costmap, but the clear_area_outside_ parameter is false, so the area will be cleared inside the specified area\");\n\t}\n\n\tclear(global_costmap_);\n\tif (clear_area_) {\n\t\tclear(local_costmap_);\n\t}\n\tROS_DEBUG(\"Clearing costmap took %f seconds\",\n\t\t\t(ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 41.57603226837003}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tf (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This recovery behavior must be initialized before it may be run\n\"\n\t\t\t\t\t\t\"Please check that the costmaps are being loaded properly\n\"\n\t\t\t\t\t\t\"If this problem persists, see the recovery_behavior.cpp source code for more information\n\");\n\t\treturn;\n\t}\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\n\t\t\t\t\"This recovery behavior must have a valid costmap_2d global and local costmaps before it may be run\n\"\n\t\t\t\t\t\t\"If this problem persists, see the recovery_behavior.cpp source code for more information\n\");\n\t\treturn;\n\t}\n\tif (clearable_layers_.empty()) {\n\t\tROS_WARN(\n\t\t\t\t\"This recovery behavior will not clear any costmaps because no layers are specified in the clearable_layers parameter\n\"\n\t\t\t\t\t\t\"If this problem persists, see the recovery_behavior.cpp source code for more information\n\");\n\t\treturn;\n\t}\n\tif (affected_maps_.empty()) {\n\t\tROS_WARN(\n\t\t\t\t\"This recovery behavior will not clear any costmaps because no maps are specified in the affected_maps parameter\n\"\n\t\t\t\t\t\t\"If this problem persists, see the recovery_behavior.cpp source code for more information\n\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\n\t\t\t\t\"This recovery behavior will clear the area outside the specified area\n\"\n\t\t\t\t\t\t\"If this problem persists, see the recovery_behavior.cpp source code for more information\n\");\n\t}\n\n\tgeometry_msgs::PoseStamped pose;\n\tif (!global_costmap_->getRobotPose(pose)) {\n\t\tROS_ERROR(\"Cannot clear map because pose cannot be retrieved\");\n\t\treturn;\n\t}\n\n\tdouble x = pose.pose.position.x;\n\tdouble y = pose.pose.position.y;\n\n\tclear(global_costmap_);\n\tclear(local_costmap_);\n}", "CodeBleu_score": 38.83965876095258}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t/ check if the object is initialized and if the costmaps are not NULL\n\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must be initialized before it can run.\");\n\t\treturn;\n\t}\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"Costmaps are not initialized. Cannot clear costmap.\");\n\t\treturn;\n\t}\n\n\t// log a warning about clearing inside or outside a specified area\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\n\t\t\t\t\"Clearing costmap inside specified area. This is not recommended.\");\n\t}\n\n\t// clear the global and/or local costmap based on the affected_maps_ setting\n\t// and optionally force an update\n\tclear(global_costmap_);\n\tclear(local_costmap_);\n}", "CodeBleu_score": 22.766262941193215}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells polygon_outline_cells;\n\tpolygon_outline_cells.initialize(polygon);\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation p1 = polygon[i];\n\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\t\traytraceLine(p1, p2, polygon_outline_cells);\n\t}\n\tpolygon_cells = polygon_outline_cells.getCells();\n}", "CodeBleu_score": 45.14613194404129}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells polygon_outline_cells;\n\tfor (unsigned int i = 0; i < polygon.size(); ++i) {\n\t\tMapLocation p1 = polygon[i];\n\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\t\tpolygon_outline_cells.addOutlineCells(p1, p2);\n\t}\n\tpolygon_cells = polygon_outline_cells.getOutlineCells();\n}", "CodeBleu_score": 42.75435405467539}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// Initialize the PolygonOutlineCells object to collect the cells\n\tPolygonOutlineCells polygon_outline_cells;\n\n\t// Iterate through the polygon vertices\n\tfor (size_t i = 0; i < polygon.size(); i++) {\n\t\t// Get the current and next vertex\n\t\tMapLocation current_vertex = polygon[i];\n\t\tMapLocation next_vertex = polygon[(i + 1) % polygon.size()];\n\n\t\t// Use raytraceLine to gather cells between the current and next vertex\n\t\traytraceLine(current_vertex, next_vertex, polygon_outline_cells);\n\t}\n\n\t// If the polygon is not empty, close it by connecting the last vertex to the first\n\tif (!polygon.empty()) {\n\t\tMapLocation last_vertex = polygon.back();\n\t\tMapLocation first_vertex = polygon.front();\n\t\traytraceLine(last_vertex, first_vertex, polygon_outline_cells);\n\t}\n\n\t// Copy the collected cells to the output vector\n\tpolygon_cells = polygon_outline_cells.cells;\n}", "CodeBleu_score": 46.79969027566037}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tROS_DEBUG(\"Costmap2DPublisher::prepareGrid\");\n\tcostmap_->getMutex().lock();\n\tdouble resolution = costmap_->getResolution();\n\tcostmap_2d::Costmap2D::MapMetaData metadata = costmap_->getCostmap()->getMetaData();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = metadata.width;\n\tgrid_.info.height = metadata.height;\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(metadata.width * metadata.height);\n\tcostmap_->getMutex().unlock();\n}", "CodeBleu_score": 44.03386212703591}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t//lock the costmap mutex\n\tcostmap_->getMutex().lock();\n\t//get the resolution\n\tresolution_ = costmap_->getResolution();\n\t//set the grid's header\n\tgrid_.header.frame_id = frame_id_;\n\t//set the grid's resolution\n\tgrid_.info.resolution = resolution_;\n\t//set the grid's width\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\t//set the grid's height\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\t//convert the map coordinates to world coordinates for the origin\n\tcostmap_->mapToWorld(0, 0, origin_x_, origin_y_);\n\t//set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin_x_;\n\tgrid_.info.origin.position.y = origin_y_;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\t//save the origin coordinates\n\torigin_x_ = origin_x_;\n\torigin_y_ = origin_y_;\n\t//resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\t//unlock the costmap mutex\n\tcostmap_->getMutex().unlock();\n\t//populate the grid data from the costmap's character map using a translation table\n\tfor (int i = 0; i < grid_.info.width; i++) {\n\t\tfor (int j = 0; j < grid_.info.height; j++) {\n\t\t\tgrid_.data[j * grid_.info.width + i] = costmap_->getCharMap()[j * grid_.info.width + i];\n\t\t}\n\t}\n}", "CodeBleu_score": 60.972188106825406}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the mutex\n\tcostmap_->getMutex()->lock();\n\n\t// Get the resolution\n\tresolution_ = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the grid's resolution\n\tgrid_.info.resolution = resolution_;\n\n\t// Set the grid's width and height\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Set the grid's origin\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Unlock the mutex\n\tcostmap_->getMutex()->unlock();\n}", "CodeBleu_score": 50.90917716516192}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tROS_DEBUG(\"readFootprintFromConfig\");\n  if (new_config.robot_radius!= old_config.robot_radius) {\n    ROS_DEBUG(\"Robot radius changed from %f to %f\", old_config.robot_radius, new_config.robot_radius);\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n  } else if (new_config.footprint.size()!= old_config.footprint.size()) {\n    ROS_DEBUG(\"Footprint changed from %lu to %lu\", old_config.footprint.size(), new_config.footprint.size());\n    setUnpaddedRobotFootprint(makeFootprintFromString(new_config.footprint));\n  }\n}", "CodeBleu_score": 45.69503872176259}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.robot_radius!= old_config.robot_radius) {\n\t\tROS_INFO(\"Setting robot radius to %f\", new_config.robot_radius);\n\t\tsetRobotRadius(new_config.robot_radius);\n\t}\n\n\tif (new_config.footprint!= old_config.footprint) {\n\t\tif (new_config.footprint.empty()) {\n\t\t\tROS_ERROR(\"Invalid footprint string, not setting robot footprint\");\n\t\t} else {\n\t\t\tROS_INFO(\"Setting robot footprint to %s\", new_config.footprint.c_str());\n\t\t\tsetFootprintFromFootprintString(new_config.footprint);\n\t\t}\n\t}\n}", "CodeBleu_score": 46.863445633157966}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t//  if (new_config.robot_radius == old_config.robot_radius) {\n//    return;\n//  }\n\n  if (new_config.footprint.size() > 0) {\n    std::vector<geometry_msgs::Point> points;\n    try {\n      makeFootprintFromString(new_config.footprint, points);\n    } catch (const std::invalid_argument &ex) {\n      ROS_ERROR(\"Invalid footprint string: %s\", ex.what());\n      return;\n    }\n    setUnpaddedRobotFootprint(points);\n  } else {\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n  }\n}", "CodeBleu_score": 51.84841069150545}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get robot pose\n\tgeometry_msgs::PoseStamped global_pose;\n\tif (!getRobotPose(global_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\t// check if the robot has moved\n\tif (last_pose_.pose.position.x == global_pose.pose.position.x && last_pose_.pose.position.y == global_pose.pose.position.y) {\n\t\treturn;\n\t}\n\n\t// update the last pose\n\tlast_pose_ = global_pose;\n\n\t// publish the new pose\n\tros::Time now = ros::Time::now();\n\tif (now.toSec() - last_pose_pub_.header.stamp.toSec() > 0.05) {\n\t\tlast_pose_pub_.header.stamp = now;\n\t\tlast_pose_pub_.pose = last_pose_.pose;\n\t\tlast_pose_pub_.header.frame_id = global_frame_;\n\t\tlast_pose_pub_.child_frame_id = robot_base_frame_;\n\t\tlast_pose_pub_pub_.publish(last_pose_pub_);\n\t}\n}", "CodeBleu_score": 57.229147328169475}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (getRobotPose(new_pose_)) {\n\t\tif (new_pose_.header.stamp.toSec() > last_pose_.header.stamp.toSec()) {\n\t\t\tlast_pose_ = new_pose_;\n\t\t\tpublishCostmap();\n\t\t}\n\t} else {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 59.117910481067504}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!getRobotPose(new_pose_)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 40.47666446802264}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t", "CodeBleu_score": 1.488121648976743}, {"code": "void Costmap2DROS::start(){\n\t\t//ROS_INFO(\"Starting costmap\");\n\t//ROS_INFO(\"Waiting for map to become available...\");\n\t//while (ros::ok() &&!map_received_) {\n\t//\tros::Duration(0.1).sleep();\n\t//}\n\t//ROS_INFO(\"Map received.\");\n\t//if (!map_received_) {\n\t//\tROS_ERROR(\"Could not get map from map_server, aborting\");\n\t//\tros::shutdown();\n\t//}\n\t//if (!is_current_) {\n\t//\tROS_ERROR(\"Map is not current, aborting\");\n\t//\tros::shutdown();\n\t//}\n\t//if (map_update_thread_!= NULL) {\n\t//\tROS_ERROR(\"Map update thread already running, aborting\");\n\t//\tros::shutdown();\n\t//}\n\t//if (!is_stopped_) {\n\t//\tROS_ERROR(\"Costmap is not stopped, aborting\");\n\t//\tros::shutdown();\n\t//}\n\t//is_stopped_ = false;\n\t//stop_updates_ = false;\n\t//map_update_thread_ = new boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this));\n\t//ROS_INFO(\"Costmap started.\");\n}", "CodeBleu_score": 1.5748498721036488}, {"code": "void Costmap2DROS::start(){\n\t\tros::NodeHandle n;\n\tros::NodeHandle private_nh(\"~\");\n\tros::Time::init();\n\tros::Duration(0.5).sleep();\n\n\t// Check if the costmap was stopped\n\tif (stopped_) {\n\t\t// Activate each plugin\n\t\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_->begin(); plugin!= plugins_->end();\n\t\t\t\t++plugin) {\n\t\t\t(*plugin)->activate();\n\t\t}\n\t\t// Set the stopped flag to false\n\t\tstopped_ = false;\n\t\t// Set stop_updates_ to false\n\t\tstop_updates_ = false;\n\t}\n\n\t// Wait until ROS is running, the costmap is initialized, and the map update thread is active\n\twhile (!ros::isInitialized()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\tros::start();\n\tros::waitForShutdown();\n\n\t// Wait until the map is initialized\n\twhile (!map_received_) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// Wait until the map update thread is active\n\twhile (!map_update_thread_->isActive()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// Start the map update thread\n\tmap_update_thread_->start();\n}", "CodeBleu_score": 57.44275305698093}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0)) {\n\t\tobservation_list_.clear();\n\t} else {\n\t\t// Iterate through the list and remove observations that are older than the specified keep time, stopping once it finds a valid observation.\n\t\t// Note that the iterator is not invalidated by the erase operation, so the iterator is left pointing to the next valid observation.\n\t\tfor (auto it = observation_list_.begin(); it!= observation_list_.end(); ++it) {\n\t\t\tif (it->time - observation_list_.front().time < observation_keep_time_) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tobservation_list_.erase(it);\n\t\t}\n\t}\n}", "CodeBleu_score": 32.59694125064771}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// TODO: Implement this function.\n\t// If the observation_keep_time_ is zero, it keeps only the most recent observation.\n\t// Otherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.\n\tif(observation_keep_time_ == 0)\n\t{\n\t\tobservation_list_.pop_front();\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i < observation_list_.size(); i++)\n\t\t{\n\t\t\tif(observation_list_[i].time_received - observation_list_[0].time_received > observation_keep_time_)\n\t\t\t{\n\t\t\t\tobservation_list_.erase(observation_list_.begin());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.04014007822032}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the observation_keep_time_ is zero, it keeps only the most recent observation.\n\tif (observation_keep_time_ == ros::Duration(0)) {\n\t\tobservation_list_.clear();\n\t} else {\n\t\t// Otherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.\n\t\twhile (!observation_list_.empty() && observation_list_.front().header.stamp + observation_keep_time_ < ros::Time::now()) {\n\t\t\tobservation_list_.pop_front();\n\t\t}\n\t}\n}", "CodeBleu_score": 24.86422849396949}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_angle = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n\tdouble angular_distance = shortest_angular_distance(start_angle, end_angle);\n\n\tdouble angle_increment = angular_distance / (end_index - start_index);\n\n\tfor (int i = start_index; i < end_index; i++) {\n\t\tdouble current_angle = tf2::getYaw(path[i].pose.orientation);\n\t\tdouble new_angle = current_angle + angle_increment;\n\t\tset_angle(&path[i], new_angle);\n\t}\n}", "CodeBleu_score": 59.02140334129159}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (start_index == end_index) {\n\t\treturn;\n\t}\n\tif (start_index > end_index) {\n\t\tstd::swap(start_index, end_index);\n\t}\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble angular_distance = shortest_angular_distance(start_yaw, end_yaw);\n\tdouble delta_yaw = angular_distance / (end_index - start_index);\n\tfor (int i = start_index; i < end_index; i++) {\n\t\tdouble yaw = start_yaw + i * delta_yaw;\n\t\tset_angle(&path[i], yaw);\n\t}\n}", "CodeBleu_score": 63.42710512537602}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Get the yaw angles at the start and end indices\n\tdouble start_angle = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end angles\n\tdouble shortest_angle = shortest_angular_distance(start_angle, end_angle);\n\n\t// Compute the incremental change in angle for each pose\n\tdouble angle_increment = shortest_angle / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble new_angle = start_angle + angle_increment * (i - start_index);\n\t\tset_angle(&path[i], new_angle);\n\t}\n}", "CodeBleu_score": 61.57220956994802}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_DEBUG(\"PlannerWithCostmap::makePlanService\");\n\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call the makePlan function to generate a path\n\tbool found_path = makePlan(req.start, req.goal, resp.plan);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tresp.success = found_path;\n\n\t// Return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 56.11711831738372}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a plan request for the %zu (x,y) path points\", req.start.size());\n\tif (req.start.size()!= req.goal.size()) {\n\t\tROS_ERROR(\"Start and goal vectors must be same size!\");\n\t\tresp.plan.poses.clear();\n\t\treturn true;\n\t}\n\n\tif (req.start.size() == 0) {\n\t\tROS_ERROR(\"Both start and goal vectors are empty!\");\n\t\tresp.plan.poses.clear();\n\t\treturn true;\n\t}\n\n\tif (!costmap_ros_->getRobotPose(robot_pose_)) {\n\t\tROS_ERROR(\"Could not get robot pose\");\n\t\tresp.plan.poses.clear();\n\t\treturn true;\n\t}\n\n\t// Set the frame_id of the start and goal to map\n\tfor (unsigned int i = 0; i < req.start.size(); ++i) {\n\t\treq.start[i].header.frame_id = \"map\";\n\t\treq.goal[i].header.frame_id = \"map\";\n\t}\n\n\t// Make the plan\n\tbool success = makePlan(req.start, req.goal, resp.plan);\n\n\t// Update the response\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.success = success;\n\n\treturn true;\n}", "CodeBleu_score": 52.60681846357329}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tgeometry_msgs::PoseStamped start;\n\tgeometry_msgs::PoseStamped goal;\n\tstart.header.frame_id = \"map\";\n\tstart.pose = req.start;\n\tgoal.header.frame_id = \"map\";\n\tgoal.pose = req.goal;\n\n\tif (makePlan(start, goal, resp.plan)) {\n\t\tresp.success = true;\n\t} else {\n\t\tresp.success = false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.929840851316186}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() || wy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 42.5110372304694}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n\t\twy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_ERROR(\"The point (%f, %f) is not in the costmap.\", wx, wy);\n\t\treturn false;\n\t}\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\treturn true;\n}", "CodeBleu_score": 41.46084693214354}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() || wx >= costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() || wy >= costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n\t\tROS_ERROR(\"The point (%f, %f) is not in the costmap\", wx, wy);\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 42.00654303038429}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\nROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\nreturn;\n}\nnav_msgs::Path gui_path;\ngui_path.poses.resize(path.size());\ngui_path.header.frame_id = global_frame_;\ngui_path.header.stamp = ros::Time::now();\nfor (std::size_t i = 0; i < path.size(); ++i) {\ngui_path.poses[i] = path[i];\n}\nplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 77.54134424771476}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tfor (std::size_t i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i].pose;\n\t}\n\tgui_path.header.frame_id = path_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 73.18719383029278}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tfor (std::size_t i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tgui_path.header.frame_id = global_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 75.46782760446814}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t", "CodeBleu_score": 7.204876027809698}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In move_base::goalCB, wrapping goal in MoveBaseActionGoal and publishing\");\n\tmove_base_msgs::MoveBaseActionGoal move_base_goal;\n\tmove_base_goal.header.stamp = ros::Time::now();\n\tmove_base_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(move_base_goal);\n}", "CodeBleu_score": 67.15776634864068}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In move_base::goalCB, received a goal of type PoseStamped\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.header.frame_id = goal->header.frame_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 72.54468978616593}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t//  ROS_INFO(\"distanceCheck\");\n  if (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough to remove speed limit.\");\n    remove_limit_thread_->join();\n    remove_limit_thread_.reset(new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this)));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 42.05284991551919}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tROS_INFO(\"distanceCheck\");\n\tif (getSqDistance() > sq_distance_limit_) {\n\t\tROS_INFO(\"Robot has moved far enough\");\n\t\tROS_INFO(\"Distance check timer stopped\");\n\t\tdistance_check_timer_.stop();\n\t\tremove_limit_thread_->join();\n\t\tdelete remove_limit_thread_;\n\t\tremove_limit_thread_ = NULL;\n\t\tROS_INFO(\"Speed limit removed\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 54.37812670024867}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\n//  ROS_INFO(\"Distance Check\");\n  double sq_distance = getSqDistance();\n  if (sq_distance > sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough, stopping distance check\");\n    distance_check_timer_.stop();\n    remove_limit_thread_->join();\n    delete remove_limit_thread_;\n    remove_limit_thread_ = NULL;\n    stop_slow_and_clear_ = true;\n  }\n}", "CodeBleu_score": 53.10060622491286}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current global pose of the robot\n\tPoseStamped global_pose = getRobotPose();\n\t// Generate a path from the current pose to the goal pose\n\tvector<PoseStamped> plan;\n\tmakePlan(global_pose, goal->pose, plan);\n\t// Update the costmap with the generated path\n\tupdateCosts(plan);\n}", "CodeBleu_score": 52.337484544920635}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t//get the current pose of the robot\n\tPoseStamped global_pose;\n\tgetRobotPose(global_pose);\n\n\t//generate a path from the current pose to the goal pose\n\tvector<PoseStamped> global_plan;\n\tmakePlan(global_pose, *goal, global_plan);\n}", "CodeBleu_score": 61.67689149649516}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current pose of the robot\n\trm::PoseStamped current_pose;\n\tcurrent_pose = getRobotPose();\n\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<rm::PoseStamped> path;\n\tmakePlan(current_pose, goal->pose, path);\n\n\t// Update the costmap with the generated path\n\tupdateCostmap(path);\n}", "CodeBleu_score": 50.882732311665}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create the service request\n\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\n\t// Send the request\n\tif (this->param_set_client_.call(srv)) {\n\t\tROS_INFO(\"ParamSet service called successfully\");\n\t} else {\n\t\tROS_ERROR(\"Failed to call service param_set\");\n\t}\n}", "CodeBleu_score": 68.2259210571844}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tROS_INFO(\"GimbalParamSetServer called\");\n\tparam_set_srv_.request.param_id = param_set.param_id;\n\tparam_set_srv_.request.param_value = param_set.param_value;\n\tif (param_set_client_.call(param_set_srv_)) {\n\t\tROS_INFO(\"GimbalParamSetServer: Succeeded\");\n\t} else {\n\t\tROS_ERROR(\"GimbalParamSetServer: Failed\");\n\t}\n}", "CodeBleu_score": 40.85255176077885}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tstd::cout << \"Gimbal Param Set Server\" << std::endl;\n\n\t// Create a ParamSet service request\n\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\n\t// Call the param_set_client_ to send the request\n\tif (this->param_set_client_.call(param_set_srv)) {\n\t\tROS_INFO(\"Gimbal Param Set Server: Param Set Service Call Succeeded\");\n\t} else {\n\t\tROS_ERROR(\"Gimbal Param Set Server: Param Set Service Call Failed\");\n\t}\n}", "CodeBleu_score": 52.739140559586794}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!this->simulation_mode_) {\n\t\tthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n\t} else {\n\t\tstd::map<int, std::shared_ptr<UAVControlSimulation>>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\t(*it).second->uavCmdPub.publish(uav_cmd);\n\t\t}\n\t}\n}", "CodeBleu_score": 47.44444090610826}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!this->is_simulation_) {\n\t\tthis->uav_basic_->uavCmdPub(uav_cmd);\n\t} else {\n\t\tif (this->swarm_control_simulation_.find(uav_cmd.id)!= this->swarm_control_simulation_.end()) {\n\t\t\tthis->swarm_control_simulation_[uav_cmd.id]->uavCmdPub(uav_cmd);\n\t\t} else {\n\t\t\tROS_WARN(\"UAV %d is not in simulation mode, but has been sent a command.\", uav_cmd.id);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.89991199053716}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!this->simulation_mode_) {\n\t\t// Publish command to UAV\n\t\tthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n\t} else {\n\t\t// Find UAV with matching ID\n\t\tstd::map<uint8_t, UAVBasic*>::iterator it;\n\t\tfor (it = this->swarm_control_simulation_.begin(); it!= this->swarm_control_simulation_.end(); it++) {\n\t\t\tif (it->second->uavID == uav_cmd.uavID) {\n\t\t\t\t// Publish command to UAV\n\t\t\t\tit->second->uavCmdPub.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.16112838772146}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t// Check if the mode is set to REBOOTNX\n\tif (mode_selection.mode == REBOOTNX) {\n\t\t// Execute the REBOOTNX system command\n\t\tsystem(REBOOTNX_COMMAND);\n\t}\n\t// Check if the mode is set to EXITNX\n\telse if (mode_selection.mode == EXITNX) {\n\t\t// Execute the EXITNX system command\n\t\tsystem(EXITNX_COMMAND);\n\t}\n\t// Check if the mode is set to CREATE\n\telse if (mode_selection.use_mode == CREATE) {\n\t\t// Call the createMode function\n\t\tcreateMode(mode_selection.mode_name);\n\t}\n\t// Check if the mode is set to DELETE\n\telse if (mode_selection.use_mode == DELETE) {\n\t\t// Call the deleteMode function\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 61.47008547364216}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tint mode = mode_selection.mode;\n\tint use_mode = mode_selection.use_mode;\n\tif (mode == REBOOTNX || mode == EXITNX) {\n\t\tif (use_mode == CREATEMODE) {\n\t\t\tcreateMode();\n\t\t} else if (use_mode == DELETEMODE) {\n\t\t\tdeleteMode();\n\t\t}\n\t}\n}", "CodeBleu_score": 27.84949835311717}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == 0) {\n\t\tsystem(\"sudo reboot\");\n\t} else if (mode_selection.use_mode == 1) {\n\t\tsystem(\"sudo shutdown -h now\");\n\t} else if (mode_selection.use_mode == 2) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == 3) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 58.998483672603875}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check if the heartbeat has been lost\n\tif (heartbeat_counter_ > heartbeat_timeout_) {\n\t\tROS_ERROR_STREAM(\"Heartbeat lost!\");\n\t\tif (vehicle_type_ == VehicleType::UAV) {\n\t\t\ttriggerUAV();\n\t\t} else if (vehicle_type_ == VehicleType::UGV) {\n\t\t\ttriggerUGV();\n\t\t} else if (vehicle_type_ == VehicleType::Swarm) {\n\t\t\ttriggerSwarmControl();\n\t\t} else {\n\t\t\tROS_ERROR_STREAM(\"Invalid vehicle type!\");\n\t\t}\n\t\tdisconnect_flag_ = true;\n\t}\n}", "CodeBleu_score": 24.3299435735343}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count_ == 0) {\n\t\tROS_ERROR(\"Heartbeat lost!\");\n\t\tif (vehicle_type_ == \"swarm\") {\n\t\t\ttriggerSwarmControl();\n\t\t} else if (vehicle_type_ == \"uav\") {\n\t\t\ttriggerUAVControl();\n\t\t} else if (vehicle_type_ == \"ugv\") {\n\t\t\ttriggerUGVControl();\n\t\t}\n\t\tdisconnect_flag_ = true;\n\t} else {\n\t\theartbeat_count_ = 0;\n\t}\n}", "CodeBleu_score": 22.89764603926196}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count_ < max_heartbeat_count_) {\n\t\theartbeat_count_++;\n\t} else {\n\t\tROS_ERROR_STREAM(\"Heartbeat lost. Missed \" << max_heartbeat_count_ << \" heartbeats.\");\n\t\tif (vehicle_type_ == \"swarm\") {\n\t\t\ttriggerSwarmControl();\n\t\t} else if (vehicle_type_ == \"UAV\") {\n\t\t\ttriggerUAVControl();\n\t\t} else if (vehicle_type_ == \"UGV\") {\n\t\t\ttriggerUGVControl();\n\t\t}\n\t\tdisconnect_flag_ = true;\n\t}\n}", "CodeBleu_score": 32.804684797223814}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tint droneID = msg->drone_id;\n\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.droneID = droneID;\n\t\tbspline.trajID = i;\n\t\tbspline.knots.resize(msg->traj[i].knots.size());\n\t\tbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n\t\tbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots[j].x = msg->traj[i].knots[j].x;\n\t\t\tbspline.knots[j].y = msg->traj[i].knots[j].y;\n\t\t\tbspline.knots[j].z = msg->traj[i].knots[j].z;\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts[j].x = msg->traj[i].pos_pts[j].x;\n\t\t\tbspline.pos_pts[j].y = msg->traj[i].pos_pts[j].y;\n\t\t\tbspline.pos_pts[j].z = msg->traj[i].pos_pts[j].z;\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n\t\t}\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tthis->communication->sendMsgByTcp(this->communication->encodeMsg(bspline));\n\t}\n}", "CodeBleu_score": 67.1973031524949}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO_STREAM(\"Received MultiBsplines msg from \" << msg->drone_id);\n\n\t// For each trajectory in the message\n\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\t// Initialize a new Bspline struct\n\t\tBspline bspline;\n\n\t\t// Set the drone ID\n\t\tbspline.drone_id = msg->drone_id;\n\n\t\t// Set the start time\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\n\t\t// Set the number of knots\n\t\tbspline.knots.resize(msg->traj[i].knots.size());\n\n\t\t// Set the number of position points\n\t\tbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n\n\t\t// Set the number of yaw points\n\t\tbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\n\t\t// For each knot in the trajectory\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\t// Set the knot\n\t\t\tbspline.knots[j] = msg->traj[i].knots[j];\n\t\t}\n\n\t\t// For each position point in the trajectory\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\t// Set the position point\n\t\t\tbspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n\t\t}\n\n\t\t// For each yaw point in the trajectory\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\t// Set the yaw point\n\t\t\tbspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n\t\t}\n\n\t\t// Encode the Bspline data and send it via TCP\n\t\tthis->communication->encodeMsg(bspline);\n\t\tthis->communication->sendMsgByTcp();\n\t}\n}", "CodeBleu_score": 53.68048545056055}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tROS_INFO_STREAM(\"Received MultiBsplines message from TCP\");\n\tint drone_id = msg->drone_id;\n\tint traj_size = msg->traj.size();\n\tROS_INFO_STREAM(\"Drone ID: \" << drone_id << \" Trajectory size: \" << traj_size);\n\tfor (int i = 0; i < traj_size; i++) {\n\t\tBspline bspline;\n\t\tbspline.id = drone_id;\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tbspline.knots.resize(msg->traj[i].knots.size());\n\t\tbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n\t\tbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots[j] = msg->traj[i].knots[j];\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n\t\t}\n\t\tstd::string encoded_msg = this->communication->encodeMsg(bspline);\n\t\tthis->communication->sendMsgByTcp(encoded_msg);\n\t}\n}", "CodeBleu_score": 56.73726428359438}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.filter(*cloud_compressed);\n\tsensor_msgs::PointCloud2 cloud_msg;\n\tpcl::toROSMsg(*cloud_compressed, cloud_msg);\n\treturn cloud_msg;\n}", "CodeBleu_score": 28.763439105034095}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a pcl::PointCloud from the input message\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Compress the point cloud\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.setLeafSize(leaf_size, leaf_size, leaf_size);\n\toctree_compression.filter(*cloud);\n\n\t// Create a new PointCloud2 message and copy the compressed data into it\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = 1;\n\tcompressed_msg.width = cloud->size();\n\tcompressed_msg.fields = msg.fields;\n\tcompressed_msg.is_bigendian = msg.is_bigendian;\n\tcompressed_msg.point_step = msg.point_step;\n\tcompressed_msg.row_step = msg.row_step;\n\tcompressed_msg.is_dense = msg.is_dense;\n\tcompressed_msg.data.resize(octree_compression.encodePointCloud(cloud, compressed_msg.data));\n\n\t// Return the compressed message\n\treturn compressed_msg;\n}", "CodeBleu_score": 40.06208276066317}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloudPtr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloudPtr2(new pcl::PointCloud<pcl::PointXYZ>());\n\toctree_compression.setInputCloud(cloudPtr);\n\toctree_compression.filter(*cloudPtr2);\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tpcl::toROSMsg(*cloudPtr2, compressed_msg);\n\treturn compressed_msg;\n}", "CodeBleu_score": 27.608756950032078}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.53973655827699}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize the MultiUGVState message\n\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_state_all.clear();\n\n\t// Iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n\t\t// Create a UGVState message for each UGV\n\t\tUGVState ugv_state;\n\t\tugv_state.id = m_multi_ugv_state.ugv_state_all[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\t\tugv_state.position = m_multi_ugv_state.ugv_state_all[i].position;\n\t\tugv_state.velocity = m_multi_ugv_state.ugv_state_all[i].velocity;\n\t\tugv_state.attitude = m_multi_ugv_state.ugv_state_all[i].attitude;\n\n\t\t// Add the UGVState message to the MultiUGVState message\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// Publish the MultiUGVState message\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 38.921929725455605}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tUGVState m_ugv_state;\n\tm_ugv_state.ugv_state.id = 0;\n\tm_ugv_state.ugv_state.battery = 0;\n\tm_ugv_state.ugv_state.position.x = 0;\n\tm_ugv_state.ugv_state.position.y = 0;\n\tm_ugv_state.ugv_state.position.z = 0;\n\tm_ugv_state.ugv_state.velocity.x = 0;\n\tm_ugv_state.ugv_state.velocity.y = 0;\n\tm_ugv_state.ugv_state.velocity.z = 0;\n\tm_ugv_state.ugv_state.attitude.roll = 0;\n\tm_ugv_state.ugv_state.attitude.pitch = 0;\n\tm_ugv_state.ugv_state.attitude.yaw = 0;\n\tm_ugv_state.ugv_state.attitude_rate.roll = 0;\n\tm_ugv_state.ugv_state.attitude_rate.pitch = 0;\n\tm_ugv_state.ugv_state.attitude_rate.yaw = 0;\n\tm_ugv_state.ugv_state.timestamp = 0;\n\tm_ugv_state.ugv_state.status = 0;\n\n\tm_multi_ugv_state.ugv_state_all.clear();\n\tint m_ugv_count = 0;\n\tfor (int i = 0; i < m_ugv_count; i++) {\n\t\tm_multi_ugv_state.ugv_state_all.push_back(m_ugv_state);\n\t}\n\tall_ugv_state_pub_.publish(m_multi_ugv_state);\n}", "CodeBleu_score": 31.742058449569893}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\ngradient = Eigen::MatrixXd::Zero(6, cps_.points.cols());\nfor (int i = 0; i < cps_.points.cols(); i++) {\nEigen::Vector3d obj_prid = moving_objs_->predictPosition(q.col(i));\ndouble dist = (cps_.points.col(i) - obj_prid).norm();\nif (dist < moving_objs_->clearance) {\ncost += pow(dist - moving_objs_->clearance, 2);\ngradient.col(i) = (cps_.points.col(i) - obj_prid).normalized();\n}\n}\n}", "CodeBleu_score": 34.285885513076444}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tdouble clearance = 0.5;\n\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(6, q.cols());\n\tEigen::VectorXd obj_prid(3);\n\tEigen::Vector3d cps_point;\n\tEigen::Vector3d cps_gradient;\n\tfor (int i = 0; i < cps_.points.cols(); i++) {\n\t\tcps_point = cps_.points.col(i);\n\t\tcps_gradient = cps_.gradients.col(i);\n\t\tobj_prid = moving_objs_->getPredictedPos(cps_point, cps_gradient);\n\t\tfor (int j = 0; j < moving_objs_->getObjNums(); j++) {\n\t\t\tif ((obj_prid - moving_objs_->getObjPos(j)).norm() < clearance) {\n\t\t\t\tcost += pow((obj_prid - moving_objs_->getObjPos(j)).norm() - clearance, 2);\n\t\t\t\tgradient.col(i) += 2 * (obj_prid - moving_objs_->getObjPos(j)) / (obj_prid - moving_objs_->getObjPos(j)).norm();\n\t\t\t}\n\t\t}\n\t}\n\tcost *= 0.5;\n}", "CodeBleu_score": 40.54002886975162}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient.setZero(q.rows(), q.cols());\n\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\tEigen::Vector3d x = q.col(i);\n\t\tEigen::Vector3d v = (x - ref_pts_[i]).normalized();\n\t\tEigen::Vector3d v_dot = (x - ref_pts_[i - 1]).normalized();\n\t\tEigen::Vector3d xcrossv = x.cross(v);\n\t\tEigen::Vector3d xcrossv_dot = x.cross(v_dot);\n\n\t\tdouble a2 = 1.0 / (1.0 + pow(v.norm(), 2));\n\t\tdouble b2 = 1.0 / (1.0 + pow(v_dot.norm(), 2));\n\n\t\tdouble d = x.dot(v);\n\t\tdouble d_dot = x.dot(v_dot);\n\n\t\tdouble cost_i = a2 * d * d + b2 * d_dot * d_dot;\n\t\tcost += cost_i;\n\n\t\tgradient.col(i) = (a2 * d * v + b2 * d_dot * v_dot).normalized();\n\t\tgradient.col(i) += (a2 * d * xcrossv + b2 * d_dot * xcrossv_dot).normalized();\n\t}\n}", "CodeBleu_score": 43.23240316545939}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctrl_pts = getJerkControlPoints();\n\tEigen::VectorXd knot = getKnot();\n\tdouble jerk = 0.0;\n\n\tfor (int i = 0; i < ctrl_pts.rows(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.cols(); j++) {\n\t\t\tjerk += ctrl_pts(i, j) * (knot(i + 1) - knot(i)) * (knot(i + 2) - knot(i + 1));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 51.180181262900405}, {"code": "double UniformBspline::getJerk(){\n\t\tUniformBspline jerk_traj = getJerkTrajectory();\n\tEigen::VectorXd jerk_knots = jerk_traj.getKnot();\n\tEigen::MatrixXd jerk_ctrl_pts = jerk_traj.getControlPoint();\n\tdouble jerk = 0;\n\tfor (int i = 0; i < jerk_ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < jerk_ctrl_pts.rows(); j++) {\n\t\t\tjerk += pow(jerk_ctrl_pts(j, i), 2) * (jerk_knots(i + 1) - jerk_knots(i));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 56.906585449810485}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd jerk_ctp = getJerkControlPoints();\n\tEigen::VectorXd knots = getKnot();\n\tdouble jerk = 0.0;\n\n\tfor (int i = 0; i < jerk_ctp.rows(); i++) {\n\t\tfor (int j = 0; j < jerk_ctp.cols(); j++) {\n\t\t\tjerk += (jerk_ctp(i, j) * (knots(i + 1) - knots(i)));\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 48.87890692866823}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos_camera;\n\tEigen::Vector4d pos_world;\n\n\tpos_camera << u, v, depth, 1.0;\n\tpos_world = K_ * pos_camera;\n\treturn pos_world;\n}", "CodeBleu_score": 32.69725155344382}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1;\n\treturn pos;\n}", "CodeBleu_score": 37.896344210819656}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\n\t// Convert pixel coordinates to camera coordinates\n\tfloat x = (u - cx_) / fx_;\n\tfloat y = (v - cy_) / fy_;\n\tfloat z = depth;\n\n\t// Convert to 3D position vector\n\tpos << x, y, z, 1;\n\n\treturn pos;\n}", "CodeBleu_score": 40.725373171168776}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(0, odom.child_frame_id.find_first_of(\":\"))));\n\t} catch (std::exception& e) {\n\t\tstd::cerr << \"Failed to extract drone ID from odometry message: \" << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 40.75910889927865}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(0, odom.child_frame_id.find('_')));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::invalid_argument e) {\n\t\tstd::cout << \"Error: \" << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 52.97951159290598}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(7, 1));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tROS_WARN_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n\t}\n}", "CodeBleu_score": 48.45254050490354}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Calculate the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = camera_pose_ + drone_poses_[drone_id] + Eigen::Vector3d(true_pixel.x(), true_pixel.y(), 0.0);\n\n\t// Check for the presence of the drone\n\tif (true_pose.z() > 0.0) {\n\t\t// Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d error = true_pose - world_pose_;\n\t\terror(2) = 0.0; // Ignore the z-component of the error\n\t\tEigen::Vector3d error_norm = error.normalized();\n\n\t\t// Update the debug result\n\t\tdrone_pose_err_debug_[drone_id].pose_error = error;\n\t\tdrone_pose_err_debug_[drone_id].pose_error_norm = error_norm;\n\t\tdrone_pose_err_debug_[drone_id].pose_error_norm_abs = error_norm.cwiseAbs();\n\n\t\t// Publish the pose error\n\t\tdrone_pose_err_pub_[drone_id].publish(drone_pose_err_debug_[drone_id]);\n\t} else {\n\t\t// Update the debug result to indicate failure\n\t\tdrone_pose_err_debug_[drone_id].pose_error << 0.0, 0.0, 0.0;\n\t\tdrone_pose_err_debug_[drone_id].pose_error_norm << 0.0, 0.0, 0.0;\n\t\tdrone_pose_err_debug_[drone_id].pose_error_norm_abs << 0.0, 0.0, 0.0;\n\t\tdrone_pose_err_pub_[drone_id].publish(drone_pose_err_debug_[drone_id]);\n\t}\n}", "CodeBleu_score": 43.753139637380976}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone's pose in the camera frame\n\tEigen::Vector3d drone_pose_cam = drone_poses_cam_[drone_id];\n\t// Get the drone's pose in the world frame\n\tEigen::Vector3d drone_pose_world = drone_poses_world_[drone_id];\n\t// Compute the true pose of the drone in the world frame\n\tEigen::Vector3d true_pose_world = drone_pose_world + drone_pose_cam;\n\t// Compute the pose error between the camera and world coordinates\n\tEigen::Vector3d pose_error = true_pose_world - true_pixel;\n\t// Update the debug result\n\tdebug_result_[drone_id] = true;\n\t// Publish the pose error\n\tpose_error[0] = pose_error[0] * 1000;\n\tpose_error[1] = pose_error[1] * 1000;\n\tpose_error[2] = pose_error[2] * 1000;\n\tpose_error_pub_[drone_id].publish(pose_error);\n}", "CodeBleu_score": 32.125949409701136}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\twhile (current!= nullptr) {\n\t\tpath.push_back(current);\n\t\tcurrent = cameFrom[current];\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 56.86323039376661}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 78.86875382773461}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\tif (IsOccupied(start_idx)) {\n\t\tVector3d start_pt_adjusted = start_pt;\n\t\twhile (IsOccupied(start_idx)) {\n\t\t\tstart_pt_adjusted += (end_pt - start_pt).normalized;\n\t\t\tstart_idx = Coord2Index(start_pt_adjusted);\n\t\t}\n\t\tstart_pt = start_pt_adjusted;\n\t}\n\tif (IsOccupied(end_idx)) {\n\t\tVector3d end_pt_adjusted = end_pt;\n\t\twhile (IsOccupied(end_idx)) {\n\t\t\tend_pt_adjusted += (start_pt - end_pt).normalized;\n\t\t\tend_idx = Coord2Index(end_pt_adjusted);\n\t\t}\n\t\tend_pt = end_pt_adjusted;\n\t}\n\treturn true;\n}", "CodeBleu_score": 43.73265901309723}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\tif (start_idx == end_idx) {\n\t\treturn true;\n\t}\n\tif (OccupancyGrid::IsOccupied(start_idx)) {\n\t\tVector3d new_start_pt = start_pt;\n\t\twhile (OccupancyGrid::IsOccupied(Coord2Index(new_start_pt))) {\n\t\t\tnew_start_pt += (start_pt - end_pt).normalized();\n\t\t}\n\t\tstart_idx = Coord2Index(new_start_pt);\n\t}\n\tif (OccupancyGrid::IsOccupied(end_idx)) {\n\t\tVector3d new_end_pt = end_pt;\n\t\twhile (OccupancyGrid::IsOccupied(Coord2Index(new_end_pt))) {\n\t\t\tnew_end_pt += (end_pt - start_pt).normalized();\n\t\t}\n\t\tend_idx = Coord2Index(new_end_pt);\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.09952906377065}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\tif (start_idx == end_idx)\n\t\treturn true;\n\tif (!checkOccupancy(start_pt)) {\n\t\tstart_idx = Coord2Index(start_pt);\n\t\tend_idx = Coord2Index(end_pt);\n\t\treturn true;\n\t}\n\tif (!checkOccupancy(end_pt)) {\n\t\tstart_idx = Coord2Index(start_pt);\n\t\tend_idx = Coord2Index(end_pt);\n\t\treturn true;\n\t}\n\tif (checkOccupancy(start_pt)) {\n\t\twhile (checkOccupancy(start_pt)) {\n\t\t\tstart_pt += Index2Coord(start_idx).normalized;\n\t\t\tstart_idx = Coord2Index(start_pt);\n\t\t}\n\t}\n\tif (checkOccupancy(end_pt)) {\n\t\twhile (checkOccupancy(end_pt)) {\n\t\t\tend_pt += Index2Coord(end_idx).normalized;\n\t\t\tend_idx = Coord2Index(end_pt);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.11320669683303}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = getIndex(min_pos);\n\tEigen::Vector3i max_id = getIndex(max_pos);\n\n\tfor (int z = min_id(2); z <= max_id(2); z++) {\n\t\tfor (int y = min_id(1); y <= max_id(1); y++) {\n\t\t\tfor (int x = min_id(0); x <= max_id(0); x++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t\tdistance_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 63.79275420889243}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t", "CodeBleu_score": 4.296121109088976}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t", "CodeBleu_score": 4.296121109088976}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt;\n\tEigen::Vector3d max_pt;\n\tfor (int i = 0; i < 3; i++) {\n\t\tmin_pt[i] = pt[i] - diff[i];\n\t\tmax_pt[i] = pt[i] + diff[i];\n\t}\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_pt[i] < min_[i]) {\n\t\t\tmin_pt[i] = min_[i];\n\t\t}\n\t\tif (max_pt[i] > max_[i]) {\n\t\t\tmax_pt[i] = max_[i];\n\t\t}\n\t}\n\n\treturn min_pt;\n}", "CodeBleu_score": 38.154474877025244}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_trans = diff;\n\tEigen::Vector3d max_trans = diff;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_trans[i] < 0) {\n\t\t\tmin_trans[i] = 0;\n\t\t}\n\t\tif (max_trans[i] > map_size_[i]) {\n\t\t\tmax_trans[i] = map_size_[i];\n\t\t}\n\t}\n\treturn camera_pt + min_trans;\n}", "CodeBleu_score": 37.159394518136146}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tmd_.last_occ_update_time_ = ros::Time::now();\n\tif (md_.need_occ_update_) {\n\t\tmd_.need_occ_update_ = false;\n\t\tif (md_.has_odom_ && md_.has_depth_) {\n\t\t\tif (md_.has_local_map_) {\n\t\t\t\tclearAndInflateLocalMap();\n\t\t\t}\n\t\t\tprojectDepthImage();\n\t\t\traycastProcess();\n\t\t} else {\n\t\t\tROS_ERROR(\"Occupancy grid update timeout. No odometry or depth data.\");\n\t\t\tmd_.has_occ_update_timeout_ = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.20380208149016}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update last occupancy update time\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// Update local map if needed\n\tif (md_.local_map_updated_) {\n\t\tclearAndInflateLocalMap();\n\t}\n\n\t// Handle timeout errors\n\tif (md_.odom_timeout_error_) {\n\t\tROS_WARN(\"Odometry timeout error. Occupancy grid not updated.\");\n\t\tmd_.odom_timeout_error_ = false;\n\t}\n\tif (md_.depth_timeout_error_) {\n\t\tROS_WARN(\"Depth timeout error. Occupancy grid not updated.\");\n\t\tmd_.depth_timeout_error_ = false;\n\t}\n\n\t// Project depth image into points\n\tif (md_.depth_image_updated_) {\n\t\tprojectDepthImage();\n\t\tmd_.depth_image_updated_ = false;\n\t}\n\n\t// Process points with raycasting\n\tif (md_.points_updated_) {\n\t\traycastProcess();\n\t\tmd_.points_updated_ = false;\n\t}\n}", "CodeBleu_score": 49.44264592851173}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure_total = 0.f;\n\tfor (int i = 0; i < image_fns.size(); ++i) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\t\tfmeasure_total += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\treturn fmeasure_total / image_fns.size();\n}", "CodeBleu_score": 64.09963078300059}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure = 0.f;\n\tunsigned n_images = image_fns.size();\n\tfor (unsigned i = 0; i < n_images; ++i) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error opening: \" << image_fns[i] << endl;\n\t\t\treturn 0.f;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tfloat fmeasure_one = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\tfmeasure += fmeasure_one;\n\t}\n\n\treturn fmeasure / n_images;\n}", "CodeBleu_score": 54.45600162964388}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat total_fmeasure = 0.0f;\n\tint total_images = 0;\n\tfor (unsigned int i = 0; i < image_fns.size(); ++i) {\n\t\tstring image_fn = image_fns[i];\n\t\tstring gt_fn = gt_fns[i];\n\t\tstring dt_fn = dt_fns[i];\n\t\tMat3b img = imread(image_fn);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error loading: \" << image_fn << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\ttotal_fmeasure += fmeasure;\n\t\ttotal_images++;\n\t}\n\treturn total_fmeasure / total_images;\n}", "CodeBleu_score": 49.35663195344853}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_a, angle_b, angle_diff;\n\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\tangle_a = atan2(y, x);\n\tangle_b = atan2(foci[1], foci[0]);\n\tangle_diff = angle_diff_signed(angle_a, angle_b);\n\treturn angle_diff;\n}", "CodeBleu_score": 29.50920548439869}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle1, angle2;\n\tfloat angle_diff;\n\n\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\tangle1 = atan2(y - foci[1], x - foci[0]);\n\tangle2 = atan2(y - foci[3], x - foci[2]);\n\tangle_diff = angle_diff_signed(angle1, angle2);\n\treturn angle_diff;\n}", "CodeBleu_score": 44.82971395396213}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat c = sqrt(a*a - b*b);\n\tfloat x1 = x - a;\n\tfloat y1 = y - c;\n\tfloat x2 = x - a;\n\tfloat y2 = y + c;\n\tfloat angle1 = atan2(y1, x1);\n\tfloat angle2 = atan2(y2, x2);\n\tfloat angle_diff = angle_diff_signed(angle1, angle2);\n\tfloat normal_angle = angle1 + angle_diff;\n\treturn normal_angle;\n}", "CodeBleu_score": 34.84006212222889}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tif (start >= end) return true;\n\tint n = end - start;\n\tif (n == 1) return false;\n\tint x1 = vp1[start].x;\n\tint y1 = vp1[start].y;\n\tint x2 = vp1[end].x;\n\tint y2 = vp1[end].y;\n\tint x3 = vp1[start + 1].x;\n\tint y3 = vp1[start + 1].y;\n\tint x4 = vp1[end - 1].x;\n\tint y4 = vp1[end - 1].y;\n\tint x_min = min(x1, min(x2, min(x3, x4)));\n\tint x_max = max(x1, max(x2, max(x3, x4)));\n\tint y_min = min(y1, min(y2, min(y3, y4)));\n\tint y_max = max(y1, max(y2, max(y3, y4)));\n\tint area_below = 0;\n\tint area_above = 0;\n\tfor (int i = x_min; i <= x_max; i++) {\n\t\tint y_below = y_min;\n\t\tint y_above = y_max;\n\t\tfor (int j = y_min; j <= y_max; j++) {\n\t\t\tif (point_in_triangle(i, j, x1, y1, x2, y2, x3, y3)) {\n\t\t\t\tarea_below++;\n\t\t\t}\n\t\t\tif (point_in_triangle(i, j, x4, y4, x2, y2, x1, y1)) {\n\t\t\t\tarea_above++;\n\t\t\t}\n\t\t}\n\t}\n\treturn area_below > area_above;\n}", "CodeBleu_score": 36.721452233151844}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = INT_MAX;\n\tint max_x = INT_MIN;\n\tint min_y = INT_MAX;\n\tint max_y = INT_MIN;\n\tint integral_above = 0;\n\tint integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tint x = vp1[i].x;\n\t\tint y = vp1[i].y;\n\t\tif (y > max_y) {\n\t\t\tintegral_above += x;\n\t\t}\n\t\tif (y < min_y) {\n\t\t\tintegral_below += x;\n\t\t}\n\t}\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.99495463998313}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tstatic int num_regain = 0;\n\tstatic int num_lost = 0;\n\tstatic bool is_detected = false;\n\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\n\tif (is_detected) {\n\t\tellipse_det.sight_angle_left = msg->detection_info[0].sight_angle;\n\t\tellipse_det.sight_angle_right = msg->detection_info[1].sight_angle;\n\t} else {\n\t\tellipse_det.sight_angle_left = 0;\n\t\tellipse_det.sight_angle_right = 0;\n\t}\n}", "CodeBleu_score": 64.37995439256137}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t", "CodeBleu_score": 10.461696713377352}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tdouble x = cur_pos(0);\n\tdouble y = cur_pos(1);\n\tdouble z = cur_pos(2);\n\n\tif (Occupy_map_ptr->check_safety(x, y, z, safe_distance)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 43.67623944199923}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node!= NULL) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.171770131868186}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.59018470364623}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr node = end_node;\n\twhile (node!= nullptr) {\n\t\tpath_nodes_.push_back(node);\n\t\tnode = node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.147758564157215}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t", "CodeBleu_score": 3.1699249080664136}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tgeometry_msgs::PoseStamped odom_pose;\n\todom_pose.header.frame_id = \"map\";\n\todom_pose.pose.position.x = odom->pose.pose.position.x;\n\todom_pose.pose.position.y = odom->pose.pose.position.y;\n\todom_pose.pose.position.z = odom->pose.pose.position.z;\n\todom_pose.pose.orientation.x = odom->pose.pose.orientation.x;\n\todom_pose.pose.orientation.y = odom->pose.pose.orientation.y;\n\todom_pose.pose.orientation.z = odom->pose.pose.orientation.z;\n\todom_pose.pose.orientation.w = odom->pose.pose.orientation.w;\n\tgeometry_msgs::Point start_pos;\n\tstart_pos.x = 0;\n\tstart_pos.y = 0;\n\tstart_pos.z = 0;\n\tif(sim_mode) {\n\t\tif((odom_pose.pose.position-start_pos).norm() > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n\tstate_nei[id].set_pose(odom_pose);\n}", "CodeBleu_score": 50.598377693053166}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].v = 0;\n\tstate_nei[id].w = 0;\n\tstate_nei[id].is_new = true;\n\tif (sim_mode) {\n\t\tif ( (start_pos-state_nei[id]).norm > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 47.64063058015767}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 5.371612362555575}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tif (update_counter == 0) {\n\t\t\tupdate_counter++;\n\t\t\treturn;\n\t\t}\n\t\tif (update_counter == 1) {\n\t\t\tupdate_counter++;\n\t\t\treturn;\n\t\t}\n\t\tif (update_counter == 2) {\n\t\t\tupdate_counter++;\n\t\t\treturn;\n\t\t}\n\t\tif (update_counter == 3) {\n\t\t\tupdate_counter++;\n\t\t\treturn;\n\t\t}\n\t\tif (update_counter == 4) {\n\t\t\tupdate_counter = 0;\n\t\t\tROS_INFO(\"UGV: Updating Astar map\");\n\t\t\tAstar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\t\t}\n\t}\n}", "CodeBleu_score": 50.285802183540355}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 5.371612362555575}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\t// Store the point cloud in the global map\n\t\tpcl::fromROSMsg(*global_point, global_map);\n\t\t// Inflates the point cloud\n\t\tinflate_point_cloud(global_map);\n\t\tget_gpcl = true;\n\t}\n}", "CodeBleu_score": 44.854895659414076}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, global_map);\n\t\tglobal_map = global_map + global_map_inflate;\n\t}\n}", "CodeBleu_score": 45.430692636970456}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\tif (sim_mode) {\n\t\t// Project the laser scan into a PointCloud2 format\n\t\tsensor_msgs::PointCloud2 laser_point;\n\t\tprojector_.projectLaser(*local_point, laser_point);\n\t\t// Convert the PointCloud2 to a pcl::PointCloud\n\t\tpcl::PointCloud<pcl::PointXYZ> laser_cloud;\n\t\tpcl::fromROSMsg(laser_point, laser_cloud);\n\t\t// Merge the local map with the provided odometry data\n\t\tpcl::PointCloud<pcl::PointXYZ> merged_cloud;\n\t\tmerge_laser(laser_cloud, merged_cloud, odom);\n\t\t// Convert the merged cloud to a PointCloud2 format\n\t\tsensor_msgs::PointCloud2 merged_point;\n\t\tpcl::toROSMsg(merged_cloud, merged_point);\n\t\t// Update the occupancy map using the merged cloud\n\t\tmap_update(merged_point);\n\t} else {\n\t\t// Project the laser scan into a PointCloud2 format\n\t\tsensor_msgs::PointCloud2 laser_point;\n\t\tprojector_.projectLaser(*local_point, laser_point);\n\t\t// Convert the PointCloud2 to a pcl::PointCloud\n\t\tpcl::PointCloud<pcl::PointXYZ> laser_cloud;\n\t\tpcl::fromROSMsg(laser_point, laser_cloud);\n\t\t// Update the occupancy map using the laser cloud\n\t\tmap_update(laser_cloud);\n\t}\n}", "CodeBleu_score": 48.080693711730035}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic\n\tpcl::toROSMsg(*global_pcl_map, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Convert and publish the inflated point cloud to the inflate_pcl_pub topic with the same frame ID\n\tinflate_pcl_pub.publish(*inflate_pcl_map);\n}", "CodeBleu_score": 33.891293416031175}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic.\n\tpcl::toROSMsg(*global_map_, global_pcl_);\n\tglobal_pcl_.header.frame_id = \"world\";\n\tglobal_pcl_.header.stamp = ros::Time::now();\n\tglobal_pcl_pub.publish(global_pcl_);\n\n\t// Convert and publish the inflated point cloud to the inflate_pcl_pub topic with the same frame ID.\n\tpcl::toROSMsg(*inflate_map_, inflate_pcl_);\n\tinflate_pcl_.header.frame_id = \"world\";\n\tinflate_pcl_.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(inflate_pcl_);\n}", "CodeBleu_score": 48.761142585489516}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tif (pcl_pub_flag) {\n\t\tif (pcl_pub_flag) {\n\t\t\tpcl::PointCloud<pcl::PointXYZ> pcl_msg;\n\t\t\tpcl_msg.header.frame_id = \"world\";\n\t\t\tpcl_msg.header.stamp = ros::Time::now();\n\t\t\tpcl_msg.height = 1;\n\t\t\tpcl_msg.width = map_cloud->size();\n\t\t\tpcl_msg.is_dense = false;\n\t\t\tpcl_msg.points.resize(pcl_msg.width * pcl_msg.height);\n\n\t\t\tfor (int i = 0; i < map_cloud->size(); i++) {\n\t\t\t\tpcl_msg.points[i].x = map_cloud->points[i].x;\n\t\t\t\tpcl_msg.points[i].y = map_cloud->points[i].y;\n\t\t\t\tpcl_msg.points[i].z = map_cloud->points[i].z;\n\t\t\t}\n\t\t\tglobal_pcl_pub.publish(pcl_msg);\n\t\t}\n\t\tif (inflate_pcl_pub_flag) {\n\t\t\tpcl::PointCloud<pcl::PointXYZ> pcl_msg;\n\t\t\tpcl_msg.header.frame_id = \"world\";\n\t\t\tpcl_msg.header.stamp = ros::Time::now();\n\t\t\tpcl_msg.height = 1;\n\t\t\tpcl_msg.width = inflate_map_cloud->size();\n\t\t\tpcl_msg.is_dense = false;\n\t\t\tpcl_msg.points.resize(pcl_msg.width * pcl_msg.height);\n\n\t\t\tfor (int i = 0; i < inflate_map_cloud->size(); i++) {\n\t\t\t\tpcl_msg.points[i].x = inflate_map_cloud->points[i].x;\n\t\t\t\tpcl_msg.points[i].y = inflate_map_cloud->points[i].y;\n\t\t\t\tpcl_msg.points[i].z = inflate_map_cloud->points[i].z;\n\t\t\t}\n\t\t\tinflate_pcl_pub.publish(pcl_msg);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.20492930125835}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odometry_ready) {\n\t\tsensor_ready = true;\n\t}\n\n\t// Update the map with the latest point cloud data\n\tif (sensor_ready) {\n\t\tsensor_ready = false;\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*msg, *cloud);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\t\tsor.setInputCloud(cloud);\n\t\tsor.setLeafSize(0.2, 0.2, 0.2);\n\t\tsor.filter(*cloud_filtered);\n\t\tif (cloud_filtered->size() > 0) {\n\t\t\tif (Astar_ptr->Occupy_map_ptr->map_update_lpcl(cloud_filtered)) {\n\t\t\t\tROS_INFO(\"Map updated\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.35034683768095}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t/TODO: add check for if the robot is in a stance phase\n\tif(in_gazebo_)\n\t{\n\t\treturn;\n\t}\n\n\tif(body_controller_.poseCommand.position.x == 0.0 && body_controller_.poseCommand.position.y == 0.0 && body_controller_.poseCommand.position.z == 0.0)\n\t{\n\t\treturn;\n\t}\n\n\t//Calculate target foot positions based on the desired pose\n\tbase_.calculateTargetFootPositions(body_controller_.poseCommand);\n\n\t//Compute velocity commands for the legs and perform inverse kinematics to determine target joint positions\n\tbase_.computeLegVelocities();\n\tbase_.inverseKinematics();\n\n\t//Publish foot contact information and joint positions\n\tpublishFootContacts_(base_.legs[0]->contact_state);\n\tpublishJoints_(base_.legs[0]->target_joints);\n}", "CodeBleu_score": 38.052565746196365}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t/Get desired pose from the body controller\n\tbody_controller_.update(ros::Time::now());\n\tbody_controller_.computeTargetPose();\n\tbody_controller_.computeTargetFootPositions();\n\tbody_controller_.computeTargetJointPositions();\n\n\t//Compute velocity commands for the legs\n\tleg_controller_.computeVelocityCommands(body_controller_.targetFootPositions());\n\n\t//Compute target joint positions for the legs\n\tkinematics_.computeTargetJointPositions(leg_controller_.velocityCommand);\n\n\t//Publish joints and foot contacts\n\tpublishJoints_(kinematics_.targetJointPositions);\n\tpublishFootContacts_(kinematics_.footContacts);\n}", "CodeBleu_score": 41.086533323016695}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tf(in_gazebo_)\n\t{\n\t\treturn;\n\t}\n\n\tif(body_controller_.is_moving())\n\t{\n\t\tbody_controller_.update();\n\t\tbody_controller_.computeTargetFootPositions();\n\t\tbody_controller_.computeTargetJointPositions();\n\t}\n\n\tfloat target_joints[12];\n\tfor(size_t i = 0; i < 12; i++)\n\t{\n\t\ttarget_joints[i] = body_controller_.joint_positions[i];\n\t}\n\n\tpublishJoints_(target_joints);\n\tpublishFootContacts_(body_controller_.foot_contacts);\n}", "CodeBleu_score": 47.872585407097276}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\t// Create a ContactsStamped message\n\t\tgeometry_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = \"base_link\";\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tgeometry_msgs::Contact contact;\n\t\t\tcontact.header.stamp = ros::Time::now();\n\t\t\tcontact.header.frame_id = \"base_link\";\n\t\t\tcontact.contact_point.normal_force.x = 0.0;\n\t\t\tcontact.contact_point.normal_force.y = 0.0;\n\t\t\tcontact.contact_point.normal_force.z = 0.0;\n\t\t\tcontact.contact_point.position.x = 0.0;\n\t\t\tcontact.contact_point.position.y = 0.0;\n\t\t\tcontact.contact_point.position.z = 0.0;\n\t\t\tcontact.contact_normal.x = 0.0;\n\t\t\tcontact.contact_normal.y = 0.0;\n\t\t\tcontact.contact_normal.z = 0.0;\n\t\t\tcontact.wrench.force.x = 0.0;\n\t\t\tcontact.wrench.force.y = 0.0;\n\t\t\tcontact.wrench.force.z = 0.0;\n\t\t\tcontact.wrench.torque.x = 0.0;\n\t\t\tcontact.wrench.torque.y = 0.0;\n\t\t\tcontact.wrench.torque.z = 0.0;\n\t\t\tcontact.surface_index = i;\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\tcontact.contact_state = geometry_msgs::ContactState::CONTACT;\n\t\t\t} else {\n\t\t\t\tcontact.contact_state = geometry_msgs::ContactState::NO_CONTACT;\n\t\t\t}\n\t\t\tcontacts_msg.contacts.push_back(contact);\n\t\t}\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 41.55098986546918}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\t// Create a ContactsStamped message\n\tgeometry_msgs::ContactsStamped contacts_msg;\n\tcontacts_msg.header.stamp = ros::Time::now();\n\tcontacts_msg.header.frame_id = \"base_link\";\n\n\t// Populate the message with the current gait phase of each leg\n\tfor (int i = 0; i < 4; i++) {\n\t\tgeometry_msgs::Contact contact;\n\t\tcontact.header.stamp = ros::Time::now();\n\t\tcontact.header.frame_id = \"base_link\";\n\t\tcontact.contact_normal.y = 0;\n\t\tcontact.contact_normal.z = 0;\n\t\tcontact.contact_wrench.force.x = 0;\n\t\tcontact.contact_wrench.force.y = 0;\n\t\tcontact.contact_wrench.force.z = 0;\n\t\tcontact.contact_wrench.torque.x = 0;\n\t\tcontact.contact_wrench.torque.y = 0;\n\t\tcontact.contact_wrench.torque.z = 0;\n\t\tif (foot_contacts[i]) {\n\t\t\tcontact.contact_point.x = 0;\n\t\t\tcontact.contact_point.y = 0;\n\t\t\tcontact.contact_point.z = 0.005;\n\t\t}\n\t\telse {\n\t\t\tcontact.contact_point.x = 0;\n\t\t\tcontact.contact_point.y = 0;\n\t\t\tcontact.contact_point.z = 0;\n\t\t}\n\t\tcontacts_msg.contacts.push_back(contact);\n\t}\n\n\t// Publish the message\n\tfoot_contacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 49.62282823120944}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t", "CodeBleu_score": 3.1254227762308044}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a message to send to the joint_trajectory topic\n\tmsg = JointTrajectory()\n\tmsg.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6', 'joint7']\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.header.frame_id = 'base_link'\n\n\t# Create a joint trajectory point\n\tpoint = JointTrajectoryPoint()\n\tpoint.positions = joints.position\n\tpoint.velocities = [0.0] * 7\n\tpoint.accelerations = [0.0] * 7\n\tpoint.time_from_start = rospy.Duration(1.0)\n\tmsg.points.append(point)\n\n\t# Publish the message\n\tself.joint_trajectory_pub.publish(msg)\n}", "CodeBleu_score": 41.098106771080566}, {"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a minimal joints message\n\tmin_joints = JointState()\n\tmin_joints.header.stamp = rospy.Time.now()\n\tmin_joints.name = [\"shoulder_pan_joint\", \"shoulder_lift_joint\", \"upperarm_roll_joint\", \"elbow_flex_joint\", \"forearm_roll_joint\", \"wrist_flex_joint\", \"wrist_roll_joint\"]\n\tmin_joints.position = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6]]\n\tself.joints_pub.publish(min_joints)\n\n\t# Create a joint trajectory message\n\ttraj_joints = JointTrajectory()\n\ttraj_joints.header.stamp = rospy.Time.now()\n\ttraj_joints.joint_names = [\"shoulder_pan_joint\", \"shoulder_lift_joint\", \"upperarm_roll_joint\", \"elbow_flex_joint\", \"forearm_roll_joint\", \"wrist_flex_joint\", \"wrist_roll_joint\"]\n\ttraj_joints.points.append(JointTrajectoryPoint())\n\ttraj_joints.points[0].positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6]]\n\ttraj_joints.points[0].time_from_start = rospy.Duration(0.5)\n\tself.traj_pub.publish(traj_joints)\n}", "CodeBleu_score": 37.721788762526955}, {"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a minimal joints message with the first 12 joint positions\n\tmin_joints = JointState()\n\tmin_joints.name = self.joint_names\n\tmin_joints.position = joints.position[0:12]\n\n\t# Publish the minimal joints message\n\tself.joint_pub.publish(min_joints)\n\n\t# Create a joint trajectory message with the same positions and a specified duration\n\ttraj = JointTrajectory()\n\ttraj.joint_names = self.joint_names\n\ttraj.points.append(JointTrajectoryPoint(positions=joints.position[0:12], time_from_start=Duration(secs=1)))\n\n\t# Publish the joint trajectory message\n\tself.traj_pub.publish(traj)\n}", "CodeBleu_score": 39.90771706051645}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (unsigned int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision = _msg->contact(i).collision1;\n\t\tstd::vector<std::string> tokens;\n\t\tboost::split(tokens, collision, boost::is_any_of(\" \"));\n\t\tstd::string link = tokens[0];\n\t\tif (link == foot_links_[0] || link == foot_links_[1]) {\n\t\t\tfoot_contact_[0] = true;\n\t\t\tfoot_contact_[1] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.92366538608498}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision_string = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> split_string;\n\t\tboost::split(split_string, collision_string, boost::is_any_of(\"/\"));\n\t\tif (split_string.size() == 2) {\n\t\t\tif (split_string[0].compare(\"foot_left\") == 0) {\n\t\t\t\tfoot_left_contact_ = true;\n\t\t\t} else if (split_string[0].compare(\"foot_right\") == 0) {\n\t\t\t\tfoot_right_contact_ = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.271325925955814}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (unsigned int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision = _msg->contact(i).collision1;\n\t\tif (collision.find(\"r_foot_link\")!= std::string::npos) {\n\t\t\tr_foot_contact = true;\n\t\t} else if (collision.find(\"l_foot_link\")!= std::string::npos) {\n\t\t\tl_foot_contact = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 32.61254065262359}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust_body;\n  thrust_body = vehicle_parameters_.rotor_configuration_.rotors[0].thrust_direction * acceleration.dot(vehicle_parameters_.rotor_configuration_.rotors[0].thrust_direction);\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d rotor_velocities_body;\n  rotor_velocities_body = thrust_body + angular_acceleration;\n\n  // Ensure non-negative values.\n  rotor_velocities_body = rotor_velocities_body.cwiseMax(Eigen::Vector3d::Zero());\n\n  // Take the square root of each component.\n  rotor_velocities_body.array().sqrt();\n\n  // Multiply by predefined matrix.\n  *rotor_velocities = vehicle_parameters_.rotor_configuration_.rotors[0].rotor_matrix * rotor_velocities_body;\n}", "CodeBleu_score": 46.421941369032076}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//  assert(vehicle_parameters_.rotor_configuration_.rotors.size() == rotor_velocities->size());\n//\n//  if (!is_active_) {\n//    rotor_velocities->setZero();\n//    return;\n//  }\n//\n//  Eigen::Vector3d acceleration;\n//  ComputeDesiredAcceleration(&acceleration);\n//\n//  Eigen::Vector3d angular_acceleration;\n//  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n//\n//  Eigen::Vector3d thrust = acceleration.dot(vehicle_parameters_.rotor_configuration_.rotors[0].axis_b_B)\n//                          + angular_acceleration.dot(vehicle_parameters_.rotor_configuration_.rotors[0].axis_b_B);\n//\n//  thrust = thrust.cwiseMax(Eigen::Vector3d::Zero());\n//\n//  Eigen::Matrix3d rotor_velocities_matrix;\n//  rotor_velocities_matrix << 0, 0, thrust[0],\n//                             0, 0, thrust[1],\n//                             0, 0, thrust[2];\n//\n//  rotor_velocities->resize(rotor_velocities->size());\n//  rotor_velocities->setZero();\n//  rotor_velocities->segment(0, 3) = rotor_velocities_matrix.col(2).cwiseSqrt();\n//  rotor_velocities->segment(3, 3) = rotor_velocities_matrix.col(1).cwiseSqrt();\n//  rotor_velocities->segment(6, 3) = rotor_velocities_matrix.col(0).cwiseSqrt();\n}", "CodeBleu_score": 3.0243722721573207}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n\tEigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity;\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d desired_velocity;\n\n\tdesired_acceleration = (position_error.cwiseProduct(position_gain_) + velocity_error.cwiseProduct(velocity_gain_)) / vehicle_mass_ + gravity_ + command_acceleration_;\n\tdesired_velocity = odometry_.velocity + desired_acceleration * dt_;\n\n\tacceleration->x() = desired_acceleration.x();\n\tacceleration->y() = desired_acceleration.y();\n\tacceleration->z() = desired_acceleration.z();\n}", "CodeBleu_score": 45.284198009198306}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error = odometry_.position - command_trajectory_.position(time_index_);\n\tEigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity(time_index_);\n\tEigen::Vector3d desired_acceleration;\n\n\t// Compute the desired acceleration using the position and velocity errors and the gains.\n\tdesired_acceleration = (position_gain_ * position_error) + (velocity_gain_ * velocity_error);\n\n\t// Adjust the desired acceleration for vehicle mass, gravity, and the commanded acceleration.\n\tdesired_acceleration = (desired_acceleration / mass_) + gravity_ + (command_trajectory_.acceleration(time_index_) / mass_);\n\n\t// Convert the desired acceleration from the world frame to the vehicle's frame.\n\t*acceleration = odometry_.orientation.toRotationMatrix() * desired_acceleration;\n}", "CodeBleu_score": 47.2780988754477}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error, velocity_error;\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d gravity_vector;\n\tEigen::Vector3d commanded_acceleration;\n\tEigen::Matrix3d odometry_orientation;\n\tEigen::Vector3d velocity_in_world;\n\n\t// Calculate position error\n\tposition_error = odometry_.position - command_trajectory_.position;\n\n\t// Calculate velocity error\n\tvelocity_error = odometry_.velocity - command_trajectory_.velocity;\n\n\t// Transform velocity to world frame\n\tvelocity_in_world = odometry_.orientation.toRotationMatrix() * velocity_error;\n\n\t// Calculate desired acceleration\n\tgravity_vector << 0, 0, -9.81;\n\tcommanded_acceleration = command_trajectory_.acceleration;\n\tdesired_acceleration = commanded_acceleration + (velocity_in_world.cwiseProduct(velocity_gains_) - gravity_vector.cwiseProduct(mass_ * gravity_gains_)) / mass_;\n\n\t// Assign the desired acceleration to the output variable\n\t*acceleration = desired_acceleration;\n}", "CodeBleu_score": 55.76657666338636}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// resize the rotor velocities vector\n\trotor_velocities->resize(rotor_velocities_->size());\n\trotor_velocities->setConstant(1.0);\n\n\t// compute desired angular acceleration\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\t// combine desired angular acceleration and thrust reference\n\tEigen::Vector3d rotor_velocities_des(Eigen::Vector3d::Zero());\n\trotor_velocities_des[2] = control_attitude_thrust_reference_(2);\n\tEigen::Vector3d rotor_velocities_error = rotor_velocities_des - angular_acceleration;\n\n\t// compute rotor velocities\n\t*rotor_velocities = rotor_velocities_error.cwiseProduct(rotor_velocities_->cwiseSqrt());\n}", "CodeBleu_score": 49.98964048002373}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\nrotor_velocities->resize(rotors_.size());\nrotor_velocities->setConstant(1);\n\nEigen::Vector3d angular_acceleration_thrust;\nComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\nEigen::Vector3d rotor_velocities_thrust(Eigen::Vector3d::Zero());\nrotor_velocities_thrust[2] = thrust_reference_;\n\nEigen::Vector3d rotor_velocities_angular_acceleration = angular_acceleration_thrust.cwiseSqrt();\nEigen::Vector3d rotor_velocities_angular_rate = angular_rate_.cwiseSqrt();\n\nrotor_velocities->head(3) = rotor_velocities_thrust;\nrotor_velocities->tail(3) = rotor_velocities_angular_acceleration;\nrotor_velocities->tail(3) = rotor_velocities_angular_rate;\n}", "CodeBleu_score": 51.839635050306185}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == rotors_.size());\n\n\t// get desired angular acceleration\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\t// combine desired angular acceleration with thrust reference\n\tEigen::Vector3d angular_acceleration_thrust(angular_acceleration);\n\tangular_acceleration_thrust.block<3, 1>(0, 0) += thrust_reference_;\n\n\t// ensure the rotor velocities are at least one\n\tEigen::Vector3d rotor_velocities_des = angular_acceleration_thrust.cwiseMax(Eigen::Vector3d::Ones());\n\n\t// take the square root of each component\n\trotor_velocities_des.array().sqrt();\n\n\t// resize the rotor velocities vector\n\trotor_velocities->resize(rotors_.size());\n\t*rotor_velocities = rotor_velocities_des;\n}", "CodeBleu_score": 50.880746066299984}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    try:\n        start_idx = self.get_next_index(start_time)\n        end_idx = self.get_next_index(end_time)\n        copied_obj = copy.deepcopy(self)\n        copied_obj.__setattr__('time', self.time[start_idx:end_idx])\n        copied_obj.__setattr__('value', self.value[start_idx:end_idx])\n        return copied_obj\n    except Exception, e:\n        raise e\n\n", "CodeBleu_score": 53.73220493913552}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_idx = self.get_next_index(start_time)\n    end_idx = self.get_next_index(end_time)\n    # make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n    # slice the data\n    copied_obj.time = copied_obj.time[start_idx:end_idx]\n    copied_obj.data = copied_obj.data[start_idx:end_idx]\n    return copied_obj", "CodeBleu_score": 31.265611306393655}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Get the indices of the start and end times\n    start_idx = self.get_next_index(start_time)\n    end_idx = self.get_next_index(end_time)\n    # Create a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n    # Slice each attribute of the copied object\n    for attr in self.__dict__:\n        if attr in ['time', 'data']:\n            continue\n        else:\n            copied_obj.__dict__[attr] = copied_obj.__dict__[attr][start_idx:end_idx]\n    return copied_obj", "CodeBleu_score": 36.51150031183284}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    point = Point(waypoint_msg.pose.position.x, waypoint_msg.pose.position.y, waypoint_msg.pose.position.z)\n    yaw = euler_from_quaternion([waypoint_msg.pose.orientation.x, waypoint_msg.pose.orientation.y, waypoint_msg.pose.orientation.z, waypoint_msg.pose.orientation.w])[2]\n    if self.last_point is None:\n        self.last_point = point\n        self.last_yaw = yaw\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n    else:\n        if not self.last_point.is_equal(point, self.tolerance) or not self.last_yaw == yaw:\n            self.append_point(point)\n            self.append_yaw(yaw)\n            self.append_times(msg_time, bag_time)\n            self.last_point = point\n            self.last_yaw = yaw\n\n", "CodeBleu_score": 29.179754371447196}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the waypoint message\n    position = waypoint_msg.pose.position\n    orientation = waypoint_msg.pose.orientation\n    # Convert the orientation to Euler angles\n    euler = euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    yaw = euler[2]\n    # Create a Point object with the position and yaw\n    point = Point(position.x, position.y, position.z, yaw)\n    # Check if the current waypoint is different from the last one\n    if not (self.last_point == point):\n        # Append the point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n        # Update the last point\n        self.last_point = point\n\n", "CodeBleu_score": 22.920579508960984}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if waypoint_msg.position.x!= self.x[-1] or waypoint_msg.position.y!= self.y[-1] or waypoint_msg.position.z!= self.z[-1] or waypoint_msg.rotation.yaw!= self.yaw[-1]:\n        self.x = numpy.append(self.x, waypoint_msg.position.x)\n        self.y = numpy.append(self.y, waypoint_msg.position.y)\n        self.z = numpy.append(self.z, waypoint_msg.position.z)\n        self.yaw = numpy.append(self.yaw, waypoint_msg.rotation.yaw)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 15.120178319240496}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 29.730167152548358}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n        self.append_times(to_sec(msg.header.stamp), bag_time)\n\n", "CodeBleu_score": 33.57868585404737}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = self.to_sec(msg.header.stamp)\n    if topic == '/imu/data':\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n        self.append_times(msg_time, bag_time)\n    elif topic == '/imu/data_raw':\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n        self.append_times(msg_time, bag_time)\n    elif topic == '/imu/data_raw_unfiltered':\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n        self.append_times(msg_time, bag_time)\n    elif topic == '/imu/data_unfiltered':\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n        self.append_times(msg_time, bag_time)\n    elif topic == '/imu/data_unfiltered_raw':\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)", "CodeBleu_score": 28.25607615931799}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title\n    fig = pyplot.figure(figsize=(10, 6))\n    fig.suptitle(f\"Acceleration Data for {self.name}\")\n    # Create a subplot for each acceleration dataset\n    for i, dataset in enumerate(self.accelerations):\n        # Get the x, y, and z components of the acceleration data\n        x_accel = dataset[\"x\"]\n        y_accel = dataset[\"y\"]\n        z_accel = dataset[\"z\"]\n        # Plot the x, y, and z components over time with different colors and labels\n        pyplot.subplot(3, 1, i + 1)\n        pyplot.plot(x_accel, label=\"x\")\n        pyplot.plot(y_accel, label=\"y\")\n        pyplot.plot(z_accel, label=\"z\")\n        pyplot.legend()\n        # Add labels for the x and y axes\n        pyplot.xlabel(\"Time (s)\")\n        pyplot.ylabel(\"Acceleration (m/s^2)\")\n    # Save the plot as a PNG file if saving plots is enabled\n    if self.save_plots:\n        # Construct a filename based on the prefix and optional suffix\n        filename = f\"{self.name}_accelerations{plot_suffix}.png\"\n        # Save the plot to the specified directory\n        pyplot.savefig(os.path.join(self.plot_dir, filename))\n    # Show the plot if saving plots is disabled\n    else:\n        pyplot.show()\n    # Clear the figure and subplots\n    pyplot.clf()\n    pyplot.cla()\n    pyplot.close()\n", "CodeBleu_score": 36.74060877396269}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration Data\")\n    ax_x = fig.add_subplot(3, 1, 1)\n    ax_x.plot(self.accel_x, color=\"red\", label=\"x-axis\")\n    ax_y = fig.add_subplot(3, 1, 2)\n    ax_y.plot(self.accel_y, color=\"green\", label=\"y-axis\")\n    ax_z = fig.add_subplot(3, 1, 3)\n    ax_z.plot(self.accel_z, color=\"blue\", label=\"z-axis\")\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.legend()\n    pyplot.xlabel(\"Time (s)\")\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        pyplot.savefig(self.plot_prefix + \"_accel\" + plot_suffix + \".png\")\n    pyplot.figure()\n", "CodeBleu_score": 33.56344025978385}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    for i, accel in enumerate(self.accelerations):\n        ax = fig.add_subplot(3, 1, i+1)\n        ax.plot(accel.x, label=\"x\")\n        ax.plot(accel.y, label=\"y\")\n        ax.plot(accel.z, label=\"z\")\n        ax.set_ylabel(\"Acceleration (g)\")\n        ax.set_xlabel(\"Time (s)\")\n        ax.legend()\n    if self.save_plots:\n        filename = self.filename_prefix + \"_accelerations\"\n        if plot_suffix:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        pyplot.savefig(filename)\n    pyplot.show()\n    return fig\n", "CodeBleu_score": 44.185781230883094}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    for i, index_one in enumerate(pose_indeces):\n        for index_two in pose_indeces[i + 1:]:\n            compare_two_xyz(self.poses[index_one].position, self.poses[index_two].position)\n\n", "CodeBleu_score": 27.317710758922047}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement this function\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = settling_time + start_time\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 65.75875208761735}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if data is null and return if it is.\n  if (!data) {\n    return;\n  }\n// Calculate the multiplier based on camera parameters.\n  const float multiplier =\n      (this->dist * this->dist) / (this->dist * this->dist + 1.0);\n// Map the data to an Eigen vector.\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n// Compute the RMS noise and the noise values.\n  const float rms_noise =\n      std::sqrt(std::min(data_vector_map * 1000.0).array().square().mean());\n  const float noise = rms_noise * multiplier;\n// For each pixel, it adds noise if the pixel value is in range, otherwise it\n// sets the pixel to a bad point value.\n  for (int i = 0; i < width * height; i++) {\n    if (InRange(data_vector_map(i))) {\n      data_vector_map(i) += noise * noise;\n    } else {\n      data_vector_map(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 50.80440214752046}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if data is null\nif (data == NULL) {\nreturn;\n}\n\n// Calculate multiplier based on camera parameters\nfloat multiplier = this->dist / this->max_depth;\n\n// Map data to Eigen vector\nEigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> data_vector_map(data, height, width);\n\n// Compute RMS noise\nfloat rms_noise = this->noise * sqrtf(multiplier);\n\n// Compute noise values\nfloat noise_values[4] = {0.0f, 0.0f, 0.0f, this->bad_point_value};\n\n// Apply noise\nfor (uint32_t i = 0; i < height; i++) {\nfor (uint32_t j = 0; j < width; j++) {\nif (InRange(data_vector_map(i, j))) {\ndata_vector_map(i, j) +=\n(noise_values[0] +\nnoise_values[1] *\n(rand() / (float)RAND_MAX) -\nnoise_values[2]) *\nrms_noise;\n} else {\ndata_vector_map(i, j) = this->bad_point_value;\n}\n}\n}\n}", "CodeBleu_score": 46.20118848996294}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if data pointer is null\n  if (data == nullptr) {\n    return;\n  }\n\n// Calculate multiplier\n  const float multiplier = this->depth_multiplier;\n\n// Create Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n// Calculate RMS noise\n  const float rms_noise = this->CalculateRmsNoise(data_vector_map);\n\n// Calculate noise values\n  const float noise = this->CalculateNoise(rms_noise, multiplier);\n\n// Add noise to data if in range\n  for (uint32_t i = 0; i < data_vector_map.size(); i++) {\n    if (this->InRange(data_vector_map[i])) {\n      data_vector_map[i] += noise;\n    } else {\n      data_vector_map[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 50.073018502699874}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time and convert it to ROS time.\n\tros::Time ros_time = ros::Time::now();\n\n\t// Write the trajectory message to a bag file using the specified namespace and waypoint topic.\n\tbag_.write(trajectory_msg->header.frame_id + \"/waypoints\", ros_time, trajectory_msg);\n}", "CodeBleu_score": 38.30380454321842}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\tros::Time current_time = ros::Time::now();\n\ttrajectory_msg->header.stamp = current_time;\n\tbag_.write(waypoint_topic_, current_time, *trajectory_msg);\n}", "CodeBleu_score": 40.87320196211442}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time and convert it to ROS time.\n\tros::Time ros_time = ros::Time::now();\n\t// Write the trajectory message to the bag file using the specified namespace and waypoint topic.\n\tbag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 35.61921098295161}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time\n\tros::Time ros_now = ros::Time::now();\n\tros_now += ros::Duration(now.Double());\n\n\t// Prepare message\n\tsensor_msgs::JointState rot_velocities_msg;\n\trot_velocities_msg.header.stamp = ros_now;\n\trot_velocities_msg.header.frame_id = \"world\";\n\n\t// Iterate through the motor joints\n\tfor (auto m : motor_joints_) {\n\t\t// Calculate slowed down rotational velocity\n\t\tdouble rot_velocity = m->second->GetVelocity();\n\t\trot_velocity *= slow_down_factor_;\n\n\t\t// Assign rotational velocity to message\n\t\trot_velocities_msg.angular_velocities.push_back(rot_velocity);\n\t}\n\n\t// Write message to bag file\n\tbag_.write(namespace_ + \"/\" + topic_ + \"/rot_velocities\", ros_now, rot_velocities_msg);\n}", "CodeBleu_score": 46.16795229757623}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\tstd_msgs::Float64MultiArray rot_velocities_msg;\n\trot_velocities_msg.header.stamp = ros_now;\n\trot_velocities_msg.header.frame_id = \"world\";\n\n\tfor (std::map<std::string, boost::shared_ptr<gazebo::physics::Joint> >::const_iterator m = motor_joints_.begin(); m!= motor_joints_.end(); ++m) {\n\t\tdouble rot_vel = m->second->GetVelocity(0);\n\t\trot_vel = rot_vel * slowdown_factor_;\n\t\trot_velocities_msg.data.push_back(rot_vel);\n\t}\n\n\trot_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 52.60919688472655}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time\n\tros::Time ros_time = ros::Time::now();\n\tros_time -= ros_time.sec;\n\tros_time += now.sec;\n\tros_time += now.nsec * 1e-9;\n\n\t// Prepare message for actuator velocities\n\tsensor_msgs::JointState rot_velocities_msg;\n\trot_velocities_msg.header.stamp = ros_time;\n\trot_velocities_msg.name.resize(motor_joints_.size());\n\trot_velocities_msg.velocity.resize(motor_joints_.size());\n\trot_velocities_msg.effort.resize(motor_joints_.size());\n\n\t// Iterate through the motor joints\n\tfor (std::map<std::string, boost::shared_ptr<Motor> >::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); ++m) {\n\t\t// Calculate slowed-down rotational velocity\n\t\tdouble rot_vel = m->second->GetVelocity();\n\t\trot_vel *= slowdown_factor_;\n\n\t\t// Assign rotational velocity to message\n\t\trot_velocities_msg.name[m->second->GetIndex()] = m->first;\n\t\trot_velocities_msg.velocity[m->second->GetIndex()] = rot_vel;\n\t\trot_velocities_msg.effort[m->second->GetIndex()] = m->second->GetEffort();\n\t}\n\n\t// Write message to bag file\n\tbag_->write(namespace_ + \"/actuator_velocities\", ros_time, rot_velocities_msg);\n}", "CodeBleu_score": 54.14666069695899}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t//  if (debug_printing_) {\n//    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n//  }\n\n  // Convert roll, pitch, and yaw rate to control surface angles\n  double roll_angle =\n      NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll());\n  double pitch_angle =\n      NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate =\n      NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set throttle from thrust\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n  double throttle = thrust / (max_thrust_ + 1e-6);\n\n  // Set control surface angles\n  aileron_->SetAngle(roll_angle);\n  elevator_->SetAngle(pitch_angle);\n  rudder_->SetAngle(yaw_rate);\n  throttle_controller_->SetThrottle(throttle);\n}", "CodeBleu_score": 44.20156036518592}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef GAZEBO_FW_DYNAMICS_PLUGIN_DEBUG\n  ROS_DEBUG(\"RollPitchYawrateThrustCallback\");\n#endif\n  if (roll_pitch_yawrate_thrust_msg) {\n    roll_pitch_yawrate_thrust_msg->roll =\n        NormalizedInputToAngle(aileron_surface_, roll_pitch_yawrate_thrust_msg->roll);\n    roll_pitch_yawrate_thrust_msg->pitch =\n        NormalizedInputToAngle(elevator_surface_, roll_pitch_yawrate_thrust_msg->pitch);\n    roll_pitch_yawrate_thrust_msg->yaw_rate =\n        NormalizedInputToAngle(rudder_surface_, roll_pitch_yawrate_thrust_msg->yaw_rate);\n    roll_pitch_yawrate_thrust_msg->thrust = roll_pitch_yawrate_thrust_msg->thrust.x;\n  }\n}", "CodeBleu_score": 38.50518804570443}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (this->debug_printing_enabled) {\n    ROS_INFO(\"RollPitchYawrateThrustCallback called\");\n  }\n  double roll_angle =\n      this->NormalizedInputToAngle(this->aileron_control_surface,\n                                   roll_pitch_yawrate_thrust_msg->roll());\n  double pitch_angle =\n      this->NormalizedInputToAngle(this->elevator_control_surface,\n                                   roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate =\n      this->NormalizedInputToAngle(this->rudder_control_surface,\n                                   roll_pitch_yawrate_thrust_msg->yaw_rate());\n  this->SetControlSurfaceAngles(roll_angle, pitch_angle, yaw_rate);\n  this->SetThrottle(roll_pitch_yawrate_thrust_msg->thrust().x);\n}", "CodeBleu_score": 42.2950274565977}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  gzdbg << \"pollForMAVLinkMessages\n\";\n  struct timeval tv;\n  tv.tv_sec = 0;\n  tv.tv_usec = _timeoutMs * 1000;\n\n  fd_set rfds;\n  FD_ZERO(&rfds);\n  FD_SET(_fd, &rfds);\n\n  int retval = select(_fd + 1, &rfds, nullptr, nullptr, &tv);\n  if (retval == -1) {\n    gzerr << \"Error polling for MAVLink messages: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  if (retval > 0) {\n    if (FD_ISSET(_fd, &rfds)) {\n      uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n      ssize_t len = recv(_fd, buf, MAVLINK_MAX_PACKET_LEN, 0);\n\n      if (len > 0) {\n        mavlink_message_t msg;\n        mavlink_status_t status;\n\n        for (ssize_t i = 0; i < len; i++) {\n          if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n            handle_message(&msg);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 55.517843537033784}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  gzdbg << \"pollForMAVLinkMessages\n\";\n  // Poll for new data.\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n\n  int ret = select(_fd + 1, &fds, nullptr, nullptr, &timeout);\n\n  if (ret == 0) {\n    // Timeout.\n    return;\n  }\n\n  if (ret < 0) {\n    gzerr << \"Error in select\n\";\n    return;\n  }\n\n  // Read data.\n  uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n  ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n  if (len > 0) {\n    // Parse the buffer.\n    mavlink_message_t msg;\n    mavlink_status_t status;\n\n    for (uint8_t* buf = buffer; len > 0; buf += status.packet_rx_size) {\n      status.packet_rx_size = mavlink_parse_char(\n          _fd, *buf, &msg, &status);\n      len -= status.packet_rx_size;\n\n      if (status.packet_rx_size == 0) {\n        gzerr << \"Error parsing packet\n\";\n        continue;\n      }\n\n      // Forward to serial port if enabled.\n      if (serial_enabled_) {\n        send_mavlink_message(&msg, 0);\n      }\n\n      // Handle message.\n      handle_message(&msg);\n    }\n  }\n}", "CodeBleu_score": 52.628881113733364}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (is_open) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 66.96045621815311}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (is_open) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open = false;\n\t}\n}", "CodeBleu_score": 65.37171654100425}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (is_open) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open = false;\n\t}\n}", "CodeBleu_score": 65.37171654100425}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d(0.0, 0.0, 0.0)\n}", "CodeBleu_score": 4.5242510250805115}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->wind_data.at(i).at(0) * (this->wind_data.at(i+1).at(0) - this->wind_data.at(i).at(0)) + this->wind_data.at(i).at(0)),\n\t(this->wind_data.at(i).at(1) * (this->wind_data.at(i+1).at(1) - this->wind_data.at(i).at(1)) + this->wind_data.at(i).at(1)),\n\t(this->wind_data.at(i).at(2) * (this->wind_data.at(i+1).at(2) - this->wind_data.at(i).at(2)) + this->wind_data.at(i).at(2))\n}", "CodeBleu_score": 9.577510680684224}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\ttime = _time;\n\tif (looping) {\n\t\ttime = fmod(time, length);\n\t} else {\n\t\ttime = std::min(std::max(0.0, time), length);\n\t}\n\tUpdate();\n}", "CodeBleu_score": 21.551371450869972}, {"code": "void Animation::SetTime(double _time){\n\t\tif (time!= _time) {\n\t\tif (looping) {\n\t\t\ttime = _time - floor(_time / length) * length;\n\t\t} else {\n\t\t\ttime = std::clamp(_time, 0.0, length);\n\t\t}\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 30.62360936219769}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time < 0.0) {\n\t\t_time = 0.0;\n\t}\n\tif (_time > length) {\n\t\t_time = length;\n\t}\n\tif (looping) {\n\t\ttime = fmod(_time, length);\n\t} else {\n\t\ttime = _time;\n\t}\n\tif (time < 0.0) {\n\t\ttime += length;\n\t}\n\tif (time > length) {\n\t\ttime -= length;\n\t}\n\tif (time!= lastTime) {\n\t\tlastTime = time;\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 35.35406663305086}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.set_position_target_local_ned(target_raw_pose)\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 42.28375264806433}, {"code": "def hover(self)\n\t\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    target_pose = self.construct_target(self.current_position.x, self.current_position.y, self.current_position.z, 0, 0, 0, 0, 0, 0, self.current_yaw, 0)\n    self.set_target_position(target_pose)\n    print(\"Vehicle Type: %s", "CodeBleu_score": 18.983486195125334}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.set_position_target(target_raw_pose)\n    print(self.vehicle_type)\n    print(self.vehicle_id)\n    print(self.flight_mode)\n\n", "CodeBleu_score": 42.50480923380804}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    elif self.flight_mode == 'GUIDED':\n        self.flight_mode = 'AUTO'\n        return self.flightModeService.set_mode(self.flight_mode)\n    elif self.flight_mode == 'AUTO':\n        self.flight_mode = 'GUIDED'\n        return self.flightModeService.set_mode(self.flight_mode)\n    else:\n        return False\n\n", "CodeBleu_score": 41.09356616011986}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flightModeService(self.flight_mode)\n        if self.flight_mode == self.flight_mode:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": flight mode switch successful\")\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 44.26088597800874}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    elif self.flightModeService.set_mode(self.vehicle_type,self.vehicle_id,self.flight_mode) == 1:\n        self.flight_mode = self.flightModeService.get_mode(self.vehicle_type,self.vehicle_id)\n        print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode changed to \"+self.flight_mode)\n        return True\n    else:\n        print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode change failed\")\n        return False\n\n", "CodeBleu_score": 55.2681282731828}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, w=msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, w=msg.angular.z, frame='enu')\n    if self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)", "CodeBleu_score": 56.227525744121166}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 59.44720342529101}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x, y, z, w, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n", "CodeBleu_score": 32.74099126913727}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (self.current_position.x > x + 0.02) or (self.current_position.y > y + 0.02) or (self.current_position.z > z + 0.02) or (self.current_yaw > w + 0.005):\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        self.hover()\n    elif self.flight_mode!= 'HOVER':\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n\n", "CodeBleu_score": 50.59767809662635}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode == \"OFFBOARD\":\n        self.hover_flag = 1\n        self.flight_mode = \"HOVER\"\n        self.hover()\n    elif self.flight_mode == \"HOVER\":\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.offboard_mode()\n        else:\n            self.hover_flag = 1\n\n", "CodeBleu_score": 48.04549006864822}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        self.hover()\n    elif (self.hover_flag == 0 and self.flight_mode == 'HOVER'):\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n\n", "CodeBleu_score": 57.64679133645517}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = math.atan2(2 * (q.w * q.z + q.x * q.y), 1 - 2 * (q.y ** 2 + q.z ** 2))\n    else:\n        yaw = math.atan2(2 * (q[0] * q[2] + q[1] * q[3]), 1 - 2 * (q[1] ** 2 + q[2] ** 2))\n    return yaw\n\n\n\n\n", "CodeBleu_score": 38.64147040564615}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        yaw = Quaternion(q[0], q[1], q[2], q[3]).yaw\n    return yaw\n\n\n\n\n", "CodeBleu_score": 36.644194759173175}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw()\n", "CodeBleu_score": 19.828110469756748}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    self.send_set_position_target_local_ned(target_raw_pose)\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 48.24517576913431}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 0\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.send_set_position_target_local_ned(target_raw_pose)\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 28.731580579171112}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 1\n\n    target_raw_pose = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n\n    self.set_position_target_local_ned(target_raw_pose)\n\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 48.00010284090907}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":Failed to switch to \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 59.63355328769248}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService.switch_mode(self.vehicle_type, self.vehicle_id, self.flight_mode) == True:\n            self.flight_mode = self.flightModeService.get_flight_mode(self.vehicle_type, self.vehicle_id)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(\"Flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 50.81457383165857}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            self.flight_mode = self.flight_mode\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode + \" -> \" + self.flight_mode + \" failed.\")\n            return False\n\n", "CodeBleu_score": 52.59938981441701}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.end = False\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 64.48519352583516}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.stamp.secs == 0 and msg.header.stamp.nsecs == 0:\n        return\n    if msg.header.frame_id!= self.uav_id:\n        return\n    self.local_pose = msg\n    self.local_pose.pose.position.x -= self.takeoff_target_pose.position.x\n    self.local_pose.pose.position.y -= self.takeoff_target_pose.position.y\n    self.local_pose.pose.position.z -= self.takeoff_target_pose.position.z\n    self.local_pose.pose.orientation.x -= self.takeoff_target_pose.orientation.x\n    self.local_pose.pose.orientation.y -= self.takeoff_target_pose.orientation.y\n    self.local_pose.pose.orientation.z -= self.takeoff_target_pose.orientation.z\n    self.local_pose.pose.orientation.w -= self.takeoff_target_pose.orientation.w\n    self.local_pose.pose.position.x += self.hover_target_pose.position.x\n    self.local_pose.pose.position.y += self.hover_target_pose.position.y\n    self.local_pose.pose.position.z += self.hover_target_pose.position.z\n    self.local_pose.pose.orientation.x += self.hover_target_pose.orientation.x\n    self.local_pose.pose.orientation.y += self.hover_target_pose.orientation.y\n    self.local_pose.pose.orientation.z += self.hover_target_pose.orientation.z\n    self.local_pose.pose.orientation.w += self.hover_target_pose.orientation.w\n    self.local_pose.pose.position.x += self.takeoff_target_pose.position.x\n    self.local_pose.pose.position.y += self.takeoff_target_pose.position.y\n    self.local_pose.pose.position.z += self.takeoff_target_pose.position.z\n    self.local_pose.pose.orientation.x += self.takeoff_target_pose.orientation.x\n    self.local_pose.pose.orientation.y += self.", "CodeBleu_score": 15.723823360724662}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.index == self.id:\n        self.local_pose = msg.pose\n        self.global_pose = msg.pose\n        self.global_pose.position.x += self.bias_x\n        self.global_pose.position.y += self.bias_y\n        self.global_pose.position.z += self.bias_z\n        if self.takeoff_target_pose is None:\n            self.takeoff_target_pose = msg.pose\n        if self.hover_target_pose is None:\n            self.hover_target_pose = msg.pose\n        self.takeoff_target_pose.position.z = self.takeoff_height\n        self.hover_target_pose.position.z = self.hover_height\n\n", "CodeBleu_score": 22.815353195724796}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    #print(\"local_pose_callback\")\n    #print(msg)\n    #print(i)\n    #print(self.local_pose)\n    #print(self.takeoff_target_pose)\n    #print(self.hover_target_pose)\n    #print(self.global_pose)\n    #print(self.uav_id)\n    #print(self.uav_id == msg.header.seq)\n    #print(self.uav_id)\n    #print(msg.header.seq)\n    if self.uav_id == msg.header.seq:\n        self.local_pose = msg.pose\n        if self.takeoff_target_pose == None:\n            self.takeoff_target_pose = msg.pose\n        if self.hover_target_pose == None:\n            self.hover_target_pose = msg.pose\n        if self.global_pose == None:\n            self.global_pose = msg.pose\n        self.global_pose.position.x = self.global_pose.position.x + self.pose_bias[0]\n        self.global_pose.position.y = self.global_pose.position.y + self.pose_bias[1]\n        self.global_pose.position.z = self.global_pose.position.z + self.pose_bias[2]\n        #print(self.local_pose)\n        #print(self.takeoff_target_pose)\n        #print(self.hover_target_pose)\n        #print(self.global_pose)\n        #print(self.uav_id)\n        #print(msg.header.seq)\n        #print(self.uav_id == msg.header.seq)\n        #print(self.uav_id)\n        #print(msg.header.seq)\n        #print(self.local_pose)\n        #print(self.takeoff_target_pose)\n        #print(self.hover_target_pose)\n        #print(self.global_pose)\n        #print(self.uav_id)\n        #print(msg.header.seq)\n        #print(self.uav_id == msg.header.seq)\n        #print(self.uav_id)\n        #print(msg.header.seq)\n        #print(self.", "CodeBleu_score": 24.5134241499207}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == True:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.88263518862473}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"armed\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.7551094861517}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"armed\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.7551094861517}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    distances = np.zeros((orig_formation.shape[0], change_formation.shape[0]))\n    for i in range(orig_formation.shape[0]):\n        for j in range(change_formation.shape[0]):\n            distances[i, j] = int(np.linalg.norm(orig_formation[i] - change_formation[j]) - 50)\n    return distances", "CodeBleu_score": 20.216489897966703}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = int(np.linalg.norm(orig_formation[i] - change_formation[j]) - 50)\n    return dist_matrix\n", "CodeBleu_score": 24.26321589791494}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    distances = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distances[i][j] = int(np.linalg.norm(orig_formation[i] - change_formation[j]) - 50)\n    return distances\n", "CodeBleu_score": 26.8793107598724}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.match_right = [-1] * self.num_right\n    self.slack_right = [0] * self.num_right\n    self.label_left = [0] * self.num_left\n    self.label_right = [0] * self.num_right\n    self.visit_left = [False] * self.num_left\n    self.visit_right = [False] * self.num_right\n    for i in range(self.num_left):\n        self.label_left[i] = sum(self.adj_matrix[i])\n        self.label_right = [0] * self.num_right\n    for i in range(self.num_left):\n        self.find_path(i)\n    return self.match_right\n\n", "CodeBleu_score": 24.585692998037782}, {"code": "def KM(self)\n\t\n    self.label_left = numpy.zeros(self.num_uavs)\n    self.label_right = numpy.zeros(self.num_sensors)\n    self.slack_right = numpy.zeros(self.num_sensors)\n    self.visit_left = numpy.zeros(self.num_uavs, dtype=bool)\n    self.visit_right = numpy.zeros(self.num_sensors, dtype=bool)\n    self.match_right = numpy.full(self.num_sensors, -1, dtype=int)\n    for i in range(self.num_uavs):\n        self.find_path(i)\n        if not self.visit_right.all():\n            self.adjust_labels()\n    return self.match_right\n\n", "CodeBleu_score": 19.501161746793596}, {"code": "def KM(self)\n\t\n    for i in range(self.num_uavs):\n        self.label_left[i] = sum(self.adj_matrix[i])\n        self.slack_right[i] = float('inf')\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n        self.match_right[i] = -1\n    while True:\n        for i in range(self.num_uavs):\n            if self.match_right[i] == -1:\n                if self.find_path(i):\n                    break\n        else:\n            break\n        delta = float('inf')\n        for i in range(self.num_uavs):\n            if self.visit_right[i]:\n                delta = min(delta, self.slack_right[i])\n        for i in range(self.num_uavs):\n            self.label_left[i] -= delta\n            self.slack_right[i] -= delta\n        for i in range(self.num_uavs):\n            self.visit_right[i] = False\n    return self.match_right\n\n", "CodeBleu_score": 34.49567701177049}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n", "CodeBleu_score": 27.779830147695577}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    lower_yellow = np.uint8([20, 100, 100])\n    upper_yellow = np.uint8([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 26.74316161337376}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.uint8([15, 100, 100])\n    upper = np.uint8([35, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 34.68640587458452}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t(const int id, TagDescriptionContainer& descriptionContainer, bool printWarning = true) const {\n\t\tauto it = standalone_tag_descriptions_.find(id);\n\t\tif (it!= standalone_tag_descriptions_.end()) {\n\t\t\tdescriptionContainer = it->second;\n\t\t\treturn true;\n\t\t} else if (printWarning) {\n\t\t\tROS_WARN(\"Tag with ID %d not found in standalone_tag_descriptions_ map.\", id);\n\t\t}\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 49.8477360081289}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tconst int id {\n\t\ttag_id_\n\t};\n\tauto it {\n\t\tstandalone_tag_descriptions_.find(id)\n\t};\n\tif (it == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tROS_WARN_THROTTLE(1.0, \"TagDetector::findStandaloneTagDescription: No standalone tag description found for ID %d\", id);\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = it->second;\n\treturn true;\n}", "CodeBleu_score": 40.5603096312398}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}]}
