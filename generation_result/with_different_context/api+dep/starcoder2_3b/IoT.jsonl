{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\tuint8_t len;\n\n\tif (desc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tlen = desc->bLength;\n\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *)desc + len);\n\n\twhile (len < desc->wTotalLength) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tlen += next_desc->bLength;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *)next_desc + len);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 46.49971122715675}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t *end_ptr = desc_ptr + desc->bLength;\n\twhile (desc_ptr < end_ptr) {\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc_tmp = (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\tif (desc_tmp->bDescriptorType == desc_id) {\n\t\t\treturn desc_tmp;\n\t\t}\n\t\tdesc_ptr += desc_tmp->bLength;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 43.09767907382993}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\n\twhile (desc!= NULL) {\n\t\tdesc_len = desc->bLength;\n\t\tif (desc_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) (desc + desc_len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 39.429753250479145}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *ptr = (uint8_t *) udc_get_conf_desc();\n\tuint8_t *end = ptr + udc_get_conf_desc_len();\n\twhile (ptr < end) {\n\t\tif (ptr[0] == USB_DESC_INTERFACE) {\n\t\t\tif (ptr[1] == iface_num && ptr[2] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tptr += ptr[0] + 1;\n\t}\n\treturn false;\n}", "CodeBleu_score": 21.992869865363122}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *p_desc_ptr = udc_get_config_desc();\n\tuint8_t *p_desc_end = p_desc_ptr + udc_get_config_desc_len();\n\tuint8_t *p_iface_desc_ptr;\n\tuint8_t *p_iface_desc_end;\n\n\t/* Check if a valid configuration is present */\n\tif (p_desc_ptr == NULL || p_desc_ptr >= p_desc_end) {\n\t\treturn false;\n\t}\n\n\t/* Check if the interface number is within bounds */\n\tif (iface_num >= udc_get_config_desc_num_ifaces()) {\n\t\treturn false;\n\t}\n\n\t/* Iterate through the descriptors until a matching interface descriptor is found */\n\twhile (p_desc_ptr < p_desc_end) {\n\t\t/* Check if the descriptor is an interface descriptor */\n\t\tif (p_desc_ptr[0] == USB_DESC_TYPE_INTERFACE) {\n\t\t\t/* Check if the interface number and setting number match */\n\t\t\tif (p_desc_ptr[1] == iface_num && p_desc_ptr[2] == setting_num) {\n\t\t\t\t/* Found a matching interface descriptor, so return true */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t/* Advance to the next descriptor */\n\t\tp_desc_ptr += p_desc_ptr[0] & 0x0f;\n\t\tp_desc_ptr++;\n\t}\n\n\t/* No matching interface descriptor was found */\n\treturn false;\n}", "CodeBleu_score": 34.19317151033074}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_status;\n\tuint8_t ep_addr;\n\tuint8_t ep_type;\n\n\tep_addr = udd_g_ctrlreq.wIndex & 0x0F;\n\tep_type = (udd_g_ctrlreq.wIndex & 0x80) >> 7;\n\n\tif (udd_ep_is_halted(ep_addr, ep_type)) {\n\t\tep_status = UDD_EP_STATUS_HALTED;\n\t} else {\n\t\tep_status = UDD_EP_STATUS_NOT_HALTED;\n\t}\n\n\tudd_set_setup_payload(ep_status, 1);\n\treturn true;\n}", "CodeBleu_score": 32.11940500291445}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint16_t ep_num;\n\tuint16_t status;\n\tuint16_t len;\n\tep_num = UDC_GET_EP_NUM(req->wIndex);\n\tstatus = udd_ep_is_halted(ep_num);\n\tlen = sizeof(status);\n\tif (req->wLength!= len) {\n\t\treturn false;\n\t}\n\tudd_set_setup_payload((uint8_t *) &status, len);\n\treturn true;\n}", "CodeBleu_score": 40.20720702399525}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = UDC_SETUP_GET_INDEX(p_setup_req);\n\tuint8_t ep_dir = UDC_SETUP_GET_DIR(p_setup_req);\n\tuint8_t ep_status = 0;\n\tif (ep_num == 0) {\n\t\treturn false;\n\t}\n\tif (ep_dir == UDC_SETUP_DIR_IN) {\n\t\tep_status = (udd_ep_is_halted(ep_num)? 1 : 0);\n\t}\n\tp_response_payload = &ep_status;\n\treturn true;\n}", "CodeBleu_score": 26.612489716433572}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tuint8_t iface_alt_num;\n\n\t// Check if device is configured\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if interface number is valid\n\tif (0 == udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Get interface number\n\tiface_num = udc_setup_req.wIndex & 0xFF;\n\n\t// Get alternate setting number\n\tsetting_num = udc_setup_req.wValue & 0xFF;\n\n\t// Get alternate setting number\n\tiface_alt_num = udc_setup_req.wIndex >> 8;\n\n\t// Update interface descriptor to the default setting\n\tif (false == udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to the current alternate setting\n\tif (false == udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\treturn udc_udi_req(iface_num, iface_alt_num);\n}", "CodeBleu_score": 59.40881637346056}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tuint8_t ret;\n\n\t// Check if the device is in configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Get the interface number and alternate setting number from the SETUP request\n\tiface_num = udc_setup_req.wIndex & 0x00FF;\n\tsetting_num = udc_setup_req.wIndex >> 8;\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tret = udc_udi_handler->setup(&udc_setup_req);\n\n\t// Check the result of the handler's setup function\n\tif (ret!= UDI_OK) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 64.7917930697923}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tuint8_t res;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Get interface number and alternate setting number from SETUP request\n\tiface_num = udc_setup_req.wIndex & 0xFF;\n\tsetting_num = udc_setup_req.wValue & 0xFF;\n\n\t// Check if interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward SETUP request to UDI\n\tres = udi_api->setup(iface_num, setting_num);\n\n\t// Check if SETUP request was successful\n\tif (res!= UDI_OK) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 72.22760453061694}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t#if defined(UDI_MSC_ENABLE_EXT)\n  // If the external enable function is defined, it is called.\n  if (!UDI_MSC_ENABLE_EXT()) {\n    return false;\n  }\n#endif\n  // Reset the state of the MSC interface\n  udi_msc_state = UDI_MSC_STATE_DISABLED;\n  // Reset the number of LUNs\n  udi_msc_nb_lun = 0;\n  // Reset the LUN state\n  for (uint8_t i = 0; i < UDI_MSC_NB_LUN; i++) {\n    udi_msc_lun_state[i] = UDI_MSC_LUN_STATE_DISABLED;\n  }\n  // Retrieve the number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n  // If there is no LUN, return false\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n  // Unload the medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_nb_lun; i++) {\n    mem_unload(i);\n  }\n  // Wait for a CBW reception\n  udi_msc_cbw_wait();\n  // Start the MSC process\n  udi_msc_state = UDI_MSC_STATE_IDLE;\n  return true;\n}", "CodeBleu_score": 51.93478112199315}, {"code": "bool udi_msc_enable(void){\n\t#if UDI_MSC_ENABLE_EXT\n  // Check if the MSC is enabled\n  if (udi_msc_is_enabled()) {\n    return true;\n  }\n\n  // Initialize the MSC interface\n  if (!udi_msc_init()) {\n    return false;\n  }\n\n  // Retrieve the number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n\n  // Check if there is any LUN\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_nb_lun; i++) {\n    mem_unload(i);\n  }\n\n  // Wait for a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 50.98515096326568}, {"code": "bool udi_msc_enable(void){\n\t#if UDI_MSC_ENABLE_EXT\n  // Retrieve the number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n\n  // Check if there is at least one LUN\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t lun = 0; lun < udi_msc_nb_lun; lun++) {\n    mem_unload(lun);\n  }\n\n  // Wait for a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 46.068683326353145}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t/  if (ep == UDI_MSC_EP_IN) {\n//    // IN transfer\n//    if (status == UDD_EP_STATUS_SUCCESS) {\n//      // Success\n//      udi_msc_csw.dCSWDataResidue -= nb_sent;\n//      if (0 == udi_msc_csw.dCSWDataResidue) {\n//        // No more data to send\n//        udi_msc_sense_pass();\n//      } else {\n//        // Send CSW\n//        udi_msc_csw_send();\n//      }\n//    } else {\n//      // Error\n//      udi_msc_sense_fail(USB_CSW_STATUS_FAIL);\n//    }\n//  } else {\n//    // OUT transfer\n//    if (status == UDD_EP_STATUS_SUCCESS) {\n//      // Success\n//      udi_msc_csw.dCSWDataResidue -= nb_sent;\n//      if (0 == udi_msc_csw.dCSWDataResidue) {\n//        // No more data to receive\n//        udi_msc_sense_pass();\n//      } else {\n//        // Send CSW\n//        udi_msc_csw_send();\n//      }\n//    } else {\n//      // Error\n//      udi_msc_sense_fail(USB_CSW_STATUS_FAIL);\n//    }\n//  }\n}", "CodeBleu_score": 23.430584974559416}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDI_MSC_EP_IN!= 0)\n  if (ep == UDI_MSC_EP_IN) {\n    if (status == UDD_EP_TRANSFER_OK) {\n      udi_msc_cbw.dCBWDataTransferLength -= nb_sent;\n      udi_msc_csw.dCSWDataResidue -= nb_sent;\n      if (udi_msc_cbw.dCBWDataTransferLength == 0) {\n        udi_msc_csw_process();\n      }\n    } else {\n      udi_msc_csw_process();\n    }\n  }\n#endif\n#if (UDI_MSC_EP_OUT!= 0)\n  if (ep == UDI_MSC_EP_OUT) {\n    if (status == UDD_EP_TRANSFER_OK) {\n      udi_msc_cbw.dCBWDataTransferLength -= nb_sent;\n      udi_msc_csw.dCSWDataResidue -= nb_sent;\n      if (udi_msc_cbw.dCBWDataTransferLength == 0) {\n        udi_msc_csw_process();\n      }\n    } else {\n      udi_msc_csw_process();\n    }\n  }\n#endif\n}", "CodeBleu_score": 48.71339724975239}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t/  if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n//    if (status == UDD_EP_STATUS_OK) {\n//      udi_msc_csw.dCSWDataResidue -= nb_sent;\n//      if (udi_msc_csw.dCSWDataResidue == 0) {\n//        udi_msc_csw_process();\n//      }\n//    } else {\n//      udi_msc_sense_pass();\n//    }\n//  } else {\n//    if (status == UDD_EP_STATUS_OK) {\n//      udi_msc_csw.dCSWDataResidue -= nb_sent;\n//      if (udi_msc_csw.dCSWDataResidue == 0) {\n//        udi_msc_csw_process();\n//      }\n//    } else {\n//      udi_msc_sense_pass();\n//    }\n//  }\n}", "CodeBleu_score": 23.692324509647325}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t", "CodeBleu_score": 2.8494374924614037}, {"code": "static void udi_msc_csw_process(void){\n\t", "CodeBleu_score": 2.8494374924614037}, {"code": "static void udi_msc_csw_process(void){\n\t", "CodeBleu_score": 2.8494374924614037}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tUNUSED(b_enable);\n}", "CodeBleu_score": 18.81282499168744}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t", "CodeBleu_score": 10.31471527023918}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tUNUSED(b_enable);\n}", "CodeBleu_score": 18.81282499168744}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tbool handled = false;\n\tuint8_t request = usb_setup_packet.bmRequestType_and_request;\n\tuint8_t request_type = request & USB_SETUP_REQUEST_TYPE_MASK;\n\tuint8_t request_index = request & USB_SETUP_REQUEST_INDEX_MASK;\n\tif (request_type == USB_SETUP_REQUEST_TYPE_VENDOR) {\n\t\tif (request_index == 0x04) {\n\t\t\t// Handle vendor request 0x04: get Microsoft-compatible ID descriptor\n\t\t\tusb_setup_packet.wLength = sizeof(usb_udd_setup_type);\n\t\t\tusb_setup_packet.wLength_le = usb_setup_packet.wLength;\n\t\t\tusb_setup_packet.wLength_le_msb = 0;\n\t\t\tusb_setup_packet.wLength_le_msb_2 = 0;\n\t\t\thandled = true;\n\t\t} else if (request_index == 0x05) {\n\t\t\t// Handle vendor request 0x05: get extended properties descriptor\n\t\t\tusb_setup_packet.wLength = sizeof(usb_udd_extended_properties_type);\n\t\t\tusb_setup_packet.wLength_le = usb_setup_packet.wLength;\n\t\t\tusb_setup_packet.wLength_le_msb = 0;\n\t\t\tusb_setup_packet.wLength_le_msb_2 = 0;\n\t\t\thandled = true;\n\t\t}\n\t}\n\treturn handled;\n}", "CodeBleu_score": 22.34096475536872}, {"code": "bool usb_task_other_requests(void){\n\t\tbool success = false;\n\tswitch (usb_setup_packet.bmRequestType.Type) {\n\t\tcase 0x01:\n\t\t\tswitch (usb_setup_packet.bRequest) {\n\t\t\t\tcase 0x04:\n\t\t\t\t\tusb_setup_packet.wLength = 0x0002;\n\t\t\t\t\tusb_setup_packet.wIndex = 0x0000;\n\t\t\t\t\tusb_setup_packet.wValue = 0x0000;\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x05:\n\t\t\t\t\tusb_setup_packet.wLength = 0x0000;\n\t\t\t\t\tusb_setup_packet.wIndex = 0x0000;\n\t\t\t\t\tusb_setup_packet.wValue = 0x0000;\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn success;\n}", "CodeBleu_score": 18.654312577106104}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint8_t dummy = 0;\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(dummy);\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 44.07477029265179}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\twhile (nbyte--) {\n\t\t*buf++ = spiRec();\n\t}\n\t*buf = spiRec();\n}", "CodeBleu_score": 25.263386979261536}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\tuint8_t i;\n\tfor (i = 0; i < nbyte; i++) {\n\t\tspiSend(0xFF);\n\t\tbuf[i] = spiRec();\n\t}\n\tspiSend(0xFF);\n}", "CodeBleu_score": 47.793502702638804}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *relocatedTableAddr;\n\tuint32_t *currentHandlerAddr;\n\n\trelocatedTableAddr = (uint32_t *) get_relocated_table_addr();\n\toldHandler = (pfnISR_Handler) relocatedTableAddr[irq + 16];\n\n\tcurrentHandlerAddr = (uint32_t *) (relocatedTableAddr + 16 + irq);\n\t*currentHandlerAddr = (uint32_t) newHandler;\n\n\treturn oldHandler;\n}", "CodeBleu_score": 51.70122565641747}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tCRITICAL_SECTION_START\n\t\toldHandler = get_relocated_table_addr()[irq];\n\t\tget_relocated_table_addr()[irq] = newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 52.07897936454029}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = NULL;\n\tuint32_t addr = 0;\n\tCRITICAL_SECTION_START\n\t\taddr = get_relocated_table_addr();\n\t\toldHandler = (pfnISR_Handler)(addr + (irq * 4));\n\t\t*oldHandler = newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 51.37646307945849}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tint c = -1;\n\n\tif (udi_cdc_is_rx_ready()) {\n\t\tc = udi_cdc_getc();\n\t}\n\n\tif (c == -1) {\n\t\tif (emergency_parser.is_enabled()) {\n\t\t\tc = emergency_parser.peek();\n\t\t}\n\t}\n\n\treturn c;\n}", "CodeBleu_score": 26.591684130642435}, {"code": "int MarlinSerialUSB::peek(){\n\t\t// Check for a pending character in the serial USB buffer.\n\t// If a pending character exists, return it.\n\t// If the USB CDC is not enabled or configured on the PC side, or if no bytes are sent from the PC, return -1.\n\t// If bytes are available, read the next character, process it if the emergency parser is enabled, and return the character.\n\tif (udi_cdc_is_rx_ready()) {\n\t\treturn udi_cdc_getc();\n\t}\n\treturn -1;\n}", "CodeBleu_score": 7.874131277004517}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_task_cdc_isenabled()) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\treturn udi_cdc_getc();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 10.104863096714118}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tint c = -1;\n\tif (rx_buffer_index > 0) {\n\t\tc = rx_buffer[0];\n\t\trx_buffer_index--;\n\t\tmemmove(rx_buffer, &rx_buffer[1], rx_buffer_index);\n\t\tif (emergency_parser.enabled) {\n\t\t\temergency_parser.update(c);\n\t\t}\n\t} else if (usb_task_cdc_isenabled() && usb_task_cdc_isconfigured()) {\n\t\tif (udi_cdc_getc(&c)) {\n\t\t\tif (emergency_parser.enabled) {\n\t\t\t\temergency_parser.update(c);\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 44.46618735634465}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char!= -1) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\tif (!usb_task_cdc_isenabled()) {\n\t\treturn -1;\n\t}\n\tif (!udi_cdc_is_rx_ready()) {\n\t\treturn -1;\n\t}\n\tint c = udi_cdc_getc();\n\tif (emergency_parser.update(c)) {\n\t\treturn c;\n\t}\n\treturn -1;\n}", "CodeBleu_score": 53.03230349428304}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (m_rx_buffer_size > 0) {\n\t\treturn m_rx_buffer[0];\n\t}\n\tif (!m_cdc_enabled) {\n\t\treturn -1;\n\t}\n\tif (!m_cdc_configured) {\n\t\treturn -1;\n\t}\n\tif (!usb_task_cdc_isenabled()) {\n\t\treturn -1;\n\t}\n\tif (!udi_cdc_is_rx_ready()) {\n\t\treturn -1;\n\t}\n\tint c = udi_cdc_getc();\n\tif (m_emergency_parser_enabled) {\n\t\temergency_parser.update(c);\n\t}\n\treturn c;\n}", "CodeBleu_score": 38.352321228522015}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_task_cdc_isenabled() && usb_task_cdc_is_rx_ready()) {\n\t\treturn usb_task_cdc_available();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 24.061720607311322}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_task_cdc_isenabled()) {\n\t\tif (usb_task_cdc_is_rx_ready()) {\n\t\t\treturn usb_task_cdc_available();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 20.36327567401842}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_task_cdc_isenabled() && usb_task_cdc_is_rx_ready()) {\n\t\treturn usb_task_cdc_rx_available();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 24.14209102838375}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tif (pos >= size)\n\t\treturn false;\n\tuint8_t *ptr = value;\n\tfor (size_t i = 0; i < size; i++) {\n\t\t*ptr = ee_Read(pos);\n\t\tif (writing)\n\t\t\tee_Write(pos, *ptr);\n\t\tptr++;\n\t\tpos++;\n\t\t*crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)*ptr++) << 8));\n\t\tfor (uint8_t i = 0; i < 8; i++)\n\t\t\t*crc = (uint16_t)((*crc & 0x8000)? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n\t}\n\treturn true;\n}", "CodeBleu_score": 43.77751873159447}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tif (pos >= size) return false;\n\tuint8_t *p = value;\n\twhile (pos < size) {\n\t\tuint8_t b = ee_Read(pos++);\n\t\tif (writing) *p++ = b;\n\t\tif (crc) *crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)b) << 8));\n\t\tfor (uint8_t i = 0; i < 8; i++)\n\t\t\t*crc = (uint16_t)((*crc & 0x8000)? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n\t}\n\treturn true;\n}", "CodeBleu_score": 40.74675502523194}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t *ptr = value;\n\tuint8_t *end = value + size;\n\twhile (ptr < end) {\n\t\tif (writing) {\n\t\t\t*ptr++ = ee_Read(pos++, false);\n\t\t} else {\n\t\t\t*crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)*ptr++) << 8));\n\t\t\tfor (uint8_t i = 0; i < 8; i++)\n\t\t\t\t*crc = (uint16_t)((*crc & 0x8000)? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n\t\t}\n\t}\n\treturn (ptr == end);\n}", "CodeBleu_score": 41.27043198317279}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif defined(ESP8266)\n  if (pin == 13) return; // Do not use pin 13 for PWM on ESP8266\n#endif\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n\n  // Not attached, is an empty timer slot avail?\n  if (pwm_count < MAX_PWM_COUNT) {\n    pwm_count++;\n    pwmInfo[pwm_count - 1].pin = pin;\n    pwmInfo[pwm_count - 1].freq = freq;\n    pwmInfo[pwm_count - 1].res = res;\n    ledcSetup(pwm_count - 1, freq, res);\n    ledcAttachPin(pin, pwm_count - 1);\n    ledcWrite(pwm_count - 1, value);\n  }\n}", "CodeBleu_score": 50.03108944771641}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t", "CodeBleu_score": 3.7373796348143205}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tifdef DEBUG\n  if (pin < 0 || pin > MAX_PWM_IOPIN) {\n    Serial.print(\"ERROR: Invalid PWM pin: \");\n    Serial.println(pin);\n    return;\n  }\n  if (value < 0 || value > 255) {\n    Serial.print(\"ERROR: Invalid PWM value: \");\n    Serial.println(value);\n    return;\n  }\n  if (freq < 1000 || freq > 1000000) {\n    Serial.print(\"ERROR: Invalid PWM frequency: \");\n    Serial.println(freq);\n    return;\n  }\n  if (res < 2 || res > 16) {\n    Serial.print(\"ERROR: Invalid PWM resolution: \");\n    Serial.println(res);\n    return;\n  }\n#endif\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n  else {\n    // Allocate a new slot for this pin\n    if (pwm_used < PWM_MAX_NUM) {\n      pwmInfo[pwm_used].pin = pin;\n      pwmInfo[pwm_used].freq = freq;\n      pwmInfo[pwm_used].res = res;\n      pwmInfo[pwm_used].value = value;\n      pwm_used++;\n    }\n  }\n}", "CodeBleu_score": 50.69118946039377}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n  if (channel >= 0) {\n    static_assert(SERVO_DELAY_ARRAY_SIZE >= 16, \"Servo delay array size must be at least 16\");\n    write(value);\n    safe_delay(servo_delay_array[channel]);\n  }\n}", "CodeBleu_score": 49.52440918575024}, {"code": "void Servo::move(const int value){\n\t#ifndef DISABLE_SERVO_MOVE_ASSERT\n  static_assert(SERVO_DELAY_ARRAY_LENGTH == 5, \"SERVO_DELAY_ARRAY_LENGTH must be 5\");\n#endif\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 50.959646707939065}, {"code": "void Servo::move(const int value){\n\t#ifdef SERVO_DEBUG\n  Serial.print(\"Servo::move: \");\n  Serial.print(channel);\n  Serial.print(\" \");\n  Serial.println(value);\n#endif\n\n  // Check if the servo is attached\n  if (channel < 0) {\n    return;\n  }\n\n  // Write the value to the servo\n  write(value);\n\n  // Wait for the servo to move\n  safe_delay(SERVO_DELAY_MS[channel]);\n\n  // Detach the servo if the condition is enabled\n  if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n    detach();\n  }\n}", "CodeBleu_score": 51.268391878284625}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tint i;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (pwm_tick_count[i] == 0) {\n\t\t\tif (pwm_state[i] == 0) {\n\t\t\t\tpwm_state[i] = 1;\n\t\t\t} else {\n\t\t\t\tpwm_state[i] = 0;\n\t\t\t}\n\t\t\tpwm_tick_count[i] = pwm_period[i];\n\t\t}\n\t\tpwm_tick_count[i]--;\n\t\tif (pwm_state[i] == 0) {\n\t\t\tif (i == 0) {\n\t\t\t\t*pwm_buffer = 0;\n\t\t\t} else if (i == 1) {\n\t\t\t\t*pwm_buffer = 0;\n\t\t\t} else if (i == 2) {\n\t\t\t\t*pwm_buffer = 0;\n\t\t\t} else {\n\t\t\t\t*pwm_buffer = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i == 0) {\n\t\t\t\t*pwm_buffer = 0;\n\t\t\t} else if (i == 1) {\n\t\t\t\t*pwm_buffer = 0;\n\t\t\t} else if (i == 2) {\n\t\t\t\t*pwm_buffer = 0;\n\t\t\t} else {\n\t\t\t\t*pwm_buffer = 0;\n\t\t\t}\n\t\t}\n\t\tpwm_buffer++;\n\t}\n}", "CodeBleu_score": 33.04030384635921}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}, {"code": "void i2s_push_sample(){\n\t\tint i;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (pwm_tick_count[i] == 0) {\n\t\t\tpwm_pin_state[i] =!pwm_pin_state[i];\n\t\t\tpwm_tick_count[i] = pwm_tick_count_max[i];\n\t\t}\n\t\tpwm_tick_count[i]--;\n\t}\n\tint j = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (pwm_pin_state[i]) {\n\t\t\tpwm_buffer[j] = 0x00;\n\t\t} else {\n\t\t\tpwm_buffer[j] = 0xFF;\n\t\t}\n\t\tj++;\n\t}\n}", "CodeBleu_score": 28.807415659011486}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t counter_value;\n\tuint32_t timer_base_address;\n\tuint32_t timer_counter_address;\n\n\ttimer_base_address = get_timer_base_address(timer_num);\n\ttimer_counter_address = get_timer_counter_address(timer_num);\n\n\tcounter_value = *(volatile hal_timer_t *) timer_counter_address;\n\n\treturn counter_value;\n}", "CodeBleu_score": 41.56083854931692}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn timer_get_count(timer_num);\n}", "CodeBleu_score": 13.703296291452144}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t counter_value;\n\tcounter_value = (hal_timer_t) TIMER_get_counter_value(timer_num);\n\treturn counter_value;\n}", "CodeBleu_score": 37.169047571440316}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (pos + size > EEPROM_SIZE)\n\t\treturn false;\n\n\tuint8_t *ptr = value;\n\tfor (int i = 0; i < size; i++) {\n\t\tuint8_t data = EEPROM.read(pos + i);\n\t\tif (writing)\n\t\t\t*ptr++ = data;\n\t\t*crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)data) << 8));\n\t\tfor (uint8_t i = 0; i < 8; i++)\n\t\t\t*crc = (uint16_t)((*crc & 0x8000)? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n\t}\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 51.9254327746817}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (pos >= EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos);\n\t\tif (writing) {\n\t\t\tcrc16(crc, &value[i], 1);\n\t\t}\n\t\tpos++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 56.12899500894064}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (pos + size > EEPROM_SIZE)\n\t\treturn false;\n\tfor (int i = 0; i < size; i++) {\n\t\tif (writing)\n\t\t\tvalue[i] = EEPROM.read(pos + i);\n\t\tcrc16(crc, &value[i], 1);\n\t}\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 61.30725382120692}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\t/*\n\t * Check that the SDIO handle and source pointer are not null.\n\t */\n\tif ((SDIO_Handle == NULL) || (src == NULL)) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Try to write the block, retrying up to a defined number of times if the write operation fails.\n\t */\n\tfor (uint32_t i = 0; i < RETRY_COUNT; i++) {\n\t\t/*\n\t\t * Write the block.\n\t\t */\n\t\tif (SDIO_WriteBlocks(src, block, 1, SDIO_Handle) == true) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/*\n\t * Print an error message and return \"false\".\n\t */\n\tprintf(\"Error: SDIO write failed.\n\");\n\treturn false;\n}", "CodeBleu_score": 31.248728516852932}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\tuint32_t retry = 0;\n\twhile (SD_WriteBlock(block, src)!= SD_OK) {\n\t\tretry++;\n\t\tif (retry >= SDIO_RETRY) {\n\t\t\tprintf(\"Failed to write block %d\n\", block);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 26.778583230127516}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (SD_SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\tif (SD_SDIO_WriteBlocks(block, src, 1, SD_SDIO_Handle)!= SD_OK) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 21.41207245983101}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tCORE_ASSERT(timer_num < TIMER_CHANNEL_COUNT);\n\tif (timer_num == TIMER_CHANNEL_TEMP) {\n\t\ttimer_num->setCallbackPriority(TIMER_CHANNEL_TEMP, TIMER_PRIORITY_TEMP);\n\t\ttimer_num->start(frequency, TIMER_PRESCALE_TEMP);\n\t} else if (timer_num == TIMER_CHANNEL_STEP) {\n\t\ttimer_num->setCallbackPriority(TIMER_CHANNEL_STEP, TIMER_PRIORITY_STEP);\n\t\ttimer_num->start(frequency, TIMER_PRESCALE_STEP);\n\t} else {\n\t\tCORE_ASSERT_FAIL;\n\t}\n}", "CodeBleu_score": 48.90112215895622}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_TEMP) {\n\t\tHAL_timer_start_temp(frequency);\n\t} else if (timer_num == TIMER_STEP) {\n\t\tHAL_timer_start_step(frequency);\n\t} else {\n\t\tCORE_ASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 25.15701318785913}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\t// Check if the timer channel is valid\n\tif (timer_num >= TIMER_CHANNELS) {\n\t\tCORE_ASSERT_FAIL();\n\t\treturn;\n\t}\n\n\t// Check if the timer channel is the temperature timer\n\tif (timer_num == TIMER_CHANNEL_TEMP) {\n\t\t// Set the temperature timer frequency\n\t\ttimer_temp_freq = frequency;\n\n\t\t// Set the temperature timer prescale\n\t\ttimer_temp_prescale = TIMER_TEMP_PRESCALE;\n\n\t\t// Set the callback priority for temperature\n\t\ttimer_temp_callback_priority = TIMER_TEMP_CALLBACK_PRIORITY;\n\t}\n\n\t// Check if the timer channel is the step timer\n\telse if (timer_num == TIMER_CHANNEL_STEP) {\n\t\t// Set the step timer frequency\n\t\ttimer_step_freq = frequency;\n\n\t\t// Set the step timer prescale\n\t\ttimer_step_prescale = TIMER_STEP_PRESCALE;\n\n\t\t// Set the callback priority for stepper\n\t\ttimer_step_callback_priority = TIMER_STEP_CALLBACK_PRIORITY;\n\t}\n\n\t// Initialize the timer channel\n\ttimer_channel_init(timer_num);\n\n\t// Set the timer frequency\n\ttimer_set_frequency(timer_num, frequency);\n\n\t// Set the timer prescale\n\ttimer_set_prescale(timer_num, TIMER_PRESCALE);\n\n\t// Enable the timer interrupt\n\ttimer_enable_interrupt(timer_num);\n\n\t// Start the timer\n\ttimer_start(timer_num);\n}", "CodeBleu_score": 42.01125212567813}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tFILE *fp = fopen(EEPROM_FILE_NAME, \"r+\");\n\tif (fp == NULL) {\n\t\treturn false;\n\t}\n\tfseek(fp, 0L, SEEK_END);\n\tif (ftell(fp) < EEPROM_SIZE) {\n\t\tmemset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t} else {\n\t\tfread(buffer, 1, EEPROM_SIZE, fp);\n\t}\n\tfclose(fp);\n\treturn true;\n}", "CodeBleu_score": 26.718436007578262}, {"code": "bool PersistentStore::access_start(){\n\t\tFILE *file;\n\tfile = fopen(filename, \"rb+\");\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\tfseek(file, 0, SEEK_END);\n\tif (ftell(file) < EEPROM_SIZE) {\n\t\tfseek(file, 0, SEEK_SET);\n\t\tfwrite(default_eeprom_value, 1, EEPROM_SIZE, file);\n\t}\n\tfseek(file, 0, SEEK_SET);\n\tfread(buffer, 1, EEPROM_SIZE, file);\n\tfclose(file);\n\treturn true;\n}", "CodeBleu_score": 31.54886982950183}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the EEPROM file\n\tFILE *f = fopen(EEPROM_FILE_NAME, \"r+\");\n\tif (f == NULL) {\n\t\t// The file does not exist, so create it and fill it with the default value\n\t\tf = fopen(EEPROM_FILE_NAME, \"w+\");\n\t\tif (f == NULL) {\n\t\t\t// Could not create the file\n\t\t\treturn false;\n\t\t}\n\t\t// Fill the buffer with the default value\n\t\tmemset(buffer, EEPROM_DEFAULT_VALUE, EEPROM_SIZE);\n\t}\n\t// Get the file size\n\tlong size = ftell(f);\n\tif (size < EEPROM_SIZE) {\n\t\t// The file is smaller than the expected size, so fill the remainder with the default value\n\t\tmemset(buffer + size, EEPROM_DEFAULT_VALUE, EEPROM_SIZE - size);\n\t} else if (size > EEPROM_SIZE) {\n\t\t// The file is larger than the expected size, so truncate it\n\t\tfseek(f, EEPROM_SIZE, SEEK_SET);\n\t\tftruncate(fileno(f), EEPROM_SIZE);\n\t}\n\t// Read the file's contents into the buffer\n\tfread(buffer, 1, EEPROM_SIZE, f);\n\t// Close the file\n\tfclose(f);\n\t// Return success\n\treturn true;\n}", "CodeBleu_score": 38.410499053227895}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_RESET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\tr |= 1 << i;\n\t\t}\n\t\tb = b << 1;\n\t}\n\treturn r;\n}", "CodeBleu_score": 36.37219135542726}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t data = 0;\n\tuint8_t mask = 0x80;\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiSetClockPin(0);\n\t\tif (b & mask)\n\t\t\tHAL_SPI_STM32_SpiSetMOSIPin(1);\n\t\telse\n\t\t\tHAL_SPI_STM32_SpiSetMOSIPin(0);\n\t\tHAL_SPI_STM32_SpiSetClockPin(1);\n\t\tmask >>= 1;\n\t\tdata <<= 1;\n\t\tif (HAL_SPI_STM32_SpiGetMISOPin())\n\t\t\tdata |= 1;\n\t}\n\tHAL_SPI_STM32_SpiSetClockPin(0);\n\tdelaySPIFunc();\n\treturn data;\n}", "CodeBleu_score": 37.494100047291454}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t d = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiTransfer_Mode_3_Bit(b & 0x80);\n\t\tb <<= 1;\n\t\td <<= 1;\n\t\td |= HAL_SPI_STM32_SpiTransfer_Mode_3_Bit(b & 0x80);\n\t}\n\treturn d;\n}", "CodeBleu_score": 31.897545427372066}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73126554935065}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState!= DISABLE) {\n\t\t/* Enable the AHB peripheral clock */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the AHB peripheral clock */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 74.07583441360325}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73126554935065}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj->rx_error) {\n\t\t// error occurred\n\t\tobj->rx_error = false;\n\t\tobj->rx_error_count++;\n\t} else {\n\t\t// no error occurred\n\t\tif (obj->rx_buffer_head == obj->rx_buffer_tail) {\n\t\t\t// buffer is full\n\t\t\tobj->rx_buffer_head = 0;\n\t\t\tobj->rx_buffer_tail = 0;\n\t\t} else {\n\t\t\t// store received byte\n\t\t\tobj->rx_buffer[obj->rx_buffer_head] = obj->rx_buffer_data;\n\t\t\t// calculate next buffer index\n\t\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % obj->rx_buffer_size;\n\t\t}\n\t\t// update emergency parser\n\t\temergency_parser.update(obj->rx_buffer_data);\n\t}\n}", "CodeBleu_score": 29.441972556118646}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->getc();\n\tif (c == '\n') {\n\t\tobj->_rx_index = 0;\n\t\treturn;\n\t}\n\tif (obj->_rx_index < RX_BUFFER_SIZE) {\n\t\tobj->_rx_buffer[obj->_rx_index++] = c;\n\t\tif (obj->_rx_index == RX_BUFFER_SIZE) {\n\t\t\tobj->_rx_index = 0;\n\t\t}\n\t}\n\tif (obj->_rx_index >= RX_BUFFER_SIZE) {\n\t\tobj->_rx_index = 0;\n\t}\n\tif (obj->_rx_index > 0) {\n\t\tobj->_rx_complete = true;\n\t}\n\tif (emergency_parser.update) {\n\t\temergency_parser.update(c);\n\t}\n}", "CodeBleu_score": 39.83690559805046}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->read();\n\tif (c!= 0) {\n\t\tif (obj->rx_buffer_head >= obj->rx_buffer_tail + obj->rx_buffer_size) {\n\t\t\tobj->rx_buffer_head = obj->rx_buffer_tail;\n\t\t}\n\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\t\tobj->rx_buffer_head++;\n\t\tif (obj->rx_buffer_head >= obj->rx_buffer_tail + obj->rx_buffer_size) {\n\t\t\tobj->rx_buffer_head = obj->rx_buffer_tail;\n\t\t}\n\t\tif (obj->emergency_parser!= NULL) {\n\t\t\tobj->emergency_parser->update(c);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.06378977849336}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->initialized &&!timer_instance[timer_num]->hasInterrupt) {\n\t\tswitch (timer_num) {\n\t\tcase MF_TIMER_STEP:\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t\tbreak;\n\t\tcase MF_TIMER_TEMP:\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 74.76070580504047}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->is_initialized) {\n\t\tif (!timer_instance[timer_num]->hasInterrupt) {\n\t\t\tswitch (timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\tHAL_attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\tHAL_attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 63.55010320205341}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt == false) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 55.27239762916516}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\thash, pow := HashStrRev(sep)\n\thash2, pow2 := HashStrRev(s[:len(sep)])\n\tif hash == hash2 && bytes.Equal(sep, s[:len(sep)]) {\n\t\treturn 0\n\t}\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\thash2 = (hash2 - uint32(s[i+len(sep)])*pow2 + uint32(s[i])*pow) % PrimeRK\n\t\tif hash2 == hash && bytes.Equal(sep, s[i:i+len(sep)]) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 43.89381165789306}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn strings.LastIndex(s, string(sep))\n\t}\n\thashSep, pow := HashStrRev(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif s[i] == sep[0] && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t\tif i > 0 {\n\t\t\thashSep = (hashSep - uint32(s[i-1])*pow)*PrimeRK + uint32(s[i+len(sep)-1])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 39.55640159222483}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\thash, pow := HashStrRev(sep)\n\tvar hashSep uint32 = 0\n\tfor i := 0; i < len(sep); i++ {\n\t\thashSep = hashSep*PrimeRK + uint32(sep[i])\n\t}\n\tvar i, j int\n\tfor i = len(s) - len(sep); i >= 0; i-- {\n\t\tif hash == hashSep && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t\tif i+len(sep) < len(s) {\n\t\t\thash = hash*PrimeRK + uint32(s[i+len(sep)]) - pow*uint32(s[i])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 44.89393233493891}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.04282649496233}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.04282649496233}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.211916470826246}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(i2c.crReg.ClearBits(i2c.crReg.I2C_CR_STOP))\n\ti2c.crReg.Set(i2c.crReg.I2C_CR_START)\n\ti2c.crReg.Set(i2c.crReg.I2C_CR_EN)\n\tfor!i2c.crReg.HasBits(i2c.crReg.I2C_CR_START) {\n\t}\n\ti2c.drReg.Set(address << 1 | uint16(write))\n\tfor!i2c.srReg.HasBits(i2c.srReg.I2C_SR_ADDR) {\n\t}\n}", "CodeBleu_score": 30.959693803839517}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.I2C_CR1_STOP)\n\ti2c.crReg.SetBits(i2c.crReg.I2C_CR1_START)\n\ti2c.crReg.SetBits(i2c.crReg.I2C_CR1_PE)\n\tfor i2c.crReg.HasBits(i2c.crReg.I2C_SR1_SB) == false {\n\t}\n\ti2c.crReg.SetBits(i2c.crReg.I2C_CR1_ACK)\n\tif write == true {\n\t\ti2c.crReg.SetBits(i2c.crReg.I2C_CR1_TX)\n\t}\n\ti2c.drReg.SetBits(address << 1)\n}", "CodeBleu_score": 29.379212784101178}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.I2C_CR1_STOP, i2c.crReg.I2C_CR1_START, i2c.crReg.I2C_CR1_ACK)\n\ti2c.crReg.SetBits(i2c.crReg.I2C_CR1_START)\n\ti2c.crReg.Wait(i2c.crReg.I2C_CR1_STARTF)\n\ti2c.drReg.Set(address)\n\tif write {\n\t\ti2c.crReg.SetBits(i2c.crReg.I2C_CR1_ACK)\n\t}\n}", "CodeBleu_score": 29.63190661630354}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tvar err error\n\tvar block uintptr\n\tblock = uintptr(start) * f.EraseBlockSize\n\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy()\n\tnrf.NVMC.ERASEPAGE.Set(block)\n\twaitWhileFlashBusy()\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy()\n\n\treturn err\n}", "CodeBleu_score": 29.661897235849988}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size.\n\tstartAddr := uintptr(start) * f.EraseBlockSize\n\n\t// Configure the flash for erasing.\n\tf.ConfigureForErase(startAddr)\n\n\t// Erase the specified number of blocks.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Wait for the flash to become available.\n\t\tf.waitWhileFlashBusy()\n\n\t\t// Erase the current block.\n\t\tf.EraseBlock(startAddr)\n\n\t\t// Wait for the flash to become available.\n\t\tf.waitWhileFlashBusy()\n\t}\n\n\t// Set the flash back to read mode.\n\tf.SetReadMode()\n\n\treturn nil\n}", "CodeBleu_score": 29.73180025564659}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"invalid arguments\")\n\t}\n\n\t// Calculate the start address based on the block number and block size\n\tstartAddr := uintptr(f.BlockSize) * uintptr(start)\n\n\t// Wait for any ongoing flash operations to complete\n\tf.waitWhileFlashBusy()\n\n\t// Configure the flash for erasing\n\tf.configureForErase()\n\n\t// Erase the specified number of blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// Wait for the flash to become ready\n\t\tf.waitWhileFlashBusy()\n\n\t\t// Erase the block at the specified address\n\t\tnrf.NVMC.ERASEPAGE.Set(startAddr + uintptr(i)*f.BlockSize)\n\n\t\t// Wait for the flash to become ready\n\t\tf.waitWhileFlashBusy()\n\t}\n\n\t// Set the flash back to read mode\n\tf.setReadMode()\n\n\treturn nil\n}", "CodeBleu_score": 42.00805516202403}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off >= int64(f.size) {\n\t\treturn 0, errors.New(\"offset out of range\")\n\t}\n\tstartAddress := uintptr(off)\n\tpad := (f.WriteBlockSize - (len(p) % f.WriteBlockSize)) % f.WriteBlockSize\n\tp = append(p, make([]byte, pad)...)\n\twaitWhileFlashBusy()\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_WEN_Enabled)\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\tendAddress := startAddress + uintptr(f.WriteBlockSize)\n\t\tif endAddress > uintptr(f.size) {\n\t\t\tendAddress = uintptr(f.size)\n\t\t}\n\t\tnrf.NVMC.SetERASEPAGE_ADDR(startAddress)\n\t\tnrf.NVMC.SetERASEPAGE_END(endAddress)\n\t\tnrf.NVMC.SetERASEPAGE_TASKS_ERASE()\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetWRITE_ADDR(startAddress)\n\t\tnrf.NVMC.SetWRITE_VALUE(binary.LittleEndian.Uint32(p[i:i+4]))\n\t\tnrf.NVMC.SetWRITE_TASKS_WRITE()\n\t\twaitWhileFlashBusy()\n\t\tstartAddress += uintptr(f.WriteBlockSize)\n\t}\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_WEN_Disabled)\n\treturn len(p), nil\n}", "CodeBleu_score": 36.43392679364592}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"flash memory out of bounds\")\n\t}\n\tstart := uintptr(off)\n\tpad := f.WriteBlockSize - (len(p) % f.WriteBlockSize)\n\tp = append(p, make([]byte, pad)...)\n\tn = len(p)\n\terr = f.writeAt(start, p)\n\treturn\n}", "CodeBleu_score": 23.816944684470563}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tnewfd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tfor {\n\t\tdir, err := syscall.Fdopendir(newfd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tsyscall.Close(newfd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 54.33554836736446}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tnewFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory using \"syscall.Fdopendir\".\n\tfor {\n\t\tdir, err := syscall.Fdopendir(newFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\n\t\t// If the error is not \"syscall.EINTR\", return the error.\n\t\tif err!= syscall.EINTR {\n\t\t\tsyscall.Close(newFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 54.18483725497853}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar dir uintptr\n\tvar err error\n\tfor {\n\t\tdir, err = syscall.Dup(int(fd))\n\t\tif err!= nil {\n\t\t\tif err!= syscall.EINTR {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\tdefer syscall.Close(int(dir))\n\tfor {\n\t\tdir, err = syscall.Fdopendir(int(dir))\n\t\tif err!= nil {\n\t\t\tif err!= syscall.EINTR {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 47.95304322361207}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_ota_get_running_partition(&running_partition);\n\tif (response == sketchSize_t::FREE_SPACE) {\n\t\treturn running_partition.size - running_partition.erased_size;\n\t} else {\n\t\treturn running_partition.size;\n\t}\n}", "CodeBleu_score": 27.037406588020684}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_err_t err;\n\tesp_ota_img_states_t state;\n\tesp_partition_t* running = esp_ota_get_running_partition();\n\tesp_partition_info_t part_info;\n\tesp_partition_read(running, 0, &part_info, sizeof(esp_partition_info_t));\n\tesp_partition_read(running, sizeof(esp_partition_info_t), &state, sizeof(esp_ota_img_states_t));\n\tif (response == SKETCH_SIZE_FREE) {\n\t\treturn part_info.size - state.app_size;\n\t} else {\n\t\treturn state.app_size;\n\t}\n}", "CodeBleu_score": 44.309700032991664}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t app_desc;\n\tesp_ota_get_running_partition(&app_desc);\n\n\tif (response == sketchSize_t::FREE_SPACE) {\n\t\treturn app_desc.app_size;\n\t} else {\n\t\treturn app_desc.size;\n\t}\n}", "CodeBleu_score": 23.489054598370554}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % ESP_PARTITION_SIZE(partition)!= 0) {\n\t\tESP_LOGE(TAG, \"Offset %d is not aligned with the flash sector size of %d\", offset, ESP_PARTITION_SIZE(partition));\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\terr = esp_partition_erase_range(partition, offset, ESP_PARTITION_SIZE(partition));\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase partition at offset %d\", offset);\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write to partition at offset %d\", offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 50.13402433600547}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tif (offset % partition->size!= 0) {\n\t\tESP_LOGE(TAG, \"offset is not aligned with flash sector size\");\n\t\terr = ESP_ERR_INVALID_ARG;\n\t}\n\tif (err == ESP_OK) {\n\t\terr = esp_partition_erase_range(partition, offset, partition->size);\n\t}\n\tif (err == ESP_OK) {\n\t\terr = esp_partition_write(partition, offset, data, size);\n\t}\n\treturn err;\n}", "CodeBleu_score": 56.267920419080255}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % ESP_PARTITION_SIZE_SEC!= 0) {\n\t\tESP_LOGE(TAG, \"Offset is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\terr = esp_partition_erase_range(partition, offset, ESP_PARTITION_SIZE_SEC);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase flash sector at offset 0x%x\", offset);\n\t\treturn err;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 55.853417525645675}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tsize_t j = 0;\n\tsize_t len = strlen(in);\n\n\twhile (i < len && j < maxlen) {\n\t\tunsigned char c = in[i++];\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tc -= '0';\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tc -= 'a' - 10;\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tc -= 'A' - 10;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == len) {\n\t\t\tbreak;\n\t\t}\n\t\tunsigned char c2 = in[i++];\n\t\tif (c2 >= '0' && c2 <= '9') {\n\t\t\tc2 -= '0';\n\t\t} else if (c2 >= 'a' && c2 <= 'f') {\n\t\t\tc2 -= 'a' - 10;\n\t\t} else if (c2 >= 'A' && c2 <= 'F') {\n\t\t\tc2 -= 'A' - 10;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tout[j++] = (c << 4) | c2;\n\t}\n\treturn j;\n}", "CodeBleu_score": 37.86199110258979}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = strlen(in);\n\tif (len % 2) {\n\t\treturn 0;\n\t}\n\tsize_t outlen = len / 2;\n\tif (outlen > maxlen) {\n\t\toutlen = maxlen;\n\t}\n\tfor (size_t i = 0; i < outlen; i++) {\n\t\tout[i] = hex_char_to_byte(in[i * 2]) << 4 | hex_char_to_byte(in[i * 2 + 1]);\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 39.27121641224923}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = strlen(in);\n\tsize_t outlen = 0;\n\tsize_t i = 0;\n\twhile (i < len) {\n\t\tif (outlen >= maxlen) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (in[i] =='') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (outlen + 1 >= maxlen) {\n\t\t\treturn 0;\n\t\t}\n\t\tunsigned char b = hex_char_to_byte(in[i]);\n\t\tif (b == 0x10) {\n\t\t\treturn 0;\n\t\t}\n\t\tout[outlen] = b;\n\t\toutlen++;\n\t\ti++;\n\t\tif (i < len) {\n\t\t\tif (outlen + 1 >= maxlen) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tb = hex_char_to_byte(in[i]);\n\t\t\tif (b == 0x10) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tout[outlen] = b;\n\t\t\toutlen++;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 38.91414608432188}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buffer == NULL || tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, tx_timeout)!= pdTRUE) {\n\t\treturn 0;\n\t}\n\tint free_size = xRingbufferGetCurFreeSize(tx_ring_buffer);\n\txSemaphoreGive(tx_lock);\n\treturn free_size;\n}", "CodeBleu_score": 72.61310885844406}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_txRingBuffer == NULL || m_txLock == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(m_txLock, 0) == pdTRUE) {\n\t\tint freeSize = xRingbufferGetCurFreeSize(m_txRingBuffer);\n\t\txSemaphoreGive(m_txLock);\n\t\treturn freeSize;\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 64.88007530960323}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint ret = 0;\n\tif (xRingbufferGetCurFreeSize(m_xRingbufferTx) == 0) {\n\t\treturn ret;\n\t}\n\tif (xSemaphoreTake(m_xSemaphoreTx, pdMS_TO_TICKS(1000)) == pdTRUE) {\n\t\tret = xRingbufferGetCurFreeSize(m_xRingbufferTx);\n\t\txSemaphoreGive(m_xSemaphoreTx);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 40.79660393461432}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if defined(ARDUINO_SAMD_ZERO)\n  // SAMD Zero does not support UART events.\n  return;\n#endif\n\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  _rxTimeout = 0;\n\n  if (function!= NULL) {\n    _rxThreshold = 1;\n    _createEventTask(NULL);\n  }\n}", "CodeBleu_score": 23.78420531505272}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t// Set the callback function\n\t_onReceiveCB = function;\n\n\t// Set the receive timeout behavior\n\t_rxTimeout.onlyOnTimeout = onlyOnTimeout;\n\t_rxTimeout.timeout = 0;\n\n\t// Set the FIFO full threshold\n\t_rxThreshold = 0;\n\n\t// Create the event task if it does not already exist\n\tif (_eventTask == NULL) {\n\t\t_createEventTask(NULL);\n\t}\n}", "CodeBleu_score": 27.23205045810327}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if defined(ARDUINO_SAMD_ZERO) &&!defined(ARDUINO_SAMD_MKR1000)\n  // The SAMD Zero does not support the Serial.onReceive() callback function.\n  // See https://github.com/arduino/ArduinoCore-samd/issues/153\n  // See https://github.com/arduino/ArduinoCore-samd/issues/195\n  return;\n#endif\n  // Lock the serial mutex\n  HSERIAL_MUTEX_LOCK\n  // Set the callback function\n  _onReceiveCB = function;\n  // Set the receive timeout behavior\n  _onlyOnTimeout = onlyOnTimeout;\n  // If the callback function is not NULL, configure the FIFO full threshold and create an event task if it does not already exist\n  if (function!= NULL) {\n    // Set the FIFO full threshold\n    _rxThreshold = _rxBuffer.getFreeSpace();\n    // If an event task does not already exist, create it\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n  // Unlock the serial mutex\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 33.392256328171314}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\tint c;\n\n\twhile (index < length) {\n\t\tc = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = c;\n\t\tindex++;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 58.04316368430881}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\tint c;\n\n\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\twhile (index < length) {\n\t\tc = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = c;\n\t\tindex++;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 67.45950543124681}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tint c;\n\tsize_t i = 0;\n\twhile ((i + 1) < length) {\n\t\tif ((c = timedRead()) < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[i] = c;\n\t\ti++;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuffer[i] = 0;\n\treturn i;\n}", "CodeBleu_score": 49.84153092014627}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t//  log_v(\"tone(%d, %d, %d)\", pin, frequency, duration);\n  if (tone_init()) {\n    if (pin < 12) {\n      if (pin_is_available(pin)) {\n        log_v(\"tone(%d, %d, %d)\", pin, frequency, duration);\n        tone_msg_t msg = {\n         .pin = pin,\n         .frequency = frequency,\n         .duration = duration,\n        };\n        if (xQueueSend(_tone_queue, &msg, 0)!= pdPASS) {\n          log_e(\"Could not send tone message to queue\");\n        }\n      } else {\n        log_e(\"Tone on pin %d already in use\", pin);\n      }\n    } else {\n      log_e(\"Invalid pin number: %d\", pin);\n    }\n  }\n}", "CodeBleu_score": 58.770268153579266}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t#ifdef LOGGING\n  log_v(\"tone(%d, %d, %d)\", pin, frequency, duration);\n#endif\n  if (tone_init() == 0) {\n    return;  // ERR\n  }\n\n  if (pin == 0) {\n    log_e(\"tone: pin 0 is reserved for the serial port\");\n    return;  // ERR\n  }\n\n  if (pin > 15) {\n    log_e(\"tone: pin %d is out of range\", pin);\n    return;  // ERR\n  }\n\n  if (frequency == 0) {\n    log_e(\"tone: frequency cannot be 0\");\n    return;  // ERR\n  }\n\n  if (duration == 0) {\n    log_e(\"tone: duration cannot be 0\");\n    return;  // ERR\n  }\n\n  if (pin_is_used(pin) == 0) {\n    log_v(\"tone: pin %d is available\", pin);\n    tone_msg_t msg = {\n     .pin = pin,\n     .frequency = frequency,\n     .duration = duration,\n    };\n    if (xQueueSend(_tone_queue, &msg, 0)!= pdTRUE) {\n      log_e(\"tone: could not send tone message to queue\");\n    }\n  } else {\n    log_e(\"tone: pin %d is in use\", pin);\n  }\n}", "CodeBleu_score": 53.42988446861463}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\ttone_init();\n\tif (pin_is_available(pin)) {\n\t\ttone_msg_t msg;\n\t\tmsg.pin = pin;\n\t\tmsg.frequency = frequency;\n\t\tmsg.duration = duration;\n\t\txQueueSend(_tone_queue, &msg, 0);\n\t} else {\n\t\tlog_e(\"Tone on pin %d is already in use\", pin);\n\t}\n}", "CodeBleu_score": 33.617276664305386}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usbStarted) {\n\t\twebUSBEnabled = enabled;\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tusbVersion = 0x0210;\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.761508743592096}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usb_started) {\n\t\twebUSB_enabled = enabled;\n\t\treturn false;\n\t}\n\tif (enabled) {\n\t\tif (usb_version < 0x0210) {\n\t\t\tusb_version = 0x0210;\n\t\t\tusb_set_version();\n\t\t}\n\t} else {\n\t\tusb_version = 0x0110;\n\t\tusb_set_version();\n\t}\n\twebUSB_enabled = enabled;\n\treturn true;\n}", "CodeBleu_score": 56.29301953092306}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_state == USB_STATE_DISABLED) {\n\t\tif (enabled) {\n\t\t\tusb_state = USB_STATE_WEBUSB_ENABLED;\n\t\t\tif (usb_version < 0x0210) {\n\t\t\t\tusb_version = 0x0210;\n\t\t\t}\n\t\t} else {\n\t\t\tusb_state = USB_STATE_WEBUSB_DISABLED;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 51.07139001020891}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\t// Read data into the buffer\n\tuint32_t length = tud_cdc_n_read(0, _rx_buf, sizeof(_rx_buf));\n\n\t// Send each byte to the receive queue\n\tfor (uint32_t i = 0; i < length; i++) {\n\t\tif (xQueueSend(_rx_queue, &_rx_buf[i], 0)!= pdPASS) {\n\t\t\t// Queue is full, post an overflow event\n\t\t\tlog_e(\"Queue is full\");\n\t\t\tarduino_usb_event_post(USB_EVENT_CDC_RX_OVERFLOW);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Post a receive event with the length of the received data\n\tarduino_usb_event_post(USB_EVENT_CDC_RX_READY);\n}", "CodeBleu_score": 22.448184899079994}, {"code": "void USBCDC::_onRX(){\n\t\tuint32_t n_read = 0;\n\tuint8_t buffer[64];\n\n\tn_read = tud_cdc_n_read(0);\n\n\tif (n_read > 64) {\n\t\tn_read = 64;\n\t}\n\n\ttud_cdc_n_read(0, buffer, n_read);\n\n\tfor (uint32_t i = 0; i < n_read; i++) {\n\t\tif (xQueueSend(rx_queue, &buffer[i], 0)!= pdPASS) {\n\t\t\tlog_e(\"overflow\");\n\t\t}\n\t}\n\n\tif (n_read > 0) {\n\t\tlog_d(\"rx: %d\", n_read);\n\t\ttud_cdc_n_write_flush(0);\n\t\ttud_cdc_n_write(0, buffer, n_read);\n\t\ttud_cdc_n_write_flush(0);\n\t\ttud_cdc_n_write(0, NULL, 0);\n\t}\n}", "CodeBleu_score": 29.30909468765978}, {"code": "void USBCDC::_onRX(){\n\t", "CodeBleu_score": 1.253830987611717}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tif robotName == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\":\"robot name is required\"}`))\n\t\treturn\n\t}\n\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\":\"no robot found with the name ` + robotName + `\"}`))\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\terr = json.NewEncoder(res).Encode(robot.Devices())\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\":\"error encoding robot devices\"}`))\n\t\treturn\n\t}\n}", "CodeBleu_score": 46.23783087727612}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tif robot, err := a.master.Robot(robotName); err == nil {\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\ta.writeJSON(res, robot.Devices())\n\t} else {\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\ta.writeJSON(res, map[string]string{\"error\": \"No robot found with the name: \" + robotName})\n\t}\n}", "CodeBleu_score": 34.28157421882857}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tif robotName == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprintf(res, \"No robot name provided\")\n\t\treturn\n\t}\n\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprintf(res, \"No robot found with the name %s\", robotName)\n\t\treturn\n\t}\n\n\tdevices, err := a.writeJSON(res, robot.Devices())\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"An error occurred while writing the JSON response: %s\", err)\n\t\treturn\n\t}\n\n\tif len(devices) == 0 {\n\t\tres.WriteHeader(http.StatusNoContent)\n\t\tfmt.Fprintf(res, \"No devices found for robot %s\", robotName)\n\t}\n}", "CodeBleu_score": 42.56345819922595}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Check if the robot exists\n\trobot, ok := a.master.Robot(robotName)\n\tif!ok {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot with name %s found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections\n\tconnections := robot.Connections()\n\tconnectionsJSON := make([]map[string]interface{}, 0, len(connections))\n\tfor _, connection := range connections {\n\t\tconnectionJSON := map[string]interface{}{\n\t\t\t\"name\":      connection.Name(),\n\t\t\t\"type\":      connection.Type(),\n\t\t\t\"connected\": connection.Connected(),\n\t\t}\n\t\tconnectionsJSON = append(connectionsJSON, connectionJSON)\n\t}\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connectionsJSON)\n\tif err!= nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Error converting connections to JSON: %s\", err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 44.427802378046295}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Check if the robot exists\n\trobot, ok := a.master.Robot(robotName)\n\tif!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, \"No robot with the name\", robotName, \"found\")\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format\n\tconnections := robot.Connections()\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(res, \"Error converting connections to JSON:\", err)\n\t\treturn\n\t}\n\n\t// Write the JSON connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 37.227758790926266}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := req.URL.Query().Get(\"robot\")\n\n\t// Check if the robot exists\n\tif _, ok := a.master.Robot(robotName);!ok {\n\t\t// Write an error message to the HTTP response indicating that no robot with the specified name was found\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with the specified name was found.\"))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections\n\tconnections := a.master.Robot(robotName).Connections()\n\tvar connectionJSONs []interface{}\n\tfor _, connection := range connections {\n\t\tconnectionJSON, err := json.Marshal(connection)\n\t\tif err!= nil {\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(\"Error while converting connection to JSON.\"))\n\t\t\treturn\n\t\t}\n\t\tconnectionJSONs = append(connectionJSONs, string(connectionJSON))\n\t}\n\n\t// Convert the connection JSONs to a single JSON array\n\tconnectionsJSON, err := json.Marshal(connectionJSONs)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"Error while converting connection JSONs to a single JSON array.\"))\n\t\treturn\n\t}\n\n\t// Write the JSON array to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 44.56409288084599}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\tcommand := req.URL.Query().Get(\":command\")\n\n\tif robot == \"\" || device == \"\" || command == \"\" {\n\t\thttp.Error(res, \"Missing parameters\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif a.master.Robot(robot).Device(device) == nil {\n\t\thttp.Error(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tif err := a.executeCommand(robot, device, command); err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusNoContent)\n}", "CodeBleu_score": 47.10823096927623}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, \"Robot not found\")\n\t\treturn\n\t}\n\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, \"Device not found\")\n\t\treturn\n\t}\n\n\tcommand := a.master.Robot(req.URL.Query().Get(\":robot\")).\n\t\t\t\tDevice(req.URL.Query().Get(\":device\")).(gobot.Commander).\n\t\t\t\tCommand(req.URL.Query().Get(\":command\"))\n\tif command == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, \"Command not found\")\n\t\treturn\n\t}\n\n\terr := command.Run(req.URL.Query())\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, \"Command executed successfully\")\n}", "CodeBleu_score": 52.295210857747776}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tcommandName := req.URL.Query().Get(\":command\")\n\n\tdevice, err := a.master.Robot(robotName).Device(deviceName)\n\tif err!= nil {\n\t\ta.writeJSON(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\terr = device.(gobot.Commander).Command(commandName)\n\tif err!= nil {\n\t\ta.writeJSON(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ta.writeJSON(res, \"OK\", http.StatusOK)\n}", "CodeBleu_score": 52.32406098480098}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth = strings.TrimPrefix(auth, \"Basic \")\n\t\tauth = strings.TrimSpace(auth)\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(pair)!= 2 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Proceed to the next handler\n\t\t//...\n\t}\n}", "CodeBleu_score": 47.62171640805942}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Missing Authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\thttp.Error(w, \"Missing Basic scheme\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Invalid Basic scheme\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 {\n\t\t\thttp.Error(w, \"Invalid Basic scheme\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Invalid username or password\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authentication succeeded, proceed to the next handler\n\t\t//...\n\t}\n}", "CodeBleu_score": 48.73341104761474}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"No authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\thttp.Error(w, \"Invalid authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Invalid authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 {\n\t\t\thttp.Error(w, \"Invalid authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!secureCompare(username, pair[0]) ||!secureCompare(password, pair[1]) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Invalid username or password\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Proceed to the next handler\n\t}\n}", "CodeBleu_score": 48.11350107223385}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\trawValue, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaledValue := float64(rawValue) * a.sensorCfg.scale\n\n\ta.lastReadRaw = rawValue\n\ta.lastReadScaled = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 51.565717818441904}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection().SupportsAnalogRead() {\n\t\traw, err := a.Connection().AnalogRead(a.Pin)\n\t\tif err!= nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\n\t\tscaled := a.sensorCfg.scale(raw)\n\n\t\ta.lastReadRaw = raw\n\t\ta.lastReadScaled = scaled\n\n\t\treturn raw, scaled, nil\n\t}\n\n\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n}", "CodeBleu_score": 48.548437394664276}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection not set\")\n\t}\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.232084918198744}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tdriver := NewAnalogSensorDriver(a, pin, opts...)\n\tdriver.SetName(DefaultName)\n\treturn driver\n}", "CodeBleu_score": 22.458155052358183}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tDefaultName:         \"GroveSoundSensorDriver\",\n\t\tAnalogSensorDriver:  NewAnalogSensorDriver(a, pin, opts...),\n\t\tSoundSensorDriver:   NewSoundSensorDriver(),\n\t\tSoundSensorDriverID: 1,\n\t}\n}", "CodeBleu_score": 40.000839804188324}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tvar name string\n\tif len(opts) > 0 {\n\t\tname = opts[0].(string)\n\t} else {\n\t\tname = gobot.DefaultName\n\t}\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               name,\n\t}\n}", "CodeBleu_score": 42.50557763706006}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, PCD_SoftReset)\n\ttime.Sleep(1)\n\tstatus := d.readByteData(CommandReg)\n\tif status&0x01!= 0 {\n\t\treturn fmt.Errorf(\"PCD_SoftReset: did not clear power down bit. MFRC522 was not reset.\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 27.048775941522447}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Reset the MFRC522\n\td.writeByteData(MFRC522CommandReg, MFRC522Reset)\n\n\t// Wait a bit\n\ttime.Sleep(time.Millisecond * 10)\n\n\t// Check the PowerDown bit of the CommandReg.\n\tif d.readByteData(MFRC522CommandReg) & MFRC522Reset!= 0 {\n\t\treturn fmt.Errorf(\"MFRC522 soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 27.708983917774233}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, 0x0F)\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// check the PowerDown bit\n\tif d.readByteData(CommandReg) == 0x0F {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 25.451477257023196}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read FIFO.\n\tn, err := d.readRegister(regFIFOData, backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if we have read enough bytes.\n\tif n!= len(backData) {\n\t\treturn 0, fmt.Errorf(\"readFifo: read %d bytes, expected %d\", n, len(backData))\n\t}\n\n\t// Read the last bits received from the FIFO.\n\tlastBits, err := d.readRegister(regControl, regControlBitMask)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 37.919767043192}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read the number of bytes waiting in the FIFO buffer\n\tn, err := d.readByte(MFRC522_FIFOLENGTHREG)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of waiting bytes is less than the size of the buffer\n\tif n > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: FIFO overflow, %d bytes in FIFO, but only %d bytes in buffer\", n, len(backData))\n\t}\n\n\t// Read the bytes\n\tfor i := 0; i < int(n); i++ {\n\t\tbackData[i], err = d.readByte(MFRC522_FIFODATAREG)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register, get the number of bytes actually read out from the FIFO, and take into account the CRC bytes\n\tcontrol, err := d.readByte(MFRC522_CONTROLREG)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn control, nil\n}", "CodeBleu_score": 55.36490676124528}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check the number of bytes available in the FIFO buffer.\n\tlen, err := d.readByteData(MFRC522_FIFOLevelReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif len!= len(backData) {\n\t\treturn 0, fmt.Errorf(\"the number of bytes in the FIFO buffer is not equal to the expected length of the byte slice\")\n\t}\n\n\t// Read the bytes from the FIFO buffer.\n\tfor i := 0; i < len; i++ {\n\t\tbackData[i], err = d.readByteData(MFRC522_FIFODataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the last bits received from the FIFO.\n\tcontrol, err := d.readByteData(MFRC522_ControlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn control, nil\n}", "CodeBleu_score": 47.95414827039246}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Build command buffer\n\thaltCommand := []byte{PICC_CMD_HLTA}\n\t// Calculate CRC_A\n\t_, err := d.calculateCRC(haltCommand, haltCommand)\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"Error in piccHalt: %s\", err)\n\t}\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\n\t//\t\tHLTA command, this response shall be interpreted as 'not acknowledge'.\n\t// We interpret that this way: Only status words other than \"OK\" indicate an error.\n\tif err := d.communicateWithPICC(haltCommand, nil, nil); err!= nil {\n\t\treturn fmt.Errorf(\"Error in piccHalt: %s\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.93722473572054}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Build command buffer\n\tcmd := []byte{PICC_CMD_HLTA}\n\t// Calculate CRC_A\n\tif d.calculateCRC(cmd, &cmd[2])!= nil {\n\t\treturn fmt.Errorf(\"PICC_CMD_HLTA CRC_A calculation failed\")\n\t}\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\n\t//\t\tHLTA command, this response shall be interpreted as 'not acknowledge'.\n\t// We interpret that this way: Only STATUS_TIMEOUT is a success; all other errors are failed transactions.\n\t// StatusTimeout - the timeout for the SOF (start of frame) byte is 1 ms!\n\tif d.communicateWithPICC(cmd, nil, 1, nil)!= STATUS_TIMEOUT {\n\t\treturn fmt.Errorf(\"PICC_CMD_HLTA failed to respond\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 21.38143050940607}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\n\t// Build command\n\thalt := []byte{PICC_CMD_HALT}\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(halt)\n\t// Append CRC_A to command\n\thalt = append(halt, crc...)\n\n\t// Send the command.\n\t// The CRC_A is appended to the end of the data we want to send.\n\tif err := d.communicateWithPICC(halt, nil); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.186097575966954}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar (\n\t\tbuffer [18]byte\n\t\tcrc    [2]byte\n\t\terr    error\n\t)\n\t// Build command buffer\n\tbuffer[0] = piccCommandRead\n\tbuffer[1] = block\n\t// Calculate CRC_A\n\td.calculateCRC(buffer[0:1], crc[:])\n\t// Append CRC_A to buffer\n\tbuffer[2] = crc[0]\n\tbuffer[3] = crc[1]\n\t// Send the buffer and receive the response\n\td.communicateWithPICC(buffer[:4], &buffer[4])\n\t// Check response status\n\tif (buffer[0]!= piccStatusOk) {\n\t\treturn nil, errors.New(fmt.Sprintf(\"Error communicating with PICC: 0x%02X\", buffer[0]))\n\t}\n\t// The PICC must reply with a 4-byte response, containing the data and the 16-bit CRC.\n\tif (len(buffer)!= 18) {\n\t\treturn nil, errors.New(\"Invalid data received from PICC\")\n\t}\n\t// Verify CRC_A - do our own calculation and store the control in buffer[17]\n\td.calculateCRC(buffer[0:16], &crc)\n\tif (crc[0]!= buffer[16] || crc[1]!= buffer[17]) {\n\t\treturn nil, errors.New(\"CRC_A did not match\")\n\t}\n\t// Return data and CRC_A\n\treturn buffer[0:16], nil\n}", "CodeBleu_score": 29.431044533081547}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t", "CodeBleu_score": 3.9226551888190304}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build command buffer\n\tcmd := []byte{MFRC522_PICC_CMD_MF_READ, block}\n\t// Calculate CRC_A\n\td.calculateCRC(cmd, &cmd[2])\n\t// Send the command.\n\t// The commands are the same32 as the commands in the MFRC522 datasheet.\n\t// Section 9.4.2.2\n\t// \"PCD_Transceive\" sends the specified command.\n\t// \"PCD_Transceive\" can also receive data, but it is not used in this function.\n\tdata, err := d.communicateWithPICC(MFRC522_PCD_TRANSCEIVE, cmd, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// The data in the buffer should be 16 bytes.\n\t// The first byte should be the length of the data.\n\t// The second byte should be NUL.\n\tif len(data)!= 16 || data[0]!= 0x90 || data[1]!= 0x00 {\n\t\treturn nil, errors.New(\"Error communicating with PICC\")\n\t}\n\treturn data[2:], nil\n}", "CodeBleu_score": 33.43614518447689}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t", "CodeBleu_score": 3.6650973421215025}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Prepare the parameter data\n\tvar txData [2]byte\n\ttxData[0] = reqMode\n\n\t// Prepare MFRC522\n\td.clearRegisterBitMask(MFRC522_CollReg, 0x80) // ValuesAfterColl=1 => Bits received after collision are cleared.\n\tif reqMode == MFRC522_REQALL {\n\t\t// Clear bit 4 and 5 of command byte, type A and type B, respectively\n\t\ttxData[1] = 0x70\n\t} else {\n\t\ttxData[1] = 0x00\n\t}\n\n\t// Transmit the command\n\tif err := d.communicateWithPICC(MFRC522_Transceive, txData[:], answer); err!= nil {\n\t\treturn err\n\t}\n\n\t// Error?\n\tif len(answer)!= 2 || answer[0]!= 0x00 {\n\t\treturn fmt.Errorf(\"PICC_REQ failed: %v\", answer)\n\t}\n\n\t// Collision?\n\tif answer[1] & 0x04 == 0x04 {\n\t\treturn fmt.Errorf(\"PICC_REQ failed: collision detected\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.6911682530788}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t", "CodeBleu_score": 3.6650973421215025}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.step == 0 {\n\t\treturn nil\n\t}\n\n\terr := d.digitalWrite(d.stepPin, LOW)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.getDelayPerStep())\n\n\terr = d.digitalWrite(d.stepPin, HIGH)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif d.step > 0 {\n\t\td.step--\n\t} else {\n\t\td.step++\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 65.834207625884}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.digitalWrite(d.stepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, 1)\n\n\tif d.direction == FORWARD {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.398534141136814}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.step == 0 {\n\t\treturn nil\n\t}\n\n\td.digitalWrite(d.stepPin, false)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, true)\n\n\tif d.direction == 1 {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.99420206992691}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\n\treturn nil\n}", "CodeBleu_score": 79.80884017958391}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}", "CodeBleu_score": 36.70966757447426}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.continuousMeasureDistance()\n\n\treturn nil\n}", "CodeBleu_score": 37.13290469304058}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(id int, duration time.Duration, name string, value uint32, timestamp uint32) {\n\t\tswitch id {\n\t\tcase 0:\n\t\t\tif duration > 0 {\n\t\t\t\td.eventChannel <- Event{\n\t\t\t\t\tName: name,\n\t\t\t\t\tValue: value,\n\t\t\t\t\tTimestamp: timestamp,\n\t\t\t\t\tDuration: duration,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.78145477555873}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, name string, channel uint32, id uint32) {\n\t\tif duration == 0 {\n\t\t\treturn\n\t\t}\n\t\tif pin == d.triggerPin {\n\t\t\td.startTimestamp = time.Now()\n\t\t} else if pin == d.echoPin {\n\t\t\td.duration = duration\n\t\t\td.channel <- d.duration\n\t\t\td.startTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.32222262097582}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Duration\n\n\treturn func(pin int, duration time.Duration, event string, channel uint32, timestamp uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstartTimestamp = time.Duration(timestamp)\n\t\t} else if event == \"falling\" {\n\t\t\td.sendDuration(channel, startTimestamp, timestamp)\n\t\t}\n\t}\n}", "CodeBleu_score": 40.928663726646604}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\td.emitTrigger()\n\tselect {\n\tcase <-d.timeoutChan:\n\t\treturn fmt.Errorf(\"Timeout while measuring distance\")\n\tcase <-d.measureChan:\n\t\treturn nil\n\t}\n}", "CodeBleu_score": 31.657297016366275}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\tselect {\n\tcase <-d.timeout:\n\t\treturn fmt.Errorf(\"timeout\")\n\tcase <-d.measurementComplete:\n\t\treturn nil\n\t}\n}", "CodeBleu_score": 30.313637094115464}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\td.emitTrigger()\n\tselect {\n\tcase <-d.measureComplete:\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout occurred while measuring distance\")\n\t}\n}", "CodeBleu_score": 29.135696358025363}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    token = self.get_state_item(\"token\")\n    if token:\n        if token[\"expires_at\"] > time.time():\n            return token[\"access_token\"]\n        else:\n            if self.get_state_item(\"refresh_token\"):\n                return self.refresh_authentication_token()\n            else:\n                raise AccountNotAuthorized()\n    else:\n        return self.fetch_authentication_token_from_env()\n\n", "CodeBleu_score": 23.75216636184164}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        token = os.environ[\"TOKEN\"]\n        expiration = os.environ[\"EXPIRATION\"]\n        return token, expiration\n    except KeyError:\n        try:\n            token = self.get_state_item(\"token\")\n            expiration = self.get_state_item(\"expiration\")\n            if time.time() > expiration:\n                raise AccountNotAuthorized\n            return token, expiration\n        except KeyError:\n            try:\n                refresh_token = self.get_state_item(\"refresh_token\")\n                if refresh_token is None:\n                    raise AccountNotAuthorized\n                token, expiration = self.fetch_new_token(refresh_token)\n                self.set_state_item(\"token\", token)\n                self.set_state_item(\"expiration\", expiration)\n                return token, expiration\n            except KeyError:\n                raise AccountNotAuthorized\n\n", "CodeBleu_score": 41.03211168926501}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return self.get_state_item(\"authentication_token\")\n    except KeyError:\n        pass\n    try:\n        access_token = self.get_state_item(\"access_token\")\n        expiration_time = self.get_state_item(\"expiration_time\")\n        if expiration_time > time.time():\n            return access_token\n    except KeyError:\n        pass\n    try:\n        refresh_token = self.get_state_item(\"refresh_token\")\n        access_token, expiration_time = self.fetch_access_token(refresh_token)\n        self.set_state_item(\"access_token\", access_token)\n        self.set_state_item(\"expiration_time\", expiration_time)\n        return access_token\n    except KeyError:\n        pass\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 35.70505813162481}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(self.get_url(\"/v1/logout\"), method=\"POST\", data={\"refresh_token\": self.refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 44.66673309157038}, {"code": "def logout(self)\n\t\n    self.get_refresh_token\n    self.delete_local_session\n    try:\n        self.fetch_json_data(\n            \"/v1/logout\",\n            method=\"POST\",\n            headers={\"Authorization\": f\"Bearer {self.refresh_token}\"},\n        )\n    except AccountError:\n        pass\n\n", "CodeBleu_score": 37.525025490345776}, {"code": "def logout(self)\n\t\n    self.get_refresh_token\n    self.delete_local_session\n    try:\n        self.fetch_json_data(\n            url=f\"{self.api_url}/v1/logout\",\n            method=\"POST\",\n            headers={\n                \"Authorization\": f\"Bearer {self.refresh_token}\",\n                \"Content-Type\": \"application/json\",\n            },\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 38.25557664127021}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.get_packages():\n        if pkg.is_optional:\n            continue\n        result.append(self.get_package_info(pkg))\n    return result\n\n", "CodeBleu_score": 17.92481819872}, {"code": "def dump_used_packages(self)\n\t\n    result", "CodeBleu_score": 0.4356724253697368}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.get_packages():\n        if pkg.is_optional:\n            continue\n        if pkg.is_external:\n            result.append({'name': pkg.name,'version': pkg.version,'source': pkg.source})\n        else:\n            result.append({'name': pkg.name,'version': pkg.version})\n    return result\n\n", "CodeBleu_score": 26.05545666129589}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls.new()\n    if env not in p.env_platforms:\n        raise UndefinedEnvPlatformError(env)\n    p.configure_project_packages(env, targets, autoinstall)\n    return p\n", "CodeBleu_score": 26.84947653308203}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls.new()\n    p.configure_project_packages(env, targets, autoinstall)\n    return p\n\n", "CodeBleu_score": 10.826488530415515}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    # cls.new\n    # UndefinedEnvPlatformError\n    # config.get\n    # ProjectConfig.get_instance\n    # p.configure_project_packages\n\n    # cls.new\n    # UndefinedEnvPlatformError\n    # config.get\n    # ProjectConfig.get_instance\n    # p.configure_project_packages\n    pass\n\n", "CodeBleu_score": 5.2564102564107245}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\n\tWire1.requestFrom(0x34, Size);\n\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 73.56846672699541}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef ESP32\n    if (time_in_us == 0) {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    } else {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    }\n    esp_deep_sleep_start();\n#endif\n}", "CodeBleu_score": 56.88090270195869}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef DEBUG\n    Serial.println(\"DeepSleep\");\n#endif\n    SetSleep();\n    if (time_in_us!= 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 44.735682165321}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef DEBUG\n    Serial.println(\"DeepSleep\");\n#endif\n\n    SetSleep();\n\n    if (time_in_us!= 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 60.16714163590725}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint16_t old_y = y;\n\tif (y > tft.height() - tft.height() / 8 - 1) {\n\t\ty = tft.height() - tft.height() / 8 - 1;\n\t\tscrollAddress(y);\n\t} else {\n\t\ty += tft.height() / 8;\n\t\tscrollAddress(y);\n\t}\n\ttft.fillRect(0, old_y, tft.width(), tft.height() / 8, color);\n\treturn old_y;\n}", "CodeBleu_score": 16.455333016679376}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tuint16_t y = tft.getCursorY();\n\ttft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n\tif (y >= tft.height() - tft.fontHeight()) {\n\t\ty = 0;\n\t} else {\n\t\ty += tft.fontHeight();\n\t}\n\tscrollAddress(y);\n\treturn y;\n}", "CodeBleu_score": 13.087945385599536}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tuint16_t x1 = 0;\n\tuint16_t y1 = 0;\n\tuint16_t x2 = tft.width();\n\tuint16_t y2 = tft.height();\n\tuint16_t y_old = 0;\n\tuint16_t y_new = 0;\n\n\ty_old = tft.getScroll();\n\ty_new = y_old + tft.fontHeight();\n\tif (y_new >= tft.height() - tft.fixed_height) {\n\t\ty_new = 0;\n\t}\n\ttft.setScroll(y_new);\n\ttft.fillRect(x1, y1, x2, y2, color);\n\treturn y_old;\n}", "CodeBleu_score": 18.302358434006567}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// Check if the setup was successful\n\tif (!this->setupAP(ssids, access_points)) {\n\t\treturn false;\n\t}\n\n\t// Check if the HTML content was set up correctly\n\tif (!this->setupHtml()) {\n\t\treturn false;\n\t}\n\n\t// Start the portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 66.12631325866059}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\n#ifdef ESP8266\n  WiFi.mode(WIFI_AP_STA);\n#endif\n\n  if (this->setAP(ssids, access_points)) {\n    if (this->setHtml()) {\n      this->startPortal();\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 60.40143043553113}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// set up access points\n\tif (!this->setAP(ssids, access_points)) {\n\t\treturn false;\n\t}\n\n\t// set up html content\n\tif (!this->setHtml()) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 72.53253761233728}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\treturn;\n\t}\n\tthis->flush_queue();\n\tthis->queue_enabled_flag = true;\n}", "CodeBleu_score": 13.481294462124222}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tthis->flush_queue();\n\t\tthis->init_queue();\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 21.65421149748323}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (gps_queue!= NULL) {\n\t\t\tgps_queue->init();\n\t\t}\n\t\tif (gps_text!= NULL) {\n\t\t\tgps_text->init();\n\t\t}\n\t\tif (gps_text_in!= NULL) {\n\t\t\tgps_text_in->init();\n\t\t}\n\t} else {\n\t\tflush_queue();\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 13.237957250727131}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea!= NULL) {\n\t\tthis->queue_nmea->clear();\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = new std::queue<char*>();\n\t} else {\n\t\tthis->queue_nmea = new std::queue<char*>();\n\t}\n}", "CodeBleu_score": 20.489843200417525}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue!= NULL) {\n\t\tdelete this->queue;\n\t\tthis->queue = new std::queue<std::string>();\n\t} else {\n\t\tthis->queue = new std::queue<std::string>();\n\t}\n}", "CodeBleu_score": 18.221620878206153}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea!= NULL) {\n\t\tdelete this->queue_nmea;\n\t}\n\tthis->queue_nmea = new Queue<NmeaSentence *>();\n}", "CodeBleu_score": 15.10058928348609}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n//    uint16_t x1 = area->x1;\n//    uint16_t y1 = area->y1;\n//    uint16_t x2 = area->x2;\n//    uint16_t y2 = area->y2;\n//    uint16_t w = x2 - x1 + 1;\n//    uint16_t h = y2 - y1 + 1;\n//    uint16_t i = 0;\n//    uint16_t j = 0;\n//    uint16_t x = 0;\n//    uint16_t y = 0;\n//    uint16_t color = 0;\n//    uint16_t *ptr = (uint16_t *)color_p;\n//\n//    /*Start the write transaction*/\n//    display_obj.tft.startWrite();\n//\n//    /*Set the address window to the specified area*/\n//    display_obj.tft.setAddrWindow(x1, y1, w, h);\n//\n//    /*Write all colors from the color buffer to the display*/\n//    for (y = y1; y <= y2; y++) {\n//        for (x = x1; x <= x2; x++) {\n//            color = ptr[i++];\n//            display_obj.tft.writeColor(color);\n//        }\n//    }\n//\n//    /*End the write transaction*/\n//    display_obj.tft.endWrite();\n//\n//    /*Notify the display that flushing is done*/\n//    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 3.2744141345528126}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint16_t x, y;\n\tuint16_t w = area->x2 - area->x1 + 1;\n\tuint16_t h = area->y2 - area->y1 + 1;\n\tdisplay_obj.tft.startWrite();\n\tdisplay_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tdisplay_obj.tft.writeColor(color_p->full);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\tdisplay_obj.tft.endWrite();\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 57.91517222610797}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->list->size; i++) {\n\t\tMenuNode * node = menu->list->get(i);\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.println(node->name);\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 60.098036635177856}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tSerial.print(\"Menu: \");\n\tSerial.println(menu->name);\n\tSerial.print(\"Layer: \");\n\tSerial.println(layer);\n\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\" \");\n\t\t}\n\t\tSerial.println(menu->list->get(i)->name);\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 67.05130952062835}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t", "CodeBleu_score": 3.1791339452368352}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t", "CodeBleu_score": 1.5471157130300377}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint numSSIDs = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += random(65, 90);\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac += random(0, 9);\n\t\t}\n\t\tmac += \":\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac += random(0, 9);\n\t\t}\n\t\tmac += \":\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac += random(0, 9);\n\t\t}\n\t\tmac += \":\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac += random(0, 9);\n\t\t}\n\t\tmac += \":\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac += random(0, 9);\n\t\t}\n\t\tmac += \":\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac += random(0, 9);\n\t\t}\n\t\tSerial.print(\"Generated SSID: \");\n\t\tSerial.println(ssid);\n\t\tSerial.print(\"Generated MAC: \");\n\t\tSerial.println(mac);\n\t\tSerial.print(\"Generated Channel: \");\n\t\tSerial.println(channel);\n\t\tssids->add(new WiFiScanData(ssid, mac, channel));\n\t\tnumSSIDs++;\n\t}\n\treturn numSSIDs;\n}", "CodeBleu_score": 44.106359777675976}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t", "CodeBleu_score": 1.5471157130300377}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    now = datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    return jwt.encode(\n        payload,\n        open(private_key_file).read(),\n        algorithm=algorithm).decode('utf-8')\n", "CodeBleu_score": 25.86104802211708}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        \"iss\": project_id,\n        \"aud\": project_id,\n        \"iat\": datetime.datetime.utcnow(),\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 49.44799431534482}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    try:\n        with open(private_key_file, 'r') as f:\n            private_key = json.load(f)['private_key']\n    except IOError:\n        print('Error: cannot read the private key file.')\n        return ''\n    else:\n        token = {\n            'iss': project_id,\n            'aud': project_id,\n            'iat': datetime.utcnow(),\n            'exp': datetime.utcnow() + datetime.timedelta(hours=1)\n        }\n        return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 54.571779772112116}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received a new message on topic {} with Qos {}'.format(\n            message.topic, message.qos))\n    print('Message is {}'.format(message.payload))\n    if message.payload == b'on':\n        print('Turning on')\n        preview_capture('image.jpg')\n        blob_url = upload_file('image.jpg', args.bucket_name)\n        unused_client.publish('events', blob_url)\n        print('Published message: {}'.format(blob_url))\n    else:\n        print('Turning off')", "CodeBleu_score": 31.69312234760876}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with QOS {}'.format(\n        message.payload, message.topic, str(message.qos)))\n    if message.payload.decode('utf-8') == 'on':\n        path = 'image.jpg'\n        preview_capture(path)\n        url = upload_file(path, bucket_name)\n        unused_client.publish('events/image', url)\n    else:\n        print('off')\n", "CodeBleu_score": 33.961905923482824}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode('utf-8'))\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        path = '/home/pi/Desktop/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, BUCKET_NAME)\n        unused_client.publish(MQTT_EVENT_TOPIC, url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 36.9229995069208}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser", "CodeBleu_score": 0.7333049639345527}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Your Google Cloud Platform project ID.',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument(\n        '--region',\n        help='The region to which the MQTT connection should be made.',\n        default='us-central1')\n    parser.add_argument(\n        '--registry_id',\n        help='The registry to which the MQTT connection should be made.',\n        default='registry-001')\n    parser.add_argument(\n        '--device_id',\n        help='The device to which the MQTT connection should be made.',\n        default='device-001')\n    parser.add_argument(\n        '--sub_id',\n        help='The subscription to which the MQTT connection should be made.',\n        default='sub-001')\n    parser.add_argument(\n        '--num_messages',\n        help='The number of messages to publish.',\n        default=10)\n    parser.add_argument(\n        '--message_type',\n        help='The type of message to publish.',\n        choices=['text', 'binary'],\n        default='text')\n    parser.add_argument(\n        '--message_count',\n        help='The number of messages to publish.',\n        default=10)\n    parser.add_argument(\n        '--message_size',\n        help='The size of each message to publish.',\n        default=1024)\n    parser.add_argument(\n        '--message_rate',\n        help='The rate at which to publish messages.',\n        default=10)\n    parser.add_argument(\n        '--message_interval',\n        help='The interval between messages.',\n        default=1)\n    parser.add_argument(\n        '--message_payload',\n        help='The payload of the message to publish.',\n        default='Hello World!')\n    parser.add_argument(\n        '--message_payload_file',\n        help='The file containing the payload of the message to publish.',\n        default=None)\n    parser.add_argument(\n        '--message_payload_file_type',\n        help='The type of the file containing the payload of the message to publish.',\n        choices=['text', 'binary'],\n        default='text')\n    parser.add_argument(\n        '--message_payload_file", "CodeBleu_score": 32.21566895972294}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument('--project_id', help='ID of the project that the device is part of', default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument('--subscription_name', help='Name of the subscription to listen to', required=True)\n    parser.add_argument('--algorithm', help='Algorithm used to sign the JWT token', default='RS256')\n    parser.add_argument('--private_key_file', help='Path to private key file.', default=os.path.join(os.path.dirname(__file__), 'rsa_private.pem'))\n    parser.add_argument('--algorithm', help='Algorithm used to sign the JWT token', default='RS256')\n    parser.add_argument('--token_lifetime', help='Lifetime of the JWT token in seconds', type=int, default=3600)\n    parser.add_argument('--num_messages', help='Number of messages to receive before exiting', type=int, default=1000)\n    parser.add_argument('--verbose', help='Enable verbose logging', action='store_true')\n    return parser.parse_args()\n", "CodeBleu_score": 38.65121048078806}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = ServiceAccountCredentials.from_service_account_file(service_account_json, scopes=scopes)\n    credentials = credentials.with_scopes(scopes)\n    return discovery.build(\"cloudiot\", version, credentials=credentials, discoveryServiceUrl=discovery_url)\n", "CodeBleu_score": 20.191811205017952}, {"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    credentials = ServiceAccountCredentials.from_service_account_file(service_account_json, scopes=scopes)\n    credentials = credentials.with_scopes(scopes)\n    return discovery.build('cloudiot', version, credentials=credentials, discoveryServiceUrl=discovery_url)\n", "CodeBleu_score": 20.77881897994733}, {"code": "def get_client(service_account_json)\n\t\n    credentials = ServiceAccountCredentials.from_service_account_file(service_account_json)\n    credentials = credentials.with_scopes(SCOPES)\n    discovery = build(\n        \"cloudiot\", \"v1\", credentials=credentials, discoveryServiceUrl=DISCOVERY_URL\n    )\n    return discovery\n", "CodeBleu_score": 10.835966473243941}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t  if hash_method =='sha1':\n        hash_method_asn1 = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method =='sha256':\n        hash_method_asn1 = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    else:\n        raise ValueError('Unknown hash method: %s' % hash_method)\n\n    return _pad_for_signing(hash_method_asn1 + hash_value, 128) + priv_key.blinded_encrypt(\n        _pad_for_signing(hash_method_asn1 + hash_value, 128))\n", "CodeBleu_score": 25.527770269738774}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   hash_method_asn1 = hash_method.get_asn1()\n    if hash_method_asn1 is None:\n        raise ValueError('Invalid hash method')\n    hash_value_with_method = b''.join([hash_method_asn1, hash_value])\n    padded_hash_value = _pad_for_signing(hash_value_with_method, 32)\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash_value)\n    return encrypted_signature\n\n", "CodeBleu_score": 33.42131261945141}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   if hash_method =='sha256':\n        hash_method_asn1 = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method =='sha512':\n        hash_method_asn1 = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Unsupported hash method: %s' % hash_method)\n\n    return _pad_for_signing(hash_method_asn1 + hash_value, 64)\n\n", "CodeBleu_score": 21.424263784375817}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t  clearsig = pub_key.decrypt(signature)\n    method_name = _find_method_hash(clearsig)\n    hash_value = compute_hash(message, method_name)\n    expected_hash = _pad_for_signing(hash_value, len(clearsig))\n\n    if clearsig!= expected_hash:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 20.111967629667195}, {"code": "def verify(message, signature, pub_key)\n\t  if not isinstance(message, bytes):\n        raise TypeError('message must be a bytes object')\n\n    if not isinstance(signature, bytes):\n        raise TypeError('signature must be a bytes object')\n\n    if not isinstance(pub_key, bytes):\n        raise TypeError('public key must be a bytes object')\n\n    clearsig = core.decrypt_int(signature, pub_key)\n\n    method_name = _find_method_hash(clearsig)\n\n    hash_of_message = compute_hash(message, method_name)\n\n    expected_hash = _pad_for_signing(hash_of_message, common.byte_size(clearsig))\n\n    if expected_hash!= clearsig:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 47.17479051494155}, {"code": "def verify(message, signature, pub_key)\n\t  clearsig = core.decrypt_int(signature, pub_key)\n    method_name = _find_method_hash(clearsig)\n    hash_message = compute_hash(message, method_name)\n    expected_hash = _pad_for_signing(hash_message, HASH_ASN1[method_name])\n\n    if clearsig!= expected_hash:\n        raise VerificationError('Verification failed')\n\n    return method_name\n\n", "CodeBleu_score": 21.619791839250976}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t t;\n\tstruct tm *tm;\n\tuint32_t epoch;\n\n\ttime(&t);\n\ttm = localtime(&t);\n\tepoch = mktime(tm);\n\tif (epoch!= -1) {\n\t\tupdateJWT(epoch);\n\t}\n\n\tMQTT_CLIENT_connect(mqttClient, mqttHost, mqttPort, mqttUsername, mqttPassword, mqttTopic, cid, mqtt_callback, mqtt_subscribe);\n}", "CodeBleu_score": 36.41813517045348}, {"code": "static void connectMQTT(){\n\t\tdebug_printInfo(\"MQTT: Connecting...\");\n\ttime_t t = time(NULL);\n\tif (t == -1) {\n\t\tdebug_printError(\"MQTT: Failed to retrieve current time\");\n\t} else {\n\t\tupdateJWT(t);\n\t}\n\tdebug_printInfo(\"MQTT: Connecting to %s:%d\", mqttHost, mqttPort);\n\tint res = MQTT_CLIENT_connect(mqttHost, mqttPort, mqttUsername, mqttPassword);\n\tif (res == 0) {\n\t\tdebug_printInfo(\"MQTT: Connected\");\n\t\tmqtt_connected = 1;\n\t\tmqtt_subscribe = 1;\n\t} else {\n\t\tdebug_printError(\"MQTT: Failed to connect\");\n\t}\n}", "CodeBleu_score": 43.936939604085715}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch == 0) {\n\t\tdebug_printError(\"MQTT: time() error\");\n\t\treturn;\n\t}\n\tupdateJWT(epoch);\n\tMQTT_CLIENT_connect(cid, mqttTopic, mqttPassword, 1, 1);\n\tmqttConnected = 1;\n\tdebug_printInfo(\"MQTT: connected\");\n}", "CodeBleu_score": 48.821334388877744}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tvalue = value * 10 + (str[i] - '0');\n\t}\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 26.342415643378075}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t val = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tval = val * 10 + (str[i] - '0');\n\t}\n\t*num = val;\n\treturn str + width;\n}", "CodeBleu_score": 26.270626522392345}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (!isdigit(str[i])) {\n\t\t\treturn str;\n\t\t}\n\t\tresult *= 10;\n\t\tresult += str[i] - '0';\n\t}\n\t*num = result;\n\treturn str + width;\n}", "CodeBleu_score": 25.858788659242528}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t = 0;\n\tsize_t cert_size = 0;\n\tuint8_t* cert = NULL;\n\n\tif (build_state == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\t// Check if we are in the middle of a build\n\tif (build_state->build_state!= ATCACERT_BUILD_STATE_BUILDING) {\n\t\treturn ATCACERT_E_BAD_STATE;\n\t}\n\n\t// Check if the cert is already built\n\tif (build_state->cert!= NULL) {\n\t\treturn ATCACERT_E_BAD_STATE;\n\t}\n\n\t// Check if there is enough room for the certificate\n\tcert_size = build_state->cert_size;\n\tif (cert_size < build_state->cert_size_min) {\n\t\treturn ATCACERT_E_BUFFER_TOO_SMALL;\n\t}\n\n\t// Allocate the certificate\n\tcert = (uint8_t*) malloc(cert_size);\n\tif (cert == NULL) {\n\t\treturn ATCACERT_E_OUT_OF_MEMORY;\n\t}\n\n\t// Build the certificate\n\tret = atcacert_build_cert(build_state, cert, cert_size);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\tfree(cert);\n\t\treturn ret;\n\t}\n\n\t// Set the certificate\n\tbuild_state->cert = cert;\n\tbuild_state->cert_size = cert_size;\n\n\t// Set the build state\n\tbuild_state->build_state = ATCACERT_BUILD_STATE_BUILT;\n\n\treturn ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 55.51001451573454}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\n\tif (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ATCA_SUCCESS;\n}", "CodeBleu_score": 68.20977512629703}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tsize_t tbs_digest_size = 32;\n\tsize_t signature_size = 64;\n\tuint8_t* cert_ptr = (uint8_t*)cert;\n\n\t// Check for null parameters\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\t// Get the TBS digest\n\tret = atcacert_get_tbs_digest(cert_def, cert_ptr, cert_size, tbs_digest, &tbs_digest_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\tgoto exit;\n\t}\n\n\t// Get the signature\n\tret = atcacert_get_signature(cert_def, cert_ptr, cert_size, signature, &signature_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\tgoto exit;\n\t}\n\n\t// Verify the TBS digest against the signature\n\tret = atcab_verify_extern(tbs_digest, tbs_digest_size, signature, signature_size, ca_public_key);\n\nexit:\n\treturn ret;\n}", "CodeBleu_score": 56.35690122425634}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *p = list;\n\twhile(*p!= NULL)\n\t{\n\t\tif(*p == timer)\n\t\t{\n\t\t\t*p = (*p)->next;\n\t\t\treturn true;\n\t\t}\n\t\tp = &(*p)->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 17.36016620347232}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t#line 111 \"timeout.c\"\n\tif (list == NULL) {\n\t\treturn false;\n\t}\n\tif (*list == NULL) {\n\t\treturn false;\n\t}\n\tif (timer == NULL) {\n\t\treturn false;\n\t}\n\tif (*list == timer) {\n\t\t*list = timer->next;\n\t\treturn true;\n\t}\n\ttimerStruct_t *temp = *list;\n\twhile (temp!= NULL) {\n\t\tif (temp->next == timer) {\n\t\t\ttemp->next = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 34.641535328911466}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t", "CodeBleu_score": 4.569190813842367}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tint\ts8Ret = BSD_ERROR;\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ts8Ret = close(socket);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = BSD_ERROR;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts8Ret = BSD_SUCCESS;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 26.21853512792211}, {"code": "int BSD_close(int socket){\n\tint ret = BSD_SUCCESS;\n\tif (socket < 0 || socket > MAX_SOCKETS) {\n\t\treturn BSD_ERROR;\n\t}\n\tif (gastrSockets[socket].bIsUsed == 1) {\n\t\tgastrSockets[socket].bIsUsed = 0;\n\t\tgastrSockets[socket].u16SessionID = 0;\n\t\tif (gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE) {\n\t\t\tret = close(socket);\n\t\t\tif (ret!= 0) {\n\t\t\t\tret = BSD_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tret = close(socket);\n\t\t\tif (ret!= 0) {\n\t\t\t\tret = BSD_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 38.67089785764727}, {"code": "int BSD_close(int socket){\n\tint ret = BSD_SUCCESS;\n\tint ret_val = 0;\n\tif (socket < 0 || socket >= MAX_SOCKETS) {\n\t\tret = BSD_ERROR;\n\t\tret_val = BSD_EBADF;\n\t\tgoto error;\n\t}\n\tif (gastrSockets[socket].bIsUsed == 0) {\n\t\tret = BSD_ERROR;\n\t\tret_val = BSD_EBADF;\n\t\tgoto error;\n\t}\n\tif (gastrSockets[socket].bIsUsed == 1) {\n\t\tret = close(socket);\n\t\tif (ret < 0) {\n\t\t\tret = BSD_ERROR;\n\t\t\tret_val = BSD_EBADF;\n\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn ret_val;\n}", "CodeBleu_score": 36.47430720474482}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint s8Ret = BSD_ERROR;\n\tint s32Ret = listen(socket, backlog);\n\tif(s32Ret == SOCK_ERR_NO_ERROR)\n\t{\n\t\ts8Ret = BSD_SUCCESS;\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(s32Ret);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 24.967159669205085}, {"code": "int BSD_listen(int socket, int backlog){\n\tint ret = BSD_ERROR;\n\tif (socket >= 0) {\n\t\tif (listen(socket, backlog) == 0) {\n\t\t\tret = BSD_SUCCESS;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 18.445145587751067}, {"code": "int BSD_listen(int socket, int backlog){\n\t", "CodeBleu_score": 4.893994777977414}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t", "CodeBleu_score": 2.7552018946369774}, {"code": "static void connectMQTT(){\n\t\ttime_t t = time(NULL);\n\tif (t == -1) {\n\t\tdebug_printError(\"MQTT: Failed to get the current time\");\n\t\treturn;\n\t}\n\tuint32_t epoch = (uint32_t)t + UNIX_OFFSET;\n\tupdateJWT(epoch);\n\tif (MQTT_CLIENT_connect(cid, mqttTopic, mqttPassword, epoch) == 0) {\n\t\tdebug_printInfo(\"MQTT: Connected to MQTT broker\");\n\t\tsendSubscribe = 1;\n\t}\n}", "CodeBleu_score": 48.1886244268522}, {"code": "static void connectMQTT(){\n\t", "CodeBleu_score": 2.7552018946369774}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tMQTT_Disconnect(mqttContext);\n\tdebug_printError(MQTT_GetConnectionState(mqttContext));\n}", "CodeBleu_score": 37.1171230190016}, {"code": "void CLOUD_disconnect(void){\n\t\tMQTT_Disconnect(mqttContext);\n\tdebug_printError(\"Disconnected from the cloud service\");\n}", "CodeBleu_score": 15.370827088837954}, {"code": "void CLOUD_disconnect(void){\n\t#if DEBUG_PRINT\n   debug_printError(DEBUG_PRINT_MQTT_DISCONNECT);\n#endif\n\n   MQTT_Disconnect(mqttContext);\n\n}", "CodeBleu_score": 37.49262635943562}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tsint8 ret;\n\tif (passed_wifi_creds) {\n\t\tret = m2m_wifi_connect_sc(wifi_ssid, strlen(wifi_ssid), wifi_auth, (void*)wifi_pass, wifi_ch, 0);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret == M2M_SUCCESS) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.84477737899346}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds) {\n\t\treturn m2m_wifi_connect(wifi_creds.ssid, strlen((char*)wifi_creds.ssid), wifi_creds.authType, wifi_creds.authInfo, wifi_creds.channel);\n\t} else {\n\t\treturn m2m_wifi_default_connect();\n\t}\n}", "CodeBleu_score": 31.159891608801505}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tsole.log(\"DisplaySensors\")\nconsole.log(\"map\")\nconsole.log(map)\nconst client = new GraphQLClient('https://api.spacex.land/graphql/', {\n    headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n    }\n})\nconst response = await client.request(`\nquery {\n    listSensors {\n        id\n        name\n        geo {\n            longitude\n            latitude\n        }\n    }\n}\n`)\nconsole.log(\"response\")\nconsole.log(response)\nif (response.data.listSensors) {\n    console.log(\"Retrieved sensors\")\n    response.data.listSensors.forEach(sensor => {\n        const marker = document.createElement('div')\n        marker.className ='marker'\n        const popup = new Mapboxgl.Popup({ offset: 25 })\n       .setHTML(`<h3>${sensor.name}</h3>`)\n       .addTo(map)\n        new Marker({element: marker})\n       .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n       .addTo(map)\n    })\n}\n}", "CodeBleu_score": 50.34637616641208}, {"code": "async function DisplaySensors(map){\n\t Create a client\nconst client = new GraphQLClient(API_URL, {\n  headers: {\n    authorization: API_KEY,\n  },\n});\n\n// Send a GraphQL query to fetch sensor data\nconst query = `\nquery {\n  listSensors {\n    id\n    name\n    geo {\n      longitude\n      latitude\n    }\n  }\n}\n`;\n\n// Execute the query\nconst response = await client.request(query);\n\n// Log the response\nconsole.log(response);\n\n// If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\nif (response.data) {\n  console.log(\"Retrieved sensors:\");\n  response.data.listSensors.forEach((sensor) => {\n    console.log(sensor);\n    const marker = document.createElement(\"div\");\n    marker.className = \"marker\";\n    new Marker({element: marker})\n     .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n     .addTo(map);\n  });\n}\n}", "CodeBleu_score": 50.912443265744756}, {"code": "async function DisplaySensors(map){\n\tnst client = new GraphQLClient(\n\"https://api.openaq.org/graphql\",\n{ headers: { \"x-api-key\": \"\" } }\n);\n\nconst response = await client.request(`\n{\nlistSensors {\nid\nlocation\ngeo {\nlatitude\nlongitude\n}\n}\n}\n`);\n\nconsole.log(\"Retrieved sensors:\", response.data.listSensors);\n\nresponse.data.listSensors.forEach(sensor => {\nconst marker = document.createElement(\"div\");\nmarker.className = \"marker\";\n\nconst popup = new Popup({\ncloseOnClick: false,\ncloseButton: false,\n});\n\nconst markerPopup = new Marker({\nelement: marker,\npopup: popup,\n});\n\nmarkerPopup.setLngLat([sensor.geo.longitude, sensor.geo.latitude]);\nmarkerPopup.addTo(map);\n\npopup.setHTML(\n`<div class=\"popup-content\">\n<h3>${sensor.id}</h3>\n<p>${sensor.location}</p>\n</div>`\n);\n});\n}", "CodeBleu_score": 38.7147590060656}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 45.92688717795596}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 45.92688717795596}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 45.95514478587068}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    _LOGGER.debug(\"Loading MFA module: %s\", module_name)\n    module_path = module_name.replace(\".\", \"/\")\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as ex:\n        raise HomeAssistantError(\n            f\"Failed to load MFA module {module_name}: {ex}\"\n        ) from ex\n    except Exception as ex:\n        raise HomeAssistantError(\n            f\"Failed to load MFA module {module_name}: {ex}\"\n        ) from ex\n    if module.REQUIREMENTS:\n        try:\n            await hass.async_process_requirements(\n                module.REQUIREMENTS,\n                module_name,\n                skip_pip_install=module.SKIP_PIP_INSTALL,\n            )\n        except HomeAssistantError as ex:\n            raise HomeAssistantError(\n                f\"Failed to load MFA module {module_name}: {ex}\"\n            ) from ex\n    return module", "CodeBleu_score": 34.51680779466037}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    _LOGGER.debug(\"Loading MFA module %s\", module_name)\n    module_path = module_name.replace(\".\", \"/\") + \".py\"\n    try:\n        module = await async_import_module(hass, module_name)\n    except ModuleNotFoundError as ex:\n        _LOGGER.error(\"Error importing MFA module %s: %s\", module_name, ex)\n        raise ex\n    except Exception as ex:\n        _LOGGER.error(\"Error importing MFA module %s: %s\", module_name, ex)\n        raise ex\n    return module", "CodeBleu_score": 30.354769403691286}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as ex:\n        _LOGGER.error(\"Unable to import %s\", module_path)\n        raise ex\n    except Exception as ex:\n        _LOGGER.error(\"Unable to import %s\", module_path)\n        raise ex from None\n    if hasattr(module, \"REQUIREMENTS\"):\n        requirements = getattr(module, \"REQUIREMENTS\")\n        if requirements:\n            if not hass.config.skip_pip:\n                await requirements.async_process_requirements(hass, requirements)\n    return module\n", "CodeBleu_score": 40.929226699169874}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id not in self._data:\n        self._data[user_id] = setup_data\n    else:\n        self._data[user_id].update(setup_data)\n    return True\n\n\n", "CodeBleu_score": 25.4751605710825}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    self.log.info(\"Setting up user with id %s\", user_id)\n    if self._check_user_in_data(user_id):\n        self.log.info(\"User with id %s already exists in data list\", user_id)\n        self.log.debug(\"Updating user with id %s\", user_id)\n        self._update_user_pin(user_id, setup_data)\n    else:\n        self.log.info(\"User with id %s does not exist in data list\", user_id)\n        self.log.debug(\"Adding user with id %s\", user_id)\n        self._add_user_to_data(user_id, setup_data)\n    self.log.info(\"User with id %s setup completed\", user_id)\n    return True\n\n\n\n\n", "CodeBleu_score": 29.09977499085122}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id not in self.data:\n        self.data[user_id] = setup_data\n        return\n    self.data[user_id] = setup_data\n\n", "CodeBleu_score": 24.788956513775908}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if not self._lock.acquire(blocking=False):\n        return\n    if self._data is None:\n        self._data = {}\n        for user in self._store.data:\n            self._data[user] = NotifySetting(user, self._store.data[user])\n    self._lock.release()", "CodeBleu_score": 24.638837252372618}, {"code": "async def _async_load(self) -> None\n\t\n    if not self._init_lock.acquire(blocking=False):\n        return\n\n    try:\n        if not self._data:\n            self._data = {}\n\n        for user_id in self._data.keys():\n            if user_id not in self._users:\n                self._users[user_id] = NotifySetting(self._data[user_id])\n    finally:\n        self._init_lock.release()", "CodeBleu_score": 26.91603005373333}, {"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n    with self._lock:\n        if self._initialized:\n            return\n        if not (data := await self._store.async_load()):\n            self._user_settings = {}\n            return\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id,\n                data[\"users\"][user_id][\"name\"],\n                data[\"users\"][user_id][\"notify_on_new_issues\"],\n                data[\"users\"][user_id][\"notify_on_issues_without_activity\"],\n                data[\"users\"][user_id][\"notify_on_issues_without_comments\"],\n            )\n            for user_id in data[\"users\"]\n        }\n\n", "CodeBleu_score": 34.04335613234571}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    return await self.async_get_user_settings(user_id) is not None", "CodeBleu_score": 19.39715642040177}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n        await self.async_load()\n        user_settings = self.async_get_user_settings(user_id)\n        if user_settings is None:\n            return False\n        return await self.async_validate_otp(user_input, user_settings)", "CodeBleu_score": 41.91403933471418}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load()\n    if user_id not in self._states_data:\n        return False\n    return await self._async_validate(user_id, user_input)", "CodeBleu_score": 31.29519187250937}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.390134801419954}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area = area_dict.get(device.area_id)\n    if not area:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 48.57083409156943}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = entity.device\n    if device is None:\n        return None\n    area = area_dict.get(device.area_id)\n    if area is None:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 52.15273241479661}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    return _merge_policies([policy.get(\"categories\") for policy in policies if policy is not None])\n\n", "CodeBleu_score": 10.158557610242122}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    # We have to do this because the types are not properly defined.\n    # We cast to the appropriate type in _merge_policies.\n    return _merge_policies([cast(CategoryType, policy) for policy in policies])\n\n", "CodeBleu_score": 10.90123328989966}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category in seen:\n                continue\n            seen.add(category)\n            policy[category] = _merge_policies([policy[category], value])\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 58.08019974345502}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        return await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(\n            f\"Authentication provider {provider} not found. Please check the configuration and ensure the provider is installed.\"\n        ) from err\n\n", "CodeBleu_score": 17.49214658312831}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(\n            f\"Unable to import authentication provider module {provider}: {err}\"\n        ) from err\n\n    requirements = getattr(module, \"REQUIREMENTS\", None)\n    if not requirements:\n        return module\n\n    processed = getattr(module, \"PROCESSED_REQUIREMENTS\", set())\n    processed.update(requirements)\n\n    async_process_requirements(hass, requirements, processed)\n\n    return module\n\n", "CodeBleu_score": 41.01709974765804}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    _LOGGER.debug(\"Loading authentication provider module %s\", provider)\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Failed to load authentication provider module %s: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Failed to load authentication provider module {provider}: {err}\"\n        ) from err\n    except Exception as err:\n        _LOGGER.error(\n            \"Failed to load authentication provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Failed to load authentication provider module {provider}: {err}\"\n        ) from err\n    requirements = getattr(module, \"REQUIREMENTS\", [])\n    processed = set()\n    if requirements:\n        _LOGGER.debug(\n            \"Processing authentication provider module %s requirements: %s\",\n            provider,\n            requirements,\n        )\n        try:\n            processed = await hass.async_process_requirements(\n                requirements, processed, \"auth\"\n            )\n        except Exception as err:\n            _LOGGER.error(\n                \"Failed to process authentication provider module %s requirements: %s\",\n                provider,\n                err,\n            )\n            raise HomeAssistantError(\n                f\"Failed to process authentication provider module {provider} requirements: {err}\"\n            ) from err\n    return module", "CodeBleu_score": 42.23419175103459}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    self.dummy_hash = \"a\" * 64\n    for user in self.users:\n        if user[\"username\"] == username:\n            self.stored_hash = user[\"password\"]\n            self.stored_hash = base64.b64decode(self.stored_hash)\n            if bcrypt.checkpw(password.encode(), self.stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n        else:\n            bcrypt.checkpw(self.dummy_hash.encode(), self.dummy_hash.encode())\n    raise InvalidAuth(\"Invalid username\")\n", "CodeBleu_score": 40.6277123752705}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy = \"\"\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password\n            if not bcrypt.checkpw(password.encode(), stored_hash):\n                raise InvalidAuth(\"Invalid password.\")\n            break\n    else:\n        if not bcrypt.checkpw(dummy.encode(), dummy.encode()):\n            raise InvalidAuth(\"Invalid username.\")\n        else:\n            raise InvalidAuth(\"Invalid username.\")\n", "CodeBleu_score": 38.90133693122967}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = user[\"password\"]\n            if not bcrypt.checkpw(password.encode(), stored_hash):\n                raise InvalidAuth(\"Invalid password\")\n            return\n    raise InvalidAuth(\"Invalid username\")\n", "CodeBleu_score": 40.48466392616066}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(f\"user_not_found: {username}\")", "CodeBleu_score": 36.803022543766055}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username(username)\n    try:\n        self.users.remove(username)\n    except ValueError:\n        raise InvalidUser(f\"user_not_found: {username}\")", "CodeBleu_score": 22.460196183442587}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(index)\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 35.598833594105635}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    try:\n        self._data = await self._store.async_load()\n    except (FileNotFoundError, json.JSONDecodeError):\n        self._data = None\n    if self._data is None:\n        self._data = {}\n    self._data.pop(credentials.username, None)\n    await self.async_save()", "CodeBleu_score": 45.41597372795208}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    self._data = self._data or {}\n    self._data.pop(credentials.username, None)\n    await self.async_save()", "CodeBleu_score": 31.95056338487643}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.async_is_initialized():\n        await self.async_initialize()\n    try:\n        await self._store.async_remove_auth(credentials)\n    except Exception:\n        pass\n", "CodeBleu_score": 42.62462212868212}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            timeout_ = timeout\n            if log:\n                timeout_ = 0.0\n            thread.join(timeout_)\n            if thread.is_alive():\n                thread.interrupt()\n                if log:\n                    _log_thread_running_at_shutdown(thread.name, thread.ident)\n            else:\n                joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 46.44903300135383}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if thread.is_alive() and thread.ident:\n            try:\n                thread.join(timeout)\n            except RuntimeError as e:\n                if \"cannot join current thread\" in str(e):\n                    # The thread is no longer alive.\n                    joined.add(thread)\n                else:\n                    raise\n            else:\n                joined.add(thread)\n        else:\n            joined.add(thread)\n\n    if log and not joined:\n        _LOGGER.warning(\n            \"All threads are dead or have no identifier, so no threads were joined.\"\n        )\n\n    for thread in threads - joined:\n        try:\n            async_raise(thread.ident, SystemExit)\n        except ValueError:\n            pass\n\n    return joined\n\n", "CodeBleu_score": 41.22957680028049}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        try:\n            timeout_ = timeout / len(threads)\n            thread.join(timeout=timeout_)\n        except Exception:\n            pass\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            try:\n                async_raise(thread.ident, SystemExit)\n            except ValueError:\n                pass\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 58.690547797230316}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    non_main_threads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon]\n    for thread in non_main_threads:\n        timeout = shutdown_timeout / len(non_main_threads)\n        try:\n            thread.join(timeout)\n        except Exception:\n            _LOGGER.warning(\"Unable to join thread %s\", thread.name)", "CodeBleu_score": 32.25606745365016}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = threading.enumerate()\n    non_main_threads = [t for t in threads if t.is_alive() and t is not threading.current_thread() and not t.daemon]\n    total_timeout = shutdown_timeout\n    if non_main_threads:\n        timeout = total_timeout / len(non_main_threads)\n    else:\n        timeout = 0\n    for thread in non_main_threads:\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            _LOGGER.warning(\"Failed to join thread %s\", thread)\n\n", "CodeBleu_score": 32.29752552469215}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    _LOGGER.warning(\"Shutting down...\")\n    threads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()]\n    if threads:\n        timeout = shutdown_timeout / len(threads)\n        for thread in threads:\n            _LOGGER.warning(\"Joining thread %s\", thread)\n            thread.join(timeout)\n            if thread.is_alive():\n                _LOGGER.warning(\"Thread %s failed to join within timeout\", thread)\n\n", "CodeBleu_score": 42.744495707599626}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher.send_internal(remaining_with_setup_started)\n    self._async_dispatcher.update_state(remaining_with_setup_started)\n\n @property\n def async_dispatcher(self) -> Dispatcher:\n    \"\"\"The dispatcher used to dispatch signals.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_internal(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send internal signals.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_external(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send external signals.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_internal_with_setup_started(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send internal signals with the setup started.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_external_with_setup_started(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send external signals with the setup started.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_internal_with_setup_finished(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send internal signals with the setup finished.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_external_with_setup_finished(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send external signals with the setup finished.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_internal_with_setup_failed(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send internal signals with the setup failed.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_external_with_setup_failed(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send external signals with the setup failed.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_internal_with_setup_canceled(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send internal signals with the setup canceled.\"\"\"\n    return self._async_dispatcher\n\n @property\n def async_dispatcher_send_external_with_setup_canceled(self) -> Dispatcher:\n    \"\"\"The dispatcher used to send external signals with the setup canceled.\"\"\"\n    return self._async_dispatcher\n\n @", "CodeBleu_score": 43.409513571956644}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n      self._async_dispatcher_send_internal(remaining_with_setup_started)\n      self._async_dispatcher_remaining_with_setup_started = {}\n    else:\n      self._async_dispatcher_remaining_with_setup_started = None\n\n", "CodeBleu_score": 35.77777976709089}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n\n    if remaining_with_setup_started:\n      self._async_dispatcher_send_internal(remaining_with_setup_started)\n      self._async_dispatcher_remaining_with_setup_started = remaining_with_setup_started\n    else:\n      self._async_dispatcher_remaining_with_setup_started = {}\n\n", "CodeBleu_score": 34.791904039020466}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    generate_and_validate(integrations)\n    fp = open(config.path, \"r\", encoding=\"utf-8\")\n    current_content = fp.read()\n    fp.close()\n    if current_content!= generate_and_validate(integrations):\n        config.add_error(\n            \"The bluetooth.py file is not up to date.", "CodeBleu_score": 36.219623384170205}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.config.get(\"bluetooth\"):\n        return\n\n    generate_and_validate(integrations)\n\n    current_content = fp.read()\n    generated_content = generate_and_validate(integrations)\n\n    if current_content!= generated_content:\n        config.add_error(\n            \"The content of bluetooth.py is not up to date. Please run `hass --script check_bluetooth` to update it.\"\n        )", "CodeBleu_score": 40.48961257065944}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if \"bluetooth\" not in config.cache:\n        return\n\n    bluetooth_content = config.cache[\"bluetooth\"]\n\n    if not bluetooth_content:\n        return\n\n    if not integrations:\n        config.add_error(\n            \"The bluetooth.py file is not up to date. Please run the following command to generate it:\n", "CodeBleu_score": 33.93121185850852}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t}\n\tvar e struct {\n\t\tError string `json:\"error\"`\n\t}\n\tif err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.AuthURL); err!= nil {\n\t\tlogger.Error(err.Error())\n\t\treturn err\n\t}\n\tif e.Error!= \"\" {\n\t\tlogger.Error(e.Error)\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\td.ExpiresIn = resp.ExpiresIn\n\td.TokenType = resp.TokenType\n\treturn nil\n}", "CodeBleu_score": 63.774011790363375}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp DropboxTokenResponse\n\tvar e DropboxTokenErrorResponse\n\tif _, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.TokenEndpoint); err!= nil {\n\t\tlogger.Error(err.Error())\n\t\treturn err\n\t}\n\tif e.Error!= \"\" {\n\t\tlogger.Error(e.Error)\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\td.RefreshToken = resp.RefreshToken\n\treturn nil\n}", "CodeBleu_score": 67.74083404624514}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\n\terr := base.RestyClient.R().SetResult(&resp).SetError(&d.Error).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.URL.Token)\n\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 62.395866000040726}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R().\n\t\tSetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.accessToken)).\n\t\tSetQueryParam(\"fields\", \"nextPageToken, files(id, name, mimeType, size, modifiedTime, createdTime, webContentLink, webViewLink, thumbnailLink)\").\n\t\tSetQueryParam(\"pageSize\", \"1000\")\n\tif callback!= nil {\n\t\treq.SetBody(callback.GetBody())\n\t\treq.SetResult(resp)\n\t\treq.SetError(callback.GetError())\n\t}\n\tvar err error\n\tvar respBody []byte\n\tfor {\n\t\trespBody, err = req.Execute(method, url)\n\t\tif err!= nil {\n\t\t\tif err.Error() == \"401 Unauthorized\" {\n\t\t\t\td.refreshToken()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tbreak\n\t}\n\treturn respBody, nil\n}", "CodeBleu_score": 44.4168422849584}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar body []byte\n\tvar err error\n\tvar req *resty.Request\n\tvar res *resty.Response\n\tvar token string\n\n\t// Set the authorization header with the access token.\n\treq = d.request.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\n\t// Add parameters for supporting all drives.\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\n\t// Set the request method.\n\treq.SetMethod(method)\n\n\t// Set the request URL.\n\treq.SetURL(url)\n\n\t// Set the request callback.\n\tif callback!= nil {\n\t\treq.OnBeforeRequest(callback)\n\t}\n\n\t// Set the request result.\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\n\t// Send the request.\n\tres, err = req.Execute()\n\tif err!= nil {\n\t\treturn body, err\n\t}\n\n\t// If the response code is 401, refresh the token and retry the request.\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\ttoken, err = d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn body, err\n\t\t}\n\n\t\t// Set the access token.\n\t\td.accessToken = token\n\n\t\t// Retry the request.\n\t\tbody, err = d.request(url, method, callback, resp)\n\t} else {\n\t\t// If the response code is 200, set the response body.\n\t\tbody, err = res.Body()\n\t}\n\n\treturn body, err\n}", "CodeBleu_score": 45.89248151416781}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(d.chunkSize)\n\tfinish := int64(0)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tif finish >= stream.GetSize() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tchunkSize = int64(d.chunkSize)\n\t\t\tif finish+chunkSize > stream.GetSize() {\n\t\t\t\tchunkSize = stream.GetSize() - finish\n\t\t\t}\n\n\t\t\treq := d.request(ctx, http.MethodPut, url, nil)\n\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext\n\n\t\t\tresp, err := req.Do()\n\t\t\tif err!= nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\tif resp.StatusCode == http.StatusRequestedRangeNotSatisfiable {\n\t\t\t\tcontinue\n\t\t\t} else if resp.StatusCode!= http.StatusNoContent {\n\t\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t\t\t}\n\n\t\t\tfinish += chunkSize\n\t\t}\n\t}\n}", "CodeBleu_score": 55.516226960837464}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the size of the file\n\tsize := stream.GetSize()\n\n\t// Calculate the chunk size based on the file size and the maximum chunk size limit\n\tchunkSize := d.maxChunkSize\n\tif size > chunkSize {\n\t\tchunkSize = size / 2\n\t}\n\n\t// Create a buffer to store the chunk data\n\tbuffer := make([]byte, chunkSize)\n\n\t// Create a reader to read the file data\n\treader := io.LimitReader(stream.GetReadCloser(), chunkSize)\n\n\t// Create a request to upload the chunk\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, reader)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the headers for the request\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"Content-Length\", strconv.FormatInt(chunkSize, 10))\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", chunkSize-1, size))\n\n\t// Perform the HTTP request\n\tresp, err := d.client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check for errors in the response\n\tif resp.StatusCode!= http.StatusCreated {\n\t\treturn fmt.Errorf(\"error uploading chunk: %s\", resp.Status)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.01724590776115}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tvar err error\n\tvar req *http.Request\n\tvar chunkSize int64\n\tvar finish int64\n\tvar resp *http.Response\n\n\t// Calculate the chunk size.\n\tchunkSize = d.chunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = 256 * 1024\n\t}\n\n\t// Upload each chunk sequentially.\n\tfor finish < stream.GetSize() {\n\t\t// Create an HTTP request for the current chunk.\n\t\treq, err = http.NewRequestWithContext(ctx, \"PUT\", url, io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the Content-Range header for the current chunk.\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()))\n\n\t\t// Send the HTTP request.\n\t\tresp, err = d.client.Do(req)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check for context cancellation.\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Check the response status code.\n\t\tif resp.StatusCode!= http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"error uploading chunk: status code %d\", resp.StatusCode)\n\t\t}\n\n\t\t// Update the finish value for the next chunk.\n\t\tfinish += chunkSize\n\n\t\t// Close the response body.\n\t\tresp.Body.Close()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.628091656512325}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context and retrieve the \"mount_point\" value.\n\tvar requestBody struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&requestBody); err!= nil {\n\t\treturn err\n\t}\n\n\t// If the mount point is empty, return a client error response.\n\tif requestBody.MountPoint == \"\" {\n\t\treturn common_err.GetMsg(ctx, http.StatusBadRequest, \"Mount point is required\")\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := service.MyService.Storage().UnmountStorage(requestBody.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(ctx, http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err := service.MyService.Storage().DeleteConfigByName(requestBody.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(ctx, http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"Storage unmounted successfully\",\n\t})\n}", "CodeBleu_score": 42.721673240698465}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\tmount_point string\n\t\terr         error\n\t)\n\tif err = ctx.Bind(&mount_point); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to parse request body\")\n\t}\n\tif mount_point == \"\" {\n\t\treturn common_err.GetMsg(err, \"Mount point is empty\")\n\t}\n\tif err = service.MyService.Storage().UnmountStorage(mount_point); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to unmount storage\")\n\t}\n\tif err = service.MyService.Storage().DeleteConfigByName(mount_point); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to delete configuration\")\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.SuccessResponse{\n\t\tMessage: \"Successfully unmounted storage\",\n\t})\n}", "CodeBleu_score": 33.78796729654978}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context\n\tvar req UmountStorageRequest\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn err\n\t}\n\n\t// Retrieve the \"mount_point\" value\n\tmountPoint := req.MountPoint\n\n\t// Check if the mount point is empty\n\tif mountPoint == \"\" {\n\t\treturn common_err.NewClientError(common_err.ErrInvalidMountPoint, \"Mount point cannot be empty\")\n\t}\n\n\t// Unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err, \"Failed to unmount storage\")\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err, \"Failed to delete configuration\")\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, UmountStorageResponse{\n\t\tMessage: \"Storage unmounted successfully\",\n\t})\n}", "CodeBleu_score": 44.471619125805695}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"filepath\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"File path is required\"})\n\t}\n\n\t// Check if the file exists\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\tdefer file.Close()\n\n\t// Read the file content\n\tfileContent, err := ioutil.ReadAll(file)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Error reading file\"})\n\t}\n\n\t// Return the file content as a response\n\treturn ctx.JSON(http.StatusOK, fileContent)\n}", "CodeBleu_score": 37.713874081117446}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Please provide a file path.\"})\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found.\"})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 31.27872045770114}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the \"path\" query parameter from the request\n\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"path is required\"})\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"file not found\"})\n\t}\n\n\t// Read the file and return it to the client\n\tfileBytes, err := ioutil.ReadFile(path)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error reading file\"})\n\t}\n\treturn ctx.JSON(http.StatusOK, fileBytes)\n}", "CodeBleu_score": 39.450271023296835}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": err.Error()})\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(message[\"name\"], message[\"message\"]); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully\"})\n}", "CodeBleu_score": 44.9803385460152}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidRequest, err.Error()))\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(message[\"name\"], message[\"message\"]); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrInternal, err.Error()))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrSuccess))\n}", "CodeBleu_score": 51.41742244028285}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewCommonError(common_err.ErrCodeBindFailed, err.Error()))\n\t}\n\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewCommonError(common_err.ErrCodeInvalidParam, \"name is empty\"))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewCommonError(common_err.ErrCodeInternalError, err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.NewCommonSuccess())\n}", "CodeBleu_score": 51.77472313144935}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service\n\tgo sendMessages()\n\n\t// Loop forever, reading messages from the WebSocket connection and printing the message type, message, and any errors\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Message type:\", msgType(msg))\n\t\tfmt.Println(\"Message:\", string(msg))\n\t\tfmt.Println(\"Error:\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.370792513050624}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\t// Upgrade the incoming request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response().Writer, ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Start a goroutine to send messages to the WebSocket connection\n\tgo sendMessages(ws)\n\t// Loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type and message\n\t\tfmt.Printf(\"Message type: %d\nMessage: %s\n\", msgType, string(msg))\n\t}\n}", "CodeBleu_score": 47.43122427824263}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service\n\tgo sendMessages()\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type and message\n\t\tfmt.Println(\"Message type:\", messageType)\n\t\tfmt.Println(\"Message:\", string(message))\n\n\t\t// Send the message back to all connected WebSocket clients\n\t\tfor _, conn := range connections {\n\t\t\terr = conn.WriteMessage(messageType, message)\n\t\t\tif err!= nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.118319618827265}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the CPU information\n\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err!= nil {\n\t\treturn common_err.GetError(ctx, common_err.ERROR_SYSTEM_GET_CPU_INFO_FAILED, err)\n\t}\n\n\t// Get the drive model\n\tdriveModel, err := service.MyService.System().GetDriveModel()\n\tif err!= nil {\n\t\treturn common_err.GetError(ctx, common_err.ERROR_SYSTEM_GET_DRIVE_MODEL_FAILED, err)\n\t}\n\n\t// Get the drive model\n\tdriveModel, err := service.MyService.System().GetDriveModel()\n\tif err!= nil {\n\t\treturn common_err.GetError(ctx, common_err.ERROR_SYSTEM_GET_DRIVE_MODEL_FAILED, err)\n\t}\n\n\t// Get the device tree\n\tdeviceTree, err := service.MyService.System().GetDeviceTree()\n\tif err!= nil {\n\t\treturn common_err.GetError(ctx, common_err.ERROR_SYSTEM_GET_DEVICE_TREE_FAILED, err)\n\t}\n\n\t// Build the response\n\tresponse := map[string]interface{}{\n\t\t\"cpuInfo\":      cpuInfo,\n\t\t\"driveModel\":   driveModel,\n\t\t\"deviceTree\":   deviceTree,\n\t\t\"architecture\": service.MyService.System().GetArchitecture(),\n\t}\n\n\treturn ctx.JSON(http.StatusOK, response)\n}", "CodeBleu_score": 25.781351889779042}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get system hardware information\n\tsystemHardwareInfo, err := service.MyService.System().GetSystemHardwareInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Return system hardware information\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 19.70520754403054}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get system hardware information\n\tsystemHardwareInfo := service.MyService.System().GetSystemHardwareInfo()\n\n\t// If CPU information is available, return it\n\tif systemHardwareInfo.CpuInfo!= nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(\"system_hardware_info\", systemHardwareInfo))\n\t}\n\n\t// If CPU information is not available, return nil\n\treturn ctx.JSON(http.StatusOK, nil)\n}", "CodeBleu_score": 19.52468543525554}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := make([]*[]string, 0)\n\tnotRunningServices := make([]*[]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service.Name, \"casaos\") {\n\t\t\tif service.Active {\n\t\t\t\trunningServices = append(runningServices, &service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, &service.Name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 58.08198684725032}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]*[]string, 0)\n\tnotRunning := make([]*[]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, &service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, &service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 66.61437027234558}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := []*string{}\n\tnotRunningServices := []*string{}\n\n\tfor _, service := range services {\n\t\tif service.Status == \"active\" {\n\t\t\trunningServices = append(runningServices, &service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, &service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 57.01061926910833}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Marshal the message values to JSON strings\n\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to marshal message values to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), name, string(jsonMessage))\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log the response status code and details if not OK\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"status\", response.Status))\n\t}\n}", "CodeBleu_score": 40.19580560736985}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings.\n\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to marshal message values to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse, err := i.messageBus.PublishEvent(context.Background(), name, string(jsonMessage))\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Check the response status code.\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.String(\"message\", string(jsonMessage)), zap.Int(\"status_code\", response.StatusCode), zap.String(\"status\", response.Status))\n\t}\n}", "CodeBleu_score": 41.1416989883498}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Initialize the client and attempt to retrieve the message bus address using a specified runtime path.\n\tif err := c.init(); err!= nil {\n\t\treturn nil\n\t}\n\n\t// If the address is found, set the client's server to the retrieved address; otherwise, set the server to a default error message.\n\tif c.address!= \"\" {\n\t\tc.server = c.address\n\t} else {\n\t\tc.server = \"Error: Unable to retrieve message bus address.\"\n\t}\n\n\t// Return the initialized client.\n\treturn c.client\n}", "CodeBleu_score": 30.12681091198478}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tc.init()\n\tif c.runtimePath == \"\" {\n\t\treturn message_bus.NewClientWithResponses(c.server, nil)\n\t}\n\taddress, err := c.getRuntimeAddress()\n\tif err!= nil {\n\t\treturn message_bus.NewClientWithResponses(c.server, nil)\n\t}\n\tc.server = address\n\treturn message_bus.NewClientWithResponses(c.server, nil)\n}", "CodeBleu_score": 38.289044182049906}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// TODO: Implement this function\n\treturn nil\n}", "CodeBleu_score": 6.9743336813361365}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\t// Get the \"x-forwarded-for\" header.\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\t// Get the request's remote address.\n\t\tip = request.RemoteAddr\n\t}\n\t// Remove the port number from the IP address.\n\tif idx := strings.LastIndex(ip, \":\"); idx > 0 {\n\t\tip = ip[:idx]\n\t}\n\t// Convert the loopback addresses \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\".\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 62.92175070713946}, {"code": "func GetIP(request *http.Request) string{\n\t\t// Check the \"x-forwarded-for\" header.\n\tif ip := request.Header.Get(\"x-forwarded-for\"); ip!= \"\" {\n\t\treturn strings.Split(ip, \", \")[0]\n\t}\n\n\t// Use the request's remote address.\n\treturn strings.Split(request.RemoteAddr, \":\")[0]\n}", "CodeBleu_score": 26.103217395763927}, {"code": "func GetIP(request *http.Request) string{\n\t\t// Check the \"x-forwarded-for\" header first.\n\tif ip := request.Header.Get(\"X-Forwarded-For\"); ip!= \"\" {\n\t\treturn strings.Split(ip, \", \")[0]\n\t}\n\t// If the \"x-forwarded-for\" header is not available,\n\t// use the request's remote address.\n\treturn strings.Split(request.RemoteAddr, \":\")[0]\n}", "CodeBleu_score": 25.473577018537906}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the system entry file path\n\tentryFilePath := filepath.Join(c.modulesPath, \"entry.json\")\n\n\t// Create a new array to store the entry data\n\tentryData := []byte(\"[]\")\n\n\t// Loop through each module directory\n\tmoduleDirs, err := os.ReadDir(c.modulesPath)\n\tif err!= nil {\n\t\tlogger.Error(\"Error reading module directories: \", err)\n\t\treturn\n\t}\n\n\tfor _, dir := range moduleDirs {\n\t\t// Skip non-directory entries\n\t\tif!dir.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the module directory path\n\t\tmoduleDirPath := filepath.Join(c.modulesPath, dir.Name())\n\n\t\t// Read the entry file from the module directory\n\t\tentryFile, err := os.ReadFile(filepath.Join(moduleDirPath, \"entry.json\"))\n\t\tif err!= nil {\n\t\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlogger.Error(\"Error reading entry file: \", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the entry data to the array\n\t\tentryData = append(entryData, entryFile...)\n\t\tentryData = append(entryData, []byte(\",\")...)\n\t}\n\n\t// Remove the trailing comma\n\tentryData = entryData[:len(entryData)-1]\n\n\t// Write the array to the entry file\n\terr = os.WriteFile(entryFilePath, entryData, 0644)\n\tif err!= nil {\n\t\tlogger.Error(\"Error writing entry file: \", err)\n\t}\n}", "CodeBleu_score": 47.62745194558396}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define the system entry file path and ensure it exists.\n\tentryFilePath := filepath.Join(c.modulesDir, \"entry.json\")\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t// Create the entry file if it doesn't exist.\n\t\tif err := os.MkdirAll(c.modulesDir, 0755); err!= nil {\n\t\t\tlogger.Error(err)\n\t\t\treturn\n\t\t}\n\t\tif err := os.WriteFile(entryFilePath, []byte(\"[]\"), 0644); err!= nil {\n\t\t\tlogger.Error(err)\n\t\t\treturn\n\t\t}\n\t}\n\t// Read the entry file and concatenate its content.\n\tvar entryFile []byte\n\tif entryFile, err := os.ReadFile(entryFilePath); err!= nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t} else {\n\t\t// Concatenate the entry file content with the new module entry.\n\t\tentryFile = append(entryFile, []byte(\",\")...)\n\t\t// Read the module entry file content.\n\t\tif moduleEntryFile, err := os.ReadFile(filepath.Join(c.modulesDir, v.Name, \"entry.json\")); err!= nil {\n\t\t\tlogger.Error(err)\n\t\t\treturn\n\t\t} else {\n\t\t\tentryFile = append(entryFile, moduleEntryFile...)\n\t\t}\n\t}\n\t// Write the consolidated entry file content to the entry file path.\n\tif err := os.WriteFile(entryFilePath, entryFile, 0644); err!= nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 42.43646560437934}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the path to the modules directory\n\tmodulesDir := c.config.ModulesDir\n\t// Get the path to the entry file\n\tentryFile := filepath.Join(modulesDir, \"entry.json\")\n\t// Create a new array to store the entry JSON objects\n\tentryJSON := []byte(\"[]\")\n\t// Read the entry.json files from each module directory\n\tmoduleDirs, err := os.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlogger.Error(\"Error reading modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\tfor _, moduleDir := range moduleDirs {\n\t\tmodulePath := filepath.Join(modulesDir, moduleDir.Name())\n\t\tentryFilePath := filepath.Join(modulePath, \"entry.json\")\n\t\t// Check if the entry file exists in the module directory\n\t\tif file.IsNotExistCreateFile(entryFilePath) {\n\t\t\tlogger.Warn(\"Entry file does not exist in module directory\", zap.String(\"module\", modulePath))\n\t\t\tcontinue\n\t\t}\n\t\t// Read the entry.json file from the module directory\n\t\tentryFile, err := os.ReadFile(entryFilePath)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Error reading entry file\", zap.String(\"module\", modulePath), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\t// Append the entry JSON object to the array\n\t\tentryJSON = append(entryJSON, entryFile...)\n\t}\n\t// Write the entry JSON array to the entry file\n\tif err := os.WriteFile(entryFile, entryJSON, 0644); err!= nil {\n\t\tlogger.Error(\"Error writing entry file\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 44.652100020137894}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tnetNames, err := c.System().GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range netNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 61.55135587182308}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tfor _, name := range netNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 57.44214774153238}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.System().GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, networkName := range networkNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == networkName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 60.0788460745834}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\n\tif (pRequest == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\n\t// add reference\n\tatomic_add_fetch_64(&pRequest->refCount, 1);\n\n\t// update request count\n\tatomic_add_fetch_64(&pTscObj->requestCount, 1);\n\n\t// update application summary\n\tif (pTscObj->pAppInfo!= NULL) {\n\t\tatomic_add_fetch_64(&pTscObj->pAppInfo->totalRequests, 1);\n\t\tatomic_add_fetch_64(&pTscObj->pAppInfo->currentRequests, 1);\n\t}\n\n\t// log debug information\n\tlogDebug(\"registerRequest: request=%p, tscObj=%p, refCount=%d, requestCount=%d, totalRequests=%d, currentRequests=%d\", pRequest, pTscObj, pRequest->refCount, pTscObj->requestCount, pTscObj->pAppInfo->totalRequests, pTscObj->pAppInfo->currentRequests);\n\n\treturn rc;\n}", "CodeBleu_score": 46.192864795744505}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* db;\n\tint i;\n\n\tif (strcmp(pRequest->primaryDb, exceptDb)!= 0) {\n\t\tfor (i = 0; i < pRequest->numDb; i++) {\n\t\t\tdb = pRequest->db[i];\n\t\t\tif (strncmp(db, exceptDb, strlen(exceptDb)) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 38.928695728766435}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (strcmp(pRequest->pPrimaryDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tint i = 0;\n\tfor (i = 0; i < pRequest->nDbNames; i++) {\n\t\tif (strcmp(pRequest->pDbNames[i], exceptDb)!= 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 37.107518622484626}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool ret = false;\n\tswitch (code) {\n\tcase RPC_ERROR_CODE_REDIRECT:\n\t\tswitch (msgType) {\n\t\tcase MSG_TYPE_CLIENT_RPC_REQUEST:\n\t\tcase MSG_TYPE_CLIENT_RPC_REQUEST_ACK:\n\t\tcase MSG_TYPE_CLIENT_RPC_RESPONSE:\n\t\tcase MSG_TYPE_CLIENT_RPC_RESPONSE_ACK:\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 25.649485927131753}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == RPC_ERROR_NEED_REDIRECT_ERROR) {\n\t\tswitch (msgType) {\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 34.42859322656463}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t", "CodeBleu_score": 4.319414830761173}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObj *pReqs = pRequests;\n\tint64_t rid = 0;\n\tint32_t ret = 0;\n\n\twhile (pReqs) {\n\t\trid = (int64_t)pReqs->key;\n\t\tacquireRequest(rid);\n\t\tret = taos_stop_query(rid);\n\t\treleaseRequest(rid);\n\t\tpReqs = pReqs->next;\n\t}\n}", "CodeBleu_score": 37.67293535412708}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint64_t rid;\n\tint i;\n\tfor (i = 0; i < pRequests->size; i++) {\n\t\trid = pRequests->data[i];\n\t\tif (rid!= 0) {\n\t\t\treleaseRequest(rid);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.050882905937527}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!crashReportingEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0)) {\n\t\twhile (clientStop) {\n\t\t\ttaosMsleep(1000);\n\t\t}\n\t} else {\n\t\tlogError(\"Crash report thread is already stopped\");\n\t}\n}", "CodeBleu_score": 55.022730935952346}, {"code": "void tscStopCrashReport(){\n\t\tif (crashReportEnabled) {\n\t\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0)) {\n\t\t\twhile (clientStop) {\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERROR(\"Crash report thread is already stopped.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 43.439395828437355}, {"code": "void tscStopCrashReport(){\n\t\tif (crashReportingEnabled) {\n\t\tif (atomic_val_compare_exchange_32(&clientStop, 0, 1)) {\n\t\t\twhile (clientStop) {\n\t\t\t\t;\n\t\t\t}\n\t\t} else {\n\t\t\tlog_info(logger, \"Crash report thread already stopped\");\n\t\t}\n\t}\n}", "CodeBleu_score": 35.977116770512914}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tstruct S3ResponsePropertiesCallbackData *data = (struct S3ResponsePropertiesCallbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 70.4837482758661}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponseCallbackData *responseCallbackData = (S3ResponseCallbackData *)callbackData;\n\tS3_LOG(S3_LOG_TRACE, \"responsePropertiesCallback: callbackData=%p\n\", callbackData);\n\tif (properties->contentLength > 0) {\n\t\tresponseCallbackData->contentLength = properties->contentLength;\n\t}\n\treturn status;\n}", "CodeBleu_score": 56.812573647113005}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tstruct S3ResponseCallbackData *data = (struct S3ResponseCallbackData *)callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 60.727642630668385}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosMkDir(tsCheckpointBackupDir, 0755)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate conf file error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsRsyncPort);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret!= 0) {\n    uError(\"[rsync] start rsync error, cmd:%s, ret:%d\", cmd, ret);\n  } else {\n    uDebug(\"[rsync] start rsync success, cmd:%s\", cmd);\n  }\n}", "CodeBleu_score": 62.14552887928257}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosMkDir(tsCheckpointBackupDir, 0755)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n  uDebug(\"[rsync] start cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  uDebug(\"[rsync] start ret:%d\", ret);\n  if (ret!= 0) {\n    uError(\"[rsync] start rsync error\");\n  }\n}", "CodeBleu_score": 55.61004018470588}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n  tsCheckpointBackupDir = path;\n#endif\n  if (taosMkDir(tsCheckpointBackupDir, 0755)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate conf file error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --port=%d --config=%s\", tsRsyncPort, tsCheckpointBackupDir);\n  if (system(cmd)!= 0) {\n    uError(\"[rsync] start rsync error, cmd:%s\", cmd);\n    return;\n  }\n\n  uDebug(\"[rsync] start rsync success, cmd:%s\", cmd);\n}", "CodeBleu_score": 56.614713765162904}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (!dispatchers.containsKey(dispatcherId)) {\n\t\tthrow new RuntimeException(\"Dispatcher with id '\" + dispatcherId + \"' is not registered.\");\n\t}\n\tdispatchers.get(dispatcherId).shutdownNow();\n\tdispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 45.02876276948163}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).getExecutor().shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found\");\n\t}\n}", "CodeBleu_score": 46.818499103004456}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\t// TODO Auto-generated method stub\n\n}", "CodeBleu_score": 2.950171161196606}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t for (TbActorId child : getChildren(parent)) {\n if (childFilter.test(child)) {\n if (highPriority) {\n tell(child, msg, true);\n } else {\n tell(child, msg, false);\n }\n }\n }\n }", "CodeBleu_score": 29.78319937395667}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t if (childFilter == null) {\n throw new IllegalArgumentException(\"childFilter is null\");\n }\n if (msg == null) {\n throw new IllegalArgumentException(\"msg is null\");\n }\n List<TbActorId> children = getChildren(parent);\n if (children == null) {\n warn(\"No children found for parent \" + parent);\n return;\n }\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n try {\n if (highPriority) {\n get(child).tell(msg, true);\n } else {\n get(child).tell(msg, false);\n }\n } catch (TbActorNotFoundException e) {\n warn(\"Child \" + child + \" not found\");\n }\n }\n }\n }", "CodeBleu_score": 40.95273429685589}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t final Map<TbActorId, TbActor> children = getChildren();\n children.forEach((childId, child) -> {\n if (childFilter.test(childId)) {\n try {\n child.tell(msg, highPriority);\n } catch (TbActorNotRegisteredException e) {\n warn(\"Child actor \" + childId + \" not registered\");\n }\n }\n });\n }", "CodeBleu_score": 46.425626555374045}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (ready.get() == READY) {\n    if (destroyed.get()) {\n        if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n            if (msg.getRuleNode().getRuleNodeState() == RULE_NODE_STATE_FAILED) {\n                initActor();\n            }\n        } else {\n            stopped.set(true);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    }\n} else {\n    log.trace(\"[{}] MessageBox is not ready, msg: {}\", selfId, msg);\n}\n}", "CodeBleu_score": 58.403906005239406}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        log.trace(\"[{}] Enqueueing message {} with high priority: {}\", selfId, msg, highPriority);\n        if (destroyed.get() == DESTROYED) {\n            if (msg instanceof RuleNodeUpdatedMsg) {\n                if (msg.getActorId().equals(selfId)) {\n                    tryInit(1);\n                } else {\n                    log.trace(\"[{}] Message {} with high priority: {} was not enqueued because actor is destroyed\", selfId, msg, highPriority);\n                    msg.getActor().getMailbox().notifyMsg(msg);\n                }\n            } else {\n                log.trace(\"[{}] Message {} with high priority: {} was not enqueued because actor is destroyed\", selfId, msg, highPriority);\n                msg.getActor().getMailbox().notifyMsg(msg);\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 58.996623051317165}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n//            if (msg.getActor().isDestroyed()) {\n//                msg.getActor().initActor();\n//            }\n//        }\n        if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n            if (msg.getActor().isDestroyed()) {\n                msg.getActor().initActor();\n            }\n        }\n        if (msg.getActor().isDestroyed()) {\n            msg.getActor().getTbActorStopped().get().onTbActorStopped(msg);\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 56.53293220888257}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\ty {\n    // Process high priority messages\n    while (highPriorityMsgs.size() > 0 && actor.getActorThroughput() > 0) {\n        TbActorMessage msg = highPriorityMsgs.poll();\n        if (msg == null) {\n            break;\n        }\n        if (msg.isReady()) {\n            try {\n                actor.process(msg);\n            } catch (Throwable t) {\n                if (msg.isStopActor()) {\n                    stopReason = TbActorStopReason.INIT_FAILURE;\n                } else {\n                    stopReason = TbActorStopReason.PROCESS_FAILURE;\n                }\n                destroy(t);\n                return;\n            }\n        } else {\n            highPriorityMsgs.add(msg);\n            break;\n        }\n    }\n    // Process normal priority messages\n    while (normalPriorityMsgs.size() > 0 && actor.getActorThroughput() > 0) {\n        TbActorMessage msg = normalPriorityMsgs.poll();\n        if (msg == null) {\n            break;\n        }\n        if (msg.isReady()) {\n            try {\n                actor.process(msg);\n            } catch (Throwable t) {\n                if (msg.isStopActor()) {\n                    stopReason = TbActorStopReason.INIT_FAILURE;\n                } else {\n                    stopReason = TbActorStopReason.PROCESS_FAILURE;\n                }\n                destroy(t);\n                return;\n            }\n        } else {\n            normalPriorityMsgs.add(msg);\n            break;\n        }\n    }\n    // Set status to free\n    ready.set(READY);\n    // Schedule queue processing attempt\n    tryProcessQueue(false);\n} catch (Throwable t) {\n    log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n    onProcessFailure(t);\n    if (stopReason == null) {\n        stopReason = TbActorStopReason.PROCESS_FAILURE;\n    }\n    destroy(t);\n}\n}", "CodeBleu_score": 39.187964669619134}, {"code": "private void processMailbox(){\n\t/        try {\n//            actor.init();\n//        } catch (Throwable t) {\n//            stopReason = TbActorStopReason.INIT_FAILURE;\n//            destroy(t);\n//            return;\n//        }\n\n        // Process high priority messages\n        try {\n            for (int i = 0; i < actor.getActorThroughput(); i++) {\n                TbActorMessage msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                } catch (Throwable t) {\n                    onProcessFailure(msg, t);\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            onProcessFailure(null, t);\n            return;\n        }\n\n        // Process normal priority messages\n        try {\n            for (int i = 0; i < actor.getActorThroughput(); i++) {\n                TbActorMessage msg = normalPriorityMsgs.poll();\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                } catch (Throwable t) {\n                    onProcessFailure(msg, t);\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            onProcessFailure(null, t);\n            return;\n        }\n\n        // Set the actor status to free\n        ready.set(FREE);\n        if (stopReason!= null) {\n            // If a stop reason has been set, destroy the actor\n            destroy(null);\n        } else {\n            // Otherwise, schedule a queue processing attempt\n            dispatcher.getExecutor().execute(this::tryProcessQueue);\n        }\n    }", "CodeBleu_score": 39.15838618239506}, {"code": "private void processMailbox(){\n\t        log.trace(\"[{}] Processing mailbox...\", selfId);\n        try {\n            int processed = 0;\n            while (processed < actor.getActorThroughput()) {\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    break;\n                }\n                if (highPriorityMsgs.isEmpty()) {\n                    processNormalPriorityMessages();\n                } else if (normalPriorityMsgs.isEmpty()) {\n                    processHighPriorityMessages();\n                } else {\n                    processHighPriorityMessages();\n                    processNormalPriorityMessages();\n                }\n                processed++;\n            }\n            if (processed > 0) {\n                ready.set(READY);\n            } else {\n                ready.set(NOT_READY);\n            }\n            if (ready.get() == NOT_READY) {\n                dispatcher.getExecutor().schedule(this::tryProcessQueue, 1, TimeUnit.SECONDS);\n            }\n        } catch (Throwable t) {\n            log.error(\"[{}] Error processing mailbox: {}\", selfId, t);\n            if (t instanceof ActorInitializationException) {\n                stopReason = TbActorStopReason.INITIALIZATION_FAILURE;\n            } else {\n                stopReason = TbActorStopReason.PROCESS_FAILURE;\n            }\n            destroy(t);\n        }\n    }", "CodeBleu_score": 33.03376194984587}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.STOPPED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\ttry {\n\t\t\tready.set(NOT_READY);\n\t\t\tactor.destroy(stopReason, cause);\n\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n\t\t}\n\t});\n}", "CodeBleu_score": 92.47258027809767}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.STOPPED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\ttry {\n\t\t\tready.set(NOT_READY);\n\t\t\tactor.destroy(stopReason, cause);\n\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n\t\t}\n\t});\n}", "CodeBleu_score": 92.47258027809767}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - this.timeout;\n\tIterator<Entry<String, DtlsSession>> iterator = this.sessions.entrySet().iterator();\n\twhile (iterator.hasNext()) {\n\t\tEntry<String, DtlsSession> entry = iterator.next();\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlog.debug(\"Removing DTLS session for peer \" + entry.getKey());\n\t\t\titerator.remove();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.61302562875001}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - this.inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : this.dtlsSessions.entrySet()) {\n\t\tDtlsSession session = entry.getValue();\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tlog.info(\"Removing DTLS session for peer \" + session.getPeerAddress());\n\t\t\tthis.dtlsSessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 35.512606083885466}, {"code": "public void evictTimeoutSessions(){\n\t\tfinal long currentTime = System.currentTimeMillis();\n\tfinal long expirationTime = currentTime - inactivityTimeout;\n\n\tfinal Iterator<Entry<String, DtlsSession>> iterator = sessions.entrySet().iterator();\n\twhile (iterator.hasNext()) {\n\t\tfinal Entry<String, DtlsSession> entry = iterator.next();\n\t\tfinal long lastActivityTime = entry.getValue().getLastActivityTime();\n\t\tif (lastActivityTime < expirationTime) {\n\t\t\tlogger.debug(\"Removing session with ID {} because it has been inactive for {} milliseconds\", entry.getKey(), currentTime - lastActivityTime);\n\t\t\titerator.remove();\n\t\t}\n\t}\n}", "CodeBleu_score": 31.704181247159823}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n}\nreturn timeseries.entrySet().stream()\n.flatMap(entry -> entry.getValue().stream()\n.map(value -> new TsKvEntry(entry.getKey(), parseValue(entry.getKey(), value))))\n.collect(Collectors.toList());\n}", "CodeBleu_score": 20.941139487442026}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n}\nreturn timeseries.entrySet().stream()\n.map(entry -> {\nList<JsonNode> values = entry.getValue();\nif (values.size()!= 1) {\nthrow new RuntimeException(\"Timeseries value must be a single value, but was \" + values);\n}\nreturn new TsKvEntry(entry.getKey(), parseValue(entry.getKey(), values.get(0)));\n})\n.collect(Collectors.toList());\n}", "CodeBleu_score": 25.975288284149578}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tList<TsKvEntry> result = new ArrayList<>();\nif (timeseries.isEmpty()) {\nreturn result;\n}\nfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\nString key = entry.getKey();\nList<JsonNode> values = entry.getValue();\nresult.add(new TsKvEntry(key, parseTimeseriesValues(key, values)));\n}\nreturn result;\n}", "CodeBleu_score": 36.237006426636654}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> body = new HashMap<>();\n\tbody.put(\"refreshToken\", this.refreshToken);\n\tHttpEntity<Map<String, String>> request = new HttpEntity<>(body, headers);\n\tResponseEntity<JsonNode> response = this.restTemplate.postForEntity(this.authEndpoint, request, JsonNode.class);\n\tthis.setTokenInfo(System.currentTimeMillis(), response.getBody());\n}", "CodeBleu_score": 51.30249799296187}, {"code": "public void refreshToken(){\n\t//        Map<String, String> requestMap = new HashMap<>();\n//        requestMap.put(\"refreshToken\", this.refreshToken);\n//        HttpEntity<Map<String, String>> request = new HttpEntity<>(requestMap);\n//        ResponseEntity<JsonNode> response = this.restTemplate.postForEntity(this.authEndpoint, request, JsonNode.class);\n//        JsonNode body = response.getBody();\n//        this.setTokenInfo(this.currentTimeMillis(), body);\n//        this.log.info(\"Refreshed token successfully\");\n//    }", "CodeBleu_score": 1.4566164722189534}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\ttry {\n\t\tResponseEntity<JsonNode> response = this.restTemplate.postForEntity(this.authenticationEndpoint, requestMap, JsonNode.class);\n\t\tJsonNode responseBody = response.getBody();\n\t\tlong ts = System.currentTimeMillis();\n\t\tthis.setTokenInfo(ts, responseBody);\n\t} catch (RestClientException e) {\n\t\te.printStackTrace();\n\t}\n}", "CodeBleu_score": 55.66184022834467}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t long ts = System.currentTimeMillis();\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", );\n ResponseEntity<JsonNode> loginResponse = restTemplate.postForEntity(authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n setTokenInfo(ts, loginResponse.getBody());\n }", "CodeBleu_score": 85.16069804450292}, {"code": " private void doLogin(){\n\t String url = \"http://localhost:8080/api/auth/login\";\n Map<String, String> requestBody = new HashMap<>();\n requestBody.put(\"username\", username);\n requestBody.put(\"password\", );\n HttpHeaders headers = new HttpHeaders();\n headers.setContentType(MediaType.APPLICATION\\_JSON);\n HttpEntity<String> request = new HttpEntity<>(requestBody.toString(), headers);\n ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);\n long ts = System.currentTimeMillis();\n setTokenInfo(ts, objectMapper.readTree(response.getBody()));\n }", "CodeBleu_score": 49.08123092766425}, {"code": " private void doLogin(){\n\t long ts = System.currentTimeMillis();\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", );\n ResponseEntity<JsonNode> response = postForEntity(authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n JsonNode tokenInfo = response.getBody();\n setTokenInfo(ts, tokenInfo);\n }", "CodeBleu_score": 78.48887001501974}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\treturn Optional.ofNullable(getForEntity(\n\t\t\t\tURI.create(String.format(DEVICE_BY_ID_URL, deviceId.getValue())),\n\t\t\t\tDevice.class).getBody());\n\t} catch (RestClientException e) {\n\t\tif (e.getRawStatusCode() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.30322755579896}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getForEntity(API_DEVICE_URL + deviceId.getId(), Device.class)\n\t\t.map(ResponseEntity::getBody);\n}", "CodeBleu_score": 10.820111053080305}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getForEntity(\n\t\t\t\"api/device/\" + deviceId,\n\t\t\tDevice.class,\n\t\t\t\"getDeviceById\",\n\t\t\tdeviceId\n\t).getBody();\n}", "CodeBleu_score": 12.223561662597183}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\t// Create a request object containing the device and its credentials\n\tRequestEntity<Device> request = RequestEntity\n\t\t.post(uri)\n\t\t.contentType(MediaType.APPLICATION_JSON)\n\t\t.body(device);\n\n\t// Attempt to send the request\n\ttry {\n\t\tResponseEntity<Device> response = restTemplate.exchange(request, Device.class);\n\t\treturn Optional.ofNullable(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.68495443270554}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tRequestEntity<Device> request = RequestEntity\n.post(URI.create(String.format(\"%s/api/device-with-credentials\", getBaseUri())))\n.contentType(MediaType.APPLICATION_JSON)\n.accept(MediaType.APPLICATION_JSON)\n.body(device);\ntry {\nreturn Optional\n.ofNullable(\ngetRestTemplate()\n.exchange(request, Device.class)\n.getBody());\n} catch (HttpClientErrorException e) {\nif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n}\nthrow e;\n}\n}", "CodeBleu_score": 49.651573196160214}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t//TODO: Implement this function\nreturn Optional.empty();\n}", "CodeBleu_score": 12.013138032389865}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n  val = addr;\n  this.each(function(device) {\n    this.brightness(device, val);\n  });\n} else {\n  this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n}\nreturn this;\n}", "CodeBleu_score": 97.49137623160196}, {"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tval = addr;\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t} else {\n\t\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n\t}\n\treturn this;\n}", "CodeBleu_score": 95.67310060368143}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\nval = addr;\nthis.each(function(device) {\nthis.brightness(device, val);\n});\n} else {\nthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n}\nreturn this;\n}", "CodeBleu_score": 95.55609170275332}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tconst bound = {};\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}, {"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\n  bound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\n  if (this[key] && typeof this[key] === \"function\") {\n    bound[key] = this[key].bind(this, addr);\n  }\n});\nreturn bound;\n}", "CodeBleu_score": 97.50366938393864}, {"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (duration = 1000, callback) => {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function');\n\t\t\t}\n\t\t\tlet signals = [];\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tlet signal = new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(this[i][method]());\n\t\t\t\t\t}, duration);\n\t\t\t\t});\n\t\t\t\tsignals.push(signal);\n\t\t\t}\n\t\t\tPromise.all(signals).then(results => {\n\t\t\t\tcallback(results);\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 38.548891298882424}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (duration, callback) => {\n\t\t\tif (typeof callback!== \"function\") {\n\t\t\t\tthrow new Error(`The callback for the ${method} method must be a function.`);\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tconst collection = this;\n\t\t\tfor (let i = 0; i < collection.length; i++) {\n\t\t\t\tpromises.push(new Promise((resolve) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(collection[i][method]());\n\t\t\t\t\t}, duration || 1000);\n\t\t\t\t}));\n\t\t\t}\n\t\t\tPromise.all(promises).then((results) => {\n\t\t\t\tcallback(results);\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 38.37504893386933}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach((method) => {\n\t\ttarget[method] = (duration = 1000, callback) => {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new TypeError('Callback must be a function');\n\t\t\t}\n\n\t\t\tconst signals = [];\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tconst signal = new Promise((resolve) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(this[i][method]());\n\t\t\t\t\t}, duration);\n\t\t\t\t});\n\t\t\t\tsignals.push(signal);\n\t\t\t}\n\n\t\t\tPromise.all(signals).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 38.509793345018416}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\ninput += new Buffer(data).toString(\"ascii\");\nconst sentences = input.split(\"\\r\n\");\n\nif (sentences.length > 1) {\nfor (let i = 0; i < sentences.length - 1; i++) {\nthis.parseNmeaSentence(sentences[i]);\n}\ninput = sentences[sentences.length - 1];\n}\n});\n}", "CodeBleu_score": 72.24788544932532}, {"code": "listen(){\n\tstate = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\ninput += new Buffer(data).toString(\"ascii\");\nconst sentences = input.split(\"\\r\n\");\n\nif (sentences.length > 1) {\nfor (let i = 0; i < sentences.length - 1; i++) {\nthis.parseNmeaSentence(sentences[i]);\n}\ninput = sentences[sentences.length - 1];\n}\n});\n}", "CodeBleu_score": 72.17468831946645}, {"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 74.81206486126135}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tconst struct adc_channel_config *channel_config = sequence->channels;\n\tint channel_count = 0;\n\tint buffer_size = 0;\n\tint i;\n\n\t/*\n\t * Calculate the number of active channels.\n\t * If the channel is not configured, it is skipped.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (channel_config[i].channel_id!= CHANNEL_ID_NONE) {\n\t\t\tchannel_count++;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the buffer size based on the number of active channels and the size of each data sample.\n\t * The buffer size is the number of channels multiplied by the size of each data sample.\n\t */\n\tbuffer_size = channel_count * config->data_size;\n\n\t/*\n\t * Check if the provided buffer size is sufficient.\n\t * If not, return an error code indicating insufficient memory.\n\t */\n\tif (sequence->buffer_size < buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.83009093969379}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tint active_channels = 0;\n\tint buffer_size = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels_num; i++) {\n\t\tif (sequence->channels[i]!= ADC_AD559X_CHANNEL_ALL) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = active_channels * sequence->resolution * sequence->channels_num;\n\n\tif (buffer_size > config->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.21967199638243}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t num_channels = 0;\n\tuint32_t buffer_size = 0;\n\tuint32_t i;\n\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i]!= 0) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = num_channels * sequence->buffer_size;\n\n\tif (buffer_size > config->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.173704988097555}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tsize_t needed;\n\tint ret;\n\n\t/* Check if the resolution of the ADC sequence matches the expected resolution */\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid */\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > config->channels) {\n\t\tLOG_ERR(\"Invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tneeded = channels * sizeof(uint16_t);\n\tif (sequence->buffer_size < needed) {\n\t\tLOG_ERR(\"Buffer too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Set the buffer */\n\tdata->buffer = sequence->buffer;\n\n\t/* Start the ADC read context */\n\tadc_context_start_read(data->context, sequence->channels, sequence->buffer, sequence->buffer_size);\n\n\t/* Wait for the read operation to complete */\n\tadc_context_wait_for_completion(data->context);\n\n\t/* Return the result */\n\treturn 0;\n}", "CodeBleu_score": 54.86082358777343}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tconst struct adc_channel_cfg *channel_cfg;\n\tuint8_t channels;\n\tuint8_t i;\n\tuint16_t *buffer;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (channels > config->channels) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tbuffer = (uint16_t *)sequence->buffer;\n\n\tfor (i = 0; i < channels; i++) {\n\t\tchannel_cfg = &config->channels[i];\n\n\t\tadc_context_set_channel_config(dev, channel_cfg);\n\t\tadc_context_set_buffer(dev, buffer);\n\t\tadc_context_start_read(dev);\n\t\tadc_context_wait_for_completion(dev);\n\n\t\tbuffer += config->channels[i].resolution;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.344719800609575}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\t/* Check the resolution of the ADC sequence */\n\tif (sequence->resolution!= data->resolution) {\n\t\tLOG_ERR(\"Resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid */\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > data->channels) {\n\t\tLOG_ERR(\"Invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn ret;\n\t}\n\n\t/* Set the buffer and start the ADC read context */\n\tadc_context_set_buffer(data->context, sequence->buffer, sequence->buffer_size);\n\tadc_context_start_read(data->context);\n\n\t/* Wait for the read operation to complete */\n\tadc_context_wait_for_completion(data->context);\n\n\treturn 0;\n}", "CodeBleu_score": 61.17936062441412}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tstruct adc_channel *channel = ctx->channel;\n\tstruct adc_repeat_buffer *buffer = ctx->buffer;\n\n\tadc_set_channel(channel);\n\tadc_set_repeat_buffer(buffer);\n\tadc_start_sampling();\n\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 26.59184858523303}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *adc_data = ctx->adc_data;\n\tadc_data->adc_channels = ctx->adc_channels;\n\tadc_data->adc_repeat_buffer = ctx->adc_repeat_buffer;\n\tadc_data->adc_repeat_buffer_size = ctx->adc_repeat_buffer_size;\n\tadc_data->adc_repeat_buffer_index = 0;\n\tadc_data->adc_repeat_buffer_end = 0;\n\tadc_data->adc_repeat_buffer_full = 0;\n\tadc_data->adc_repeat_buffer_empty = 1;\n\tadc_data->adc_repeat_buffer_overflow = 0;\n\tadc_data->adc_repeat_buffer_underflow = 0;\n\tadc_data->adc_sampling_done = 0;\n\tadc_data->adc_sampling_done_sem = ctx->adc_sampling_done_sem;\n\tadc_data->adc_sampling_done_sem_value = 0;\n\tadc_data->adc_sampling_done_sem_max_value = 1;\n\tadc_data->adc_sampling_done_sem_type = SEM_TYPE_COUNTING;\n\tadc_data->adc_sampling_done_sem_initial_value = 0;\n\tadc_data->adc_sampling_done_sem_max_value = 1;\n\tadc_data->adc_sampling_done_sem_options = 0;\n\tadc_data->adc_sampling_done_sem_name = NULL;\n\tadc_data->adc_sampling_done_sem_handle = NULL;\n\tadc_data->adc_sampling_done_sem_handle = k_sem_init(&adc_data->adc_sampling_done_sem, adc_data->adc_sampling_done_sem_initial_value, adc_data->adc_sampling_done_sem_max_value, adc_data->adc_sampling_done_sem_type, adc_data->adc_sampling_done_sem_options, adc_data->adc_sampling_done_sem_name);\n\tk_sem_give(adc_data->adc_sampling_done_sem_handle);\n}", "CodeBleu_score": 41.441295588254164}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tuint8_t *buffer = data->buffer;\n\tuint32_t i;\n\n\t// set the channels to be sampled\n\tadc_set_channels(data->channels);\n\n\t// initialize the repeat buffer\n\tfor (i = 0; i < data->buffer_size; i++) {\n\t\tbuffer[i] = 0;\n\t}\n\n\t// release the semaphore to signal the start of sampling\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 36.616421864315534}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = ctx->adc_data_container;\n\tif (repeat_sampling) {\n\t\tadc_data_container->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tadc_data_container->buffer_pointer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 46.06184475309036}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data = &ctx->adc_data;\n\tstruct adc_data_container_buffer *adc_data_buffer = &adc_data->adc_data_buffer;\n\n\tif (repeat_sampling) {\n\t\tadc_data_buffer->adc_data_buffer_pointer = adc_data_buffer->adc_data_buffer_repeat_pointer;\n\t} else {\n\t\tadc_data_buffer->adc_data_buffer_pointer = adc_data_buffer->adc_data_buffer_pointer_normal;\n\t}\n}", "CodeBleu_score": 44.093273882426374}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = &ctx->adc_data_container;\n\tif (repeat_sampling) {\n\t\tadc_data_container->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tadc_data_container->buffer_pointer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 45.9452504932863}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\ttruct k_sem *sem = &data->sem;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for semaphore to be released */\n\t\tk_sem_take(sem, K_FOREVER);\n\n\t\t/* Iterate through active channels */\n\t\tfor (channel = 0; channel < data->active_channels; channel++) {\n\t\t\t/* Read ADC value */\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC channel %d: %d\", channel, ret);\n\t\t\t\tdata->context_complete = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Store result in buffer */\n\t\t\tdata->results[channel] = result;\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tadc_context_on_sampling_done(data->context);\n\t}\n}", "CodeBleu_score": 50.65108447207605}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->dev->config;\n\tuint16_t result;\n\tint ret;\n\tint i;\n\tint channel;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (i = 0; i < config->channels_count; i++) {\n\t\t\tchannel = data->channels[i];\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"ADC channel %d failed to read\", channel);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdata->results[i] = result;\n\t\t}\n\n\t\tadc_context_on_sampling_done(data);\n\t\tcontinue;\n\nerror:\n\t\tadc_context_complete(data);\n\t}\n}", "CodeBleu_score": 51.71284493426379}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\ttruct adc_context *ctx = &data->ctx;\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tint i;\n\tint ret;\n\tuint16_t val;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (i = 0; i < data->num_channels; i++) {\n\t\t\tif (data->channels[i] == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, data->channels[i], &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", data->channels[i], ret);\n\t\t\t\tadc_context_complete(ctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata->buf[i] = val;\n\t\t}\n\n\t\tadc_context_on_sampling_done(ctx);\n\t}\n}", "CodeBleu_score": 47.533212256078485}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[2] = {0};\n\tint rc = 0;\n\tint i = 0;\n\tint timeout = 10000;\n\n\twhile (timeout--) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (!(reg_val[0] & 0x80)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n\n\tif (timeout == 0) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.33062863224458}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\n\t/*\n\t * Wait for the ADS1112 device to be ready for data reading.\n\t */\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t\tk_sleep(config->ready_time);\n\t} while (reg_val & ADS1112_REG_CONFIG_DRDY);\n\n\treturn 0;\n}", "CodeBleu_score": 38.28929143544496}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tint rc = 0;\n\tuint8_t reg_val[2] = {0};\n\n\t/*\n\t * Wait for the device to be ready for data reading.\n\t * The ready time is specified in the device's configuration register.\n\t */\n\tk_sleep(config->ready_time);\n\n\t/*\n\t * Read the configuration register.\n\t * If the device is not ready, sleep for 100 microseconds and check the status again.\n\t */\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\twhile (reg_val[0] & ADS1112_CONFIG_DRDY) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 49.24516288406016}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t buffer_size = 0;\n\tuint32_t num_samplings = 0;\n\tuint32_t num_extra_samplings = 0;\n\tuint32_t num_channels = 0;\n\tuint32_t i = 0;\n\n\tif (sequence == NULL) {\n\t\treturn -1;\n\t}\n\n\t/* Calculate the number of samplings, including any extra samplings specified in the sequence options. */\n\tnum_samplings = sequence->options & ADC_SAMPLING_MODE_MASK;\n\tnum_extra_samplings = (sequence->options & ADC_EXTRA_SAMPLING_MASK) >> ADC_EXTRA_SAMPLING_SHIFT;\n\tnum_samplings += num_extra_samplings;\n\n\t/* Calculate the number of channels in the sequence. */\n\tnum_channels = 0;\n\tfor (i = 0; i < ADC_MAX_CHANNELS; i++) {\n\t\tif (sequence->channels[i]!= 0) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\t/* Calculate the required buffer size based on the number of samplings and channels. */\n\tbuffer_size = (num_samplings * num_channels * 2) + 1;\n\n\t/* Check if the buffer size is sufficient. */\n\tif (buffer_size < ADC_BUFFER_SIZE) {\n\t\tLOG_ERR(\"Buffer size is not sufficient.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.6132363301771}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\tint samplings = sequence->options & ADC_SAMPLING_COUNT_MASK;\n\tint extra_samplings = sequence->options & ADC_EXTRA_SAMPLING_COUNT_MASK;\n\tif (samplings == 0) {\n\t\tLOG_ERR(\"Invalid number of samplings specified in the sequence options: %d\", samplings);\n\t\treturn -1;\n\t}\n\tif (extra_samplings == 0) {\n\t\tbuffer_size = samplings;\n\t} else {\n\t\tbuffer_size = samplings + extra_samplings;\n\t}\n\tif (buffer_size < 2) {\n\t\tLOG_ERR(\"Insufficient buffer size for the specified number of samplings: %d\", buffer_size);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 42.04432784338078}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint num_samplings = 0;\n\tint i;\n\tint extra_samplings = 0;\n\n\tfor (i = 0; i < sequence->options.num_samples; i++) {\n\t\tif (sequence->options.samples[i] == ADS1112_SAMPLE_CONTINUOUS) {\n\t\t\tnum_samplings += 1;\n\t\t} else if (sequence->options.samples[i] == ADS1112_SAMPLE_SINGLE) {\n\t\t\tnum_samplings += 1;\n\t\t\textra_samplings += 1;\n\t\t} else if (sequence->options.samples[i] == ADS1112_SAMPLE_INTERLEAVE) {\n\t\t\tnum_samplings += 1;\n\t\t\textra_samplings += 2;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid sample type: %d\", sequence->options.samples[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tint buffer_size = (num_samplings + extra_samplings) * (sequence->options.channels + 1);\n\tif (buffer_size < sequence->options.buffer_size) {\n\t\tLOG_ERR(\"Buffer size %d is too small for the requested sequence. \"\n\t\t\t\"Required buffer size: %d\",\n\t\t\tsequence->options.buffer_size, buffer_size);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 31.631803032682498}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret = 0;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\tadc_context_start_read(dev);\n\n\tif (wait) {\n\t\treturn adc_context_wait_for_completion(dev);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 55.629203035515616}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\tadc_context_start_read(dev, sequence->buffer, sequence->buffer_size);\n\tif (wait) {\n\t\treturn adc_context_wait_for_completion(dev);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 56.959699387834796}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tstruct adc_context *ctx = &data->ctx;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tctx->sequence = sequence;\n\n\tif (wait) {\n\t\treturn adc_context_wait_for_completion(ctx);\n\t}\n\n\tadc_context_start_read(ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 53.70385985756365}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\tif (argc!= 2) {\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Error: device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret!= 0) {\n\t\tshell_error(sh, \"Error: audio codec apply properties failed\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 61.27927371765336}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\tret = audio_codec_apply_properties(dev, argv[2], argv[3]);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 52.10340178657582}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\tstruct audio_codec_apply_properties_params params;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Usage: %s <device_name> <prop_name> <prop_value>\n\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Error: device %s not found\n\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tparams.prop_name = argv[2];\n\tparams.prop_value = argv[3];\n\n\tret = audio_codec_apply_properties(dev, &params);\n\tif (ret) {\n\t\tshell_error(sh, \"Error: audio codec apply properties failed %d\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.84998602895163}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\n\t\tret = mpxxdtyy_i2s_configure(dev);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"Error configuring device\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Already configured\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.27356192612042}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t", "CodeBleu_score": 4.702895929663203}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint err = 0;\n\tstruct mpxxdtyy_data *data = dev->data;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\n\tif (data->state == MPPXDTYY_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tdata->state = MPPXDTYY_STATE_CONFIGURED;\n\t\t\tdata->i2s_cmd = MPPXDTYY_I2S_CMD_START;\n\t\t} else {\n\t\t\tdata->i2s_cmd = MPPXDTYY_I2S_CMD_STOP;\n\t\t}\n\t} else if (data->state == MPPXDTYY_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tdata->state = MPPXDTYY_STATE_ACTIVE;\n\t\t\tdata->i2s_cmd = MPPXDTYY_I2S_CMD_START;\n\t\t} else {\n\t\t\tdata->i2s_cmd = MPPXDTYY_I2S_CMD_STOP;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Invalid device state: %d\", data->state);\n\t\terr = -EINVAL;\n\t}\n\n\tif (err == 0) {\n\t\terr = mpxxdtyy_i2s_send_command(dev, data->i2s_cmd);\n\t\tif (err == 0) {\n\t\t\tdata->state = MPPXDTYY_STATE_CONFIGURED;\n\t\t}\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 44.76512313969832}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t command = AUXDISPLAY_HD44780_DISPLAY_OFF;\n\n\tif (enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (config->blink_mode == AUXDISPLAY_HD44780_BLINK_MODE_CURSOR) {\n\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t} else if (config->blink_mode == AUXDISPLAY_HD44780_BLINK_MODE_CURSOR_AND_BLINK) {\n\t\tcommand |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t\tcommand |= AUXDISPLAY_HD44780_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, command, config->mode);\n}", "CodeBleu_score": 58.44254267486117}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_ON;\n\t} else {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_OFF;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_BLINK) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 61.665320584982}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0x00;\n\n\tif (enabled) {\n\t\tcmd |= 0x04;\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcmd |= 0x02;\n\t}\n\n\tif (config->display_blink) {\n\t\tcmd |= 0x01;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 42.77737238158574}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (!config->busy_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_dt(config->busy_port);\n}", "CodeBleu_score": 40.187700250793284}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint busy_gpio_pin;\n\tint busy_gpio_pin_state;\n\n\tbusy_gpio_pin = config->busy_gpio_pin;\n\tif (busy_gpio_pin == -1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tbusy_gpio_pin_state = gpio_pin_get_dt(busy_gpio_pin);\n\tif (busy_gpio_pin_state < 0) {\n\t\treturn busy_gpio_pin_state;\n\t}\n\n\treturn busy_gpio_pin_state;\n}", "CodeBleu_score": 61.69168604466995}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (!config->busy_gpio_pin) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio_pin, &busy_pin_value);\n\n\treturn ret;\n}", "CodeBleu_score": 69.48655378426972}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tstruct auxdisplay_serlcd_config *config = dev->config;\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t command_buffer[2];\n\tint ret;\n\n\t/*\n\t * Construct the command buffer by appending the command prefix and the command itself.\n\t */\n\tcommand_buffer[0] = config->command_prefix;\n\tcommand_buffer[1] = command;\n\n\t/*\n\t * Write the command buffer to the device using I2C.\n\t */\n\tret = i2c_write(config->i2c, data->address, command_buffer,\n\t\t\tsizeof(command_buffer), false);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Introduce a delay specified in the device configuration before returning the result of the I2C write operation.\n\t */\n\tk_sleep(K_MSEC(config->delay_after_special_command));\n\n\treturn ret;\n}", "CodeBleu_score": 57.96659052291835}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\n\t/* Construct a buffer containing the special command prefix and the command itself. */\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\t/* Write the buffer to the device using the I2C bus. */\n\tint ret = i2c_write(config->i2c, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* Introduce a delay specified in the device configuration before returning the result of the I2C write operation. */\n\tk_sleep(K_MSEC(config->delay_ms));\n\n\treturn 0;\n}", "CodeBleu_score": 67.36214867125044}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = config->prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write(config->i2c_dev, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->delay_ms));\n\n\treturn 0;\n}", "CodeBleu_score": 66.76965861050952}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint ret;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = bbram_emul_check_invalid(dev);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data_ptr->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 65.64982786204268}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint ret;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset >= BBRAM_EMUL_SIZE) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EIO;\n\t}\n\n\tif (size == 0) {\n\t\treturn -EIO;\n\t}\n\n\tret = memcpy(data, &data_ptr->memory[offset], size);\n\tif (ret!= 0) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 46.63537661419576}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint ret = 0;\n\n\tif (offset + size > data_ptr->mem_size) {\n\t\tret = -EINVAL;\n\t} else if (bbram_emul_check_invalid(dev)) {\n\t\tret = -EIO;\n\t} else {\n\t\tmemcpy(data, data_ptr->mem + offset, size);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 58.85419962828453}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_struct = dev->data;\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\tif (offset + size > data_struct->size) {\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(data_struct->memory + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 66.12507644391317}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint ret;\n\n\tif (size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data_ptr->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.45225800257819}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tuint8_t *ram = data_ptr->ram;\n\tint rc;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\trc = memcpy(ram + offset, data, size);\n\tif (rc!= 0) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 60.87005346356924}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tstruct device *dev;\n\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, SHELL_E_USAGE_ERR);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, SHELL_E_DEVICE_NOT_FOUND);\n\t\treturn -ENODEV;\n\t}\n\n\terr = device_bind(dev);\n\tif (err) {\n\t\tshell_error(sh, SHELL_E_DEVICE_ALREADY_EXISTS);\n\t\treturn -EALREADY;\n\t}\n\n\t*bbram_dev = dev;\n\treturn 0;\n}", "CodeBleu_score": 59.273465965772246}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint ret;\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, SHELL_RCODE_USAGE_ERROR);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, SHELL_RCODE_DEVICE_NOT_FOUND);\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_enable(dev);\n\tif (ret) {\n\t\tshell_error(sh, SHELL_RCODE_DEVICE_BUSY);\n\t\treturn ret;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 59.266579490785944}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, SHELL_CMD_ARG_INVALID, argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, SHELL_DEVICE_NOT_FOUND, argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = device_bind(dev);\n\tif (err < 0) {\n\t\tshell_error(sh, SHELL_DEVICE_ALREADY_EXISTS, argv[1]);\n\t\treturn -EALREADY;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 58.44207000320919}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct uart_fifo_config *config = uart_fifo_get_config(dev);\n\tstruct uart_fifo_data *data = uart_fifo_get_data(dev);\n\n\tif (uart_fifo_read(dev, data->hdr_buf + data->hdr_len, config->hdr_len - data->hdr_len) < 0) {\n\t\tLOG_ERR(\"UART read failed\");\n\t} else {\n\t\tdata->hdr_len += config->hdr_len - data->hdr_len;\n\t}\n}", "CodeBleu_score": 31.116095482335876}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct uart_fifo_data *data = dev->data;\n\tint32_t bytes_read;\n\tuint8_t *hdr_ptr = data->hdr_buf + data->hdr_bytes_read;\n\tuint8_t *hdr_end = data->hdr_buf + UART_FIFO_HDR_BUF_SIZE;\n\n\tif (uart_fifo_read(dev, hdr_ptr, UART_FIFO_HDR_BUF_SIZE - data->hdr_bytes_read, &bytes_read)!= 0) {\n\t\tLOG_ERR(\"Failed to read header data from UART FIFO\");\n\t\treturn;\n\t}\n\n\tdata->hdr_bytes_read += bytes_read;\n\n\tif (data->hdr_bytes_read < UART_FIFO_HDR_BUF_SIZE) {\n\t\treturn;\n\t}\n\n\tif (hdr_ptr[0]!= UART_FIFO_HDR_MAGIC) {\n\t\tLOG_ERR(\"Invalid header magic number\");\n\t\treturn;\n\t}\n\n\tif (hdr_ptr[1]!= UART_FIFO_HDR_VERSION) {\n\t\tLOG_ERR(\"Invalid header version number\");\n\t\treturn;\n\t}\n\n\tdata->hdr_bytes_read = 0;\n\tdata->hdr_bytes_remaining = (hdr_ptr[2] << 8) | hdr_ptr[3];\n\n\tif (data->hdr_bytes_remaining > UART_FIFO_HDR_BUF_SIZE) {\n\t\tLOG_ERR(\"Invalid header size\");\n\t\treturn;\n\t}\n\n\tif (data->hdr_bytes_remaining > 0) {\n\t\treturn;\n\t}\n\n\tif (data->hdr_bytes_remaining == 0) {\n\t\tLOG_ERR(\"Invalid header size\");\n\t\treturn;\n\t}\n\n\tdata->hdr_bytes_remaining = 0;\n}", "CodeBleu_score": 37.52008389571382}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint32_t read_bytes = 0;\n\tint32_t bytes_to_read = 0;\n\tint32_t bytes_read = 0;\n\tuint8_t *hdr_ptr = NULL;\n\n\t/*\n\t * Calculate the number of bytes already read.\n\t */\n\tread_bytes = (int32_t) (hdr_read_ptr - hdr_buf);\n\n\t/*\n\t * Calculate the number of bytes remaining to be read.\n\t */\n\tbytes_to_read = (int32_t) (hdr_buf_end - hdr_read_ptr);\n\n\t/*\n\t * Attempt to read the remaining bytes from the UART FIFO into the header buffer.\n\t */\n\tbytes_read = uart_fifo_read(dev, hdr_read_ptr, bytes_to_read);\n\n\t/*\n\t * If the read operation fails, log an error message.\n\t */\n\tif (bytes_read < 0) {\n\t\tLOG_ERR(\"Error reading header from UART device.\");\n\t}\n\n\t/*\n\t * Otherwise, update the remaining byte count based on the number of bytes successfully read.\n\t */\n\telse {\n\t\thdr_read_ptr += bytes_read;\n\t}\n}", "CodeBleu_score": 29.335970479500112}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t *buffer = k_malloc(33);\n\tif (buffer == NULL) {\n\t\tLOG_ERR(\"Failed to allocate memory for discard buffer\");\n\t\treturn 0;\n\t}\n\n\tsize_t bytes_read = 0;\n\twhile (len > 0) {\n\t\tsize_t bytes_to_read = MIN(len, 33);\n\t\tsize_t bytes_read_now = uart_fifo_read(uart, buffer, bytes_to_read);\n\t\tif (bytes_read_now == 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART\");\n\t\t\tbreak;\n\t\t}\n\t\tlen -= bytes_read_now;\n\t\tbytes_read += bytes_read_now;\n\t}\n\tk_free(buffer);\n\treturn bytes_read;\n}", "CodeBleu_score": 33.50944814487379}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t temp_buf[33];\n\tsize_t bytes_read = 0;\n\n\tif (uart_fifo_read(uart, temp_buf, sizeof(temp_buf)) == sizeof(temp_buf)) {\n\t\tbytes_read = sizeof(temp_buf);\n\t} else {\n\t\tLOG_ERR(\"Failed to read from UART FIFO\");\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 49.030272824860155}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buffer[33];\n\tsize_t read;\n\n\tread = uart_fifo_read(uart, buffer, sizeof(buffer));\n\tif (read < len) {\n\t\tLOG_ERR(\"Failed to discard %u bytes\", len);\n\t}\n\n\treturn read;\n}", "CodeBleu_score": 50.60610694224168}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t", "CodeBleu_score": 5.021327460876122}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *chan_data = chan->data;\n\tstruct zbus_observer *observer;\n\tstruct zbus_observer *highest = NULL;\n\tint i;\n\n\tzbus_spinlock_lock(&chan_data->lock);\n\n\tfor (i = 0; i < chan->num_observers; i++) {\n\t\tobserver = &chan->observers[i];\n\t\tif (observer->enabled && observer->priority > highest->priority) {\n\t\t\thighest = observer;\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = highest->priority;\n\n\tzbus_spinlock_unlock(&chan_data->lock);\n}", "CodeBleu_score": 30.577335649549674}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t", "CodeBleu_score": 5.021327460876122}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_data->observers_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_observer *obs_in_chan = observation->obs;\n\n\t\t\tif (!obs_in_chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (obs == obs_in_chan) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.202585419728422}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_data.observers_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_data.observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tif (!observation->obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.368060188026814}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_end_idx;\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.42252070492725}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tk_spinlock_key_t key;\n\n\tk_is_in_isr();\n\n\tk_assert(obs!= NULL);\n\n\tkey = k_spin_lock(&obs->lock);\n\n\tobs->priority = k_thread_priority_get(k_current_get());\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 34.358128670934526}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (k_is_in_isr()) {\n\t\treturn -1;\n\t}\n\n\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\n\tzbus_spinlock_lock();\n\tzbus_obs_set_priority(obs, ZBUS_MIN_THREAD_PRIORITY);\n\tupdate_all_channels_hop(obs);\n\tzbus_spinlock_unlock();\n\n\treturn 0;\n}", "CodeBleu_score": 22.964392067610557}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tk_spinlock_key_t key = k_spin_lock(&zbus_observer_lock);\n\n\tk_is_in_isr();\n\n\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tzbus_obs_set_priority(obs, ZBUS_THREAD_PRIORITY_MIN);\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&zbus_observer_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 24.487084237302405}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tnt err = 0;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\tk_timeout_t end_time = sys_timepoint_calc(timeout);\n\n\tif (k_is_in_isr()) {\n\t\tend_time = k_uptime_get();\n\t}\n\n\tint prio = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 64.0302885874243}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tnt err = 0;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = k_uptime_delta(&chan->data->last_isr_time);\n\t}\n\n\tk_timepoint_t end_time = k_time_add_timeout(k_uptime_get(), timeout);\n\n\tint prio = 0;\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 59.59017631389554}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tnt err = 0;\n\tk_timepoint_t end_time;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\tif (k_is_in_isr()) {\n\t\tend_time = k_time_get();\n\t} else {\n\t\tend_time = k_time_add(k_time_get(), timeout);\n\t}\n\n\tint prio = 0;\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 58.79017658664163}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (Int == ETH_INT_NORMAL) {\n\t\tif (enable) {\n\t\t\tETH->NIE |= 0x00000001;\n\t\t} else {\n\t\t\tETH->NIE &= ~0x00000001;\n\t\t}\n\t} else if (Int == ETH_INT_ABNORMAL) {\n\t\tif (enable) {\n\t\t\tETH->NIE |= 0x00000002;\n\t\t} else {\n\t\t\tETH->NIE &= ~0x00000002;\n\t\t}\n\t} else {\n\t\tassert_param(IS_ETH_INT(Int));\n\t}\n}", "CodeBleu_score": 28.27797449505426}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t regval;\n\tuint32_t mask;\n\tuint32_t shift;\n\n\tassert_param(IS_ETH_INT(Int));\n\n\tregval = ETH_GetITStatus(Int);\n\tmask = (uint32_t) (Int & 0x0000000F);\n\tshift = (uint32_t) (Int & 0x000000F0);\n\tif (enable == DISABLE) {\n\t\t/* Clear the interrupt */\n\t\tETH_ClearITPendingBit(Int);\n\t\t/* Disable the interrupt */\n\t\tETH->IER &= ~mask;\n\t\t/* Update the normal and abnormal interrupt enable bits */\n\t\tif (regval == 0) {\n\t\t\tETH->NCR &= ~shift;\n\t\t} else {\n\t\t\tETH->NCR &= ~shift;\n\t\t\tETH->ACR &= ~shift;\n\t\t}\n\t} else {\n\t\t/* Enable the interrupt */\n\t\tETH->IER |= mask;\n\t\t/* Update the normal and abnormal interrupt enable bits */\n\t\tif (regval == 0) {\n\t\t\tETH->NCR |= shift;\n\t\t} else {\n\t\t\tETH->NCR |= shift;\n\t\t\tETH->ACR |= shift;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.41975522446096}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t itstatus = 0;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\n\t/* Check the interrupt status */\n\titstatus = ETH->MISR;\n\n\t/* Clear the interrupt */\n\tETH->MISR = Int;\n\n\t/* Check if the interrupt is normal or abnormal */\n\tif (Int & ETH_INT_ABNORMAL) {\n\t\t/* Clear the interrupt */\n\t\tETH->AICR = Int;\n\n\t\t/* Update the interrupt enable bit */\n\t\tif (enable == TRUE) {\n\t\t\tETH->AIE |= Int;\n\t\t} else {\n\t\t\tETH->AIE &= ~Int;\n\t\t}\n\t} else {\n\t\t/* Clear the interrupt */\n\t\tETH->NISR = Int;\n\n\t\t/* Update the interrupt enable bit */\n\t\tif (enable == TRUE) {\n\t\t\tETH->NIE |= Int;\n\t\t} else {\n\t\t\tETH->NIE &= ~Int;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.89503397762002}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t", "CodeBleu_score": 2.546149641071209}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t", "CodeBleu_score": 2.546149641071209}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *ptxdesc;\n\tuint32_t status;\n\n\tptxdesc = (ETH_TX_DESC *)ETH_TX_DESC_LIST_START;\n\tdo {\n\t\tstatus = ETH_ReadReg(ETH_BASE, ETH_DMATXDESC_OFFSET + (ptxdesc->Status & ETH_DMATXDESC_OWN_MASK));\n\t\tif ((status & ETH_DMATXDESC_OWN_MASK) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tptxdesc++;\n\t\tif (ptxdesc == (ETH_TX_DESC *)ETH_TX_DESC_LIST_END) {\n\t\t\tptxdesc = (ETH_TX_DESC *)ETH_TX_DESC_LIST_START;\n\t\t}\n\t} while (ptxdesc!= (ETH_TX_DESC *)ETH_TX_DESC_LIST_START);\n\treturn ptxdesc;\n}", "CodeBleu_score": 43.7324857930055}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\tcy_en_csdida_channel_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n\tif (device == RT_NULL) {\n\t\tLOG_E(\"device is null\");\n\t\treturn RT_ERROR;\n\t}\n\n\tif (Cy_CSDIDAC_OutputEnable(device->parent.user_data, cyp_dac_channel, *value)!= CY_RSLT_SUCCESS) {\n\t\tLOG_E(\"cyp_adc_convert failed\");\n\t\tresult = RT_ERROR;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 50.14159944615002}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t#if (CY_CSDIDAC_DEBUG == 1)\n    RT_ASSERT(device!= RT_NULL);\n#endif\n\n    cy_en_csdida_channel_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    cy_en_csdida_status_t cyp_dac_status = Cy_CSDIDAC_OutputEnable(device->parent.user_data, cyp_dac_channel, *value);\n\n    if (cyp_dac_status!= CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"cyp_adc_convert: failed to enable DAC output with value %d\n\", *value);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 56.06059354181991}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t#if defined(RT_USING_CSD_ADC)\n    rt_err_t result = RT_EOK;\n    cy_en_csd_idac_channel_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    RT_ASSERT(device!= RT_NULL);\n\n    /* Enable the DAC output with the specified value */\n    result = Cy_CSDIDAC_OutputEnable(device->parent.user_data, cyp_dac_channel, *value);\n    if (result!= CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"cyp_adc_convert: Cy_CSDIDAC_OutputEnable failed with error code %d\", result);\n    }\n\n    return result;\n#else\n    RT_ASSERT(0);\n    return -RT_ENOSYS;\n#endif\n}", "CodeBleu_score": 55.364157181216015}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t *p_buf;\n\trt_uint32_t *p_addr;\n\trt_uint32_t *p_end;\n\n\tp_buf = (rt_uint32_t *)buf;\n\tp_addr = (rt_uint32_t *)addr;\n\tp_end = (rt_uint32_t *)(addr + size);\n\n\tif (p_end > (rt_uint32_t *)FLASH_END) {\n\t\tLOG_E(\"Flash read error: Address is out of range.\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < size; i += 4) {\n\t\t*p_buf = *p_addr;\n\t\tp_buf++;\n\t\tp_addr++;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 41.703087583918496}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tint i = 0;\n\trt_uint32_t *p_buf = (rt_uint32_t *) buf;\n\trt_uint32_t *p_addr = (rt_uint32_t *) addr;\n\n\tif (addr + size > FLASH_32K_END_ADDR) {\n\t\tLOG_E(\"Read address exceeds flash memory's end address\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0; i < size / 4; i++) {\n\t\tp_buf[i] = p_addr[i];\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 45.75657757590602}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > FLASH_32K_END) {\n\t\tLOG_E(\"read 32k flash error, addr=%d, size=%d, end=%d\", addr, size, FLASH_32K_END);\n\t\treturn -RT_ERROR;\n\t}\n\tif (buf == RT_NULL) {\n\t\tLOG_E(\"read 32k flash error, buf is null\");\n\t\treturn -RT_ERROR;\n\t}\n\trt_uint32_t i = 0;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\treturn size;\n}", "CodeBleu_score": 47.977146039412}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\treturn cyhal_timer_read(timer->timer_obj);\n}", "CodeBleu_score": 14.12580500586142}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer!= RT_NULL);\n\n/* Get the timer object from the user data */\ncyhal_timer_t *obj = (cyhal_timer_t *)timer->data;\n\n/* Read the current count */\nreturn cyhal_timer_read(obj);\n}", "CodeBleu_score": 23.530473773326385}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(obj);\n}", "CodeBleu_score": 28.50932842614228}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.611528593983764}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n\tRT_ASSERT\n}", "CodeBleu_score": 5.446218766202625}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.611528593983764}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (fdt->fds[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* no empty slot found, expand fd table */\n\treturn fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 28.069942633652317}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfd = startfd;\n\twhile (fd < fdt->maxfd) {\n\t\tif (fdt->fds[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t\tfd++;\n\t}\n\n\treturn fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 27.549470491253135}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (fdt->fds[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/*\n\t * no empty slot found, try to expand the fd table\n\t */\n\tfd = fd_slot_expand(fdt, startfd);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 39.43543601070655}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tfor (i = 0; i < sizeof(errors) / sizeof(errors[0]); i++) {\n\t\tif (errors[i].code == error) {\n\t\t\treturn errors[i].str;\n\t\t}\n\t}\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 53.99125522764952}, {"code": "const char *rt_strerror(rt_err_t error){\n\t", "CodeBleu_score": 3.4236961536175192}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\n\terror = (error < 0)? -error : error;\n\n\tfor (i = 0; i < RT_ERR_NUM; i++) {\n\t\tif (error == rt_err_table[i].code) {\n\t\t\treturn rt_err_table[i].string;\n\t\t}\n\t}\n\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 48.81999364981895}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_spin_lock_irqsave(&rt_thread_idle_sethook_lock);\n\tif (rt_thread_idle_sethook_count < RT_THREAD_IDLE_HOOK_MAX) {\n\t\trt_thread_idle_sethook_list[rt_thread_idle_sethook_count++] = hook;\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_spin_unlock_irqrestore(&rt_thread_idle_sethook_lock);\n\treturn result;\n}", "CodeBleu_score": 30.214355022574463}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_spin_lock_irqsave(&idle_hook_lock);\n\tif (idle_hook_count < RT_THREAD_IDLE_HOOK_MAX) {\n\t\tidle_hook[idle_hook_count++] = hook;\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_spin_unlock_irqrestore(&idle_hook_lock);\n\treturn result;\n}", "CodeBleu_score": 29.240528337789595}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_spin_lock_irqsave(&idle_hook_list_lock);\n\tif (idle_hook_list_count < RT_THREAD_IDLE_HOOK_LIST_SIZE) {\n\t\tidle_hook_list[idle_hook_list_count++] = hook;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_spin_unlock_irqrestore(&idle_hook_list_lock);\n\treturn result;\n}", "CodeBleu_score": 26.70978851633439}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t err = RT_EOK;\n\trt_uint32_t level;\n\trt_list_t *p;\n\tstruct rt_thread *thread;\n\trt_list_t *list;\n\n\tlist = &rt_thread_idle_list;\n\trt_list_for_each(p, list) {\n\t\tthread = rt_list_entry(p, struct rt_thread, list);\n\t\tif (thread->idle_hook == hook) {\n\t\t\tthread->idle_hook = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p == list) {\n\t\terr = -RT_ENOSYS;\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 28.107818000458547}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_spinlock_t lock;\n\trt_thread_t *thread;\n\trt_list_t *list, *next;\n\trt_err_t result = RT_EOK;\n\n\trt_spin_lock_irqsave(&lock);\n\n\tlist = &rt_thread_idle_list;\n\tnext = list->next;\n\n\twhile (next!= list) {\n\t\tthread = rt_list_entry(next, rt_thread_t, list);\n\t\tnext = next->next;\n\n\t\tif (thread->idle_hook == hook) {\n\t\t\tthread->idle_hook = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (next == list) {\n\t\tresult = -RT_ENOSYS;\n\t}\n\n\trt_spin_unlock_irqrestore(&lock);\n\n\treturn result;\n}", "CodeBleu_score": 41.44965728560796}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = -RT_ERROR;\n\trt_spin_lock_irqsave(&_idle_hook_lock);\n\tstruct rt_thread_idle_hook *hook_entry = _idle_hook_list;\n\twhile (hook_entry!= RT_NULL) {\n\t\tif (hook_entry->hook == hook) {\n\t\t\thook_entry->hook = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t\thook_entry = hook_entry->next;\n\t}\n\trt_spin_unlock_irqrestore(&_idle_hook_lock);\n\treturn result;\n}", "CodeBleu_score": 46.230689916130665}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_list_t *thread;\n\trt_err_t result = RT_EOK;\n\n\trt_hw_interrupt_disable();\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\t\trt_list_remove(susp_list->next);\n\t\trt_thread_resume(thread, thread_error);\n\t}\n\trt_hw_interrupt_enable();\n\treturn result;\n}", "CodeBleu_score": 37.205532057627785}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_list_t *list_node;\n\trt_list_t *next;\n\trt_err_t result;\n\n\t/* Ensure the scheduler is unlocked */\n\trt_scheduler_lock();\n\n\t/* Dequeue and wake up each thread from the list */\n\twhile (!rt_list_is_empty(susp_list)) {\n\t\tlist_node = rt_list_first(susp_list);\n\t\tthread = rt_list_entry(list_node, rt_thread_t, suspend_list);\n\t\tnext = rt_list_next(list_node);\n\t\trt_list_remove(list_node);\n\t\tresult = rt_thread_resume(thread, thread_error);\n\t\tif (result!= RT_EOK) {\n\t\t\t/* If a thread cannot be resumed, remove it from the list and return an error */\n\t\t\trt_list_insert_before(susp_list, list_node);\n\t\t\trt_scheduler_unlock();\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/* Unlock the scheduler */\n\trt_scheduler_unlock();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 37.35047065111051}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t result;\n\trt_thread_t thread;\n\n\tif (rt_thread_scheduler_lock()) {\n\t\treturn RT_ERROR;\n\t}\n\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, suspend_list);\n\t\tif (thread->error == RT_EOK) {\n\t\t\tthread->error = thread_error;\n\t\t}\n\t\trt_thread_resume(thread);\n\t}\n\n\tresult = rt_thread_scheduler_unlock();\n\tif (result!= RT_EOK) {\n\t\treturn result;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 33.5422692687476}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t dev = RT_NULL;\n\trt_device_t old_dev = RT_NULL;\n\n\tif (name) {\n\t\told_dev = rt_console_get_device();\n\t\tdev = rt_device_find(name);\n\t\tif (dev!= RT_NULL) {\n\t\t\tif (dev!= old_dev) {\n\t\t\t\tif (old_dev!= RT_NULL) {\n\t\t\t\t\trt_device_close(old_dev);\n\t\t\t\t}\n\t\t\t\trt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM);\n\t\t\t\trt_console_set_device(dev);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old_dev;\n}", "CodeBleu_score": 49.625726619116186}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\tif (new_console!= RT_NULL) {\n\t\tif (new_console!= old_console) {\n\t\t\tif (old_console!= RT_NULL) {\n\t\t\t\trt_device_close(old_console);\n\t\t\t}\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)!= RT_EOK) {\n\t\t\t\trt_kprintf(\"rt_console_set_device: rt_device_open failed\n\");\n\t\t\t\treturn RT_NULL;\n\t\t\t}\n\t\t}\n\t\trt_console_set_device(new_console);\n\t}\n\treturn old_console;\n}", "CodeBleu_score": 51.575577107469584}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\n\tif (new_console!= RT_NULL) {\n\t\tif (new_console!= old_console) {\n\t\t\tif (old_console!= RT_NULL) {\n\t\t\t\trt_device_close(old_console);\n\t\t\t}\n\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM) == RT_EOK) {\n\t\t\t\trt_console_set_device(new_console);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 50.827029004737035}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_spinlock *lock = rt_object_get_spinlock(type);\n\trt_spin_lock_irqsave(lock);\n\trt_list_for_each(obj, &rt_object_list[type]) {\n\t\tcount++;\n\t}\n\trt_spin_unlock_irqrestore(lock);\n\treturn count;\n}", "CodeBleu_score": 26.91110745441938}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_class *object_class;\n\tint count = 0;\n\trt_spin_lock_irqsave(&object_class_list_lock);\n\tobject_class = rt_object_class_get(type);\n\tif (object_class) {\n\t\tstruct rt_list_head *pos;\n\t\trt_list_for_each(pos, &object_class->object_list) {\n\t\t\tstruct rt_object *object = rt_list_entry(pos, struct rt_object, object_list);\n\t\t\tcount++;\n\t\t}\n\t}\n\trt_spin_unlock_irqrestore(&object_class_list_lock);\n\treturn count;\n}", "CodeBleu_score": 32.648334414675304}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_spinlock_t *lock;\n\trt_list_t *list;\n\trt_object_t *obj;\n\tint count = 0;\n\n\tlock = rt_object_get_lock(type);\n\trt_spin_lock_irqsave(lock);\n\n\tlist = rt_object_get_list(type);\n\trt_list_for_each(list, obj) {\n\t\tcount++;\n\t}\n\n\trt_spin_unlock_irqrestore(lock);\n\n\treturn count;\n}", "CodeBleu_score": 32.57602533963592}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t", "CodeBleu_score": 1.5020509296100257}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\tRT_OBJECT_HOOK_CALL(RT_OBJECT_DETACH_HOOK, object);\n\trt_object_t info = rt_object_get_information(object);\n\trt_spin_lock_irqsave(&info->lock);\n\trt_list_remove(&info->list);\n\trt_spin_unlock_irqrestore(&info->lock);\n\tinfo->type = RT_OBJECT_TYPE_NONE;\n}", "CodeBleu_score": 32.01288682887421}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_t object_info;\n\tRT_ASSERT(object!= RT_NULL);\n\tRT_OBJECT_HOOK_CALL(object, RT_OBJECT_DETACH_HOOK);\n\tobject_info = rt_object_get_information(object);\n\tRT_ASSERT(object_info!= RT_NULL);\n\trt_spin_lock_irqsave(&(object_info->lock), object_info->irq_save);\n\trt_list_remove(&(object_info->list));\n\trt_spin_unlock_irqrestore(&(object_info->lock), object_info->irq_save);\n\tobject_info->type = RT_Object_Type_Unknown;\n}", "CodeBleu_score": 52.62221562369268}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result;\n\trt_object_t object;\n\tstruct rt_object_information *information;\n\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\tobject = rt_object_get_parent(obj);\n\tRT_ASSERT(object!= RT_NULL);\n\n\tinformation = rt_object_get_information((enum rt_object_class_type)object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tif (object->destroy!= RT_NULL) {\n\t\tresult = object->destroy(obj);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\trt_object_delete(obj);\n\treturn result;\n}", "CodeBleu_score": 43.764926450734144}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result = RT_EOK;\n\tstruct rt_object_information *information;\n\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n\tinformation = rt_object_get_information((enum rt_object_class_type)obj->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tif (information->destroy) {\n\t\tresult = information->destroy(obj);\n\t}\n\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 45.83427447443411}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result;\n\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\tif (obj->type & RT_Object_Class_Static) {\n\t\tRT_DEBUG_NOT_SUPPORTED();\n\t\treturn -RT_ENOSYS;\n\t}\n\n\tif (obj->destroy!= RT_NULL) {\n\t\tresult = obj->destroy(obj);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 44.152248980074006}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\tdefined(RT_USING_SMP) &&!defined(ARCH_USING_HW_THREAD_SELF)\n    rt_thread_t self;\n    rt_base_t lock;\n\n    lock = rt_hw_local_irq_disable();\n    self = rt_cpu_self()->current_thread;\n    rt_hw_local_irq_enable(lock);\n\n    RT_ASSERT(self!= RT_NULL);\n\n    rt_thread_close(self);\n#else\n    rt_thread_close(rt_thread_self());\n#endif\n}", "CodeBleu_score": 55.89884496354698}, {"code": "static void _thread_exit(void){\n\tdef RT_USING_SMP\n    rt_thread_t thread = rt_cpu_self()->current_thread;\n#else /* RT_USING_SMP */\n    rt_thread_t thread;\n    rt_base_t lock;\n#endif /*!RT_USING_SMP */\n\n    /* enter a critical section */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct list */\n    rt_list_insert_before(&(thread->thread_list), &(rt_thread_defunct_list));\n\n    /* exit critical section */\n    rt_exit_critical();\n\n    /* trigger context switch */\n    rt_schedule();\n}", "CodeBleu_score": 32.463017059771474}, {"code": "static void _thread_exit(void){\n\tdefined(RT_USING_HOOK)\n    /* invoke exit hook */\n    rt_thread_exit_hook(rt_thread_self());\n#endif\n    rt_thread_close(rt_thread_self());\n    rt_thread_defunct_enqueue(rt_thread_self());\n    rt_schedule();\n}", "CodeBleu_score": 45.14469963342707}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t", "CodeBleu_score": 2.7917483345743506}, {"code": "static void _thread_timeout(void *parameter){\n\t\tRT_ASSERT(parameter!= RT_NULL);\n\tRT_ASSERT(rt_list_isempty(&rt_thread_suspend_list) == RT_FALSE);\n\tRT_ASSERT(rt_list_find(&rt_thread_suspend_list, parameter)!= RT_NULL);\n\n\trt_thread_t *thread = (rt_thread_t *)parameter;\n\tRT_ASSERT(rt_thread_is_suspended(thread) == RT_TRUE);\n\n\trt_list_remove(&rt_thread_suspend_list, thread);\n\trt_list_insert_before(&rt_thread_ready_list, thread);\n\n\trt_schedule();\n}", "CodeBleu_score": 43.3129051359696}, {"code": "static void _thread_timeout(void *parameter){\n\t\tRT_ASSERT(parameter!= RT_NULL);\n\trt_thread_t thread = (rt_thread_t)parameter;\n\n\trt_kprintf(\"thread timeout: %s\n\", thread->name);\n\tRT_ASSERT(thread->state == RT_THREAD_SUSPENDED);\n\n\trt_list_remove(&thread->list);\n\trt_list_insert_after(&rt_thread_ready_list, &thread->list);\n\trt_thread_resume(thread);\n}", "CodeBleu_score": 36.81458527860683}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spinlock_t *lock = &thread->lock;\n\trt_list_t *list;\n\n\trt_spin_lock_irqsave(lock, thread->flags);\n\n\tlist = thread->mutex_list;\n\twhile (list!= RT_NULL) {\n\t\trt_mutex_t *mutex = rt_list_entry(list, rt_mutex_t, wait_list);\n\t\tlist = list->next;\n\t\trt_mutex_release(mutex);\n\t}\n\n\trt_spin_unlock_irqrestore(lock, thread->flags);\n}", "CodeBleu_score": 29.829016257292697}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_list_t *list, *next;\n\trt_mutex_t mutex;\n\trt_err_t result;\n\n\t/* Lock the thread's spinlock. */\n\trt_spin_lock_irqsave(&thread->lock, thread->irq_save);\n\n\t/* Check if the thread is waiting on a mutex. */\n\tlist = &thread->mutexes;\n\trt_list_for_each_safe(list, next) {\n\t\tmutex = rt_list_entry(list, rt_mutex_t, list);\n\n\t\t/* Remove the thread from the mutex's waiting list. */\n\t\tresult = rt_mutex_release(mutex, thread);\n\t\tif (result == RT_EOK) {\n\t\t\t/* Clear the pending object. */\n\t\t\tmutex->pending_object = RT_NULL;\n\t\t}\n\t}\n\n\t/* Release all mutexes the thread has taken. */\n\trt_mutex_drop_thread(thread);\n\n\t/* Restore the spinlock state. */\n\trt_spin_unlock_irqrestore(&thread->lock, thread->irq_save);\n}", "CodeBleu_score": 42.563024743817934}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spin_lock(&thread->lock);\n\tif (thread->mutex!= RT_NULL) {\n\t\trt_list_remove(&thread->list);\n\t\tthread->mutex = RT_NULL;\n\t}\n\trt_spin_unlock(&thread->lock);\n}", "CodeBleu_score": 18.596372784219845}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n\trt_thread_info_t thread_info;\n\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/*\n\t * Check the thread's state.\n\t */\n\tif (thread->parent.flag & RT_THREAD_FLAG_INIT)\n\t{\n\t\t/*\n\t\t * Calculate the thread's priority attributes.\n\t\t */\n\t\trt_thread_info_init(&thread_info, thread);\n\n\t\t/*\n\t\t * Reset the thread's state to the suspended state.\n\t\t */\n\t\trt_thread_suspend(thread);\n\n\t\t/*\n\t\t * Resume the thread and trigger a scheduler if available.\n\t\t */\n\t\tresult = rt_thread_resume(thread);\n\n\t\tif (result == RT_EOK)\n\t\t{\n\t\t\trt_thread_info_deinit(&thread_info);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The thread could not be resumed, so we must reset it to the initialization state.\n\t\t\t */\n\t\t\trt_thread_init(thread);\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = -RT_EINIT;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 51.71781645316812}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_entry *timer_entry;\n\trt_tick_t timeout_tick_temp;\n\n\t/* check if the highest level of the timer skip list is not empty */\n\tif (timer_list[RT_TIMER_SKIP_LIST_LEVELS - 1].head == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get the first timer entry */\n\ttimer_entry = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVELS - 1].head, rt_list_entry, list);\n\n\t/* set the timeout tick to the timer's timeout value */\n\ttimeout_tick_temp = timer_entry->timeout;\n\n\t/* return the timeout tick */\n\t*timeout_tick = timeout_tick_temp;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 50.04003346304189}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t", "CodeBleu_score": 5.182189237133654}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_entry *entry;\n\trt_uint32_t level;\n\n\tfor (level = RT_TIMER_LIST_LEVEL - 1; level > 0; level--) {\n\t\tif (!rt_list_isempty(timer_list[level])) {\n\t\t\tentry = rt_list_entry(rt_list_first(timer_list[level]), rt_timer_list_item, list);\n\t\t\t*timeout_tick = entry->timeout_tick;\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\treturn -RT_ENOSYS;\n}", "CodeBleu_score": 34.61146054708029}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_TIMER_ALL_SOFT\n    rt_timer_t timer;\n\n    RT_ASSERT(timeout!= RT_NULL);\n\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer!= RT_NULL)\n    {\n        _timer_init(timer, timeout, parameter, time, flag);\n        rt_list_init(&(timer->parent.tlist));\n        rt_list_insert_after(&(rt_timer_list), &(timer->parent.tlist));\n        rt_timer_name(timer, name);\n    }\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 57.478282383481925}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_TIMER_ALL_SOFT\n    rt_timer_t timer;\n\n    RT_ASSERT(timeout!= RT_NULL);\n\n    timer = rt_calloc(1, sizeof(struct rt_timer));\n    if (timer!= RT_NULL)\n    {\n        _timer_init(timer, timeout, parameter, time, flag);\n        rt_list_insert_after(&rt_timer_list, &timer->parent.list);\n    }\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 56.97390557744597}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_TIMER_ALL_SOFT\n    rt_timer_t timer;\n    RT_ASSERT(timeout!= RT_NULL);\n\n    timer = rt_malloc(sizeof(struct rt_timer));\n    if (timer!= RT_NULL)\n    {\n        _timer_init(timer, timeout, parameter, time, flag);\n        rt_list_insert_before(&(rt_timer_list), &(timer->parent.tlist));\n        rt_timer_control(timer, RT_TIMER_CTRL_SET_TIME, (rt_uint32_t)time);\n        rt_timer_control(timer, RT_TIMER_CTRL_ACTIVATE, 0);\n    }\n\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 56.488959247376826}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder for capturing the response.\n\trec := httptest.NewRecorder()\n\n\t// Call the router's ServeHTTP method to process the request.\n\ta.router.ServeHTTP(rec, req)\n\n\t// Copy the response headers from the recorder to the original response.\n\tfor k, v := range rec.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Copy the response status code from the recorder to the original response.\n\tres.WriteHeader(rec.Code)\n\n\t// Copy the response body from the recorder to the original response.\n\tio.Copy(res, rec.Body)\n}", "CodeBleu_score": 39.73713566422247}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\n\tres.WriteHeader(rec.Code)\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 62.767116534944655}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == 401 {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\tres.WriteHeader(rec.Code)\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 57.8664667779045}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// The function \"robeaux\" serves static assets in response to HTTP requests.\nIt retrieves the requested asset based on the URL path and checks for errors.\nIf the asset is found, it sets the appropriate Content-Type header based on the file extension (js, css, html).\nIt then writes the asset content to the response.\nIf an error occurs while retrieving the asset, it returns a 404 error.\n\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tres.Write([]byte(robeaux.Asset))\n}", "CodeBleu_score": 39.24257361361468}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t", "CodeBleu_score": 2.29984901754818}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the requested asset from the URL path\n\tassetPath := req.URL.Path\n\n\t// Check if the asset exists\n\tif _, err := os.Stat(assetPath); os.IsNotExist(err) {\n\t\thttp.Error(res, \"Asset not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Open the asset file\n\tfile, err := os.Open(assetPath)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Set the appropriate Content-Type header based on the file extension\n\tswitch filepath.Ext(assetPath) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response\n\tio.Copy(res, file)\n}", "CodeBleu_score": 59.29181698727331}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\ta.writeJSON(res, err, http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\ta.writeJSON(res, err, http.StatusInternalServerError)\n\t\treturn\n\t}\n\ta.writeJSON(res, connectionsJSON, http.StatusOK)\n}", "CodeBleu_score": 38.47412436527032}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"No robot found with name: \" + robotName,\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": \"Failed to marshal connections: \" + err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, map[string]string{\n\t\t\"connections\": string(connectionsJSON),\n\t})\n}", "CodeBleu_score": 40.53194705530884}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusNotFound, gobot.NewJSONError(err))\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 30.983569778774722}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 47.9779261626733}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\t// If we get here, the user is authorized.\n\t}\n}", "CodeBleu_score": 47.56677152451451}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 48.87222978544063}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(math.Min(slope*input+intercept, float64(toMax)), float64(toMin)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.96773985080796}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\treturn int(math.Round(slope*input + intercept))\n\t}\n}", "CodeBleu_score": 47.09588970194092}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(math.Min(slope*input+intercept, float64(toMax)), float64(toMin)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.96773985080796}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Connection is not valid\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = a.scale(raw)\n\n\treturn raw, a.lastScaledValue, nil\n}", "CodeBleu_score": 49.92573592625487}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Connection is not valid\")\n\t}\n\n\trawValue, err := reader.AnalogRead(a.Pin())\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.sensorCfg.scale(rawValue)\n\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 56.59795171619177}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Connection is not valid\")\n\t}\n\n\trawValue, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = rawValue\n\ta.lastScaled = a.sensorCfg.scale(rawValue)\n\n\treturn rawValue, a.lastScaled, nil\n}", "CodeBleu_score": 52.56239284283461}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 43.52982958392711}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 43.52982958392711}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 43.52982958392711}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(DefaultName)\n\td.AddEvent(NewVibrationEvent())\n\td.On(d.Event(VibrationEvent), func(data interface{}) {\n\t\tif vibration, ok := data.(int); ok {\n\t\t\tif vibration > 1000 {\n\t\t\t\td.Publish(NewVibrationEvent(vibration))\n\t\t\t}\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 34.461073801771555}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(DefaultName)\n\td.AddEvent(VibrationEvent)\n\td.On(VibrationEvent, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(VibrationEvent)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 44.394740080063556}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Initialize the driver\n\td := NewGrovePiezoVibrationSensorDriverWithName(\n\t\ta,\n\t\tpin,\n\t\tDefaultName,\n\t\topts...,\n\t)\n\n\t// Set up the event listener\n\tgo func() {\n\t\tfor data := range d.data {\n\t\t\tif data > 1000 {\n\t\t\t\td.Publish(d.Event, data)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn d\n}", "CodeBleu_score": 22.965847431435364}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period in milliseconds\n\ttonePeriod := 1000 / hz\n\n\t// Repeat the tone for the specified duration\n\tfor i := 0; i < int(duration/tonePeriod); i++ {\n\t\t// Toggle the buzzer on\n\t\terr := d.On()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\n\t\t// Toggle the buzzer off\n\t\terr = d.Off()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 54.60646052155924}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 || duration <= 0 {\n\t\treturn errors.New(\"Invalid frequency or duration\")\n\t}\n\n\tif d.BPM <= 0 {\n\t\treturn errors.New(\"Invalid BPM\")\n\t}\n\n\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := 1 / hz * 60 / d.BPM\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < int(duration/tonePeriod); i++ {\n\t\terr := d.On()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Second)\n\n\t\terr = d.Off()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.30134409581872}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 || duration <= 0 {\n\t\treturn errors.New(\"invalid frequency or duration\")\n\t}\n\tperiod := 1 / hz\n\tbpm := 60\n\tdurationInSeconds := duration / 1000\n\tdurationInBeats := durationInSeconds * bpm\n\tdurationInBeats = math.Ceil(durationInBeats)\n\tdurationInBeats = durationInBeats / 2\n\tdurationInBeats = int(durationInBeats)\n\tdurationInBeats = durationInBeats * 2\n\tfor i := 0; i < durationInBeats; i++ {\n\t\td.On()\n\t\ttime.Sleep(time.Duration(period) * time.Second)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(period) * time.Second)\n\t}\n\treturn nil\n}", "CodeBleu_score": 31.442422971654743}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.stopIfRunning()\n\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 30.58595756945493}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.528340806641403}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.58595756945493}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin, err := a.sys.NewAnalogPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 52.905521766303934}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not initialized\")\n\t}\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin = a.sys.NewAnalogPin(path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 56.20330901060083}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.newAnalogPin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 45.26422640258526}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 60.39754526414518}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 60.39754526414518}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.digitalPins == nil {\n\t\treturn nil, fmt.Errorf(\"digital pins not connected\")\n\t}\n\tfor _, pin := range a.digitalPins {\n\t\tif pin.ID() == id {\n\t\t\treturn pin, nil\n\t\t}\n\t}\n\tchip, line, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := a.NewDigitalPin(chip, line)\n\tpin.ApplyOptions(opts...)\n\ta.initialize(pin)\n\ta.digitalPins = append(a.digitalPins, pin)\n\treturn pin, nil\n}", "CodeBleu_score": 48.7418178566692}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.IsConnected() {\n\t\treturn nil, fmt.Errorf(\"the %s adaptor is not connected to any pins\", a.Name())\n\t}\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"the %s adaptor is not connected to any pins\", a.Name())\n\t}\n\tpin, err := a.getPin(id)\n\tif err!= nil {\n\t\tpin = a.newDigitalPin(id, opts...)\n\t}\n\tpin.ApplyOptions(opts...)\n\treturn pin, nil\n}", "CodeBleu_score": 31.27556616296773}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no digital pins connected\")\n\t}\n\n\tif len(opts) > 0 {\n\t\tfor _, opt := range opts {\n\t\t\tif!opt(a) {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid option provided\")\n\t\t\t}\n\t\t}\n\t}\n\n\tpin, ok := a.pins[id]\n\tif!ok {\n\t\tpin = a.newDigitalPin(id)\n\t\tif err := a.initialize(pin); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t} else {\n\t\tif err := pin.ApplyOptions(opts...); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 53.53979571292184}]}
