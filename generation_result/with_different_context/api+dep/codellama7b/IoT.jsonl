{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\twhile (desc != NULL) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 39.81264078589973}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\twhile (desc != NULL) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc +\n\t\t\t\tdesc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 37.5335384234466}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\twhile (desc->bDescriptorType != desc_id) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tdesc->bLength);\n\t\tif ((uint8_t *) desc >= (uint8_t *) & _UDC_DESC_STORAGE_END) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc;\n}", "CodeBleu_score": 36.480189985560564}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tuint8_t i;\n\tuint8_t *desc_ptr;\n\tuint8_t *desc_end;\n\tuint8_t desc_type;\n\tuint8_t desc_len;\n\tuint8_t desc_num;\n\tuint8_t desc_iface;\n\tuint8_t desc_setting;\n\tuint8_t desc_alt;\n\tuint8_t desc_class;\n\tuint8_t desc_subclass;\n\tuint8_t desc_protocol;\n\tuint8_t desc_ep_count;\n\tuint8_t desc_ep_addr;\n\tuint8_t desc_ep_attr;\n\tuint8_t desc_ep_size;\n\tuint8_t desc_ep_interval;\n\tuint8_t desc_ep_interval_cnt;\n\tuint8_t desc_ep_interval_type;\n\tuint8_t desc_ep_interval_max;\n\tuint8_t desc_ep_interval_cur;\n\tuint8_t desc_ep_interval_cur_cnt;\n\tuint8_t desc_ep_interval_cur_type;\n\tuint8_t desc_ep_interval_cur_max;\n\tuint8_t desc_ep_interval_cur_max_cnt;\n\tuint8_t desc_ep_interval_cur_max_type;\n\tuint8_t desc_ep_interval_cur_max_type_cnt;\n\tuint8_t desc_ep_interval_cur_max_type_max;\n\tuint8_t desc_ep_interval_cur_max_type_max_cnt;\n\tuint8_t desc_ep_interval_cur_max_type_max_type;\n\tuint8_t desc_ep_interval_cur_max_type_max_type_cnt;\n\tuint8_t desc_ep_interval_cur_max_type_max_type_max;\n\tuint8_t desc_ep_interval_cur_max_type_max_type_max_cnt;\n\tuint8_t desc_ep_interval_cur_max_type_max_type_max_type;\n\tuint8_t desc", "CodeBleu_score": 6.027139298295115}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tuint8_t *p_desc;\n\tuint8_t desc_type;\n\tuint8_t desc_len;\n\tuint8_t desc_num;\n\tuint8_t desc_index;\n\tuint8_t iface_num_temp;\n\tuint8_t setting_num_temp;\n\tuint8_t iface_desc_len;\n\tuint8_t iface_desc_type;\n\tuint8_t iface_desc_index;\n\tuint8_t iface_desc_num;\n\n\t/* Verify that there is a valid configuration. */\n\tif (udc_get_eof_conf() == false) {\n\t\treturn false;\n\t}\n\n\t/* Verify that the interface number is within bounds. */\n\tif (iface_num >= udc_get_num_of_ifaces()) {\n\t\treturn false;\n\t}\n\n\t/* Initialize the interface descriptor iterator. */\n\tp_desc = udc_get_conf_desc();\n\tdesc_index = 0;\n\tdesc_num = udc_get_conf_desc_len() / 2;\n\n\t/* Iterate through the descriptors, starting from the beginning of the configuration descriptor, and check each one to see if it matches the specified interface number and setting number. */\n\twhile (desc_index < desc_num) {\n\t\tdesc_type = p_desc[desc_index];\n\t\tdesc_len = p_desc[desc_index + 1];\n\t\tiface_desc_len = 0;\n\n\t\t/* If this is an interface descriptor, check to see if it matches the specified interface number and setting number. */\n\t\tif (desc_type == USB_DESC_TYPE_INTERFACE) {\n\t\t\tiface_desc_type = p_desc[desc_index + 2];\n\t\t\tiface_desc_index = desc_index + 3;\n\t\t\tiface_desc_num = p_desc[desc_index + 3];\n\t\t\tiface_num_temp = p_desc[iface_desc_index];\n\t\t\tsetting_num_temp =", "CodeBleu_score": 27.475385809331065}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tif (udc_config.num_configurations) {\n\t\tif (iface_num < udc_config.num_interfaces) {\n\t\t\tuint8_t *desc = udc_config.config_descriptor;\n\t\t\tuint8_t *end_desc = desc + udc_config.config_descriptor_size;\n\t\t\tuint8_t *iface_desc;\n\t\t\tuint8_t *end_iface_desc;\n\t\t\tuint8_t *desc_end;\n\t\t\tuint8_t desc_type;\n\t\t\tuint8_t desc_len;\n\t\t\tuint8_t iface_num_found;\n\t\t\tuint8_t setting_num_found;\n\t\t\twhile (desc < end_desc) {\n\t\t\t\tdesc_type = *desc;\n\t\t\t\tdesc_len = *(desc + 1);\n\t\t\t\tdesc_end = desc + desc_len;\n\t\t\t\tif (desc_type == 0x04) {\n\t\t\t\t\tiface_num_found = *(desc + 2);\n\t\t\t\t\tsetting_num_found = *(desc + 3);\n\t\t\t\t\tif (iface_num_found == iface_num) {\n\t\t\t\t\t\tif (setting_num_found == setting_num) {\n\t\t\t\t\t\t\tiface_desc = desc;\n\t\t\t\t\t\t\tend_iface_desc = desc_end;\n\t\t\t\t\t\t\tiface_desc += 4;\n\t\t\t\t\t\t\twhile (iface_desc < end_iface_desc) {\n\t\t\t\t\t\t\t\tdesc_type = *iface_desc;\n\t\t\t\t\t\t\t\tdesc_len = *(iface_desc + 1);\n\t\t\t\t\t\t\t\tif (desc_type == 0x04) {\n\t\t\t\t\t\t\t\t\tiface_desc += 2;\n\t\t\t\t\t\t\t\t\t*(iface_desc - 2) = 0x", "CodeBleu_score": 32.898040281013635}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\tuint16_t ep_status;\n\tudc_req_t *req = &udc_req;\n\tuint8_t ep_num = req->req_setup.wIndex & 0x0F;\n\tif (req->req_setup.wLength != 2) {\n\t\treturn false;\n\t}\n\tif (udd_ep_is_halted(ep_num)) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\tudd_set_setup_payload(ep_status, 2);\n\treturn true;\n}", "CodeBleu_score": 26.432471389248093}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tuint8_t ep_num = udd_setup_payload[1] & 0x7F;\n\tuint16_t *ep_status = &udd_ep_status[ep_num];\n\tuint8_t *ep_size = &udd_ep_size[ep_num];\n\tuint8_t *ep_buf = &udd_ep_buf[ep_num];\n\tuint8_t *ep_buf_size = &udd_ep_buf_size[ep_num];\n\tuint8_t *ep_buf_cnt = &udd_ep_buf_cnt[ep_num];\n\tuint8_t *ep_nak_cnt = &udd_ep_nak_cnt[ep_num];\n\tuint8_t *ep_in = &udd_ep_in[ep_num];\n\tuint8_t *ep_stall = &udd_ep_stall[ep_num];\n\tuint16_t *ep_mps = &udd_ep_mps[ep_num];\n\tuint8_t ep_status_value = 0;\n\tif (udd_setup_payload_length != sizeof(uint16_t)) {\n\t\treturn false;\n\t}\n\tif (udd_ep_is_halted(ep_num)) {\n\t\tep_status_value = 1;\n\t}\n\tif (udd_ep_is_stalled(ep_num)) {\n\t\tep_status_value |= 2;\n\t}\n\tif (udd_ep_is_in(ep_num)) {\n\t\tep_status_value |= 1;\n\t}\n\tCPU_TO_LE16(ep_status_value, ep_status);\n\treturn true;\n}", "CodeBleu_score": 28.465713307347436}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tudc_req_t * req = &udc_req;\n\tuint16_t ep_status;\n\tuint16_t ep_num;\n\tuint8_t ep_dir;\n\tuint16_t ep_addr;\n\tbool retval = false;\n\t\n\tif (req->req_len == 2) {\n\t\tep_num = req->req_index & 0x0F;\n\t\tep_dir = req->req_index & 0x80;\n\t\tep_addr = ep_num | ep_dir;\n\t\tif (ep_num == 0) {\n\t\t\tep_status = udd_ep_is_halted(ep_addr) ? 1 : 0;\n\t\t} else {\n\t\t\tep_status = udd_ep_is_halted(ep_addr) ? 1 : 0;\n\t\t}\n\t\tudd_set_setup_payload(0, &ep_status, 2);\n\t\tretval = true;\n\t}\n\treturn retval;\n}", "CodeBleu_score": 40.75122264609998}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num, setting_num;\n\tbool ret;\n\n\t// Check if the device is in a configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Get the requested interface number\n\tiface_num = udc_ctrl_req.wIndex & 0xFF;\n\n\t// Check if the interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tret = udc_update_iface_desc(iface_num, 0);\n\tif (ret) {\n\t\t// Update the interface descriptor to the current alternate setting\n\t\tsetting_num = udc_ctrl_req.wValue & 0xFF;\n\t\tret = udc_update_iface_desc(iface_num, setting_num);\n\t}\n\tif (ret) {\n\t\t// Forward the SETUP request to the UDI\n\t\tret = udi_api->setup();\n\t}\n\treturn ret;\n}", "CodeBleu_score": 65.87284002729105}, {"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\tiface_num = udc_setup_packet.wIndex;\n\tsetting_num = udc_setup_packet.wValue;\n\n\t// Check if the device is configured\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the request to the UDI\n\treturn udi_api->setup(udc_setup_packet.bRequest,\n\t\t\tudc_setup_packet.wValue,\n\t\t\tudc_setup_packet.wIndex,\n\t\t\tudc_setup_packet.wLength);\n}", "CodeBleu_score": 64.17265227312832}, {"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tusb_req_t *rq = &udi_api->ctrlreq;\n\n\tiface_num = rq->wIndex;\n\tsetting_num = rq->wValue;\n\n\t// Check if device is in a configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward SETUP request to UDI\n\treturn udi_api->setup();\n}", "CodeBleu_score": 68.15923810299755}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t// Initialize internal structures\n  udi_msc_nb_lun = get_nb_lun();\n  if (udi_msc_nb_lun == 0) {\n    // No LUNs available\n    return false;\n  }\n  udi_msc_lun_in_use = 0;\n  udi_msc_cbw.dCBWDataTransferLength = 0;\n  udi_msc_cbw.bmCBWFlags = 0;\n  udi_msc_cbw.bCBWLUN = 0;\n  udi_msc_cbw.bCBWCBLength = 0;\n  udi_msc_cbw.CBWCB[0] = 0;\n  udi_msc_cbw.dCBWSignature = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_csw.dCSWTag = 0;\n  udi_msc_csw.dCSWDataResidue = 0;\n  udi_msc_csw.bCSWStatus = 0;\n  udi_msc_cbw_received = false;\n  udi_msc_csw_send = false;\n  udi_msc_in_stall = false;\n  udi_msc_out_stall = false;\n\n  // Unload medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_nb_lun; i++) {\n    if (!mem_unload(i)) {\n      return false;\n    }\n  }\n\n  // Register callbacks\n  udd_g_ctrlreq.callback = udi_msc_setup_callback;\n  udd_g_ctrlreq.callback_arg = NULL;\n  udd_g_ctrlreq.callback_ex = udi_msc_setup_callback_ex;\n  udd_g_ctrlreq.callback_ex_arg = NULL;\n  udd_g_in_isoc.callback = udi_msc_in", "CodeBleu_score": 45.65808744007992}, {"code": "bool udi_msc_enable(void){\n\t// Initialize internal variables\n  udi_msc_nb_lun = 0;\n  udi_msc_cbw.dCBWDataTransferLength = 0;\n  udi_msc_cbw.bmCBWFlags = 0;\n  udi_msc_cbw.bCBWLUN = 0;\n  udi_msc_cbw.bCBWCBLength = 0;\n  udi_msc_cbw.CBWCB[0] = 0;\n  udi_msc_cbw.dCBWSignature = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWDataTransferLength = 0;\n  udi_msc_cbw.dCBWLUN = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi_msc_cbw.dCBWTag = 0;\n  udi", "CodeBleu_score": 14.372665634491844}, {"code": "bool udi_msc_enable(void){\n\t// Initialize internal structures\n  udi_msc_nb_lun = get_nb_lun();\n  if (udi_msc_nb_lun == 0) {\n    // No LUNs available\n    return false;\n  }\n  udi_msc_lun = 0;\n  udi_msc_cbw_received = false;\n  udi_msc_cbw_signature = 0;\n  udi_msc_cbw_tag = 0;\n  udi_msc_cbw_data_residue = 0;\n  udi_msc_cbw_data_direction = 0;\n  udi_msc_cbw_lun = 0;\n  udi_msc_cbw_length = 0;\n  udi_msc_cbw_cb[0] = 0;\n  udi_msc_cbw_cb[1] = 0;\n  udi_msc_cbw_cb[2] = 0;\n  udi_msc_cbw_cb[3] = 0;\n  udi_msc_cbw_cb[4] = 0;\n  udi_msc_cbw_cb[5] = 0;\n  udi_msc_cbw_cb[6] = 0;\n  udi_msc_cbw_cb[7] = 0;\n  udi_msc_cbw_cb[8] = 0;\n  udi_msc_cbw_cb[9] = 0;\n  udi_msc_cbw_cb[10] = 0;\n  udi_msc_cbw_cb[11] = 0;\n  udi_msc_cbw_cb[12] = 0;\n  udi_msc_cbw_cb[13] = 0;\n  udi_msc_cbw_cb[14] = 0;\n  udi_msc_cbw_cb[15] = 0;\n  udi_msc_cb", "CodeBleu_score": 26.732112308975843}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(nb_sent);\n  UNUSED(ep);\n\n  // Check status of data transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Data transfer error\n    // then STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n  }\n  // Prepare and send CSW\n  udi_msc_csw.dCSWDataResidue -= udi_msc_cbw.dCBWDataTransferLength;\n  udi_msc_csw_process();\n}", "CodeBleu_score": 64.379110897655}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep);\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Data transfer error\n    // then STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n  } else {\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    udi_msc_sense_pass();\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 70.46771338650473}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(nb_sent);\n  UNUSED(ep);\n  if (UDD_EP_TRANSFER_OK != status) {\n    // STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    // Reset the CBW reception\n    udi_msc_cbw_receive();\n    return;\n  }\n  // Data transfer is successful\n  // Update sense data\n  udi_msc_sense_pass();\n  // Decrease data residue in the Command Status Wrapper (CSW)\n  udi_msc_csw.dCSWDataResidue -= udi_msc_data_transfered;\n  // Process the updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 71.6387782314204}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n  udi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_GOOD;\n  udi_msc_csw_send();\n}", "CodeBleu_score": 39.39151996158346}, {"code": "static void udi_msc_csw_process(void){\n\t// If there is a non-zero data residue, then stall the next request\n  if (udi_msc_csw.dCSWDataResidue) {\n    // Stall the endpoint\n    udd_ep_set_halt(udi_msc_cbw.bmCBWFlags & 0x80 ? UDI_MSC_EP_IN : UDI_MSC_EP_OUT);\n  }\n\n  // Prepare the CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\n  // Send the CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 61.92321072213976}, {"code": "static void udi_msc_csw_process(void){\n\t// Check if there is a non-zero data residue\n  if (udi_msc_cbw.dCBWDataTransferLength != 0) {\n    // Stall the next request on the appropriate endpoint\n    if (udi_msc_cbw.bmCBWFlags & 0x80) {\n      // IN endpoint\n      udd_ep_set_stall(UDI_MSC_EP_IN);\n    } else {\n      // OUT endpoint\n      udd_ep_set_stall(UDI_MSC_EP_OUT);\n    }\n  }\n\n  // Prepare the CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n\n  // Send CSW on IN endpoint\n  udi_msc_csw_send();\n}", "CodeBleu_score": 71.99244618642437}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (port == 0) {\n        if (b_enable) {\n            if (g_b_dtr_1200 == false) {\n                g_b_dtr_1200 = true;\n                cancelReset();\n            }\n        } else {\n            if (g_b_dtr_1200 == true) {\n                g_b_dtr_1200 = false;\n                scheduleReset();\n            }\n        }\n    }\n}", "CodeBleu_score": 29.220193546990103}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n\t\t// DTR is enabled, cancel any scheduled reset\n\t\tcancelReset();\n\t} else {\n\t\t// DTR is disabled, schedule a delayed system reset\n\t\tscheduleReset(port);\n\t}\n}", "CodeBleu_score": 24.25954214947384}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n\t\t// DTR signal is enabled\n\t\t// Cancel any scheduled reset\n\t\tcancelReset(port);\n\t} else {\n\t\t// DTR signal is disabled\n\t\t// Schedule a delayed system reset\n\t\tscheduleReset(port);\n\t}\n}", "CodeBleu_score": 21.99058390687551}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\tuint8_t *payload = (uint8_t *)&usb_control_request.payload;\n\tuint16_t size = usb_control_request.size;\n\tuint8_t request = usb_control_request.request;\n\tuint8_t request_type = usb_control_request.request_type;\n\tuint8_t request_index = usb_control_request.request_index;\n\tuint8_t request_length = usb_control_request.request_length;\n\n\tif (request_type == 0x80) {\n\t\tif (request_index == 0x04) {\n\t\t\tif (request_length == 0x05) {\n\t\t\t\tusb_control_request.size = 0x05;\n\t\t\t\tpayload[0] = 0x04;\n\t\t\t\tpayload[1] = 0x00;\n\t\t\t\tpayload[2] = 0x00;\n\t\t\t\tpayload[3] = 0x00;\n\t\t\t\tpayload[4] = 0x00;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (request_index == 0x05) {\n\t\t\tif (request_length == 0x12) {\n\t\t\t\tusb_control_request.size = 0x12;\n\t\t\t\tpayload[0] = 0x05;\n\t\t\t\tpayload[1] = 0x00;\n\t\t\t\tpayload[2] = 0x00;\n\t\t\t\tpayload[3] = 0x00;\n\t\t\t\tpayload[4] = 0x00;\n\t\t\t\tpayload[5] = 0x00;\n\t\t\t\tpayload[6] = 0x00;\n\t\t\t\tpayload[7] = 0x00;\n\t\t\t\tpayload[8] = 0x00;\n\t\t\t\tpayload[9] = 0x00;\n\t\t\t\tpayload[10] = 0", "CodeBleu_score": 25.262020009444203}, {"code": "bool usb_task_other_requests(void){\n\tif (udd_g_ctrlreq.req.wIndex == 0x04) {\n\t\tif (udd_g_ctrlreq.req.wValue == 0x0000) {\n\t\t\tudd_g_ctrlreq.payload = (uint8_t *) &usb_microsoft_compatid_desc;\n\t\t\tudd_g_ctrlreq.payload_size = sizeof(usb_microsoft_compatid_desc);\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (udd_g_ctrlreq.req.wIndex == 0x05) {\n\t\tif (udd_g_ctrlreq.req.wValue == 0x0000) {\n\t\t\tudd_g_ctrlreq.payload = (uint8_t *) &usb_microsoft_extproperty_desc;\n\t\t\tudd_g_ctrlreq.payload_size = sizeof(usb_microsoft_extproperty_desc);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 26.12815864081655}, {"code": "bool usb_task_other_requests(void){\n\tswitch (usb_setup.bRequest) {\n\t\tcase 0x04:\n\t\t\t/*\n\t\t\t * The request index 0x04 is used to set up a pointer to a Microsoft-compatible ID descriptor, which is used by the Microsoft operating system to identify the device as a USB mouse.\n\t\t\t */\n\t\t\tusb_setup.wLength = sizeof(usb_microsoft_compatible_id_descriptor);\n\t\t\tusb_setup.wValue = 0;\n\t\t\tusb_setup.pData = (uint8_t *)&usb_microsoft_compatible_id_descriptor;\n\t\t\treturn true;\n\t\tcase 0x05:\n\t\t\t/*\n\t\t\t * The request index 0x05 is used to set up a pointer to a Microsoft-compatible extended properties descriptor, which is used by the Microsoft operating system to identify the device as a USB mouse.\n\t\t\t */\n\t\t\tusb_setup.wLength = sizeof(usb_microsoft_compatible_extended_properties_descriptor);\n\t\t\tusb_setup.wValue = 0;\n\t\t\tusb_setup.pData = (uint8_t *)&usb_microsoft_compatible_extended_properties_descriptor;\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}", "CodeBleu_score": 17.243091837217616}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint8_t i;\n    if (nbyte == 0) return;\n    for (i = 0; i < nbyte - 1; i++) {\n        SPI_PCS = 0;\n        spiRec();\n    }\n    SPI_PCS = 0;\n    buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 45.54163876809254}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\n    if (nbyte == 0) {\n        return;\n    }\n\n    for (i = 0; i < nbyte - 1; i++) {\n        SPI_PUSH(0);\n        while (SPI_ISR_RXNE == 0);\n        *buf++ = SPI_POP;\n    }\n\n    SPI_PUSH(0);\n    while (SPI_ISR_RXNE == 0);\n    *buf = spiRec();\n}", "CodeBleu_score": 44.88970382152301}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\tfor (i = 0; i < nbyte; i++) {\n\t\tif (i == nbyte - 1) {\n\t\t\tspiRec(&buf[i]);\n\t\t} else {\n\t\t\tspiSend(0x00);\n\t\t\tspiRec(&buf[i]);\n\t\t}\n\t}\n}", "CodeBleu_score": 44.58211349185154}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n    uint32_t *relocatedTableAddr;\n\n    /*\n     * Get the address of the relocated interrupt vector table.\n     */\n    relocatedTableAddr = get_relocated_table_addr();\n\n    /*\n     * Disable global interrupts.\n     */\n    DISABLE_INTERRUPTS();\n\n    /*\n     * Get the old handler.\n     */\n    oldHandler = relocatedTableAddr[irq];\n\n    /*\n     * Install the new handler.\n     */\n    relocatedTableAddr[irq] = newHandler;\n\n    /*\n     * Enable global interrupts.\n     */\n    ENABLE_INTERRUPTS();\n\n    /*\n     * Return the old handler.\n     */\n    return oldHandler;\n}", "CodeBleu_score": 51.08173648336665}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n    CRITICAL_SECTION_START\n    oldHandler = get_isr(irq);\n    set_isr(irq, newHandler);\n    CRITICAL_SECTION_END\n    return oldHandler;\n}", "CodeBleu_score": 40.08908460133983}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tCRITICAL_SECTION_START\n\tpfnISR_Handler oldHandler;\n\toldHandler = get_relocated_table_addr(irq);\n\tset_relocated_table_addr(irq, newHandler);\n\tCRITICAL_SECTION_END\n\n\treturn oldHandler;\n}", "CodeBleu_score": 40.86928144120523}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\tif (isEnabled() && (is_usb_cdc_enabled() || emergency_parser.enabled)) {\n    if (emergency_parser.enabled) {\n      if (emergency_parser.update())\n        return emergency_parser.getc();\n    }\n    else {\n      if (udi_cdc_getc() != -1)\n        return udi_cdc_getc();\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 39.651234112695}, {"code": "int MarlinSerialUSB::peek(){\n\tif (usb_cdc_enabled && (usb_cdc_rx_byte_count > 0)) {\n    if (emergency_parser.enabled)\n      emergency_parser.update();\n    return usb_cdc_rx_buffer[usb_cdc_rx_head];\n  }\n  return -1;\n}", "CodeBleu_score": 23.890658408584695}, {"code": "int MarlinSerialUSB::peek(){\n\tif (is_enabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      return udi_cdc_getc();\n    }\n    else {\n      return -1;\n    }\n  }\n  else {\n    return -1;\n  }\n}", "CodeBleu_score": 13.521282409180312}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\tif (rx_buffer_head != rx_buffer_tail) {\n    uint8_t c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % SERIAL_BUFFER_SIZE;\n    return c;\n  }\n  if (!udi_cdc_is_rx_ready()) return -1;\n  if (!usb_task_cdc_isenabled()) return -1;\n  uint8_t c = udi_cdc_getc();\n  if (emergency_parser.enabled) emergency_parser.update(c);\n  return c;\n}", "CodeBleu_score": 55.03396260054695}, {"code": "int MarlinSerialUSB::read(){\n\tif (available()) return _rx_buffer[_rx_buffer_head++];\n  if (!udi_cdc_is_rx_ready()) return -1;\n  if (!usb_task_cdc_isenabled()) return -1;\n  uint8_t c = udi_cdc_getc();\n  if (emergency_parser.update(c)) return emergency_parser.get_value();\n  return c;\n}", "CodeBleu_score": 45.79578578135132}, {"code": "int MarlinSerialUSB::read(){\n\tif (available()) {\n    return udi_cdc_getc();\n  }\n  if (!udi_cdc_is_rx_ready()) {\n    return -1;\n  }\n  if (!usb_task_cdc_isenabled()) {\n    return -1;\n  }\n  return udi_cdc_getc();\n}", "CodeBleu_score": 24.118587209851412}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\tif (rx_buffer_head != rx_buffer_tail) {\n    return rx_buffer_head - rx_buffer_tail;\n  }\n  if (udi_cdc_is_rx_ready()) {\n    return 1;\n  }\n  return 0;\n}", "CodeBleu_score": 36.456586076657}, {"code": "int MarlinSerialUSB::available(){\n\tif (rx_buffer_head != rx_buffer_tail) {\n    return (rx_buffer_head - rx_buffer_tail);\n  }\n  if (udi_cdc_is_rx_ready()) {\n    return 1;\n  }\n  return 0;\n}", "CodeBleu_score": 36.467380504906735}, {"code": "int MarlinSerialUSB::available(){\n\tif (usb_task_cdc_isenabled()) {\n    return udi_cdc_is_rx_ready();\n  }\n  return 0;\n}", "CodeBleu_score": 22.124010677667812}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tif (writing) {\n    while (size--) {\n      *value++ = ee_Read(pos++);\n      if (crc)\n        crc16(crc, value - 1, 1);\n    }\n  }\n  else {\n    while (size--) {\n      if (crc)\n        crc16(crc, value, 1);\n      *value++ = ee_Read(pos++);\n    }\n  }\n  return false;\n}", "CodeBleu_score": 46.458795321361926}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t *buf = value;\n  while (size--) {\n    if (writing)\n      *buf++ = ee_Read(pos++);\n    else\n      pos++;\n    if (crc)\n      crc16(crc, &value, 1);\n  }\n  return false;\n}", "CodeBleu_score": 56.39796974976539}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t * const data = (uint8_t*)value;\n\n  while (size--) {\n    if (writing)\n      *data++ = ee_Read(pos++);\n    else\n      ee_Read(pos++);\n    if (crc)\n      crc16(crc, value, 1);\n  }\n\n  return false;\n}", "CodeBleu_score": 50.41122517163228}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tint8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n  else {\n    // Software PWM\n    if (pin == 5) {\n      if (value == 0) {\n        WRITE(5, LOW);\n        SET_OUTPUT(5);\n      }\n      else {\n        SET_INPUT(5);\n        WRITE(5, HIGH);\n        delayMicroseconds(value);\n        WRITE(5, LOW);\n      }\n    }\n    else if (pin == 6) {\n      if (value == 0) {\n        WRITE(6, LOW);\n        SET_OUTPUT(6);\n      }\n      else {\n        SET_INPUT(6);\n        WRITE(6, HIGH);\n        delayMicroseconds(value);\n        WRITE(6, LOW);\n      }\n    }\n    else if (pin == 13) {\n      if (value == 0) {\n        WRITE(13, LOW);\n        SET_OUTPUT(13);\n      }\n      else {\n        SET_INPUT(13);\n        WRITE(13, HIGH);\n        delayMicroseconds(value);\n        WRITE(13, LOW);\n      }\n    }\n    else if (pin == 12) {\n      if (value == 0) {\n        WRITE(12, LOW);\n        SET_OUTPUT(12);\n      }\n      else {\n        SET_INPUT(12);\n        WRITE(12, HIGH);\n        delayMicroseconds(value);\n        WRITE(12, LOW);\n      }\n    }\n    else if (pin == 10) {\n      if (value == 0) {\n        WRITE(10, LOW);\n        SET_OUTPUT(10);\n      }\n      else {\n        SET_INPUT(10);\n        WR", "CodeBleu_score": 45.27921721365003}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return; // Not a hardware PWM pin!\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n  else {\n    // Start timer if this is the first PWM pin used\n    if (pwm_count == 0) {\n      HAL_timer_start(PWM_TIMER_NUM, PWM_TIMER_CHANNEL);\n    }\n    // Allocate a new PWM slot\n    if (pwm_count < PWM_MAX_SLOT) {\n      pwm_count++;\n      pwm_pin[pwm_count - 1] = pin;\n      pwm_value[pwm_count - 1] = value;\n      pwm_freq[pwm_count - 1] = freq;\n      pwm_res[pwm_count - 1] = res;\n    }\n    else {\n      // No more PWM slots available\n      SERIAL_ERROR_START;\n      SERIAL_ERRORLNPGM(\"No more PWM slots available!\");\n      return;\n    }\n  }\n}", "CodeBleu_score": 47.1374855089952}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (pin >= MAX_PWM_IOPIN) return; // Not a hardware PWM pin!\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid < 0) return; // No channel available\n\n  ledcWrite(cid, value);\n}", "CodeBleu_score": 32.37028232733969}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\tstatic_assert(SERVO_DELAY_LENGTH == SERVO_COUNT, \"SERVO_DELAY_LENGTH != SERVO_COUNT\");\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 49.572162839741665}, {"code": "void Servo::move(const int value){\n\tstatic_assert(SERVO_DELAY_LENGTH == SERVO_COUNT, \"Servo delay array length must equal servo count\");\n  if (attach()) {\n    write(value);\n    safe_delay(SERVO_DELAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 39.027505316861145}, {"code": "void Servo::move(const int value){\n\tstatic_assert(SERVO_DELAY_LENGTH == NUM_SERVOS, \"Servo::move: SERVO_DELAY_LENGTH must be equal to NUM_SERVOS\");\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 52.13343357940248}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t// 1. Update the PWM states for each pin\n    for (uint8_t i = 0; i < 16; i++) {\n        if (pwm_state[i].duty_cycle > 0) {\n            if (pwm_state[i].tick_count == 0) {\n                if (pwm_state[i].state == 1) {\n                    pwm_state[i].state = 0;\n                } else {\n                    pwm_state[i].state = 1;\n                }\n                pwm_state[i].tick_count = pwm_state[i].duty_cycle;\n            } else {\n                pwm_state[i].tick_count--;\n            }\n        }\n    }\n    // 2. Write the resulting data to the DMA buffer\n    for (uint8_t i = 0; i < 16; i++) {\n        if (pwm_state[i].state == 1) {\n            dma_buffer[dma_buffer_position] = 1 << i;\n        } else {\n            dma_buffer[dma_buffer_position] = 0;\n        }\n        dma_buffer_position++;\n        if (dma_buffer_position == DMA_BUFFER_SIZE) {\n            dma_buffer_position = 0;\n        }\n    }\n}", "CodeBleu_score": 42.84077930737795}, {"code": "void i2s_push_sample(){\n\t// Update the PWM states for each pin\n    for (uint8_t i = 0; i < PINS_COUNT; i++) {\n        if (pins[i].pwm_tick_count > 0) {\n            pins[i].pwm_tick_count--;\n        }\n\n        // Check if the pin has active PWM\n        if (pins[i].pwm_tick_count == 0) {\n            // Toggle the pin state\n            pins[i].state = !pins[i].state;\n\n            // Set the tick count for the next transition\n            pins[i].pwm_tick_count = pins[i].pwm_tick_length;\n        }\n    }\n\n    // Write the updated port data to the current position of the DMA buffer\n    *(uint32_t*)(DMA_BUFFER_ADDRESS + dma_buffer_position) = port_data;\n\n    // Increment the buffer position\n    dma_buffer_position += 4;\n\n    // Check if the buffer position has reached the end of the buffer\n    if (dma_buffer_position == DMA_BUFFER_SIZE) {\n        dma_buffer_position = 0;\n    }\n}", "CodeBleu_score": 35.11737791693965}, {"code": "void i2s_push_sample(){\n\tfor (int i = 0; i < 16; i++) {\n\t\tif (pwm_states[i].duty_cycle > 0) {\n\t\t\tif (pwm_states[i].tick_count == 0) {\n\t\t\t\tpwm_states[i].pin_state = !pwm_states[i].pin_state;\n\t\t\t\tpwm_states[i].tick_count = pwm_states[i].duty_cycle;\n\t\t\t}\n\t\t\tpwm_states[i].tick_count--;\n\t\t\tif (pwm_states[i].pin_state) {\n\t\t\t\tport_data[pwm_states[i].port] |= (1 << pwm_states[i].pin);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tport_data[pwm_states[i].port] &= ~(1 << pwm_states[i].pin);\n\t\t\t}\n\t\t}\n\t}\n\t*(dma_buffer++) = port_data[0];\n\t*(dma_buffer++) = port_data[1];\n\t*(dma_buffer++) = port_data[2];\n\t*(dma_buffer++) = port_data[3];\n\t*(dma_buffer++) = port_data[4];\n\t*(dma_buffer++) = port_data[5];\n\t*(dma_buffer++) = port_data[6];\n\t*(dma_buffer++) = port_data[7];\n\t*(dma_buffer++) = port_data[8];\n\t*(dma_buffer++) = port_data[9];\n\t*(dma_buffer++) = port_data[10];\n\t*(dma_buffer++) = port_data[11];\n\t*(dma_buffer++) = port_data[12];\n\t*(dma_buffer++) = port_data[13];\n\t*(dma_buffer++) = port_data[14];\n\t*(dma_buffer++) = port_data[15];\n}", "CodeBleu_score": 38.27442035915519}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\tif", "CodeBleu_score": 23.76438294758681}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\treturn timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.481424464712367}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\treturn timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.481424464712367}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    if (writing) *value++ = eeprom_read_byte((uint8_t*)(pos + i));\n    crc16(crc, (uint8_t*)(pos + i), 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 67.09413419671277}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (size == 0) return true;\n  if (pos + size > capacity()) return false;\n  uint8_t *ptr = value;\n  while (size--) {\n    *ptr++ = eeprom_read_byte((uint8_t *)pos);\n    if (crc) crc16(crc, ptr - 1, 1);\n    pos++;\n  }\n  if (writing) return false;\n  return true;\n}", "CodeBleu_score": 42.06452252119121}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (!writing) {\n    if (size > 0) {\n      if (eeprom_read_block(value, (void *)(eeprom_address + pos), size)) {\n        pos += size;\n        return true;\n      }\n    }\n    else {\n      pos += size;\n      return false;\n    }\n  }\n  else {\n    if (size > 0) {\n      if (eeprom_write_block(value, (void *)(eeprom_address + pos), size)) {\n        pos += size;\n        return true;\n      }\n    }\n    else {\n      pos += size;\n      return false;\n    }\n  }\n}", "CodeBleu_score": 36.324199243154034}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(sdioHandle != nullptr);\n    CORE_ASSERT(src != nullptr);\n\n    for (int i = 0; i < RETRY_COUNT; i++) {\n        if (HAL_SD_WriteBlocks(sdioHandle, (uint8_t *)src, block, 1, 5) == HAL_OK) {\n            return true;\n        }\n    }\n\n    printf(\"SD card write failed\n\");\n    return false;\n}", "CodeBleu_score": 38.16745499863949}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (sdio == nullptr || src == nullptr) {\n        printf(\"SDIO_WriteBlock: SDIO handle or source pointer is null\n\");\n        return false;\n    }\n    for (int i = 0; i < RETRY_COUNT; i++) {\n        if (HAL_SD_WriteBlocks(sdio, (uint8_t *)src, block, 1, SD_DATATIMEOUT) == HAL_OK) {\n            return true;\n        }\n    }\n    printf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n    return false;\n}", "CodeBleu_score": 40.55292937782548}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (sdioHandle == NULL || src == NULL) {\n        printf(\"SDIO_WriteBlock: Invalid parameters\n\");\n        return false;\n    }\n\n    for (int i = 0; i < SDCARD_RETRY_COUNT; i++) {\n        if (HAL_SD_WriteBlocks(sdioHandle, (uint8_t *)src, block, 1, SDCARD_BLOCK_SIZE) == HAL_OK) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock: Failed to write block\n\");\n    return false;\n}", "CodeBleu_score": 39.639629636868}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tCORE_DEBUG_PRINTF(\"HAL_timer_start\n\");\n    CORE_ASSERT_FAIL;\n}", "CodeBleu_score": 7.601311660668525}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t// Check if the timer channel is valid.\n\tCORE_DEBUG_ASSERT(timer_num < TIMER_CHANNEL_NUM);\n\n\t// Start the timer.\n\tswitch (timer_num) {\n\t\tcase TIMER_CHANNEL_TEMPERATURE:\n\t\t\t// Start the timer with the given frequency and temperature timer prescale.\n\t\t\tHAL_timer_setFrequency(timer_num, frequency);\n\t\t\tHAL_timer_setCallbackPriority(timer_num, TIMER_CALLBACK_PRIORITY_TEMPERATURE);\n\t\t\tbreak;\n\t\tcase TIMER_CHANNEL_STEP:\n\t\t\t// Start the timer with the given frequency and stepper timer prescale.\n\t\t\tHAL_timer_setFrequency(timer_num, frequency);\n\t\t\tHAL_timer_setCallbackPriority(timer_num, TIMER_CALLBACK_PRIORITY_STEP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Trigger an assertion failure.\n\t\t\tCORE_DEBUG_ASSERT(false);\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 38.66923057489495}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tif (timer_num == TIMER_TEMP) {\n\t\tHAL_timer_start_temperature(timer_num, frequency);\n\t} else if (timer_num == TIMER_STEP) {\n\t\tHAL_timer_start_stepper(timer_num, frequency);\n\t} else {\n\t\tCORE_DEBUG_PRINTF(\"Invalid timer channel\n\");\n\t\tCORE_ASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 31.219263854936024}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\tif (eeprom_file == NULL) {\n    // Open the file\n    eeprom_file = fopen(eeprom_filename, \"r+\");\n    if (eeprom_file == NULL) {\n      // File does not exist, create it\n      eeprom_file = fopen(eeprom_filename, \"w+\");\n      if (eeprom_file == NULL) {\n        SERIAL_ERROR_START;\n        SERIAL_ERRORLNPGM(\"Could not open file for writing\");\n        return false;\n      }\n      // File opened, write the default value\n      fwrite(eeprom_default, eeprom_size, 1, eeprom_file);\n      fclose(eeprom_file);\n      // Open the file again for reading\n      eeprom_file = fopen(eeprom_filename, \"r+\");\n      if (eeprom_file == NULL) {\n        SERIAL_ERROR_START;\n        SERIAL_ERRORLNPGM(\"Could not open file for reading\");\n        return false;\n      }\n    }\n    // File opened, read the contents into the buffer\n    fseek(eeprom_file, 0, SEEK_SET);\n    fread(eeprom_buffer, eeprom_size, 1, eeprom_file);\n    fclose(eeprom_file);\n  }\n  else {\n    // File already open, read the contents into the buffer\n    fseek(eeprom_file, 0, SEEK_SET);\n    fread(eeprom_buffer, eeprom_size, 1, eeprom_file);\n  }\n  return true;\n}", "CodeBleu_score": 38.959097029958336}, {"code": "bool PersistentStore::access_start(){\n\t// Open the file\n  file = fopen(file_name, \"r+\");\n  if (!file) {\n    // File doesn't exist\n    return false;\n  }\n\n  // Get the file size\n  fseek(file, 0, SEEK_END);\n  size_t file_size = ftell(file);\n  fseek(file, 0, SEEK_SET);\n\n  // Read the file\n  if (file_size < sizeof(data)) {\n    // File is smaller than the expected size; fill the rest with erase value\n    memset(data, erase_value, sizeof(data) - file_size);\n  }\n  fread(data, sizeof(data), 1, file);\n\n  // Close the file\n  fclose(file);\n\n  // Return success\n  return true;\n}", "CodeBleu_score": 37.98348838783562}, {"code": "bool PersistentStore::access_start(){\n\t// Open the file\n  #if defined(ARDUINO_ARCH_STM32)\n    // Open the file\n    if (eeprom_file) fclose(eeprom_file);\n    eeprom_file = fopen(eeprom_filename, \"r+\");\n    if (!eeprom_file) {\n      SERIAL_ERROR_START;\n      SERIAL_ERRORLNPGM(\"Error opening EEPROM file.\");\n      return false;\n    }\n  #else\n    eeprom_file = fopen(eeprom_filename, \"r+\");\n    if (!eeprom_file) {\n      SERIAL_ERROR_START;\n      SERIAL_ERRORLNPGM(\"Error opening EEPROM file.\");\n      return false;\n    }\n  #endif\n\n  // Get the file size\n  #if defined(ARDUINO_ARCH_STM32)\n    fseek(eeprom_file, 0, SEEK_END);\n    size_t file_size = ftell(eeprom_file);\n    fseek(eeprom_file, 0, SEEK_SET);\n  #else\n    fseek(eeprom_file, 0, SEEK_END);\n    size_t file_size = ftell(eeprom_file);\n    fseek(eeprom_file, 0, SEEK_SET);\n  #endif\n\n  // Read the file into the buffer\n  if (file_size < EEPROM_SIZE) {\n    // The file is smaller than expected, fill the buffer with erase values\n    memset(eeprom_buffer, eeprom_erase_byte, EEPROM_SIZE);\n    memset(eeprom_buffer, 0, file_size);\n  }\n  else {\n    // The file is large enough, read it into the buffer\n    size_t read_size = fread(eeprom_buffer, 1, EEPROM_SIZE, eeprom_file);\n    if (read_size != EEPROM_SIZE) {\n      SERIAL_ERROR_START;", "CodeBleu_score": 45.98646327126783}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\t// set clock low\n\t\tHAL_GPIO_WritePin(GPIO_PORT_SPI_CLK, GPIO_PIN_SPI_CLK, GPIO_PIN_RESET);\n\t\t// write most significant bit\n\t\tHAL_GPIO_WritePin(GPIO_PORT_SPI_MOSI, GPIO_PIN_SPI_MOSI, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\t// toggle clock\n\t\tHAL_GPIO_TogglePin(GPIO_PORT_SPI_CLK, GPIO_PIN_SPI_CLK);\n\t\t// read bit\n\t\tr = (r << 1) | HAL_GPIO_ReadPin(GPIO_PORT_SPI_MISO, GPIO_PIN_SPI_MISO);\n\t\t// shift byte\n\t\tb = b << 1;\n\t}\n\t// introduce delay\n\tHAL_Delay(1);\n\treturn r;\n}", "CodeBleu_score": 39.61510446044576}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tSPI_CLK_LOW;\n\t\tif (b & 0x80) {\n\t\t\tSPI_MOSI_HIGH;\n\t\t} else {\n\t\t\tSPI_MOSI_LOW;\n\t\t}\n\t\tSPI_CLK_HIGH;\n\t\tSPI_CLK_LOW;\n\t\tif (SPI_MISO_READ) {\n\t\t\tr |= 0x01;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tdelaySPIFunc();\n\treturn r;\n}", "CodeBleu_score": 36.67693519718084}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t c;\n\tfor (c = 0; c < 8; c++) {\n\t\tHAL_SPI_STM32_SpiTransfer_Mode_0(b & 0x80);\n\t\tb <<= 1;\n\t}\n\treturn b;\n}", "CodeBleu_score": 19.816144597033027}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 77.97819102603172}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState != DISABLE) {\n\t\t/* Enable the peripheral */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the peripheral */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 78.26394678944122}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 77.97819102603172}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = (uint8_t)obj->serial->RXDATA;\n  if (c == 0) c = 256; // Ignore zero-length packets\n  if (c == 255) c = 0; // Ignore overrun error\n  if (c == 254) c = 1; // Ignore buffer full error\n  if (c == 253) c = 2; // Ignore parity error\n  if (c == 252) c = 3; // Ignore framing error\n\n  if (c == 251) { // Ignore break condition\n    // Do nothing\n  }\n  else if (c == 250) { // Ignore timeout error\n    // Do nothing\n  }\n  else if (c < 250) { // Valid data\n    if (rx_buffer_head == rx_buffer_tail) {\n      rx_buffer_head = 0;\n      rx_buffer_tail = 0;\n    }\n    else if (rx_buffer_head == BUFFER_SIZE - 1) {\n      rx_buffer_head = 0;\n    }\n    else {\n      rx_buffer_head++;\n    }\n    rx_buffer[rx_buffer_head] = c;\n  }\n  else { // Parity error\n    // Do nothing\n  }\n\n  if (emergency_parser.enabled) {\n    emergency_parser.update(c);\n  }\n}", "CodeBleu_score": 28.44190461239139}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = uart_getc(obj);\n  if (c == 0x00) return;\n  if (rx_buffer_head == rx_buffer_tail) {\n    rx_buffer_overflow = true;\n  }\n  else {\n    rx_buffer[rx_buffer_head] = c;\n    rx_buffer_head = (rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n  if (emergency_parser.enabled) {\n    emergency_parser.update(c);\n  }\n}", "CodeBleu_score": 37.68432901134059}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = uart_getc(obj);\n\n  // If the buffer is full, clear an error\n  if (rx_buffer_head == rx_buffer_tail) rx_buffer_overflow = false;\n\n  // If the buffer is full, don't overwrite\n  if (rx_buffer_head == BUFFER_SIZE) return;\n\n  // Store the received byte in the buffer\n  rx_buffer[rx_buffer_head] = c;\n  rx_buffer_head++;\n\n  // If the buffer is full, set an overflow flag\n  if (rx_buffer_head == BUFFER_SIZE) rx_buffer_overflow = true;\n\n  // If enabled, update the emergency parser\n  if (emergency_parser.enabled) emergency_parser.update(c);\n}", "CodeBleu_score": 30.609103209755528}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_instance[timer_num]->isInitialized() && !timer_instance[timer_num]->hasInterrupt()) {\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n    }\n  }\n}", "CodeBleu_score": 90.87349057216485}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_instance[timer_num] != NULL && !timer_instance[timer_num]->hasInterrupt) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t}\n\t\telse if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 55.31650085860036}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_instance[timer_num] != NULL && !timer_instance[timer_num]->hasInterrupt()) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t}\n\t\telse if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 59.02745582190898}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tvar (\n\t\thash, pow, sq uint32\n\t\tsepLen        = len(sep)\n\t\tsLen          = len(s)\n\t)\n\tif sepLen == 0 || sLen == 0 {\n\t\treturn -1\n\t}\n\thash, pow = HashStrRev(sep)\n\tsq = pow\n\tfor i := sepLen - 1; i >= 0; i-- {\n\t\thash = hash*PrimeRK + uint32(s[i])\n\t}\n\tfor i := sLen - sepLen; i >= 0; i-- {\n\t\tif hash == 0 {\n\t\t\tfor j := 0; j < sepLen; j++ {\n\t\t\t\tif s[i+j] != sep[j] {\n\t\t\t\t\tgoto fail\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i\n\t\t}\n\t\tif i > 0 {\n\t\t\thash *= PrimeRK\n\t\t\thash += uint32(s[i-1])\n\t\t\thash -= sq * uint32(s[i+sepLen-1])\n\t\t}\n\t}\nfail:\n\treturn -1\n}", "CodeBleu_score": 41.549190443785584}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tn := len(s)\n\tk := len(sep)\n\tif n < k {\n\t\treturn -1\n\t}\n\tif k == 0 {\n\t\treturn n\n\t}\n\thashS, pow := HashStrRev(sep)\n\thashS *= Pow(PrimeRK, uint32(n-k))\n\tfor i := n - k; i >= 0; i-- {\n\t\thash := hashS * PrimeRK\n\t\tfor j := 0; j < k; j++ {\n\t\t\thash += uint32(s[i+j])\n\t\t}\n\t\tif hash == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 40.00511345035013}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tn := len(s)\n\tk := len(sep)\n\tif k == 0 {\n\t\treturn n\n\t}\n\tif n < k {\n\t\treturn -1\n\t}\n\thashSep, pow := HashStrRev(sep)\n\thashSep *= Pow(PrimeRK, uint(n-k))\n\tfor i := n - k; i >= 0; i-- {\n\t\thashSep = hashSep*PrimeRK + uint32(s[i+k-1]) - uint32(sep[k-1])*pow\n\t\tif hashSep == 0 && s[i:i+k] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 39.57577590031829}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.272023591199634}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n}", "CodeBleu_score": 36.38504554306771}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t// Disable interrupts\n\tinterrupt.Disable()\n\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Get() != nil {\n\t\t// Send the data in the transmit buffer to the USB endpoint\n\t\tusbcdc.SendUSBInPacket(usbcdc.txBuffer.Get())\n\t} else {\n\t\t// No data in the transmit buffer, so set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore interrupt mask\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.86514507631238}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// clear the interrupt flag\n\ti2c.crReg.Clear(i2c.crReg.I2CEN)\n\t// put a start condition on the SDA line\n\ti2c.crReg.Set(i2c.crReg.START)\n\t// enable the I2C module\n\ti2c.crReg.Set(i2c.crReg.I2CEN)\n\n\t// wait for the start condition to be transmitted\n\tfor !i2c.srReg.HasBits(i2c.srReg.SB) {\n\t}\n\n\t// write the 7-bit shifted peripheral address to the bus\n\ti2c.writeByte(address<<1 | uint8(write))\n}", "CodeBleu_score": 38.3625941646516}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.crReg.Clear(i2c.crReg.AllPending)\n\ti2c.crReg.Set(i2c.crReg.Start)\n\tfor i2c.crReg.HasBits(i2c.crReg.Busy) {\n\t}\n\ti2c.writeByte(address<<1 | uint8(write))\n\tfor i2c.crReg.HasBits(i2c.crReg.Busy) {\n\t}\n}", "CodeBleu_score": 37.091476214134914}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.crReg.Clear(i2c.crReg.I2CEN)\n\ti2c.crReg.Clear(i2c.crReg.STOP)\n\ti2c.crReg.Clear(i2c.crReg.ACK)\n\ti2c.crReg.Clear(i2c.crReg.POS)\n\ti2c.crReg.Clear(i2c.crReg.PEC)\n\ti2c.crReg.Clear(i2c.crReg.START)\n\ti2c.crReg.Clear(i2c.crReg.STOP)\n\ti2c.crReg.Clear(i2c.crReg.NACK)\n\ti2c.crReg.Clear(i2c.crReg.RSTA)\n\ti2c.crReg.Clear(i2c.crReg.TXE)\n\ti2c.crReg.Clear(i2c.crReg.TXD)\n\ti2c.crReg.Clear(i2c.crReg.RXNE)\n\ti2c.crReg.Clear(i2c.crReg.BTF)\n\ti2c.crReg.Clear(i2c.crReg.ADD10)\n\ti2c.crReg.Clear(i2c.crReg.ADD0)\n\ti2c.crReg.Clear(i2c.crReg.ADD8)\n\ti2c.crReg.Clear(i2c.crReg.ADD7)\n\ti2c.crReg.Clear(i2c.crReg.ADD6)\n\ti2c.crReg.Clear(i2c.crReg.ADD5)\n\ti2c.crReg.Clear(i2c.crReg.ADD4)\n\ti2c.crReg.Clear(i2c.crReg.ADD3)\n\ti2c.crReg.Clear(i2c.crReg.ADD2)\n\ti2c.crReg.Clear(i2c.crReg.ADD1)\n\ti2c.crReg.Clear(i2c.crReg.ADD0)\n\ti2c.cr", "CodeBleu_score": 25.91004836932822}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || start+len > f.BlockCount() {\n\t\treturn ErrInvalidRange\n\t}\n\tif len == 0 {\n\t\treturn nil\n\t}\n\tf.EraseBlockSize\n\tFlashDataStart\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(start + i) * f.EraseBlockSize / 4)\n\t\twaitWhileFlashBusy\n\t}\n\tnrf.NVMC.SETCONFIG_REN\n\treturn nil\n}", "CodeBleu_score": 41.23044171577191}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || start >= f.BlockCount {\n\t\treturn ErrInvalidBlock\n\t}\n\tif len < 1 || start+len > f.BlockCount {\n\t\treturn ErrInvalidBlockCount\n\t}\n\tif len > 1 {\n\t\t// Erase the first block.\n\t\tif err := f.EraseBlock(start); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Erase the rest of the blocks.\n\t\tfor i := start + 1; i < start+len; i++ {\n\t\t\tif err := f.EraseBlock(i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 37.1072952202624}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || start > math.MaxUint32 {\n\t\treturn errors.New(\"start address out of range\")\n\t}\n\tif len < 0 || start+len > math.MaxUint32 {\n\t\treturn errors.New(\"length out of range\")\n\t}\n\tif f.EraseBlockSize == 0 {\n\t\treturn errors.New(\"block size is zero\")\n\t}\n\tif len%f.EraseBlockSize != 0 {\n\t\treturn errors.New(\"length not a multiple of block size\")\n\t}\n\tif f.EraseBlockSize < f.MinEraseSize {\n\t\treturn errors.New(\"block size less than minimum erase size\")\n\t}\n\tif f.EraseBlockSize > f.MaxEraseSize {\n\t\treturn errors.New(\"block size greater than maximum erase size\")\n\t}\n\tif f.EraseBlockSize > math.MaxUint32 {\n\t\treturn errors.New(\"block size out of range\")\n\t}\n\tif start%f.EraseBlockSize != 0 {\n\t\treturn errors.New(\"start address not a multiple of block size\")\n\t}\n\tif len%f.EraseBlockSize != 0 {\n\t\treturn errors.New(\"length not a multiple of block size\")\n\t}\n\tif len == 0 {\n\t\treturn nil\n\t}\n\tstartAddr := uint32(start)\n\tendAddr := startAddr + uint32(len)\n\tfor startAddr < endAddr {\n\t\tif startAddr%f.EraseBlockSize == 0 {\n\t\t\tnrf.NVMC.SetCONFIG_WEN\n\t\t\twaitWhileFlashBusy\n\t\t\tnrf.NVMC.ERASEPAGE.Set(startAddr)\n\t\t\twaitWhileFlashBusy\n\t\t}\n\t\tstartAddr += f.EraseBlockSize\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tnrf.NVMC.ERASEPAGE.Set(startAddr - 1)", "CodeBleu_score": 34.277854120316675}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Check if the write operation exceeds the flash memory bounds.\n\tif off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, errors.New(\"WriteAt: write exceeds flash memory bounds\")\n\t}\n\t// Calculate the start address for writing and pad the byte slice to fit the write block size.\n\tstart := off & ^uint64(f.WriteBlockSize-1)\n\tpad := int(start + uint64(f.WriteBlockSize) - off)\n\tif pad > len(p) {\n\t\tpad = len(p)\n\t}\n\tp = append(p[:pad], bytes.Repeat([]byte{0xFF}, f.WriteBlockSize-pad)...)\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\t// Write the data in blocks.\n\tfor len(p) > 0 {\n\t\t// Calculate the start address for writing.\n\t\tFlashDataStart = uintptr(start)\n\t\t// Write the data in blocks of the write block size.\n\t\twaitWhileFlashBusy\n\t\tint\n\t\tlen\n\t\tbinary.LittleEndian.Uint32\n\t\t(*uint32)\n\t\tFlashDataEnd\n\t\tf.WriteBlockSize\n\t\tuintptr\n\t\tunsafe.Pointer\n\t\tf.pad\n\t\t// Wait for the flash memory to be ready after each write operation.\n\t\twaitWhileFlashBusy\n\t\t// Calculate the start address for writing.\n\t\tFlashDataStart = uintptr(start)\n\t\t// Write the data in blocks of the write block size.\n\t\twaitWhileFlashBusy\n\t\tint\n\t\tlen\n\t\tbinary.LittleEndian.Uint32\n\t\t(*uint32)\n\t\tFlashDataEnd\n\t\tf.WriteBlockSize\n\t\tuintptr\n\t\tunsafe.Pointer\n\t\tf.pad\n\t\t// Wait for the flash memory to be ready after each write operation.", "CodeBleu_score": 37.65876410625982}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 || off+int64(len(p)) > f.size {\n\t\treturn 0, os.ErrInvalid\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off%int64(f.WriteBlockSize) != 0 || len(p)%f.WriteBlockSize != 0 {\n\t\treturn 0, os.ErrInvalid\n\t}\n\tf.pad(p)\n\tn = len(p)\n\tvar (\n\t\taddr = uintptr(f.start + off)\n\t\tdata = unsafe.Pointer(&p[0])\n\t\tlen  = uintptr(len(p))\n\t)\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tFlashDataStart\n\twaitWhileFlashBusy\n\tint\n\tlen\n\tbinary.LittleEndian.Uint32\n\t(*uint32)\n\tFlashDataEnd\n\tf.WriteBlockSize\n\tuintptr\n\tunsafe.Pointer\n\tf.pad\n\n\n\n\n", "CodeBleu_score": 36.24220097828494}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 {\n\t\treturn 0, errors.New(\"flashBlockDevice: negative offset\")\n\t}\n\tif off >= f.size {\n\t\treturn 0, errors.New(\"flashBlockDevice: offset exceeds flash memory size\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > f.size {\n\t\treturn 0, errors.New(\"flashBlockDevice: offset+length exceeds flash memory size\")\n\t}\n\tif len(p)%f.WriteBlockSize != 0 {\n\t\treturn 0, errors.New(\"flashBlockDevice: data length is not a multiple of the write block size\")\n\t}\n\tn = len(p)\n\tFlashDataStart\n\twaitWhileFlashBusy\n\tint\n\tlen\n\tbinary.LittleEndian.Uint32\n\t(*uint32)\n\tFlashDataEnd\n\tf.WriteBlockSize\n\tuintptr\n\tunsafe.Pointer\n\tf.pad\n\n\n\n\n", "CodeBleu_score": 27.12106055646899}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the provided file descriptor\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\t// Close the duplicated file descriptor\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"\", err\n\t}\n\n\t// Success!\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 54.153101390924995}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor.\n\tnewfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory.\n\tvar dir *syscall.Dir\n\tfor {\n\t\tdir, err = syscall.Fdopendir(newfd)\n\t\tif err == nil {\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the duplicated file descriptor.\n\tsyscall.Close(newfd)\n\n\t// Return the error.\n\treturn 0, \"\", err\n}", "CodeBleu_score": 68.02236889588069}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor.\n\tdup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Open the directory.\n\tdir, err := syscall.Fdopendir(dup)\n\tif err != nil {\n\t\tsyscall.Close(dup)\n\t\treturn 0, \"\", err\n\t}\n\t// Return the directory pointer.\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 53.95968851571601}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\tconst esp_partition_t *running = esp_ota_get_running_partition();\n  if (running == NULL) {\n    return 0;\n  }\n  if (response == FREE_SPACE) {\n    return running->size;\n  }\n  if (response == SKETCH_SIZE) {\n    uint32_t ota_size = 0;\n    esp_partition_t *ota = esp_ota_get_next_update_partition(NULL);\n    if (ota != NULL) {\n      ota_size = ota->size;\n    }\n    return ota_size;\n  }\n  return 0;\n}", "CodeBleu_score": 47.76961686367214}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tuint32_t size = 0;\n  const esp_partition_t* running = esp_ota_get_running_partition();\n  if (running != NULL) {\n    if (esp_ota_get_partition_description(running, &partition) == ESP_OK) {\n      if (esp_image_verify(ESP_IMAGE_VERIFY, &partition) == ESP_OK) {\n        if (response) {\n          size = partition.size - partition.ota_size;\n        } else {\n          size = partition.ota_size;\n        }\n      }\n    }\n  }\n  return size;\n}", "CodeBleu_score": 49.872906628613904}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tuint32_t size = 0;\n    const esp_partition_t *running = esp_ota_get_running_partition();\n    if (running) {\n        if (esp_ota_get_partition_description(running, &_partition) == ESP_OK) {\n            if (response == SKETCH_SIZE_RESPONSE_FREE) {\n                size = _partition.size - _partition.ota_last_offset;\n            } else if (response == SKETCH_SIZE_RESPONSE_SIZE) {\n                size = _partition.ota_last_offset;\n            }\n        }\n    }\n    return size;\n}", "CodeBleu_score": 50.40522977813825}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors == 0) {\n    log_e(\"No disk space available\");\n    return false;\n  }\n  if (msc_disk_data) {\n    free(msc_disk_data);\n  }\n  msc_disk_data = (uint8_t *)calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk_data) {\n    log_e(\"Disk allocation failed\");\n    return false;\n  }\n  msc_disk_size = total_sectors;\n  msc_disk_sector_count = total_sectors;\n  msc_disk_sectors_per_cluster = 1;\n  msc_disk_first_data_sector = 1;\n  msc_disk_root_dir_first_sector = msc_disk_first_data_sector + msc_disk_size - msc_table_sectors;\n  msc_disk_fat_first_sector = msc_disk_root_dir_first_sector - 1;\n  msc_disk_fat_last_sector = msc_disk_fat_first_sector + msc_table_sectors;\n  msc_disk_data_first_sector = msc_disk_fat_last_sector + 1;\n  msc_disk_data_last_sector = msc_disk_data_first_sector + msc_disk_size - msc_disk_root_dir_first_sector - 1;\n  msc_disk_data_sector_count = msc_disk_data_last_sector - msc_disk_data_first_sector + 1;\n  msc_disk_root_dir_sector_count = msc_disk_root_dir_first_sector - msc_disk_data_first_sector + 1;\n  msc_disk_fat_sector_count = msc_disk_fat_last_se", "CodeBleu_score": 44.387000697744185}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_disk = calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk) {\n    log_e(\"Disk allocation failed\");\n    return false;\n  }\n  log_d(\"Disk allocated at %p\", msc_disk);\n  msc_disk_size = total_sectors;\n  log_d(\"Disk size: %u sectors\", msc_disk_size);\n  if (!fat_init_boot_sector(msc_disk, msc_disk_size, volume_label, serial_number, mcs_is_fat16)) {\n    log_e(\"Boot sector setup failed\");\n    free(msc_disk);\n    msc_disk = NULL;\n    return false;\n  }\n  if (!fat_init_fat(msc_disk, msc_disk_size, msc_table_sectors, mcs_is_fat16)) {\n    log_e(\"FAT setup failed\");\n    free(msc_disk);\n    msc_disk = NULL;\n    return false;\n  }\n  if (msc_run_partition) {\n    if (!fat_add_boot_sector(msc_disk, msc_run_partition)) {\n      log_e(\"Boot sector add failed\");\n      free(msc_disk);\n      msc_disk = NULL;\n      return false;\n    }\n  }\n  if (msc_ota_partition) {\n    if (!fat_add_table(msc_disk, msc_ota_partition)) {\n      log_e(\"OTA table add failed\");\n      free(msc_disk);\n      msc_disk = NULL;\n      return false;\n    }\n  }\n  if (msc_run_partition) {\n    if (!fat_add_root_file(msc_disk, msc_run_partition)) {\n      log_e(\"Root file add failed\");\n      free(msc_disk);\n      msc_disk", "CodeBleu_score": 41.403357543101485}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tuint8_t *fat_buf = NULL;\n  size_t total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors > 0) {\n    fat_buf = calloc(total_sectors, DISK_SECTOR_SIZE);\n    if (fat_buf) {\n      log_d(\"Allocated %uKB for FAT\", total_sectors * DISK_SECTOR_SIZE / 1024);\n    } else {\n      log_e(\"Failed to allocate %uKB for FAT\", total_sectors * DISK_SECTOR_SIZE / 1024);\n      return false;\n    }\n  } else {\n    log_e(\"Failed to calculate required disk sectors\");\n    return false;\n  }\n  if (fat_buf) {\n    if (msc_is_fat16) {\n      if (fat_init_16(fat_buf, total_sectors, msc_table_sectors, volume_label, serial_number) == true) {\n        log_d(\"Initialized FAT16\");\n      } else {\n        log_e(\"Failed to initialize FAT16\");\n        free(fat_buf);\n        return false;\n      }\n    } else {\n      if (fat_init_12(fat_buf, total_sectors, msc_table_sectors, volume_label, serial_number) == true) {\n        log_d(\"Initialized FAT12\");\n      } else {\n        log_e(\"Failed to initialize FAT12\");\n        free(fat_buf);\n        return false;\n      }\n    }\n    msc_disk_sectors = total_sectors;\n    msc_disk_buf = fat_buf;\n    log_d(\"Initialized RAM disk\");\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 40.84055960055324}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err;\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Offset 0x%x is not aligned to flash sector size 0x%x\", offset, SPI_FLASH_SEC_SIZE);\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"Update region (0x%x-0x%x) overruns partition size (0x%x)\", offset, offset + size, partition->size);\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (offset & (SPI_FLASH_SEC_SIZE - 1)) {\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase sector at 0x%x\", offset);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to partition\");\n    }\n    return err;\n}", "CodeBleu_score": 59.05203359781781}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t// TODO: ESP32-S2\n    return ESP_ERR_NOT_SUPPORTED;\n}", "CodeBleu_score": 7.10154422562154}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t//Check if the offset is aligned with the flash sector size.\n\tif (offset % FLASH_SECTOR_SIZE != 0) {\n\t\t//If not, log an error message and return an error code.\n\t\tLOG_E(\"update_write: offset is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\t//Check if the given data is aligned with the flash sector size.\n\tif (((uint32_t)data % FLASH_SECTOR_SIZE) != 0) {\n\t\t//If not, log an error message and return an error code.\n\t\tLOG_E(\"update_write: data is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\t//Check if the given data is aligned with the flash page size.\n\tif (((uint32_t)data % FLASH_PAGE_SIZE) != 0) {\n\t\t//If not, log an error message and return an error code.\n\t\tLOG_E(\"update_write: data is not aligned with flash page size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\t//Check if the given data is aligned with the flash block size.\n\tif (((uint32_t)data % FLASH_BLOCK_SIZE) != 0) {\n\t\t//If not, log an error message and return an error code.\n\t\tLOG_E(\"update_write: data is not aligned with flash block size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\t//Check if the size is aligned with the flash sector size.\n\tif (size % FLASH_SECTOR_SIZE != 0) {\n\t\t//If not, log an error message and return an error code.\n\t\tLOG_E(\"update_write: size is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\t//Check if the size is aligned with the flash page size.\n\tif (size % FLASH_PAGE_SIZE != 0) {\n\t\t//If not, log an", "CodeBleu_score": 36.2108672292966}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i, j;\n  for (i = j = 0; i < maxlen && *in; i++) {\n    if (hex_char_to_byte(*in) < 0x10) {\n      out[j++] = hex_char_to_byte(*in++) << 4;\n      if (*in) {\n        out[j++] |= hex_char_to_byte(*in++);\n      }\n    } else {\n      in++;\n    }\n  }\n  return j;\n}", "CodeBleu_score": 41.18433176776441}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i = 0;\n  size_t j = 0;\n  uint8_t c;\n  while (i < maxlen && j < strlen(in) && (c = hex_char_to_byte(in[j])) != 0x10) {\n    out[i++] = c;\n    j += 2;\n  }\n  return i;\n}", "CodeBleu_score": 29.296056567911826}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t len = 0;\n  while (*in != '\\0' && len < maxlen) {\n    uint8_t c = *in++;\n    if (c >= 'a' && c <= 'f') {\n      c = c - ((uint8_t)'a' - 0xa);\n    } else if (c >= 'A' && c <= 'F') {\n      c = c - ((uint8_t)'A' - 0xa);\n    } else if (c >= '0' && c <= '9') {\n      c = c - (uint8_t)'0';\n    } else {\n      continue;\n    }\n    out[len++] = c;\n  }\n  return len;\n}", "CodeBleu_score": 42.25091181564524}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tif (txRingBuffer == NULL || txRingBufferLock == NULL) {\n    return 0;\n  }\n\n  if (xSemaphoreTake(txRingBufferLock, portMAX_DELAY) == pdTRUE) {\n    int freeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n    xSemaphoreGive(txRingBufferLock);\n    return freeSize;\n  } else {\n    return 0;\n  }\n}", "CodeBleu_score": 66.96635180117809}, {"code": "int HWCDC::availableForWrite(void){\n\tif (txRingBuffer == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(txLock, portMAX_DELAY) == pdTRUE) {\n\t\tint freeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n\t\txSemaphoreGive(txLock);\n\t\treturn freeSize;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 56.67491638006579}, {"code": "int HWCDC::availableForWrite(void){\n\tint ret;\n\tif (tx_rbuf == NULL) {\n\t\treturn 0;\n\t}\n\tif (tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, (TickType_t) 1000) == pdTRUE) {\n\t\tret = xRingbufferGetCurFreeSize(tx_rbuf);\n\t\txSemaphoreGive(tx_lock);\n\t}\n\telse {\n\t\tret = 0;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 59.30089492474136}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _rxTimeout = onlyOnTimeout;\n  if (_onReceiveCB) {\n    _uart->setRxFifoFullCallback(uartSetRxFIFOFull, this);\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  } else {\n    _uart->setRxFifoFullCallback(NULL, NULL);\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 45.267870096941756}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    uartSetRxFIFOFull(_uart_nr, HSERIAL_RX_FIFO_FULL_THRESHOLD);\n    _createEventTask();\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 36.67570544520874}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK\n\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    uartSetRxFIFOFull(_uart_nr, HSERIAL_RX_FIFO_FULL_THRESHOLD);\n    _createEventTask();\n  }\n\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 36.67570544520874}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (!buffer) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    buffer[index++] = (char)c;\n  }\n  buffer[index] = 0;\n  return index;\n}", "CodeBleu_score": 77.32822560084753}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (!buffer || !length) {\n    return 0;\n  }\n\n  size_t index = 0;\n  while (index < length - 1) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[index++] = c;\n    if (c == terminator) {\n      break;\n    }\n  }\n  buffer[index] = 0;\n  return index;\n}", "CodeBleu_score": 73.24957002561571}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (!buffer) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    buffer[index++] = (char)c;\n  }\n  return index;\n}", "CodeBleu_score": 77.16647960026646}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"tone called\");\n  if (pin >= PINS_COUNT) {\n    log_e(\"Pin not available\");\n    return;\n  }\n  if (_tone_pins[pin]) {\n    log_e(\"Pin already in use\");\n    return;\n  }\n  if (tone_init() == 0) {\n    log_e(\"Could not initialize tone\");\n    return;\n  }\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.frequency = frequency;\n  msg.duration = duration;\n  if (xQueueSend(_tone_queue, &msg, 0) != pdPASS) {\n    log_e(\"Could not send tone message\");\n    return;\n  }\n  log_d(\"Tone message sent\");\n}", "CodeBleu_score": 41.1528362716888}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tif (pin >= TONE_PIN_NUM) {\n    log_e(\"Pin %d is not available\", pin);\n    return;\n  }\n\n  if (_tone_pins[pin] == 1) {\n    log_e(\"Pin %d is already in use\", pin);\n    return;\n  }\n\n  log_d(\"Tone pin %d, frequency %d, duration %d\", pin, frequency, duration);\n\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.frequency = frequency;\n  msg.duration = duration;\n  xQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 45.42275252494409}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tif (frequency == 0) {\n    log_e(\"Frequency cannot be 0\");\n    return;\n  }\n  if (duration == 0) {\n    log_e(\"Duration cannot be 0\");\n    return;\n  }\n  if (pin >= GPIO_NUM_MAX) {\n    log_e(\"Pin %d is not valid\", pin);\n    return;\n  }\n  if (_tone_pins[pin] == 1) {\n    log_e(\"Pin %d is already in use\", pin);\n    return;\n  }\n  log_v(\"Pin %d, frequency %d, duration %d\", pin, frequency, duration);\n  _tone_pins[pin] = 1;\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.frequency = frequency;\n  msg.duration = duration;\n  if (xQueueSend(_tone_queue, &msg, 0) != pdTRUE) {\n    log_e(\"Could not send tone message to queue\");\n  }\n}", "CodeBleu_score": 47.456017891966084}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (usb_enabled) {\n    if (enabled) {\n      if (usb_version < 0x0210) {\n        return true;\n      }\n      if (webusb_enabled == enabled) {\n        return false;\n      }\n      webusb_enabled = enabled;\n      if (enabled) {\n        webusb_enabled_time = millis();\n        webusb_enabled_count = 0;\n      }\n      else {\n        webusb_enabled_time = 0;\n        webusb_enabled_count = 0;\n      }\n      return false;\n    }\n    else {\n      if (webusb_enabled == enabled) {\n        return false;\n      }\n      webusb_enabled = enabled;\n      if (enabled) {\n        webusb_enabled_time = millis();\n        webusb_enabled_count = 0;\n      }\n      else {\n        webusb_enabled_time = 0;\n        webusb_enabled_count = 0;\n      }\n      return false;\n    }\n  }\n  else {\n    if (webusb_enabled == enabled) {\n      return false;\n    }\n    webusb_enabled = enabled;\n    if (enabled) {\n      webusb_enabled_time = millis();\n      webusb_enabled_count = 0;\n    }\n    else {\n      webusb_enabled_time = 0;\n      webusb_enabled_count = 0;\n    }\n    return true;\n  }\n}", "CodeBleu_score": 43.57285798561203}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_usbStarted) {\n    _webUSBEnabled = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (_usbVersion < 0x0210) {\n      _webUSBEnabled = false;\n      return true;\n    }\n    _webUSBEnabled = true;\n  } else {\n    _webUSBEnabled = false;\n  }\n  return false;\n}", "CodeBleu_score": 41.678426991975506}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (usbInitialised) {\n    if (enabled) {\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (usbVersion < 0x0210) {\n        return true;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (webUSBEnabled) {\n        return false;\n      }\n      if (web", "CodeBleu_score": 23.19613563567724}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\tuint8_t buffer[USB_CDC_RX_BUFFER_SIZE];\n    uint32_t count = tud_cdc_n_read(USB_CDC_RX_BUFFER_SIZE, buffer);\n    if (count > 0) {\n        // post receive event\n        arduino_usb_event_post(USB_CDC_RX, count);\n        // send data to queue\n        if (!xQueueSend(USB_CDC_RX_QUEUE, buffer, 0)) {\n            // queue is full, log error\n            log_e(\"USB CDC RX queue full\");\n            // post overflow event\n            arduino_usb_event_post(USB_CDC_RX_OVERFLOW, count);\n        }\n    }\n}", "CodeBleu_score": 18.584966042222494}, {"code": "void USBCDC::_onRX(){\n\tuint8_t c;\n\tuint16_t len;\n\tuint8_t dropped;\n\t\n\t// Read data into a buffer\n\tlen = tud_cdc_n_read(_cdc_itf, _rx_buffer, sizeof(_rx_buffer));\n\t\n\t// If no data, return\n\tif (len == 0) {\n\t\treturn;\n\t}\n\t\n\t// Process each byte\n\tfor (uint16_t i = 0; i < len; i++) {\n\t\t// Read the byte\n\t\tc = _rx_buffer[i];\n\t\t\n\t\t// Attempt to post the byte to the receive queue\n\t\tif (xQueueSend(_rx_queue, &c, 0) == pdPASS) {\n\t\t\t// If successful, post a receive event with the length of the received data\n\t\t\tusb_cdc_event_post(USB_CDC_EVENT_RX, len);\n\t\t} else {\n\t\t\t// If unsuccessful, post an overflow event with the number of dropped bytes\n\t\t\tdropped = _rx_buffer[i];\n\t\t\tusb_cdc_event_post(USB_CDC_EVENT_RX_OVERFLOW, dropped);\n\t\t\t\n\t\t\t// Log an error\n\t\t\tLOG_ERR(\"CDC RX overflow: %d dropped bytes\", dropped);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.69746783382695}, {"code": "void USBCDC::_onRX(){\n\tuint32_t n = tud_cdc_n_read(_cdc_itf, _rx_buf, sizeof(_rx_buf));\n  if (n > 0) {\n    if (!xQueueSend(_rx_queue, _rx_buf, 0)) {\n      _overflow_event.post(n);\n      LOG_ERROR(\"USBCDC\", \"RX overflow (%u bytes dropped)\", n);\n    }\n    _rx_event.post(n);\n  }\n}", "CodeBleu_score": 13.93702698492572}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the URL parameters.\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Check if a robot with the given name exists.\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\t// If the robot does not exist, return an error message.\n\t\ta.writeJSON(res, http.StatusNotFound, gobot.ErrResponse{Message: fmt.Sprintf(\"no robot found with name %s\", robotName)})\n\t\treturn\n\t}\n\n\t// Gather the devices associated with the robot into a JSON format.\n\tdevices := robot.Devices()\n\tdevicesJSON := make([]gobot.DeviceJSON, len(devices))\n\tfor i, device := range devices {\n\t\tdevicesJSON[i] = device.JSON()\n\t}\n\n\t// Write the JSON response to the HTTP response writer.\n\ta.writeJSON(res, http.StatusOK, devicesJSON)\n}", "CodeBleu_score": 44.84204267760008}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the URL parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\t// Check if a robot with the given name exists.\n\tif !a.master.RobotExists(robotName) {\n\t\t// If not, return a JSON response with an error message.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]string{\"error\": \"No robot found with name \" + robotName})\n\t\treturn\n\t}\n\t// If a robot with the given name exists, gather its devices into a JSON format and write this JSON response to the HTTP response writer.\n\tres.WriteHeader(http.StatusOK)\n\ta.writeJSON(res, a.master.Robot(robotName).Devices())\n}", "CodeBleu_score": 33.635814291850096}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\t// Check if the robot exists.\n\tif _, err := a.master.Robot(robotName); err != nil {\n\t\t// If the robot does not exist, return a JSON response with an error message.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"no robot with that name\"}`))\n\t\treturn\n\t}\n\t// If the robot exists, gather its devices into a JSON format.\n\tdevices := a.master.Robot(robotName).Devices()\n\t// Write the JSON response to the HTTP response writer.\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(devices)\n}", "CodeBleu_score": 34.243890322320915}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL.\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\t// Check if the robot exists.\n\tif _, ok := a.master.Robots[robotName]; !ok {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\thttp.Error(res, fmt.Sprintf(\"robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\t// Iterate through the robot's connections and write them to the HTTP response.\n\tconnections := []map[string]interface{}{}\n\ta.master.Robots[robotName].Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, a.master.Robot(robotName).Connection(c.Name()).Export())\n\t})\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(a.writeJSON(connections)))\n}", "CodeBleu_score": 47.43977768429887}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL and check if the robot exists.\n\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\t// If the robot is not found, write an error message to the HTTP response.\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections, convert them to JSON format, and write them to the HTTP response.\n\tconnections := robot.Connections()\n\tconnectionsJSON := make([]*gobot.ConnectionJSON, len(connections))\n\tfor i, connection := range connections {\n\t\tconnectionsJSON[i] = connection.ToJSON()\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(fmt.Sprintf(\"%v\", connectionsJSON)))\n}", "CodeBleu_score": 42.40030728029528}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\t// Check if the robot exists.\n\tif !a.master.RobotExists(robotName) {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"no robot with name %s found\", robotName)\n\t\treturn\n\t}\n\n\t// If the robot exists, iterate through its connections and convert them to JSON format.\n\tconnections := a.master.RobotConnections(robotName)\n\tconnectionsJSON := make([]interface{}, len(connections))\n\tfor i, connection := range connections {\n\t\tconnectionsJSON[i] = connection.ToJSON()\n\t}\n\n\t// Write the JSON-formatted connections to the HTTP response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, \"%s\", connectionsJSON)\n}", "CodeBleu_score": 46.394804324261706}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the URL query parameters\n\trobotName := req.URL.Query().Get(\":robot\")\n\t// Get the device name from the URL query parameters\n\tdeviceName := req.URL.Query().Get(\":device\")\n\t// Get the command from the URL query parameters\n\tcommand := req.URL.Query().Get(\":command\")\n\t// Check if the robot exists\n\tif _, err := a.master.Robot(robotName); err != nil {\n\t\t// If the robot does not exist, write the error message as a JSON response\n\t\ta.writeJSON(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\t// Check if the device exists\n\tif _, err := a.master.Robot(robotName).Device(deviceName); err != nil {\n\t\t// If the device does not exist, write the error message as a JSON response\n\t\ta.writeJSON(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\t// Execute the command on the device using the Gobot framework\n\tif err := a.master.Robot(robotName).Device(deviceName).(gobot.Commander).Command(command); err != nil {\n\t\t// If an error occurs while executing the command, write the error message as a JSON response\n\t\ta.writeJSON(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\t// Write a JSON response\n\ta.writeJSON(res, http.StatusOK, \"OK\")\n}", "CodeBleu_score": 54.788841078654585}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the URL query parameters\n\trobotName := req.URL.Query().Get(\":robot\")\n\t// Get the device name from the URL query parameters\n\tdeviceName := req.URL.Query().Get(\":device\")\n\t// Get the command from the URL query parameters\n\tcommand := req.URL.Query().Get(\":command\")\n\t// Check if the device exists\n\tif !a.master.Robot(robotName).DeviceExists(deviceName) {\n\t\t// Write an error response\n\t\ta.writeJSON(res, http.StatusNotFound, \"Device not found\")\n\t\treturn\n\t}\n\t// Execute the specified command on the device\n\terr := a.master.Robot(robotName).Device(deviceName).(gobot.Commander).Command(command)\n\t// Check if an error occurred\n\tif err != nil {\n\t\t// Write an error response\n\t\ta.writeJSON(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\t// Write a success response\n\ta.writeJSON(res, http.StatusOK, \"Command executed successfully\")\n}", "CodeBleu_score": 52.55193805051812}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\tcommand := req.URL.Query().Get(\":command\")\n\n\t// Check if the robot exists\n\tif _, ok := a.master.Robot(robot); !ok {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\tif _, ok := a.master.Robot(robot).Device(device); !ok {\n\t\thttp.Error(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\tif err := a.master.Robot(robot).Device(device).(gobot.Commander).Command(command); err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.47998031846842}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Proceed to the next handler\n\t\tr.Header.Del(\"Authorization\")\n\t\tr.RemoteAddr = \"127.0.0.1\"\n\t\tr.SetBasicAuth(username, password)\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 52.96489853948596}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(u, username) || !secureCompare(p, password) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext(w, r)\n\t}\n}", "CodeBleu_score": 51.36603997763154}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Authorization Required\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext(w, r)\n\t}\n}", "CodeBleu_score": 53.28680829143908}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection().AnalogRead == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog reading not supported\")\n\t}\n\tif a.sensorCfg.scale == 0 {\n\t\treturn 0, 0, fmt.Errorf(\"invalid scale value\")\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog reading failed: %s\", err)\n\t}\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRead.raw = raw\n\ta.lastRead.scaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 46.74479597492391}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\tvar (\n\t\trawVal int\n\t\terr    error\n\t)\n\t// Lock the sensor for reading.\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\t// Check if the connection supports analog reading.\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\t// Retrieve the raw sensor value.\n\tif rawVal, err = reader.AnalogRead(a.Pin()); err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"error reading analog value from pin %d: %v\", a.Pin(), err)\n\t}\n\t// Scale the raw value according to the sensor's configuration.\n\tscaledVal := a.sensorCfg.scale(float64(rawVal))\n\t// Update the last read values.\n\ta.lastRead.raw = rawVal\n\ta.lastRead.scaled = scaledVal\n\t// Return the raw and scaled values.\n\treturn rawVal, scaledVal, nil\n}", "CodeBleu_score": 48.74040481251454}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\tvar raw int\n\tvar scaled float64\n\tvar err error\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: invalid connection\")\n\t}\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: connection does not support analog read\")\n\t}\n\traw, err = reader.AnalogRead(a.Connection(), a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled = a.sensorCfg.Scale(float64(raw))\n\ta.lastReading = raw\n\ta.lastReadingScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 50.221525432662894}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\ts := &GroveSoundSensorDriver{\n\t\tname: DefaultName,\n\t\tpin:  pin,\n\t\ta:    a,\n\t}\n\ts.SetName(s.name)\n\ts.SetPin(s.pin)\n\treturn s\n}", "CodeBleu_score": 32.43158380144837}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tvar options = make(map[string]interface{})\n\tvar name string\n\n\t// Process options\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase gobot.Name:\n\t\t\toptions[opt.(gobot.Name).Name()] = opt\n\t\tdefault:\n\t\t\toptions[reflect.TypeOf(opt).String()] = opt\n\t\t}\n\t}\n\n\tif name, ok := options[\"Name\"].(gobot.Name); ok {\n\t\tdelete(options, \"Name\")\n\t} else {\n\t\tname = gobot.DefaultName(\"GroveSoundSensor\")\n\t}\n\n\ts := &GroveSoundSensorDriver{\n\t\tname:       name,\n\t\tpin:        pin,\n\t\tanalogRead: a,\n\t}\n\n\ts.AddEvent(gobot.DefaultName(\"Threshold\"))\n\ts.AddEvent(gobot.DefaultName(\"Noise\"))\n\n\ts.AddCommand(\"Threshold\", func(params map[string]interface{}) interface{} {\n\t\tif params[\"Threshold\"] == nil {\n\t\t\treturn s.Threshold\n\t\t}\n\t\ts.Threshold = params[\"Threshold\"].(int)\n\t\treturn s.Threshold\n\t})\n\n\ts.AddCommand(\"Noise\", func(params map[string]interface{}) interface{} {\n\t\tif params[\"Noise\"] == nil {\n\t\t\treturn s.Noise\n\t\t}\n\t\ts.Noise = params[\"Noise\"].(int)\n\t\treturn s.Noise\n\t})\n\n\treturn s\n}", "CodeBleu_score": 30.3861845133332}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tvar options = make(map[string]interface{})\n\tvar name string\n\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase gobot.Nameer:\n\t\t\toptions[opt.(gobot.Nameer).Name()] = opt\n\t\tdefault:\n\t\t\toptions[reflect.TypeOf(opt).String()] = opt\n\t\t}\n\t}\n\n\tif name, ok := options[\"Name\"].(string); ok {\n\t\tdelete(options, \"Name\")\n\t} else {\n\t\tname = gobot.DefaultName(\"GroveSoundSensor\")\n\t}\n\n\treturn &GroveSoundSensorDriver{\n\t\tname:       name,\n\t\tpin:        pin,\n\t\tanalogRead: a,\n\t\tthreshold:  0,\n\t\tsound:      0,\n\t\tsoundLevel: 0,\n\t\tsoundDb:    0,\n\t\tsoundDbA:   0,\n\t\tsoundDbB:   0,\n\t\tsoundDbC:   0,\n\t\tsoundDbD:   0,\n\t\tsoundDbE:   0,\n\t\tsoundDbF:   0,\n\t\tsoundDbG:   0,\n\t\tsoundDbH:   0,\n\t\tsoundDbI:   0,\n\t\tsoundDbJ:   0,\n\t\tsoundDbK:   0,\n\t\tsoundDbL:   0,\n\t\tsoundDbM:   0,\n\t\tsoundDbN:   0,\n\t\tsoundDbO:   0,\n\t\tsoundDbP:   0,\n\t\tsoundDbQ:   0,\n\t\tsoundDbR:   0,\n\t\tsoundDbS:   0,\n\t\tsoundDbT:   0,\n\t\tsoundDbU:   0,\n\t\tsoundDbV:   0,\n\t\tsoundDbW:   0,\n\t\tsoundDbX:   0,\n\t\tsoundDbY:   0,\n\t\tsoundDbZ:   0,\n\t\tsoundDbAA:  0,\n\t\tsoundDbAB:  0,\n\t\tsoundDbAC:", "CodeBleu_score": 30.18349630868316}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\td.writeByte(commandReg, softReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tstatus := d.readByte(commandReg)\n\tif status&0x01 == 0x01 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 29.034099487529485}, {"code": "func (d *MFRC522Common) softReset() error{\n\td.writeByteData(commandReg, softReset)\n\ttime.Sleep(100 * time.Microsecond)\n\tstatus := d.readByteData(commandReg)\n\tif status&0x01 != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.32737920517821}, {"code": "func (d *MFRC522Common) softReset() error{\n\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(10 * time.Microsecond)\n\tval := d.readByteData(CommandReg)\n\tif val&0x01 != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.46141620878896}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Check if there are any bytes in the FIFO buffer.\n\tstatus, err := d.readRegister(FIFODataReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// Check if there are enough bytes in the FIFO buffer.\n\tif status == 0 {\n\t\treturn 0, fmt.Errorf(\"no data in FIFO\")\n\t}\n\t// Check if there are more bytes in the FIFO than expected.\n\tif status > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"not enough data in FIFO\")\n\t}\n\t// Read the bytes from the FIFO buffer.\n\tfor i := uint8(0); i < status; i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received.\n\tlastBits, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 52.867849937821646}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Check if there are any bytes in the FIFO buffer.\n\tstatus, err := d.readRegister(MFRC522_FIFO_LEVEL_REG)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// Return an error if the FIFO buffer is not empty.\n\tif status&0x80 != 0 {\n\t\treturn 0, fmt.Errorf(\"FIFO buffer is not empty\")\n\t}\n\t// Return an error if the number of bytes available in the FIFO buffer is smaller than the length of the byte slice.\n\tif status != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"not enough bytes available in FIFO buffer\")\n\t}\n\t// Read each byte in the FIFO buffer into the byte slice.\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(MFRC522_FIFO_DATA_REG)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received.\n\treturn d.readRegister(MFRC522_CONTROL_REG)\n}", "CodeBleu_score": 47.14607944110983}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Check if there are any bytes in the FIFO buffer.\n\tstatus, err := d.readRegister(Status2Reg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif status&0x08 == 0x00 {\n\t\treturn 0, fmt.Errorf(\"no data in FIFO\")\n\t}\n\n\t// Read the FIFO bytes.\n\tbytesAvailable := int(status & 0x07)\n\tif len(backData) < bytesAvailable {\n\t\tbytesAvailable = len(backData)\n\t}\n\tfor i := 0; i < bytesAvailable; i++ {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register.\n\tlastBits, err := d.readByteData(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 54.080969628652106}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\td.Debug(\"Halting communication with PICC\")\n\tcmd := []byte{d.cmdHalt}\n\tcrc := d.calculateCRC(cmd)\n\tcmd = append(cmd, crc)\n\terr := d.communicateWithPICC(cmd, d.cmdHalt)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error halting communication with PICC: %s\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 29.01005617180149}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\tif d.debug {\n\t\td.logf(\"Halting communication with PICC\")\n\t}\n\t// Build command\n\tcmd := []byte{d.cmdHalt}\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\t// Append CRC_A to command\n\tcmd = append(cmd, crc)\n\t// Send command\n\tif err := d.communicateWithPICC(cmd, d.cmdHalt); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 29.640931565527666}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t// Create command\n\tcmd := []byte{piccHaltCommand}\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\t// Append CRC_A to command\n\tcmd = append(cmd, crc)\n\t// Send command\n\tif err := d.communicateWithPICC(piccCommandHalt, cmd); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 25.681224986975565}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Create a slice of bytes that will hold the read data.\n\tdata := make([]byte, 16)\n\n\t// Build the command to read a block from the card.\n\t// The command is built by first appending the instruction, address, and block number to a slice of bytes.\n\t// The command is then appended to a second slice of bytes that is then converted to the final command.\n\tcmd := make([]byte, 4)\n\tcmd[0] = 0x30  // Instruction\n\tcmd[1] = 0x00  // Address\n\tcmd[2] = block // Block number\n\tcmd[3] = d.calculateCRC(cmd) // CRC\n\n\t// Send the command and get the response.\n\tresponse, err := d.communicateWithPICC(piccCommand, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check that the response is valid.\n\tif response[0] != 0x00 || response[1] != 0x00 {\n\t\treturn nil, errors.New(\"Error reading block\")\n\t}\n\n\t// Copy the 16 data bytes to the data buffer.\n\tcopy(data, response[2:18])\n\n\t// Return the data.\n\treturn data, nil\n}", "CodeBleu_score": 33.37637992470868}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Build command buffer\n\tcmd := []byte{MF522_READ, block}\n\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\n\t// Append CRC_A to command buffer\n\tcmd = append(cmd, crc)\n\n\t// Send command\n\tstatus := d.communicateWithPICC(cmd, MF522_READ_RESPONSE_LENGTH)\n\tif status != MI_OK {\n\t\treturn nil, errors.New(\"Error communicating with PICC\")\n\t}\n\n\t// Copy command buffer to response buffer\n\tresp := make([]byte, MF522_READ_RESPONSE_LENGTH)\n\tcopy(resp, cmd)\n\n\t// Verify response\n\tif resp[0] != MF522_READ_RESPONSE_CODE {\n\t\treturn nil, errors.New(\"Unexpected response code\")\n\t}\n\n\t// Return response data\n\treturn resp[1 : 1+MF522_BLOCK_SIZE], nil\n}", "CodeBleu_score": 33.55269263446148}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Create a buffer to store the data received from the MFRC522 chip\n\tdata := make([]byte, 16)\n\n\t// Create the command to send to the MFRC522 chip\n\t// First byte is the instruction\n\t// Second byte is the address of the first sector to read from\n\t// Third byte is the number of sectors to read (1 for 16 bytes)\n\t// Fourth byte is the value of the authentication key A\n\t// Fifth byte is the value of the authentication key B\n\t// Sixth byte is the value of the address pointer\n\t// Seventh byte is the value of the sector trailer address\n\tcommand := []byte{\n\t\tMF522_READ,\n\t\tblock,\n\t\t0x01,\n\t\t0x00,\n\t\t0x00,\n\t\t0x00,\n\t\t0x00,\n\t}\n\n\t// Calculate the CRC_A for the command\n\tcrc := d.calculateCRC(command[0:4])\n\t// Append the CRC_A to the command\n\tcommand = append(command, crc[0])\n\tcommand = append(command, crc[1])\n\n\t// Send the command and get the response\n\tresponse, err := d.communicateWithPICC(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is valid\n\tif response[0] != MF522_ACK {\n\t\treturn nil, fmt.Errorf(\"invalid response from MFRC522 chip\")\n\t}\n\n\t// Copy the 16 data bytes to the data buffer\n\tcopy(data, response[1:17])\n\n\t// Return the data\n\treturn data, nil\n}", "CodeBleu_score": 43.723437003633045}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Check if the buffer has enough space to hold the answer\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"The buffer has not enough space to hold the answer\")\n\t}\n\n\t// Clear the answer buffer\n\tfor i := 0; i < len(answer); i++ {\n\t\tanswer[i] = 0\n\t}\n\n\t// Clear the bits in the CollReg that are used for receiving\n\td.clearRegisterBitMask(CollReg, 0x80+0x40+0x20+0x10+0x08+0x04+0x02+0x01)\n\n\t// Set the bits in the CollReg that are used for the request mode\n\td.setRegisterBitMask(CollReg, reqMode)\n\n\t// For NTAG216, the 7 bits should be sent in the last byte\n\tif reqMode == 0x26 {\n\t\td.setRegisterBitMask(TxModeReg, 0x04)\n\t} else {\n\t\td.clearRegisterBitMask(TxModeReg, 0x04)\n\t}\n\n\t// Transceive the data\n\t_, err := d.transceive([]byte{reqMode}, answer)\n\treturn err\n}", "CodeBleu_score": 42.357066389317296}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Clear the answer buffer\n\tanswer[0] = 0\n\tanswer[1] = 0\n\n\t// Clear the bits in the collision register that are used in the response\n\td.clearRegisterBitMask(d.CollReg, 0x03)\n\n\t// Set the bits in the bit-frame-sfd register that are used in the request\n\tswitch reqMode {\n\tcase d.PICC_CMD_REQA:\n\t\td.setRegisterBitMask(d.BitFramingReg, 0x08)\n\tcase d.PICC_CMD_WUPA:\n\t\td.setRegisterBitMask(d.BitFramingReg, 0x08)\n\tdefault:\n\t\td.clearRegisterBitMask(d.BitFramingReg, 0x08)\n\t}\n\n\t// ReqA and WupA have a different value in the last bits of the request.\n\t// ReqA: 0x52, WupA: 0x53\n\tif reqMode == d.PICC_CMD_REQA || reqMode == d.PICC_CMD_WUPA {\n\t\td.setRegisterBitMask(d.BitFramingReg, 0x04)\n\t} else {\n\t\td.clearRegisterBitMask(d.BitFramingReg, 0x04)\n\t}\n\n\t// Transceive the request\n\terr := d.transceive(reqMode, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check the error register for any errors\n\terr = d.checkError()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Clear the bits in the bit-frame-sfd register that are used in the request\n\td.clearRegisterBitMask(d.BitFramingReg, 0x08)\n\n\t// The PICC must have sent a response, otherwise the communication would have failed.\n\treturn nil", "CodeBleu_score": 36.5033689280128}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: The answer buffer must have at least 2 bytes of space\")\n\t}\n\t// Clear the answer buffer by using the clearCommandBuffer function\n\td.clearCommandBuffer()\n\t// Copy the request command into the internal buffer\n\td.setCommandBuffer(reqMode, answer)\n\t// Send the request command\n\td.executeCommand(piccCmdReqA, d.commandBuffer, answer)\n\t// If the answer buffer is not empty, the collision bit will be set.\n\t// If this is the case, the PICC has sent us a collision signal.\n\tif d.collisionReg != 0 {\n\t\t// We don't need to do anything here. We could in fact do something, but we don't know what to do.\n\t\t// This is application dependent! Removing this code will save 7 bytes of flash memory.\n\t\t// If you do not want that, you can add the code below:\n\t\t//\t\t// The PICC has sent us a \"collision\" signal. This means that several PICCs are in the field.\n\t\t//\t\t// We do not know which one is which, they could be in the same or in different areas.\n\t\t//\t\t// We do not know which area each PICC is in, or which PICC is which.\n\t\t//\t\t// We do not know the relative distance of the PICCs to each other.\n\t\t//\t\t// We do not know if they are emitting.\n\t\t//\t\t// We do not know if they are near or far.\n\t\t//\t\t// We do not know if they are mute or loud.\n\t\t//\t\t// We do not know if they are to the left or to the right.\n\t\t//\t\t// In short, we don't know anything!\n\t\t//\t\t// We should just wait for a while, and then try again.\n\t\t//\t\t// This is called \"Backoff\" and is a very important part of the RFID standard.\n\t\t//\t\t// If we do not add backoff, we will be in a tight loop, constantly transm", "CodeBleu_score": 32.159310072348156}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == nil {\n\t\treturn errors.New(\"step pin not set\")\n\t}\n\n\tif d.stepPin.Value() != 0 {\n\t\treturn errors.New(\"step pin already high\")\n\t}\n\n\td.stepPin.Low()\n\ttime.Sleep(d.getDelayPerStep())\n\td.stepPin.High()\n\n\tif d.direction == CW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.041591905812915}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t// Lock the valueMutex to ensure thread safety while accessing shared variables\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a valid step by setting the step pin low, waiting for a delay, and setting the step pin high\n\terr := d.digitalWrite(d.stepPin, gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction == Clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 68.86922313335792}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == 0 {\n\t\treturn errors.New(\"stepPin not set\")\n\t}\n\n\tif d.directionPin == 0 {\n\t\treturn errors.New(\"directionPin not set\")\n\t}\n\n\tif d.delayPerStep == 0 {\n\t\treturn errors.New(\"delayPerStep not set\")\n\t}\n\n\tif d.stepNumber == 0 {\n\t\treturn errors.New(\"stepNumber not set\")\n\t}\n\n\tif d.direction == 0 {\n\t\treturn errors.New(\"direction not set\")\n\t}\n\n\tif d.valueMutex == nil {\n\t\treturn errors.New(\"valueMutex not set\")\n\t}\n\n\tif d.digitalWrite == nil {\n\t\treturn errors.New(\"digitalWrite not set\")\n\t}\n\n\tif d.getDelayPerStep == nil {\n\t\treturn errors.New(\"getDelayPerStep not set\")\n\t}\n\n\td.digitalWrite(d.stepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, 1)\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.588648084692814}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name)\n\treturn nil\n}", "CodeBleu_score": 68.14963285978233}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 63.55502568616137}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 68.2114057082292}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, eventType string, eventValue uint32, eventTimestamp uint32) {\n\t\tif eventType == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if eventType == \"falling\" {\n\t\t\td.ch <- d.getDistance(startTimestamp, duration)\n\t\t}\n\t}\n}", "CodeBleu_score": 38.66406903966388}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, eventType string, eventValue uint32, eventTimestamp uint32) {\n\t\tif eventType == \"rise\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if eventType == \"fall\" {\n\t\t\td.ch <- d.calculateDistance(startTimestamp, time.Now())\n\t\t}\n\t}\n}", "CodeBleu_score": 38.38036967251319}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestamp32 uint32) {\n\t\tif edge == \"RISING\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else {\n\t\t\td.durationChan <- (t - startTimestamp).Microseconds()\n\t\t}\n\t}\n}", "CodeBleu_score": 43.06049310767572}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor.\n\td.emitTrigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur.\n\tselect {\n\tcase <-time.After(d.measureTimeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\tcase <-d.measureComplete:\n\t}\n\n\t// Store the measured time in microseconds.\n\td.measurement = d.measurementTime\n\n\treturn nil\n}", "CodeBleu_score": 35.61378663471416}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\td.emitTrigger()\n\tselect {\n\tcase <-time.After(d.Timeout):\n\t\treturn fmt.Errorf(\"Timeout while waiting for measurement\")\n\tcase <-d.measurementComplete:\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.863320784595043}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\td.emitTrigger()\n\tselect {\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\tcase <-d.measureMutex.Done():\n\t\treturn nil\n\t}\n}", "CodeBleu_score": 26.99926888799608}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\ttry:\n        token = os.environ.get(self.TOKEN_ENV_VAR)\n        if token:\n            return token\n\n        auth_data = self.get_state_item(self.STATE_ITEM_AUTH_DATA)\n        if not auth_data:\n            raise AccountNotAuthorized\n\n        if auth_data.get(\"expires_at\") <= time.time():\n            if not auth_data.get(\"refresh_token\"):\n                raise AccountNotAuthorized\n\n            auth_data = self.refresh_authentication_token(auth_data)\n            self.set_state_item(self.STATE_ITEM_AUTH_DATA, auth_data)\n        return auth_data.get(\"access_token\")\n    except AccountError as exc:\n        raise AccountNotAuthorized from exc\n\n", "CodeBleu_score": 37.60345020033455}, {"code": "def fetch_authentication_token(self)\n\tif 'AUTH_TOKEN' in os.environ:\n        return os.environ['AUTH_TOKEN']\n    if not self.is_authenticated:\n        raise AccountNotAuthorized(\"No authentication token available.\")\n    if self.is_token_expired:\n        if not self.is_refresh_token_available:\n            raise AccountNotAuthorized(\"No authentication token available.\")\n        try:\n            response = self.fetch_json_data(\n                'auth/refresh',\n                method='POST',\n                data={\n                    'refresh_token': self.refresh_token\n                }\n            )\n            self.set_local_session(response)\n            return self.access_token\n        except HTTPClientError as exc:\n            raise AccountNotAuthorized(\"Failed to refresh access token.\") from exc\n    return self.access_token\n\n", "CodeBleu_score": 34.372540886922756}, {"code": "def fetch_authentication_token(self)\n\tif self.auth_token is None:\n        if self.refresh_token is None:\n            raise AccountNotAuthorized(\"No authentication token available.\")\n        else:\n            try:\n                self.auth_token = self.get_access_token_from_refresh_token()\n            except HTTPClientError as exc:\n                raise AccountNotAuthorized(\n                    \"Could not refresh authentication token.\"\n                ) from exc\n            self.set_state_item(\"auth_token\", self.auth_token)\n            self.set_state_item(\"auth_token_expires_at\", self.auth_token_expires_at)\n\n", "CodeBleu_score": 25.368339195636935}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\ttry:\n        refresh_token = self.get_refresh_token()\n    except AccountError:\n        refresh_token = None\n    self.delete_local_session()\n    if refresh_token:\n        try:\n            self.fetch_json_data(\n                \"/v1/logout\",\n                method=\"POST\",\n                params={\"refresh_token\": refresh_token},\n            )\n        except AccountError:\n            pass\n    return True\n\n", "CodeBleu_score": 64.45841488589265}, {"code": "def logout(self)\n\ttry:\n        self.get_refresh_token()\n    except AccountError:\n        pass\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\"/v1/logout\", method=\"POST\")\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 49.816224595016095}, {"code": "def logout(self)\n\tself.delete_local_session()\n    try:\n        self.get_refresh_token()\n        self.fetch_json_data(\n            \"/v1/logout\",\n            method=\"POST\",\n            headers={\"Authorization\": \"Bearer {}\".format(self.refresh_token)},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 50.268081923368555}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\tused_packages = []\n    for package in self.pm.list_packages():\n        if not package.optional:\n            used_packages.append({\n                'name': package.name,\n                'version': package.version,\n                'source': package.source_url\n            })\n    return used_packages\n\n", "CodeBleu_score": 23.77422140726715}, {"code": "def dump_used_packages(self)\n\tused_packages = []\n    for package in self.pm.get_installed():\n        if not package.metadata.get('optional', False):\n            used_packages.append(\n                {\n                    'name': package.name,\n                    'version': package.version,\n                    'source_url': package.metadata.get('source_url', '')\n                }\n            )\n    return used_packages\n\n", "CodeBleu_score": 25.922612842737415}, {"code": "def dump_used_packages(self)\n\tused_packages = []\n    for package in self.pm.list_installed():\n        if package.is_optional:\n            continue\n        package_info = {\n            'name': package.name,\n            'version': package.version,\n            'build_number': package.build_number,\n            'build_string': package.build_string,\n            'build_platform': package.build_platform,\n            'build_platform_version': package.build_platform_version,\n            'build_platform_revision': package.build_platform_revision,\n            'build_timestamp': package.build_timestamp,\n            'build_type': package.build_type,\n            'build_tag': package.build_tag,\n            'build_user': package.build_user,\n            'build_machine': package.build_machine,\n            'build_sys_type': package.build_sys_type,\n            'build_proc_type': package.build_proc_type,\n            'build_app_version': package.build_app_version,\n            'build_app_build_number': package.build_app_build_number,\n            'build_app_build_string': package.build_app_build_string,\n            'build_app_build_platform': package.build_app_build_platform,\n            'build_app_build_platform_version': package.build_app_build_platform_version,\n            'build_app_build_platform_revision': package.build_app_build_platform_revision,\n            'build_app_build_timestamp': package.build_app_build_timestamp,\n            'build_app_build_type': package.build_app_build_type,\n            'build_app_build_tag': package.build_app_build_tag,\n            'build_app_build_user': package.build_app_build_user,\n            'build_app_build_machine': package.build_app_build_machine,\n            'build_app_build_sys_type': package.build_app_build_sys_type,\n            'build_app_build_proc_type': package.build_app_", "CodeBleu_score": 15.402121245557565}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not env:\n        raise UndefinedEnvPlatformError\n    platform = cls.get_platform_for_env(env)\n    if not platform:\n        raise UndefinedEnvPlatformError\n    p = cls(platform, autoinstall=autoinstall)\n    p.set_env(env)\n    p.configure_project_packages(targets)\n    return p\n\n", "CodeBleu_score": 38.01781062124226}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tenv_name = cls.normalize_env_name(env)\n    if env_name is None:\n        raise exception.UndefinedEnvPlatformError(env)\n\n    # Get the platform specification for the environment\n    platform_spec = cls.get_platform_spec(env_name)\n    if platform_spec is None:\n        raise exception.UndefinedEnvPlatformError(env)\n\n    # Create a new instance of the class with the platform specification\n    instance = cls.new(platform_spec, autoinstall=autoinstall)\n\n    # Set the project environment\n    instance.set_project_environment(env_name)\n\n    # Configure the project packages for the given environment and targets\n    instance.configure_project_packages(targets=targets)\n\n    return instance\n\n", "CodeBleu_score": 24.43067865410512}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tenv_name = env\n    if isinstance(env, cls):\n        env_name = env.name\n    elif isinstance(env, str):\n        env = cls.get_instance(env)\n    elif isinstance(env, dict):\n        env = cls.from_dict(env)\n\n    if env_name not in cls.get_platform_names():\n        raise UndefinedEnvPlatformError(env_name)\n\n    env.autoinstall = autoinstall\n    env.configure_project_packages(targets)\n    return env\n\n", "CodeBleu_score": 35.929676604053206}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(AXP192_ADDRESS);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(AXP192_ADDRESS, Size);\n    for (uint8_t i = 0; i < Size; i++) {\n        Buff[i] = Wire1.read();\n    }\n}", "CodeBleu_score": 67.79700432617571}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(AXP192_SLAVE_ADDRESS);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(AXP192_SLAVE_ADDRESS, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 66.20881785131758}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 78.48483205243677}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.3181116932034}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 59.179927255240706}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.3181116932034}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\tuint16_t y = 0;\n  uint16_t x = 0;\n  uint16_t y_prev = y;\n\n  if (tteBar) {\n    y = tft.height() - tft.height() / 8;\n  } else {\n    y = tft.height() - tft.height() / 16;\n  }\n\n  if (y >= tft.height() - tft.height() / 8) {\n    y = tft.height() - tft.height() / 8;\n  }\n\n  if (y < tft.height() - tft.height() / 16) {\n    y = tft.height() - tft.height() / 16;\n  }\n\n  if (y_prev != y) {\n    tft.fillRect(0, y_prev, tft.width(), tft.height() / 8, color);\n    scrollAddress(y_prev);\n    y_prev = y;\n  }\n\n  return y_prev;\n}", "CodeBleu_score": 24.005770825856676}, {"code": "int Display::scroll_line(uint32_t color){\n\tint y = 0;\n  #ifdef HAS_ILI9341\n    tft.writecommand(ILI9341_VSCRSADD); // Vertical scrolling pointer\n    tft.writedata(vsp>>8);\n    tft.writedata(vsp);\n    tft.writecommand(ILI9341_RAMWR);\n    tft.fillRect(0, vsp, tft.width(), tft.height()-vsp, color);\n    if (vsp < tft.height()-vsp) {\n      y = vsp;\n      vsp += tft.height()/16;\n    } else {\n      y = vsp;\n      vsp = 0;\n    }\n  #endif\n  return y;\n}", "CodeBleu_score": 21.643471295688528}, {"code": "int Display::scroll_line(uint32_t color){\n\tuint16_t y = scroll_y;\n  tft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n  scroll_y += tft.fontHeight();\n  if (scroll_y >= (tft.height() - tft.fontHeight())) {\n    scroll_y = tft.fontHeight();\n    if (tteBar) {\n      scrollAddress(0x0000);\n    } else {\n      scrollAddress(0x0000 + tft.fontHeight());\n    }\n  }\n  return y;\n}", "CodeBleu_score": 16.691946980259175}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  this->setAP();\n  this->setHtml();\n\n  this->startAP();\n\n  this->runServer = true;\n\n  return true;\n}", "CodeBleu_score": 52.92217015083198}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tif (ssids == NULL || access_points == NULL) {\n    return false;\n  }\n\n  if (!this->setAP(ssids)) {\n    return false;\n  }\n\n  if (!this->setHtml(access_points)) {\n    return false;\n  }\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 58.57236061699105}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setAP()) {\n    return false;\n  }\n\n  if (!this->setHtml()) {\n    return false;\n  }\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 61.6317923640472}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag == true) {\n        if (text == NULL) {\n            text = new char[BUF_SIZE];\n            text_in = new char[BUF_SIZE];\n        }\n    }\n    else {\n        flush_queue();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 15.681857191369728}, {"code": "void GpsInterface::enable_queue(){\n\tif (this->queue_enabled_flag) {\n        if (!this->queue_initialized) {\n            this->initialize_queue();\n        }\n    } else {\n        this->flush_queue();\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 30.747548142975067}, {"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n\t\tif (!this->queue) {\n\t\t\tthis->queue = new Queue(this->max_queue_length, this->queue_name);\n\t\t\tthis->text = new Text(this->max_text_length, this->text_name);\n\t\t\tthis->text_in = new Text(this->max_text_length, this->text_in_name);\n\t\t}\n\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 29.029612350703744}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\tif (this->queue != NULL) {\n\t\tif (this->queue->size() > 0) {\n\t\t\tthis->new_queue = new queue<string>();\n\t\t\tdelete this->queue;\n\t\t\tthis->queue = this->new_queue;\n\t\t}\n\t} else {\n\t\tthis->queue = new queue<string>();\n\t}\n}", "CodeBleu_score": 25.22425249144239}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (this->queue != NULL) {\n\t\tif (this->queue->size() != 0) {\n\t\t\tthis->new_queue = new std::queue<std::string>();\n\t\t\tthis->new_queue->swap(*this->queue);\n\t\t\tdelete this->queue;\n\t\t\tthis->queue = this->new_queue;\n\t\t}\n\t} else {\n\t\tthis->queue = new std::queue<std::string>();\n\t}\n\n\treturn;\n}", "CodeBleu_score": 20.477651555913308}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (this->queue_nmea) {\n\t\tthis->new_queue_nmea = new std::queue<std::string>();\n\t\twhile (!this->queue_nmea->empty()) {\n\t\t\tthis->new_queue_nmea->push(this->queue_nmea->front());\n\t\t\tthis->queue_nmea->pop();\n\t\t}\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = this->new_queue_nmea;\n\t\tthis->new_queue_nmea = NULL;\n\t} else {\n\t\tthis->queue_nmea = new std::queue<std::string>();\n\t}\n}", "CodeBleu_score": 17.510396784207483}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t c;\n    uint32_t i;\n    uint32_t p;\n\n    /*Serial.println(\"Flushing display\");*/\n\n    /*Set the TFT address window to the area to be updated.*/\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n    /*Start a transaction to avoid multiple transactions from being started simultaneously.*/\n    display_obj.tft.startWrite();\n\n    /*Iterate through each pixel in the area.*/\n    for (i = 0; i < (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1); i++) {\n      /*Get the color of the pixel.*/\n      c = color_p->full;\n\n      /*Write the color to the TFT.*/\n      display_obj.tft.writeColor(c, 1);\n\n      /*Increment the color pointer.*/\n      color_p++;\n    }\n\n    /*End the transaction.*/\n    display_obj.tft.endWrite();\n\n    /*Notify the graphics library that the flush is complete.*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 65.46347031371947}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint32_t x;\n    uint32_t y;\n\n    /*Serial.println(\"flush\");\n    Serial.println(area->x1);\n    Serial.println(area->x2);\n    Serial.println(area->y1);\n    Serial.println(area->y2);*/\n\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    for (y = area->y1; y <= area->y2; y++) {\n      for (x = area->x1; x <= area->x2; x++) {\n        display_obj.tft.writeColor(color_p->full);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 77.55165628678998}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t c;\n    uint32_t i;\n    uint32_t x;\n    uint32_t y;\n    uint32_t px_num = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n    for (y = area->y1; y <= area->y2; y++) {\n      for (x = area->x1; x <= area->x2; x++) {\n        i = (y - area->y1) * (area->x2 - area->x1 + 1) + (x - area->x1);\n        c = color_p[i];\n        display_obj.tft.writeColor(c, 1);\n      }\n    }\n\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 69.97650959570542}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tif (menu != NULL) {\n\t\tfor (int i = 0; i < menu->list->size; i++) {\n\t\t\tMenu * node = (Menu *)menu->list->get(i);\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tSerial.print(\"  \");\n\t\t\t}\n\t\t\tSerial.print(node->name);\n\t\t\tSerial.println();\n\t\t\tif (node->list != NULL) {\n\t\t\t\tshowMenuList(node, layer + 1);\n\t\t\t}\n\t\t}\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 57.29919089413193}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tif (menu == NULL) {\n    return;\n  }\n  for (int i = 0; i < menu->list->size; i++) {\n    MenuNode * node = menu->list->get(i);\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\"  \");\n    }\n    Serial.println(node->name);\n  }\n  Serial.println();\n}", "CodeBleu_score": 61.74531395084767}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t// Iterate through all menu nodes\n\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\t// Print menu node name with indentation\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"\\t\");\n\t\t}\n\t\tSerial.println(menu->list->get(i)->name);\n\t\t// If menu node has children, print them with increased indentation\n\t\tif (menu->list->get(i)->children != NULL) {\n\t\t\tshowMenuList(menu->list->get(i)->children, layer + 1);\n\t\t}\n\t}\n\t// Print an empty line\n\tSerial.println();\n}", "CodeBleu_score": 58.743654006678746}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\tfor (int i = 0; i < count; i++) {\n    String ssid = randomSSID();\n    int channel = random(1, 14);\n    String mac = randomMAC();\n    ssids->add(new SSID(ssid, channel, mac));\n    Serial.println(ssid + \" \" + channel + \" \" + mac);\n  }\n  return count;\n}", "CodeBleu_score": 31.674515585255264}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i = 0;\n  char essid[7];\n  int channel = 0;\n  String macAddress = \"\";\n  while (i < count) {\n    for (int j = 0; j < 6; j++) {\n      essid[j] = (char)random(97, 123);\n    }\n    essid[6] = '\\0';\n    channel = random(1, 14);\n    macAddress = generateMACAddress();\n    Serial.println(String(essid) + \" \" + String(channel) + \" \" + macAddress);\n    ssids->add(new SSID(String(essid), channel, macAddress));\n    i++;\n  }\n  return i;\n}", "CodeBleu_score": 43.13303760213781}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i;\n  for (i = 0; i < count; i++) {\n    char ssid[7];\n    char mac[18];\n    int channel;\n    String essid;\n    generateRandomSSID(ssid);\n    generateRandomMAC(mac);\n    channel = generateRandomChannel();\n    essid = String(ssid);\n    essid.concat(\"-\");\n    essid.concat(mac);\n    essid.concat(\"-\");\n    essid.concat(channel);\n    ssids->add(essid);\n    Serial.println(essid);\n  }\n  return i;\n}", "CodeBleu_score": 40.02869950859893}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\tiat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode({'iat': iat, 'exp': exp, 'aud': project_id}, private_key, algorithm)\n\n", "CodeBleu_score": 37.35032716712385}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t# Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT payload.\n    iat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': project_id\n    }\n\n    # Create the JWT.\n    return jwt.encode(payload, private_key, algorithm)\n\n", "CodeBleu_score": 48.290477188827055}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\tiat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 50.36792315527999}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n            payload, message.topic, message.qos))\n    if payload == 'on':\n        path = '/home/pi/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        print('Uploaded file to {}'.format(url))\n        publish_event(url)\n    else:\n        print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n            payload, message.topic, message.qos))\n        print('off')\n\n", "CodeBleu_score": 45.22740882156849}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode()\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        path = '/home/pi/Desktop/image.jpg'\n        url = upload_file(path, args.bucket_name)\n        print(url)\n        client.publish('events', url, qos=1)\n    elif payload == 'off':\n        print('off')\n    else:\n        print('unknown')\n\n", "CodeBleu_score": 42.453597084581496}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode()\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n        payload, message.topic, message.qos))\n    if payload == 'on':\n        print('Capturing preview image...')\n        path = '/home/pi/Desktop/image.jpg'\n        url = upload_file(path, args.bucket_name)\n        print('Preview image uploaded to {}'.format(url))\n        print('Publishing URL to MQTT event topic...')\n        mqtt_topic = '/devices/{}/events'.format(args.device_id)\n        client.publish(mqtt_topic, url, qos=1)\n    else:\n        print('Payload is not \"on\".')\n\n", "CodeBleu_score": 52.785850549295056}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description=\"MQTT device connection for Google Cloud IoT Core.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name.\")\n    parser.add_argument(\"--registry_id\", required=True, help=\"Cloud IoT Core registry id.\")\n    parser.add_argument(\"--device_id\", required=True, help=\"Cloud IoT Core device id.\")\n    parser.add_argument(\"--private_key_file\", required=True, help=\"Path to private key file.\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), default=\"RS256\", help=\"Encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--ca_certs\", default=\"roots.pem\", help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", choices=(8883, 443), default=8883, type=int, help=\"MQTT bridge port.\")\n    parser.add_argument(\"--jwt_expires_minutes\", default=20, type=int, help=\"Expiration time, in minutes, for JWT tokens.\")\n    parser.add_argument(\"--jwt_refresh_minutes\", default=15, type=int, help=\"Refresh interval, in minutes, for JWT tokens.\")\n    parser.add_argument(\"--message_type\", default=\"event\", choices=(\"event\", \"state\"), help=\"Message type to publish. Default is 'event'.\")\n    parser.add_argument(\"--message_data\", default=\"{}\", help=\"Data to send in the message payload. Default is '{}'.\")\n    parser.add_argument(\"--message_id\", default=\"\", help=\"Identifier string to use with state messages. Default is ''.\")\n    parser.add_argument(\"--mqtt_topic\", default=\"state\", help=\"", "CodeBleu_score": 37.282105820632}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description='Arguments for Google Cloud IoT Core MQTT example.')\n    parser.add_argument(\n        '--project_id', help='GCP cloud project name', required=True)\n    parser.add_argument(\n        '--registry_id', help='Cloud IoT Core registry id', required=True)\n    parser.add_argument(\n        '--device_id', help='Cloud IoT Core device id', required=True)\n    parser.add_argument(\n        '--private_key_file', help='RSA private key file', required=True)\n    parser.add_argument(\n        '--algorithm', help='Encryption algorithm', default='RS256')\n    parser.add_argument(\n        '--cloud_region', help='GCP cloud region', default='us-central1')\n    parser.add_argument(\n        '--ca_certs', help='CA root certificate',\n        default='roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        help='Number of messages to publish',\n        default=10)\n    parser.add_argument(\n        '--message_type', help='Type of message to publish', choices=['event', 'state'], default='event')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='MQTT bridge hostname',\n        default='mqtt.googleapis.com')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        help='MQTT bridge port',\n        choices=[8883, 443],\n        default=8883)\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        help='Expiration time in minutes for JWT tokens',\n        default=20)\n    parser.add_argument(\n        '--jwt_refresh_minutes',\n        help='Refresh time in minutes for JWT tokens',\n        default=15)\n    parser.add_argument(\n        '--mqtt_topic', help='MQTT topic', default='state')\n    parser.add_argument(\n        '", "CodeBleu_score": 32.05160724441492}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description=\"Arguments for Google Cloud IoT Core MQTT example.\")\n    parser.add_argument(\n        '--project_id', help='GCP cloud project name', required=False)\n    parser.add_argument(\n        '--region', help='GCP cloud region name', required=False)\n    parser.add_argument(\n        '--registry_id', help='Registry ID', required=True)\n    parser.add_argument(\n        '--device_id', help='Device ID', required=True)\n    parser.add_argument(\n        '--private_key_file', help='RSA private key file', required=True)\n    parser.add_argument(\n        '--algorithm', help='Encryption algorithm', required=False)\n    parser.add_argument(\n        '--ca_certs', help='CA root certificate', required=True)\n    parser.add_argument(\n        '--num_messages',\n        help='Number of messages to publish.',\n        default=10,\n        type=int)\n    parser.add_argument(\n        '--message_type',\n        help='Type of message to publish.',\n        choices=['event', 'state'],\n        default='event')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='MQTT bridge hostname.',\n        default='mqtt.googleapis.com')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        help='MQTT bridge port.',\n        choices=[8883, 443],\n        default=8883,\n        type=int)\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        help='Expiration time in minutes for JWT tokens.',\n        default=20,\n        type=int)\n    parser.add_argument(\n        '--jwt_refresh_interval_minutes',\n        help='Refresh interval for JWT tokens.',\n        default=15,\n        type=int)\n    parser.add_argument(\n        '--mqtt_topic', help='MQTT topic to sub", "CodeBleu_score": 37.35899027266304}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\tcredentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(['https://www.googleapis.com/auth/cloud-platform'])\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n    return discovery.build('cloudiot', 'v1', credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 18.45659853907047}, {"code": "def get_client(service_account_json)\n\t# Set up the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(['https://www.googleapis.com/auth/cloud-platform'])\n\n    # Set up the Cloud IoT Core service\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n    service = discovery.build('cloudiot', 'v1', credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n    return service\n\n", "CodeBleu_score": 20.338899730190455}, {"code": "def get_client(service_account_json)\n\tcredentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=SCOPES)\n    credentials = credentials.with_scopes(SCOPES)\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n    return discovery.build('cloudiot', 'v1', credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 17.58126464344641}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\thash_method_asn1 = hash_method_to_asn1(hash_method)\n    hash_with_asn1 = hash_method_asn1 + hash_value\n    padded_hash = _pad_for_signing(hash_with_asn1, 16)\n    return priv_key.blinded_encrypt(padded_hash)", "CodeBleu_score": 9.730794242749043}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# get ASN1 code for hash method\n    hash_code = get_hash_code(hash_method)\n\n    if not hash_code:\n        raise ValueError('Invalid hash method')\n\n    # concatenate hash code and hash value\n    message = b''.join([hash_code, hash_value])\n\n    # pad for signing\n    padded_message = _pad_for_signing(message, 16)\n\n    # encrypt padded message\n    encrypted_message = priv_key.blinded_encrypt(padded_message)\n\n    return encrypted_message", "CodeBleu_score": 32.68958066717035}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# check hash method\n    if hash_method not in _hash_methods:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n\n    # get ASN1 code for hash method\n    hash_method_code = _hash_methods[hash_method]\n\n    # concatenate ASN1 code with hash value\n    hash_value_with_code = hash_method_code + hash_value\n\n    # pad the hash value for signing\n    hash_value_with_code_padded = _pad_for_signing(hash_value_with_code,\n                                                   _hash_block_lengths[hash_method])\n\n    # encrypt the hash value with the private key\n    encrypted_signature = priv_key.blinded_encrypt(hash_value_with_code_padded)\n\n    return encrypted_signature\n\n", "CodeBleu_score": 48.73210462958305}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t# convert the signature to an integer\n    sig_int = transform.bytes2int(signature)\n    # decrypt the signature to obtain the clear signature\n    clear_sig = common.byte_size(common.decrypt_int(sig_int, pub_key))\n    # find the hash method used\n    hash_method = _find_method_hash(clear_sig)\n    # compute the hash of the message\n    hashed_msg = compute_hash(message, hash_method)\n    # reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(hashed_msg, len(clear_sig))\n    # if the expected padded hash does not match the clear signature, raise a verification error\n    if expected_hash != clear_sig:\n        raise VerificationError('Verification failed')\n    # if the verification is successful, return the hash method name\n    return hash_method", "CodeBleu_score": 21.272496530264252}, {"code": "def verify(message, signature, pub_key)\n\t#:param message: the signed message. Can be an 8-bit string or a file-like\n    #:        object. If ``message`` has a ``read()`` method, it is assumed to be a\n    #:        file-like object.\n    #:param signature: the signature to be verified.\n    #:param pub_key: the public key.\n    #:return: the hash method name.\n    #:raise VerificationError: when the signature is invalid.\n    #:raise ValueError: when the hash method cannot be found.\n    #:raise OverflowError: when the message is too long.\n\n    #:return: the hash method name.\n    #:raise VerificationError: when the signature is invalid.\n    #:raise ValueError: when the hash method cannot be found.\n    #:raise OverflowError: when the message is too long.\n\n    #:return: the hash method name.\n    #:raise VerificationError: when the signature is invalid.\n    #:raise ValueError: when the hash method cannot be found.\n    #:raise OverflowError: when the message is too long.\n\n    #:return: the hash method name.\n    #:raise VerificationError: when the signature is invalid.\n    #:raise ValueError: when the hash method cannot be found.\n    #:raise OverflowError: when the message is too long.\n\n    #:return: the hash method name.\n    #:raise VerificationError: when the signature is invalid.\n    #:raise ValueError: when the hash method cannot be found.\n    #:raise OverflowError: when the message is too long.\n\n    #:return: the hash method name.\n    #:raise VerificationError: when the signature is invalid.\n    #:raise ValueError: when the hash method cannot be found.\n    #:raise OverflowError: when the message is too long.\n\n    #:return: the hash method name.\n    #:raise VerificationError: when the signature is invalid.\n    #:raise ValueError: when the hash method cannot be found.\n    #:raise OverflowError: when the message is too long.\n\n    #:return: the hash method name.\n    #:raise VerificationError: when", "CodeBleu_score": 1.8790849673202614}, {"code": "def verify(message, signature, pub_key)\n\t# Convert signature to an integer\n    sigint = transform.bytes2int(signature)\n\n    # Decrypt the integer to obtain the clear signature\n    clearsig = core.decrypt_int(sigint, pub_key)\n\n    # Find the hash method used\n    hash_method = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hash_message = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(hash_message, len(clearsig))\n\n    # If the expected padded hash does not match the clear signature,\n    # raise a verification error\n    if expected_hash != clearsig:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 23.028714538630645}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t// Get current time\n  time_t epoch = time(NULL);\n  // Check if current time is valid\n  if (epoch < 1516239022) {\n    debug_printError(\"Invalid time\");\n    return;\n  }\n  // Update JWT\n  updateJWT(epoch);\n\n  // Connect to MQTT\n  MQTT_CLIENT_connect();\n\n  // Set flag to send MQTT SUBSCRIBE packet after connection is established\n  sendSubscribe = true;\n\n  debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 32.81671459969301}, {"code": "static void connectMQTT(){\n\ttime_t epoch = time(NULL);\n    debug_printInfo(\"MQTT: Connecting to MQTT broker\");\n    updateJWT(epoch);\n    MQTT_CLIENT_connect();\n    MQTT_CLIENT_subscribe();\n}", "CodeBleu_score": 24.44048305686183}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = time(NULL);\n    if (epoch > 0) {\n        updateJWT(epoch);\n    }\n\n    if (MQTT_CLIENT_connect(cid, mqttPassword, mqttTopic, mqttUsername, 1, 0) == 0) {\n        debug_printError(\"MQTT: Connection failed\");\n        return;\n    }\n\n    debug_printInfo(\"MQTT: Connected\");\n    mqttConnected = 1;\n    mqttSubscribe = 1;\n}", "CodeBleu_score": 50.506509956182825}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t value = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tvalue = value * 10 + (str[i] - '0');\n\t}\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 26.33656613247644}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t value = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        value = value * 10 + (c - '0');\n    }\n    *num = value;\n    return str;\n}", "CodeBleu_score": 26.262990903845623}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9')\n            return str;\n        n = n * 10 + c - '0';\n    }\n    *num = n;\n    return str;\n}", "CodeBleu_score": 23.890760123165943}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n\n    if (build_state == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Set the serial number\n    ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Set the signature\n    ret = atcacert_set_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_SIGNATURE], build_state->cert, build_state->cert_size, build_state->signature, build_state->signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Set the signature algorithm\n    ret = atcacert_set_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_SIG_ALG], build_state->cert, build_state->cert_size, build_state->sig_alg, build_state->sig_alg_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Set the issuer\n    ret = atcacert_set_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_ISSUER], build_state->cert, build_state->cert_size, build_state->issuer, build_state->issuer_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Set the subject\n    ret = atcacert_set_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_SUBJECT], build_state->cert, build_state->cert", "CodeBleu_score": 60.86315656937123}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    uint8_t cert[ATCACERT_CERT_MAX_SIZE];\n    size_t cert_size = sizeof(cert);\n    size_t i = 0;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Generate the certificate\n    ret = atcacert_gen_cert(build_state->cert_def, cert, cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Generate the serial number\n    ret = atcacert_gen_cert_sn(build_state->cert_def, cert, cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Copy the certificate to the output buffer\n    if (build_state->cert_size < cert_size)\n    {\n        return ATCACERT_E_BUFFER_TOO_SMALL;\n    }\n    memcpy(build_state->cert, cert, cert_size);\n    build_state->cert_size = cert_size;\n\n    // Calculate the SHA256 of the certificate\n    ret = atcacert_get_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_CERT_SHA256], build_state->cert, build_state->cert_size, build_state->cert_sha256, sizeof(build_state->cert_sha256));\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Calculate the SHA256 of the public key\n    ret = atcacert_get_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_PUBLIC_KEY_SHA256], build_", "CodeBleu_score": 62.249361917379616}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->cert_template_flags & CERT_FLAG_BUILD_CERT)\n    {\n        ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (build_state->cert_def->cert_template_flags & CERT_FLAG_BUILD_SIGNER_ID)\n    {\n        ret = atcacert_get_signer_id(build_state->cert_def, build_state->cert, build_state->cert_size, &build_state->signer_id);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (build_state->cert_def->cert_template_flags & CERT_FLAG_BUILD_ISSUE_DATE)\n    {\n        ret = atcacert_get_issue_date(build_state->cert_def, build_state->cert, build_state->cert_size, &build_state->issue_date);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (build_state->cert_def->cert_template_flags & CERT_FLAG_BUILD_EXPIRE_DATE)\n    {\n        ret = atcacert_get_expire_date(build_state->cert_def, build_state->cert, build_state->cert_size, &build_state->expire_date);\n        if (ret != ATCACERT_E_SUCCESS", "CodeBleu_score": 61.181565385804994}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, ca_public_key, &cert[cert_def->cert_elements[ATCACERT_ELEMENT_SIGNATURE].offset], cert_def->cert_elements[ATCACERT_ELEMENT_SIGNATURE].size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, &cert[cert_def->cert_elements[ATCACERT_ELEMENT_TBS_DIGEST].offset], cert_def->cert_elements[ATCACERT_ELEMENT_TBS_DIGEST].size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return atcab_verify_extern(&cert[cert_def->cert_elements[ATCACERT_ELEMENT_TBS_DIGEST].offset], cert_def->cert_elements[ATCACERT_ELEMENT_TBS_DIGEST].size, &cert[cert_def->cert_elements[ATCACERT_ELEMENT_SIGNATURE].offset], cert_def->cert_elements[ATCACERT_ELEMENT_SIGNATURE].size, ca_public_key);\n}", "CodeBleu_score": 64.3722934468757}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest and signature\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, cert_def->tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    ret = atcacert_get_signature(cert_def, cert, cert_size, cert_def->tbs_digest, cert_def->signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature\n    return atcab_verify_extern(cert_def->tbs_digest, cert_def->signature, ca_public_key);\n}", "CodeBleu_score": 64.55714029306195}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Retrieve the TBS digest and signature from the certificate\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, NULL, NULL);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest using the CA public key\n    ret = atcab_verify_extern(cert_def->sign_key, cert_def->tbs_digest, cert_def->signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 57.531885567307306}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif (*list == NULL)\n        {\n            return false;\n        }\n        if (*list == timer)\n        {\n            *list = (*list)->next;\n            return true;\n        }\n        return timeout_deleteHelper(&((*list)->next), timer);\n    }", "CodeBleu_score": 24.63506967185738}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif(list==NULL)\n    {\n        return false;\n    }\n\n    if(timer==NULL)\n    {\n        return false;\n    }\n\n    if(*list==NULL)\n    {\n        return false;\n    }\n\n    if((*list)->absoluteTime!=timer->absoluteTime)\n    {\n        return false;\n    }\n\n    if((*list)->next==NULL)\n    {\n        return false;\n    }\n\n    if((*list)->next->absoluteTime!=timer->absoluteTime)\n    {\n        return false;\n    }\n\n    if((*list)->next->next!=NULL)\n    {\n        return false;\n    }\n\n    *list = (*list)->next;\n\n    return true;\n}", "CodeBleu_score": 26.86772543138064}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif(list==NULL)\n        return false;\n\n    if(timer==NULL)\n        return false;\n\n    if(*list==NULL)\n        return false;\n\n    if(timer==*list)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *prev = *list;\n    timerStruct_t *cur = prev->next;\n\n    while(cur!=NULL)\n    {\n        if(cur==timer)\n        {\n            prev->next = cur->next;\n            return true;\n        }\n\n        prev = cur;\n        cur = cur->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 37.38980478942303}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tint8_t s8Ret = SOCK_ERR_INVALID_ARG;\n\tif(socket >= 0 && socket < MAX_SOCKET)\n\t{\n\t\ts8Ret = close(socket);\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(BSD_SOCKET_CLOSE_ERR);\n\t\t\ts8Ret = BSD_ERROR;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 25.881513704298126}, {"code": "int BSD_close(int socket){\n\tint8\t\ts8Ret = BSD_ERROR;\n\ttstrSocket\t*pstrSocket = &gastrSockets[socket];\n\tif(pstrSocket->bIsUsed == 1)\n\t{\n\t\ts8Ret = close(socket);\n\t\tif(s8Ret == SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tpstrSocket->bIsUsed = 0;\n\t\t\tpstrSocket->u16SessionID = 0;\n\t\t\tpstrSocket->u8SSLFlags = 0;\n\t\t\tpstrSocket->u8SSLFlags |= SSL_FLAGS_ACTIVE;\n\t\t\ts8Ret = BSD_SUCCESS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbsd_setErrNo(BSD_ERR_SOCKET_CLOSE_FAIL);\n\t\t}\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(BSD_ERR_SOCKET_NOT_CREATED);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 35.80932363300771}, {"code": "int BSD_close(int socket){\n\tint ret = BSD_ERROR;\n\ttstrSocketInfo\tstrSocket;\n\tif(socket < 0 || socket >= TCP_SOCK_MAX)\n\t{\n\t\tbsd_setErrNo(BSD_ERR_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tif(gastrSockets[socket].bIsUsed == 0)\n\t{\n\t\tbsd_setErrNo(BSD_ERR_SOCKET_NOT_CREATED);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tif(gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE)\n\t{\n\t\tret = BSD_SSL_close(socket);\n\t}\n\telse\n\t{\n\t\tret = close(socket);\n\t}\n\t\n\tif(ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(BSD_ERR_SOCKET_CLOSE);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tbsd_setErrNo(BSD_SOCKET_CLOSED);\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 43.336541527113546}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\tret = listen(socket, backlog);\n\t\tif(ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(ret);\n\t\t\tret = BSD_ERROR;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = BSD_SUCCESS;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 38.22790428656131}, {"code": "int BSD_listen(int socket, int backlog){\n\tint s8Ret = BSD_ERROR;\n\tsint8 s8listen = listen((SOCKET)socket, (uint8)backlog);\n\tif(s8listen == SOCK_ERR_NO_ERROR)\n\t{\n\t\ts8Ret = BSD_SUCCESS;\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(s8listen);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 27.272655555222176}, {"code": "int BSD_listen(int socket, int backlog){\n\tint\t\t\t\t\t\t\ts32Ret = BSD_ERROR;\n\tbsd_sock_t\t\t\t\t\tsock = (bsd_sock_t)socket;\n\t\n\ts32Ret = listen(sock, backlog);\n\tif(s32Ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(s32Ret);\n\t\ts32Ret = BSD_ERROR;\n\t}\n\telse\n\t{\n\t\ts32Ret = BSD_SUCCESS;\n\t}\n\treturn s32Ret;\n}", "CodeBleu_score": 35.91559855232968}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts32Ret = -1;\n\tbsdErrno_t\t\t\t\t\t\t\t\t\t\t\t\t\terrno = 0;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(gastrSockets[socket].bIsBound == 1)\n\t\t{\n\t\t\tif(gastrSockets[socket].bIsListening == 1)\n\t\t\t{\n\t\t\t\tif(gastrSockets[socket].bIsConnected == 0)\n\t\t\t\t{\n\t\t\t\t\tif(gastrSockets[socket].bIsClosed == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(gastrSockets[socket].bIsNonBlocking == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(gastrSockets[socket].bIsServerSocket == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ts32Ret = accept(socket, (struct sockaddr *)addr, (uint8 *)addrlen);\n\t\t\t\t\t\t\t\tif(s32Ret == SOCK_ERR_NO_ERROR)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgastrSockets[s32Ret].bIsUsed = 1;\n\t\t\t\t\t\t\t\t\tgastrSockets[s32Ret].bIsServerSocket = 1;\n\t\t\t\t\t\t\t\t\tgastrSockets[s32Ret].bIsConnected = 1;\n\t\t\t\t\t\t\t\t\tgastrSockets[s32Ret].bIsClosed = 0;\n\t\t\t\t\t\t\t\t\tgastrSockets[s32Ret].bIsBound = 1;\n\t\t\t\t\t\t\t\t\tgastrSockets[s32Ret].bIsListening = 1;", "CodeBleu_score": 24.768799823096693}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tret = accept(socket, (struct sockaddr *)addr, addrlen);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 15.016095052981331}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint s8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = accept(socket, (struct sockaddr *)addr, addrlen);\n\t\tif(s8Ret < 0)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 20.526645373447778}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\ttime_t epoch = time(NULL);\n   if (epoch < 0) {\n      debug_printError(\"MQTT: Failed to get time\");\n      return;\n   }\n   debug_printInfo(\"MQTT: Current time is %s\", ctime(&epoch));\n   updateJWT(epoch);\n\n   MQTT_CLIENT_connect(cid, mqttUsername, mqttPassword, mqttTopic, MQTT_QOS_AT_LEAST_ONCE);\n}", "CodeBleu_score": 48.70021771724302}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = time(NULL);\n  if (epoch == 0) {\n    debug_printInfo(\"MQTT: Time is not set\");\n    return;\n  }\n  updateJWT(epoch);\n  MQTT_CLIENT_connect();\n}", "CodeBleu_score": 28.405641427862594}, {"code": "static void connectMQTT(){\n\t// Get the current time\n   uint32_t epoch = time(NULL);\n   if (epoch == 0) {\n      debug_printError(\"MQTT: Unable to get time\");\n      return;\n   }\n   updateJWT(epoch);\n\n   // Initiate MQTT connection\n   MQTT_CLIENT_connect();\n\n   // Set flag to subscribe\n   subscribe = 1;\n}", "CodeBleu_score": 31.55381179252348}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tmqttCurrentState = MQTT_Disconnect(&mqttClient);\n   debug_printError(\"MQTT: Disconnected\");\n}", "CodeBleu_score": 17.488098560202868}, {"code": "void CLOUD_disconnect(void){\n\tmqttContext* connectionInfo = NULL;\n\n   if (mqttState == CONNECTED) {\n      connectionInfo = MQTT_GetClientConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n   }\n\n   debug_printError(\"MQTT_Disconnect\");\n\n}", "CodeBleu_score": 57.08225455791944}, {"code": "void CLOUD_disconnect(void){\n\tmqttCurrentState = MQTT_Disconnect(&mqttContext);\n   if (mqttCurrentState == DISCONNECTED) {\n      debug_printError(\"CLOUD_disconnect: MQTT client disconnected\");\n   }\n}", "CodeBleu_score": 49.76018648472012}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tsint8 ret = M2M_ERR_MEM_ALLOC;\n\tif (passed_wifi_creds == 1) {\n\t\tret = m2m_wifi_connect(WiFi_SSID, strlen(WiFi_SSID), M2M_WIFI_SEC_WPA_PSK, (void *)WiFi_PSK, M2M_WIFI_CH_ALL);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret != M2M_SUCCESS) {\n\t\tdebug_printError(\"Wifi connection failed\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 47.262447899219985}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tsint8 ret = M2M_SUCCESS;\n\ttstrNetworkId networkId;\n\tuint8_t *pucSsid = NULL;\n\tuint8_t u8SsidLen = 0;\n\tuint8_t u8SecType = 0;\n\tvoid *pvAuthInfo = NULL;\n\tuint16 u16Ch = 0;\n\tuint8_t u8IsConnOpen = 0;\n\tuint8_t u8IsDHCPEnabled = 0;\n\tuint8_t u8IsStaticIPEnabled = 0;\n\tuint8_t u8IsDNSConfigured = 0;\n\tuint8_t u8IsMACSet = 0;\n\tuint8_t u8IsPingResponseReceived = 0;\n\tuint8_t u8IsIPConfigured = 0;\n\tuint8_t u8IsMACAddrValid = 0;\n\tuint8_t u8IsSSIDValid = 0;\n\tuint8_t u8IsSecurityValid = 0;\n\tuint8_t u8IsPingResponseReceived = 0;\n\tuint8_t u8IsIPConfigured = 0;\n\tuint8_t u8IsMACAddrValid = 0;\n\tuint8_t u8IsSSIDValid = 0;\n\tuint8_t u8IsSecurityValid = 0;\n\tuint8_t u8IsPingResponseReceived = 0;\n\tuint8_t u8IsIPConfigured = 0;\n\tuint8_t u8IsMACAddrValid = 0;\n\tuint8_t u8IsSSIDValid = 0;\n\tuint8_t u8IsSecurityValid = 0;\n\tuint8_t u8IsPingResponseReceived = 0;\n\tuint8_t u8IsIPConfigured = 0;\n\tuint8_t u8IsMACAddrValid = 0;\n\tuint8_t u8IsSSIDValid = 0;\n\tuint8_t u8IsSecurityValid = 0;\n\tuint8_t u8IsPing", "CodeBleu_score": 4.72333727186532}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tif (passed_wifi_creds == 1) {\n\t\tif (m2m_wifi_connect(SSID, strlen(SSID), M2M_WIFI_SEC_WPA_PSK, (void *) PASSWORD, 0) != M2M_SUCCESS) {\n\t\t\tdebug_printError(\"Could not connect to Wi-Fi\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (m2m_wifi_default_connect() != M2M_SUCCESS) {\n\t\t\tdebug_printError(\"Could not connect to Wi-Fi\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.336273590467336}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t// Create a GraphQL client\n    const client = createClient();\n    // Create a GraphQL query\n    const query = gql`\n        query listSensors {\n            listSensors {\n                items {\n                    id\n                    name\n                    description\n                    geo {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        }\n    `;\n    // Send the query to the API\n    const response = await client.query({query});\n    // If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\n    if (response.data.listSensors.items) {\n        console.log('Sensors retrieved:');\n        response.data.listSensors.items.forEach(sensor => {\n            // Create a marker\n            const marker = document.createElement('div');\n            marker.className = 'marker';\n            // Create a popup\n            const popup = new Popup({\n                offset: 25,\n                closeButton: false,\n                closeOnClick: false\n            });\n            // Create a marker element\n            const markerElement = document.createElement('div');\n            markerElement.className = 'marker-element';\n            markerElement.innerHTML = `\n                <div class=\"marker-element__info\">\n                    <h3 class=\"marker-element__title\">${sensor.name}</h3>\n                    <p class=\"marker-element__description\">${sensor.description}</p>\n                </div>\n                <div class=\"marker-element__actions\">\n                    <button class=\"marker-element__action\">\n                        <i class=\"marker-element__action__icon fas fa-info-circle\"></i>\n                        <span class=\"marker-element__action__label\">More info</span>\n                    </button>\n                    <button class=\"marker-element__action\">\n                        <i class=\"marker-element__action__icon fas fa-map-marker-alt\"></i>\n                        <span class=\"marker-element__action__label\">View on map</span>\n                    </button>\n                </div>\n            `;\n            // Add the marker element to the popup", "CodeBleu_score": 31.014035937084856}, {"code": "async function DisplaySensors(map){\n\t// Create a GraphQL client\n    const client = createClient();\n\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.query(gql`\n        query ListSensors {\n            listSensors {\n                items {\n                    id\n                    name\n                    geo {\n                        longitude\n                        latitude\n                    }\n                }\n            }\n        }\n    `);\n\n    // Log the API response\n    console.log(response);\n\n    // If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\n    if (response.data.listSensors.items) {\n        console.log('Retrieved sensors:');\n        response.data.listSensors.items.forEach(sensor => {\n            // Create a marker for each sensor\n            const marker = new Marker({\n                element: document.createElement('div'),\n                anchor: 'bottom',\n            });\n\n            // Set the marker's position and add it to the map\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n\n            // Log the marker's position\n            console.log(marker.getLngLat());\n        });\n    }\n}", "CodeBleu_score": 56.75223572287658}, {"code": "async function DisplaySensors(map){\n\tconst client = createClient();\n    const response = await client.graphql(gql`\n        query listSensors {\n            listSensors {\n                items {\n                    id\n                    name\n                    sensorType {\n                        name\n                    }\n                    geo {\n                        longitude\n                        latitude\n                    }\n                }\n            }\n        }\n    `);\n    if (response.errors) {\n        console.error(response.errors);\n        return;\n    }\n    console.log(response.data.listSensors);\n    response.data.listSensors.forEach(sensor => {\n        const marker = document.createElement(\"div\");\n        marker.className = \"marker\";\n        marker.style.backgroundImage = `url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/10957/${sensor.sensorType.name.toLowerCase()}.svg)`;\n        marker.style.backgroundSize = \"cover\";\n        marker.style.width = \"50px\";\n        marker.style.height = \"50px\";\n        marker.style.borderRadius = \"50%\";\n        marker.style.cursor = \"pointer\";\n        new Marker({element: marker})\n                        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                        .addTo(map);\n    });\n}", "CodeBleu_score": 51.18310258893006}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"marker\";\n  marker.style.backgroundColor = \"rgba(255, 255, 255, 0.5)\";\n  marker.style.border = \"1px solid white\";\n  return marker;\n}", "CodeBleu_score": 44.92824274421774}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.border = '3px solid #000000';\n  marker.style.borderRadius = '50%';\n  marker.style.width = '15px';\n  marker.style.height = '15px';\n  marker.style.background = 'blue';\n  marker.style.position = 'absolute';\n  marker.style.zIndex = '10';\n  marker.style.top = `${sensor.position.y - 7.5}px`;\n  marker.style.left = `${sensor.position.x - 7.5}px`;\n  return marker;\n}", "CodeBleu_score": 42.183414010436486}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tlet marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensorMarker';\n  marker.style.backgroundColor = 'white';\n  marker.style.border = '2px solid black';\n  return marker;\n}", "CodeBleu_score": 42.9752896252856}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Error importing %s: %s\", module_path, err)\n        raise HomeAssistantError(\n            f\"Error importing {module_path}: {err}\"\n        ) from err\n    except Exception as err:  # pylint: disable=broad-except\n        _LOGGER.error(\"Error importing %s: %s\", module_path, err)\n        raise HomeAssistantError(\n            f\"Error importing {module_path}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"PLATFORMS\"):\n        return module\n\n    if not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module_name, module.__path__[0]\n        )\n\n    return module\n\n", "CodeBleu_score": 46.27850061622032}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"{MFA_PACKAGE_NAME}.{module_name}\"\n    try:\n        module = await hass.async_add_executor_job(_import_module, module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"MFA module %s not found\", module_name)\n        raise\n    except Exception:\n        _LOGGER.exception(\"Failed to import MFA module %s\", module_name)\n        raise\n    if not hasattr(module, \"PLATFORMS\"):\n        _LOGGER.error(\"MFA module %s does not have PLATFORMS attribute\", module_name)\n        raise\n    if not isinstance(module.PLATFORMS, tuple):\n        _LOGGER.error(\n            \"MFA module %s PLATFORMS attribute is not a tuple\", module_name\n        )\n        raise\n    if not module.PLATFORMS:\n        _LOGGER.error(\"MFA module %s does not have any platforms\", module_name)\n        raise\n    if not isinstance(module.PLATFORMS[0], str):\n        _LOGGER.error(\n            \"MFA module %s PLATFORMS attribute is not a tuple of strings\", module_name\n        )\n        raise\n    if not module.PLATFORMS[0]:\n        _LOGGER.error(\"MFA module %s does not have any platforms\", module_name)\n        raise\n    if not hasattr(module, \"get_config_flow\"):\n        _LOGGER.error(\n            \"MFA module %s does not have get_config_flow function\", module_name\n        )\n        raise\n    if not callable(module.get_config_flow):\n        _LOGGER.error(\n            \"MFA module %s get_config_flow attribute is not a callable function\",\n            module_name,\n        )\n        raise\n    if not hasattr(module, \"async_setup_entry\"):\n        _LOGGER.error(\n            \"MFA module %s does not have async_setup_entry function\", module_name\n        )\n        raise\n    if not callable(module.async_setup_entry", "CodeBleu_score": 30.75579837367497}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Unable to import %s\", module_path)\n        raise\n    else:\n        if not hasattr(module, \"PLATFORM_SCHEMA\"):\n            _LOGGER.error(\"Module %s does not have PLATFORM_SCHEMA\", module_path)\n            raise\n        if not hasattr(module, \"async_setup_platform\"):\n            _LOGGER.error(\n                \"Module %s does not have async_setup_platform\", module_path\n            )\n            raise\n    if module_name not in MFA_MODULES:\n        return module\n    if not hass.config.skip_pip and not hass.config.skip_package_installation:\n        requirements = getattr(module, \"REQUIREMENTS\", [])\n        if requirements:\n            await requirements.async_process_requirements(hass)\n    return module\n\n", "CodeBleu_score": 41.93850407993301}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data.get(CONF_PIN)\n    if not pin:\n        raise ValueError(f\"Missing {CONF_PIN} in setup data\")\n    if user_id in self._data:\n        self._data[user_id] = pin\n    else:\n        self._data[user_id] = pin\n\n", "CodeBleu_score": 29.609693525363596}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data[\"pin\"]\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n\n\n\n\n\n\n", "CodeBleu_score": 34.52990329539472}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t# Check if the user already has an entry in the internal data list\n    if user_id in self._data:\n        # Update the PIN\n        self._data[user_id] = setup_data\n    else:\n        # Add a new entry with the user ID and PIN to the data list\n        self._data[user_id] = setup_data\n    # Return the setup data\n    return setup_data\n\n", "CodeBleu_score": 26.344556435434463}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\tif self._initialized:\n        return\n\n    async with self._lock:\n        if self._initialized:\n            return\n\n        if not (data := await self._store.async_load()):\n            return\n\n        # In 2021.9 we fixed validation to disallow a path (because that's never\n        # correct) but this data still lives in storage, so we print a warning.\n        if data.get(\"external_url\") and urlparse(data[\"external_url\"]).path not in (\n            \"\",\n            \"/\",\n        ):\n            _LOGGER.warning(\"Invalid external_url set. It's not allowed to have a path\")\n\n        if data.get(\"internal_url\") and urlparse(data[\"internal_url\"]).path not in (\n            \"\",\n            \"/\",\n        ):\n            _LOGGER.warning(\"Invalid internal_url set. It's not allowed to have a path\")\n\n        await self._async_update(\n            source=ConfigSource.STORAGE,\n            latitude=data.get(\"latitude\"),\n            longitude=data.get(\"longitude\"),\n            elevation=data.get(\"elevation\"),\n            unit_system=data.get(\"unit_system_v2\"),\n            location_name=data.get(\"location_name\"),\n            time_zone=data.get(\"time_zone\"),\n            external_url=data.get(\"external_url\", UNDEFINED),\n            internal_url=data.get(\"internal_url\", UNDEFINED),\n            currency=data.get(\"currency\"),\n            country=data.get(\"country\"),\n            language=data.get(\"language\"),\n            radius=data[\"radius\"],\n        )\n\n", "CodeBleu_score": 21.791509776664}, {"code": "async def _async_load(self) -> None\n\tasync with self._init_lock:\n        if self._async_user_settings:\n            return\n        if not (data := await self._store.async_load()):\n            data = {}\n        self._async_user_settings = {\n            user: NotifySetting(\n                user,\n                data.get(user, {}),\n                self._store,\n                self._event_bus,\n            )\n            for user in data\n        }\n\n", "CodeBleu_score": 39.33612648912966}, {"code": "async def _async_load(self) -> None\n\tasync with self._init_lock:\n        if self._loaded:\n            return\n        data = await self._store.async_load()\n        if not data:\n            data = {}\n        self._data = data\n        self._loaded = True\n        self._notify_settings = {\n            user: NotifySetting(self, user, data[user])\n            for user in data\n            if user not in self._notify_settings\n        }\n\n", "CodeBleu_score": 37.875895345035275}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self._async_load(user_id)\n    user_settings = self._user_settings.get(user_id)\n    if user_settings is None:\n        return False\n    notification_settings = user_settings.get(\"notification\")\n    if notification_settings is None:\n        return False\n    if user_input.get(\"otp\") is None:\n        return False\n    try:\n        otp = int(user_input.get(\"otp\"))\n    except ValueError:\n        return False\n    if notification_settings.get(\"otp_secret\") is None:\n        return False\n    if notification_settings.get(\"otp_secret\") == \"\":\n        return False\n    try:\n        totp = pyotp.TOTP(notification_settings.get(\"otp_secret\"))\n    except pyotp.totp.InvalidKey:\n        return False\n    return totp.verify(otp)\n\n", "CodeBleu_score": 45.52233893088191}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self._async_load(user_id)\n    settings = self.get_settings(user_id)\n    if settings is None:\n        return False\n    return await self._async_validate(user_id, user_input, settings)", "CodeBleu_score": 42.34951124149931}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self._async_load(user_id)\n    settings = self._settings.get(user_id)\n    if not settings:\n        return False\n    return await self._async_validate_otp(user_id, user_input, settings)", "CodeBleu_score": 40.26301960975756}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area = device.area_id\n    if area is None:\n        return None\n    return area_dict.get(area)", "CodeBleu_score": 52.55926639111067}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n\n    area_id = device.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.241374078923066}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.get_entity_entry(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.get_device_entry(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 60.98957198748302}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t# pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-return-statements\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-return-statements\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-return-statements\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-return-statements\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-return-statements\n    # pylint: disable=too-many-branches\n    # pylint: disable=too-many-statements\n    # pylint: disable=too-many-locals\n    # pylint: disable=too-many-nested-blocks\n    # pylint: disable=too-many-return-statements\n    # pylint: disable", "CodeBleu_score": 6.25}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tseen: set[str] = set()\n    policy: PolicyType = {}\n    for policy_dict in policies:\n        if policy_dict is None:\n            continue\n\n        assert isinstance(policy_dict, dict)\n\n        for category in policy_dict:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            policy[category] = _merge_policies([policy_dict.get(category), policy.get(category)])\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 49.44913136686351}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tseen: set[str] = set()\n    policy: PolicyType = {}\n    for policy_dict in policies:\n        if policy_dict is None:\n            continue\n\n        assert isinstance(policy_dict, dict)\n\n        for category, category_policy in policy_dict.items():\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [src.get(category) for src in policies if isinstance(src, dict)]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return policy\n\n", "CodeBleu_score": 48.475362003987854}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        return await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except (ModuleNotFoundError, ImportError) as ex:\n        _LOGGER.error(\n            \"Unable to import auth provider %s: %s\", provider, ex, exc_info=True\n        )\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {ex}\"\n        ) from ex\n\n", "CodeBleu_score": 27.356886526105512}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError:\n        raise HomeAssistantError(f\"Unable to find auth provider {provider}\")\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    try:\n        requirements = module.REQUIREMENTS\n    except AttributeError:\n        raise HomeAssistantError(f\"Unable to load auth provider {provider}\")\n\n    await requirements.async_process_requirements(hass)\n    return module\n\n", "CodeBleu_score": 37.06270537099814}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, \"homeassistant.auth.providers.\" + provider)\n    except ModuleNotFoundError:\n        raise HomeAssistantError(f\"{provider} not found\") from None\n\n    requirements = getattr(module, \"REQUIREMENTS\", [])\n    if not requirements:\n        return module\n\n    await requirements.async_process_requirements(hass)\n    return module\n\n", "CodeBleu_score": 26.576038700998783}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b'password', bcrypt.gensalt())\n    for user in self.users:\n        if user['username'] == username:\n            stored_password = user['password']\n            if bcrypt.checkpw(password.encode(), stored_password):\n                return\n            else:\n                raise InvalidAuth()\n    if bcrypt.checkpw(dummy_hash, stored_password):\n        raise InvalidAuth()\n    else:\n        raise InvalidAuth()\n\n\n\n\n", "CodeBleu_score": 40.01310158206696}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tself.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            password_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            else:\n                raise InvalidAuth()\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth()\n    else:\n        raise InvalidAuth()", "CodeBleu_score": 45.23632962631117}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            raise InvalidAuth\n    if bcrypt.checkpw(dummy_hash, base64.b64decode(self.users[0][\"password\"])):\n        raise InvalidAuth", "CodeBleu_score": 46.757675460745155}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\tusername = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            del self.users[i]\n            return\n    raise InvalidUser(user_not_found)\n\n", "CodeBleu_score": 33.34806023798166}, {"code": "def async_remove_auth(self, username: str) -> None\n\tusername = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(index)\n            break\n    else:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 37.421801949792325}, {"code": "def async_remove_auth(self, username: str) -> None\n\tself.normalize_username\n    for index, user in enumerate(self.users):\n        if user.username == username:\n            del self.users[index]\n            return\n    raise InvalidUser(message=\"user_not_found\")\n\n\n\n\n", "CodeBleu_score": 31.635062668447212}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        self._data = {}\n    if self._data[credentials.username] is None:\n        return\n    self._data[credentials.username] = None\n    await self.async_save()\n\n", "CodeBleu_score": 35.714334832188555}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        self._data = await self._store.async_load()\n    if credentials.username not in self._data:\n        return\n    del self._data[credentials.username]\n    await self._store.async_save(self._data)\n\n", "CodeBleu_score": 46.55317646418423}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif not self._data:\n        self._data = {}\n    if credentials.username in self._data:\n        del self._data[credentials.username]\n    await self.async_save()\n\n", "CodeBleu_score": 35.02203596753639}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is not None:\n                try:\n                    thread.join(timeout=timeout)\n                    joined.add(thread)\n                except (KeyboardInterrupt, SystemExit):\n                    raise\n                except Exception:\n                    pass\n            else:\n                joined.add(thread)\n    if log:\n        for thread in threads - joined:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads - joined:\n        try:\n            async_raise(thread.ident, SystemExit)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except Exception:\n            pass\n    return joined\n\n", "CodeBleu_score": 44.90944150077591}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        try:\n            with suppress(SystemExit):\n                thread.join(timeout=timeout)\n                joined.add(thread)\n        except SystemExit:\n            joined.add(thread)\n        except Exception:\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            try:\n                async_raise(thread.ident, SystemExit)\n            except Exception:\n                pass\n    return joined\n\n", "CodeBleu_score": 51.39228762686449}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        timeout_ = timeout - time.monotonic()\n        if timeout_ <= 0:\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout_)\n        except (SystemExit, KeyboardInterrupt):\n            raise\n        except Exception:\n            pass\n        if thread.is_alive():\n            joined.add(thread)\n        else:\n            joined.add(thread)\n    if log:\n        for thread in threads:\n            if thread.is_alive():\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                thread.interrupt()\n            except (SystemExit, KeyboardInterrupt):\n                raise\n            except Exception:\n                pass\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                thread.join()\n            except (SystemExit, KeyboardInterrupt):\n                raise\n            except Exception:\n                pass\n            if thread.is_alive():\n                joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 44.80769797674874}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\tpass", "CodeBleu_score": 0.5}, {"code": "def deadlock_safe_shutdown() -> None\n\tpass\n\n", "CodeBleu_score": 0.5}, {"code": "def deadlock_safe_shutdown() -> None\n\tif not threading.current_thread().is_daemon():\n        _LOGGER.warning(\"Thread %s is not a daemon thread. This could cause a deadlock.\", threading.current_thread().name)\n    for thread in threading.enumerate():\n        if thread is not threading.main_thread():\n            if not thread.is_alive():\n                _LOGGER.warning(\"Thread %s is not alive.\", thread.name)\n            elif thread.is_daemon():\n                _LOGGER.warning(\"Thread %s is a daemon thread. This could cause a deadlock.\", thread.name)\n            else:\n                _LOGGER.warning(\"Thread %s is alive and is not a daemon thread. This could cause a deadlock.\", thread.name)\n    for thread in threading.enumerate():\n        if thread is not threading.main_thread() and not thread.is_daemon() and thread.is_alive():\n            _LOGGER.warning(\"Waiting for thread %s to shutdown.\", thread.name)\n            try:\n                thread.join(timeout=SHUTDOWN_TIMEOUT / len(threading.enumerate()))\n            except Exception:\n                _LOGGER.warning(\"Thread %s failed to shutdown.\", thread.name)\n\n\n\n\n", "CodeBleu_score": 28.613791027975687}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif len(remaining_with_setup_started) > 0 or len(self._remaining_with_setup_started) > 0:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" sends an internal dispatcher signal with the remaining setups.\"\"\"\n    self._async_dispatcher_send(self._remaining_with_setup_started)\n\n\n def _async_dispatcher_send(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send\" sends an internal dispatcher signal with the remaining setups.\"\"\"\n    self._async_dispatcher_send_signal.emit(remaining_with_setup_started)\n\n\n def _async_dispatcher_callback(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_callback\" is a callback function that is called when the internal dispatcher signal is emitted. It updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n\n def _async_dispatcher_callback_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_callback_internal\" is a callback function that is called when the internal dispatcher signal is emitted. It updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n\n def _async_dispatcher_callback_setup_finished(self, setup_name: str, setup_time: float) -> None:\n    \"\"\"The function \"_async_dispatcher_callback_setup_finished\" is a callback function that is called when", "CodeBleu_score": 44.28646291189659}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif self._remaining_setups or remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_setups = remaining_with_setup_started", "CodeBleu_score": 44.313992058250136}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif not self._remaining_setups:\n        self._remaining_setups = remaining_with_setup_started\n        self._async_dispatcher_send_internal(self._remaining_setups)\n        return\n    if self._remaining_setups:\n        self._async_dispatcher_send_internal(self._remaining_setups)\n    self._remaining_setups = remaining_with_setup_started\n\n\n\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" sends a signal to the dispatcher with the remaining setups.\"\"\"\n    self._async_dispatcher_send(remaining_with_setup_started)\n\n\n\n\n\n def _async_dispatcher_send(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send\" sends a signal to the dispatcher with the remaining setups.\"\"\"\n    self._dispatcher.dispatch(self._remaining_setups_signal, remaining_with_setup_started)\n\n\n\n\n\n def _async_dispatcher_connect(self, callback: Callable[[dict[str, float]], None], signal: str) -> None:\n    \"\"\"The function \"_async_dispatcher_connect\" connects a callback to the dispatcher signal.\"\"\"\n    self._dispatcher.connect(callback, signal)\n\n\n\n\n\n def _async_dispatcher_disconnect(self, callback: Callable[[dict[str, float]], None], signal: str) -> None:\n    \"\"\"The function \"_async_dispatcher_disconnect\" disconnects a callback from the dispatcher signal.\"\"\"\n    self._dispatcher.disconnect(callback, signal)\n\n\n\n\n\n def _async_dispatcher_disconnect_all(self) -> None:\n    \"\"\"The function \"_async_dispatcher_disconnect_all\" disconnects all callbacks from the dispatcher signal.\"\"\"\n    self._dispatcher.disconnect_all()\n\n\n\n\n\n def _async_dispatcher_send_", "CodeBleu_score": 45.85280843733399}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tbluetooth_content = generate_and_validate(integrations)\n    bluetooth_file = config.path.joinpath(\"bluetooth.py\")\n\n    if bluetooth_file.exists():\n        with bluetooth_file.open() as bluetooth_file_handle:\n            current_content = bluetooth_file_handle.read()\n\n        if current_content == bluetooth_content:\n            return\n\n    with bluetooth_file.open(\"w\") as bluetooth_file_handle:\n        bluetooth_file_handle.write(bluetooth_content)\n\n    config.add_error(\n        \"bluetooth.py is not up to date. Please run 'make generate' to fix this issue.\",\n        fix=f\"mv {bluetooth_file} {bluetooth_file}.old && make generate\",\n    )\n\n", "CodeBleu_score": 45.48210263828663}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tbluetooth_content = generate_and_validate(integrations)\n    bluetooth_file = Path(config.config_dir, \"bluetooth.py\")\n\n    if bluetooth_file.exists():\n        with bluetooth_file.open() as bluetooth_file_handle:\n            current_bluetooth_content = bluetooth_file_handle.read()\n\n        if current_bluetooth_content != bluetooth_content:\n            config.add_error(\n                f\"The file '{bluetooth_file}' is out of date and needs to be updated.\",\n                fix=f\"Run `hass --script update_bluetooth_files` to update the file '{bluetooth_file}'.\",\n            )\n\n    else:\n        bluetooth_file.write_text(bluetooth_content)\n\n", "CodeBleu_score": 39.687350480548865}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tbluetooth_py = config.path.joinpath(\"bluetooth.py\")\n    bluetooth_py_cache = config.path.joinpath(\"bluetooth.py.cache\")\n    bluetooth_py_content = bluetooth_py.read_text()\n\n    if not integrations:\n        if bluetooth_py_cache.exists():\n            bluetooth_py_cache.unlink()\n        return\n\n    bluetooth_py_generated = generate_and_validate(integrations)\n\n    if bluetooth_py_cache.exists():\n        bluetooth_py_cache_content = bluetooth_py_cache.read_text()\n\n        if bluetooth_py_generated == bluetooth_py_cache_content:\n            return\n\n        if bluetooth_py_content == bluetooth_py_cache_content:\n            bluetooth_py.write_text(bluetooth_py_generated)\n            return\n\n    config.add_error(\n        \"bluetooth.py is out of date and needs to be updated. Run `make generate` to fix it.\",\n        fix=fix_bluetooth_py,\n    )\n\n", "CodeBleu_score": 41.76567356065225}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\tresp := &tokenResponse{}\n\te := &base.APIError{}\n\tlogger := d.logger\n\tlogger.Info(\"refreshing token\")\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.Oauth2TokenEndpoint)\n\tif err != nil {\n\t\tlogger.Error(\"failed to refresh token\", zap.Error(err))\n\t\treturn err\n\t}\n\tif res.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"failed to refresh token\", zap.String(\"status\", res.Status()))\n\t\treturn fmt.Errorf(\"failed to refresh token: %s\", res.Status())\n\t}\n\tif e.Status != \"\" {\n\t\tlogger.Error(\"failed to refresh token\", zap.String(\"status\", e.Status))\n\t\treturn fmt.Errorf(\"failed to refresh token: %s\", e.Status)\n\t}\n\tif resp.AccessToken == \"\" {\n\t\tlogger.Error(\"failed to refresh token\", zap.String(\"status\", \"access token is empty\"))\n\t\treturn fmt.Errorf(\"failed to refresh token: access token is empty\")\n\t}\n\tif resp.ExpiresIn == 0 {\n\t\tlogger.Error(\"failed to refresh token\", zap.String(\"status\", \"expires in is 0\"))\n\t\treturn fmt.Errorf(\"failed to refresh token: expires in is 0\")\n\t}\n\td.AccessToken = resp.AccessToken\n\td.ExpiresIn = resp.ExpiresIn\n\td.ExpiresAt = time.Now().Add(time.Duration(d.ExpiresIn) * time.Second)\n\tlogger.Info(\"token refreshed\", zap.String(\"access_token\", d.AccessToken), zap.Int64(\"expires_in\", d", "CodeBleu_score": 58.10038787816928}, {"code": "func (d *Dropbox) refreshToken() error{\n\tvar resp *base.Response\n\tvar e error\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.OAuth2TokenURL)\n\tif e != nil {\n\t\tlogger.Error(e.Error())\n\t\treturn e\n\t}\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(fmt.Sprintf(\"Refresh token failed with status code: %d\", resp.StatusCode()))\n\t\treturn errors.New(fmt.Sprintf(\"Refresh token failed with status code: %d\", resp.StatusCode()))\n\t}\n\tvar data *oauth2.Token\n\tif err := json.Unmarshal(resp.Body(), &data); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn err\n\t}\n\td.AccessToken = data.AccessToken\n\td.RefreshToken = data.RefreshToken\n\td.ExpiresIn = data.Expiry.Sub(time.Now())\n\treturn nil\n}", "CodeBleu_score": 59.73032847108921}, {"code": "func (d *Dropbox) refreshToken() error{\n\tvar resp *http.Response\n\tvar e error\n\tif d.Addition.AccessToken == \"\" {\n\t\treturn fmt.Errorf(\"access token is empty\")\n\t}\n\tif d.Addition.RefreshToken == \"\" {\n\t\treturn fmt.Errorf(\"refresh token is empty\")\n\t}\n\tif d.Addition.AppKey == \"\" {\n\t\treturn fmt.Errorf(\"app key is empty\")\n\t}\n\tif d.Addition.AppSecret == \"\" {\n\t\treturn fmt.Errorf(\"app secret is empty\")\n\t}\n\tresp, e = base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.DropboxOAuthToken)\n\tif e != nil {\n\t\tlogger.Info(\"refresh token error\", zap.Error(e))\n\t\treturn e\n\t}\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Info(\"refresh token error\", zap.String(\"status\", resp.Status()))\n\t\treturn fmt.Errorf(\"refresh token error\")\n\t}\n\td.Addition.AccessToken = resp.String()\n\td.Addition.RefreshToken = resp.String()\n\treturn nil\n}", "CodeBleu_score": 54.34429043372051}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t// TODO: Add support for uploading files.\n\treq := d.client.R().SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\t// TODO: Add support for uploading files.\n\tresp, err := req.Execute(method, url)\n\tif err != nil {\n\t\tif e, ok := err.(*resty.ResponseError); ok {\n\t\t\tif e.StatusCode() == 401 {\n\t\t\t\t// The token has expired; refresh it and retry the request.\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tresp, err = d.request(url, method, callback, resp)\n\t\t\t}\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp.Body(), nil\n}", "CodeBleu_score": 64.81795238061558}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar err error\n\tvar body []byte\n\tfor i := 0; i < 2; i++ {\n\t\tbody, err = d.requestOnce(url, method, callback, resp)\n\t\tif err == nil {\n\t\t\treturn body, nil\n\t\t}\n\t\tif !d.isTokenExpiredError(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\td.refreshToken()\n\t}\n\treturn nil, err\n}", "CodeBleu_score": 27.478357779512457}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\treq := d.RestyClient.R()\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\trespBody, err := req.Execute(method, url)\n\tif err != nil {\n\t\tif resp != nil {\n\t\t\treq.SetError(err)\n\t\t\treq.SetResult(resp)\n\t\t}\n\t\treturn nil, err\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tif req.IsError() {\n\t\tif req.StatusCode() == 401 {\n\t\t\tif err = d.refreshToken(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"%s: %s\", req.Error(), respBody)\n\t}\n\treturn respBody, nil\n}", "CodeBleu_score": 72.84687668955866}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Get the size of the file\n\tsize := stream.GetSize()\n\t// Calculate the chunk size\n\tchunkSize := utils.GetChunkSize(size)\n\t// Create a new request\n\treq, err := d.request(ctx, http.MethodPut, url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Upload the file in chunks\n\tfor finish := int64(0); finish < size; finish += chunkSize {\n\t\t// Check if the context is canceled\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\t// Set the headers and body for the request\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t// Execute the request\n\t\tresp, err := d.doRequest(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Close the response body\n\t\tresp.CloseBody()\n\t\t// Check if the request failed\n\t\tif resp.StatusCode() != http.StatusOK {\n\t\t\treturn utils.ErrFromResponse(resp)\n\t\t}\n\t}\n\t// Complete the upload\n\treturn d.completeUpload(ctx, url)\n}", "CodeBleu_score": 61.76255459415716}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := int64(d.chunkSize)\n\tfor finish := int64(0); finish < stream.GetSize(); finish += chunkSize {\n\t\tif ctx.Err() != nil {\n\t\t\treturn utils.IsCanceled(ctx.Err())\n\t\t}\n\t\t// Set the headers for each chunk.\n\t\treq := d.request(ctx, \"PUT\", url, nil)\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t// Send the chunk and check for errors.\n\t\tif _, err := req.Send(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 53.491944315971985}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := d.chunkSize\n\tvar finish int64\n\tvar err error\n\tfor {\n\t\t// If the context is cancelled, stop the upload.\n\t\tif ctx.Err() != nil {\n\t\t\treturn utils.IsCanceled(ctx.Err())\n\t\t}\n\t\t// Calculate the size of the next chunk.\n\t\tif finish+chunkSize > stream.GetSize() {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\t// Create the request.\n\t\treq := d.request(ctx, http.MethodPatch, url, nil)\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t// Send the request.\n\t\tres, err := req.Send()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// If the response is not a success, return the error.\n\t\tif err := utils.GetErrorFromResponse(res); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// If the upload is complete, stop the upload.\n\t\tif finish+chunkSize >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t\t// Increment the finish variable to the next chunk.\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 62.64548970127862}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\tctx.JSON(\n\t\thttp.StatusOK,\n\t\tcommon_err.GetMsg(\n\t\t\tservice.MyService.Storage().UnmountStorage(\n\t\t\t\tctx.Bind(\n\t\t\t\t\t&service.Storage{},\n\t\t\t\t\tctx.Request().Body,\n\t\t\t\t\tmake([]byte, ctx.Request().ContentLength),\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t)\n\treturn nil\n}", "CodeBleu_score": 11.449721734791533}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tctx.JSON(http.StatusOK, common_err.GetMsg(ctx, \"unmount_storage\", \"success\", \"unmounting storage\", nil))\n\treturn nil\n}", "CodeBleu_score": 6.5534940895327285}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t// Bind the data from the request context to the ctx variable.\n\tctx = ctx.(*context.Context)\n\tvar ctxData ctx.JSON\n\tif err := ctx.Bind(&ctxData); err != nil {\n\t\treturn common_err.GetMsg(ctx, common_err.BadRequest, err.Error())\n\t}\n\n\t// Retrieve the mount point from the ctx variable.\n\tmountPoint := strings.ReplaceAll(ctxData.Data[\"mount_point\"], \"\\\"\", \"\")\n\tif mountPoint == \"\" {\n\t\treturn common_err.GetMsg(ctx, common_err.BadRequest, \"mount point is empty\")\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn common_err.GetMsg(ctx, common_err.ServiceError, err.Error())\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn common_err.GetMsg(ctx, common_err.ServiceError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"status\": \"success\"})\n}", "CodeBleu_score": 37.817941039786106}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Get the file path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\t// Check if the path is provided.\n\tif path == \"\" {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(http.StatusBadRequest, \"Please provide the file path.\"))\n\t}\n\t// Check if the file exists.\n\tif !file.Exists(path) {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(http.StatusNotFound, \"File not found.\"))\n\t}\n\t// Return the file to the client.\n\treturn ctx.File(path)\n}", "CodeBleu_score": 42.43686795722371}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Extract the file path from the query parameters and check if the path is provided.\n\tfilePath := ctx.QueryParam(\"filePath\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing, \"file path is missing\"))\n\t}\n\n\t// Check if the file exists.\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound, \"file not found\"))\n\t}\n\n\t// Return the file to the client.\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 38.29546228587931}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Get the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided.\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\n\t// Check if the file exists.\n\tif !file.Exists(filePath) {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client.\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.78814250136637}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// Return a bad request error with the binding error message.\n\t\treturn common_err.GetMsg(ctx, \"bad_request\", err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\".\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\t// Return an internal server error with the error message.\n\t\treturn common_err.GetMsg(ctx, \"internal_server_error\", err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"message\": \"success\",\n\t})\n}", "CodeBleu_score": 55.50401062654618}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Get the name parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.GetMsg(ctx, common_err.BAD_REQUEST, err.Error())\n\t}\n\n\t// Send the notification.\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn common_err.GetMsg(ctx, common_err.INTERNAL_SERVER_ERROR, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"message\": \"Notification sent.\",\n\t})\n}", "CodeBleu_score": 60.63420425300598}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.BadRequest(err.Error())\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn common_err.InternalServerError(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, make(map[string]string))\n}", "CodeBleu_score": 49.44196299149849}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\t// Add the WebSocket connection to the list of connections.\n\tconnectionsMutex.Lock()\n\tconnections[ws] = true\n\tconnectionsMutex.Unlock()\n\t// Ensure the message sending service is running.\n\tif !sendRunning {\n\t\tgo SendMeg()\n\t\tsendRunning = true\n\t}\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read the next message from the WebSocket connection.\n\t\tmessageType, p, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// Remove the WebSocket connection from the list of connections.\n\t\t\tconnectionsMutex.Lock()\n\t\t\tdelete(connections, ws)\n\t\t\tconnectionsMutex.Unlock()\n\t\t\t// Print the error.\n\t\t\tlog.Println(err)\n\t\t\t// Return the error.\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type and message.\n\t\tlog.Printf(\"Message type: %d\nMessage: %s\n\", messageType, p)\n\t}\n}", "CodeBleu_score": 40.6659507457095}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t// Upgrade the HTTP connection to a WebSocket connection.\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections.\n\tconnections.Store(ws, true)\n\n\t// Start the message sending service.\n\tgo sendMessage()\n\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read the next message from the WebSocket connection.\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Println(string(message))\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tconnections.Delete(ws)\n\n\treturn nil\n}", "CodeBleu_score": 43.03831771681247}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list of connections.\n\tconnectionsMutex.Lock()\n\tconnections[ws] = true\n\tconnectionsMutex.Unlock()\n\n\t// Start the message sending service.\n\tif !messageSendingServiceRunning {\n\t\tgo SendMessages()\n\t\tmessageSendingServiceRunning = true\n\t}\n\n\t// Loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"Message type: %v\nMessage: %s\n\", messageType, message)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tconnectionsMutex.Lock()\n\tdelete(connections, ws)\n\tconnectionsMutex.Unlock()\n\n\treturn nil\n}", "CodeBleu_score": 43.116218130965066}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Create a new system service instance.\n\tservice := service.NewSystem()\n\n\t// Create a new CPU service instance.\n\tcpuService := service.NewCPU()\n\n\t// Get the system hardware information.\n\thardwareInfo, err := service.GetSystemHardwareInfo()\n\tif err != nil {\n\t\treturn common_err.GetMsg(ctx, err)\n\t}\n\n\t// Get the CPU information.\n\tcpuInfo, err := cpuService.GetCpuInfo()\n\tif err != nil {\n\t\treturn common_err.GetMsg(ctx, err)\n\t}\n\n\t// If CPU information is not available, return nil.\n\tif cpuInfo == nil {\n\t\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\t\"status\":  \"success\",\n\t\t\t\"message\": \"No CPU information available.\",\n\t\t\t\"data\":    hardwareInfo,\n\t\t})\n\t}\n\n\t// Return the system hardware information and CPU information.\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"status\":  \"success\",\n\t\t\"message\": \"System hardware information retrieved successfully.\",\n\t\t\"data\":    hardwareInfo,\n\t\t\"cpu\":     cpuInfo,\n\t})\n}", "CodeBleu_score": 23.120534860587615}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get the system hardware information.\n\tsystemHardwareInfo, err := system.GetSystemHardwareInfo()\n\tif err != nil {\n\t\t// Return an error message.\n\t\treturn common_err.GetMsg(ctx, err)\n\t}\n\n\t// Return the system hardware information.\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 10.984096084262049}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get drive model and architecture.\n\tdriveModel, architecture := GetDriveModelAndArchitecture()\n\t// Get CPU information.\n\tcpuInfo := GetCpuInfo()\n\t// Return JSON response.\n\tif cpuInfo == nil {\n\t\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"driveModel\": driveModel,\n\t\t\t\"architecture\": architecture,\n\t\t})\n\t} else {\n\t\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"driveModel\": driveModel,\n\t\t\t\"architecture\": architecture,\n\t\t\t\"cpuInfo\": cpuInfo,\n\t\t})\n\t}\n}", "CodeBleu_score": 18.730425568062824}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 71.32745181505238}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 71.32745181505238}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 70.80174014354898}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), &pb.PublishEventRequest{\n\t\tTopic:   i.config.NotifyTopic,\n\t\tMessage: string(jsonMessage),\n\t\tMetadata: map[string]string{\n\t\t\t\"name\": name,\n\t\t},\n\t})\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish notification\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish notification\",\n\t\t\tzap.String(\"response_status_code\", response.StatusCode.String()),\n\t\t\tzap.String(\"response_status\", response.Status),\n\t\t\tzap.String(\"response_body\", response.Body),\n\t\t)\n\t}\n}", "CodeBleu_score": 40.80357201571863}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// The function \"SendNotify\" sends a notification with a given name and message map.\n\t// It serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\n\t// If the response status code is not OK, it logs the failure along with the response details.\n\t// The function \"SendNotify\" sends a notification with a given name and message map.\n\t// It serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\n\t// If the response status code is not OK, it logs the failure along with the response details.\n\t// The function \"SendNotify\" sends a notification with a given name and message map.\n\t// It serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\n\t// If the response status code is not OK, it logs the failure along with the response details.\n\t// The function \"SendNotify\" sends a notification with a given name and message map.\n\t// It serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\n\t// If the response status code is not OK, it logs the failure along with the response details.\n\t// The function \"SendNotify\" sends a notification with a given name and message map.\n\t// It serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\n\t// If the response status code is not OK, it logs the failure along with the response details.\n\t// The function \"SendNotify\" sends a notification with a given name and message map.\n\t// It serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\n\t// If the response status code is not OK, it logs the failure along with the response details.\n\t// The function \"SendNotify\" sends a notification with a given name and message map.\n\t// It serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\n\t// If the response status code is not OK, it logs the failure along with the response details.", "CodeBleu_score": 2.3824830077938293}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// Marshal the message values to JSON strings.\n\tjsonValues, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.logger.Error(\"failed to marshal message values\", zap.Error(err))\n\t\treturn\n\t}\n\t// Publish the event to the message bus.\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), &pb.PublishEventRequest{\n\t\tName:     name,\n\t\tJsonData: string(jsonValues),\n\t})\n\tif err != nil {\n\t\ti.logger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\t// If the response status code is not OK, log the failure.\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err), zap.String(\"status_code\", response.StatusCode.String()))\n\t\treturn\n\t}\n\t// Log the success.\n\ti.logger.Info(\"successfully published event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.String(\"status_code\", response.StatusCode.String()))\n}", "CodeBleu_score": 41.54685570532306}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Create a new message bus client with responses.\n\tclient := message_bus.NewClientWithResponses()\n\t// Attempt to retrieve the message bus address using a specified runtime path.\n\taddress, err := c.GetMessageBusAddress()\n\t// If the address is found, set the client's server to the retrieved address.\n\tif err == nil {\n\t\tclient.SetServer(address)\n\t} else {\n\t\t// Otherwise, set the server to a default error message.\n\t\tclient.SetServer(\"Message bus address not found.\")\n\t}\n\t// Return the initialized client.\n\treturn client\n}", "CodeBleu_score": 29.309813749723997}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Create a new message bus client with responses.\n\tclient := message_bus.NewClientWithResponses()\n\n\t// Initialize the client.\n\tclient.Initialize()\n\n\t// Attempt to retrieve the message bus address using a specified runtime path.\n\taddress := c.GetMessageBusAddress()\n\n\t// If the address is found, set the client's server to the retrieved address; otherwise, set the server to a default error message.\n\tif address != \"\" {\n\t\tclient.SetServer(address)\n\t} else {\n\t\tclient.SetServer(\"Error: Message bus address not found.\")\n\t}\n\n\t// Return the initialized client.\n\treturn client\n}", "CodeBleu_score": 27.684962424827987}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Initialize a new message bus client with responses.\n\tclient := message_bus.NewClientWithResponses()\n\n\t// Attempt to retrieve the message bus address using a specified runtime path.\n\taddress := c.GetMessageBusAddress()\n\n\t// If the address is found, set the client's server to the retrieved address; otherwise, set the server to a default error message.\n\tif address != \"\" {\n\t\tclient.Server = address\n\t} else {\n\t\tclient.Server = \"http://localhost:8080\"\n\t}\n\n\t// Return the initialized client.\n\treturn client\n}", "CodeBleu_score": 27.721048831333867}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \",\") {\n\t\tip = strings.Split(ip, \",\")[0]\n\t}\n\tif strings.Contains(ip, \"::ffff:\") {\n\t\tip = strings.Replace(ip, \"::ffff:\", \"\", -1)\n\t}\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = strings.Replace(ip, \"::1\", \"127.0.0.1\", -1)\n\t}\n\treturn ip\n}", "CodeBleu_score": 55.074613042515594}, {"code": "func GetIP(request *http.Request) string{\n\t// Get the IP address from the \"x-forwarded-for\" header.\n\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\t// If the \"x-forwarded-for\" header is not present, use the request's remote address.\n\tif forwarded == \"\" {\n\t\tforwarded = request.RemoteAddr\n\t}\n\t// Extract the first IP address from the comma-separated list.\n\tparts := strings.Split(forwarded, \",\")\n\tif len(parts) > 0 {\n\t\tforwarded = strings.TrimSpace(parts[0])\n\t}\n\t// If the IP address is \"::1\" or \"::ffff:127.0.0.1\", return \"127.0.0.1\".\n\tif forwarded == \"::1\" || forwarded == \"::ffff:127.0.0.1\" {\n\t\tforwarded = \"127.0.0.1\"\n\t}\n\treturn forwarded\n}", "CodeBleu_score": 50.19750366871365}, {"code": "func GetIP(request *http.Request) string{\n\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\tif forwarded != \"\" {\n\t\ti := strings.Index(forwarded, \",\")\n\t\tif i == -1 {\n\t\t\ti = len(forwarded)\n\t\t}\n\t\tip := forwarded[:i]\n\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\tip = \"127.0.0.1\"\n\t\t}\n\t\treturn ip\n\t}\n\tip, _, err := net.SplitHostPort(request.RemoteAddr)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.99256847616323}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\tvar entryFilePath = filepath.Join(c.ModulePath, \"entry.json\")\n\tvar moduleDirPath = filepath.Join(c.ModulePath, \"modules\")\n\tvar modules = make([]string, 0)\n\tvar modulesEntry = make([]interface{}, 0)\n\tvar err error\n\tvar moduleEntryFilePath string\n\tvar moduleEntryFileContent []byte\n\tvar moduleEntryFileContentString string\n\tvar moduleEntryFileContentMap map[string]interface{}\n\tvar moduleEntryFileContentArray []interface{}\n\tvar moduleEntryFileContentMapEntry map[string]interface{}\n\tvar moduleEntryFileContentMapEntryName string\n\tvar moduleEntryFileContentMapEntryPath string\n\tvar moduleEntryFileContentMapEntryModule string\n\tvar moduleEntryFileContentMapEntryVersion string\n\tvar moduleEntryFileContentMapEntryDescription string\n\tvar moduleEntryFileContentMapEntryAuthor string\n\tvar moduleEntryFileContentMapEntryLicense string\n\tvar moduleEntryFileContentMapEntryURL string\n\tvar moduleEntryFileContentMapEntryKeywords []string\n\tvar moduleEntryFileContentMapEntryDependencies []string\n\tvar moduleEntryFileContentMapEntryDependenciesMap map[string]interface{}\n\tvar moduleEntryFileContentMapEntryDependenciesMapName string\n\tvar moduleEntryFileContentMapEntryDependenciesMapVersion string\n\tvar moduleEntryFileContentMapEntryDependenciesMapDescription string\n\tvar moduleEntryFileContentMapEntryDependenciesMapAuthor string\n\tvar moduleEntryFileContentMapEntryDependenciesMapLicense string\n\tvar moduleEntryFileContentMapEntryDependenciesMapURL string\n\tvar moduleEntryFileContentMapEntryDependenciesMapKeywords []string\n\tvar moduleEntryFileContentMapEntryDependenciesMapDependencies []string\n\tvar moduleEntryFileContentMapEntryDependenciesMapDependenciesMap map[string]interface{}\n\tvar moduleEntryFileContentMapEntryDependenciesMapDependenciesMapName string\n\tvar moduleEntryFileContentMapEntryDependenciesMapDependenciesMapVersion string\n\tvar moduleEntryFileContentMapEntryDependenciesMapDependenciesMapDescription string\n\tvar moduleEntryFileContentMapEntryDependenciesMapDependenciesMapAuthor string\n\tvar moduleEntryFileContentMapEntryDependenciesMapDependenciesMapLicense string\n\tvar moduleEntryFileContentMapEntryDependenciesMap", "CodeBleu_score": 20.413153424506792}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Declare and initialize the modules directory path and the entry file path.\n\tmodulesDirPath := filepath.Join(c.systemDirPath, \"modules\")\n\tentryFilePath := filepath.Join(c.systemDirPath, \"entry.json\")\n\t// Declare and initialize the system entry JSON array.\n\tvar systemEntryJSONArray []byte\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info slice.\n\tvar modulesDirFileInfoSlice []os.FileInfo\n\t// Declare and initialize the modules directory file info", "CodeBleu_score": 15.182835615342249}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Ensure the modules directory exists.\n\tmodulesDir := filepath.Join(c.systemDir, \"modules\")\n\tif err := file.IsNotExistCreateFile(modulesDir); err != nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n\t// Ensure the entry file exists.\n\tentryFile := filepath.Join(c.systemDir, \"entry.json\")\n\tif err := file.IsNotExistCreateFile(entryFile); err != nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n\t// Read each module directory for entry.json files, concatenate their content into a single JSON array, and write this array to the entry file path.\n\tvar entries []string\n\tif err := filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tlogger.Error(err)\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Ext(path) != \".json\" {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(filepath.Base(path), \".\") {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(filepath.Base(path), \"_\") {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(filepath.Base(path), \"~\") {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(filepath.Base(path), \"entry\") {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(filepath.Base(path), \"entry\") {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(filepath.Base(path), \"entry\") {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(filepath.Base(path), \"entry\") {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(filepath.Base(path), \"entry\") {\n\t\t\treturn nil\n\t\t}", "CodeBleu_score": 34.67097025949503}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := c.GetNetInterfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, name := range names {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddress.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 59.88723387971891}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := c.GetNetInterfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnetworkNames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, interface_ := range interfaces {\n\t\tfor _, networkName := range networkNames {\n\t\t\tif interface_.Name == networkName {\n\t\t\t\treturn interface_.MacAddress, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 63.79723366982803}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tvar macAddress string\n\tvar err error\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnames, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, name := range names {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == name {\n\t\t\t\tmacAddress = iface.HardwareAddr.String()\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif macAddress != \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\tif macAddress == \"\" {\n\t\treturn \"\", errors.New(\"No matching network interface found\")\n\t}\n\treturn macAddress, nil\n}", "CodeBleu_score": 58.729893164364235}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t nRet = 0;\n    if (pRequest == NULL || pTscObj == NULL) {\n        return -1;\n    }\n\n    // add reference to request object\n    nRet = atomic_add_fetch_32(&pRequest->nRefCount, 1);\n    if (nRet < 0) {\n        return -2;\n    }\n\n    // increment request count\n    nRet = atomic_add_fetch_32(&pTscObj->nRequestCount, 1);\n    if (nRet < 0) {\n        return -3;\n    }\n\n    // update application request summary\n    if (pTscObj->pAppInfo != NULL) {\n        nRet = atomic_add_fetch_32(&pTscObj->pAppInfo->nRequestCount, 1);\n        if (nRet < 0) {\n            return -4;\n        }\n\n        nRet = atomic_add_fetch_32(&pTscObj->pAppInfo->nCurrentRequestCount, 1);\n        if (nRet < 0) {\n            return -5;\n        }\n    }\n\n    // log debug information\n    nRet = tscDebug(pTscObj, pRequest, \"registerRequest\");\n    if (nRet < 0) {\n        return -6;\n    }\n\n    return 0;\n}", "CodeBleu_score": 41.810801970053134}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = TSC_ERROR_GENERAL;\n    if (pRequest && pTscObj) {\n        pRequest->pTscObj = pTscObj;\n        pRequest->pAppInfo = pTscObj->pAppInfo;\n        if (pRequest->pAppInfo) {\n            atomic_add_fetch_32(&pRequest->pAppInfo->totalRequestCount, 1);\n            atomic_add_fetch_32(&pRequest->pAppInfo->currentRequestCount, 1);\n        }\n        atomic_add_fetch_32(&pRequest->refCount, 1);\n        atomic_add_fetch_32(&pTscObj->requestCount, 1);\n        if (pTscObj->pAppInfo) {\n            rc = TSC_SUCCESS;\n        } else {\n            rc = TSC_ERROR_NO_APP_INFO;\n        }\n        tscDebug(\"registerRequest: %p %p %d %d\n\", pRequest, pTscObj, pRequest->refCount, pTscObj->requestCount);\n    }\n    return rc;\n}", "CodeBleu_score": 48.768466449068946}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t ret = TA_OK;\n\tint32_t rc = TA_OK;\n\tint32_t rc2 = TA_OK;\n\tint32_t rc3 = TA_OK;\n\tint32_t rc4 = TA_OK;\n\tint32_t rc5 = TA_OK;\n\tint32_t rc6 = TA_OK;\n\tint32_t rc7 = TA_OK;\n\tint32_t rc8 = TA_OK;\n\tint32_t rc9 = TA_OK;\n\tint32_t rc10 = TA_OK;\n\tint32_t rc11 = TA_OK;\n\tint32_t rc12 = TA_OK;\n\tint32_t rc13 = TA_OK;\n\tint32_t rc14 = TA_OK;\n\tint32_t rc15 = TA_OK;\n\tint32_t rc16 = TA_OK;\n\tint32_t rc17 = TA_OK;\n\tint32_t rc18 = TA_OK;\n\tint32_t rc19 = TA_OK;\n\tint32_t rc20 = TA_OK;\n\tint32_t rc21 = TA_OK;\n\tint32_t rc22 = TA_OK;\n\tint32_t rc23 = TA_OK;\n\tint32_t rc24 = TA_OK;\n\tint32_t rc25 = TA_OK;\n\tint32_t rc26 = TA_OK;\n\tint32_t rc27 = TA_OK;\n\tint32_t rc28 = TA_OK;\n\tint32_t rc29 = TA_OK;\n\tint32_t rc30 = TA_OK", "CodeBleu_score": 5.380930331073651}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (pRequest->dbName == NULL) {\n        return false;\n    }\n    if (strcmp(pRequest->dbName, exceptDb) == 0) {\n        return false;\n    }\n    char* dbName = pRequest->dbName;\n    while (*dbName != '\\0') {\n        if (strcmp(dbName, exceptDb) == 0) {\n            return false;\n        }\n        dbName = strchr(dbName, '.');\n        if (dbName == NULL) {\n            break;\n        }\n        dbName++;\n    }\n    return true;\n}", "CodeBleu_score": 51.859631836103546}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tbool result = true;\n    if (pRequest->dbName != NULL && strcmp(pRequest->dbName, exceptDb) == 0) {\n        result = false;\n    } else {\n        ListCell *cell = NULL;\n        foreach (cell, pRequest->dbList) {\n            char *db = (char *) lfirst(cell);\n            if (db != NULL && strcmp(db, exceptDb) == 0) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 38.05310377903141}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tchar *pDb = NULL;\n    char *pDbList = NULL;\n    char *pDbName = NULL;\n\n    pDb = pRequest->pDb;\n    if (pDb == NULL) {\n        return true;\n    }\n\n    if (strcmp(pDb, exceptDb) != 0) {\n        pDbList = pRequest->pDbList;\n        if (pDbList == NULL) {\n            return true;\n        }\n\n        while ((pDbName = strchr(pDbList, '.')) != NULL) {\n            pDbName++;\n            if (strcmp(pDbName, exceptDb) == 0) {\n                return false;\n            }\n            pDbList = pDbName;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 49.41219594291864}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\treturn (code == E_ED_RFP_REDIRECT) && (msgType != T_ED_RFP_REDIRECT_ACK);\n}", "CodeBleu_score": 17.727337205689235}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tif (code == RPC_S_SERVER_UNAVAILABLE || code == RPC_S_CALL_FAILED_DNE || code == RPC_S_CALL_FAILED_OTHER || code == RPC_S_CALL_FAILED_RTIME || code == RPC_S_CALL_FAILED_RTIMEDOUT) {\n\t\tif (msgType != TMSG_REDIRECT_RPC_SERVER_UNAVAILABLE && msgType != TMSG_REDIRECT_RPC_CALL_FAILED_DNE && msgType != TMSG_REDIRECT_RPC_CALL_FAILED_OTHER && msgType != TMSG_REDIRECT_RPC_CALL_FAILED_RTIME && msgType != TMSG_REDIRECT_RPC_CALL_FAILED_RTIMEDOUT) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 39.66700595022562}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\treturn (code == ED_REDIRECT_ERROR && msgType != MSG_TYPE_RPC_RESPONSE && msgType != MSG_TYPE_RPC_REDIRECT_RESPONSE);\n}", "CodeBleu_score": 20.311874751853523}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\tSHashIter iter;\n    int64_t rid;\n    TAOS_DB_REQUEST *request;\n\n    if (pRequests == NULL) {\n        return;\n    }\n    if (SHashFirst(pRequests, &iter) == 0) {\n        do {\n            rid = iter.hash_key;\n            request = (TAOS_DB_REQUEST *) SHASH_FIND(pRequests, &rid);\n            if (request != NULL) {\n                if (request->query != NULL) {\n                    taos_stop_query(request->query);\n                }\n                releaseRequest(rid);\n            }\n        } while (SHashNext(&iter) != 0);\n    }\n}", "CodeBleu_score": 32.38361133086608}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tint64_t rid;\n    int32_t rc;\n    int32_t i;\n    int32_t count = 0;\n    int32_t max_count = 100;\n    int32_t *rids = (int32_t *)malloc(sizeof(int32_t) * max_count);\n\n    if (rids == NULL) {\n        TAOS_ERR(\"[stopAllRequests] malloc error\n\");\n        return;\n    }\n\n    while ((i = taosHashIterate(pRequests, &rid)) != -1) {\n        if (count >= max_count) {\n            taos_stop_query(rids, count);\n            taosReleaseRef(clientReqRefPool, rids, count);\n            count = 0;\n        }\n\n        rids[count++] = rid;\n    }\n\n    if (count > 0) {\n        taos_stop_query(rids, count);\n        taosReleaseRef(clientReqRefPool, rids, count);\n    }\n\n    free(rids);\n}", "CodeBleu_score": 39.03305362257179}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tint64_t rid;\n    void *value;\n    int32_t ret;\n    while ((ret = sHashIterate(pRequests, &rid, &value)) == 0) {\n        taos_stop_query(rid);\n        releaseRequest(rid);\n    }\n}", "CodeBleu_score": 35.903444395732684}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\tif (tscCrashReportingEnabled) {\n    if (atomic_compare_exchange_strong_32(&tscCrashReportThreadClientStop, &clientStop, 1)) {\n      while (atomic_load_32(&tscCrashReportThreadClientStop) != 0) {\n        tscMsleep(50);\n      }\n    } else {\n      tscLogMessage(LOG_WARNING, \"Crash report thread already stopped.\");\n    }\n  }\n}", "CodeBleu_score": 52.925674045152206}, {"code": "void tscStopCrashReport(){\n\tif (!tscCrashReportingEnabled) {\n        return;\n    }\n    if (atomic_val_compare_exchange_32(&clientStop, 0, 1) == 0) {\n        return;\n    }\n    while (atomic_load_32(&clientStop) == 1) {\n        tscMsleep(1000);\n    }\n}", "CodeBleu_score": 69.06900393828873}, {"code": "void tscStopCrashReport(){\n\tif (!tscIsCrashReportEnabled()) {\n\t\treturn;\n\t}\n\tif (!atomic_val_compare_exchange_32(&clientStop, 0, 1)) {\n\t\tLOG_DEBUG(\"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\twhile (atomic_load_32(&clientStop) == 1) {\n\t\tusleep(1000);\n\t}\n}", "CodeBleu_score": 73.01295195232261}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t l = 0;\n\tint32_t m = 0;\n\tint32_t n = 0;\n\tint32_t o = 0;\n\tint32_t p = 0;\n\tint32_t q = 0;\n\tint32_t r = 0;\n\tint32_t s = 0;\n\tint32_t t = 0;\n\tint32_t u = 0;\n\tint32_t v = 0;\n\tint32_t w = 0;\n\tint32_t x = 0;\n\tint32_t y = 0;\n\tint32_t z = 0;\n\tint32_t a = 0;\n\tint32_t b = 0;\n\tint32_t c = 0;\n\tint32_t d = 0;\n\tint32_t e = 0;\n\tint32_t f = 0;\n\tint32_t g = 0;\n\tint32_t h = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t l = 0;\n\tint32_t m = 0;\n\tint32_t n = 0;\n\tint32_t o = 0;\n\tint32_t p = 0;\n\tint32_t q = 0;\n\tint32_t r = 0;\n\tint32_t s = 0;\n\tint32_t t = 0;\n\tint32_t u = 0;\n\tint32_t v = 0;\n\tint32_t w = 0;\n\tint32_t x = 0;\n\tint32_t y =", "CodeBleu_score": 8.09030811523925}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t ret;\n\tint32_t i;\n\tint32_t j;\n\tint32_t numViews;\n\tint32_t numCols;\n\tint32_t numColsOld;\n\tint32_t numColsNew;\n\tint32_t numColsRemoved;\n\tint32_t numColsAdded;\n\tint32_t numColsUpdated;\n\tint32_t numColsUpdatedOld;\n\tint32_t numColsUpdatedNew;\n\tint32_t numColsUpdatedRemoved;\n\tint32_t numColsUpdatedAdded;\n\tint32_t numColsUpdatedUpdated;\n\tint32_t numColsUpdatedUpdatedOld;\n\tint32_t numColsUpdatedUpdatedNew;\n\tint32_t numColsUpdatedUpdatedRemoved;\n\tint32_t numColsUpdatedUpdatedAdded;\n\tint32_t numColsUpdatedUpdatedUpdated;\n\tint32_t numColsUpdatedUpdatedUpdatedOld;\n\tint32_t numColsUpdatedUpdatedUpdatedNew;\n\tint32_t numColsUpdatedUpdatedUpdatedRemoved;\n\tint32_t numColsUpdatedUpdatedUpdatedAdded;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdated;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedOld;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedNew;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedRemoved;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedAdded;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedUpdated;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedUpdatedOld;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedUpdatedNew;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedUpdatedRemoved;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedUpdatedAdded;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedUpdatedUpdated;\n\tint32_t numColsUpdatedUpdatedUpdatedUpdatedUpdatedUpdatedOld;", "CodeBleu_score": 6.104925835067624}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t numViews = 0;\n\tint32_t numCols = 0;\n\tint32_t numColsPrev = 0;\n\tint32_t numColsNew = 0;\n\tint32_t numColsTotal = 0;\n\tint32_t numColsRemoved = 0;\n\tint32_t numColsAdded = 0;\n\tint32_t numColsUpdated = 0;\n\tint32_t numColsUnchanged = 0;\n\tint32_t numColsTotalPrev = 0;\n\tint32_t numColsTotalNew = 0;\n\tint32_t numColsTotalUpdated = 0;\n\tint32_t numColsTotalUnchanged = 0;\n\tint32_t numColsTotalTotal = 0;\n\tint32_t numColsTotalRemoved = 0;\n\tint32_t numColsTotalAdded = 0;\n\tint32_t numColsTotalTotalPrev = 0;\n\tint32_t numColsTotalTotalNew = 0;\n\tint32_t numColsTotalTotalUpdated = 0;\n\tint32_t numColsTotalTotalUnchanged = 0;\n\tint32_t numColsTotalTotalTotal = 0;\n\tint32_t numColsTotalTotalRemoved = 0;\n\tint32_t numColsTotalTotalAdded = 0;\n\tint32_t numColsTotalTotalTotalPrev = 0;\n\tint32_t numColsTotalTotalTotalNew = 0;\n\tint32_t numColsTotalTotalTotalUpdated = 0;\n\tint32_t numColsTotalTotalTotalUnchanged = 0;\n\tint32_t numColsTotalTotalTotalTotal = 0;\n\tint32_t numCols", "CodeBleu_score": 8.669275134248036}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status = S3StatusOK;\n    CallbackData *data = (CallbackData *) callbackData;\n\n    if (properties != NULL) {\n        if (properties->contentLength > 0) {\n            data->contentLength = properties->contentLength;\n        } else {\n            data->contentLength = 0;\n        }\n    } else {\n        status = S3StatusInternalError;\n    }\n\n    return status;\n}", "CodeBleu_score": 67.48304652794045}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3PutObjectHandlerData *handlerData = (S3PutObjectHandlerData *) callbackData;\n\n    /* Check for valid parameters */\n    if (properties == NULL) {\n        return S3StatusInvalidParameter;\n    }\n\n    /* Check for valid callback data */\n    if (handlerData == NULL) {\n        return S3StatusInvalidParameter;\n    }\n\n    /* Extract the content length */\n    if (properties->contentLength > 0) {\n        handlerData->contentLength = properties->contentLength;\n    }\n\n    /* Return success */\n    return S3StatusOK;\n}", "CodeBleu_score": 59.795954990777474}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3PutObjectHandlerData *handlerData = (S3PutObjectHandlerData *)callbackData;\n    if (properties->contentLength > 0) {\n        handlerData->contentLength = properties->contentLength;\n    } else {\n        handlerData->contentLength = 0;\n    }\n    return S3StatusOK;\n}", "CodeBleu_score": 74.32973255427517}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync\");\n\n  if (taosMulMkDir(tsCheckpointBackupDir, 0755) != 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%s/rsync.conf\", tsCheckpointBackupDir);\n\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%s\", confDir);\n  uDebug(\"[rsync] start rsync cmd:%s\", cmd);\n\n  if (system(cmd) == -1) {\n    uError(\"[rsync] start rsync error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  uDebug(\"[rsync] start rsync success\");\n}", "CodeBleu_score": 64.85847125439955}, {"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync\");\n\n  if (taosMulMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create dir error, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n#ifdef WINDOWS\n  snprintf(cmd, PATH_MAX, \"\\\"%s\\\" -p %d -c %srsync.conf\", tsRsyncPath, tsRsyncPort, tsCheckpointBackupDir);\n#else\n  snprintf(cmd, PATH_MAX, \"%s -p %d -c %srsync.conf\", tsRsyncPath, tsRsyncPort, tsCheckpointBackupDir);\n#endif\n  uDebug(\"[rsync] cmd:%s\", cmd);\n\n  int32_t ret = system(cmd);\n  if (ret == 0) {\n    uDebug(\"[rsync] rsync start success\");\n  } else {\n    uError(\"[rsync] rsync start error, cmd:%s, ret:%d\", cmd, ret);\n  }\n}", "CodeBleu_score": 57.36048685776522}, {"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync\");\n  if (taosMulMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n#ifdef WINDOWS\n  char confFile[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, confFile);\n  snprintf(confFile, PATH_MAX, \"%srsync.conf\", confFile);\n#else\n  char confFile[PATH_MAX] = {0};\n  snprintf(confFile, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n#endif\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%s\", confFile);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start rsync error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync success\");\n  }\n}", "CodeBleu_score": 65.4496365536769}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 81.32220759106568}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n\t\tif (dispatcher == null) {\n\t\t\tthrow new RuntimeException(\"The dispatcher with the specified ID is not registered.\");\n\t\t}\n\t\tdispatcher.shutdownNow();\n\t}", "CodeBleu_score": 52.90639235569604}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdownNow();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 68.8025067165076}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId[] children = childrenMap.get(parent);\n        if (children != null) {\n            for (TbActorId child : children) {\n                if (childFilter.test(child)) {\n                    if (highPriority) {\n                        tell(child, msg, true);\n                    } else {\n                        tell(child, msg);\n                    }\n                }\n            }\n        }\n    }", "CodeBleu_score": 50.5821858250029}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId[] children = childrenMap.get(parent);\n        if (children != null) {\n            for (TbActorId child : children) {\n                if (childFilter.test(child)) {\n                    tell(child, msg, highPriority);\n                }\n            }\n        }\n    }", "CodeBleu_score": 53.93609769556426}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tif (parent != null) {\n            Map<TbActorId, TbActorRef> children = childActors.get(parent);\n            if (children != null) {\n                for (TbActorRef child : children.values()) {\n                    if (childFilter.test(child.getActorId())) {\n                        child.tell(msg, highPriority);\n                    }\n                }\n            }\n        }\n    }", "CodeBleu_score": 51.61177361213946}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroying.get() == NOT_DESTROYING) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(false);\n        } else {\n            if (msg.getMsgType() == TbActorMsg.RULE_NODE_UPDATED_MSG) {\n                TbActorMsg ruleNodeUpdatedMsg = (TbActorMsg) msg;\n                if (ruleNodeUpdatedMsg.getEntityId().equals(selfId)) {\n                    if (destroying.get() == DESTROYING) {\n                        tryInit(0);\n                    } else {\n                        log.trace(\"[{}] Actor is destroying, msg: {}\", selfId, msg);\n                    }\n                } else {\n                    log.trace(\"[{}] Actor is destroying, msg: {}\", selfId, msg);\n                }\n            } else {\n                msg.onActorStopped();\n            }\n        }\n    }", "CodeBleu_score": 57.41982418487193}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroying.get() == NOT_DESTROYING) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(false);\n        } else {\n            if (msg instanceof TbActorMsgWrapper) {\n                TbActorMsgWrapper wrapper = (TbActorMsgWrapper) msg;\n                if (wrapper.getMsg() instanceof RuleNodeToRuleChainTbQueueMsg) {\n                    RuleNodeToRuleChainTbQueueMsg ruleNodeToRuleChainTbQueueMsg = (RuleNodeToRuleChainTbQueueMsg) wrapper.getMsg();\n                    if (ruleNodeToRuleChainTbQueueMsg.getMsg() instanceof RuleNodeUpdatedMsg) {\n                        RuleNodeUpdatedMsg ruleNodeUpdatedMsg = (RuleNodeUpdatedMsg) ruleNodeToRuleChainTbQueueMsg.getMsg();\n                        if (ruleNodeUpdatedMsg.getRuleNodeId().equals(selfId)) {\n                            if (highPriority) {\n                                tryInit(2);\n                            } else {\n                                log.debug(\"[{}] Failed to process msg: {}\", selfId, msg);\n                                msg.onFailure(new RuntimeException(\"Actor is being destroyed\"));\n                            }\n                        }\n                    }\n                }\n            }\n            msg.onFailure(new RuntimeException(\"Actor is being destroyed\"));\n        }\n    }", "CodeBleu_score": 52.63285805725402}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroy.get() == NOT_DESTROYED) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(false);\n        } else if (msg instanceof RuleNodeToRuleChainTbActorMsg) {\n            RuleNodeToRuleChainTbActorMsg ruleNodeToRuleChainTbActorMsg = (RuleNodeToRuleChainTbActorMsg) msg;\n            if (ruleNodeToRuleChainTbActorMsg.getMsgType() == RuleNodeToRuleChainTbActorMsg.RULE_NODE_UPDATED_MSG) {\n                if (destroy.get() == DESTROYING) {\n                    if (init.compareAndSet(NOT_INITIALIZED, INITIALIZING)) {\n                        tryInit(1);\n                    } else {\n                        log.trace(\"[{}] MessageBox is not ready, new msg: {}\", selfId, msg);\n                    }\n                } else {\n                    log.trace(\"[{}] MessageBox is not ready, new msg: {}\", selfId, msg);\n                }\n            } else {\n                log.trace(\"[{}] MessageBox is not ready, new msg: {}\", selfId, msg);\n            }\n        } else {\n            log.trace(\"[{}] MessageBox is not ready, new msg: {}\", selfId, msg);\n        }\n    }", "CodeBleu_score": 52.70656409192793}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\tif (destroyInProgress.get()) {\n            return;\n        }\n        if (ready.get() == READY) {\n            int throughput = actor.getActorThroughput();\n            int msgCount = highPriorityMsgs.size() + normalPriorityMsgs.size();\n            if (msgCount > 0) {\n                log.trace(\"[{}] Processing mailbox, throughput: {}, msgCount: {}\", selfId, throughput, msgCount);\n            }\n            int processed = 0;\n            while (processed < throughput) {\n                if (!highPriorityMsgs.isEmpty()) {\n                    TbActorMsg msg = highPriorityMsgs.poll();\n                    if (msg != null) {\n                        try {\n                            actor.process(msg);\n                            processed++;\n                        } catch (Throwable t) {\n                            log.warn(\"[{}] Failed to process high priority message: {}\", selfId, msg, t);\n                            onProcessFailure(msg, t);\n                        }\n                    }\n                }\n                if (!normalPriorityMsgs.isEmpty()) {\n                    TbActorMsg msg = normalPriorityMsgs.poll();\n                    if (msg != null) {\n                        try {\n                            actor.process(msg);\n                            processed++;\n                        } catch (Throwable t) {\n                            log.warn(\"[{}] Failed to process normal priority message: {}\", selfId, msg, t);\n                            onProcessFailure(msg, t);\n                        }\n                    }\n                }\n                if (processed == throughput) {\n                    break;\n                }\n            }\n            if (processed == 0) {\n                busy.set(FREE);\n                if (!highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty()) {\n                    dispatcher.getExecutor().execute(this::processMailbox);\n                }\n            } else {\n                busy.set(READY);\n                if (msgCount > 0) {\n                    log.trace(\"[{}] Mailbox processed: {}\", selfId, msgCount);", "CodeBleu_score": 43.18367734486011}, {"code": "private void processMailbox(){\n\ttry {\n            long startTime = System.currentTimeMillis();\n            int processed = 0;\n            while (processed < throughput) {\n                if (highPriorityMsgs.isEmpty()) {\n                    break;\n                }\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                    processed++;\n                } catch (Throwable e) {\n                    log.error(\"[{}] Failed to process message: {}\", selfId, msg, e);\n                    msg.onTbActorFailed(e);\n                }\n            }\n            while (processed < throughput) {\n                if (normalPriorityMsgs.isEmpty()) {\n                    break;\n                }\n                TbActorMsg msg = normalPriorityMsgs.poll();\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                    processed++;\n                } catch (Throwable e) {\n                    log.error(\"[{}] Failed to process message: {}\", selfId, msg, e);\n                    msg.onTbActorFailed(e);\n                }\n            }\n            long endTime = System.currentTimeMillis();\n            long elapsed = endTime - startTime;\n            if (elapsed < 10) {\n                Thread.sleep(10 - elapsed);\n            }\n        } catch (Throwable e) {\n            log.error(\"[{}] Failed to process mailbox: {}\", selfId, e);\n            destroy(e);\n        } finally {\n            busy.set(FREE);\n            tryProcessQueue(false);\n        }\n    }", "CodeBleu_score": 41.39633843075923}, {"code": "private void processMailbox(){\n\ttry {\n            while (true) {\n                if (busy.compareAndSet(BUSY, FREE)) {\n                    break;\n                }\n            }\n            int processed = 0;\n            while (processed < actorThroughput) {\n                if (highPriorityMsgs.isEmpty()) {\n                    if (normalPriorityMsgs.isEmpty()) {\n                        break;\n                    } else {\n                        processNormalPriorityMessages();\n                    }\n                } else {\n                    processHighPriorityMessages();\n                }\n                processed++;\n            }\n        } catch (Throwable th) {\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, th);\n        } finally {\n            tryProcessQueue(false);\n        }\n    }", "CodeBleu_score": 25.384899762094783}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    if (rateLimit.isEnabled()) {\n        RateLimitCounter counter = getRateLimitCounter(api, tenantId, level);\n        if (counter == null) {\n            return true;\n        }\n        long now = System.currentTimeMillis();\n        long startOfPeriod = now - (now % rateLimit.getPeriod());\n        long currentPeriodStart = counter.getPeriodStart();\n        if (startOfPeriod != currentPeriodStart) {\n            counter.setPeriodStart(startOfPeriod);\n            counter.setCount(0);\n        }\n        long count = counter.getCount();\n        if (count >= rateLimit.getMaxCount()) {\n            if (rateLimit.isNotifyByEmail()) {\n                processRateLimitNotification(tenantId, api, rateLimit, count);\n            }\n            return false;\n        } else {\n            counter.setCount(count + 1);\n        }\n    }\n    return true;\n}", "CodeBleu_score": 47.1137768857673}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    ApiLimitConfiguration limit = profile.getApiLimitConfiguration();\n    if (limit == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimit = limit.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    long currentTime = System.currentTimeMillis();\n    long timeWindow = rateLimit.getTimeWindow();\n    long limitPerTimeWindow = rateLimit.getLimitPerTimeWindow();\n    long limitPerMinute = limitPerTimeWindow / 60;\n    long limitPerHour = limitPerMinute / 60;\n    long limitPerDay = limitPerHour / 24;\n    long limitPerMonth = limitPerDay / 30;\n    long limitPerYear = limitPerMonth / 12;\n    long limitPerLifetime = limitPerYear / 365;\n    long limitPerLevel = limitPerLifetime / 100;\n    long limitPerEntity = limitPerLevel / 100;\n    long limitPerTenant = limitPerEntity / 100;\n    long limitPerApi = limitPerTenant / 100;\n    long limitPerApiLevel = limitPerApi / 100;\n    long limitPerApiLevelEntity = limitPerApiLevel / 100;\n    long limitPerApiLevelEntityName = limitPerApiLevelEntity / 100;\n    long limitPerApiLevelEntityNameLevel = limitPerApiLevelEntityName / 100;\n    long limitPerApiLevelEntityNameLevelMap = limitPerApiLevelEntityNameLevel / 100;\n    long limitPerApiLevelEntityNameLevelMapBuilder = limitPerApiLevelEntityNameLevelMap / 100;\n    long limitPerApiLevelEntityNameLevelMapBuilderGet = limitPerApiLevelEntityNameLevelMapBuilder / 100;\n    long limitPerApiLevelEntityNameLevelMapBuilderGetProfileConfiguration =", "CodeBleu_score": 38.12804488875698}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId);\n    if (profile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfiguration configuration = profile.getRateLimitConfiguration();\n    if (configuration == null) {\n        return true;\n    }\n    RateLimit rateLimit = configuration.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitExceededException exception = rateLimit.checkAndIncrement(level);\n    if (exception != null) {\n        if (exception.getType() == RateLimitExceededException.Type.PER_TENANT) {\n            log.info(\"[{}] Rate limit of [{}] exceeded for tenant: {}\", api, rateLimit, tenantId);\n        } else {\n            log.info(\"[{}] Rate limit of [{}] exceeded for tenant: {}\", api, rateLimit, tenantId);\n        }\n        if (exception.getType() == RateLimitExceededException.Type.GLOBAL) {\n            log.info(\"[{}] Rate limit of [{}] exceeded for tenant: {}\", api, rateLimit, tenantId);\n        } else {\n            log.info(\"[{}] Rate limit of [{}] exceeded for tenant: {}\", api, rateLimit, tenantId);\n        }\n        if (exception.getType() == RateLimitExceededException.Type.SYSTEM) {\n            log.info(\"[{}] Rate limit of [{}] exceeded for tenant: {}\", api, rateLimit, tenantId);\n        } else {\n            log.info(\"[{}] Rate limit of [{}] exceeded for tenant: {}\", api, rateLimit, tenantId);\n        }\n        if (exception.getType() == RateLimitExceededException.Type.TENANT) {\n            log.info(\"[{}] Rate limit of [{}] exceeded for", "CodeBleu_score": 49.67901518896693}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\n    long expirationTime = currentTime - getInactivityTimeout();\n    for (Map.Entry<String, DTLSServerSession> entry : getEntrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            getLogger().trace(\"Removing inactive DTLS session for {}\", entry.getKey());\n            remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 43.48620646065781}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSConnection> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            logger.trace(\"Removing DTLS session with key {}\", entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 55.311308332892494}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = currentTimeMillis() - getInactivityTimeout();\n\tfor (Map.Entry<String, DTLSConnection> entry : entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tString key = entry.getKey();\n\t\t\tDTLSConnection dtlsConnection = entry.getValue();\n\t\t\tremoveIf(dtlsConnection);\n\t\t\ttrace(\"Removed inactive DTLS session for \" + key + \" with last activity time \" + dtlsConnection.getLastActivityTime());\n\t\t}\n\t}\n}", "CodeBleu_score": 43.944396993086684}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        } else {\n            List<TsKvEntry> tsKvEntries = new ArrayList<>(timeseries.size());\n            timeseries.forEach((key, value) -> {\n                if (value.isEmpty()) {\n                    tsKvEntries.add(new BasicTsKvEntry(0L, new BooleanDataEntry(key, false)));\n                } else {\n                    value.forEach(node -> tsKvEntries.add(new BasicTsKvEntry(0L, parseValue(key, node))));\n                }\n            });\n            return tsKvEntries;\n        }\n    }", "CodeBleu_score": 44.02709002173981}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        } else {\n            List<TsKvEntry> result = new ArrayList<>(timeseries.size());\n            timeseries.forEach((key, value) -> {\n                if (value.isEmpty()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, \"\")));\n                } else {\n                    for (JsonNode node : value) {\n                        result.add(parseTsValue(key, node));\n                    }\n                }\n            });\n            return result;\n        }\n    }", "CodeBleu_score": 45.69045270159553}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        } else {\n            List<TsKvEntry> tsKvEntries = new ArrayList<>(timeseries.size());\n            for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n                String key = entry.getKey();\n                List<JsonNode> values = entry.getValue();\n                for (JsonNode value : values) {\n                    tsKvEntries.add(parseTsValue(key, value));\n                }\n            }\n\n            return tsKvEntries;\n        }\n    }", "CodeBleu_score": 43.34388173394682}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", refreshToken);\n        try {\n            HttpEntity<Map<String, String>> request = new HttpEntity<>(requestMap);\n            ResponseEntity<JsonNode> response = restTemplate.postForEntity(authEndpoint, request, JsonNode.class);\n            long ts = currentTimeMillis();\n            setTokenInfo(ts, response.getBody());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }", "CodeBleu_score": 54.06420379660675}, {"code": "public void refreshToken(){\n\tlong ts = currentTimeMillis();\n        String url = \"https://accounts.spotify.com/api/token\";\n        Map<String, String> request = new HashMap<>();\n        request.put(\"grant_type\", \"refresh_token\");\n        request.put(\"refresh_token\", this.refreshToken);\n        request.put(\"client_id\", this.clientId);\n        request.put(\"client_secret\", this.clientSecret);\n\n        try {\n            ResponseEntity<JsonNode> response = postForEntity(url, request);\n            setTokenInfo(ts, response.getBody());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "CodeBleu_score": 42.51352233316886}, {"code": "public void refreshToken(){\n\ttry {\n            long ts = currentTimeMillis();\n            Map<String, String> request = new HashMap<>();\n            request.put(\"refreshToken\", refreshToken);\n            request.put(\"grantType\", \"refresh_token\");\n            request.put(\"clientId\", clientId);\n            request.put(\"clientSecret\", clientSecret);\n            HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(request);\n            ResponseEntity<String> response = restTemplate.postForEntity(authEndpoint, requestEntity, String.class);\n            setTokenInfo(ts, mapper.readTree(response.getBody()));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "CodeBleu_score": 43.898227074429826}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\tlong ts = currentTimeMillis();\n        Map<String, String> loginReq = new HashMap<>();\n        loginReq.put(\"username\", username);\n        loginReq.put(\"password\", password);\n        loginReq.put(\"grant_type\", \"password\");\n        loginReq.put(\"client_id\", \"android\");\n        loginReq.put(\"scope\", \"read write\");\n        loginReq.put(\"client_secret\", \"android\");\n        try {\n            ResponseEntity<String> response = restTemplate.postForEntity(LOGIN_URL, loginReq, String.class);\n            JsonNode tokenInfo = mapper.readTree(response.getBody());\n            setTokenInfo(ts, tokenInfo);\n        } catch (Exception e) {\n            System.out.println(\"Error while logging in: \" + e.getMessage());\n        }\n    }", "CodeBleu_score": 49.67950013308739}, {"code": " private void doLogin(){\n\tlong ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        ResponseEntity<JsonNode> response = postForEntity(this.baseUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 63.66945278129381}, {"code": " private void doLogin(){\n\tlong ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        loginRequest.put(\"grant_type\", \"password\");\n        loginRequest.put(\"client_id\", \"android\");\n        loginRequest.put(\"client_secret\", \"android\");\n        loginRequest.put(\"scope\", \"openid\");\n        loginRequest.put(\"device_id\", \"android\");\n        loginRequest.put(\"device_name\", \"android\");\n        loginRequest.put(\"device_type\", \"android\");\n        loginRequest.put(\"device_token\", \"android\");\n        loginRequest.put(\"device_os_version\", \"android\");\n        loginRequest.put(\"device_os\", \"android\");\n        loginRequest.put(\"device_app_version\", \"android\");\n        loginRequest.put(\"device_app_build_number\", \"android\");\n        loginRequest.put(\"device_app_package_name\", \"android\");\n        loginRequest.put(\"device_app_name\", \"android\");\n        loginRequest.put(\"device_app_build_type\", \"android\");\n        loginRequest.put(\"device_app_flavor\", \"android\");\n        loginRequest.put(\"device_app_mode\", \"android\");\n        loginRequest.put(\"device_app_environment\", \"android\");\n        loginRequest.put(\"device_app_build_environment\", \"android\");\n        loginRequest.put(\"device_app_build_flavor\", \"android\");\n        loginRequest.put(\"device_app_build_type\", \"android\");\n        loginRequest.put(\"device_app_build_number\", \"android\");\n        loginRequest.put(\"device_app_package_name\", \"android\");\n        loginRequest.put(\"device_app_name\", \"android\");\n        loginRequest.put(\"device_app_version\", \"android\");\n        loginRequest.put(\"device_os_version\", \"android\");\n        loginRequest.put(\"device_os\", \"android\");\n        loginRequest.put(\"device_token\", \"android\");\n        loginRequest.put(\"device_name\", \"android\");\n        login", "CodeBleu_score": 29.3269635200961}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.ofNullable(restTemplate.getForEntity(\n                String.format(DEVICE_REST_API_URL, deviceId.getId()), Device.class).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 48.71602045089657}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\tString url = String.format(\"%s/api/device/%s\", baseUrl, deviceId.getId());\n    HttpRequest request = HttpRequest.newBuilder(URI.create(url)).GET().build();\n    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n    if (response.statusCode() == 200) {\n        return Optional.of(new Device(deviceId, response.body()));\n    } else if (response.statusCode() == 404) {\n        return Optional.empty();\n    } else {\n        throw new RuntimeException(\"HTTP error \" + response.statusCode());\n    }\n}", "CodeBleu_score": 48.20965360908252}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.ofNullable(this.restTemplate.getForEntity(this.url + \"/api/device/\" + deviceId.getId(), Device.class).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 49.15573216242998}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException.NotFoundException e) {\n        return Optional.empty();\n    } catch (Exception e) {\n        throw e;\n    }\n}", "CodeBleu_score": 53.70169118489496}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n        if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        return Optional.of(response.getBody());\n    } catch (RestClientException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 58.24008597124759}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n    if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n        return Optional.empty();\n    }\n    return Optional.of(response.getBody());\n}", "CodeBleu_score": 50.99190308571586}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n        target[method] = (duration, callback) => {\n            let signals = [];\n            this.each(element => {\n                signals.push(element[method](duration, callback));\n            });\n            Promise.all(signals).then(() => {\n                if (callback) {\n                    callback();\n                }\n            });\n        };\n    });\n}", "CodeBleu_score": 30.213716856547762}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tfor (let method of methods) {\n    target[method] = function(duration, callback) {\n      if (typeof duration !== 'number') {\n        callback = duration;\n        duration = 1000;\n      }\n      if (typeof callback !== 'function') {\n        throw new TypeError('Callback must be a function');\n      }\n      let signals = [];\n      for (let i = 0; i < this.length; i++) {\n        let signal = this[i][method](duration);\n        signals.push(signal);\n      }\n      return Promise.all(signals).then(callback);\n    }\n  }\n}", "CodeBleu_score": 54.356588998329336}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n        target[method] = function(duration, callback) {\n            if (!callback) {\n                callback = duration;\n                duration = 1000;\n            }\n            callback = callback || function() {};\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback must be a function');\n            }\n            this.forEach(element => {\n                element[method](duration);\n            });\n            return Promise.all(this.map(element => element[method]())).then(callback);\n        };\n    });\n}", "CodeBleu_score": 42.74591760832919}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.07023430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.07023430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.07023430593136}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *cfg = dev->config;\n\tuint32_t buffer_size = sequence->buffer_size;\n\tuint8_t num_of_channels = sequence->channels->mask_array[0];\n\tuint8_t num_of_active_channels = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < num_of_channels; i++) {\n\t\tif (sequence->channels->mask_array[i + 1]) {\n\t\t\tnum_of_active_channels++;\n\t\t}\n\t}\n\n\tif (num_of_active_channels == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tbuffer_size = num_of_active_channels * sequence->resolution;\n\n\tif (buffer_size > cfg->buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size is insufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.744868489393134}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tint ret = 0;\n\tint num_channels = 0;\n\tuint8_t channel_mask = 0;\n\tuint8_t channel_mask_temp = 0;\n\tuint8_t channel_mask_temp_2 = 0;\n\tuint8_t channel_mask_temp_3 = 0;\n\tuint8_t channel_mask_temp_4 = 0;\n\tuint8_t channel_mask_temp_5 = 0;\n\tuint8_t channel_mask_temp_6 = 0;\n\tuint8_t channel_mask_temp_7 = 0;\n\tuint8_t channel_mask_temp_8 = 0;\n\tuint8_t channel_mask_temp_9 = 0;\n\tuint8_t channel_mask_temp_10 = 0;\n\tuint8_t channel_mask_temp_11 = 0;\n\tuint8_t channel_mask_temp_12 = 0;\n\tuint8_t channel_mask_temp_13 = 0;\n\tuint8_t channel_mask_temp_14 = 0;\n\tuint8_t channel_mask_temp_15 = 0;\n\tuint8_t channel_mask_temp_16 = 0;\n\tuint8_t channel_mask_temp_17 = 0;\n\tuint8_t channel_mask_temp_18 = 0;\n\tuint8_t channel_mask_temp_19 = 0;\n\tuint8_t channel_mask_temp_20 = 0;\n\tuint8_t channel_mask_temp_21 = 0;\n\tuint8_t channel_mask_temp_22 = 0;\n\tuint8_t channel_mask_temp_23 = 0;\n\tuint8_t channel_mask_temp_24 = 0;\n\tuint8_t channel_mask_temp_25 = 0;\n\tuint8_t channel_mask_temp_26 = 0;\n\tuint8_t channel_mask_temp_27 = 0;\n\tuint8_t", "CodeBleu_score": 9.840766370764504}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint32_t needed_buffer_size = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (adc_ad559x_channel_is_active(config, sequence->channels,\n\t\t\t\t\t\t sequence->resolution,\n\t\t\t\t\t\t sequence->buffer_size,\n\t\t\t\t\t\t sequence->channels[i])) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = active_channels *\n\t\t\t     adc_ad559x_get_resolution_bytes(sequence->resolution);\n\n\tif (needed_buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.340824533404856}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\tuint8_t channels;\n\tuint8_t resolution;\n\tuint8_t channel_mask;\n\tuint8_t channel_mask_index;\n\tuint8_t channel_mask_bit;\n\tuint8_t channel_mask_bit_index;\n\tuint8_t channel_mask_bit_index_max;\n\tuint8_t channel_mask_bit_index_min;\n\tuint8_t channel_mask_bit_index_min_max;\n\tuint8_t channel_mask_bit_index_min_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max_max_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max_max_max_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max_max_max_max_max_max_max_max;\n\tuint8_t channel_mask_bit_index_min_max_max_max_max_max_max_max_max_max_max_max_max_max;", "CodeBleu_score": 14.317154704990283}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t resolution;\n\tuint8_t channels;\n\tuint8_t i;\n\tuint8_t channel;\n\tuint8_t channel_mask;\n\tuint16_t *buffer;\n\tuint16_t value;\n\tint ret;\n\n\tif (sequence->resolution != data->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels == 0) {\n\t\tLOG_ERR(\"No channels specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < channels; i++) {\n\t\tchannel = find_msb_set(sequence->channels) - 1;\n\t\tif (channel >= AD559X_NUM_CHANNELS) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchannel_mask = BIT(channel);\n\t\tif ((sequence->channels & channel_mask) == 0) {\n\t\t\tLOG_ERR(\"Channel %d not specified\", channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsequence->channels &= ~channel_mask;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tbuffer = sequence->buffer;\n\n\tresolution = data->resolution;\n\tif (resolution == ADC_RESOLUTION_12_BIT) {\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tchannel = find_msb_set(sequence->channels) - 1;\n\t\t\tchannel_mask = BIT(channel);\n\t\t\tsequence->channels &= ~channel_mask;\n\n\t\t\tret = adc_ad559x_read_channel(dev, channel, &value);", "CodeBleu_score": 52.07808352194074}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_config *cfg = dev->config;\n\tuint8_t channels;\n\tuint8_t resolution;\n\tuint16_t *buffer;\n\tint ret;\n\n\tif (sequence->resolution != ADC_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!adc_channels_sorted(sequence->channels)) {\n\t\tLOG_ERR(\"Channels not sorted\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~ADC_CHANNEL_ALL_MASK) {\n\t\tLOG_ERR(\"Invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tbuffer = sequence->buffer;\n\tchannels = POPCOUNT(sequence->channels);\n\tresolution = sequence->resolution;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tadc_context_wait_for_completion(&data->ctx);\n\n\tadc_ad559x_read_channels(dev, sequence->channels, resolution, buffer);\n\n\treturn 0;\n}", "CodeBleu_score": 65.85315779915479}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_data *data = ctx->data;\n\tuint8_t *buf = data->buf;\n\tuint8_t *repeat_buf = data->repeat_buf;\n\tuint8_t *repeat_buf_end = repeat_buf + data->repeat_buf_len;\n\tuint8_t *buf_end = buf + data->buf_len;\n\tuint8_t *buf_ptr;\n\tuint8_t *repeat_buf_ptr;\n\tuint8_t *repeat_buf_ptr_end;\n\tuint8_t *repeat_buf_ptr_next;\n\tuint8_t *buf_ptr_next;\n\tuint8_t *buf_ptr_end;\n\tuint8_t *buf_ptr_next_end;\n\tuint8_t *buf_ptr_next_next;\n\tuint8_t *buf_ptr_next_next_end;\n\tuint8_t *buf_ptr_next_next_next;\n\tuint8_t *buf_ptr_next_next_next_end;\n\tuint8_t *buf_ptr_next_next_next_next;\n\tuint8_t *buf_ptr_next_next_next_next_end;\n\tuint8_t *buf_ptr_next_next_next_next_next;\n\tuint8_t *buf_ptr_next_next_next_next_next_end;\n\tuint8_t *buf_ptr_next_next_next_next_next_next;\n\tuint8_t *buf_ptr_next_next_next_next_next_next_end;\n\tuint8_t *buf_ptr_next_next_next_next_next_next_next;\n\tuint8_t *buf_ptr_next_next_next_next_next_next_next_end;\n\tuint8_t *buf_ptr_next_next_next_next_next_next_next_next;\n\tuint8_t *buf_ptr_next_next_next_next_next_next_next_next_end;\n\tuint8_t *buf_ptr_next_next_next_next_next_next", "CodeBleu_score": 13.671638196858932}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct device *dev = ctx->dev;\n\tconst struct adc_driver_api *api = dev->driver_api;\n\tstruct adc_data *data = ctx->data;\n\tconst struct adc_sampling_options *options = &ctx->options;\n\tuint16_t *repeat_buffer = data->repeat_buffer;\n\tuint16_t *buffer = data->buffer;\n\tuint8_t channel_count = options->channel_count;\n\tuint8_t i;\n\n\t/*\n\t * Get the ADC data structure from the context.\n\t */\n\tstruct adc_data *adc_data = ctx->data;\n\n\t/*\n\t * Set the channels to be sampled.\n\t */\n\tapi->channel_setup(dev, options->channels, channel_count);\n\n\t/*\n\t * Copy the data buffer to the repeat buffer.\n\t */\n\tfor (i = 0; i < channel_count; i++) {\n\t\trepeat_buffer[i] = buffer[i];\n\t}\n\n\t/*\n\t * Release the semaphore to signal the start of sampling.\n\t */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 30.185478856310223}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_data *data = ctx->data;\n\tstruct device *dev = data->dev;\n\tconst struct adc_driver_api *api = dev->driver_api;\n\tconst struct adc_sequence *sequence = &data->sequence;\n\tu8_t *repeat_buffer = data->buffer;\n\tu8_t *buffer = data->buffer;\n\tu8_t *repeat_buffer_end = repeat_buffer + sequence->channels;\n\tu8_t *buffer_end = buffer + sequence->channels;\n\tu8_t *repeat_buffer_ptr = repeat_buffer;\n\tu8_t *buffer_ptr = buffer;\n\tu8_t *buffer_ptr_end = buffer + sequence->resolution * sequence->channels;\n\tu8_t *repeat_buffer_ptr_end = repeat_buffer + sequence->resolution * sequence->channels;\n\tu8_t *repeat_buffer_ptr_start = repeat_buffer;\n\tu8_t *buffer_ptr_start = buffer;\n\tu8_t *buffer_ptr_repeat_start = buffer;\n\tu8_t *buffer_ptr_repeat_end = buffer + sequence->channels;\n\tu8_t *buffer_ptr_repeat_start_end = buffer + sequence->resolution * sequence->channels;\n\tu8_t *buffer_ptr_repeat_end_end = buffer + sequence->resolution * sequence->channels;\n\tu8_t *buffer_ptr_repeat_start_start = buffer;\n\tu8_t *buffer_ptr_repeat_end_start = buffer + sequence->channels;\n\tu8_t *buffer_ptr_repeat_start_start_end = buffer + sequence->resolution * sequence->channels;\n\tu8_t *buffer_ptr_repeat_end_start_end = buffer + sequence->resolution * sequence->channels;\n\tu8_t *buffer_ptr_repeat_start_start_start = buffer;\n\tu8_t *buffer_ptr_repeat_end_start_start = buffer + sequence->channels;\n\tu8_t *buffer_ptr_repeat_start_start_start", "CodeBleu_score": 15.039977040493271}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tstruct adc_data_container *adc_data_container = adc_context_get_data_container(ctx);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tctx->buffer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 37.878472791576115}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tif (repeat_sampling) {\n        ctx->buffer = ctx->repeat_buffer;\n    } else {\n        ctx->buffer = ctx->data_container->buffer;\n    }\n}", "CodeBleu_score": 48.86384730882591}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tstruct adc_data_container *adc_data_container = adc_context_get_data_container(ctx);\n    if (repeat_sampling) {\n        ctx->buffer = adc_data_container->repeat_buffer;\n    } else {\n        ctx->buffer = adc_data_container->buffer;\n    }\n}", "CodeBleu_score": 37.925138441318495}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tstruct adc_ad559x_config *config = data->dev->config;\n\tuint16_t result;\n\tuint8_t channel;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->num_channels; channel++) {\n\t\t\tif (data->channels[channel].acquisition_time == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel);\n\t\t\t\tadc_context_complete(&data->channels[channel].ctx, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdata->channels[channel].buffer[data->channels[channel].buffer_index] = result;\n\t\t\tdata->channels[channel].buffer_index++;\n\n\t\t\tif (data->channels[channel].buffer_index == data->channels[channel].buffer_size) {\n\t\t\t\tdata->channels[channel].buffer_index = 0;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, data->dev);\n\t}\n}", "CodeBleu_score": 56.24534861540796}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tstruct adc_ad559x_config *config = data->dev->config;\n\tuint8_t channel;\n\tuint16_t val;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for a semaphore to be released */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Iterate through the active channels */\n\t\tfor (channel = 0; channel < config->channels; channel++) {\n\t\t\tif (data->active_channels & BIT(channel)) {\n\t\t\t\t/* Read channel */\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &val);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Reading channel %d failed (err %d)\", channel, ret);\n\n\t\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Store result in buffer */\n\t\t\t\tdata->buffer[channel] = val;\n\t\t\t}\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tadc_context_on_sampling_done(&data->ctx, data->buffer);\n\t}\n}", "CodeBleu_score": 57.10240555919249}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tstruct adc_ad559x_config *config = data->dev->config;\n\tuint16_t val;\n\tuint8_t channel;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->channels; channel++) {\n\t\t\tif (data->active_channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &val);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel);\n\t\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tadc_context_on_sampling_done(&data->ctx, val);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 53.868451286415485}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[2] = {0};\n\tint rc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\n\tif (rc) {\n\t\tLOG_ERR(\"Failed to read configuration register\");\n\t\treturn rc;\n\t}\n\n\tif (buf[1] & ADS1112_CFG_DRDY_MASK) {\n\t\treturn 0;\n\t}\n\n\tk_sleep(K_USEC(config->drdy_time));\n\n\trc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\tif (rc) {\n\t\tLOG_ERR(\"Failed to read configuration register\");\n\t\treturn rc;\n\t}\n\n\tif (buf[1] & ADS1112_CFG_DRDY_MASK) {\n\t\treturn 0;\n\t}\n\n\tLOG_ERR(\"ADS1112 device is not ready for data reading\");\n\treturn -EIO;\n}", "CodeBleu_score": 31.995165613902017}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[2] = {0};\n\tint rc = 0;\n\n\twhile (1) {\n\t\trc = i2c_write_read_dt(&config->bus, &config->addr, buf, sizeof(buf), sizeof(buf));\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (buf[1] & ADS1112_REG_CONFIG_DRDY) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(100);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 32.96349549324934}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[2] = {0};\n\tint rc;\n\n\twhile (1) {\n\t\trc = i2c_write_read_dt(&config->bus, ADS1112_REG_CONFIG, buf, sizeof(buf));\n\t\tif (rc) {\n\t\t\tLOG_ERR(\"ADS1112: Error %d reading config register\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (buf[0] & ADS1112_CONFIG_DRDY) {\n\t\t\treturn 0;\n\t\t}\n\t\tk_sleep(100);\n\t}\n}", "CodeBleu_score": 34.22801673004212}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t/*\n\t * The buffer size required for an ADC sequence is:\n\t * 1. The number of samplings in the sequence.\n\t * 2. The number of extra samplings specified in the sequence options.\n\t */\n\tconst size_t buffer_size_required = sequence->options.extra_samplings + sequence->buffer_size;\n\n\t/*\n\t * If the buffer size is less than the required size, it logs an error message and returns an error code;\n\t * otherwise, it returns 0 indicating the buffer size is sufficient.\n\t */\n\tif (sequence->buffer_size < buffer_size_required) {\n\t\tLOG_ERR(\"The buffer size is insufficient.\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 36.47882893352607}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint ret = 0;\n\tint sampl_cnt = 0;\n\tint sampl_cnt_extra = 0;\n\tint buffer_size = 0;\n\tint req_buffer_size = 0;\n\tint i = 0;\n\n\t/* Calculate the number of samplings. */\n\tsampl_cnt = sequence->channels + sequence->extra_samplings;\n\n\t/* Calculate the number of extra samplings. */\n\tfor (i = 0; i < sequence->options.extra_samplings; i++) {\n\t\tsampl_cnt_extra++;\n\t}\n\n\t/* Calculate the buffer size. */\n\tbuffer_size = sequence->options.buffer_size;\n\n\t/* Calculate the required buffer size. */\n\treq_buffer_size = sampl_cnt + sampl_cnt_extra;\n\n\t/* Check if the buffer size is sufficient. */\n\tif (buffer_size < req_buffer_size) {\n\t\tLOG_ERR(\"The buffer size is insufficient.\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 36.24514982145198}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint buffer_size = sequence->options;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tbuffer_size += sequence->channels;\n\t}\n\n\tif (buffer_size < sequence->buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.42103078115649}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint rc = 0;\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc) {\n\t\tLOG_ERR(\"Invalid sequence\");\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\trc = adc_context_start_read(&data->ctx, sequence);\n\tif (rc) {\n\t\tLOG_ERR(\"Failed to start sampling\");\n\t\treturn rc;\n\t}\n\n\tif (wait) {\n\t\trc = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 70.58081560338158}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint rc;\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->repeat_buffer = sequence->repeat_buffer;\n\n\trc = adc_context_start_read(&data->ctx, sequence);\n\tif (rc == 0 && wait) {\n\t\trc = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 76.31107055703055}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tdata->buffer = sequence->buffer;\n\t\tdata->buffer_len = sequence->buffer_length;\n\t\tdata->read_completed = false;\n\t\tadc_context_start_read(&data->ctx, sequence);\n\t\tadc_context_wait_for_completion(&data->ctx);\n\t} else {\n\t\tdata->buffer = sequence->buffer;\n\t\tdata->buffer_len = sequence->buffer_length;\n\t\tdata->read_completed = false;\n\t\tadc_context_start_read(&data->ctx, sequence);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 62.01397633601562}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tstruct device *dev;\n\tstruct audio_codec_properties prop;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn SHELL_CMD_HELP_PRINTED;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn SHELL_CMD_HELP_PRINTED;\n\t}\n\n\tprop.gain = 0;\n\tprop.muted = false;\n\tprop.mic_muted = false;\n\n\tret = audio_codec_apply_properties(dev, &prop);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Error applying properties: %d\", ret);\n\t\treturn SHELL_CMD_HELP_PRINTED;\n\t}\n\n\tshell_print(sh, \"Properties applied\");\n\n\treturn 0;\n}", "CodeBleu_score": 52.68028571077116}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tstruct device *dev;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Successfully applied properties\");\n\n\treturn 0;\n}", "CodeBleu_score": 61.277360946946956}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tstruct device *dev;\n\tint ret;\n\tstruct audio_codec_properties prop;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tprop.gain = strtoul(argv[2], NULL, 0);\n\tprop.bias = strtoul(argv[3], NULL, 0);\n\n\tret = audio_codec_apply_properties(dev, &prop);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Properties applied\");\n\n\treturn 0;\n}", "CodeBleu_score": 60.033742464586304}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tconst struct mpxxdtyy_i2s_dev_config *cfg = dev->config;\n\tstruct mpxxdtyy_i2s_dev_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_DBG(\"starting device\");\n\t\t\tret = i2s_trigger(cfg->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"failed to start I2S device\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_ERR(\"device not in configured state\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_DBG(\"stopping device\");\n\t\t\tret = i2s_trigger(cfg->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"failed to stop I2S device\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"device not in active state\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"unsupported trigger command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 58.57035086781165}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret;\n\t\n\tswitch (cmd) {\n\t\tcase DMIC_TRIGGER_START:\n\t\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\t\tLOG_ERR(\"DMIC is already active\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t\n\t\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\t\tret = dmic_start(dev);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tLOG_ERR(\"DMIC start failed\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t\t\tLOG_DBG(\"DMIC started\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tLOG_ERR(\"DMIC is not configured\");\n\t\t\treturn -EINVAL;\n\t\t\t\n\t\tcase DMIC_TRIGGER_STOP:\n\t\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\t\tret = dmic_stop(dev);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tLOG_ERR(\"DMIC stop failed\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t\t\tLOG_DBG(\"DMIC stopped\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tLOG_ERR(\"DMIC is not active\");\n\t\t\treturn -EINVAL;\n\t\t\t\n\t\tdefault:\n\t\t\tLOG_ERR(\"DMIC trigger command not supported\");\n\t\t\treturn -EINVAL;\n\t}\n}", "CodeBleu_score": 56.1786331018185}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tstruct mpxxdtyy_i2s_dev_data *data = DEV_DATA(dev);\n\tstruct mpxxdtyy_i2s_dev_cfg *cfg = DEV_CFG(dev);\n\n\tswitch (data->state) {\n\t\tcase DMIC_STATE_STOPPED:\n\t\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t\t\tret = i2s_trigger(cfg->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tLOG_ERR(\"I2S start failed\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Invalid command for device state\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMIC_STATE_CONFIGURED:\n\t\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\t\tdata->state = DMIC_STATE_STOPPED;\n\t\t\t\tret = i2s_trigger(cfg->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tLOG_ERR(\"I2S stop failed\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Invalid command for device state\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMIC_STATE_ACTIVE:\n\t\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\t\tdata->state = DMIC_STATE_CONFIGURED", "CodeBleu_score": 51.07199174879293}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->cursor_position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_POSITION_BLINK;\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, config->mode);\n}", "CodeBleu_score": 66.76981540182288}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0x00;\n\n\tif (enabled) {\n\t\tcmd |= 0x08;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= 0x02;\n\t}\n\n\tif (config->blink_enabled) {\n\t\tcmd |= 0x01;\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, config->mode);\n}", "CodeBleu_score": 43.16115186189782}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0x00;\n\n\tif (enabled) {\n\t\tcmd |= 0x04;\n\t}\n\n\tif (config->display_cursor) {\n\t\tcmd |= 0x02;\n\t}\n\n\tif (config->blink_cursor) {\n\t\tcmd |= 0x01;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_MODE_8_BIT) {\n\t\tcmd |= 0x10;\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, config->display_mode);\n}", "CodeBleu_score": 50.08214641630951}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (!config->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get status of busy GPIO pin\");\n\t}\n\n\tdata->is_busy = ret;\n\n\treturn ret;\n}", "CodeBleu_score": 61.28689722473952}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\tgpio_pin_t pin;\n\n\tif (!config->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tpin = config->busy_gpio_pin;\n\n\tret = gpio_pin_get_dt(config->busy_gpio_port, pin, &data->busy_state);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get GPIO pin %d (%d)\", pin, ret);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 61.235500680525725}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *cfg = dev->config;\n\tif (!cfg->busy_gpio_port) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\treturn gpio_pin_get_dt(cfg->busy_gpio_port, cfg->busy_gpio_pin);\n}", "CodeBleu_score": 32.425623009455876}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config * const config = dev->config;\n\tuint8_t buffer[2];\n\tint result;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tresult = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n\tif (result) {\n\t\tLOG_ERR(\"Could not write to device %s: %d\", config->i2c.name, result);\n\t\treturn result;\n\t}\n\n\tk_sleep(K_MSEC(config->delay_ms));\n\n\treturn result;\n}", "CodeBleu_score": 60.93677362627843}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint rc;\n\n\tbuffer[0] = (uint8_t)command;\n\tbuffer[1] = (uint8_t)command;\n\n\trc = i2c_write_dt(config->i2c, buffer, sizeof(buffer));\n\tif (rc != 0) {\n\t\tLOG_ERR(\"Failed to write special command %d to LCD device %s: %d\",\n\t\t\tcommand, config->i2c_label, rc);\n\t\treturn rc;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\n\treturn rc;\n}", "CodeBleu_score": 64.873108327319}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tint ret;\n\tuint8_t buf[2];\n\n\tbuf[0] = (uint8_t)command;\n\tbuf[1] = (uint8_t)command;\n\n\tret = i2c_write_dt(dev, buf, 2);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to write command %d to device %s: %d\",\n\t\t\tcommand, dev->name, ret);\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(LCD_SPECIAL_COMMAND_DELAY_MS));\n\n\treturn ret;\n}", "CodeBleu_score": 47.656645705027046}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul = dev->data;\n\tstruct bbram_emul_status *status = &emul->status;\n\tuint8_t *mem = emul->mem;\n\tint ret;\n\n\tif (offset + size > emul->size) {\n\t\tLOG_ERR(\"Read out of bounds (%zu + %zu > %zu)\", offset, size,\n\t\t\temul->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Read from invalid memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, mem + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 58.237011110296436}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul = dev->data;\n\tint err;\n\n\tif (size > emul->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\terr = k_mutex_lock(&emul->lock, K_MSEC(100));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tmemcpy(data, emul->mem + offset, size);\n\n\tk_mutex_unlock(&emul->lock);\n\n\treturn 0;\n}", "CodeBleu_score": 57.498884253705654}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\tint ret = 0;\n\n\tif (size > emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, emul_data->mem + offset, size);\n\n\treturn ret;\n}", "CodeBleu_score": 62.11489242252729}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tbool is_invalid = false;\n\n\tif (size > data->size) {\n\t\tLOG_ERR(\"Invalid write size %zu (max %zu)\", size, data->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data->size) {\n\t\tLOG_ERR(\"Invalid write offset %zu + size %zu (max %zu)\", offset, size, data->size);\n\t\treturn -EINVAL;\n\t}\n\n\tis_invalid = bbram_emul_check_invalid(dev);\n\tif (is_invalid) {\n\t\tLOG_ERR(\"BBRAM is in invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 59.36249215883094}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\tint rc = 0;\n\n\tif (offset + size > emul_data->size) {\n\t\tLOG_ERR(\"Invalid write size\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Invalid BBRAM state\");\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(emul_data->mem + offset, data, size);\n\nexit:\n\treturn rc;\n}", "CodeBleu_score": 58.623619722921916}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *bbram_emul_data = dev->data;\n\tint ret = 0;\n\n\tif (offset + size > bbram_emul_data->size) {\n\t\tLOG_ERR(\"Write outside of device bounds\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Cannot write to invalid device\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(bbram_emul_data->mem + offset, data, size);\n\nout:\n\treturn ret;\n}", "CodeBleu_score": 57.93036517405166}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tsize_t i;\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tshell_help(sh);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device not specified.\");\n\t\treturn -ENOEXEC;\n\t}\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!(*bbram_dev)) {\n\t\tshell_error(sh, \"Device not found.\");\n\t\treturn -ENOEXEC;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 60.999120178179076}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tconst struct device *dev;\n\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = device_get_binding(argv[1]);\n\tif (err == NULL) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 65.61927644423152}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint i;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--help\") == 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Error: No device specified.\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Error: Device not found.\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 69.43835223434877}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tint ret;\n\tstruct uart_h4_data *data = DEV_DATA(dev);\n\tuint8_t *buf = data->hdr_buf;\n\tsize_t *len = &data->hdr_len;\n\tsize_t *remaining = &data->hdr_remaining;\n\tsize_t *read_len = &data->hdr_read_len;\n\tsize_t read_bytes;\n\tuint8_t *hdr_buf = data->hdr_buf;\n\tsize_t hdr_len = data->hdr_len;\n\tsize_t hdr_remaining = data->hdr_remaining;\n\tsize_t hdr_read_len = data->hdr_read_len;\n\n\t/*\n\t * If the number of bytes already read is equal to the total number of bytes in the header, then the header has been fully read.\n\t */\n\tif (hdr_read_len == hdr_len) {\n\t\tLOG_ERR(\"h4_read_hdr: hdr_read_len == hdr_len\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Attempt to read the remaining bytes from the UART FIFO into the header buffer.\n\t */\n\tret = uart_fifo_read(dev, buf + hdr_read_len, hdr_remaining, &read_bytes);\n\tif (ret) {\n\t\tLOG_ERR(\"h4_read_hdr: uart_fifo_read failed\");\n\t\treturn;\n\t}\n\n\t/*\n\t * If the number of bytes read is zero, then the header has been fully read.\n\t */\n\tif (read_bytes == 0) {\n\t\tLOG_ERR(\"h4_read_hdr: read_bytes == 0\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the number of bytes already read based on the number of bytes successfully read.\n\t */\n\thdr_read_len += read_bytes;\n\n\t/*\n\t * Update the number of bytes remaining in the header based on the number of bytes successfully read.\n\t */\n\thdr_remaining", "CodeBleu_score": 38.70816095161228}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct uart_h4_data *data = dev->data;\n\tuint8_t *buf = data->hdr_buf;\n\tsize_t len = data->hdr_len;\n\tsize_t read;\n\tint err;\n\n\tread = data->hdr_read;\n\tlen -= read;\n\tif (len == 0) {\n\t\treturn;\n\t}\n\n\t/* Attempt to read the remaining bytes from the UART FIFO into the header buffer. */\n\terr = uart_fifo_read(dev, buf + read, len, &read);\n\tif (err) {\n\t\tLOG_ERR(\"failed to read header data (err %d)\", err);\n\t\treturn;\n\t}\n\n\t/* Update the remaining byte count based on the number of bytes successfully read. */\n\tdata->hdr_read += read;\n}", "CodeBleu_score": 44.59970329162418}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct uart_h4_data *data = dev->data;\n\tstruct uart_h4_data_hdr *hdr = &data->hdr;\n\tuint8_t *buf = hdr->buf;\n\tuint32_t *cnt = &hdr->cnt;\n\tuint32_t *rem = &hdr->rem;\n\tuint32_t len = hdr->len;\n\tuint32_t read;\n\tint err;\n\n\t/*\n\t * If the header buffer is not empty, calculate the number of bytes already read.\n\t */\n\tif (*cnt > 0) {\n\t\tread = len - *cnt;\n\t} else {\n\t\tread = len;\n\t}\n\n\t/*\n\t * Attempt to read the remaining bytes from the UART FIFO into the header buffer.\n\t */\n\terr = uart_fifo_read(dev, buf + *cnt, read, &read);\n\tif (err != 0) {\n\t\tLOG_ERR(\"h4_read_hdr: uart_fifo_read failed (err %d)\", err);\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the remaining byte count based on the number of bytes successfully read.\n\t */\n\t*rem = len - (*cnt + read);\n\t*cnt += read;\n}", "CodeBleu_score": 47.71876275255514}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n\tsize_t read_len;\n\tsize_t ret = 0;\n\tread_len = uart_fifo_read(uart, buf, len);\n\tif (read_len > 0) {\n\t\tret = read_len;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 45.818854260095605}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n\tsize_t ret;\n\tret = uart_fifo_read(uart, buf, len);\n\tif (ret < len) {\n\t\tLOG_ERR(\"Failed to discard %zu bytes\", len - ret);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 46.900767686039146}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tsize_t ret;\n    uint8_t buf[33];\n    ret = uart_fifo_read(uart, buf, sizeof(buf));\n    if (ret < len) {\n        LOG_ERR(\"Failed to discard %d bytes (%d)\", len, ret);\n        return 0;\n    }\n    return ret;\n}", "CodeBleu_score": 55.395628023801756}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tunsigned int i;\n\tint prio;\n\t\n\tK_SPIN_LOCK(&chan->lock);\n\t\n\tfor (i = 0; i < chan->observer_count; i++) {\n\t\tif (chan->observers[i].enabled) {\n\t\t\tprio = chan->observers[i].prio;\n\t\t\tif (prio > chan->highest_observer_prio) {\n\t\t\t\tchan->highest_observer_prio = prio;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tK_SPIN_UNLOCK(&chan->lock);\n}", "CodeBleu_score": 21.820919216338737}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tint prio = 0;\n\tstruct zbus_observer *obs;\n\tstruct zbus_observer *obs_highest = NULL;\n\tstruct zbus_observer *obs_highest_prev = NULL;\n\tstruct zbus_observer *obs_highest_next = NULL;\n\tint i;\n\tint j;\n\tint k;\n\tint prio_new;\n\tint prio_old;\n\tint prio_old_highest;\n\tint prio_old_highest_prev;\n\tint prio_old_highest_next;\n\tint prio_old_new;\n\tint prio_old_prev;\n\tint prio_old_next;\n\tint prio_old_tmp;\n\tint prio_old_tmp_highest;\n\tint prio_old_tmp_highest_prev;\n\tint prio_old_tmp_highest_next;\n\tint prio_old_tmp_new;\n\tint prio_old_tmp_prev;\n\tint prio_old_tmp_next;\n\tint prio_old_tmp_tmp;\n\tint prio_tmp;\n\tint prio_tmp_highest;\n\tint prio_tmp_highest_prev;\n\tint prio_tmp_highest_next;\n\tint prio_tmp_new;\n\tint prio_tmp_prev;\n\tint prio_tmp_next;\n\tint prio_tmp_tmp;\n\tint prio_tmp_tmp_highest;\n\tint prio_tmp_tmp_highest_prev;\n\tint prio_tmp_tmp_highest_next;\n\tint prio_tmp_tmp_new;\n\tint prio_tmp_tmp_prev;\n\tint prio_tmp_tmp_next;\n\tint prio_tmp_tmp_tmp;\n\tint prio_tmp_tmp_tmp_highest;\n\tint prio_tmp_tmp_tmp_highest_prev;\n\tint prio_tmp_tmp_tmp_highest_next;\n\tint prio_tmp_tmp_tmp_new;\n\tint", "CodeBleu_score": 11.255811457662066}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tstruct zbus_observer *obs;\n\tunsigned int prio;\n\tunsigned int i;\n\tunsigned int highest = 0;\n\tunsigned int enabled = 0;\n\tunsigned int num_obs = 0;\n\tunsigned int num_enabled = 0;\n\tunsigned int num_prio = 0;\n\tunsigned int num_prio_enabled = 0;\n\tunsigned int num_prio_disabled = 0;\n\tunsigned int num_prio_enabled_highest = 0;\n\tunsigned int num_prio_disabled_highest = 0;\n\tunsigned int num_prio_enabled_highest_prio = 0;\n\tunsigned int num_prio_disabled_highest_prio = 0;\n\tunsigned int num_prio_enabled_highest_prio_disabled = 0;\n\tunsigned int num_prio_disabled_highest_prio_disabled = 0;\n\tunsigned int num_prio_enabled_highest_prio_enabled = 0;\n\tunsigned int num_prio_disabled_highest_prio_enabled = 0;\n\tunsigned int num_prio_enabled_highest_prio_enabled_disabled = 0;\n\tunsigned int num_prio_disabled_highest_prio_enabled_disabled = 0;\n\tunsigned int num_prio_enabled_highest_prio_enabled_disabled_enabled = 0;\n\tunsigned int num_prio_disabled_highest_prio_enabled_disabled_enabled = 0;\n\tunsigned int num_prio_enabled_highest_prio_enabled_disabled_enabled_disabled = 0;\n\tunsigned int num_prio_disabled_highest_prio_enabled_disabled_enabled_disabled = 0;\n\tunsigned int num_prio_enabled_highest_prio_enabled_disabled_enabled_disabled_enabled = 0;\n\tunsigned int num_prio_disabled_highest_prio_enabled_disabled_enabled_disabled_enabled = 0;\n\tunsigned int num_prio_enabled_highest_prio_enabled_disabled_enabled_disabled_enabled_disabled = 0", "CodeBleu_score": 9.135919200959746}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channel_observations_end_idx;\n\n\t\tfor (int16_t i = obs->data->channel_observations_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tif (observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan->data->highest_observer_priority > obs->data->priority) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 18.97749243611094}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_data.channels_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_data.channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tif (!chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (obs->data->priority <= chan->data->highest_observer_priority) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 18.94033713317335}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channel_observations_end_idx;\n\n\t\tfor (int16_t i = obs->data->channel_observations_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (!observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 24.664067780038682}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t_ZBUS_ASSERT(obs != NULL);\n\n\tK_SPINLOCK(lock);\n\n\t_ZBUS_ASSERT(!k_is_in_isr());\n\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\n\tupdate_all_channels_hop(obs);\n\n\tK_SPINUNLOCK(lock);\n\n\treturn 0;\n}", "CodeBleu_score": 51.27166626699835}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t_ZBUS_ASSERT(obs != NULL, \"zbus_obs_attach_to_thread: observer is NULL\");\n\t_ZBUS_ASSERT(!k_is_in_isr(), \"zbus_obs_attach_to_thread: called from ISR\");\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 58.61726795319665}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tK_ASSERT(!k_is_in_isr());\n\tK_ASSERT(obs);\n\n\tk_spinlock_key_t key = k_spin_lock(&obs_lock);\n\n\tobs->prio = K_LOWEST_THREAD_PRIO;\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&obs_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 49.920935862490865}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"zbus channel must be not NULL\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_init(timeout);\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 61.09895378755931}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"zbus channel must not be NULL\");\n\n\tk_timepoint_t end_time = sys_clock_timeout_end_calc(timeout);\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 46.872048956273574}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\tk_timepoint_t end_time = sys_clock_timeout_end_calc(timeout);\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 47.394465284482614}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tassert_param(IS_ETH_INT(Int));\n\tif (enable) {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->IMR |= Int;\n\t\t} else {\n\t\t\tETH->IER |= Int;\n\t\t}\n\t} else {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->IMR &= ~Int;\n\t\t} else {\n\t\t\tETH->IER &= ~Int;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.95468012053996}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tassert_param(IS_ETH_INT(Int));\n\tif (enable) {\n\t\tif (Int == IS_ETH_INT_NORMAL) {\n\t\t\tETH->INTEN |= Int;\n\t\t} else {\n\t\t\tETH->INTEN |= Int << 16;\n\t\t}\n\t} else {\n\t\tif (Int == IS_ETH_INT_NORMAL) {\n\t\t\tETH->INTEN &= ~Int;\n\t\t} else {\n\t\t\tETH->INTEN &= ~(Int << 16);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.20686520989382}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\n\t/* Disable the interrupt if the ETH_INTENR register value is 0 */\n\tif (enable == FALSE) {\n\t\tETH->INTENR &= ~Int;\n\t}\n\t/* Enable the interrupt if the ETH_INTENR register value is not 0 */\n\telse {\n\t\t/* Check the interrupt is normal or abnormal */\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\t/* Set the corresponding enable bit in the ETH_INTENR register */\n\t\t\tETH->INTENR |= Int;\n\t\t}\n\t\telse {\n\t\t\t/* Set the corresponding enable bit in the ETH_INTENR register */\n\t\t\tETH->INTENR |= Int;\n\t\t}\n\t}\n}", "CodeBleu_score": 26.867817191517435}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n    uint32_t i;\n\n    pTxDesc = (ETH_TX_DESC *)&(ETH_TX_DESC_BASE);\n\n    for (i = 0; i < ETH_TX_DESC_NUM; i++) {\n        if ((pTxDesc->Status & ETH_TX_DESC_STAT_OWN) == 0) {\n            return (pTxDesc);\n        }\n        pTxDesc++;\n    }\n    return (0);\n}", "CodeBleu_score": 35.79308420173224}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *txDesc;\n\n\ttxDesc = ETH_txDesc;\n\n\twhile (txDesc->Status & ETH_TX_DESC_OWN) {\n\t\ttxDesc = (ETH_TX_DESC *) (txDesc->Buffer1Addr);\n\t\tif (txDesc == ETH_txDesc) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn txDesc;\n}", "CodeBleu_score": 43.347605667372214}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *txDesc;\n\tuint32_t i;\n\t\n\ttxDesc = (ETH_TX_DESC *)ETH_TX_DESC_BASE;\n\tfor (i = 0; i < ETH_TX_DESC_COUNT; i++) {\n\t\tif ((txDesc->status & ETH_TX_DESC_STATUS_OWN) == 0) {\n\t\t\treturn txDesc;\n\t\t}\n\t\ttxDesc++;\n\t}\n\t\n\treturn 0;\n}", "CodeBleu_score": 32.844523195937505}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t result = RT_EOK;\n    rt_uint32_t cyp_dac_channel = 0;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    result = Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value);\n    if (result != CY_CSD_SUCCESS)\n    {\n        LOG_E(\"cyp_dac_convert failed\");\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 62.52190106614764}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tRT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    struct cyp_dac_device *cyp_dac_device = (struct cyp_dac_device *)device;\n\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    rt_err_t result = RT_EOK;\n\n    result = Cy_CSDIDAC_OutputEnable(cyp_dac_device->base, cyp_dac_channel, *value);\n    if (result != RT_EOK)\n    {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable failed\");\n    }\n\n    return result;\n}", "CodeBleu_score": 59.797273393512086}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tRT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    struct rt_cyp_dac_device *cyp_dac_device = (struct rt_cyp_dac_device *)device;\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (cyp_dac_channel == 0)\n    {\n        LOG_E(\"cyp_dac_convert: cyp_dac_get_channel failed.\");\n        return -RT_ERROR;\n    }\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_device->dac, cyp_dac_channel, *value) != CY_CSD_SUCCESS)\n    {\n        LOG_E(\"cyp_dac_convert: Cy_CSDIDAC_OutputEnable failed.\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 55.790628764152764}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tint ret = 0;\n    if (addr + size > IFX_FLASH_END_ADDRESS) {\n        LOG_E(\"Error: read address(0x%x) exceeds flash memory's end address(0x%x)\", addr, IFX_FLASH_END_ADDRESS);\n        return -RT_EINVAL;\n    }\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n    ret = size;\n    return ret;\n}", "CodeBleu_score": 47.6260780946716}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tint i;\n    rt_uint8_t *ptr;\n    rt_uint32_t *ptr_32;\n\n    if (addr + size > IFX_FLASH_32K_END_ADDR) {\n        LOG_E(\"read addr: 0x%x, size: %d, out of range!\", addr, size);\n        return -RT_EINVAL;\n    }\n\n    ptr = buf;\n    ptr_32 = (rt_uint32_t *)addr;\n    for (i = 0; i < size; i += 4) {\n        *ptr++ = (*ptr_32 >> 0) & 0xFF;\n        *ptr++ = (*ptr_32 >> 8) & 0xFF;\n        *ptr++ = (*ptr_32 >> 16) & 0xFF;\n        *ptr++ = (*ptr_32 >> 24) & 0xFF;\n        ptr_32++;\n    }\n\n    return size;\n}", "CodeBleu_score": 48.28827608235886}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n    RT_ASSERT(timer_obj != RT_NULL);\n    return cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 60.162922003216224}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    rt_uint32_t count = 0;\n    cyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    count = cyhal_timer_read(cyhal_timer);\n    return count;\n}", "CodeBleu_score": 71.44955623292498}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    rt_uint32_t count = 0;\n    count = cyhal_timer_read(((cyhal_timer_t *)timer->parent.user_data));\n    return count;\n}", "CodeBleu_score": 58.27288192853416}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\tint32_t res;\n\tres = rt_mutex_take(&dfs_lock_mutex, RT_WAITING_FOREVER);\n\tRT_ASSERT(res == RT_EOK);\n}", "CodeBleu_score": 15.475320303082407}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.1903433445041065}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.1903433445041065}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint i;\n    int index;\n    int fd;\n    struct dfs_file **fds = NULL;\n\n    fds = fdt->fds;\n\n    for (i = startfd; i < fdt->maxfd; i++)\n    {\n        if (!fds[i])\n        {\n            return i;\n        }\n    }\n\n    index = fd_slot_expand(fdt, startfd);\n    if (index < 0)\n    {\n        return -1;\n    }\n\n    for (i = startfd; i < fdt->maxfd; i++)\n    {\n        if (!fds[i])\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}", "CodeBleu_score": 48.20353255450769}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n    int index;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (!fdt->fds[fd]) {\n            return fd;\n        }\n    }\n\n    return fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 28.960393096904337}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            return fd;\n        }\n    }\n\n    return fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 29.913012396220733}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\tif (error < 0) {\n        error = -error;\n    }\n    switch (error) {\n        case RT_EOK:\n            return \"RT_EOK\";\n        case RT_ERROR:\n            return \"RT_ERROR\";\n        case RT_ETIMEOUT:\n            return \"RT_ETIMEOUT\";\n        case RT_EFULL:\n            return \"RT_EFULL\";\n        case RT_EEMPTY:\n            return \"RT_EEMPTY\";\n        case RT_ENOMEM:\n            return \"RT_ENOMEM\";\n        case RT_ENOENT:\n            return \"RT_ENOENT\";\n        case RT_EIO:\n            return \"RT_EIO\";\n        case RT_EINTR:\n            return \"RT_EINTR\";\n        case RT_EINVAL:\n            return \"RT_EINVAL\";\n        case RT_ENOSYS:\n            return \"RT_ENOSYS\";\n        case RT_EBUSY:\n            return \"RT_EBUSY\";\n        case RT_EAGAIN:\n            return \"RT_EAGAIN\";\n        case RT_EWOULDBLOCK:\n            return \"RT_EWOULDBLOCK\";\n        case RT_EINPROGRESS:\n            return \"RT_EINPROGRESS\";\n        case RT_EALREADY:\n            return \"RT_EALREADY\";\n        case RT_ENOTINIT:\n            return \"RT_ENOTINIT\";\n        case RT_ENOTSUPPORT:\n            return \"RT_ENOTSUPPORT\";\n        case RT_EBADGESTURE:\n            return \"RT_EBADGESTURE\";\n        case RT_EDEADLOCK:\n            return \"RT_EDEADLOCK\";\n        case RT_EINTRPT:\n            return \"RT_EINTRPT\";\n        case RT_EEXIT:\n            return \"RT_EEXIT\";\n        case RT_EEXCEPTION:\n            return \"RT_EEXCEPTION\";\n        case R", "CodeBleu_score": 31.45971360985511}, {"code": "const char *rt_strerror(rt_err_t error){\n\tint i;\n\n    /* Convert the error code to a positive value */\n    if (error < 0) {\n        error = -error;\n    }\n\n    /* Iterate through the array of known error strings to find a match for the error code */\n    for (i = 0; i < RT_ERROR_MAX; i++) {\n        if (error == rt_error_strings[i].error) {\n            return rt_error_strings[i].string;\n        }\n    }\n\n    /* If no match is found, return the string \"EUNKNOW\" */\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 59.51810616450486}, {"code": "const char *rt_strerror(rt_err_t error){\n\tif (error < 0)\n        error = -error;\n    switch (error) {\n        case RT_EOK:\n            return \"RT_EOK\";\n        case RT_ERROR:\n            return \"RT_ERROR\";\n        case RT_ETIMEOUT:\n            return \"RT_ETIMEOUT\";\n        case RT_EFULL:\n            return \"RT_EFULL\";\n        case RT_EEMPTY:\n            return \"RT_EEMPTY\";\n        case RT_ENOMEM:\n            return \"RT_ENOMEM\";\n        case RT_ENOSYS:\n            return \"RT_ENOSYS\";\n        case RT_EBUSY:\n            return \"RT_EBUSY\";\n        case RT_EIO:\n            return \"RT_EIO\";\n        case RT_EINTR:\n            return \"RT_EINTR\";\n        case RT_EINVAL:\n            return \"RT_EINVAL\";\n        case RT_EOPNOTSUPP:\n            return \"RT_EOPNOTSUPP\";\n        case RT_ENOSPC:\n            return \"RT_ENOSPC\";\n        case RT_ENOENT:\n            return \"RT_ENOENT\";\n        case RT_EEXIST:\n            return \"RT_EEXIST\";\n        case RT_EAGAIN:\n            return \"RT_EAGAIN\";\n        case RT_EINPROGRESS:\n            return \"RT_EINPROGRESS\";\n        case RT_ENOTCONN:\n            return \"RT_ENOTCONN\";\n        case RT_ECONNABORTED:\n            return \"RT_ECONNABORTED\";\n        case RT_ECONNRESET:\n            return \"RT_ECONNRESET\";\n        case RT_EALREADY:\n            return \"RT_EALREADY\";\n        case RT_ENOTSUP:\n            return \"RT_ENOTSUP\";\n        case RT_EUNKNOW:\n            return \"RT_EUNKNOW\";\n        default:", "CodeBleu_score": 34.303629431180084}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n\trt_base_t level;\n\tstruct rt_thread *thread;\n\t\n\tRT_ASSERT(hook != RT_NULL);\n\t\n\tlevel = rt_hw_interrupt_disable();\n\tthread = rt_thread_self();\n\tif (thread->idle_hook == RT_NULL) {\n\t\tthread->idle_hook = hook;\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_hw_interrupt_enable(level);\n\t\n\treturn result;\n}", "CodeBleu_score": 24.839484370623783}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\n    rt_uint32_t i;\n    rt_thread_idle_sethook_t hook_item;\n\n    level = rt_hw_interrupt_disable();\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_thread_idle_hook_list[i].hook == RT_NULL) {\n            rt_thread_idle_hook_list[i].hook = hook;\n            break;\n        }\n    }\n    rt_hw_interrupt_enable(level);\n\n    if (i < RT_THREAD_IDLE_HOOK_LIST_SIZE) {\n        hook_item = &rt_thread_idle_hook_list[i];\n        rt_sem_init(&hook_item->sem, \"idle_sem\", 0, RT_IPC_FLAG_FIFO);\n        rt_sem_control(&hook_item->sem, RT_IPC_CMD_RESET, RT_NULL);\n        return RT_EOK;\n    }\n\n    return -RT_EFULL;\n}", "CodeBleu_score": 53.21930043373819}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\n    rt_err_t ret;\n    struct rt_thread *idle;\n\n    idle = rt_thread_find(\"idle\");\n    if (idle == RT_NULL) return -RT_ERROR;\n\n    level = rt_hw_interrupt_disable();\n    if (idle->idle_hook_list[idle->idle_hook_count] != RT_NULL)\n    {\n        ret = -RT_EFULL;\n    }\n    else\n    {\n        idle->idle_hook_list[idle->idle_hook_count] = hook;\n        ret = RT_EOK;\n    }\n    rt_hw_interrupt_enable(level);\n\n    return ret;\n}", "CodeBleu_score": 36.377628525626456}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_spin_lock_irqsave(&idle_hook_lock);\n\n    rt_list_t *l;\n    rt_list_t *l_next;\n    rt_list_t *l_safe;\n\n    for (l = (&idle_hook_list)->next; l != &idle_hook_list; l = l_next) {\n        l_next = l->next;\n        l_safe = l->next;\n\n        rt_thread_idle_hook_t *hook_item = rt_list_entry(l, rt_thread_idle_hook_t, list);\n        if (hook_item->hook == hook) {\n            rt_list_remove(l);\n            rt_free(hook_item);\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&idle_hook_lock);\n\n    return RT_EOK;\n}", "CodeBleu_score": 42.76641828263848}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_spin_lock_irqsave(&idle_hook_lock);\n\n    rt_list_for_each(hook_node, &idle_hook_list, struct rt_thread_hook, list) {\n        if (hook_node->hook == hook) {\n            rt_list_remove(&hook_node->list);\n            RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"remove idle hook %p\n\", hook));\n            rt_spin_unlock_irqrestore(&idle_hook_lock);\n            return RT_EOK;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&idle_hook_lock);\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 30.84879525934316}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_base_t lock;\n    rt_thread_idle_hook_t *hook_list;\n    rt_thread_idle_hook_t *prev_hook;\n    rt_thread_idle_hook_t *cur_hook;\n\n    lock = rt_hw_interrupt_disable();\n    hook_list = &(rt_thread_global_control[RT_THREAD_CTRL_IDLE_HOOK].value);\n    prev_hook = RT_NULL;\n    cur_hook = hook_list->next;\n    while (cur_hook != RT_NULL) {\n        if (cur_hook->hook == hook) {\n            if (prev_hook != RT_NULL) {\n                prev_hook->next = cur_hook->next;\n            } else {\n                hook_list->next = cur_hook->next;\n            }\n\n            rt_hw_interrupt_enable(lock);\n\n            rt_free(cur_hook);\n\n            return RT_EOK;\n        }\n\n        prev_hook = cur_hook;\n        cur_hook = cur_hook->next;\n    }\n\n    rt_hw_interrupt_enable(lock);\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 41.95966118103745}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* ensure the scheduler is unlocked */\n    rt_scheduler_unlock();\n\n    /* resume all suspended threads */\n    while (rt_list_len(susp_list)) {\n        thread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n        rt_list_remove(&(thread->tlist));\n        rt_schedule_remove_thread(thread);\n        rt_thread_resume(thread, thread_error);\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 43.701058710932664}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* dequeue thread from suspension list */\n    while (!rt_list_isempty(susp_list)) {\n        /* get thread from suspension list */\n        thread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\n        /* remove thread from suspension list */\n        rt_list_remove(&(thread->tlist));\n\n        /* set error code */\n        thread->error = thread_error;\n\n        /* resume thread */\n        rt_thread_resume(thread);\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.39639499158649}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n    rt_err_t result;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    while (rt_list_isempty(susp_list) == RT_FALSE) {\n        /* dequeue thread */\n        thread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n        rt_list_remove(&(thread->tlist));\n\n        /* unlock scheduler */\n        rt_exit_critical();\n\n        /* resume thread */\n        result = rt_thread_resume(thread, thread_error);\n        if (result != RT_EOK) {\n            return result;\n        }\n\n        /* lock scheduler */\n        rt_enter_critical();\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.759097673068915}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console;\n    rt_device_t new_console;\n\n    if (name == RT_NULL)\n        return RT_NULL;\n\n    old_console = rt_console_get_device();\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL ||\n            !(new_console->type == RT_Device_Class_Char &&\n                    (new_console->flag & RT_DEVICE_FLAG_RDWR) &&\n                    (new_console->flag & RT_DEVICE_FLAG_STREAM)))\n    {\n        return old_console;\n    }\n\n    if (old_console != new_console)\n    {\n        if (old_console != RT_NULL)\n            rt_device_close(old_console);\n\n        rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        rt_console_set_device(new_console);\n    }\n\n    return old_console;\n}", "CodeBleu_score": 55.17877502403966}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console;\n    rt_device_t new_console;\n\n    old_console = rt_console_get_device();\n    if (old_console == RT_NULL) return RT_NULL;\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) return RT_NULL;\n\n    if (old_console != new_console) {\n        rt_device_close(old_console);\n        rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        rt_console_set_device(new_console);\n    }\n\n    return old_console;\n}", "CodeBleu_score": 55.557772617108256}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console_device;\n    rt_device_t new_console_device;\n    RT_ASSERT(name != RT_NULL);\n    old_console_device = rt_console_get_device();\n    new_console_device = rt_device_find(name);\n    if ((new_console_device != RT_NULL) && (new_console_device != old_console_device)) {\n        if (old_console_device != RT_NULL) {\n            rt_device_close(old_console_device);\n        }\n        rt_device_open(new_console_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        rt_console_set_device(new_console_device);\n    }\n    return old_console_device;\n}", "CodeBleu_score": 50.43185703433915}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\trt_spinlock_t lock;\n    struct rt_object *object;\n    int count = 0;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* get lock */\n    lock = rt_object_get_lock(type);\n    if (lock == RT_NULL)\n        return -RT_ERROR;\n\n    /* get count */\n    object = rt_object_get_first(type);\n    while (object)\n    {\n        count ++;\n        object = rt_object_get_next(object);\n    }\n\n    /* release lock */\n    rt_spin_unlock_irqrestore(lock);\n\n    return count;\n}", "CodeBleu_score": 46.69579742555009}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\trt_spinlock_t lock;\n    rt_object_t object;\n    int count = 0;\n\n    if (type >= RT_Object_Class_Unknown)\n        return -RT_ERROR;\n\n    lock = rt_object_get_lock(type);\n    rt_spin_lock_irqsave(&lock);\n\n    object = rt_object_next_get(type, RT_NULL);\n    while (object != RT_NULL) {\n        count++;\n        object = rt_object_next_get(type, object);\n    }\n\n    rt_spin_unlock_irqrestore(&lock);\n\n    return count;\n}", "CodeBleu_score": 44.980012742008626}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tstruct rt_object_information *information;\n    struct rt_object *object;\n    int count;\n    unsigned long lock;\n\n    information = &_object_information_table[type];\n    count = 0;\n    lock = rt_spin_lock_irqsave(&information->lock);\n    rt_list_for_each(object, &information->object_list) {\n        count ++;\n    }\n    rt_spin_unlock_irqrestore(&information->lock, lock);\n\n    return count;\n}", "CodeBleu_score": 43.53757059992134}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\trt_object_information_t object_info;\n    RT_ASSERT(object != RT_NULL);\n    RT_OBJECT_HOOK_CALL(RT_OBJECT_DETACH, object);\n    object_info = object->object_inf;\n    rt_spin_lock_irqsave(&(object_info->spinlock));\n    rt_list_remove(&(object->list));\n    object->type = 0;\n    rt_spin_unlock_irqrestore(&(object_info->spinlock));\n}", "CodeBleu_score": 44.58915586422979}, {"code": "void rt_object_detach(rt_object_t object){\n\trt_object_info_t object_info;\n\n    RT_ASSERT(object != RT_NULL);\n\n    object_info = &(object->object_info);\n    /* invoke detach hook function */\n    if (object_info->ops->detach != RT_NULL)\n        object_info->ops->detach(object);\n\n    /* lock object */\n    rt_spin_lock_irqsave(&(object_info->lock));\n\n    /* remove from object list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object */\n    rt_spin_unlock_irqrestore(&(object_info->lock));\n\n    /* set object type to zero */\n    object->type = 0;\n}", "CodeBleu_score": 46.40220839179335}, {"code": "void rt_object_detach(rt_object_t object){\n\trt_object_information_t object_info;\n    RT_ASSERT(object != RT_NULL);\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, object);\n    object_info = object->object_info;\n    rt_spin_lock_irqsave(&(object_info->spinlock));\n    rt_list_remove(&(object->list));\n    rt_spin_unlock_irqrestore(&(object_info->spinlock));\n    object->type = 0;\n}", "CodeBleu_score": 48.36980525224123}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n    /* custom object check */\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* call custom object destroy function */\n    if (obj->ops->destroy != RT_NULL) {\n        result = obj->ops->destroy(obj);\n    } else {\n        result = RT_EOK;\n    }\n\n    /* delete object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 48.3359932524321}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\n    struct rt_object_information *information;\n    rt_base_t level;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n    /* get object information */\n    information = rt_object_get_information((enum rt_object_class_type)obj->type);\n    RT_ASSERT(information != RT_NULL);\n\n    level = rt_spin_lock_irqsave(&(information->spinlock));\n\n    /* remove from old list */\n    rt_list_remove(&(obj->list));\n\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    /* call object destroy method */\n    if (obj->ops->destroy != RT_NULL)\n    {\n        result = obj->ops->destroy(obj);\n    }\n\n    /* reset object type */\n    obj->type = RT_Object_Class_Null;\n\n    /* free the memory of object */\n    RT_KERNEL_FREE(obj);\n\n    return result;\n}", "CodeBleu_score": 45.260015728985714}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\n    rt_object_information_t information;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type != RT_Object_Class_Static);\n\n    /* get object information */\n    information = rt_object_get_information(obj->type);\n    RT_ASSERT(information != RT_NULL);\n\n    /* check object type */\n    if (obj->type != information->type) {\n        return -RT_ERROR;\n    }\n\n    /* invoke object's destroy function */\n    if (information->destroy != RT_NULL) {\n        result = information->destroy(obj);\n    }\n\n    /* delete object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 45.748325029100165}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* thread exit */\n    rt_thread_close(thread);\n\n    /* schedule */\n    rt_schedule();\n}", "CodeBleu_score": 26.726159867950727}, {"code": "static void _thread_exit(void){\n\trt_thread_t self;\n\n    /* get current thread */\n    self = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* thread exit */\n    rt_thread_close(self);\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* schedule */\n    rt_schedule();\n}", "CodeBleu_score": 30.443223069149173}, {"code": "static void _thread_exit(void){\n\trt_thread_t self;\n\n    /* get current thread */\n    self = rt_thread_self();\n\n    /* thread exit */\n    rt_thread_close(self);\n\n    /* thread defunct */\n    rt_thread_defunct_enqueue(self);\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 53.60702572410677}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\trt_thread_t thread;\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (rt_thread_t)parameter;\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_thread_is_suspend(thread));\n    rt_sched_lock();\n    thread->error = -RT_ETIMEOUT;\n    rt_list_remove(&(thread->tlist));\n    rt_sched_insert_thread(thread);\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 57.96046397646055}, {"code": "static void _thread_timeout(void *parameter){\n\trt_thread_t thread;\n\trt_err_t result;\n\tRT_ASSERT(parameter != RT_NULL);\n\tthread = (rt_thread_t)parameter;\n\tRT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\t/* lock scheduler */\n\trt_enter_critical();\n\t/* set error number */\n\tthread->error = -RT_ETIMEOUT;\n\t/* remove from suspend list */\n\trt_list_remove(&(thread->tlist));\n\t/* insert to ready list */\n\trt_list_insert_before(&(thread->tlist), &(thread->scheduler->ready_list));\n\t/* unlock scheduler */\n\trt_exit_critical();\n\t/* reschedule */\n\tresult = rt_schedule();\n\tRT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 46.073947471992376}, {"code": "static void _thread_timeout(void *parameter){\n\tRT_ASSERT(parameter != RT_NULL);\n\tstruct rt_thread *thread = (struct rt_thread *)parameter;\n\tRT_ASSERT(rt_object_get_type(thread) == RT_Object_Class_Thread);\n\tRT_ASSERT(thread->stat == RT_THREAD_STAT_SUSPEND);\n\tRT_ASSERT(rt_list_isempty(&(thread->tlist)));\n\tRT_ASSERT(rt_list_isempty(&(thread->suspend_list)));\n\tRT_ASSERT(rt_list_isempty(&(thread->activate_list)));\n\tRT_ASSERT(rt_list_isempty(&(thread->cleanup_list)));\n\tRT_ASSERT(rt_list_isempty(&(thread->wait_list)));\n\tRT_ASSERT(rt_list_isempty(&(thread->join_list)));\n\tRT_ASSERT(thread->error == RT_EOK);\n\tRT_ASSERT(thread->stat == RT_THREAD_STAT_SUSPEND);\n\tRT_ASSERT(thread->cleanup != RT_NULL);\n\tRT_ASSERT(thread->cleanup_parameter != RT_NULL);\n\tRT_ASSERT(thread->timeout_tick != 0);\n\tRT_ASSERT(thread->timeout_tick < rt_tick_get());\n\tRT_ASSERT(thread->stat == RT_THREAD_STAT_SUSPEND);\n\tRT_ASSERT(rt_list_isempty(&(thread->suspend_list)));\n\tRT_ASSERT(rt_list_isempty(&(thread->activate_list)));\n\tRT_ASSERT(rt_list_isempty(&(thread->cleanup_list)));\n\tRT_ASSERT(rt_list_isempty(&(thread->wait_list)));\n\tRT_ASSERT(rt_list_isempty(&(thread->join_list)));\n\tRT_ASSERT(thread->error == RT_EOK);\n\tRT_ASSERT(thread->stat == RT_THREAD_STAT_SUSPEND);\n\tRT_ASSERT(thread->cleanup != R", "CodeBleu_score": 45.26180634108281}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tregister rt_mutex_t mutex;\n\tregister rt_list_t *l;\n\tregister rt_list_t *l_next;\n\trt_spinlock_t lock;\n\tregister rt_ubase_t level;\n\trt_ubase_t need_schedule;\n\tregister rt_ubase_t state;\n\trt_ubase_t need_resched;\n\trt_ubase_t need_sched_locked;\n\n\t/*\n\t * Lock the thread's spinlock and get its current state.\n\t */\n\tlock = thread->lock;\n\tlevel = rt_hw_spin_lock_irqsave(lock);\n\n\t/*\n\t * Check if the thread is waiting on a mutex.\n\t */\n\tif (thread->state & RT_THREAD_STATE_MUTEX_WAIT) {\n\t\t/*\n\t\t * Yes, it is.\n\t\t *\n\t\t * Remove it from the mutex's waiting list and clear the pending\n\t\t * object.\n\t\t */\n\t\tmutex = (rt_mutex_t)thread->pending_object;\n\t\tl = &mutex->wait_list;\n\t\tl_next = l->next;\n\t\trt_list_remove(l_next);\n\t\tthread->pending_object = RT_NULL;\n\n\t\t/*\n\t\t * Clear the mutex waiting flag.\n\t\t */\n\t\tthread->state &= ~RT_THREAD_STATE_MUTEX_WAIT;\n\t}\n\n\t/*\n\t * Restore the thread's spinlock state and release it.\n\t */\n\trt_hw_spin_unlock_irqrestore(lock, level);\n\n\t/*\n\t * Restore the thread's state and release all mutexes the thread has\n\t * taken.\n\t */\n\tstate = thread->state;\n\tneed_resched = 0;\n\tneed_sched_locked = 0;\n\tif (state & RT_THREAD_STATE_MUTEX_LOCK) {\n\t\t/*\n\t\t * Yes, it has taken", "CodeBleu_score": 42.08863145370616}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n    rt_uint32_t level;\n\n    /* lock thread's spinlock */\n    level = rt_hw_interrupt_disable();\n    RT_ASSERT(thread->stat & RT_THREAD_STAT_SPIN_LOCK);\n\n    /* detach from mutex */\n    mutex = thread->wait_list.next;\n    if (mutex != RT_NULL) {\n        /* remove from mutex waiting list */\n        rt_list_remove(&(thread->wait_list));\n        /* clear pending object */\n        thread->wait_list.next = RT_NULL;\n        thread->wait_list.prev = RT_NULL;\n        thread->stat &= ~RT_THREAD_STAT_PEND_MASK;\n        /* release mutex */\n        rt_mutex_release(mutex);\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->stat & RT_THREAD_STAT_MUTEX_LOCK) {\n        mutex = thread->stat & ~RT_THREAD_STAT_MUTEX_LOCK;\n        thread->stat &= ~RT_THREAD_STAT_MUTEX_LOCK;\n        rt_mutex_release(mutex);\n    }\n\n    /* restore interrupt level */\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 46.124023200974484}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n    rt_base_t level;\n    rt_list_t *l;\n    rt_list_t *l_next;\n    rt_list_t *l_safe;\n    rt_list_t *l_safe_next;\n\n    level = rt_hw_interrupt_disable();\n    if (thread->mutex_list.next != thread->mutex_list.prev) {\n        for (l = thread->mutex_list.next; l != &(thread->mutex_list); l = l_next) {\n            l_next = l->next;\n            mutex = rt_list_entry(l, struct rt_mutex, wait_list);\n            rt_list_remove(l);\n            l_safe = l;\n            l_safe_next = l->next;\n            rt_hw_interrupt_enable(level);\n\n            rt_mutex_release(mutex);\n\n            level = rt_hw_interrupt_disable();\n            rt_list_remove(l_safe);\n            rt_hw_interrupt_enable(level);\n        }\n    }\n\n    if (thread->mutex_count) {\n        for (l = thread->mutex_list.next; l != &(thread->mutex_list); l = l_next) {\n            l_next = l->next;\n            mutex = rt_list_entry(l, struct rt_mutex, wait_list);\n            rt_list_remove(l);\n            l_safe = l;\n            l_safe_next = l->next;\n            rt_hw_interrupt_enable(level);\n\n            rt_mutex_release(mutex);\n\n            level = rt_hw_interrupt_disable();\n            rt_list_remove(l_safe);\n            rt_hw_interrupt_enable(level);\n        }\n    }\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 40.17619389623022}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    /* thread startup */\n    error = rt_sched_thread_startup(thread);\n    if (error != RT_EOK)\n    {\n        LOG_E(\"thread startup: %s\", thread->parent.name);\n    }\n\n    return error;\n}", "CodeBleu_score": 54.29189470508913}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    /* change thread status */\n    thread->stat = RT_THREAD_READY;\n\n    /* init schedule lock level */\n    thread->scheduler_lock_nest = 0;\n\n    /* init error number */\n    thread->error = RT_EOK;\n\n    /* init thread stack */\n    if (thread->stack_addr == RT_NULL)\n    {\n        thread->stack_addr = (rt_uint8_t *)rt_malloc(thread->stack_size);\n        if (thread->stack_addr == RT_NULL)\n        {\n            thread->stat = RT_THREAD_CLOSE;\n\n            LOG_E(\"no memory for thread stack!\");\n\n            return -RT_ENOMEM;\n        }\n    }\n\n    /* init thread sp */\n    thread->sp = (rt_uint32_t)thread->stack_addr + thread->stack_size;\n\n    /* init thread entry */\n    thread->entry = thread->thread_entry;\n\n    /* init thread cleanup */\n    thread->cleanup = thread->thread_cleanup;\n\n    /* init thread user_data */\n    thread->user_data = thread->user_data;\n\n    /* init thread error */\n    thread->error = RT_EOK;\n\n    /* init thread stack frame */\n    rt_hw_context_init(thread->stack_addr,\n                       (void (*)(void *parameter))thread->entry,\n                       thread->parameter,\n                       thread->sp);\n\n    /* resume thread */\n    error = rt_thread_resume(thread);\n    if (error != RT_EOK)\n    {\n        return error;\n    }\n\n    /* trigger scheduler */\n    rt_schedule();\n\n    return RT", "CodeBleu_score": 47.72572001063526}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n    {\n        return -RT_ERROR;\n    }\n\n    /* thread is initialized */\n    thread->stat = RT_THREAD_READY;\n\n    /* calculate priority attributes */\n    rt_sched_lock();\n    rt_sched_insert_thread(thread);\n    rt_sched_unlock();\n\n    /* resume thread */\n    error = rt_sched_thread_resume(thread);\n    if (error != RT_EOK)\n    {\n        return error;\n    }\n\n    /* trigger sched */\n    if (rt_thread_self() != thread)\n    {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 54.0355065420983}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_timer_entry_t timer_entry;\n\n    if (rt_list_isempty(timer_list)) return -RT_ERROR;\n\n    timer_entry = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n    *timeout_tick = timer_entry->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 66.42582424095849}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_tick_t tick;\n    rt_timer_t timer;\n    rt_list_t *list;\n\n    /* get the highest level of the timer skip list */\n    list = timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n    if (rt_list_isempty(list)) return -RT_EEMPTY;\n\n    /* get the first timer entry */\n    timer = rt_list_entry(list->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n    /* set the timeout tick */\n    tick = timer->timeout_tick;\n    *timeout_tick = tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 57.525400982357255}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_timer_t timer;\n    rt_tick_t timeout;\n\n    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ERROR;\n    }\n\n    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n    timeout = timer->timeout_tick;\n\n    /* find the next timeout tick */\n    for (int i = RT_TIMER_SKIP_LIST_LEVEL - 2; i >= 0; i--) {\n        if (!rt_list_isempty(&timer_list[i])) {\n            timer = rt_list_entry(timer_list[i].next, struct rt_timer, row[i]);\n            if (timeout > timer->timeout_tick) {\n                timeout = timer->timeout_tick;\n            }\n        }\n    }\n\n    *timeout_tick = timeout;\n\n    return RT_EOK;\n}", "CodeBleu_score": 65.88205756606547}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* allocate memory */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* register timer object to object management */\n    rt_object_register(rt_object_get_type(&timer->parent), timer, name);\n\n    return timer;\n}", "CodeBleu_score": 61.63212367230102}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check name */\n    RT_ASSERT(name != RT_NULL);\n    RT_ASSERT(strlen(name) < RT_NAME_MAX);\n\n    /* check timeout function */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* check time */\n    RT_ASSERT(time > 0);\n\n    /* allocate object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* initialize object */\n    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n    /* insert timer to timer list */\n    rt_timer_insert(timer);\n\n    return timer;\n}", "CodeBleu_score": 69.09695316254152}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    /* allocate object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) return timer;\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* initialize object */\n    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n    /* insert timer to timer list */\n    rt_timer_insert(timer);\n\n    return timer;\n}", "CodeBleu_score": 66.18081746116901}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\thandler := a.handler\n\tif handler == nil {\n\t\thandler = http.DefaultServeMux\n\t}\n\thandler.ServeHTTP(res, req)\n}", "CodeBleu_score": 68.7167951654628}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", rec.Code)\n\t\treturn\n\t}\n\thandler := a.router.Handler(req.URL.Path)\n\tif handler == nil {\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\thandler.ServeHTTP(res, req)\n}", "CodeBleu_score": 67.66956719405438}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", rec.Code)\n\t\treturn\n\t}\n\thandler := a.handler\n\tif handler != nil {\n\t\thandler.ServeHTTP(res, req)\n\t} else {\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t}\n}", "CodeBleu_score": 68.68094212670569}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  // TODO: Implement the \"robeaux\" function.\n\n\n  //", "CodeBleu_score": 2.29984901754818}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to the API struct\n\t// TODO: Add a logger to", "CodeBleu_score": 2.2998490336681834}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t//line views/robeaux/robeaux.html:11\n\tq := req.URL.Query()\n\tasset := q.Get(\"asset\")\n", "CodeBleu_score": 9.441403119512096}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\t// Find the robot using the master instance.\n\trobot := a.master.Robot(robotName)\n\t// If the robot is found, gather its connections and convert them to JSON format.\n\tif robot != nil {\n\t\t// Convert the connections to JSON format.\n\t\tconnections := robot.Connections()\n\t\tconnectionsJSON, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\t// Write the JSON response containing the connections.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(connectionsJSON)\n\t} else {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write([]byte(`{\"error\":\"no robot found with name \"` + robotName + `\"\"}`))\n\t}\n}", "CodeBleu_score": 38.34193458181067}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\t// Find the robot using the master instance.\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\ta.writeJSON(res, req, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"robot not found: %v\", err)})\n\t\treturn\n\t}\n\n\t// Gather the robot's connections.\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format.\n\tconnectionsJSON, err := connections.JSON()\n\tif err != nil {\n\t\ta.writeJSON(res, req, http.StatusInternalServerError, map[string]string{\"error\": fmt.Sprintf(\"error converting connections to JSON: %v\", err)})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections.\n\ta.writeJSON(res, req, http.StatusOK, connectionsJSON)\n}", "CodeBleu_score": 42.13004149608627}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/connections/\")\n\n\t// Find the robot using the master instance\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\t// If the robot is not found, write an error message\n\t\ta.writeJSON(res, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON := connections.ToJSON()\n\n\t// Write the JSON response containing the connections\n\ta.writeJSON(res, connectionsJSON)\n}", "CodeBleu_score": 29.929739520690035}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If all is good, continue with the request\n\t\tr.Header.Del(\"Authorization\")\n\t}\n}", "CodeBleu_score": 55.271113490359426}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), 401)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\t// Authentication successful\n\t\t// Do not forward the Authorization header to the final destination\n\t\t// See https://github.com/golang/go/issues/12620\n\t\tr.Header.Del(\"Authorization\")\n\t}\n}", "CodeBleu_score": 47.935698494328214}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(u, username) || !secureCompare(p, password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.77827186366433}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (float64(toMax) - float64(toMin)) / (float64(fromMax) - float64(fromMin))\n\tintercept := float64(toMin) - (slope * float64(fromMin))\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(math.Min(slope*input+intercept, float64(toMax)), float64(toMin)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 48.80041464696736}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t// calculate the slope and intercept for the scaling transformation\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\t// create the scaling function\n\treturn func(input float64) (value int) {\n\t\t// calculate the scaled value\n\t\tvalue = int(slope*input + intercept)\n\t\t// ensure the value is within the target range\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.42414133094553}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.468143608272165}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"connection is nil\")\n\t}\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0.0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\trawValue, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\ta.sensorCfg.lastRawValue = rawValue\n\ta.sensorCfg.lastScaledValue = a.sensorCfg.scale.Convert(rawValue)\n\treturn rawValue, a.sensorCfg.lastScaledValue, nil\n}", "CodeBleu_score": 54.67061056620713}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"invalid connection\")\n\t}\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0.0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\trawValue, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"analog read failed: %v\", err)\n\t}\n\ta.sensorCfg.LastRawValue = rawValue\n\ta.sensorCfg.LastScaledValue = a.sensorCfg.Scale(rawValue)\n\treturn rawValue, a.sensorCfg.LastScaledValue, nil\n}", "CodeBleu_score": 50.65831309197777}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: Connection is nil\")\n\t}\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: Connection does not support analog read\")\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"analogSensorRead: %v\", err)\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = raw * a.sensorCfg.scale\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 48.553085444252055}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 51.66430623464202}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 51.66430623464202}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tslope := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tintercept := toMin - (slope * float64(fromMin))\n\treturn func(input int) float64 {\n\t\treturn slope * float64(input) + intercept\n\t}\n}", "CodeBleu_score": 49.267674282855836}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:       gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:        pin,\n\t\tanalogRead: a,\n\t\tthreshold:  1000,\n\t}\n\td.AddEvent(Vibration)\n\tif err := d.AddEvent(Data); err != nil {\n\t\tpanic(err)\n\t}\n\td.AddEvent(gobot.Every(10*time.Millisecond, func() {\n\t\tif d.analogRead.Read(d.pin) > d.threshold {\n\t\t\td.Publish(Vibration, true)\n\t\t} else {\n\t\t\td.Publish(Vibration, false)\n\t\t}\n\t}))\n\treturn d\n}", "CodeBleu_score": 45.82152668450284}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tvar options = make(map[string]interface{})\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase gobot.Nameer:\n\t\t\toptions[optionName] = opt.(gobot.Nameer).Name()\n\t\tcase gobot.Events:\n\t\t\toptions[optionEvents] = opt.(gobot.Events)\n\t\tcase gobot.Publisher:\n\t\t\toptions[optionPublisher] = opt.(gobot.Publisher)\n\t\tcase gobot.Eventer:\n\t\t\toptions[optionEventer] = opt.(gobot.Eventer)\n\t\tcase gobot.Commander:\n\t\t\toptions[optionCommander] = opt.(gobot.Commander)\n\t\t}\n\t}\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:               gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:                pin,\n\t\tanalogReader:       a,\n\t\tvibrationThreshold: 1000,\n\t\tdata:               0,\n\t\tevent:              \"vibration\",\n\t\tevents:             gobot.DefaultEvents(),\n\t\tpublisher:          gobot.DefaultPublisher,\n\t\teventer:            gobot.DefaultEventer,\n\t\twork:               func(data interface{}) {\n\t\t\td.data = data.(int)\n\t\t\tif d.data >= d.vibrationThreshold {\n\t\t\t\td.Publish(d.event, d.data)\n\t\t\t}\n\t\t},\n\t}\n\n\td.AddEvent(d.event)\n\n\tif eventer, ok := options[optionEventer].(gobot.Eventer); ok {\n\t\td.AddEvent(eventer.Event(d.event))\n\t}\n\n\tif events, ok := options[optionEvents].(gobot.Events); ok {\n\t\tfor event := range events.List() {\n\t\t\td.AddEvent(event)\n\t\t}\n\t}", "CodeBleu_score": 33.54420167202629}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Initialize the driver.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: DefaultName,\n\t\ta:    a,\n\t\tpin:  pin,\n\t}\n\n\t// Set up the event listener.\n\tif err := d.AddEvent(Vibration, gobot.DefaultName(Vibration), func(data interface{}) {\n\t\tif data.(int) >= 1000 {\n\t\t\td.Publish(Vibration, true)\n\t\t} else {\n\t\t\td.Publish(Vibration, false)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Set up the default name.\n\td.SetName(DefaultName)\n\n\t// Return the driver.\n\treturn d\n}", "CodeBleu_score": 47.60177862177253}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif d.IsConnected() == false {\n\t\treturn errors.New(\"buzzer is not connected\")\n\t}\n\n\tif hz <= 0 || duration <= 0 {\n\t\treturn errors.New(\"frequency and duration must be greater than 0\")\n\t}\n\n\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\tperiod := 1 / (hz * d.Tempo)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < int(duration/period); i++ {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(time.Duration(period * 1000) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 55.26464608020931}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\tperiod := time.Duration(float64(time.Second) / hz)\n\t// Calculate the tempo based on the buzzer's beats per minute (bpm).\n\tbpm := d.BeatsPerMinute\n\t// Calculate the number of tones to play based on the duration.\n\ttones := int(duration / float64(period))\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < tones; i++ {\n\t\t// Turn the buzzer on.\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Wait for the tone period.\n\t\ttime.Sleep(period)\n\t\t// Turn the buzzer off.\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Wait for the tone period.\n\t\ttime.Sleep(period)\n\t}\n\t// Return success.\n\treturn nil\n}", "CodeBleu_score": 53.08215058325245}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif err := d.Enable(); err != nil {\n\t\treturn err\n\t}\n\tdefer d.Disable()\n\treturn d.tone(hz, duration)\n}", "CodeBleu_score": 23.506927928350528}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin < 0 {\n\t\treturn fmt.Errorf(\"Sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 29.97244770557445}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == 0 {\n\t\treturn fmt.Errorf(\"no sleep pin configured\")\n\t}\n\tif d.sleepPin == d.resetPin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as reset pin\")\n\t}\n\tif d.sleepPin == d.enablePin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as enable pin\")\n\t}\n\tif d.sleepPin == d.dirPin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as dir pin\")\n\t}\n\tif d.sleepPin == d.stepPin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as step pin\")\n\t}\n\tif d.sleepPin == d.ms1Pin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as ms1 pin\")\n\t}\n\tif d.sleepPin == d.ms2Pin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as ms2 pin\")\n\t}\n\tif d.sleepPin == d.ms3Pin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as ms3 pin\")\n\t}\n\tif d.sleepPin == d.ms4Pin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as ms4 pin\")\n\t}\n\tif d.sleepPin == d.brakePin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as brake pin\")\n\t}\n\tif d.sleepPin == d.enablePin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as enable pin\")\n\t}\n\tif d.sleepPin == d.enablePin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as enable pin\")\n\t}\n\tif d.sleepPin == d.enablePin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same as enable pin\")\n\t}\n\tif d.sleepPin == d.enablePin {\n\t\treturn fmt.Errorf(\"sleep pin cannot be the same", "CodeBleu_score": 17.21179513807016}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"Sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, gpio.Low)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.394983097578816}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.Pins == nil {\n\t\treturn nil, fmt.Errorf(\"analogPin called before analogPins initialized\")\n\t}\n\tif pin, ok := a.Pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.Pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 53.688226664924954}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.Pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map is not initialized\")\n\t}\n\tif pin, ok := a.Pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.Pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.31211482232994}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\ta.pinsMutex.Lock()\n\tdefer a.pinsMutex.Unlock()\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 54.04847357129682}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.GetPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 64.50239852122381}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\ta.pin, err = a.GetDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta.pin, err = a.pin.WithDirection(gpio.Out)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = a.pin.Write(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.555052978561434}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\ta.pin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn a.pin.Write(val)\n}", "CodeBleu_score": 58.03436613780762}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.connectedPins) == 0 {\n\t\treturn nil, errors.New(\"No pins connected\")\n\t}\n\n\t// append options to existing options\n\topts = append(opts, a.translate)\n\n\t// retrieve existing pin\n\tpin, ok := a.pins[id]\n\n\t// create new pin if it doesn't exist\n\tif !ok {\n\t\t// translate id to chip and line\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// create new pin\n\t\tpin = a.NewDigitalPin(chip, line)\n\t\tif err := pin.Init(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// store new pin\n\t\ta.pins[id] = pin\n\t}\n\n\t// apply options\n\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 57.85073854532429}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.connected {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"No pins configured\")\n\t}\n\tpin, err := a.pin(id)\n\tif err != nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin, err = a.initialize(chip, line)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin.ApplyOptions(opts...)\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 57.753250874674286}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins()) == 0 {\n\t\treturn nil, errors.New(\"No pins defined for DigitalPinsAdaptor\")\n\t}\n\tpin := a.Pins()[id]\n\tif pin == nil {\n\t\tif chip, line, err := a.translate(id); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tpin = a.NewDigitalPin(chip, line)\n\t\t\tif err := a.initialize(pin); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ta.Pins()[id] = pin\n\t\t}\n\t}\n\tpin.ApplyOptions(opts...)\n\treturn pin, nil\n}", "CodeBleu_score": 50.42156393419744}]}
