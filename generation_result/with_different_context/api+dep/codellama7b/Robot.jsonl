{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    // Check if the file exists locally\n    for (auto &file : files) {\n      if (download) {\n        // If the file does not exist locally, request it\n        if (!FileTransfer::FileExists(file)) {\n          RequestFile(file);\n          log_info(\"Downloaded file {}\", file);\n        }\n        else {\n          log_info(\"File {} found in cache\", file);\n        }\n      }\n    }\n    return files;\n  }", "CodeBleu_score": 67.84087975122347}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    // If the download flag is set to true\n    if (download) {\n      // For each file in the required files\n      for (auto &file : required_files) {\n        // If the file does not exist locally\n        if (!FileTransfer::FileExists(file)) {\n          // Request the file\n          RequestFile(file);\n          // Log the download action\n          log_info(\"Downloaded file \" + file + \" from \" + folder);\n        }\n        // Otherwise\n        else {\n          // Log that the file is found in the cache\n          log_info(\"File \" + file + \" found in cache\");\n        }\n      }\n    }\n    // Return the list of required files\n    return required_files;\n  }", "CodeBleu_score": 68.67922031553458}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if each file exists locally\n    for (const auto &file : required_files) {\n      if (download) {\n        if (!FileTransfer::FileExists(file)) {\n          // Request the file\n          RequestFile(file);\n          // Log the download action\n          log_info(\"Downloaded file: \" + file);\n        } else {\n          // Log that the file is found in the cache\n          log_info(\"Found file: \" + file);\n        }\n      }\n    }\n\n    return required_files;\n  }", "CodeBleu_score": 65.87560051371246}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tstd::string error;\n  rpc::Actor actor;\n  if (parent != rpc::ActorId::kNull) {\n    const auto parent_actor = _pimpl->GetActor(parent, error);\n    if (parent_actor == nullptr) {\n      return actor;\n    }\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.location.z != 0.f) {\n        if (std::fabs(transform.location.z) > 1.f) {\n          carla::log_warning(\"SpawnActorWithParent\",\n              \"The SpringArm attachment type is not valid when the translation is not in the 'z' axis\");\n        }\n      }\n    }\n    actor = _pimpl->CallAndWait<rpc::Actor>(\n        [&](auto &ctx) {\n          return ctx.client.call(\n              ctx.xrpc_actor_spawn_actor_with_parent,\n              description,\n              transform,\n              parent,\n              attachment_type,\n              socket_name);\n        });\n  } else {\n    actor = _pimpl->CallAndWait<rpc::Actor>(\n        [&](auto &ctx) {\n          return ctx.client.call(\n              ctx.xrpc_actor_spawn_actor,\n              description,\n              transform,\n              attachment_type,\n              socket_name);\n        });\n  }\n  return actor;\n}", "CodeBleu_score": 53.12005751305981}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t// Check if the socket name is valid\n  if (socket_name.empty()) {\n    throw std::invalid_argument(\n        \"Socket name cannot be empty. Please specify a valid socket name.\");\n  }\n\n  // Check if the attachment type is valid\n  if (attachment_type != rpc::AttachmentType::SpringArm &&\n      attachment_type != rpc::AttachmentType::SpringArmGhost) {\n    throw std::invalid_argument(\n        \"Invalid attachment type. Please specify a valid attachment type.\");\n  }\n\n  // Check if the parent is valid\n  if (!parent.IsValid()) {\n    throw std::invalid_argument(\n        \"Invalid parent. Please specify a valid parent.\");\n  }\n\n  // Check if the actor description is valid\n  if (!description.IsValid()) {\n    throw std::invalid_argument(\n        \"Invalid actor description. Please specify a valid actor description.\");\n  }\n\n  // Check if the actor description is valid\n  if (!transform.IsValid()) {\n    throw std::invalid_argument(\n        \"Invalid transform. Please specify a valid transform.\");\n  }\n\n  // Check if the attachment type is valid\n  if (!transform.IsValid()) {\n    throw std::invalid_argument(\n        \"Invalid transform. Please specify a valid transform.\");\n  }\n\n  // Check if the attachment type is valid\n  if (!transform.IsValid()) {\n    throw std::invalid_argument(\n        \"Invalid transform. Please specify a valid transform.\");\n  }\n\n  // Check if the attachment type is valid\n  if (!transform.IsValid()) {\n    throw std::invalid_argument(\n        \"Invalid transform. Please specify a valid transform.\");\n  }\n\n  // Check if the attachment type is valid\n  if (!transform.IsValid()) {\n    throw std::invalid_argument(\n        \"Invalid transform. Please specify a valid transform.\");\n  }\n\n  // Check if the attachment type is valid\n  if (!transform.IsValid()) {\n    throw std::invalid_argument(\n        \"Invalid transform. Please specify a valid transform.\");\n  }\n\n  // Check if the attachment type is valid\n  if (!transform.IsValid()) {\n    throw std::invalid_", "CodeBleu_score": 34.483814699789285}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t// TODO: this is a workaround to avoid spawning invalid actors.\n    // We should fix this in the server side.\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.location.x == 0.0f &&\n          transform.location.y == 0.0f &&\n          transform.location.z != 0.0f) {\n        std::cerr << \"WARNING: Spawning an actor with only a translation in the 'z' axis. This is not allowed. Please use a different attachment type or a different location.\" << std::endl;\n      }\n    }\n\n    // We create the actor description.\n    rpc::Actor actor = _pimpl->CallAndWait<rpc::Actor>(\n        \"spawn_actor_with_parent\",\n        description,\n        transform,\n        parent,\n        attachment_type,\n        socket_name);\n\n    // We add the actor to the list of actors.\n    _pimpl->actors.insert(actor.id);\n\n    // We return the actor.\n    return actor;\n  }", "CodeBleu_score": 54.42774997314507}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\"GetGBufferToken\", ActorId, GBufferId);\n  // Copy the token data\n  std::vector<unsigned char> token;\n  token.resize(token_data.size());\n  std::memcpy(token.data(), token_data.data(), token_data.size());\n  // Subscribe to the streaming client\n  _pimpl->streaming_client.Subscribe(token, callback);\n}", "CodeBleu_score": 67.39889136505235}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer\n  auto token = _pimpl->CallAndWait<rpc::Token>(\"GetGBufferToken\", ActorId, GBufferId);\n\n  // Copy the token data\n  std::vector<unsigned char> token_data;\n  token_data.resize(token.size);\n  std::memcpy(token_data.data(), token.data, token.size);\n\n  // Subscribe to the streaming client using the provided callback function\n  _pimpl->streaming_client.Subscribe(token_data, callback);\n}", "CodeBleu_score": 60.76519571617588}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tauto token = _pimpl->CallAndWait<rpc::Token>(\"SubscribeToGBuffer\", ActorId, GBufferId);\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\"GetTokenData\", token);\n  std::vector<unsigned char> data(token_data.size());\n  std::memcpy(data.data(), token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(\n      std::move(data),\n      callback);\n}", "CodeBleu_score": 60.67948409938191}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation;\n  while (!_walker_navigation.compare_exchange_strong(navigation, std::make_shared<WalkerNavigation>())) {}\n  return navigation;\n}", "CodeBleu_score": 29.897891477099353}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n  while (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>();\n    if (_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n      break;\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 54.24695569943094}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation;\n    while (!_walker_navigation.compare_exchange_weak(navigation, std::make_shared<WalkerNavigation>())) {\n    }\n    return navigation;\n}", "CodeBleu_score": 30.932836534383956}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tauto start_time = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrameNumber() < frame) {\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start_time) > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetState()->Tick(timeout.to_chrono());\n  return true;\n}", "CodeBleu_score": 45.66010257118973}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\twhile (episode.GetState()->GetFrameNumber() < frame) {\n    std::this_thread::yield();\n  }\n  auto start = std::chrono::system_clock::now();\n  while (true) {\n    if (episode.GetState()->GetFrameNumber() >= frame) {\n      carla::traffic_manager::TrafficManager::GetInstance()->Tick(timeout.to_chrono());\n      return true;\n    }\n    auto current = std::chrono::system_clock::now();\n    if (current - start > timeout.to_chrono()) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n}", "CodeBleu_score": 55.56323029736747}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\twhile (episode.GetState()->GetFrameNumber() < frame) {\n    std::this_thread::yield();\n  }\n  auto tm = episode.GetWorld().GetTrafficManager();\n  tm->Tick(timeout.to_chrono());\n  return true;\n}", "CodeBleu_score": 26.533849902130246}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t// Get the current episode ID\n    auto current_episode_id = GetCurrentEpisode().GetId();\n    // Set the new episode ID\n    auto new_episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n    // Wait for the new episode to be ready\n    _client.WaitForEpisode(new_episode_id);\n    // Check if the new episode is ready\n    if (new_episode_id == GetCurrentEpisode().GetId()) {\n      throw std::runtime_error(\"Failed to load episode \" + map_name);\n    }\n    // Return the new episode\n    return EpisodeProxy{shared_from_this()};\n  }", "CodeBleu_score": 36.11073859231267}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t// Get the current episode ID\n    std::string current_episode_id = GetCurrentEpisode().GetId();\n\n    // Create a new episode with the specified map name\n    auto request = std::make_shared<rpc::LoadEpisode>(map_name, reset_settings, map_layers);\n    // Send the request to the simulator\n    _client.Send(request);\n\n    // Wait for the episode to be loaded\n    uint64_t attempts = 0;\n    while (GetCurrentEpisode().GetId() == current_episode_id) {\n      // If we have reached the maximum number of attempts, throw an exception\n      if (attempts >= _client.GetTimeout().milliseconds() / 10) {\n        throw std::runtime_error(\"Unable to load episode\");\n      }\n      // Sleep for 10ms\n      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n      ++attempts;\n    }\n\n    // Return the episode proxy\n    return EpisodeProxy{shared_from_this()};\n  }", "CodeBleu_score": 50.271656749323114}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t// Create a new episode proxy.\n    EpisodeProxy episode_proxy{shared_from_this()};\n\n    // Load the episode.\n    auto request = std::make_shared<rpc::LoadEpisode>(map_name, reset_settings, map_layers);\n    auto response = _client.sendRpcAndWait(request);\n    if (!response->episode_id.empty()) {\n      // Set the episode ID.\n      _episode_id = response->episode_id;\n      // Set the episode settings.\n      _episode_settings = response->settings;\n      // Set the episode start system time.\n      _episode_start_system_time = std::chrono::system_clock::now();\n      // Set the episode start game time.\n      _episode_start_game_time = response->start_time;\n      // Set the episode start delta time.\n      _episode_start_delta_time = response->start_time;\n      // Set the episode start frame number.\n      _episode_start_frame_number = response->start_frame;\n      // Set the episode start snapshot time.\n      _episode_start_snapshot_time = response->start_snapshot_time;\n      // Set the episode start snapshot frame number.\n      _episode_start_snapshot_frame_number = response->start_snapshot_frame;\n      // Set the episode start snapshot game time.\n      _episode_start_snapshot_game_time = response->start_snapshot_time;\n      // Set the episode start snapshot delta time.\n      _episode_start_snapshot_delta_time = response->start_snapshot_time;\n    } else {\n      throw std::runtime_error(\"Failed to load episode.\");\n    }\n\n    // Return the episode proxy.\n    return episode_proxy;\n  }", "CodeBleu_score": 36.21289841752419}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t// TODO: Check if the controller is already registered.\n  // TODO: Check if the controller's episode is the same as the simulator's episode.\n  // TODO: Check if the controller's walker is null.\n  // TODO: Check if the controller's episode is null.\n  // TODO: Check if the controller's episode is not the same as the simulator's episode.\n\n  // Get the walker associated with the controller.\n  Walker *walker = _episode->GetWalker(controller.GetWalkerId());\n  // TODO: Check if the walker is null.\n  // TODO: Check if the walker's episode is the same as the simulator's episode.\n\n  // TODO: Create navigation if it is missing.\n\n  // Register the walker with the controller's ID.\n  nav->RegisterWalker(controller.GetId(), walker->GetId());\n}", "CodeBleu_score": 28.169349968292728}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t// TODO: This function should be renamed to RegisterWalker.\n  // TODO: This function should take a pointer to a walker.\n  // TODO: This function should not throw an exception.\n  // TODO: This function should not assert.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call throw_exception.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std::runtime_error.\n  // TODO: This function should not call std", "CodeBleu_score": 3.36716990766008}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tstd::shared_ptr<Walker> walker = GetWalker(controller.GetId());\n    DEBUG_ASSERT(walker != nullptr);\n    std::shared_ptr<Navigation> nav = _episode->GetNavigation();\n    DEBUG_ASSERT(nav != nullptr);\n    nav->RegisterWalker(controller.GetId(), controller.GetDisplayId());\n}", "CodeBleu_score": 54.879419187445365}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tif (!blueprint.IsValid()) {\n      throw std::runtime_error(\"Invalid actor blueprint\");\n    }\n    // Get the current episode.\n    auto current_episode = GetCurrentEpisode();\n    if (current_episode == nullptr) {\n      throw std::runtime_error(\"No episode available\");\n    }\n    // Spawn the actor.\n    auto actor = current_episode->MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n    // Register the actor.\n    current_episode->RegisterActor(actor, gc);\n    // Log the actor creation.\n    LogActorCreation(blueprint, actor, transform, parent, attachment_type, socket_name);\n    // Return the actor.\n    return actor;\n  }", "CodeBleu_score": 44.58859235907972}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tauto actor = ActorFactory::MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n    if (gc == GarbageCollectionPolicy::KeepAcrossScenes) {\n      _episode->RegisterActor(actor);\n    } else {\n      _episode->RegisterActor(actor, gc);\n    }\n    if (actor->GetId() != 0u) {\n      log_debug(\"spawned actor\", actor->GetId(), \"with blueprint\", actor->GetActorBlueprint().id);\n    }\n    return actor;\n  }", "CodeBleu_score": 38.01140760137698}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tSharedPtr<Actor> actor = nullptr;\n    if (parent) {\n      actor = ActorFactory::MakeActor(blueprint, parent, attachment_type, socket_name);\n    } else {\n      actor = ActorFactory::MakeActor(blueprint, transform);\n    }\n    RegisterActor(actor, gc);\n    log_debug(\"spawned actor\", actor->GetId(), actor->GetDescription().id);\n    return actor;\n  }", "CodeBleu_score": 37.79383767590744}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t// Ensure the episode is valid\n  if (!IsEpisodeRunning()) {\n    throw std::runtime_error(\"Episode is not running\");\n  }\n  // Subscribe to the sensor's data stream\n  _client.SubscribeToStream(sensor.GetActorDescription().GetStreamToken(),\n                            [this, sensor, callback](\n                                const std::string &stream,\n                                const std::string &message) {\n                              // Deserialize the data\n                              SharedPtr<sensor::SensorData> data =\n                                  sensor.Deserialize(stream, message);\n                              // Associate the data with the current episode\n                              data->SetEpisode(GetCurrentEpisode());\n                              // Invoke the callback\n                              callback(data);\n                            });\n}", "CodeBleu_score": 39.003494329136515}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t// Ensure the episode is valid.\n  if (!episode_) {\n    throw std::logic_error(\n        \"Attempted to subscribe to a sensor before setting the episode.\");\n  }\n\n  // Subscribe to the sensor's data stream.\n  auto stream_token = sensor.GetActorDescription().GetStreamToken();\n  _client.SubscribeToStream(stream_token, [this, &sensor, callback](\n      const std::string &stream_token,\n      const std::string &message) {\n    // Deserialize the message.\n    auto sensor_data = sensor.Deserialize(message);\n    // Associate the message with the current episode.\n    sensor_data->SetEpisode(episode_);\n    // Invoke the callback.\n    callback(sensor_data);\n  });\n}", "CodeBleu_score": 43.59382748017434}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t// Check that the episode is valid\n  if (!IsEpisodeReady()) {\n    throw std::runtime_error(\n        \"Episode is not ready. Call Simulator::BeginEpisode() before \"\n        \"subscribing to sensors.\");\n  }\n\n  // Subscribe to the sensor's data stream\n  _client.SubscribeToStream(sensor.GetActorDescription().GetStreamToken(),\n                            sensor.GetName());\n\n  // Set up a callback to handle the incoming sensor data\n  _client.SetCallback(\n      [this, callback, sensor](const std::string &stream,\n                               const std::string &message) {\n        // Deserialize the incoming data\n        SharedPtr<sensor::SensorData> data =\n            sensor::Deserialize(stream, message);\n\n        // Associate the data with the current episode\n        data->episode_id = _episode->GetEpisodeId();\n\n        // Invoke the provided callback\n        callback(data);\n      });\n}", "CodeBleu_score": 41.59479714681697}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// load the walkers\n    auto walkers = _walkers.Load(episode);\n    if (walkers.empty()) {\n      return;\n    }\n\n    // check if the walkers are still in the episode\n    CheckIfWalkerExist(walkers, *episode->GetState());\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, true);\n\n    // update the crowd\n    _nav.UpdateCrowd();\n\n    // get the current state of the episode\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // create the batch\n    auto commands = std::vector<carla::command::Command>();\n    commands.reserve(walkers.size());\n\n    // get the transforms and speeds of the walkers\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n      // get the speed\n      float speed = _nav.GetWalkerSpeed(walker.walker);\n      // get the transform\n      Transform transform = snapshot.transform;\n      // create the command\n      commands.emplace_back(carla::command::ApplyTransform(walker.walker, transform));\n      commands.emplace_back(carla::command::ApplyVelocity(walker.walker, carla::geom::Vector3D(speed, 0.0f, 0.0f)));\n    }\n\n    // apply the batch\n    _simulator.lock()->ApplyBatchSync(commands, true);\n\n    // check if any walker is dead\n    for (auto &&walker : walkers) {\n      if (_nav.IsWalkerAlive(walker.walker)) {\n        continue;\n      }\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);", "CodeBleu_score": 55.13246913335178}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// load the current walkers\n    std::vector<WalkerHandle> walkers = _walkers.Load(episode);\n    if (walkers.empty()) return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // check if the walkers exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd itself\n    _nav.UpdateCrowd();\n\n    // get the commands for each walker\n    std::vector<carla::nav::WalkerCommand> commands;\n    commands.reserve(walkers.size());\n    for (auto &&walker : walkers) {\n      // get the transform and speed\n      auto transform = state->GetActorSnapshot(walker.walker).transform;\n      auto speed = _nav.GetWalkerSpeed(walker.walker);\n      // add to the vector\n      commands.emplace_back(carla::nav::WalkerCommand{walker.walker, transform, speed});\n    }\n\n    // apply the commands in a batch\n    _simulator.lock()->ApplyBatchSync(commands);\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      if (_nav.IsWalkerAlive(walker.walker)) continue;\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }", "CodeBleu_score": 53.497711532748916}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // get the walkers\n  std::vector<WalkerHandle> walkers = _walkers.Load(episode);\n\n  // check if empty\n  if (walkers.empty()) return;\n\n  // check if walkers exist\n  CheckIfWalkerExist(walkers, *state);\n\n  // update vehicles in crowd\n  UpdateVehiclesInCrowd(episode, false);\n\n  // update the crowd\n  _nav.UpdateCrowd(state->GetFrameNumber());\n\n  // get the walker transforms\n  std::vector<carla::geom::Transform> walker_transforms;\n  for (auto &&walker : walkers) {\n    // get the transform\n    carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n    // add to the vector\n    walker_transforms.emplace_back(transform);\n  }\n\n  // get the walker speeds\n  std::vector<float> walker_speeds;\n  for (auto &&walker : walkers) {\n    // get the speed\n    float speed = _nav.GetWalkerSpeed(walker.walker);\n    // add to the vector\n    walker_speeds.emplace_back(speed);\n  }\n\n  // apply the batch\n  _simulator.lock()->ApplyBatchSync(walker_transforms, walker_speeds, false);\n\n  // check if any walkers have died\n  for (auto &&walker : walkers) {\n    // check if dead\n    if (!_simulator.lock()->IsActorAlive(walker.walker)) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n\n}", "CodeBleu_score": 54.194598145989204}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.id = id_;\n  description.type = type_;\n  description.attributes.reserve(attributes_.size());\n  for (const auto &attribute : attributes_) {\n    description.attributes.push_back(attribute.second->Clone());\n  }\n  return description;\n}", "CodeBleu_score": 73.48892061071028}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.id = id_;\n  description.parent_id = parent_id_;\n  description.attributes.reserve(attributes_.size());\n  for (const auto &attribute : attributes_) {\n    description.attributes.push_back(attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 73.68101622646259}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.id = id_;\n  description.parent_id = parent_id_;\n  description.parent_name = parent_name_;\n  description.attributes.reserve(attributes_.size());\n  for (const auto &attribute : attributes_) {\n    description.attributes.push_back(attribute.second->GetRPC());\n  }\n  return description;\n}", "CodeBleu_score": 70.56077019869976}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t// TODO: add support for recommended values\n  std::vector<Blueprint> result;\n  for (auto &pair : blueprints_) {\n    if (pair.second.ContainsAttribute(name)) {\n      const std::string& attribute_value = pair.second.GetAttribute(name);\n      if (attribute_value == value) {\n        result.emplace_back(pair.first);\n      }\n    }\n  }\n  return std::make_shared<BlueprintLibrary>(result);\n}", "CodeBleu_score": 39.232717688730524}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tBlueprintLibrary result;\n    for (const auto& pair : blueprints) {\n      if (pair.second.ContainsAttribute(name)) {\n        const auto& attribute = pair.second.GetAttribute(name);\n        if (attribute.GetValue() == value || attribute.GetRecommendedValues().contains(value)) {\n          result.emplace(pair.first, pair.second);\n        }\n      }\n    }\n    return result;\n  }", "CodeBleu_score": 42.76700873226997}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tstd::vector<Blueprint> result;\n    for (const Blueprint &bp : *this) {\n      if (bp.ContainsAttribute(name)) {\n        const Attribute &attr = bp.GetAttribute(name);\n        if (attr.GetValue() == value) {\n          result.emplace_back(bp);\n        } else {\n          for (const std::string &val : attr.GetRecommendedValues()) {\n            if (val == value) {\n              result.emplace_back(bp);\n              break;\n            }\n          }\n        }\n      }\n    }\n    return MakeShareable(new BlueprintLibrary(result));\n  }", "CodeBleu_score": 56.72703628875448}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Construct the full file path using a base folder and version information.\n\tstd::string full_path = FileTransfer::ConstructFullPath(path);\n\t// Validate the file path.\n\tif (!FileTransfer::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\t// Open the file in binary mode to truncate its contents.\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\t// If the file is successfully opened, write the content and close the file.\n\tif (out.good()) {\n\t\tout.write(reinterpret_cast<const char*>(content.data()), content.size());\n\t\tout.close();\n\t\treturn true;\n\t}\n\t// If the file cannot be opened, return false.\n\treturn false;\n}", "CodeBleu_score": 44.62511224058634}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string file_path = ConstructFilePath(path);\n    if (carla::FileSystem::ValidateFilePath(file_path)) {\n        std::ofstream out(file_path, std::ios::binary | std::ios::trunc);\n        if (out.good()) {\n            out.write(reinterpret_cast<char*>(content.data()), content.size());\n            out.close();\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 48.50900725913715}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = baseFolder + path;\n    if (!carla::FileSystem::ValidateFilePath(fullPath)) {\n        return false;\n    }\n\n    std::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n    if (out.good()) {\n        out.write(reinterpret_cast<const char*>(content.data()), content.size());\n        out.close();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 49.30184724756616}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto &location = transform.location;\n    const auto &extents = transform.extents;\n    const auto &yaw = transform.rotation.yaw;\n    const auto &pitch = transform.rotation.pitch;\n    const auto &roll = transform.rotation.roll;\n    const auto &x = location.x;\n    const auto &y = location.y;\n    const auto &z = location.z;\n    const auto &ex = extents.x;\n    const auto &ey = extents.y;\n    const auto &ez = extents.z;\n    const auto &cx = x + ex * std::cos(yaw);\n    const auto &cy = y + ex * std::sin(yaw);\n    const auto &cz = z + ez;\n    const auto &dx = x + ex * std::cos(yaw + geom::Math::Pi<float>() / 2.0f);\n    const auto &dy = y + ex * std::sin(yaw + geom::Math::Pi<float>() / 2.0f);\n    const auto &dz = z + ez;\n    const auto &bx = x + ex * std::cos(yaw - geom::Math::Pi<float>() / 2.0f);\n    const auto &by = y + ex * std::sin(yaw - geom::Math::Pi<float>() / 2.0f);\n    const auto &bz = z + ez;\n    const auto &ax = x + ex * std::cos(yaw + geom::Math::Pi<float>());\n    const auto &ay = y + ex * std::sin(yaw + geom::Math::Pi<float>());\n    const auto &az = z + ez;\n    return std::make_shared<Bounds>(\n        frame,\n        cx, cy, cz,\n        dx, dy, dz,\n        bx, by, bz,\n        ax, ay, az);\n  }", "CodeBleu_score": 38.286490084586745}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto location = transform.location + parent_->GetBounds(frame).location;\n    const auto corners = std::array<geom::Location, 4>{\n        geom::Location{\n            -transform.extents.x,\n            -transform.extents.y},\n        geom::Location{\n            transform.extents.x,\n            -transform.extents.y},\n        geom::Location{\n            transform.extents.x,\n            transform.extents.y},\n        geom::Location{\n            -transform.extents.x,\n            transform.extents.y}};\n    return std::make_shared<Bounds>(frame, Rotate(transform.rotation.yaw, location), corners);\n  }", "CodeBleu_score": 39.04512934552983}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto &location = transform.location();\n    const auto &extents = transform.extents();\n    const auto &yaw = transform.rotation().yaw();\n    const auto &pitch = transform.rotation().pitch();\n    const auto &roll = transform.rotation().roll();\n    const auto &x = location.x;\n    const auto &y = location.y;\n    const auto &z = location.z;\n    const auto &ex = extents.x;\n    const auto &ey = extents.y;\n    const auto &ez = extents.z;\n    const auto &cx = x + ex * std::cos(yaw);\n    const auto &cy = y + ex * std::sin(yaw);\n    const auto &cz = z + ez * std::cos(pitch);\n    const auto &cyy = y - ex * std::sin(yaw);\n    const auto &czz = z - ez * std::cos(pitch);\n    const auto &cyyy = y + ex * std::sin(yaw);\n    const auto &czzz = z + ez * std::cos(pitch);\n    const auto &cxx = x - ex * std::cos(yaw);\n    const auto &cyxx = y + ex * std::sin(yaw);\n    const auto &czxx = z - ez * std::cos(pitch);\n    const auto &cxxx = x + ex * std::cos(yaw);\n    const auto &cyxxx = y - ex * std::sin(yaw);\n    const auto &czxxx = z + ez * std::cos(pitch);\n    return std::make_shared<Bounds>(\n        frame,\n        geom::Location{cx, cy, cz},\n        geom::Location{cx, cyyy, czzz},\n        geom::Location{cxx, cyxx, czxx},\n        geom::Location{cxxx, cyxxx, czxxx},\n        geom::Location{c, cxx, czxx},\n        geom::Location{c, cxxx, czxxx},\n        geom::Location{c, cx, cz},\n        geom::Location{c, cx, czzz},\n        geom::Location{", "CodeBleu_score": 36.513789684557295}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n    // Query the light states from the server\n    std::vector<Light> lights = _episode.Lock()->QueryLightsStateToServer();\n\n    // Update the local light states and create new lights if they don't exist\n    for (auto &light : lights) {\n        if (_lights.find(light.GetId()) == _lights.end()) {\n            _lights[light.GetId()] = std::make_shared<Light>(light);\n        } else {\n            _lights[light.GetId()]->SetState(light);\n        }\n    }\n\n    // Remove lights that are not in the server\n    for (auto it = _lights.begin(); it != _lights.end();) {\n        if (std::find_if(lights.begin(), lights.end(), [&](const Light &light) { return light.GetId() == it->second->GetId(); }) == lights.end()) {\n            it = _lights.erase(it);\n        } else {\n            ++it;\n        }\n    }\n}", "CodeBleu_score": 44.49399288210488}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex to ensure thread safety.\n  std::lock_guard<std::mutex> lock(_mutex);\n  // Get the light states from the server.\n  std::vector<Light> lights = _episode.Lock()->QueryLightsStateToServer();\n  // Update the local light states.\n  for (const auto& light : lights) {\n    _lights[light.GetId()] = light;\n  }\n  // Create new light objects if they do not already exist in the _lights map.\n  for (const auto& light : lights) {\n    if (_lights.find(light.GetId()) == _lights.end()) {\n      _lights[light.GetId()] = light;\n    }\n  }\n}", "CodeBleu_score": 34.82888034715905}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t/*\n   * This function, LightManager::QueryLightsStateToServer, queries the current state of lights from the server.\nIt locks a mutex to ensure thread safety and retrieves the light states from the server.\nIt then updates the local light states and creates new light objects if they do not already exist in the _lights map.\n   */\n  std::lock_guard<std::mutex> lock(_lights_mutex);\n  auto light_state = _episode.Lock()->QueryLightsStateToServer();\n  for (const auto &light : light_state) {\n    if (_lights.find(light.first) == _lights.end()) {\n      _lights[light.first] = std::make_shared<Light>(light.first, _episode.Lock());\n    }\n    _lights[light.first]->SetState(light.second);\n  }\n}", "CodeBleu_score": 41.58198754360329}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tif (!_dirty) return;\n    std::lock_guard<std::mutex> lock(_mutex);\n    if (!_dirty) return;\n    std::vector<rpc::Color> message;\n    message.reserve(_lights.size());\n    for (auto& light : _lights) {\n        message.push_back(light.second.GetLocation());\n    }\n    if (discard_client) {\n        _server->SendMessage(rpc::LightUpdateMessage(message));\n    } else {\n        _server->SendMessage(rpc::LightUpdateMessage(message), rpc::LightUpdateMessage::kLightUpdate);\n    }\n    _lights_changes.clear();\n    _dirty = false;\n}", "CodeBleu_score": 45.359885003692824}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t// Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Check if there have been any changes\n    if (!_lights_changes.empty()) {\n        // Create a message containing the updated light states\n        std::vector<rpc::Color> message;\n        for (auto& light : _lights) {\n            message.push_back(light.second.GetLocation());\n        }\n\n        // Send the message to the server\n        if (!discard_client) {\n            _episode.Lock()->UpdateServerLightsState(message);\n        }\n\n        // Clear the changes and reset the dirty flag\n        _lights_changes.clear();\n        _dirty = false;\n    }\n}", "CodeBleu_score": 41.25997859040944}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n    if (!_lights_changes.empty()) {\n        std::vector<rpc::LightState> message;\n        for (auto& light : _lights) {\n            if (_lights_changes.find(light.first) != _lights_changes.end()) {\n                message.push_back(rpc::LightState{light.first, light.second.GetLocation(), light.second.GetColor(), light.second.GetIntensity(), light.second.GetRadius(), light.second.GetDirection()});\n            }\n        }\n        _episode.Lock()->UpdateServerLightsState(message, discard_client);\n        _lights_changes.clear();\n        _dirty = false;\n    }\n}", "CodeBleu_score": 57.092274396688516}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"Sending message: %s\", message.c_str());\n    if (GetId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not 'sensor.other.v2x_custom'\");\n        return;\n    }\n    GetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 57.411301944235284}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"Sending message \\\"%s\\\" to episode \\\"%s\\\"\", message.c_str(), GetEpisode().Lock()->GetDisplayId().c_str());\n    if (GetEpisode().Lock()->GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is \\\"%s\\\", not \\\"sensor.other.v2x_custom\\\"\", GetEpisode().Lock()->GetDisplayId().c_str());\n        return;\n    }\n    GetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 52.722573986655654}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"Sending message: \" + message);\n    if (GetId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not 'sensor.other.v2x_custom'.\");\n        return;\n    }\n    GetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 57.086201525844004}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n\t\ttm.RegisterVehicles(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 41.57662892093094}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n        tm.RegisterVehicles(tm_port);\n    } else {\n        tm.UnregisterVehicles(tm_port);\n    }\n}", "CodeBleu_score": 48.05277760855889}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t// Check if the vehicle is already registered with the traffic manager.\n\tif (enabled && tm_port != 0) {\n\t\t// If the vehicle is not already registered with the traffic manager, register it with the traffic manager.\n\t\tif (!registered_with_tm) {\n\t\t\ttm.RegisterVehicles(tm_port, this);\n\t\t\tregistered_with_tm = true;\n\t\t}\n\t} else {\n\t\t// If the vehicle is already registered with the traffic manager, unregister it from the traffic manager.\n\t\tif (registered_with_tm) {\n\t\t\ttm.UnregisterVehicles(tm_port, this);\n\t\t\tregistered_with_tm = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.47404436861185}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\tauto walker = Cast<AWalker>(GetPawn());\n\tif (walker != nullptr) {\n\t\tauto& episode = GetEpisode();\n\t\tepisode.Lock()->SetActorCollisions(walker, false);\n\t\tepisode.Lock()->SetActorSimulatePhysics(walker, false);\n\t\tepisode.Lock()->RegisterAIController(walker, this);\n\t\tepisode.Lock()->GetNavigation()->AddWalker(walker, walker->GetLocation());\n\t}\n}", "CodeBleu_score": 54.41225947893747}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\tauto walker = Cast<AWalker>(GetPawn());\n\tif (walker) {\n\t\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n\t\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\t\tGetEpisode().Lock()->GetNavigation()->RegisterNavigationObject(walker, walker->GetActorLocation(), true);\n\t}\n}", "CodeBleu_score": 50.66812742850383}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\n\t// Get the walker actor from the controller\n\tACharacter* walker = Cast<ACharacter>(GetPawn());\n\tif (walker) {\n\t\t// Get the episode from the controller\n\t\tUCarlaEpisode* episode = GetEpisode();\n\t\tif (episode) {\n\t\t\t// Get the navigation system from the episode\n\t\t\tUNavigationSystem* nav_sys = episode->GetNavigationSystem();\n\t\t\tif (nav_sys) {\n\t\t\t\t// Register the walker with the navigation system\n\t\t\t\tnav_sys->RegisterNavigationObject(walker, walker->GetActorLocation(), true, true, true);\n\t\t\t}\n\t\t\t// Disable the physics simulation and collisions for the walker actor\n\t\t\twalker->SetActorSimulatePhysics(false);\n\t\t\twalker->SetActorEnableCollision(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.57317350815928}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto* nav = GetEpisode().Lock()->GetNavigation();\n    if (nav) {\n        auto* walker = GetParent();\n        if (walker) {\n            if (nav->SetWalkerMaxSpeed(walker, max_speed)) {\n                return;\n            }\n        }\n        log_warning(\"Walker\", *GetParent(), \"does not have a valid walker component\");\n    }\n    log_warning(\"Navigation\", *GetEpisode().Lock()->GetNavigation(), \"is not valid\");\n}", "CodeBleu_score": 51.8047076575337}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto walker = GetParent();\n    if (walker) {\n        auto nav = GetEpisode().Lock()->GetNavigation();\n        if (nav) {\n            if (nav->SetWalkerMaxSpeed(walker, max_speed)) {\n                UE_LOG(LogCarla, Log, TEXT(\"Walker %s max speed set to %f\"), *GetParent()->GetName(), max_speed);\n            } else {\n                UE_LOG(LogCarla, Warning, TEXT(\"Walker %s max speed could not be set to %f\"), *GetParent()->GetName(), max_speed);\n            }\n        } else {\n            UE_LOG(LogCarla, Warning, TEXT(\"Walker %s max speed could not be set to %f because navigation is not available\"), *GetParent()->GetName(), max_speed);\n        }\n    } else {\n        UE_LOG(LogCarla, Warning, TEXT(\"Walker %s max speed could not be set to %f because the walker is not available\"), *GetParent()->GetName(), max_speed);\n    }\n}", "CodeBleu_score": 55.627375177682026}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tif (GetEpisode() == nullptr) {\n        log_warning(\"WalkerAIController\", \"SetMaxSpeed\", \"WalkerAIController is not bound to an episode!\");\n        return;\n    }\n    auto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav == nullptr) {\n        log_warning(\"WalkerAIController\", \"SetMaxSpeed\", \"Navigation component is not found!\");\n        return;\n    }\n    auto walker = GetParent();\n    if (walker == nullptr) {\n        log_warning(\"WalkerAIController\", \"SetMaxSpeed\", \"Walker is not found!\");\n        return;\n    }\n    if (nav->SetWalkerMaxSpeed(walker, max_speed)) {\n        log_debug(\"WalkerAIController\", \"SetMaxSpeed\", \"Walker speed set to \" + std::to_string(max_speed));\n    } else {\n        log_warning(\"WalkerAIController\", \"SetMaxSpeed\", \"Failed to set walker speed!\");\n    }\n}", "CodeBleu_score": 54.84854484447018}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n  result.reserve(_parent->GetMap().GetPrevious(_id, distance).size());\n  for (const auto& waypoint : _parent->GetMap().GetPrevious(_id, distance)) {\n    result.emplace_back(std::make_shared<Waypoint>(_parent, waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 60.510269476613566}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (const auto& wp : waypoints) {\n        result.emplace_back(std::make_shared<Waypoint>(_parent->GetMap().GetPrevious(wp, distance)));\n    }\n    return result;\n}", "CodeBleu_score": 60.6409637821366}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n\n  for (const auto& wp : waypoints) {\n    if (wp->GetDistance() < distance) {\n      result.emplace_back(std::make_shared<Waypoint>(wp, _parent));\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 54.1488231690529}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t// TODO: Implement this function\n  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::set<SharedPtr<Signal>> added_signals;\n  for (auto signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      result.emplace_back(new Landmark(signal, _parent));\n      added_signals.insert(signal);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 40.91027723208981}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n  auto added_signals = std::set<Signal>();\n  for (auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    if (added_signals.count(signal) == 0) {\n      result.emplace_back(\n          new Landmark(signal,\n                       _parent->GetMap().GetLandmark(signal.id).pose));\n      added_signals.insert(signal);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 41.47461479572879}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t// TODO: Your code here\n    std::vector<SharedPtr<Landmark>> result;\n    std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n    std::unordered_set<std::string> added_landmarks;\n    for (auto signal : signals) {\n      if (added_landmarks.count(signal->GetName()) == 0) {\n        result.emplace_back\n        SharedPtr<Landmark>\n        _parent->GetMap().GetLandmarksInDistance\n        _parent->GetMap\n        added_landmarks.insert\n        added_landmarks.count\n\n\n\n\n", "CodeBleu_score": 41.52872651538397}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    uint64_t id = _episode.Lock()->ApplySettings(settings, local_timeout);\n    if (settings.fixed_delta_seconds.has_value()) {\n      if (settings.fixed_delta_seconds.get() <= 0) {\n        log_warning(\"fixed_delta_seconds must be greater than zero\");\n      } else {\n        // Verify that the provided fixed_delta_seconds is correct.\n        constexpr size_t kMaxTicks = 100;\n        for (size_t i = 0; i < kMaxTicks; ++i) {\n          WorldSnapshot curr_snapshot = GetSnapshot();\n          if (abs(curr_snapshot.GetTimestamp() -\n                  curr_snapshot.GetEngineTime()) <\n              std::numeric_limits<float>::epsilon()) {\n            break;\n          }\n          Tick(local_timeout);\n        }\n        if (i == kMaxTicks) {\n          log_warning(\n              \"fixed_delta_seconds setting does not match the engine's tick \"\n              \"rate\");\n        }\n      }\n    }\n    return id;\n  }", "CodeBleu_score": 58.24439492578376}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t// Apply settings locally.\n    _episode.Lock()->SetEpisodeSettings(settings);\n\n    // Set local timeout based on the provided timeout or the episode's networking timeout.\n    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n\n    // Attempt to verify the accuracy of the fixed delta time over a series of ticks.\n    if (settings.fixed_delta_seconds.has_value()) {\n      float fixed_delta_seconds = settings.fixed_delta_seconds.get();\n      float delta_seconds = 0.0f;\n      float error_sum = 0.0f;\n      uint64_t num_ticks = 0;\n      uint64_t max_ticks = 10;\n      while (num_ticks < max_ticks) {\n        uint64_t curr_tick = Tick(local_timeout);\n        WorldSnapshot curr_snapshot = GetSnapshot();\n        if (curr_snapshot.GetTimestamp() == 0) {\n          break;\n        }\n        delta_seconds = (curr_snapshot.GetTimestamp() - _last_snapshot_timestamp) / 1000.0f;\n        error_sum += abs(delta_seconds - fixed_delta_seconds);\n        num_ticks++;\n        _last_snapshot_timestamp = curr_snapshot.GetTimestamp();\n      }\n      if (num_ticks >= max_ticks) {\n        log_warning(\"Unable to verify the accuracy of the fixed delta time setting. The error sum is \",\n                    error_sum, \" and the average error is \", error_sum / num_ticks, \".\");\n      }\n    }\n\n    // Return the identifier of the applied settings.\n    return _episode.Lock()->GetSettingsId();\n  }", "CodeBleu_score": 57.79752300828782}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    uint64_t settings_id = _episode.Lock()->ApplySettings(settings, local_timeout);\n    if (settings.fixed_delta_seconds.has_value()) {\n      // Attempt to verify the accuracy of the fixed delta time setting over a series of ticks.\n      float delta_time = settings.fixed_delta_seconds.get();\n      float delta_time_error = std::numeric_limits<float>::epsilon();\n      uint64_t num_ticks = 10;\n      for (uint64_t i = 0; i < num_ticks; ++i) {\n        WorldSnapshot curr_snapshot = GetSnapshot();\n        if (curr_snapshot.GetTimestamp() == 0) {\n          // Wait for the first tick.\n          continue;\n        }\n        float delta_time_error_i = abs(curr_snapshot.GetTimestamp() - curr_snapshot.GetTimeSeconds()) / curr_snapshot.GetTimestamp();\n        if (delta_time_error_i > delta_time_error) {\n          log_warning(\"The fixed delta time setting was not correctly applied after \" + std::to_string(i) + \" ticks.\");\n          break;\n        }\n        delta_time_error = delta_time_error_i;\n      }\n    }\n    return settings_id;\n  }", "CodeBleu_score": 58.29649824064622}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat a, b, c, d, e, f, g, h, i;\n\ta = b - a;\n\tc = d - a;\n\te = f - a;\n\tg = c * e;\n\tif (g <= 0.0f)\n\t\treturn std::make_pair(0.0f, std::sqrt(a * a + e * e));\n\tf = c * c;\n\tif (g >= f)\n\t\treturn std::make_pair(std::sqrt(f), std::sqrt(a * a + e * e));\n\th = e * e - f * g;\n\ti = std::sqrt(h);\n\treturn std::make_pair(std::sqrt(g / f * f), i);\n}", "CodeBleu_score": 33.39192189510507}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tstd::pair<float, float> DistanceSegmentToPoint(const Math::Vector2& point, const Math::Vector2& start, const Math::Vector2& end) {\n\t\tfloat segmentLengthSquared = Math::DistanceSquared2D(start, end);\n\t\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\n\t\tif (segmentLength == 0.0f) {\n\t\t\treturn std::make_pair(0.0f, Math::Distance2D(point, start));\n\t\t}\n\n\t\tMath::Vector2 projection = Math::Clamp(point, start, end);\n\n\t\tfloat distanceAlongSegment = Math::Dot2D(projection - start, end - start) / segmentLengthSquared;\n\t\tfloat distanceFromProjectionToPoint = Math::Distance2D(point, projection);\n\n\t\treturn std::make_pair(distanceAlongSegment, distanceFromProjectionToPoint);\n\t}\n}", "CodeBleu_score": 44.29720031492077}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tstd::pair<float, float> DistanceSegmentToPoint(const Vector2f& point, const Vector2f& start, const Vector2f& end) {\n\t\tfloat segmentLengthSquared = std::powf(end.x - start.x, 2) + std::powf(end.y - start.y, 2);\n\t\tfloat segmentLength = std::sqrtf(segmentLengthSquared);\n\t\tif (segmentLengthSquared == 0) {\n\t\t\treturn std::make_pair(0.0f, std::sqrtf(std::powf(point.x - start.x, 2) + std::powf(point.y - start.y, 2)));\n\t\t}\n\t\tfloat t = std::clamp((point.x - start.x) * (end.x - start.x) + (point.y - start.y) * (end.y - start.y), 0.0f, segmentLengthSquared) / segmentLengthSquared;\n\t\tVector2f projection = start + t * (end - start);\n\t\treturn std::make_pair(std::sqrtf(DistanceSquared2D(point, projection)), std::sqrtf(DistanceSquared2D(point, projection)));\n\t}\n}", "CodeBleu_score": 47.677757976015336}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n    index_type initial_index = _indexes.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size(); ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i - 1);\n    }\n  }", "CodeBleu_score": 52.410267245058996}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n    index_type initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (index_type i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 54.53001284598531}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3, \"Mesh::AddTriangleFan: vertices.size() must be >= 3\");\n    index_type initial_index = _indexes.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 47.04791891330197}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message);\n  if (!message->empty()) {\n    boost::system::error_code ec;\n    if (self->_socket.is_open()) {\n      self->_deadline.expires_from_now(std::chrono::seconds(10), ec);\n      if (!ec) {\n        self->_deadline.async_wait(boost::asio::bind_executor(self->_strand, [=](const boost::system::error_code &ec) {\n          if (ec) {\n            log_error(\"write operation timed out\");\n            self->CloseNow();\n          }\n        }));\n        boost::asio::async_write(self->_socket, message->GetBufferSequence(), boost::asio::bind_executor(self->_strand, [=](const boost::system::error_code &ec, std::size_t bytes_transferred) {\n          self->_deadline.cancel();\n          self->HandleSent(ec, bytes_transferred);\n        }));\n      } else {\n        log_error(\"failed to set deadline timer\");\n        self->CloseNow();\n      }\n    } else {\n      log_error(\"socket is closed\");\n      self->CloseNow();\n    }\n  }\n}", "CodeBleu_score": 42.11926901812115}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  if (message->empty()) {\n    log_error(\"Empty message\");\n    return;\n  }\n  weak_ptr<Primary> self = shared_from_this();\n  auto callback = [self, message](const boost::system::error_code &ec) {\n    if (ec.value() != 0) {\n      log_error(ec.message());\n      self->CloseNow();\n    } else {\n      self->HandleSent(message);\n    }\n  };\n  boost::asio::post(boost::asio::bind_executor(self->_strand, callback));\n}", "CodeBleu_score": 38.92515059849793}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t// Check if the message is valid.\n  if (!message->IsValid()) {\n    LogError(\"Invalid message\");\n    return;\n  }\n  // Check if the socket is open.\n  if (!_socket.is_open()) {\n    LogError(\"Socket is not open\");\n    return;\n  }\n  // Set a timeout.\n  _deadline.expires_from_now(std::chrono::seconds(5));\n  // Post a lambda function to the strand for execution.\n  _strand.post([this, message]() {\n    // Check if the socket is open.\n    if (!_socket.is_open()) {\n      LogError(\"Socket is not open\");\n      return;\n    }\n    // Check if the message is valid.\n    if (!message->IsValid()) {\n      LogError(\"Invalid message\");\n      return;\n    }\n    // Set a timeout.\n    _deadline.expires_from_now(std::chrono::seconds(5));\n    // Initiate an asynchronous write.\n    boost::asio::async_write(_socket, message->GetBufferSequence(),\n        boost::asio::bind_executor(_strand,\n          std::bind(&Primary::handle_sent, shared_from_this(),\n            std::placeholders::_1, message)));\n  });\n}", "CodeBleu_score": 38.67403929978104}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    _socket.shutdown(tcp::socket::shutdown_both, ec);\n    _socket.close(ec);\n  }\n  _on_closed();\n  log_debug(\"Session closed\");\n}", "CodeBleu_score": 46.27863919186591}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    _socket.close(ec);\n  }\n  _on_closed();\n  LOG_DEBUG(\"Session closed\");\n}", "CodeBleu_score": 47.66962597214264}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\n    if (!ec && _socket.is_open()) {\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        _socket.close(ec);\n    }\n    _on_closed();\n    log_debug(\"Closed connection: {}\", ec.message());\n}", "CodeBleu_score": 50.570977770876226}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t// Create buffer from message\n    std::string msg = \"Are you alive?\";\n    std::shared_ptr<Buffer> buffer = std::make_shared<Buffer>(msg.size());\n    memcpy(buffer->data, msg.c_str(), msg.size());\n\n    // Log sending action\n    log_info(\"Sending message: \" + msg + \" to next router\");\n\n    // Write buffer to next router\n    _router->WriteToNext(buffer, YOU_ALIVE);\n\n    // Wait for and log response\n    std::shared_ptr<Buffer> response = _router->WaitForResponse();\n    log_info(\"Response from system: \" + std::string(response->data));\n}", "CodeBleu_score": 48.71145974032154}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tstd::string message = \"Are you alive?\";\n    std::string response;\n    Buffer buf(message);\n    Log::log(\"Sending Is Alive message...\");\n    _router->WriteToNext(buf, YOU_ALIVE);\n    Log::log(\"Waiting for response...\");\n    _router->ReadFromNext(response);\n    Log::log(\"Response: \" + response);\n}", "CodeBleu_score": 40.440269011318776}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tstd::string msg = \"Are you alive?\";\n    std::string response;\n    Buffer buffer(msg.size());\n    buffer.Write(msg.c_str(), msg.size());\n    _router->Log(LogLevel::INFO, \"Sending \\\"\" + msg + \"\\\" to \" + _router->GetName() + \".\");\n    _router->WriteToNext(buffer, YOU_ALIVE);\n    _router->Log(LogLevel::INFO, \"Waiting for response from \" + _router->GetName() + \"...\");\n    _router->WaitForMessage(response, YOU_ALIVE);\n    _router->Log(LogLevel::INFO, \"Response from \" + _router->GetName() + \": \\\"\" + response + \"\\\"\");\n}", "CodeBleu_score": 44.564852103257216}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Check if the sensor has been activated on any secondary server\n    if (_servers.find(sensor_id) == _servers.end()) {\n        // If not, log an error message\n        log_error(\"Sensor \" + std::to_string(sensor_id) + \" has not been activated on any secondary server.\");\n        return;\n    }\n    // If so, create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router\n    std::vector<uint8_t> buffer = {static_cast<uint8_t>(Command::ENABLE_ROS), sensor_id};\n    _router->WriteToOne(buffer);\n    // Wait for and process the server's response\n    std::future<std::vector<uint8_t>> fut = _router->ReadFromOne();\n    std::vector<uint8_t> response = fut.get();\n    if (response.size() == 0) {\n        log_error(\"No response received from server.\");\n        return;\n    }\n    if (response[0] != static_cast<uint8_t>(Command::ENABLE_ROS)) {\n        log_error(\"Unexpected response from server: \" + std::to_string(response[0]));\n        return;\n    }\n    if (response[1] != 0) {\n        log_error(\"Error while enabling sensor \" + std::to_string(sensor_id) + \" on server: \" + std::to_string(response[1]));\n        return;\n    }\n    return;\n}", "CodeBleu_score": 41.82875328929371}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tstd::lock_guard<std::mutex> lock(_servers_mutex);\n  // Check if the sensor is already activated on any secondary server.\n  if (_servers.find(sensor_id) == _servers.end()) {\n    // Sensor is not activated on any secondary server.\n    log_error(\"Sensor {} is not activated on any secondary server.\", sensor_id);\n    return;\n  }\n  // Sensor is activated on at least one secondary server.\n  // Create a buffer with the sensor ID.\n  std::vector<char> buffer(sizeof(stream_id));\n  std::memcpy(buffer.data(), &sensor_id, sizeof(stream_id));\n  // Send an ENABLE_ROS command to the server using the router.\n  _router->WriteToOne(buffer, _servers.begin()->second, Router::Command::ENABLE_ROS);\n  // Wait for and process the server's response.\n  auto fut = _router->ReadFromOne();\n  // Check if the response is valid.\n  if (!fut.valid()) {\n    log_error(\"No response from secondary server.\");\n    return;\n  }\n  // Check if the response is an error.\n  if (fut.get().buffer.size() > 0 && fut.get().buffer.data()[0] == '\\0') {\n    log_error(\"{}\", fut.get().buffer.data() + 1);\n    return;\n  }\n  // Check if the response is valid.\n  if (fut.get().buffer.size() != sizeof(bool)) {\n    log_error(\"Invalid response from secondary server.\");\n    return;\n  }\n  // Check if the response is valid.\n  if (!reinterpret_cast<bool *>(fut.get().buffer.data())[0]) {\n    log_error(\"Failed to enable ROS for sensor {} on secondary server.\", sensor_id);\n    return;\n  }\n  // Log a success message.\n  log_info(\"ROS enabled for sensor {} on secondary server.\", sensor_id);\n}", "CodeBleu_score": 48.03831138562093}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Check if the sensor is already enabled on any server\n  if (_servers.find(sensor_id) != _servers.end()) {\n    // Create a buffer with the sensor ID\n    std::vector<char> buffer(sizeof(stream_id));\n    stream_id *id = reinterpret_cast<stream_id *>(buffer.data());\n    *id = sensor_id;\n\n    // Send an ENABLE_ROS command to the server\n    auto fut = _router->WriteToOne(buffer, Command::ENABLE_ROS);\n\n    // Wait for and process the server's response\n    auto response = fut.get();\n    if (response.buffer.data == nullptr) {\n      log_error(\"ROS\", \"Server did not respond to ENABLE_ROS command.\");\n    } else {\n      bool *enabled = reinterpret_cast<bool *>(response.buffer.data);\n      if (*enabled) {\n        log_info(\"ROS\", \"ROS enabled for sensor: \" + std::to_string(sensor_id));\n      } else {\n        log_error(\"ROS\", \"ROS not enabled for sensor: \" + std::to_string(sensor_id));\n      }\n    }\n  } else {\n    log_error(\"ROS\", \"ROS not enabled for sensor: \" + std::to_string(sensor_id));\n  }\n}", "CodeBleu_score": 51.587394167226975}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tauto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"token already exists\");\n    return it->second;\n  }\n\n  auto token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = token;\n  _ports[sensor_id] = token.get_port();\n  _stream_ids[sensor_id] = token.get_stream_id();\n  log_info(\"token created\");\n  return token;\n}", "CodeBleu_score": 56.511418144329525}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(buf));\n\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  return new_token;\n}", "CodeBleu_score": 42.13988322740194}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"got a token: \", it->second.get_stream_id(), \", \", it->second.get_port());\n    return it->second;\n  }\n\n  // Enable the sensor on a secondary server\n  log_info(\"enabling sensor: \", sensor_id);\n  _router->WriteToNext(MultiGPUCommand::ENABLE_SENSOR, carla::Buffer((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id)));\n\n  // Retrieve a new token\n  log_info(\"asking for a token\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, carla::Buffer((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id)));\n\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n\n  // Update the maps\n  _tokens.insert(std::make_pair(sensor_id, new_token));\n  _stream_ids.insert(std::make_pair(new_token.get_stream_id(), sensor_id));\n  _ports.insert(std::make_pair(new_token.get_port(), sensor_id));\n\n  return new_token;\n}", "CodeBleu_score": 59.83671063222595}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.56354618969615}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!IsReady()) {\n        return false;\n    }\n    DEBUG_ASSERT(crowd != nullptr);\n\n    std::lock_guard<std::mutex> lock(mutex);\n\n    auto it_walker = _mapped_walkers_id.find(id);\n    if (it_walker != _mapped_walkers_id.end()) {\n        _walker_manager.RemoveWalker(it_walker->second);\n        _mapped_walkers_id.erase(it_walker);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);\n        _mapped_by_index.erase(it_walker->second);", "CodeBleu_score": 42.965944733995514}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tDEBUG_ASSERT(IsReady());\n\tDEBUG_ASSERT(_crowd != nullptr);\n\n\t// Remove the agent from the crowd\n\tif (_mapped_vehicles_id.find(id) != _mapped_vehicles_id.end()) {\n\t\t_crowd->removeAgent(_mapped_vehicles_id.find(id)->second);\n\t\t_mapped_vehicles_id.erase(id);\n\t\treturn true;\n\t}\n\telse if (_mapped_walkers_id.find(id) != _mapped_walkers_id.end()) {\n\t\t_walker_manager.RemoveWalker(_mapped_walkers_id.find(id)->second);\n\t\t_mapped_walkers_id.erase(id);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 39.79834811017545}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tDEBUG_ASSERT(IsReady());\n\tDEBUG_ASSERT(_crowd != nullptr);\n\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\n\tif (walker_it != _mapped_walkers_id.end()) {\n\t\tDEBUG_ASSERT(vehicle_it == _mapped_vehicles_id.end());\n\n\t\t_crowd->removeAgent(walker_it->second);\n\t\t_walker_manager.RemoveWalker(walker_it->second);\n\n\t\t_mapped_by_index.erase(walker_it->second);\n\t\t_mapped_walkers_id.erase(walker_it);\n\t\treturn true;\n\t}\n\telse if (vehicle_it != _mapped_vehicles_id.end()) {\n\t\tDEBUG_ASSERT(walker_it == _mapped_walkers_id.end());\n\n\t\t_crowd->removeAgent(vehicle_it->second);\n\t\t_vehicle_manager.RemoveVehicle(vehicle_it->second);\n\n\t\t_mapped_by_index.erase(vehicle_it->second);\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 57.56892426051755}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tauto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    return _crowd->hasVehicleNear(_mapped_walkers_id[id], distance, direction);\n  }\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    return _crowd->hasVehicleNear(_mapped_vehicles_id[id], distance, direction);\n  }\n  return false;\n}", "CodeBleu_score": 56.516577808854365}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tauto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    return _crowd->hasVehicleNear(it->second, distance, direction);\n  }\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    return _crowd->hasVehicleNear(it->second, distance, direction);\n  }\n  return false;\n}", "CodeBleu_score": 57.64706296953689}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    return _crowd->hasVehicleNear(it->second, distance, direction);\n  }\n  auto it2 = _mapped_vehicles_id.find(id);\n  if (it2 != _mapped_vehicles_id.end()) {\n    return _crowd->hasVehicleNear(it2->second, distance, direction);\n  }\n  return false;\n}", "CodeBleu_score": 61.3635851108014}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tWalkerEventVisitor visitor(id, delta, info, *this);\n    boost::variant2::visit(visitor, info.route_points[info.current_route_point].event);\n    return visitor.result;\n}", "CodeBleu_score": 53.36614701143788}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tWalkerEventVisitor visitor(id, info, delta);\n    boost::variant2::visit(visitor, info.route.current);\n    return visitor.result;\n}", "CodeBleu_score": 40.81962342248695}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tEventResult result;\n  WalkerEventVisitor visitor(id, info, delta);\n  boost::variant2::visit(visitor, info.route.points[info.route.current_point]);\n  result = visitor.result;\n  return result;\n}", "CodeBleu_score": 44.2853524863869}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        if (info.current_count == 1) {\n            if (info.total_count == 1) {\n                if (info.total_count_change == 1) {\n                    // this is the first match\n                    std::cout << \"Listener: first match\" << std::endl;\n                    this->matched_count = 1;\n                    this->first_connection = true;\n                } else {\n                    // invalid count change\n                    std::cout << \"Listener: invalid count change\" << std::endl;\n                }\n            } else {\n                // this is the first match\n                std::cout << \"Listener: first match\" << std::endl;\n                this->matched_count = 1;\n                this->first_connection = true;\n            }\n        } else {\n            // this is an additional match\n            std::cout << \"Listener: additional match\" << std::endl;\n            this->matched_count++;\n        }\n    } else {\n        if (info.current_count == 0) {\n            if (info.total_count == 0) {\n                if (info.total_count_change == -1) {\n                    // this is the last match\n                    std::cout << \"Listener: last match\" << std::endl;\n                    this->matched_count--;\n                    this->first_connection = false;\n                } else {\n                    // invalid count change\n                    std::cout << \"Listener: invalid count change\" << std::endl;\n                }\n            } else {\n                // this is the last match\n                std::cout << \"Listener: last match\" << std::endl;\n                this->matched_count--;\n                this->first_connection = false;\n            }\n        } else {\n            // invalid count change\n            std::cout << \"Listener: invalid count change\" << std::endl;\n        }\n    }\n}", "CodeBleu_score": 51.291705179032164}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\tfirst_connection = true;\n\t\t\tmatched_count = 1;\n\t\t} else if (info.current_count > 1) {\n\t\t\tmatched_count = info.current_count;\n\t\t} else {\n\t\t\tstd::cerr << \"Invalid count change: \" << info.current_count_change << \" \" << info.current_count << std::endl;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tif (info.current_count == 0) {\n\t\t\tmatched_count = 0;\n\t\t} else if (info.current_count < 0) {\n\t\t\tstd::cerr << \"Invalid count change: \" << info.current_count_change << \" \" << info.current_count << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cerr << \"Invalid count change: \" << info.current_count_change << \" \" << info.current_count << std::endl;\n\t}\n}", "CodeBleu_score": 61.92138737580688}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == efd::MATCHED_MATCHED) {\n    if (info.total_count == 1) {\n      std::cout << \"First connection.\" << std::endl;\n      first_connection_ = true;\n    }\n    matched_count_++;\n  } else if (info.current_count_change == efd::MATCHED_UNMATCHED) {\n    if (matched_count_ > 0) {\n      matched_count_--;\n    } else {\n      std::cerr << \"Invalid unmatched count.\" << std::endl;\n    }\n  } else {\n    std::cerr << \"Invalid count change.\" << std::endl;\n  }\n}", "CodeBleu_score": 55.130741484135704}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    if (info.current_count == 1) {\n      _first_connected = true;\n    }\n    _matched_count++;\n  } else if (info.current_count_change == -1) {\n    _matched_count--;\n    if (_matched_count == 0) {\n      _owner->DestroySubscriber();\n    }\n  } else {\n    CARLA_ERROR(\"Invalid change count: \" << info.current_count_change);\n  }\n}", "CodeBleu_score": 65.64134150134858}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        if (info.total_count == 1) {\n            _first_connected = true;\n        }\n        _matched_count++;\n    } else if (info.current_count_change == -1) {\n        _matched_count--;\n        if (_matched_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        LOG_ERROR(\"Invalid subscription change count: \" << info.current_count_change);\n    }\n}", "CodeBleu_score": 67.48621988823498}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tstd::stringstream ss;\n  ss << \"Subscription matched for \" << reader->get_topicdescription()->get_name();\n  if (info.current_count_change == 1) {\n    ss << \" (first connection)\";\n    _first_connected = true;\n  }\n  if (info.current_count_change == -1) {\n    ss << \" (last disconnection)\";\n  }\n  RCLCPP_INFO(_owner->get_logger(), ss.str());\n  RCLCPP_INFO(_owner->get_logger(), \"Number of subscriptions: %d\", info.current_count_change);\n  if (info.current_count_change == 1) {\n    _matched_count++;\n  } else if (info.current_count_change == -1) {\n    _matched_count--;\n  } else {\n    RCLCPP_ERROR(_owner->get_logger(), \"Invalid subscription count change: %d\", info.current_count_change);\n  }\n  if (_matched_count == 0) {\n    _owner->DestroySubscriber();\n  }\n}", "CodeBleu_score": 50.44003728858275}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    *handle = p_type->getKey();\n    return true;\n}", "CodeBleu_score": 13.65550463513654}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_get_key) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    m_md5.reset();\n    m_md5.update((unsigned char*)&p_type->header.sec, sizeof(p_type->header.sec));\n    m_md5.update((unsigned char*)&p_type->header.nanosec, sizeof(p_type->header.nanosec));\n    m_md5.update((unsigned char*)&p_type->type, sizeof(p_type->type));\n    m_md5.update((unsigned char*)&p_type->id, sizeof(p_type->id));\n    m_md5.update((unsigned char*)&p_type->actorId, sizeof(p_type->actorId));\n    m_md5.update((unsigned char*)&p_type->otherActorId, sizeof(p_type->otherActorId));\n    m_md5.update((unsigned char*)&p_type->actorType, sizeof(p_type->actorType));\n    m_md5.update((unsigned char*)&p_type->otherActorType, sizeof(p_type->otherActorType));\n    m_md5.update((unsigned char*)&p_type->actorLocation.x, sizeof(p_type->actorLocation.x));\n    m_md5.update((unsigned char*)&p_type->actorLocation.y, sizeof(p_type->actorLocation.y));\n    m_md5.update((unsigned char*)&p_type->actorLocation.z, sizeof(p_type->actorLocation.z));\n    m_md5.update((unsigned char*)&p_type->otherActorLocation.x, sizeof(p_type->otherActorLocation.x));\n    m_md5.update((unsigned char*)&p_type->otherActorLocation.y, sizeof(p_type->otherActorLocation.y));\n    m_md5.update((unsigned char*)&p_type->otherActorLocation.z, sizeof(p_type->otherActorLocation.z));\n    m_md5.update((unsigned", "CodeBleu_score": 21.61687478062625}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    if (!p_type) {\n        return false;\n    }\n    if (p_type->m_key && !force_md5) {\n        *handle = *p_type->m_key;\n        return true;\n    }\n    if (!p_type->m_key && !force_md5) {\n        return false;\n    }\n    if (force_md5) {\n        std::stringstream ss;\n        if (!p_type->m_key) {\n            ss << \"CarlaCollisionEvent::getKey(): Key is not set.\";\n            std::cerr << ss.str() << std::endl;\n            return false;\n        }\n        ss << *p_type->m_key;\n        std::string key_md5 = ss.str();\n        if (key_md5.length() >= 2) {\n            if (key_md5[0] == '0' && key_md5[1] == 'x') {\n                key_md5 = key_md5.substr(2, key_md5.length() - 2);\n            }\n            *handle = std::hash<std::string>{}(key_md5);\n            return true;\n        }\n        std::cerr << \"CarlaCollisionEvent::getKey(): MD5 hash of key is empty.\" << std::endl;\n        return false;\n    }\n    return false;\n}", "CodeBleu_score": 36.77528398027565}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    SerializedPayload_t payload_local = *payload;\n    uint32_t initial_size = payload_local.length;\n    bool ret = false;\n    try {\n        FastBuffer cdrbuffer;\n        Cdr cdr_ser(cdrbuffer);\n        // serialize CDR stream\n        if (p_type->serialize(cdr_ser)) {\n            payload_local.length = static_cast<uint32_t>(cdrbuffer.getBufferSize());\n            payload_local.data = cdrbuffer.getBuffer();\n            *payload = payload_local;\n            ret = true;\n        }\n    } catch (exception& e) {\n        (void)e;\n    }\n    return ret;\n}", "CodeBleu_score": 42.98532390750347}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    // Object fields\n    // Member: throttle\n    {\n        // Serializer member\n        p_type->throttle.serialize(\n                &payload->buffer[payload->length]);\n        // Update the length member of the payload\n        payload->length += p_type->throttle.getSerializedSize();\n    }\n    // Member: steer\n    {\n        // Serializer member\n        p_type->steer.serialize(\n                &payload->buffer[payload->length]);\n        // Update the length member of the payload\n        payload->length += p_type->steer.getSerializedSize();\n    }\n    // Member: brake\n    {\n        // Serializer member\n        p_type->brake.serialize(\n                &payload->buffer[payload->length]);\n        // Update the length member of the payload\n        payload->length += p_type->brake.getSerializedSize();\n    }\n    // Member: hand_brake\n    {\n        // Serializer member\n        p_type->hand_brake.serialize(\n                &payload->buffer[payload->length]);\n        // Update the length member of the payload\n        payload->length += p_type->hand_brake.getSerializedSize();\n    }\n    // Member: reverse\n    {\n        // Serializer member\n        p_type->reverse.serialize(\n                &payload->buffer[payload->length]);\n        // Update the length member of the payload\n        payload->length += p_type->reverse.getSerializedSize();\n    }\n    // Member: manual_gear_shift\n    {\n        // Serializer member\n        p_type->manual_gear_shift.serialize(\n                &payload->buffer[payload->length]);\n        // Update the length member of the payload\n        payload->length += p_type->manual_gear_shift.getSerializedSize();\n    }\n    // Member: gear_switch\n    {\n        // Serializer member\n        p_type->gear_switch.serialize(\n                &payload->buffer[payload->length]);", "CodeBleu_score": 27.827370587473947}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    // Object fields\n    cdr_serialize(p_type->throttle, &(payload->encapsulation));\n    cdr_serialize(p_type->steer, &(payload->encapsulation));\n    cdr_serialize(p_type->brake, &(payload->encapsulation));\n    cdr_serialize(p_type->hand_brake, &(payload->encapsulation));\n    cdr_serialize(p_type->reverse, &(payload->encapsulation));\n    cdr_serialize(p_type->manual_gear_shift, &(payload->encapsulation));\n    cdr_serialize(p_type->gear, &(payload->encapsulation));\n    // Serialize encapsulation\n    payload->encapsulation.cdr_serialize(payload->data, payload->length);\n    if (payload->encapsulation.buf != NULL) {\n        // We own the buffer. Destroy and free it.\n        delete[] payload->encapsulation.buf;\n    }\n    payload->encapsulation.buf = NULL;\n    return true;\n}", "CodeBleu_score": 32.866260082230234}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) {\n\t\treturn;\n\t}\n\t\n\tmavlink_message_t msg_copy = msg;\n\tmavlink_heartbeat_t heartbeat;\n\tmavlink_msg_heartbeat_decode(&msg_copy, &heartbeat);\n\t\n\tif (heartbeat.type != MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.autopilot != MAV_AUTOPILOT_INVALID) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_CUSTOM_MODE_ENABLED) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_TEST_ENABLED) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_MANUAL_INPUT_ENABLED) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_GUIDED_ENABLED) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_STABILIZE_ENABLED) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_HIL_ENABLED) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_SAFETY_ARMED) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_SAFETY_DISARMED) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_SAFETY_ARMED_IN_AIR) {\n\t\treturn;\n\t}\n\t\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_", "CodeBleu_score": 32.61699031302451}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t// check if the target is already set\n    if (tracker.gcs().target_set()) {\n        return;\n    }\n\n    // decode the message\n    mavlink_heartbeat_t heartbeat;\n    mavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n    // check if the message type is one that should be tracked\n    if (heartbeat.type != MAV_TYPE_GCS && heartbeat.type != MAV_TYPE_GCS_ROVER && heartbeat.type != MAV_TYPE_GCS_FIXED_WING) {\n        return;\n    }\n\n    // set the target system ID\n    tracker.gcs().set_target(heartbeat.sysid);\n\n    // request position and air pressure data streams from the target\n    mavlink_message_t request_pos_msg;\n    mavlink_message_t request_airpress_msg;\n    mavlink_msg_request_datastream_pack(heartbeat.sysid, heartbeat.compid, &request_pos_msg, MAVLINK_DATA_STREAM_POSITION, heartbeat.sysid, 1, 1);\n    mavlink_msg_request_datastream_pack(heartbeat.sysid, heartbeat.compid, &request_airpress_msg, MAVLINK_DATA_STREAM_AIR_PRESSURE, heartbeat.sysid, 1, 1);\n    tracker.gcs().send_message(request_pos_msg);\n    tracker.gcs().send_message(request_airpress_msg);\n\n    // flag that the target has been set\n    tracker.gcs().set_target_set();\n}", "CodeBleu_score": 46.15371257724974}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t// Check if the target has been set\n    if (tracker.g.sysid_target.set) {\n        return;\n    }\n\n    // Decode the message\n    mavlink_message_t msg_copy = msg;\n    mavlink_heartbeat_t heartbeat;\n    mavlink_msg_heartbeat_decode(&msg_copy, &heartbeat);\n\n    // Check if the message type should be tracked\n    if (heartbeat.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    // Check if the target system ID is set\n    if (tracker.g.sysid_target.sysid != heartbeat.sysid) {\n        // Set the target system ID\n        tracker.g.sysid_target.sysid = heartbeat.sysid;\n\n        // Request position and air pressure data streams from the target\n        tracker.gcs().request_datastream_position(tracker.g.sysid_target.sysid);\n        tracker.gcs().request_datastream_airpressure(tracker.g.sysid_target.sysid);\n\n        // Flag that the target has been set\n        tracker.g.sysid_target.set = true;\n    }\n}", "CodeBleu_score": 48.502905997814025}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_alt_cal = true;\n    }\n    return result;\n}", "CodeBleu_score": 66.92516260591795}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.97645751027159}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.97645751027159}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    if (packet.param1 == 1.0) {\n        result = MAV_RESULT_ACCEPTED;\n        tracker.arm_servos();\n    } else if (packet.param1 == 0.0) {\n        result = MAV_RESULT_ACCEPTED;\n        tracker.disarm_servos();\n    }\n\n    return result;\n}", "CodeBleu_score": 59.907131132517634}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\t\n\tif (packet.param1 == 1.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\ttracker.arm_servos();\n\t} else if (packet.param1 == 0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\ttracker.disarm_servos();\n\t}\n\t\n\treturn result;\n}", "CodeBleu_score": 56.05214007343085}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    if (packet.param1 == 1.0) {\n        result = MAV_RESULT_ACCEPTED;\n        tracker.arm_servos();\n    } else if (packet.param1 == 0.0) {\n        result = MAV_RESULT_ACCEPTED;\n        tracker.disarm_servos();\n    }\n\n    return result;\n}", "CodeBleu_score": 59.907131132517634}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < _num_gcs; i++) {\n\t\tif (_gcs[i].get_avail_payload_space() >= sizeof(mavlink_message_t)) {\n\t\t\tmavlink_message_t msg;\n\t\t\tmavlink_msg_request_data_stream_pack(0, 0, &msg, _gcs[i].get_system_id(), _gcs[i].get_component_id(), MAV_DATA_STREAM_POSITION, 50.0f);\n\t\t\t_gcs[i].send_message(msg);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.53710460784658}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// Iterate over the available GCS channels\n    for (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n\n        // Check if this GCS channel has payload space available\n        if (gcs_channels[i].payload_space > 0) {\n\n            // Send a request to start the data stream on the corresponding channel with the specified update rate\n            mavlink_msg_request_data_stream_send(gcs_channels[i].system_id, gcs_channels[i].component_id, MAV_DATA_STREAM_POSITION, 100);\n\n            // Decrement the payload space\n            gcs_channels[i].payload_space--;\n\n            // Exit the loop\n            break;\n        }\n    }\n}", "CodeBleu_score": 32.42478689094725}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// Iterate over the available GCS channels\n\tfor (int i = 0; i < NUM_GCS_VEHICLES; i++) {\n\n\t\t// Check for available payload space\n\t\tif (HAVE_PAYLOAD_SPACE(i)) {\n\n\t\t\t// Send a request to start the data stream on the corresponding channel with the specified update rate\n\t\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, sysid, compid, MAV_DATA_STREAM_POSITION, 100);\n\n\t\t\t// Increment the number of GCS channels with which we have successfully sent a request\n\t\t\tnum_gcs++;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.128472360648594}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tif (ahrs.cos_pitch == 0) {\n\t\treturn false;\n\t}\n\n\tef_pitch = asin(ahrs.sin_pitch * sin(pitch) + ahrs.cos_pitch * cos(pitch) * cos(yaw));\n\tef_yaw = atan2(ahrs.cos_pitch * sin(yaw) - ahrs.sin_pitch * cos(yaw), cos(pitch));\n\treturn true;\n}", "CodeBleu_score": 45.19038401490591}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tif (is_zero(ahrs.cos_pitch)) {\n\t\treturn false;\n\t}\n\telse {\n\t\tef_pitch = asin(ahrs.sin_pitch * cos(yaw) + ahrs.cos_pitch * sin(pitch) * sin(yaw));\n\t\tef_yaw = atan2(-sin(yaw) * cos(pitch), ahrs.cos_pitch * cos(pitch) - ahrs.sin_pitch * sin(pitch) * sin(yaw));\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 44.665018037423955}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS& ahrs = is_zero(pitch) ? AP::ahrs : AP::ahrs;\n  if (is_zero(pitch)) {\n    return false;\n  }\n  ef_pitch = atan2(ahrs.sin_roll * cos(yaw), ahrs.cos_roll * cos(pitch) - ahrs.sin_roll * sin(pitch) * sin(yaw));\n  ef_yaw = atan2(sin(pitch) * cos(yaw), ahrs.cos_roll * cos(pitch) + ahrs.sin_roll * sin(pitch) * sin(yaw));\n  return true;\n}", "CodeBleu_score": 52.152267918698904}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t// get the yaw and pitch in centidegrees\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float pitch = (nav_status.distance * cosf(nav_status.bearing)) * 100;\n    float yaw = (nav_status.distance * sinf(nav_status.bearing)) * 100;\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate the angle error\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // convert the angle error from earth frame to body frame\n    float bf_pitch_err;\n    float bf_yaw_err;\n    convert_ef_to_bf(nav_status.angle_error_pitch, nav_status.angle_error_yaw, bf_pitch_err, bf_yaw_err);\n\n    // update the pitch and yaw servos\n    tracker.update_pitch_servo(bf_pitch_err);\n    tracker.update_yaw_servo(bf_yaw_err);\n}", "CodeBleu_score": 51.77889038499879}, {"code": "void Mode::update_auto(void){\n\tParameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n\n    // calculate target distance in centimeters\n    float target_distance_cm = 0;\n    if (nav_status.target_distance_valid) {\n        target_distance_cm = nav_status.target_distance_cm;\n    }\n\n    // calculate target distance in centidegrees\n    float target_distance_cd = 0;\n    if (target_distance_cm > 0) {\n        target_distance_cd = target_distance_cm * 100.0f / g.tracker_distance;\n    }\n\n    // calculate target bearing in centidegrees\n    float target_bearing_cd = (nav_status.bearing + g.yaw_trim) * 100.0f;\n\n    // calculate target pitch in centidegrees\n    float target_pitch_cd = 0;\n    if (target_distance_cd > 0) {\n        target_pitch_cd = target_distance_cd * g.tracker_pitch_factor;\n    }\n\n    // calculate target yaw in centidegrees\n    float target_yaw_cd = 0;\n    if (target_distance_cd > 0) {\n        target_yaw_cd = target_distance_cd * g.tracker_yaw_factor;\n    }\n\n    // calculate target pitch and yaw in centidegrees\n    float pitch_cd = target_pitch_cd;\n    float yaw_cd = target_yaw_cd;\n\n    // calculate distance to earthframe angle limits in centi-degrees\n    float ef_yaw_limit_lower = 0;\n    float ef_yaw_limit_upper = 0;\n    float ef_pitch_limit_lower = 0;\n    float ef_pitch_limit_upper = 0;\n    if (target_distance_cm > 0) {\n        ef_yaw_limit_lower = (-g.yaw_range * 100.0f /", "CodeBleu_score": 45.44787485130548}, {"code": "void Mode::update_auto(void){\n\tParameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float yaw_angle_error;\n    float pitch_angle_error;\n    bool direction_reversed = get_ef_yaw_direction();\n    calc_angle_error(nav_status.pitch, nav_status.yaw, direction_reversed);\n    // calculate the angle error in centidegrees\n    yaw_angle_error = nav_status.angle_error_yaw;\n    pitch_angle_error = nav_status.angle_error_pitch;\n\n    // if the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n    if (nav_status.target_distance_valid || !g.min_distance_cm) {\n        // update the pitch and yaw servos\n        tracker.update_pitch_servo(pitch_angle_error);\n        tracker.update_yaw_servo(yaw_angle_error);\n    }\n}", "CodeBleu_score": 49.289618509320846}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t// Update the GPS data\n    gps.update();\n\n    // Check if the GPS status is at least 3D fix\n    if (gps.status >= 3) {\n        // If the last message time has changed, update the last message time\n        if (gps.last_message_time_ms != last_message_time_ms) {\n            last_message_time_ms = gps.last_message_time_ms;\n\n            // If the countdown is still running, reset it\n            if (ground_start_countdown > 0) {\n                ground_start_countdown = 0;\n            }\n        }\n\n        // If the countdown is running, increment it\n        if (ground_start_countdown > 0) {\n            ground_start_countdown++;\n        }\n\n        // If the countdown is at the maximum, set the home location\n        if (ground_start_countdown == GROUND_START_COUNTDOWN_MAX) {\n            // If the current location is valid, set the home location\n            if (gps.location.isValid()) {\n                home.latitude = gps.location.lat();\n                home.longitude = gps.location.lng();\n                home.altitude = gps.altitude;\n\n                // Reset the countdown\n                ground_start_countdown = 0;\n            }\n            // If the current location is invalid, reset the countdown\n            else {\n                ground_start_countdown = 0;\n            }\n        }\n    }\n    // If the GPS status is not at least 3D fix, reset the countdown\n    else {\n        ground_start_countdown = 0;\n    }\n}", "CodeBleu_score": 55.30327918252005}, {"code": "void Tracker::update_GPS(void){\n\t// update the GPS data\n  gps.update();\n\n  // check if the GPS status is at least 3D fix\n  if (gps.status >= 3) {\n    // check if the last message time has changed\n    if (gps.last_message_time_ms != last_message_time_ms) {\n      // set the last message time\n      last_message_time_ms = gps.last_message_time_ms;\n\n      // check if the GPS location is valid\n      if (gps.location.isValid()) {\n        // set the home location if the countdown is 1\n        if (ground_start_countdown == 1) {\n          // set the home location\n          set_home();\n\n          // reset the countdown\n          ground_start_countdown = 0;\n        } else {\n          // increment the countdown\n          ground_start_countdown++;\n        }\n      } else {\n        // reset the countdown\n        ground_start_countdown = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 45.22843287495696}, {"code": "void Tracker::update_GPS(void){\n\t// Check if the GPS is connected\n  if (!gps.location.isValid()) {\n    // Check if the GPS has been initialized\n    if (gps_initialized) {\n      // Check if the GPS has a valid fix\n      if (gps.status == STATUS_NO_FIX) {\n        // Reset the countdown\n        gps_countdown = GPS_COUNTDOWN_MAX;\n        // Set the GPS status to invalid\n        gps_status = GPS_INVALID;\n        // Update the GPS status\n        update_GPS_status();\n      }\n      // Check if the GPS has a 3D fix\n      else if (gps.status == STATUS_3D_FIX) {\n        // Check if the last message time has changed\n        if (gps.last_message_time_ms != last_gps_message_time_ms) {\n          // Update the last message time\n          last_gps_message_time_ms = gps.last_message_time_ms;\n          // Check if the GPS status is invalid\n          if (gps_status == GPS_INVALID) {\n            // Reset the countdown\n            gps_countdown = GPS_COUNTDOWN_MAX;\n            // Set the GPS status to valid\n            gps_status = GPS_VALID;\n            // Update the GPS status\n            update_GPS_status();\n          }\n        }\n      }\n    }\n    // Check if the GPS has not been initialized\n    else {\n      // Check if the last message time has changed\n      if (gps.last_message_time_ms != last_gps_message_time_ms) {\n        // Update the last message time\n        last_gps_message_time_ms = gps.last_message_time_ms;\n        // Check if the GPS has a valid fix\n        if (gps.status == STATUS_NO_FIX) {\n          // Reset the countdown\n          gps_countdown = GPS_COUNTDOWN_MAX;\n          // Set the GPS status to invalid\n          gps_status = GPS_INVALID", "CodeBleu_score": 39.57655307271932}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tif (pitch > 0.0f) {\n\t\tif (pitch > 1.0f) {\n\t\t\tpitch = 1.0f;\n\t\t}\n\t\tif (pitch < -1.0f) {\n\t\t\tpitch = -1.0f;\n\t\t}\n\t\tpitch = (1.0f - pitch) * 0.5f + 0.5f;\n\t}\n\telse {\n\t\tif (pitch < -1.0f) {\n\t\t\tpitch = -1.0f;\n\t\t}\n\t\tif (pitch > 1.0f) {\n\t\t\tpitch = 1.0f;\n\t\t}\n\t\tpitch = (1.0f + pitch) * 0.5f;\n\t}\n\t//pitch = 1.0f;\n\t//pitch = 0.0f;\n\t//pitch = -1.0f;\n\n\t//pitch = 1.0f;\n\t//pitch = 0.0f;\n\t//pitch = -1.0f;\n\t//pitch = 1.0f;\n\t//pitch = 0.0f;\n\t//pitch = -1.0f;\n\t//pitch = 1.0f;\n\t//pitch = 0.0f;\n\t//pitch = -1.0f;\n\t//pitch = 1.0f;\n\t//pitch = 0.0f;\n\t//pitch = -1.0f;\n\t//pitch = 1.0f;\n\t//pitch = 0.0f;\n\t//pitch = -1.0f;\n\t//pitch = 1.0f;\n\t//pitch = 0.0f;\n\t//pitch = -1.0f;\n\t//pitch = 1.0f;\n\t//pitch = 0.0f;\n\t//pitch = -1.0f;\n\t//pitch = 1.0f;\n\t//pitch = 0.0f", "CodeBleu_score": 12.790956743808707}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tif (pitch > 0.5) {\n        if (pitch > 0.5) {\n            if (pitch > 0.5) {\n                if (pitch > 0.5) {\n                    if (pitch > 0.5) {\n                        if (pitch > 0.5) {\n                            if (pitch > 0.5) {\n                                if (pitch > 0.5) {\n                                    if (pitch > 0.5) {\n                                        if (pitch > 0.5) {\n                                            if (pitch > 0.5) {\n                                                if (pitch > 0.5) {\n                                                    if (pitch > 0.5) {\n                                                        if (pitch > 0.5) {\n                                                            if (pitch > 0.5) {\n                                                                if (pitch > 0.5) {\n                                                                    if (pitch > 0.5) {\n                                                                        if (pitch > 0.5) {\n                                                                            if (pitch > 0.5) {\n                                                                                if (pitch > 0.5) {\n                                                                                    if (pitch > 0.5) {\n                                                                                        if (pitch > 0.5) {\n                                                                                            if (pitch > 0.5) {\n                                                                                                if (pitch > 0.5) {\n                                                                                                    if (pitch > 0.5) {\n                                                                                                        if (pitch > 0.5) {\n                                                                                                            if (pitch > 0.5) {\n                                                                                                                if (pitch > 0.5) {\n                                                                                                                    if (pitch > 0.5) {\n                                                                                                                        if (pitch > 0.5) {\n                                                                                                                            if (pitch > 0.5) {", "CodeBleu_score": 10.606283814757848}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t//if(pitch > 0.0) {\n\t\t//pitch_onoff_servo.set_position(0.0);\n\t//} else {\n\t\t//pitch_onoff_servo.set_position(1.0);\n\t//}\n\tpitch_onoff_servo.set_position(pitch);\n}", "CodeBleu_score": 9.580962518537818}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (AP_ARMING_CHECK_BARO == 0) {\n        return true;\n    }\n    // check barometer reference\n    if (fabsf(copter.barometer.get_ref_altitude() - copter.inertial_nav.get_position_z_up_cm()) > 1000) {\n        if (display_failure) {\n            hal.console->printf(\"Barometer reference is %d cm off inertial altitude\n\",\n                                copter.barometer.get_ref_altitude() - copter.inertial_nav.get_position_z_up_cm());\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 42.5428541881563}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tbool result = AP_Arming::barometer_checks(display_failure);\n\tif (result && AP_Notify::flags.arming_check_baro) {\n\t\tfloat baro_alt_cm = copter.barometer.get_altitude_cm();\n\t\tfloat baro_ref_cm = copter.barometer.get_reference_altitude();\n\t\tfloat baro_diff_cm = fabsf(baro_alt_cm - baro_ref_cm);\n\t\tif (baro_diff_cm > ARMING_CHECK_BARO_MAX_CM) {\n\t\t\tif (display_failure) {\n\t\t\t\tSerial.println(F(\"Barometer reference is too far from current altitude\"));\n\t\t\t\tSerial.print(F(\"Baro alt: \"));\n\t\t\t\tSerial.print(baro_alt_cm);\n\t\t\t\tSerial.print(F(\" cm\"));\n\t\t\t\tSerial.print(F(\" Baro ref: \"));\n\t\t\t\tSerial.print(baro_ref_cm);\n\t\t\t\tSerial.print(F(\" cm\"));\n\t\t\t\tSerial.print(F(\" Diff: \"));\n\t\t\t\tSerial.print(baro_diff_cm);\n\t\t\t\tSerial.println(F(\" cm\"));\n\t\t\t}\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 45.72749573484513}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call base class\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    // check ARMING_CHECK_BARO\n    if (g.ARMING_CHECK_BARO == 0) {\n        return true;\n    }\n    // check barometer reference\n    if (barometer.get_reference_altitude() == 0) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Barometer reference not set\n\"));\n        }\n        return false;\n    }\n    // check barometer altitude\n    float baro_alt = barometer.get_altitude();\n    if (isnan(baro_alt)) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Barometer not reading\n\"));\n        }\n        return false;\n    }\n    // check barometer altitude against inertial navigation altitude\n    float inertial_alt = copter.inertial_nav.get_position_z_up_cm() / 100.0f;\n    if (fabsf(inertial_alt - baro_alt) > 10.0f) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Barometer altitude %dm differs from inertial altitude %dm\n\"), (int)(baro_alt * 100), (int)(inertial_alt * 100));\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 52.773798577693775}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\treturn _terrain_database_required;\n}", "CodeBleu_score": 5.371750580214259}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tswitch (terrain_source) {\n    case AP_TERRAIN_SRC_RANGEFINDER:\n        return false;\n    case AP_TERRAIN_SRC_TERRAIN_DB:\n        return (rtl_alt_type == RTL_ALT_TERRAIN);\n    default:\n        return AP_Arming::terrain_database_required();\n    }\n}", "CodeBleu_score": 31.01238218475314}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (copter.wp_nav->get_terrain_source() == AP_TERRAIN_SRC_RANGEFINDER) {\n        return false;\n    }\n    if (copter.mode_rtl.get_alt_type() == AP_RALLY_ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.42148232795728}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// set dt for attitude, position, and motor controllers\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// run attitude and position controllers\n\tattitude_control->rate_controller_run();\n\tpos_control->run_pos_controller();\n\n\t// run the motors\n\tmotors->run();\n}", "CodeBleu_score": 45.76120992121725}, {"code": "void Copter::run_rate_controller(){\n\tattitude_control->rate_controller_run();\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n}", "CodeBleu_score": 48.55743163499574}, {"code": "void Copter::run_rate_controller(){\n\t// set dt for attitude and position controllers\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// run attitude and position controllers\n\tattitude_control->rate_controller_run();\n\tpos_control->run();\n\n\t// run the motors\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->update();\n}", "CodeBleu_score": 46.386618615661654}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // Check if the old location matches this waypoint and if the altitude frames of the old and new locations are the same.\n    if (old_loc.get_alt_frame() == new_loc.get_alt_frame() && old_loc.same_loc_as(new_loc)) {\n        // set new location as target\n        return mode_guided.set_destination(new_loc);\n    }\n\n    return false;\n}", "CodeBleu_score": 56.91431510233655}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (new_loc.get_alt_frame() != old_loc.get_alt_frame()) {\n        return false;\n    }\n\n    if (!old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 58.24521661946014}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    if (old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 65.89287431478128}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AuxSwitchPos::HIGH) {\n    copter.set_mode(mode);\n  } else {\n    if (copter.flightmode->mode_number == mode) {\n      rc().reset_mode_switch();\n    }\n  }\n}", "CodeBleu_score": 60.42961171764192}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AuxSwitchPos::HIGH) {\n    copter.set_mode(mode);\n  } else if (copter.flightmode->mode_number == mode) {\n    rc().reset_mode_switch();\n  }\n}", "CodeBleu_score": 57.07375540021224}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AuxSwitchPos::HIGH) {\n    copter.set_mode(mode);\n  } else if (copter.flightmode->mode_number == mode) {\n    rc().reset_mode_switch(ch_flag);\n  }\n}", "CodeBleu_score": 50.55195487720854}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t// add the trim values to the AHRS\n    ahrs.add_trim(channel_roll->get_control_in() * DEG_TO_RAD, channel_pitch->get_control_in() * DEG_TO_RAD);\n\n    // convert the trim values to radians and add them to the AHRS trim\n    // add the trim values to the AHRS\n    ahrs.add_trim(channel_roll->get_control_in() * DEG_TO_RAD, channel_pitch->get_control_in() * DEG_TO_RAD);\n\n    // calculate the trim values\n    float roll_trim = channel_roll->get_control_in() * DEG_TO_RAD;\n    float pitch_trim = channel_pitch->get_control_in() * DEG_TO_RAD;\n\n    // convert the trim values to radians and add them to the AHRS trim\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log the event\n    LOG_INFO(MAV_SEVERITY_INFO, \"Trim saved: %4.2f %4.2f\", (double)roll_trim, (double)pitch_trim);\n\n    // send a confirmation message\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Trim saved: %4.2f %4.2f\", (double)roll_trim, (double)pitch_trim);\n}", "CodeBleu_score": 48.38997999511648}, {"code": "void Copter::save_trim(){\n\t// calculate the trim values from the control inputs of the roll and pitch channels\n    float roll_trim = channel_roll->get_control_in();\n    float pitch_trim = channel_pitch->get_control_in();\n\n    // convert the trim values to radians\n    roll_trim = ToRad(roll_trim);\n    pitch_trim = ToRad(pitch_trim);\n\n    // add the trim values to the AHRS trim\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log the event\n    LOGGER_WRITE_EVENT(LOGGER_EVENT_TRIM);\n\n    // send a confirmation message with MAV_SEVERITY_INFO\n    gcs.send_text_fmt(MAV_SEVERITY_INFO, \"Trim saved: roll = %0.2f rad, pitch = %0.2f rad\", roll_trim, pitch_trim);\n}", "CodeBleu_score": 57.51016846982364}, {"code": "void Copter::save_trim(){\n\tif (channel_roll->control_in > 0.5f) {\n        // roll trim is positive\n        ahrs.add_trim(ToRad(channel_roll->control_in));\n    } else if (channel_roll->control_in < -0.5f) {\n        // roll trim is negative\n        ahrs.add_trim(-ToRad(channel_roll->control_in));\n    }\n    if (channel_pitch->control_in > 0.5f) {\n        // pitch trim is positive\n        ahrs.add_trim(ToRad(channel_pitch->control_in));\n    } else if (channel_pitch->control_in < -0.5f) {\n        // pitch trim is negative\n        ahrs.add_trim(-ToRad(channel_pitch->control_in));\n    }\n    LOG_INFO(\"Saved trim\");\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Saved trim\");\n}", "CodeBleu_score": 39.18566876246151}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t//Retrieve the copter's velocity\n\tVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n\t//Calculate the speed squared\n\tfloat speed_sq = vel.xy().length_squared();\n\n\t//If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (copter.position_ok() && speed_sq > MIN_SPEED_SQ) {\n\t\t//Calculate the look-ahead yaw angle using the arctangent of the velocity components\n\t\tfloat yaw_angle = atan2f(vel.y(), vel.x());\n\n\t\t//Update the look-ahead yaw angle\n\t\tlook_ahead_yaw_angle = degrees(yaw_angle);\n\t}\n\n\t//Return the computed look-ahead yaw angle\n\treturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 61.35794876631317}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// get the copter's velocity\n    Vector2f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // calculate the speed squared\n    float speed_squared = vel.length_squared();\n\n    // check if the copter's position is valid and the speed exceeds a minimum threshold\n    if (copter.position_ok && speed_squared > 0.0001f) {\n        // update the look-ahead yaw angle using the arctangent of the velocity components\n        look_ahead_yaw_angle = atan2f(vel.y, vel.x);\n    }\n\n    // return the computed look-ahead yaw angle\n    return look_ahead_yaw_angle;\n}", "CodeBleu_score": 49.85440495641475}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t/*\n   * This function, Mode::AutoYaw::look_ahead_yaw, calculates the yaw angle for a copter to look ahead based on its velocity.\nIt retrieves the copter's velocity, calculates the speed squared, and if the copter's position is valid and the speed exceeds a minimum threshold, it updates the look-ahead yaw angle using the arctangent of the velocity components.\nFinally, it returns the computed look-ahead yaw angle.\n   */\n  float speed_squared = vel.xy().length_squared();\n  if (speed_squared > 0.01f && copter.position_ok) {\n    look_ahead_yaw = atan2f(vel.x, vel.y);\n  }\n  return look_ahead_yaw;\n}", "CodeBleu_score": 37.35963830303224}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\n        if (plane.get_rudder_arming_type() == AP_Rudder::DISABLED || plane.get_throttle_input() != 0) {\n            gcs().send_text_fmt(PSTR(\"Arming disabled by rudder arming\"));\n            return false;\n        }\n    }\n    if (hal.util->was_watchdog_armed()) {\n        gcs().send_text_fmt(PSTR(\"Arming disabled by watchdog\"));\n        return false;\n    }\n    if (AP_Arming::arm_checks(method)) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 59.04130467342728}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\n        if (plane.get_rudder_arming_type() == AP_Rudder::ARMING_DISABLED) {\n            gcs().send_text_fmt(PSTR(\"Rudder arming disabled\"));\n            return false;\n        }\n        if (plane.get_throttle_input() != 0) {\n            gcs().send_text_fmt(PSTR(\"Throttle not zero\"));\n            return false;\n        }\n    }\n    if (AP_Arming::arm_checks(method)) {\n        if (hal.util->was_watchdog_armed()) {\n            gcs().send_text_fmt(PSTR(\"Watchdog armed\"));\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 59.93532103064837}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (plane.get_rudder_arming_type() == AP_Rudder::DISABLED) {\n\t\t\tgcs().send_text_fmt(PSTR(\"Rudder arming disabled\"));\n\t\t\treturn false;\n\t\t}\n\t\tif (plane.get_throttle_input() != 0) {\n\t\t\tgcs().send_text_fmt(PSTR(\"Throttle not zero\"));\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (is_zero(method)) {\n\t\tif (hal.util->was_watchdog_armed()) {\n\t\t\tgcs().send_text_fmt(PSTR(\"Watchdog armed\"));\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 53.85491991894645}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tbool ret = false;\n    if (method == AP_ARMING_METHOD_ARM_CHECK) {\n        if (do_arming_checks) {\n            if (!check_arming_ok()) {\n                send_arm_disarm_statustext(AP_ARMING_STATUSTEXT_DISARMED_ARMING_CHECK_FAILED);\n                return false;\n            }\n        }\n        if (!check_pre_arm_conditions()) {\n            send_arm_disarm_statustext(AP_ARMING_STATUSTEXT_DISARMED_PRE_ARM_FAILED);\n            return false;\n        }\n        if (!check_throttle_range()) {\n            send_arm_disarm_statustext(AP_ARMING_STATUSTEXT_DISARMED_THROTTLE_RANGE);\n            return false;\n        }\n    }\n    if (method == AP_ARMING_METHOD_ARM_CHECK || method == AP_ARMING_METHOD_ARM_WITH_CHECK) {\n        if (!check_battery_voltage()) {\n            send_arm_disarm_statustext(AP_ARMING_STATUSTEXT_DISARMED_BATTERY_VOLTAGE);\n            return false;\n        }\n    }\n    if (method == AP_ARMING_METHOD_ARM_CHECK || method == AP_ARMING_METHOD_ARM_WITH_CHECK) {\n        if (!check_battery_current()) {\n            send_arm_disarm_statustext(AP_ARMING_STATUSTEXT_DISARMED_BATTERY_CURRENT);\n            return false;\n        }\n    }\n    if (method == AP_ARMING_METHOD_ARM_CHECK || method == AP_ARMING_METHOD_ARM_WITH_CHECK) {\n        if (!check_battery_power()) {\n            send_arm_disarm_statustext(AP_ARMING_STAT", "CodeBleu_score": 40.928328723680416}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tbool success = false;\n    bool set_home = false;\n    bool armed_changed = false;\n\n    // if we are already armed, do nothing\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // if we are in failsafe mode, do not arm\n    if (hal.util->get_soft_failsafe()) {\n        return false;\n    }\n\n    // if we are in manual mode, do not arm\n    if (hal.util->get_manual_override_switch()) {\n        return false;\n    }\n\n    // if we are in RTL mode, do not arm\n    if (hal.rc_get_sw2()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.util->get_low_battery()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.rc_get_sw3()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.rc_get_sw4()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.rc_get_sw5()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.rc_get_sw6()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.rc_get_sw7()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.rc_get_sw8()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.rc_get_sw9()) {\n        return false;\n    }\n\n    // if we are in a low battery mode, do not arm\n    if (hal.rc_get_sw", "CodeBleu_score": 28.55948678555177}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tif (method == AP_ARMING_METHOD_INITIALISED) {\n        // initialised arming is only allowed if we are in a non-armed state\n        if (plane.control_mode != MANUAL && plane.control_mode != STABILIZE && plane.control_mode != ACRO && plane.control_mode != AUTO) {\n            return false;\n        }\n    }\n\n    if (method == AP_ARMING_METHOD_ARMED) {\n        // arming checks are only allowed if we are in a non-armed state\n        if (plane.control_mode != MANUAL && plane.control_mode != STABILIZE && plane.control_mode != ACRO && plane.control_mode != AUTO) {\n            return false;\n        }\n    }\n\n    if (method == AP_ARMING_METHOD_GPS_WPNEXT || method == AP_ARMING_METHOD_GPS_WPINDEX) {\n        // arming checks are only allowed if we are in a non-armed state\n        if (plane.control_mode != MANUAL && plane.control_mode != STABILIZE && plane.control_mode != ACRO && plane.control_mode != AUTO) {\n            return false;\n        }\n    }\n\n    if (method == AP_ARMING_METHOD_GPS_NAV_RTH) {\n        // arming checks are only allowed if we are in a non-armed state\n        if (plane.control_mode != MANUAL && plane.control_mode != STABILIZE && plane.control_mode != ACRO && plane.control_mode != AUTO) {\n            return false;\n        }\n    }\n\n    if (method == AP_ARMING_METHOD_GPS_NAV_LOITER) {\n        // arming checks are only allowed if we are in a non-armed state\n        if (plane.control_mode != MANUAL && plane.control_mode != STABILIZE && plane.control_mode != ACRO && plane.control_mode != AUTO)", "CodeBleu_score": 41.160752361910724}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if the vehicle is already armed, return true\n    if (sub.armed()) {\n        return true;\n    }\n\n    // if the craft has a disarm button, check it\n    if (has_disarm_function()) {\n        // if the disarm button is pressed, disarm the vehicle\n        if (sub.get_button(0)->pressed()) {\n            sub.disarm();\n            return false;\n        }\n    }\n\n    // if the craft does not have a disarm button, display a failure message if requested\n    if (display_failure) {\n        AP_Notify::flags.arm_no_disarm = true;\n    }\n    return false;\n}", "CodeBleu_score": 56.19080872190947}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if we're already armed, return true\n    if (sub.get_armed()) {\n        return true;\n    }\n\n    // if we don't have a disarm button, display a failure message if requested and return false\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            AP_Notify::flags.arming_failed = true;\n        }\n        return false;\n    }\n\n    // if we have a disarm button, run the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.99198543177334}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (sub.armed()) {\n        return true;\n    }\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            AP_Notify::flags.display_prearm_check_failed = true;\n        }\n        return false;\n    }\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.0960965517953}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n    float ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 62.30803172129984}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x*cos(ahrs.yaw) - y*sin(ahrs.yaw);\n\tfloat ne_y = x*sin(ahrs.yaw) + y*cos(ahrs.yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 59.44379233777972}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n\tfloat ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 59.22122201978088}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t// Check if the yaw angle is within the acceptable range\n\tif (packet.param1 < -180.0f || packet.param1 > 180.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if param4 is within the acceptable range\n\tif (packet.param4 < 0.0f || packet.param4 > 1.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters\n\t_mission_type.mode_auto.set_auto_yaw_heading(packet.param1, packet.param4);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.688597303238346}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t// Check if the yaw angle and param4 values are within acceptable ranges\n\tif (packet.param1 < -180.0f || packet.param1 > 180.0f || packet.param4 < 0.0f || packet.param4 > 180.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters\n\t_mission_type.set_yaw_heading(packet.param1, packet.param4);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 42.72972463833845}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_DENIED;\n    uint16_t target_system = packet.target_system;\n    uint8_t target_component = packet.target_component;\n    uint8_t condition_number = packet.param1;\n    float yaw_angle_deg = packet.param2;\n    float yaw_speed_deg_s = packet.param3;\n    float yaw_distance_deg = packet.param4;\n    bool is_relative = packet.param5;\n    bool is_async = packet.param6;\n    bool is_message_sent = packet.param7;\n    float yaw_angle_min = packet.param8;\n    float yaw_angle_max = packet.param9;\n    float yaw_speed_min = packet.param10;\n    float yaw_speed_max = packet.param11;\n    float yaw_distance_min = packet.param12;\n    float yaw_distance_max = packet.param13;\n\n    // Check if the command is valid\n    if (is_zero(yaw_angle_deg) && is_zero(yaw_speed_deg_s) && is_zero(yaw_distance_deg) && !is_relative && !is_async && !is_message_sent && is_equal(yaw_angle_min, 0) && is_equal(yaw_angle_max, 0) && is_equal(yaw_speed_min, 0) && is_equal(yaw_speed_max, 0) && is_equal(yaw_distance_min, 0) && is_equal(yaw_distance_max, 0)) {\n        result = MAV_RESULT_ACCEPTED;\n    }\n\n    // Check if the yaw angle is within the range\n    if (yaw_angle_deg < yaw_angle_min || yaw_angle_deg > yaw_angle_max) {\n        result = MAV_RESULT_DENIED;\n    }\n\n    // Check if the yaw speed is within the range\n    if (yaw_speed_deg", "CodeBleu_score": 40.014154910793245}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.139455216244209}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.139455216244209}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n\t\treturn (wp_nav.get_wp_bearing_to_destination() + 18000) / 2;\n\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 41.89964875275278}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (!should_log) return;\n\tLog_Packet_Header_Init();\n\tlog_packet.id = id;\n\tlog_packet.value = value;\n\tlogger.WriteCriticalBlock(&log_packet, LOG_PACKET_SIZE);\n}", "CodeBleu_score": 36.556403126431974}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (!should_log) {\n\t\treturn;\n\t}\n\t\n\t// Create a log packet\n\tLogPacketHeader header;\n\theader.Init(id, AP_HAL::micros64());\n\t\n\t// Write the packet to the logger as a critical block\n\tlogger.WriteCriticalBlock((const uint8_t*)&header, sizeof(LogPacketHeader));\n\tlogger.WriteCriticalBlock((const uint8_t*)&value, sizeof(int32_t));\n}", "CodeBleu_score": 39.1003551128412}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (!should_log) {\n\t\treturn;\n\t}\n\tAP_HAL::CriticalSection cs;\n\tif (!logger.WriteCriticalBlock(log_packet_header_init, sizeof(log_packet_header_init))) {\n\t\treturn;\n\t}\n\tif (!logger.WriteCriticalBlock((uint8_t*)&id, sizeof(id))) {\n\t\treturn;\n\t}\n\tif (!logger.WriteCriticalBlock((uint8_t*)&value, sizeof(value))) {\n\t\treturn;\n\t}\n\tif (!logger.WriteCriticalBlock(log_packet_footer_init, sizeof(log_packet_footer_init))) {\n\t\treturn;\n\t}\n}", "CodeBleu_score": 38.258228691396276}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\tif (ahrs.home_is_set()) {\n        return;\n    }\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 55.543990573553224}, {"code": "void Sub::update_home_from_EKF(){\n\tif (ahrs.home_is_set()) {\n        return;\n    }\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 55.543990573553224}, {"code": "void Sub::update_home_from_EKF(){\n\tif (home_is_set) {\n        return;\n    }\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 50.02560266038398}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\tif (!motors.armed()) {\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(Motors::UnlimitedThrottle);\n\t\tattitude_control.relax_attitude_controllers();\n\t\treturn;\n\t}\n\t// 1. Set the spool state to unlimited throttle.\n\tmotors.set_desired_spool_state(Motors::UnlimitedThrottle);\n\t// 2. Get the pilot's desired body frame rates.\n\tVector3f pilot_desired_rate = get_pilot_desired_angle_rates();\n\t// 3. Convert pilot inputs to desired body frame rates.\n\tVector3f desired_body_frame_rates = attitude_control.input_rate_bf_roll_pitch_yaw(pilot_desired_rate);\n\t// 4. Run the attitude controller with these rates.\n\tattitude_control.set_throttle_out(motors.get_throttle());\n\tattitude_control.set_body_rates_in(desired_body_frame_rates);\n\tattitude_control.set_roll_pitch_rate_slew_rate_in(Vector3f(pilot_desired_rate));\n\t// 5. Set the forward and lateral motor inputs based on pilot controls.\n\tmotors.set_forward(channel_forward->norm_input);\n\tmotors.set_lateral(channel_lateral->norm_input);\n\t// 6. Set the throttle output.\n\tmotors.set_throttle(channel_throttle->norm_input);\n\t// 7. Set the yaw output.\n\tmotors.set_yaw(channel_yaw->get_control_in());\n\t// 8. Set the yaw rate output.\n\tmotors.set_yaw_rate(channel_yaw->get_control_in());\n\t// 9. Set the yaw spin output.\n\tmotors.set_yaw_spin(channel_yaw->get_control_in", "CodeBleu_score": 51.58275730672359}, {"code": "void ModeAcro::run(){\n\tif (!motors.armed()) {\n        motors.set_throttle(0);\n        motors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n        attitude_control.relax_attitude_controllers();\n        return;\n    }\n    motors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n    float roll = channel_roll->get_control_in();\n    float pitch = channel_pitch->get_control_in();\n    float yaw = channel_yaw->get_control_in();\n    float throttle = channel_throttle->norm_input();\n    float desired_body_frame_rates[3];\n    get_pilot_desired_angle_rates(desired_body_frame_rates, roll, pitch, yaw);\n    attitude_control.set_throttle_out(throttle);\n    attitude_control.set_body_frame_rates_from_pilot(desired_body_frame_rates);\n    motors.set_forward(motors.get_desired_forward());\n    motors.set_lateral(motors.get_desired_lateral());\n}", "CodeBleu_score": 52.4930847085885}, {"code": "void ModeAcro::run(){\n\t// if the motors are not armed, do nothing\n\tif (!motors.armed()) {\n\t\tmotors.set_throttle_out(0);\n\t\tmotors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t// otherwise, run the attitude controller\n\tfloat roll_angle_rate_bf = pilot_desired_angle_rates.roll;\n\tfloat pitch_angle_rate_bf = pilot_desired_angle_rates.pitch;\n\tfloat yaw_angle_rate_bf = pilot_desired_angle_rates.yaw;\n\n\t// convert pilot inputs to desired body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs to body frame rates\n\t// TODO: this is the only place where we convert pilot inputs", "CodeBleu_score": 29.745122312053418}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.get_stopping_point());\n    sub.wp_nav.wp_and_spline_init();\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n    sub.wp_nav.set_mode(WP_NAV_MODE_POS_HOLD);\n}", "CodeBleu_score": 47.70125653175692}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set position control mode\n    set_control_mode(GUIDED_POSITION);\n\n    // initialize waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // set default auto yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n\n    // set destination\n    sub.wp_nav.set_wp_destination(sub.wp_nav.get_stopping_point());\n}", "CodeBleu_score": 42.44626976889828}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set position control mode\n    sub.pos_control_mode = POSCTRL_POSITION;\n\n    // set waypoint controller to position control\n    sub.wp_nav.wp_and_spline_init();\n\n    // set default auto yaw mode\n    sub.set_auto_yaw_mode(sub.get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 37.163430045848905}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// initialise max speed and acceleration\n    position_control->set_max_speed_accel_xy(sub.get_pilot_speed_xy());\n    position_control->set_max_speed_accel_z(sub.get_pilot_speed_dn());\n\n    // initialise the velocity controllers\n    position_control->init_xy_controller();\n    position_control->init_z_controller();\n\n    // set the yaw control mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 44.42328575042032}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set max speeds and accelerations\n    position_control->set_max_speed_xy(sub.get_pilot_speed_xy());\n    position_control->set_max_speed_z(sub.get_pilot_speed_z());\n    position_control->set_max_accel_xy(sub.get_pilot_accel_xy());\n    position_control->set_max_accel_z(sub.get_pilot_accel_z());\n\n    // initialize velocity controllers\n    position_control->init_xy_controller();\n    position_control->init_z_controller();\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 52.73287942597731}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set guided mode to velocity control\n    sub.guided_mode = GUIDED_MODE_VELOCITY;\n\n    // initialize vertical max speeds and acceleration\n    sub.init_z_controller();\n    sub.init_xy_controller();\n\n    // initialize vertical and horizontal velocity controllers\n    position_control->init_z_controller();\n    position_control->init_xy_controller();\n\n    // set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 46.14766355487835}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t// If the vehicle has been in guided mode for more than the specified limit, terminate guided mode.\n\tif (hrt_absolute_time() - guided_limit.start_time_us > guided_limit.duration_us) {\n\t\treturn true;\n\t}\n\n\t// If the altitude is below the minimum altitude threshold, terminate guided mode.\n\tif (inertial_nav.get_position_neu_cm().z < guided_limit.min_alt_cm) {\n\t\treturn true;\n\t}\n\n\t// If the altitude is above the maximum altitude threshold, terminate guided mode.\n\tif (inertial_nav.get_position_neu_cm().z > guided_limit.max_alt_cm) {\n\t\treturn true;\n\t}\n\n\t// If the horizontal distance moved exceeds the specified limit, terminate guided mode.\n\tif (get_horizontal_distance_cm() > guided_limit.max_horizontal_distance_cm) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 34.438285725555396}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// check if we have reached the maximum altitude\n  if (guided_limit.max_altitude != 0.0f && _global_pos.alt < guided_limit.max_altitude) {\n    return true;\n  }\n\n  // check if we have reached the minimum altitude\n  if (guided_limit.min_altitude != 0.0f && _global_pos.alt > guided_limit.min_altitude) {\n    return true;\n  }\n\n  // check if we have reached the maximum horizontal distance\n  if (guided_limit.max_distance != 0.0f) {\n    // calculate the distance moved\n    Vector2f dist = _global_pos.coord_body - guided_limit.start_pos.xy;\n    float dist_cm = dist.length();\n\n    if (dist_cm > guided_limit.max_distance) {\n      return true;\n    }\n  }\n\n  // check if we have reached the maximum horizontal distance\n  if (guided_limit.max_distance_xy != 0.0f) {\n    // calculate the distance moved\n    Vector2f dist = _global_pos.coord_body - guided_limit.start_pos.xy;\n    float dist_cm = dist.length();\n\n    if (dist_cm > guided_limit.max_distance_xy) {\n      return true;\n    }\n  }\n\n  // check if we have reached the maximum horizontal distance\n  if (guided_limit.max_distance_z != 0.0f) {\n    // calculate the distance moved\n    float dist_cm = get_horizontal_distance_cm();\n\n    if (dist_cm > guided_limit.max_distance_z) {\n      return true;\n    }\n  }\n\n  // check if we have reached the maximum horizontal distance\n  if (guided_limit.max_distance_xy_z != 0.0f) {\n    // calculate the distance moved\n    float dist_cm = get_horizontal_distance_cm();\n\n    if (dist_cm > guided_limit.max_distance_xy_z) {\n      return", "CodeBleu_score": 56.49075208588082}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// if we have not reached the minimum altitude yet, do not allow guided mode to terminate\n\tif (guided_limit.min_alt > 0) {\n\t\tif (curr_pos.z < guided_limit.min_alt) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// if we have not reached the maximum altitude yet, do not allow guided mode to terminate\n\tif (guided_limit.max_alt > 0) {\n\t\tif (curr_pos.z > guided_limit.max_alt) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// if we have not reached the minimum horizontal distance yet, do not allow guided mode to terminate\n\tif (guided_limit.min_distance > 0) {\n\t\tif (get_horizontal_distance_cm() < guided_limit.min_distance) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// if we have not reached the maximum horizontal distance yet, do not allow guided mode to terminate\n\tif (guided_limit.max_distance > 0) {\n\t\tif (get_horizontal_distance_cm() > guided_limit.max_distance) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// if we have not reached the maximum horizontal distance yet, do not allow guided mode to terminate\n\tif (guided_limit.max_time > 0) {\n\t\tif (is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_zero(is_", "CodeBleu_score": 47.43361022216036}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t// Check if the motor test has timed out\n    if (millis() - motor_test_start > MOTOR_TEST_TIMEOUT) {\n        // Send a timeout message\n        gcs().send_text_fmt(PSTR(\"Motor test timed out\"));\n        // Disable the motor test\n        motor_test_enabled = false;\n        // Disarm the system\n        arming().disarm();\n        // Record the failure time\n        motor_test_failure_time = millis();\n        // Return false\n        return false;\n    }\n\n    // If the motor test has passed\n    if (motor_test_pass) {\n        // Return true\n        return true;\n    }\n\n    // If the motor test has failed\n    if (motor_test_fail) {\n        // Send a failure message\n        gcs().send_text_fmt(PSTR(\"Motor test failed\"));\n        // Disable the motor test\n        motor_test_enabled = false;\n        // Disarm the system\n        arming().disarm();\n        // Record the failure time\n        motor_test_failure_time = millis();\n        // Return false\n        return false;\n    }\n\n    // If the motor test has not timed out and has not passed or failed\n    // Send a message to the GCS\n    gcs().send_text_fmt(PSTR(\"Motor test in progress\"));\n    // Return false\n    return false;\n}", "CodeBleu_score": 47.671808230268724}, {"code": "bool Sub::verify_motor_test(){\n\tif (motor_test_pass) {\n\t\t// If the motor test has passed, return true.\n\t\treturn true;\n\t}\n\n\t// If the motor test has not passed, check if the motor test requests are received at least every 2 Hz.\n\tif (AP_HAL::millis() - last_motor_test_request_time >= 500) {\n\t\t// If the motor test requests are not received at least every 2 Hz, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false.\n\t\tgcs().send_text_fmt(PSTR(\"Motor test timed out.\"));\n\t\tmotor_test_pass = false;\n\t\tmotor_test_enabled = false;\n\t\tarmed.armed = false;\n\t\tlast_motor_test_failure_time = AP_HAL::millis();\n\t\treturn false;\n\t}\n\n\t// If the motor test requests are received at least every 2 Hz, return true.\n\treturn true;\n}", "CodeBleu_score": 53.10745171844715}, {"code": "bool Sub::verify_motor_test(){\n\tif (motor_test_request_count == 0) {\n\t\tmotor_test_request_count = 1;\n\t\tmotor_test_request_time = millis();\n\t\treturn true;\n\t}\n\n\tif (millis() - motor_test_request_time > 500) {\n\t\tmotor_test_request_count = 0;\n\t\tmotor_test_pass = false;\n\t\tmotor_test_request_time = millis();\n\t\tarming().disarm();\n\t\tgcs().send_text_fmt(PSTR(\"Motor test timeout\"));\n\t\tmotor_test_fail_time = millis();\n\t\treturn false;\n\t}\n\n\tif (motor_test_request_count >= 20) {\n\t\tmotor_test_pass = true;\n\t\tmotor_test_request_count = 0;\n\t\tmotor_test_request_time = millis();\n\t\treturn true;\n\t}\n\n\treturn true;\n\n}", "CodeBleu_score": 46.61734897612252}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t//TODO: Check if the roll and pitch values are within the specified range\n    //TODO: Normalize the roll and pitch values\n    //TODO: Assign the normalized values to lateral_out and forward_out\n}", "CodeBleu_score": 3.647387792519552}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// TODO: This is a stub, replace with real code.\n  lateral_out = 0;\n  forward_out = 0;\n  // TODO: This is a stub, replace with real code.\n}", "CodeBleu_score": 8.584376967010396}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Get roll and pitch targets from wp_nav in centidegrees.\n  int16_t wp_roll = wp_nav.get_roll();\n  int16_t wp_pitch = wp_nav.get_pitch();\n\n  // Constrain these targets within a specified maximum angle range.\n  wp_roll = constrain_int16(wp_roll, -wp_nav_max_roll, wp_nav_max_roll);\n  wp_pitch = constrain_int16(wp_pitch, -wp_nav_max_pitch, wp_nav_max_pitch);\n\n  // Normalize these targets.\n  float wp_roll_norm = wp_roll / wp_nav_max_roll;\n  float wp_pitch_norm = wp_pitch / wp_nav_max_pitch;\n\n  // Assign the normalized values to lateral_out and forward_out.\n  lateral_out = wp_roll_norm;\n  forward_out = wp_pitch_norm;\n\n  // Print the roll and pitch targets to the console.\n  // printf(\"wp_roll = %d, wp_pitch = %d, wp_roll_norm = %f, wp_pitch_norm = %f, lateral_out = %f, forward_out = %f\n\", wp_roll, wp_pitch, wp_roll_norm, wp_pitch_norm, lateral_out, forward_out);\n}", "CodeBleu_score": 42.524894117036794}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\tbarometer.update();\n  if (barometer.healthy()) {\n    if (barometer.get_altitude() > 0) {\n      barometer.update_calibration();\n    }\n    if (depth_sensor_present) {\n      depth_sensor.healthy = barometer.healthy();\n    }\n  }\n}", "CodeBleu_score": 72.35408705240991}, {"code": "void Sub::read_barometer(){\n\tbarometer.update();\n  if (barometer.healthy()) {\n    if (barometer.get_altitude() > 0) {\n      barometer_calibration = barometer.get_altitude();\n    }\n    if (barometer.get_altitude() < 0) {\n      barometer_calibration = -barometer.get_altitude();\n    }\n    if (barometer.get_altitude() == 0) {\n      barometer_calibration = 0;\n    }\n  }\n  else {\n    barometer_calibration = 0;\n    if (barometer.get_altitude() > 0) {\n      barometer_calibration = barometer.get_altitude();\n    }\n    if (barometer.get_altitude() < 0) {\n      barometer_calibration = -barometer.get_altitude();\n    }\n    if (barometer.get_altitude() == 0) {\n      barometer_calibration = 0;\n    }\n  }\n  if (barometer_calibration > 0) {\n    barometer_calibration_status = true;\n  }\n  else {\n    barometer_calibration_status = false;\n  }\n  if (barometer_calibration_status == true) {\n    if (barometer_calibration < 100) {\n      barometer_calibration = 100;\n    }\n    if (barometer_calibration > 100) {\n      barometer_calibration = barometer_calibration - 100;\n    }\n    if (barometer_calibration == 100) {\n      barometer_calibration = 100;\n    }\n  }\n  else {\n    if (barometer_calibration < 100) {\n      barometer_calibration = 100;\n    }\n    if (barometer_calibration > 100) {\n      barometer_calibration = barometer_calibration - 100;\n    }\n    if (barometer_calibration == 100) {\n      barometer_calibration", "CodeBleu_score": 45.945673699456115}, {"code": "void Sub::read_barometer(){\n\tbarometer.update();\n  if (barometer.healthy()) {\n    if (barometer.get_altitude() > 0) {\n      barometer.update_calibration();\n    }\n    if (depth_sensor_present) {\n      depth_sensor_healthy = barometer.healthy();\n    }\n  }\n}", "CodeBleu_score": 72.6135495864776}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\tif (!ahrs.have_inertial_nav()) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed()) {\n\t\treturn ekf.get_filter_status().absolute_position_ok;\n\t}\n\n\tif (!ekf.get_filter_status().absolute_position_ok) {\n\t\treturn false;\n\t}\n\n\tif (ekf.get_filter_status().constant_position_mode) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.82953105102027}, {"code": "bool Sub::ekf_position_ok(){\n\tif (!ahrs.have_inertial_nav()) {\n\t\treturn false;\n\t}\n\n\tif (motors.armed()) {\n\t\tif (inertial_nav.get_filter_status() == INS_FILTER_STATUS_CONSTANT_POSITION) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (inertial_nav.get_filter_status() == INS_FILTER_STATUS_PREDICTED_POSITION) {\n\t\t\tif (inertial_nav.get_filter_status_time() > 10000000) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 46.9337612768446}, {"code": "bool Sub::ekf_position_ok(){\n\tif (!ahrs.have_inertial_nav()) {\n\t\treturn false;\n\t}\n\tif (!motors.armed()) {\n\t\treturn ekf.get_filter_status().absolute_position_ok;\n\t} else {\n\t\treturn ekf.get_filter_status().absolute_position_ok && !ekf.get_filter_status().constant_position_mode;\n\t}\n}", "CodeBleu_score": 48.87399442982472}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!rover.ahrs_status_ok()) {\n\t\tif (display_failure) {\n\t\t\tprint_reject(\"AHRS system not ready\");\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (rover.ekf_failsafe_status_ok()) {\n\t\tif (display_failure) {\n\t\t\tprint_reject(\"EKF failsafe active\");\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!rover.ekf_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tprint_reject(\"EKF position estimate invalid\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 43.39333612900415}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check that AHRS is ready\n    if (!rover.ahrs.initialised()) {\n        if (display_failure) {\n            AP_Notify::flags.rover_gps_check_failed = true;\n            AP_Notify::notify(AP_NOTIFY_WARNING, AP_NOTIFY_ROVER_GPS_CHECK_FAILED);\n        }\n        return false;\n    }\n\n    // check that EKF failsafe is inactive\n    if (rover.ekf.failsafe_status()) {\n        if (display_failure) {\n            AP_Notify::flags.rover_gps_check_failed = true;\n            AP_Notify::notify(AP_NOTIFY_WARNING, AP_NOTIFY_ROVER_GPS_CHECK_FAILED);\n        }\n        return false;\n    }\n\n    // check that EKF position estimate is valid\n    if (!rover.ekf.position_ok()) {\n        if (display_failure) {\n            AP_Notify::flags.rover_gps_check_failed = true;\n            AP_Notify::notify(AP_NOTIFY_WARNING, AP_NOTIFY_ROVER_GPS_CHECK_FAILED);\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 54.136657297850874}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check for AHRS system ready\n    if (!rover.ahrs.status_ok()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"AHRS not ready\n\"));\n        }\n        return false;\n    }\n\n    // check for EKF failsafe\n    if (rover.ekf_position_ok == false) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"EKF position check failed\n\"));\n        }\n        return false;\n    }\n\n    // check for position estimate valid\n    if (rover.control_mode->requires_position) {\n        if (!rover.control_mode->position_valid()) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Position estimate invalid\n\"));\n            }\n            return false;\n        }\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 55.58085889806458}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (method == AP_Arming::ARM_CHECK) {\n        return do_arming_checks ? do_arming_checks() : true;\n    }\n    if (method == AP_Arming::ARM_CHECK_VTOL) {\n        return do_arming_checks ? do_arming_checks(true) : true;\n    }\n\n    // set the arming state\n    _arming_state = ARMED_STATE_ARMED;\n\n    // set the arming method\n    _arming_method = method;\n\n    // set the arming time\n    _arming_time = hal.scheduler->millis();\n\n    // set the arming reason\n    _arming_reason = ARMING_REASON_NONE;\n\n    // set the arming event\n    _arming_event = ARMING_EVENT_NONE;\n\n    // set the arming_failed event\n    _arming_failed = false;\n\n    // set the arming_failed_reason\n    _arming_failed_reason = ARMING_FAILED_REASON_NONE;\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arm_disarm_statustext();\n\n    // set the home location\n    rover.g2.smart_rtl.set_home();\n\n    // initialize the simple mode heading\n    rover.mode_simple.init_heading();\n\n    // record the home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    return true;\n}", "CodeBleu_score": 44.91248093597674}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tbool ret = false;\n\n    switch (method) {\n    case AP_ARMING_METHOD_INITIALIZE:\n        if (is_armed()) {\n            ret = true;\n            break;\n        }\n        ret = initialize_arming(do_arming_checks);\n        break;\n\n    case AP_ARMING_METHOD_SMART_RTL:\n        if (is_armed()) {\n            ret = true;\n            break;\n        }\n        ret = smart_rtl_arming(do_arming_checks);\n        break;\n\n    case AP_ARMING_METHOD_MANUAL_OVERRIDE:\n        if (is_armed()) {\n            ret = true;\n            break;\n        }\n        ret = manual_override_arming(do_arming_checks);\n        break;\n\n    case AP_ARMING_METHOD_DISARM_LAND:\n        if (is_armed()) {\n            ret = true;\n            break;\n        }\n        ret = disarm_land_arming(do_arming_checks);\n        break;\n\n    case AP_ARMING_METHOD_DISARM_IN_AIR:\n        if (is_armed()) {\n            ret = true;\n            break;\n        }\n        ret = disarm_in_air_arming(do_arming_checks);\n        break;\n\n    case AP_ARMING_METHOD_DISARM_ALL:\n        if (is_armed()) {\n            ret = true;\n            break;\n        }\n        ret = disarm_all_arming(do_arming_checks);\n        break;\n\n    default:\n        ret = false;\n        break;\n    }\n\n    if (ret) {\n        // if we get here, we've successfully armed, so update the soft armed status\n        update_soft_armed();\n    }\n\n    return ret;\n}", "CodeBleu_score": 37.45968269515337}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// if we're already armed, return true\n    if (is_armed()) {\n        return true;\n    }\n\n    // if we're not armed, set the arming method\n    _arming_method = method;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the arming state to arming\n    _arming_state = ARMING_STATE_ARMING;\n\n    // if we're not armed, set the", "CodeBleu_score": 31.521613240058578}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (status_message.charging_enabled) {\n            if (checkShouldCharge()) {\n                status_message.charging_enabled = false;\n                status_message.charging_enabled_time = millis();\n            }\n        } else {\n            if (!checkShouldCharge()) {\n                status_message.charging_enabled = true;\n            }\n        }\n    } else {\n        if (status_message.charging_enabled) {\n            status_message.charging_enabled = false;\n            status_message.charging_enabled_time = millis();\n        }\n        if (millis() - status_message.charging_enabled_time > 1000) {\n            if (checkShouldCharge()) {\n                status_message.charging_enabled = true;\n                status_message.charging_enabled_time = millis();\n            }\n        }\n    }\n}", "CodeBleu_score": 44.0111388792785}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (shouldCharge()) {\n            if (charging_enabled) {\n                if (shouldDisableCharging()) {\n                    charging_enabled = false;\n                    charging_disabled_time = millis();\n                }\n            } else {\n                charging_enabled = true;\n            }\n        } else {\n            charging_enabled = false;\n            charging_disabled_time = millis();\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            charging_disabled_time = millis();\n        }\n        if (millis() - charging_disabled_time > 60000) {\n            charging_allowed = true;\n            charging_disabled_time = 0;\n        }\n    }\n}", "CodeBleu_score": 53.457533077337736}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (should_charge()) {\n            if (status_message.charging_enabled) {\n                if (!status_message.charging_current) {\n                    status_message.charging_enabled = false;\n                    status_message.charging_disabled_time = millis();\n                }\n            } else {\n                status_message.charging_enabled = true;\n            }\n        } else {\n            status_message.charging_enabled = false;\n        }\n    } else {\n        if (status_message.charging_enabled) {\n            status_message.charging_enabled = false;\n            status_message.charging_disabled_time = millis();\n        }\n        if (millis() - status_message.charging_disabled_time > 1000) {\n            if (should_charge()) {\n                status_message.charging_enabled = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 38.08500640026544}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\tif (rosRunning && size >= 4) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    uint8_t *msg = (uint8_t *)message;\n    msg[size] = crc >> 8;\n    msg[size + 1] = crc & 0xFF;\n    packetSerial.send(msg, size + 2);\n  }\n}", "CodeBleu_score": 52.564185441971745}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ros_running && size > 3) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    ((uint16_t*)message)[size / 2 - 1] = crc;\n    packetSerial.send((const uint8_t*)message, size);\n  }\n}", "CodeBleu_score": 37.81574114816932}, {"code": "void sendMessage(void *message, size_t size){\n\tif (rosRunning && size >= 4) {\n    uint16_t crc = CRC16.ccitt(message, size - 2);\n    ((uint16_t*) message)[size / 2 - 1] = crc;\n    packetSerial.send((const uint8_t*) message, size);\n  }\n}", "CodeBleu_score": 39.17573959520194}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t// Initialize serial communication with sound module\n  soundSerial.begin(9600);\n  soundSerial.flush();\n\n  // Initialize sound module\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0x7E);\n\n  // Retrieve number of sound files available\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x02);\n  soundSerial.write(0x7E);\n  soundSerial.flush();\n  soundSerial.read();\n  numSdTracks = soundSerial.read();\n  numSdTracks = (numSdTracks << 8) | soundSerial.read();\n  numSdTracks = (numSdTracks << 8) | soundSerial.read();\n  numSdTracks = (numSdTracks << 8) | soundSerial.read();\n  soundSerial.flush();\n\n  return numSdTracks > 0;\n}", "CodeBleu_score": 44.333601947980235}, {"code": "bool MP3Sound::begin(){\n\t// Initialize serial communication\n    soundSerial.begin(9600);\n    soundSerial.flush();\n\n    // Initialize sound module\n    soundSerial.write(0x7E);\n    soundSerial.write(0xFF);\n    soundSerial.write(0x06);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x01);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);", "CodeBleu_score": 36.86187783208366}, {"code": "bool MP3Sound::begin(){\n\t// Clear the serial buffer\n  soundSerial.flush();\n\n  // Initialize the serial communication\n  soundSerial.begin(9600);\n\n  // Initialize the sound module\n  soundSerial.write(0x7E);\n  soundSerial.write(0x00);\n  soundSerial.write(0x02);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  sound", "CodeBleu_score": 35.70080695249344}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t} else {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.2946511255404}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0) {\n    return active_sounds.size();\n  }\n  else if (active_sounds.size() == 1 && myMP3.isPlaying()) {\n    return active_sounds.size();\n  }\n  else {\n    myMP3.play(active_sounds.back());\n    active_sounds.pop_back();\n    return active_sounds.size();\n  }\n}", "CodeBleu_score": 45.37778402920978}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0) {\n    return 0;\n  }\n  if (myMP3.isPlaying()) {\n    return active_sounds.size();\n  }\n  myMP3.play(active_sounds.back());\n  active_sounds.pop_back();\n  return active_sounds.size();\n}", "CodeBleu_score": 48.43402411009047}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *c = d->pdata;\n  bool handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (c->mmap_file)\n        munmap(c->mmap_file, c->mmap_size);\n      c->mmap_file = NULL;\n      c->mmap_size = 0;\n      wb_camera_request_memory_mapped_file(r, c->tag);\n      c->mmap_file = mmap(0, r->size, PROT_READ, MAP_SHARED, r->fd, 0);\n      c->mmap_size = r->size;\n      break;\n    default:\n      handled = false;\n  }\n  return handled;\n}", "CodeBleu_score": 56.663349448073916}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_abstract_camera_cleanup_memory_mapped_file(c);\n      wb_abstract_camera_setup_memory_mapped_file(c, r);\n      return true;\n    default:\n      c->command_handled = false;\n      return false;\n  }\n}", "CodeBleu_score": 47.17187454676169}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_abstract_camera_cleanup_mmap(c);\n      wb_abstract_camera_setup_mmap(c, r);\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 44.496612121711465}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock_step();\n  int height = wb_abstract_camera_get_height_fast(d);\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 45.24703090033872}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock_step();\n  int height = -1;\n  if (wb_abstract_camera_get_sampling_period(d) > 0) {\n    AbstractCamera *ac = d->pdata;\n    if (ac) {\n      height = ac->height;\n    }\n  }\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 62.150547053573526}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock_step();\n  int result = wb_abstract_camera_get_height_helper(d);\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 48.68131520957776}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 55.33717718465916}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  robot_mutex_lock_step();\n  accelerometer_get_struct(tag);\n  if (accelerometers[tag].tag != tag) {\n    robot_mutex_unlock_step();\n    fprintf(stderr, \"Error: %s() called with an invalid tag (%d).\n\", __FUNCTION__, tag);\n    return -1;\n  }\n  sampling_period = accelerometers[tag].sampling_period;\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 52.81072729295213}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock_step();\n  accelerometer_get_struct(tag, &accelerometers);\n  if (accelerometers.tag != tag) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  } else {\n    sampling_period = accelerometers.sampling_period;\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 65.21130801407232}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.192479297986715}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString = dms;\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 42.98311638092734}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.192479297986715}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g);\n  dUASSERT (g->type == dBoxClass, \"argument not a box\");\n  dVector3 center;\n  dVector3 side;\n  dMatrix3 R;\n  dAASSERT (plane);\n  dAASSERT (dGeomIsSpace (g));\n  dAASSERT (dGeomGetBody (g) == 0);\n  dAASSERT (dGeomGetClass (g) == dBoxClass);\n  dAASSERT (dGeomGetPosition (g, center));\n  dAASSERT (dGeomGetRotation (g, R));\n  dAASSERT (dGeomGetLengths (g, side));\n  dAASSERT (dCalcVectorDot3_41 (center, R, x, y, z, center));\n  dAASSERT (dCalcVectorDot3_41 (side, R, x, y, z, side));\n  dAASSERT (dCalcVectorDot3_41 (center, R, x, y, z, center));\n  dAASSERT (dCalcVectorDot3_41 (side, R, x, y, z, side));\n  dAASSERT (dCalcVectorDot3_41 (center, R, x, y, z, center));\n  dAASSERT (dCalcVectorDot3_41 (side, R, x, y, z, side));\n  dAASSERT (dCalcVectorDot3_41 (center, R, x, y, z, center));\n  dAASSERT (dCalcVectorDot3_41 (side, R, x, y, z, side));\n  dAASSERT (dCalcVectorDot3_41 (center, R, x, y, z, center));\n  dAASSERT (dCalcVectorDot3_41 (side, R, x, y, z, side));\n  dAASSERT (dCalcVectorDot3_41 (center, R, x, y, z, center));\n  dAASSERT (dCalcVectorDot3_4", "CodeBleu_score": 21.848331489433836}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && dGeomGetClass(g)==dBoxClass,\"argument not a box\");\n    dVector3 center;\n    dGeomBoxGetLengths (g, center);\n    dVector3 relpos;\n    relpos[0] = x - center[0];\n    relpos[1] = y - center[1];\n    relpos[2] = z - center[2];\n    dVector3 abs_relpos;\n    abs_relpos[0] = dFabs (relpos[0]);\n    abs_relpos[1] = dFabs (relpos[1]);\n    abs_relpos[2] = dFabs (relpos[2]);\n    dReal dist = 0;\n    dVector3 normal;\n    if (abs_relpos[0] < center[0]) {\n        normal[0] = 1;\n        dist = relpos[0];\n    }\n    else if (abs_relpos[0] > center[0]) {\n        normal[0] = -1;\n        dist = -relpos[0];\n    }\n    if (abs_relpos[1] < center[1]) {\n        normal[1] = 1;\n        dist = dMax (dist, relpos[1]);\n    }\n    else if (abs_relpos[1] > center[1]) {\n        normal[1] = -1;\n        dist = dMax (dist, -relpos[1]);\n    }\n    if (abs_relpos[2] < center[2]) {\n        normal[2] = 1;\n        dist = dMax (dist, relpos[2]);\n    }\n    else if (abs_relpos[2] > center[2]) {\n        normal[2] = -1;\n        dist = dMax (dist, -relpos[2]);\n    }\n    if (dist > 0) {\n        normal[0] = -normal[0];\n        normal[1] = -normal[1];\n        normal[2] = -normal[2];\n    }\n    plane[0] = normal[0];\n    plane[1] = normal[1];", "CodeBleu_score": 30.03754010235959}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass,\"argument not a box\");\n  dVector3 c;\n  dGeomBoxGetLengths(g,c);\n  dVector3 p;\n  dSubtractVectors3(p,c,dGeomGetPosition(g));\n  dVector3 px,py,pz;\n  dMultiply1_331(px,g->R,p);\n  dMultiply1_331(py,g->R+3,p);\n  dMultiply1_331(pz,g->R+6,p);\n  dReal px2=px[0]*px[0],py2=py[0]*py[0],pz2=pz[0]*pz[0];\n  dReal px_py=px[0]*py[0],px_pz=px[0]*pz[0],py_pz=py[0]*pz[0];\n  dReal px_py_pz=px[0]*py[0]*pz[0],py_pz_px=py[0]*pz[0]*px[0],pz_px_py=pz[0]*px[0]*py[0];\n  dReal px_py_pz_2=px_py_pz*px_py_pz;\n  dReal py_pz_px_2=py_pz_px*py_pz_px;\n  dReal pz_px_py_2=pz_px_py*pz_px_py;\n  dReal px_py_pz_px_2=px_py_pz_2+px_py_pz*px[1];\n  dReal py_pz_px_py_2=py_pz_px_2+py_pz_px*py[1];\n  dReal pz_px_py_pz_2=pz_px_py_2+pz_px_py*pz[1];\n  dReal px_py_pz_px_py_2=px_py_", "CodeBleu_score": 32.09624807509655}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box != NULL, \"dImmerseBox: box is NULL\");\n  dUASSERT (immersion != NULL, \"dImmerseBox: immersion is NULL\");\n\n  dIASSERT (box->body != NULL);\n  dIASSERT (box->body->immersion_data == NULL);\n\n  dIASSERT (flags & (dImmersion_Immersed | dImmersion_ImmersedPartially));\n  dIASSERT (flags & (dImmersion_Immersed | dImmersion_ImmersedPartially));\n\n  dIASSERT (immersion->body != NULL);\n  dIASSERT (immersion->body->immersion_data == NULL);\n\n  dIASSERT (immersion->body == box->body);\n\n  sBoxImmersionData *data = (sBoxImmersionData *)\n    dAlloc (sizeof (sBoxImmersionData));\n\n  data->box = box;\n  data->fluidPlane = fluidPlane;\n  data->flags = flags;\n  data->immersion = immersion;\n\n  data->box->body->immersion_data = data;\n\n  int result = dPerformImmersionChecking (data);\n\n  if (result == 0) {\n    dFree (data, sizeof (sBoxImmersionData));\n    data = NULL;\n  }\n\n  return result;\n}", "CodeBleu_score": 40.783759299512276}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box, \"dImmerseBox: box is NULL\");\n  dUASSERT (fluidPlane, \"dImmerseBox: fluidPlane is NULL\");\n  dUASSERT (immersion, \"dImmerseBox: immersion is NULL\");\n  dUASSERT (immersion->data, \"dImmerseBox: immersion->data is NULL\");\n  dUASSERT (immersion->data->boxImmersionData, \"dImmerseBox: boxImmersionData is NULL\");\n\n  sBoxImmersionData *data = (sBoxImmersionData*) immersion->data->boxImmersionData;\n\n  dIASSERT (dCheckBox (box));\n  dIASSERT (dCheckVector (fluidPlane, 4));\n  dIASSERT (flags == 0 || flags == 1);\n\n  data->box = box;\n  data->fluidPlane = fluidPlane;\n  data->flags = flags;\n\n  return dPerformBoxImmersionChecking (data);\n}", "CodeBleu_score": 43.15659129322477}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdIASSERT (box && immersion);\n  dUASSERT (box->body, \"dImmerseBox: box has no body\");\n  dUASSERT (box->body->world, \"dImmerseBox: box's body has no world\");\n  dUASSERT (box->body->world->immersion_library,\n      \"dImmerseBox: world has no immersion library\");\n  dUASSERT (box->body->world->immersion_library->check_box_immersion,\n      \"dImmerseBox: world's immersion library has no box immersion checking function\");\n  dUASSERT (box->body->world->immersion_library->clean_box_immersion,\n      \"dImmerseBox: world's immersion library has no box immersion cleaning function\");\n  dUASSERT (box->body->world->immersion_library->compute_box_fluid_pressure,\n      \"dImmerseBox: world's immersion library has no box fluid pressure computation function\");\n  dUASSERT (box->body->world->immersion_library->compute_box_fluid_viscosity,\n      \"dImmerseBox: world's immersion library has no box fluid viscosity computation function\");\n  dUASSERT (box->body->world->immersion_library->compute_box_fluid_force,\n      \"dImmerseBox: world's immersion library has no box fluid force computation function\");\n  dUASSERT (box->body->world->immersion_library->compute_box_fluid_torque,\n      \"dImmerseBox: world's immersion library has no box fluid torque computation function\");\n  dUASSERT (box->body->world->immersion_library->compute_box_fluid_surface_area,\n      \"dImmerseBox: world's immersion library has no box fluid surface area computation function\");\n  dUASSERT (box->body->world->immersion_library->compute_box_fluid_volume,\n      \"dImmerseBox: world's immersion library has no box fluid volume computation function\");\n  dUASSERT (box", "CodeBleu_score": 40.321926677752884}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT (o1->type == dBoxClass);\n  dIASSERT (o2->type == dCapsuleClass);\n\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dIASSERT (box->body);\n  dIASSERT (capsule->body);\n\n  dUASSERT(box->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(capsule->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(box, capsule, immersion, flags);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 46.63661815830653}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dxBox *box = (dxBox*)o1;\n  dxCapsule *capsule = (dxCapsule*)o2;\n\n  dUASSERT(box->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(capsule->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sBoxImmersionData data(box, capsule, immersion, flags);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 36.87454673475151}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\n  sBoxImmersionData data(o1, o2, immersion, flags);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 19.944096289721866}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\treturn (\n\t\t// first part\n\t\tsHemisphereIntegrationData(zIOverR, tanTheta0, 0.0, sinTheta1, 1.0).volumeIntegrand() * 0.5 * (1.0 + sinTheta1)\n\t\t// second part\n\t\t+ sHemisphereIntegrationData(zIOverR, tanTheta0, 0.0, 0.0, 1.0).volumeIntegrand() * 0.5 * sinTheta1\n\t);\n}", "CodeBleu_score": 22.021875294462486}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tdReal volume = 0;\n\n\tif (zIOverR < 0) {\n\n\t\t// Volume of the first part of the hemisphere, from 0 to theta0\n\t\tvolume += sHemisphereIntegrationData::integrate(0, tanTheta0, zIOverR, sinTheta1);\n\n\t\t// Volume of the second part of the hemisphere, from theta0 to pi/2\n\t\tvolume += sHemisphereIntegrationData::integrate(tanTheta0, 1, zIOverR, sinTheta1);\n\t}\n\telse {\n\n\t\t// Volume of the first part of the hemisphere, from 0 to theta0\n\t\tvolume += sHemisphereIntegrationData::integrate(0, tanTheta0, zIOverR, sinTheta1);\n\n\t\t// Volume of the second part of the hemisphere, from theta0 to pi/2\n\t\tvolume += sHemisphereIntegrationData::integrate(tanTheta0, 1, zIOverR, sinTheta1);\n\t}\n\n\treturn volume;\n}", "CodeBleu_score": 34.22520292794346}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t// The hemisphere is defined by z = R - zIOverR\n\t// The volume of the hemisphere is 1/3 * pi * R^3\n\t// The volume of the portion of the hemisphere below the capsule is 1/3 * pi * R^3 * (1 - zIOverR/R)\n\t// The volume of the portion of the hemisphere above the capsule is 1/3 * pi * R^3 * (zIOverR/R)\n\t// The volume of the portion of the hemisphere above the capsule is 1/3 * pi * R^3 * (zIOverR/R)\n\t// The volume of the portion of the hemisphere below the capsule is 1/3 * pi * R^3 * (1 - zIOverR/R)\n\t// The volume of the hemisphere is 1/3 * pi * R^3\n\t// The volume of the portion of the hemisphere below the capsule is 1/3 * pi * R^3 * (1 - zIOverR/R)\n\t// The volume of the portion of the hemisphere above the capsule is 1/3 * pi * R^3 * (zIOverR/R)\n\t// The volume of the hemisphere is 1/3 * pi * R^3\n\t// The volume of the portion of the hemisphere below the capsule is 1/3 * pi * R^3 * (1 - zIOverR/R)\n\t// The volume of the portion of the hemisphere above the capsule is 1/3 * pi * R^3 * (zIOverR/R)\n\t// The volume of the hemisphere is 1/3 * pi * R^3\n\t// The volume of the portion of the hemisphere below the capsule is 1/3 * pi * R^3 * (1 - zIOverR/R)\n\t// The volume of the portion of the hemisphere above the capsule is 1/3 * pi * R^3 * (zIOverR/R)\n\t// The volume of the hemisphere is 1/3 * pi * R^3\n\t// The volume of the portion of the", "CodeBleu_score": 7.098807256604882}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tdReal xCenterOfMassIntegrand = 0;\n\tdReal zIntegrand = 0;\n\tdReal zIntegrandPrev = 0;\n\tdReal zIntegrandNext = 0;\n\tdReal zIntegrandNextPrev = 0;\n\tdReal zIntegrandNextNext = 0;\n\tdReal zIntegrandNextNextPrev = 0;\n\tdReal zIntegrandNextNextNext = 0;\n\tdReal zIntegrandNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNextNextNextNextPrev = 0;\n\tdReal zIntegrandNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n\tdReal zIntegr", "CodeBleu_score": 10.367632970456114}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t//Calculate the number of intervals to use in the integration\n\tint numIntervals = (int) (1.0 / (2.0 * zIOverR) + 0.5);\n\tnumIntervals = (numIntervals < 1) ? 1 : numIntervals;\n\tdReal dx = 2.0 * zIOverR / numIntervals;\n\tdReal xSum = 0.0;\n\tdReal xIntegrand = 0.0;\n\tdReal xCenterOfMassIntegrand = 0.0;\n\t//Calculate the x-coordinate of the center of mass of the hemisphere\n\tdReal xCenterOfMass = (radius * radius) / (4.0 * volume);\n\t//Calculate the x-coordinate of the buoyancy center of the hemisphere\n\tfor (int i = 0; i < numIntervals; ++i) {\n\t\txIntegrand = (zIOverR - i * dx) * tanTheta0;\n\t\txCenterOfMassIntegrand = (zIOverR - i * dx) * xCenterOfMass;\n\t\txSum += (xIntegrand + xCenterOfMassIntegrand);\n\t}\n\txSum *= dx;\n\treturn xSum;\n}", "CodeBleu_score": 40.72435675496578}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t// Integrand\n\tsHemisphereIntegrationData hemisphereIntegrationData;\n\themisphereIntegrationData.xCenterOfMassIntegrand = [&](dReal theta) {\n\t\treturn hemisphereXCenterOfMassIntegrand(zIOverR, tanTheta0, sinTheta1, theta);\n\t};\n\n\t// Integration\n\tdReal xBuoyancyCenter = 0;\n\tif (zIOverR > 0) {\n\t\t// Integration limits\n\t\tdReal theta0 = 0;\n\t\tdReal theta1 = M_PI_2;\n\t\tdReal theta2 = M_PI;\n\n\t\t// Integration\n\t\txBuoyancyCenter = simpson(hemisphereIntegrationData, theta0, theta1, theta2);\n\t}\n\n\t// Scale and adjust\n\txBuoyancyCenter *= 2 * zIOverR * volume;\n\n\treturn xBuoyancyCenter;\n}", "CodeBleu_score": 44.33101885605718}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dUASSERT(o1->body, \"The first object has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->type == dTriMeshClass, \"The second object is not a trimesh and hence cannot be tested for immersion into a fluid\");\n\n  dxTriMesh *triMesh = (dxTriMesh *) o2;\n  dxBody *body = o1->body;\n\n  dVector3 fluidPlane;\n  dPlaneSpace(body->avel, fluidPlane);\n\n  sCapsuleImmersionData data(o1, o2, fluidPlane, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 46.11718842483402}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 25.19228016192519}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 25.19228016192519}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t// TODO: Implement the function\n  // Sets the node status to RUNNING\n  setStatus(RUNNING);\n\n  // Retrieves the sleep duration in milliseconds from the input\n  double duration;\n  if (!retrieveInput(INPUT_DURATION, duration)) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // If the duration is missing or non-positive, it returns SUCCESS\n  if (duration <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Starts a timer\n  timer_.add(std::chrono::milliseconds(static_cast<int>(duration)),\n             [this]() { emitWakeUpSignal(); });\n\n  // Sets a callback to emit a wake-up signal when the timer expires\n  timer_.setCallback([this]() { emitWakeUpSignal(); });\n\n  // Returns RUNNING\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 42.72246966144784}, {"code": "NodeStatus SleepNode::onStart(){\n\t// TODO: Implement the onStart function\n  // TODO: Retrieve the sleep duration in milliseconds from the input\n  // TODO: If the duration is missing or non-positive, it returns SUCCESS\n  // TODO: Otherwise, it sets the node status to RUNNING, starts a timer, and sets a callback to emit a wake-up signal when the timer expires\n  // TODO: If the timer is aborted, it ensures the timer_waiting_ flag is reset\n  std::chrono::milliseconds sleep_duration;\n  if (!getInput<std::chrono::milliseconds>(\"duration\", sleep_duration)) {\n    return NodeStatus::SUCCESS;\n  }\n  if (sleep_duration <= std::chrono::milliseconds::zero()) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_.add(sleep_duration, [this] { emitWakeUpSignal(); });\n  timer_.start();\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 47.36207023455161}, {"code": "NodeStatus SleepNode::onStart(){\n\tif (input_.hasMissingParents()) {\n        return NodeStatus::SUCCESS;\n    }\n    duration_ = std::chrono::milliseconds(static_cast<int>(input_.getValue<double>() * 1000));\n    if (duration_ <= std::chrono::milliseconds::zero()) {\n        return NodeStatus::SUCCESS;\n    }\n    timer_.add(duration_, [this]() {\n        if (timer_.isAborted()) {\n            timer_waiting_ = false;\n        } else {\n            emitWakeUpSignal();\n        }\n    });\n    setStatus(NodeStatus::RUNNING);\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 44.99224473211578}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\tstd::string entry_name = config().blackboard->get<std::string>(\"entry_name\");\n\tauto entry = config().blackboard->getEntry(entry_name);\n\tif (entry == nullptr) {\n\t\tthrow std::runtime_error(\"EntryUpdatedAction: Entry \" + entry_name + \" not found.\");\n\t}\n\tstd::lock_guard<std::mutex> lock(entry->mutex);\n\tif (entry->sequence_id == entry->last_sequence_id) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tentry->last_sequence_id = entry->sequence_id;\n\treturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 40.635830648629145}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// TODO: Implement your code here\n    if (getInput<std::string>(\"entry_name\")->empty()) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::string entry_name = getInput<std::string>(\"entry_name\")->getValue();\n    if (entry_name.empty()) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::string entry_value = getInput<std::string>(\"entry_value\")->getValue();\n    if (entry_value.empty()) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::string entry_value_type = getInput<std::string>(\"entry_value_type\")->getValue();\n    if (entry_value_type.empty()) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::string entry_value_type_id = getInput<std::string>(\"entry_value_type_id\")->getValue();\n    if (entry_value_type_id.empty()) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::string entry_value_type_id_str = getInput<std::string>(\"entry_value_type_id_str\")->getValue();\n    if (entry_value_type_id_str.empty()) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::string entry_value_type_str = getInput<std::string>(\"entry_value_type_str\")->getValue();\n    if (entry_value_type_str.empty()) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::string entry_value_type_str_id = getInput<std::string>(\"entry_value_type_str_id\")->getValue();\n    if (entry_value_type_str_id.empty()) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::string entry_value_type_str_id_str = getInput<std::string>(\"entry_value_type_str_id_str\")->getValue();\n    if (entry_value_type_str_id_str.empty()) {", "CodeBleu_score": 38.19595879578781}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// TODO: Implement this function\n  // TODO: Uncomment the following lines\n  // TODO: Get the entry from the blackboard\n  // TODO: Lock the mutex of the entry\n  // TODO: Check if the entry is found\n  // TODO: Check if the sequence ID is different\n  // TODO: Update the sequence ID\n  // TODO: Unlock the mutex of the entry\n  // TODO: Return NodeStatus::SUCCESS if the sequence ID is different\n  // TODO: Return NodeStatus::FAILURE otherwise\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 6.587517749686045}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\n    return std::max<size_t>(0, static_cast<size_t>(-successThreshold_ * children_nodes_.size()));\n  }\n  return successThreshold_;\n}", "CodeBleu_score": 53.8882232151915}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\n        return -successThreshold_ * children_nodes_.size();\n    } else {\n        return successThreshold_;\n    }\n}", "CodeBleu_score": 56.0475020669291}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\n\t\treturn static_cast<size_t>(-successThreshold_) * children_nodes_.size();\n\t} else {\n\t\treturn static_cast<size_t>(successThreshold_);\n\t}\n}", "CodeBleu_score": 56.46963369678502}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t// TODO: make this a thread\n  while(true)\n  {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    if(_p->heartbeat_enabled)\n    {\n      std::chrono::time_point<std::chrono::system_clock> current_time = std::chrono::system_clock::now();\n      if(current_time - _p->heartbeat_last_time > std::chrono::milliseconds(1000))\n      {\n        _p->heartbeat_enabled = false;\n        RCLCPP_INFO(_p->node->get_logger(), \"Heartbeat lost. Disabling all breakpoints.\");\n        enableAllHooks(false);\n      }\n    }\n  }\n}", "CodeBleu_score": 40.036749667338114}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\tstd::chrono::milliseconds sleep_time(10);\n  while(true) {\n    std::this_thread::sleep_for(sleep_time);\n    std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n    auto now = std::chrono::system_clock::now();\n    for(auto& [node_uid, hook] : _p->pre_hooks) {\n      if(hook->mode == Monitor::Hook::Mode::HEARTBEAT) {\n        if(hook->enabled) {\n          if(now - hook->last_heartbeat > hook->heartbeat_timeout) {\n            hook->enabled = false;\n            hook->last_heartbeat = now;\n            hook->wakeup.notify_all();\n          }\n        } else {\n          if(now - hook->last_heartbeat < hook->heartbeat_timeout) {\n            hook->enabled = true;\n            hook->last_heartbeat = now;\n            hook->wakeup.notify_all();\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 42.55138104654324}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile (_p->running) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    //std::cout << \"heartbeatLoop\" << std::endl;\n    //std::cout << \"heartbeatLoop: \" << std::chrono::system_clock::now() << std::endl;\n    std::chrono::time_point<std::chrono::system_clock> now = std::chrono::system_clock::now();\n    std::chrono::time_point<std::chrono::system_clock> last_heartbeat = _p->last_heartbeat;\n    std::chrono::milliseconds time_since_last_heartbeat = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_heartbeat);\n    //std::cout << \"time_since_last_heartbeat: \" << time_since_last_heartbeat.count() << std::endl;\n    if (time_since_last_heartbeat.count() > 5000) {\n      //std::cout << \"heartbeatLoop: \" << std::chrono::system_clock::now() << std::endl;\n      std::cout << \"Groot2Publisher::heartbeatLoop: no heartbeat received in 5 seconds, disabling all breakpoints\" << std::endl;\n      enableAllHooks(false);\n    }\n  }\n}", "CodeBleu_score": 44.75125152937752}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tnlohmann::json j;\n\tstd::vector<uint8_t> ret;\n\tstd::vector<std::string> bb_names;\n\tstd::stringstream ss(bb_list);\n\tstd::string s;\n\twhile (std::getline(ss, s, ',')) {\n\t\tbb_names.push_back(s);\n\t}\n\tfor (auto& bb_name : bb_names) {\n\t\tstd::string subtree_name = \"blackboard.\" + bb_name;\n\t\tauto subtree = _p->subtrees.find(subtree_name);\n\t\tif (subtree != _p->subtrees.end()) {\n\t\t\tstd::lock_guard<std::mutex> lock(subtree->second.lock);\n\t\t\tnlohmann::json j_bb = ExportBlackboardToJSON(subtree->second.blackboard);\n\t\t\tj[bb_name] = j_bb;\n\t\t}\n\t}\n\tret = nlohmann::json::to_msgpack(j);\n\treturn ret;\n}", "CodeBleu_score": 51.850477563364606}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t// Parse the input string to get a list of blackboards\n\tstd::vector<std::string> blackboard_names;\n\tstd::stringstream ss(bb_list);\n\tstd::string bb_name;\n\twhile (std::getline(ss, bb_name, ',')) {\n\t\tblackboard_names.push_back(bb_name);\n\t}\n\n\t// Iterate through the list of blackboards and export them to JSON\n\tnlohmann::json blackboards_json;\n\tfor (const std::string& bb_name : blackboard_names) {\n\t\t// Find the subtree\n\t\tauto subtree_it = _p->subtrees.find(bb_name);\n\t\tif (subtree_it == _p->subtrees.end()) {\n\t\t\tthrow std::runtime_error(\"Blackboard \" + bb_name + \" not found\");\n\t\t}\n\t\tauto& subtree = subtree_it->second;\n\n\t\t// Lock the subtree\n\t\tif (!subtree.lock()) {\n\t\t\tthrow std::runtime_error(\"Blackboard \" + bb_name + \" not locked\");\n\t\t}\n\n\t\t// Export the blackboard to JSON\n\t\tnlohmann::json blackboard_json;\n\t\tExportBlackboardToJSON(subtree, blackboard_json);\n\n\t\t// Add the blackboard to the JSON object\n\t\tblackboards_json[bb_name] = blackboard_json;\n\n\t\t// Unlock the subtree\n\t\tsubtree.unlock();\n\t}\n\n\t// Convert the JSON object to MessagePack\n\tstd::vector<uint8_t> blackboards_msgpack;\n\tblackboards_json.to_msgpack(blackboards_msgpack);\n\n\t// Return the MessagePack vector\n\treturn blackboards_msgpack;\n}", "CodeBleu_score": 45.54783822385948}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> ret;\n  std::vector<std::string> bb_names;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n\n  while (std::getline(ss, bb_name, ',')) {\n    bb_names.push_back(bb_name);\n  }\n\n  nlohmann::json j;\n  for (auto& bb_name : bb_names) {\n    auto subtree = _p->subtrees.find(bb_name);\n    if (subtree != _p->subtrees.end()) {\n      auto bb = subtree->second.lock();\n      if (bb) {\n        j[bb_name] = bb->toJSON();\n      }\n    }\n  }\n\n  ret = nlohmann::json::to_msgpack(j);\n\n  return ret;\n}", "CodeBleu_score": 56.26233303571302}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->status != NodeStatus::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->notify_all();\n  return true;\n}", "CodeBleu_score": 45.11827570545961}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::lock_guard<std::mutex> lk(hook->mutex);\n  if(hook->status != HookStatus::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = HookStatus::READY;\n  hook->result = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 48.13868396957546}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::lock_guard<std::mutex> lk(hook->mutex);\n  if(hook->status != NodeStatus::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 46.88451100379741}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n    halt_requested_.store(false);\n    std::async(std::launch::async, [this]() {\n      try\n      {\n        NodeStatus status = tick_functor_(*this);\n        if(status != prev_status)\n        {\n          setStatus(status);\n        }\n      }\n      catch(const std::exception& e)\n      {\n        setStatus(NodeStatus::IDLE);\n        BT::logging::error(\"Exception in ThreadedAction::executeTick: {}\", e.what());\n        halt_requested_.store(true);\n      }\n    });\n  }\n  if(halt_requested_.load())\n  {\n    setStatus(NodeStatus::IDLE);\n    halt_requested_.store(false);\n    return NodeStatus::IDLE;\n  }\n  else\n  {\n    rethrowException();\n    return status();\n  }\n}", "CodeBleu_score": 54.27639687118414}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  try\n  {\n    NodeStatus status = tick_functor_(*this);\n    if(status != prev_status)\n    {\n      setStatus(status);\n    }\n  }\n  catch(std::exception& e)\n  {\n    setStatus(NodeStatus::IDLE);\n    RCLCPP_ERROR(get_logger(), \"Exception thrown in tick() of %s: %s\", name(), e.what());\n  }\n\n  if(halt_requested())\n  {\n    setStatus(NodeStatus::IDLE);\n    RCLCPP_ERROR(get_logger(), \"Halt requested in tick() of %s\", name());\n  }\n\n  if(std::exception_ptr e = std::current_exception())\n  {\n    std::rethrow_exception(e);\n  }\n\n  return status();\n}", "CodeBleu_score": 50.64810304336459}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n  if(prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n    halt_requested_.store(false);\n    std::async(std::launch::async, [this]() {\n      try {\n        tick_functor_(*this);\n      } catch(const std::exception& e) {\n        BT::logError(\"exception thrown in tick: %s\", e.what());\n        setStatus(NodeStatus::IDLE);\n        halt_requested_.store(true);\n      } catch(...) {\n        BT::logError(\"unknown exception thrown in tick\");\n        setStatus(NodeStatus::IDLE);\n        halt_requested_.store(true);\n      }\n    });\n  }\n\n  if(!halt_requested_.load()) {\n    setStatus(NodeStatus::RUNNING);\n    return NodeStatus::RUNNING;\n  }\n\n  if(status() == NodeStatus::RUNNING) {\n    setStatus(NodeStatus::IDLE);\n  }\n\n  if(exception_ptr_) {\n    std::rethrow_exception(exception_ptr_);\n  }\n\n  return status();\n}", "CodeBleu_score": 52.33798753885341}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// Function to print the tree recursively\n    auto print_tree = [&](const TreeNode* node, int depth) {\n        // Print the node's name\n        stream << std::string(depth, ' ') << node->name << std::endl;\n\n        // Print the children for ControlNode or the child for DecoratorNode\n        if (auto control = dynamic_cast<const ControlNode*>(node)) {\n            for (auto child : control->children) {\n                print_tree(child, depth + 1);\n            }\n        } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n            print_tree(decorator->child, depth + 1);\n        }\n    };\n\n    // Print the separator line\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n\n    // Print the tree recursively\n    print_tree(root_node, 0);\n\n    // Print the separator line\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 43.855343973729596}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tstd::function<void(const TreeNode*, int)> print_tree_recursively;\n    print_tree_recursively = [&print_tree_recursively, &stream](const TreeNode* node, int depth) {\n        std::string indent(depth, '\\t');\n        stream << indent << node->name << std::endl;\n        if (const BT::ControlNode* control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const TreeNode* child : control->children) {\n                print_tree_recursively(child, depth + 1);\n            }\n        } else if (const BT::DecoratorNode* decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            print_tree_recursively(decorator->child, depth + 1);\n        }\n    };\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    print_tree_recursively(root_node, 0);\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 52.73524034018317}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// The lambda function to handle printing\n    auto print_node = [&](const TreeNode* node, int depth) {\n        // Print the node's name\n        stream << std::string(depth, ' ') << node->name << std::endl;\n        // If the node is a ControlNode, print its children\n        if (const auto* control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto* child : control->children) {\n                print_node(child, depth + 1);\n            }\n        }\n        // If the node is a DecoratorNode, print its child\n        else if (const auto* decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            print_node(decorator->child, depth + 1);\n        }\n    };\n\n    // Print the root node\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    print_node(root_node, 0);\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 48.18376127381788}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.find(manifest.registrationID) != _p->builders.end()) {\n        throw BehaviorTreeException(\n            \"The registration ID is already registered\");\n    }\n    _p->builders.insert(std::make_pair(manifest.registrationID, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 56.32111886346527}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.find(manifest.registrationId) != _p->builders.end()) {\n    throw BehaviorTreeException(\"Registration ID already exists.\");\n  }\n\n  _p->builders.insert(std::make_pair(manifest.registrationId, builder));\n  _p->manifests.insert(std::make_pair(manifest.registrationId, manifest));\n}", "CodeBleu_score": 54.619657401981414}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t// TODO: Check if the manifest is valid\n  std::string id = manifest.getRegistrationID();\n  if (builders.find(id) != builders.end()) {\n    throw BehaviorTreeException(\"NodeBuilder with ID \" + id + \" already exists\");\n  }\n\n  builders.insert(std::make_pair(id, builder));\n  manifests.insert(std::make_pair(id, manifest));\n}", "CodeBleu_score": 42.707810714199404}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tauto builder = [tick_functor, ports](const std::string& ID,\n                                        const NodeParameters& parameters) {\n    return std::make_unique<SimpleActionNode>(ID, tick_functor, ports);\n  };\n\n  registerBuilder(TreeNodeManifest(ID, SimpleActionNode::type_name_static(),\n                                   std::move(ports)),\n                  builder);\n}", "CodeBleu_score": 53.042552387441376}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tauto builder = [tick_functor](const TreeNode::Parameters& parameters) {\n    return std::make_unique<SimpleActionNode>(\n        tick_functor, parameters.name, parameters.registration_ID,\n        std::move(ports));\n  };\n  registerBuilder(TreeNodeManifest(ID, TreeNodeManifest::NodeType::ACTION),\n                  builder);\n}", "CodeBleu_score": 51.8686253277936}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const std::string& ID,\n                                       const std::string& type,\n                                       const PortsList& ports) {\n    return std::make_unique<SimpleActionNode>(ID, tick_functor, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.registration_ID = ID;\n  manifest.type = \"SimpleAction\";\n  manifest.ports = ports;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 58.68862328851667}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        auto b = Blackboard::create();\n        sub->blackboard->cloneInto(b);\n        bb.push_back(b);\n    }\n    return bb;\n}", "CodeBleu_score": 73.95920794871846}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (auto& sub : tree.subtrees) {\n        Blackboard::Ptr new_bb = Blackboard::create();\n        sub->blackboard->cloneInto(new_bb);\n        bb.push_back(new_bb);\n    }\n    return bb;\n}", "CodeBleu_score": 70.16088922901965}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        Blackboard::Ptr new_bb = Blackboard::create();\n        sub->blackboard->cloneInto(new_bb);\n        bb.push_back(new_bb);\n    }\n    return bb;\n}", "CodeBleu_score": 72.21512946110383}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor)\n  {\n    return executor(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 85.81878852551466}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor) {\n    return executor(env);\n  }\n  else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 85.09823809006738}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor) {\n    return executor.value()(env);\n  }\n  else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 95.4619496849724}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n    if (is_loaded) {\n        throw RuntimeError(\"SharedLibrary already loaded\");\n    }\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    this->path = path;\n    is_loaded = true;\n}", "CodeBleu_score": 52.78541894900414}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n  if (loaded) {\n    throw RuntimeError(\"Shared library already loaded\");\n  }\n  void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (handle == nullptr) {\n    throw RuntimeError(dlerror());\n  }\n  this->path = path;\n  loaded = true;\n}", "CodeBleu_score": 51.4268707238705}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::unique_lock<std::mutex> lock(mutex);\n    if (loaded)\n        throw RuntimeError(\"SharedLibrary::load\", \"Attempt to load a library that is already loaded\");\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle)\n        throw RuntimeError(\"SharedLibrary::load\", dlerror());\n    this->path = path;\n    loaded = true;\n}", "CodeBleu_score": 54.316972791464124}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 25.885146661559844}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t// If the string is less than 3 characters long, return false.\n    if (str.size() < 3) {\n        return false;\n    }\n\n    // Strip leading and trailing spaces.\n    StringView stripped = str.strip();\n\n    // If the stripped string starts with '{' and ends with '}', return true.\n    if (stripped.starts_with('{') && stripped.ends_with('}')) {\n        if (stripped_pointer != nullptr) {\n            *stripped_pointer = stripped;\n        }\n        return true;\n    }\n\n    // If the stripped string is not at least 3 characters long, return false.\n    if (stripped.size() < 3) {\n        return false;\n    }\n\n    // If the stripped string starts with '{' and ends with '}', return true.\n    if (stripped.starts_with('{') && stripped.ends_with('}')) {\n        if (stripped_pointer != nullptr) {\n            *stripped_pointer = stripped;\n        }\n        return true;\n    }\n\n    // If the stripped string is not at least 3 characters long, return false.\n    if (stripped.size() < 3) {\n        return false;\n    }\n\n    // If the stripped string starts with '{' and ends with '}', return true.\n    if (stripped.starts_with('{') && stripped.ends_with('}')) {\n        if (stripped_pointer != nullptr) {\n            *stripped_pointer = stripped;\n        }\n        return true;\n    }\n\n    // If the stripped string is not at least 3 characters long, return false.\n    if (stripped.size() < 3) {\n        return false;\n    }\n\n    // If the stripped string starts with '{' and ends with '}', return true.\n    if (stripped.starts_with('{') && stripped.ends_with('}')) {\n        if (stripped_pointer != nullptr) {\n            *stripped_pointer", "CodeBleu_score": 26.477280417953374}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t// Check if the string is at least 3 characters long\n\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\t// Strip leading and trailing spaces\n\tStringView stripped_str = str.strip();\n\n\t// Check if the stripped string starts with '{' and ends with '}'\n\tif (!(stripped_str.startsWith('{') && stripped_str.endsWith('}'))) {\n\t\treturn false;\n\t}\n\n\t// If a stripped_pointer is provided, assign the inner content to it\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped_str.slice(1, stripped_str.size() - 1);\n\t}\n\n\t// Return whether the string is a valid blackboard pointer\n\treturn true;\n}", "CodeBleu_score": 22.66294203847678}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//check if the line is valid\n    if(!isValid(x0, y0, x1, y1))\n      return -1;\n\n    //initialize the line cost\n    double line_cost = 0;\n\n    //iterate through each point on the line\n    for(LineIterator iterator(x0, y0, x1, y1); iterator.isValid(); iterator.advance()) {\n      //calculate the point cost\n      double point_cost = pointCost(iterator.getX(), iterator.getY());\n\n      //if the point cost is negative, return immediately\n      if(point_cost < 0)\n        return point_cost;\n\n      //update the line cost if the point cost is higher\n      if(point_cost > line_cost)\n        line_cost = point_cost;\n    }\n\n    //return the total line cost\n    return line_cost;\n  }", "CodeBleu_score": 57.97156522395639}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble line_cost = 0;\n    //calculate the line cost\n    LineIterator line(x0, y0, x1, y1);\n    line.advance();\n    while (line.isValid()) {\n      double point_cost = pointCost(line.getX(), line.getY());\n      if (point_cost < 0)\n        return point_cost;\n      line_cost += point_cost;\n      line.advance();\n    }\n    return line_cost;\n  }", "CodeBleu_score": 66.10476565651548}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble line_cost = 0;\n    LineIterator line(costmap_, x0, y0, x1, y1);\n    line.advance();\n    while(line.isValid()) {\n      double point_cost = pointCost(line.getX(), line.getY());\n      if(point_cost < 0)\n        return point_cost;\n      line_cost += point_cost;\n      line.advance();\n    }\n    return line_cost;\n  }", "CodeBleu_score": 66.15994473191442}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty())\n        return;\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.poses.resize(path.size());\n    for (size_t i = 0; i < path.size(); ++i) {\n        gui_path.poses[i] = path[i].pose;\n    }\n    pub.publish(gui_path);\n}", "CodeBleu_score": 76.51132266389537}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n        return;\n    }\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.poses.resize(path.size());\n    for (size_t i = 0; i < path.size(); ++i) {\n        gui_path.poses[i] = path[i];\n    }\n    pub.publish(gui_path);\n}", "CodeBleu_score": 79.74696494249362}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty())\n    return;\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n  for (size_t i = 0; i < path.size(); ++i)\n    gui_path.poses[i] = path[i].pose;\n  pub.publish(gui_path);\n}", "CodeBleu_score": 77.3641730564368}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tdouble rot_vel = base_odom.twist.twist.angular.z;\n  double trans_vel = base_odom.twist.twist.linear.x;\n\n  if (fabs(rot_vel) <= rot_stopped_velocity && fabs(trans_vel) <= trans_stopped_velocity) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}", "CodeBleu_score": 51.75814251789159}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t// Check if the robot has stopped\n  bool stopped = false;\n  if (base_odom.twist.twist.angular.z <= rot_stopped_velocity &&\n      base_odom.twist.twist.linear.x <= trans_stopped_velocity) {\n    stopped = true;\n  }\n  return stopped;\n}", "CodeBleu_score": 54.94519417173015}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tdouble rot_velocity = base_odom.twist.twist.angular.z;\n  double trans_velocity = base_odom.twist.twist.linear.x;\n  ROS_INFO(\"rot_velocity: %f, trans_velocity: %f\", rot_velocity, trans_velocity);\n  if (fabs(rot_velocity) <= rot_stopped_velocity && fabs(trans_velocity) <= trans_stopped_velocity) {\n    ROS_INFO(\"Stopped\");\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 49.433386867045556}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup) {\n\t\tif (restore_defaults) {\n\t\t\tconfig.max_vel_lin = DEFAULT_MAX_VEL_LIN;\n\t\t\tconfig.max_vel_ang = DEFAULT_MAX_VEL_ANG;\n\t\t\tconfig.max_vel_lin_x = DEFAULT_MAX_VEL_LIN_X;\n\t\t\tconfig.max_vel_lin_y = DEFAULT_MAX_VEL_LIN_Y;\n\t\t\tconfig.max_vel_lin_z = DEFAULT_MAX_VEL_LIN_Z;\n\t\t\tconfig.max_vel_ang_x = DEFAULT_MAX_VEL_ANG_X;\n\t\t\tconfig.max_vel_ang_y = DEFAULT_MAX_VEL_ANG_Y;\n\t\t\tconfig.max_vel_ang_z = DEFAULT_MAX_VEL_ANG_Z;\n\t\t\tconfig.max_acc_lin = DEFAULT_MAX_ACC_LIN;\n\t\t\tconfig.max_acc_ang = DEFAULT_MAX_ACC_ANG;\n\t\t\tconfig.max_acc_lin_x = DEFAULT_MAX_ACC_LIN_X;\n\t\t\tconfig.max_acc_lin_y = DEFAULT_MAX_ACC_LIN_Y;\n\t\t\tconfig.max_acc_lin_z = DEFAULT_MAX_ACC_LIN_Z;\n\t\t\tconfig.max_acc_ang_x = DEFAULT_MAX_ACC_ANG_X;\n\t\t\tconfig.max_acc_ang_y = DEFAULT_MAX_ACC_ANG_Y;\n\t\t\tconfig.max_acc_ang_z = DEFAULT_MAX_ACC_ANG_Z;\n\t\t\tconfig.max_jerk_lin = DEFAULT_MAX_JERK_LIN;\n\t\t\tconfig.max_jerk_ang = DEFAULT_MAX_JERK_ANG;\n\t\t\tconfig.max_jerk_lin_x = DEFAULT_MAX_JERK_LIN_X;\n\t\t\tconfig.max_jerk_lin_y = DEFAULT_MAX_JERK_LIN_Y;\n\t\t\tconfig.max_jerk", "CodeBleu_score": 20.20373612119385}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (!setup) {\n\t\t// Initialize the default limits with the provided configuration\n\t\tdefault_limits.min_turning_radius = config.min_turning_radius;\n\t\tdefault_limits.max_turning_radius = config.max_turning_radius;\n\t\tdefault_limits.min_linear_velocity = config.min_linear_velocity;\n\t\tdefault_limits.max_linear_velocity = config.max_linear_velocity;\n\t\tdefault_limits.min_linear_acceleration = config.min_linear_acceleration;\n\t\tdefault_limits.max_linear_acceleration = config.max_linear_acceleration;\n\t\tdefault_limits.min_angular_velocity = config.min_angular_velocity;\n\t\tdefault_limits.max_angular_velocity = config.max_angular_velocity;\n\t\tdefault_limits.min_angular_acceleration = config.min_angular_acceleration;\n\t\tdefault_limits.max_angular_acceleration = config.max_angular_acceleration;\n\t\tdefault_limits.min_angular_jerk = config.min_angular_jerk;\n\t\tdefault_limits.max_angular_jerk = config.max_angular_jerk;\n\t\tdefault_limits.min_linear_jerk = config.min_linear_jerk;\n\t\tdefault_limits.max_linear_jerk = config.max_linear_jerk;\n\t\tdefault_limits.min_orientation_error = config.min_orientation_error;\n\t\tdefault_limits.max_orientation_error = config.max_orientation_error;\n\t\tdefault_limits.min_linear_error = config.min_linear_error;\n\t\tdefault_limits.max_linear_error = config.max_linear_error;\n\t\tdefault_limits.min_angular_error = config.min_angular_error;\n\t\tdefault_limits.max_angular_error = config.max_angular_error;\n\t\tdefault_limits.min_time_to_collision = config.min_time_to_collision;", "CodeBleu_score": 21.839350276854656}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup) {\n        if (restore_defaults) {\n            config.setup.limits.max_velocity_x = 0.5;\n            config.setup.limits.max_velocity_y = 0.5;\n            config.setup.limits.max_velocity_z = 0.5;\n            config.setup.limits.max_velocity_theta = 1;\n            config.setup.limits.max_acceleration_x = 0.5;\n            config.setup.limits.max_acceleration_y = 0.5;\n            config.setup.limits.max_acceleration_z = 0.5;\n            config.setup.limits.max_acceleration_theta = 1;\n            config.setup.limits.max_deceleration_x = 0.5;\n            config.setup.limits.max_deceleration_y = 0.5;\n            config.setup.limits.max_deceleration_z = 0.5;\n            config.setup.limits.max_deceleration_theta = 1;\n            config.setup.limits.max_yaw_rate = 1;\n            config.setup.limits.max_pitch_rate = 1;\n            config.setup.limits.max_roll_rate = 1;\n            config.setup.limits.max_height_rate = 0.5;\n            config.setup.limits.max_distance_rate = 0.5;\n            config.setup.limits.max_yaw_angle = 1.57;\n            config.setup.limits.max_pitch_angle = 1.57;\n            config.setup.limits.max_roll_angle = 1.57;\n            config.setup.limits.max_height_angle = 1.57;\n            config.setup.limits.max_distance_angle = 1.57;\n            config.setup.limits.min_distance_to_target = 0.5;\n            config.setup.limits.min_distance_to_target_angle = 0.5;\n            config.setup.limits.", "CodeBleu_score": 27.5003817069562}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tif (check_cell->obstacle) {\n      current_cell->target_distance = std::numeric_limits<double>::max();\n      return false;\n    }\n    if (check_cell->cost == costmap_2d::NO_INFORMATION) {\n      current_cell->target_distance = std::numeric_limits<double>::max();\n      return false;\n    }\n    double new_distance = current_cell->target_distance +\n      (check_cell->cost - current_cell->cost);\n    if (new_distance < current_cell->target_distance) {\n      current_cell->target_distance = new_distance;\n      return true;\n    }\n    return false;\n  }", "CodeBleu_score": 44.40596574179019}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tif (check_cell->isObstacle()) {\n        current_cell->setTargetDistance(obstacleCosts);\n        return false;\n    }\n    else if (check_cell->getCost(costmap) == costmap_2d::NO_INFORMATION) {\n        current_cell->setTargetDistance(obstacleCosts);\n        return false;\n    }\n    else {\n        double new_distance = current_cell->getTargetDistance() +\n            (current_cell->getX() - check_cell->getX()) *\n            (current_cell->getX() - check_cell->getX()) +\n            (current_cell->getY() - check_cell->getY()) *\n            (current_cell->getY() - check_cell->getY());\n        if (new_distance < current_cell->getTargetDistance()) {\n            current_cell->setTargetDistance(new_distance);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}", "CodeBleu_score": 43.02317783491114}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tif (check_cell->obstacle()) {\n    current_cell->setTargetDistance(obstacleCosts);\n    return false;\n  }\n\n  if (check_cell->unknown()) {\n    current_cell->setTargetDistance(obstacleCosts);\n    return false;\n  }\n\n  unsigned int new_distance = current_cell->getTargetDistance() +\n      (check_cell->getCost() * costmap.getResolution());\n  if (new_distance < current_cell->getTargetDistance()) {\n    current_cell->setTargetDistance(new_distance);\n  }\n\n  return true;\n}", "CodeBleu_score": 43.24802349925445}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n  if (!footprint_spec_.empty()) {\n    double vmag = hypot(traj.xv_, traj.yv_);\n    scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n    for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n      double footprint_cost = footprintCost(traj.x_(i), traj.y_(i), traj.theta_(i), scale, footprint_spec_, costmap_, world_model_);\n      if (footprint_cost < 0) {\n        return footprint_cost;\n      }\n      if (sum_scores_) {\n        cost += footprint_cost;\n      } else {\n        cost = std::max(cost, footprint_cost);\n      }\n    }\n  } else {\n    ROS_ERROR(\"No footprint specified for obstacle cost function\");\n    return -9.0;\n  }\n  return cost;\n}", "CodeBleu_score": 59.89573631680123}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n\n  //if we have a footprint specification, we'll use it to scale the cost\n  //otherwise, we'll just use the speed\n  if (!footprint_spec_.empty()) {\n    scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  }\n  //we'll use the scaling factor to scale the cost\n  //if we're scaling up, we'll take the max cost of the footprint\n  //if we're scaling down, we'll sum the costs of the footprint\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.x_(i), traj.y_(i), traj.th_(i), scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(footprint_cost, cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 56.606579926401004}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n  double vmag = hypot(traj.xv_, traj.yv_);\n\n  //initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (vmag > 0.0) {\n    cost = (vmag * vmag) / (2.0 * max_vel_);\n    scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  }\n\n  //if the footprint specification is empty, log an error and return -9\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"ObstacleCostFunction: footprint specification is empty\");\n    return -9.0;\n  }\n\n  //calculate the footprint cost for each point in the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.x_(i), traj.y_(i), traj.th_(i), scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    //either sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 63.05628134965391}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  scaled_footprint.reserve(footprint_spec.size());\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    scaled_footprint.push_back(scalePoint(footprint_spec.at(i), scale));\n  }\n  // check if the position is off the map\n  if (!costmap->worldToMap(x, y, i, j)) {\n    return -7.0;\n  }\n  // compute the footprint cost\n  double footprint_cost = world_model->footprintCost(i, j, scaled_footprint);\n  // get the cell cost\n  unsigned int cell_cost = costmap->getCost(i, j);\n  // return the maximum between the footprint cost and the cell cost\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 57.68111715618519}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// Get the footprint of the robot\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    double x_i = footprint_spec[i].x * scale;\n    double y_i = footprint_spec[i].y * scale;\n    scaled_footprint.push_back(geometry_msgs::Point(x_i, y_i));\n  }\n  // Get the cost of the footprint\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  // Get the cost of the cell\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n  double cell_cost = costmap->getCost(mx, my);\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 72.24278335915805}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// First, scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  scaled_footprint.reserve(footprint_spec.size());\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point p;\n    p.x = x + (footprint_spec[i].x * scale);\n    p.y = y + (footprint_spec[i].y * scale);\n    scaled_footprint.push_back(p);\n  }\n\n  // Next, check if the robot is inside the map\n  if (!costmap->worldToMap(x, y, i, j)) {\n    return -7.0;\n  }\n\n  // Finally, calculate the cost\n  double footprint_cost = world_model->footprintCost(scaled_footprint, costmap);\n  double cell_cost = costmap->getCost(i, j);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 65.7447427402982}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tboost::mutex::scoped_lock lock(odom_mutex_);\n\n  if (odom_topic != odom_topic_) {\n    if (odom_topic_.empty()) {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to odometry topic: %s\", odom_topic.c_str());\n      odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Unsubscribing from odometry topic: %s\", odom_topic_.c_str());\n      odom_sub_.shutdown();\n    }\n    odom_topic_ = odom_topic;\n  }\n}", "CodeBleu_score": 42.03577703904576}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    ROS_INFO_NAMED(\"dwa_local_planner\", \"Setting odometry topic to: %s\", odom_topic.c_str());\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 52.253669861478954}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tboost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic != odom_topic_) {\n    ROS_INFO_NAMED(\"dwa_local_planner\", \"Changing odometry topic from '%s' to '%s'\", odom_topic_.c_str(), odom_topic.c_str());\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 47.491862364371414}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist = (pos - prev).norm();\n  float angle = std::acos(pos.dot(prev) / (dist * dist));\n\n  if (dist > kOscillationDistThreshold) {\n    resetOscillationFlags();\n  } else if (angle > kOscillationAngleThreshold) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 37.00245598775941}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat distance = (pos - prev).squaredNorm();\n  float angle = fabs(std::atan2(pos[1] - prev[1], pos[0] - prev[0]) - std::atan2(pos[1], pos[0]));\n  if (distance > 0.0001f) {\n    if (distance > 0.0001f && distance > 0.001f * (pos - prev).norm()) {\n      resetOscillationFlags();\n      return;\n    }\n    if (angle > 0.0001f && angle > 0.001f) {\n      resetOscillationFlags();\n      return;\n    }\n  }\n}", "CodeBleu_score": 48.20177334803305}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist_sq = (pos - prev).squaredNorm();\n  float ang_diff = std::abs(pos.z() - prev.z());\n\n  if (dist_sq > 0.0001) {\n    if (dist_sq > 0.000001) {\n      if (dist_sq > 0.00000001) {\n        if (dist_sq > 0.0000000001) {\n          if (dist_sq > 0.00000000001) {\n            if (dist_sq > 0.000000000001) {\n              if (dist_sq > 0.0000000000001) {\n                if (dist_sq > 0.00000000000001) {\n                  if (dist_sq > 0.000000000000001) {\n                    if (dist_sq > 0.0000000000000001) {\n                      if (dist_sq > 0.00000000000000001) {\n                        if (dist_sq > 0.000000000000000001) {\n                          if (dist_sq > 0.0000000000000000001) {\n                            if (dist_sq > 0.00000000000000000001) {\n                              if (dist_sq > 0.000000000000000000001) {\n                                if (dist_sq > 0.0000000000000000000001) {\n                                  if (dist_sq > 0.00000000000000000000", "CodeBleu_score": 20.940351013188348}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    if (gridCoords(pt, gx, gy)) {\n        //get the bounds of the grid cell in world coords\n        geometry_msgs::Point lower_left, upper_right;\n        getCellBounds(gx, gy, lower_left, upper_right);\n\n        //now we need to check what cells could contain the nearest neighbor\n        geometry_msgs::Point32 check_point;\n        double sq_dist = DBL_MAX;\n\n        //left\n        if (gx > 0) {\n            check_point.x = lower_left.x;\n            check_point.y = pt.y;\n            sq_dist = sq_distance(pt, check_point);\n            if (sq_dist < sq_min_separation_)\n                return;\n        }\n\n        //upper left\n        if (gx > 0 && gy < height_ - 1) {\n            check_point.x = lower_left.x;\n            check_point.y = upper_right.y;\n            sq_dist = sq_distance(pt, check_point);\n            if (sq_dist < sq_min_separation_)\n                return;\n        }\n\n        //top\n        if (gy < height_ - 1) {\n            check_point.x = pt.x;\n            check_point.y = upper_right.y;\n            sq_dist = sq_distance(pt, check_point);\n            if (sq_dist < sq_min_separation_)\n                return;\n        }\n\n        //upper right\n        if (gx < width_ - 1 && gy < height_ - 1) {\n            check_point.x = upper_right.x;\n            check_point.y = upper_right.y;\n            sq_dist = sq_distance(pt, check_point);\n            if (sq_dist < sq_min_separation_)\n                return;\n        }\n\n        //right\n        if (gx < width_ - 1) {\n            check_point.x = upper_right.x;\n            check_point.", "CodeBleu_score": 45.688412548615055}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n    gridCoords(pt, gx, gy);\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy));\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy + 1));\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx, gy + 1));\n    }\n\n    //upper right\n    if(gx < width_ - 1 && gy < height_ - 1){", "CodeBleu_score": 43.70135926228376}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n    if(!gridCoords(pt, gx, gy))\n      return;\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, nearestNeighborDistance(pt));\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, nearestNeighborDistance(pt));\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, nearestNeighborDistance(pt));\n    }\n\n    //upper right\n    if(gx < width_ - 1 && gy < height_ - 1){\n      check_point.x = upper_right.x;\n      check_point.y = upper_right", "CodeBleu_score": 54.58916407698715}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel(i) > vel(i)) {\n      if (vel(i) + acclimits(i) * dt < sample_target_vel(i)) {\n        new_vel(i) = vel(i) + acclimits(i) * dt;\n      } else {\n        new_vel(i) = sample_target_vel(i);\n      }\n    } else if (sample_target_vel(i) < vel(i)) {\n      if (vel(i) - acclimits(i) * dt > sample_target_vel(i)) {\n        new_vel(i) = vel(i) - acclimits(i) * dt;\n      } else {\n        new_vel(i) = sample_target_vel(i);\n      }\n    } else {\n      new_vel(i) = sample_target_vel(i);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 56.13938125051303}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      if (vel[i] + acclimits[i] * dt < sample_target_vel[i]) {\n        new_vel[i] = vel[i] + acclimits[i] * dt;\n      } else {\n        new_vel[i] = sample_target_vel[i];\n      }\n    } else if (sample_target_vel[i] < vel[i]) {\n      if (vel[i] - acclimits[i] * dt > sample_target_vel[i]) {\n        new_vel[i] = vel[i] - acclimits[i] * dt;\n      } else {\n        new_vel[i] = sample_target_vel[i];\n      }\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 72.84522373500054}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = vel[i] + std::min(acclimits[i], sample_target_vel[i] - vel[i]) * dt;\n    } else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = vel[i] - std::min(acclimits[i], vel[i] - sample_target_vel[i]) * dt;\n    } else {\n      new_vel[i] = sample_target_vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 72.46577828076451}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble heading_diff = DBL_MAX;\n  int goal_x, goal_y;\n\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    goal_x = global_plan_[i].cell_x;\n    goal_y = global_plan_[i].cell_y;\n\n    if (lineCost(cell_x, goal_x, cell_y, goal_y) >= 0) {\n      double goal_x_world, goal_y_world;\n      costmap_.mapToWorld(goal_x, goal_y, goal_x_world, goal_y_world);\n      double goal_heading = atan2(goal_y_world - y, goal_x_world - x);\n\n      if (fabs(angles::shortest_angular_distance(heading, goal_heading)) < heading_diff) {\n        heading_diff = fabs(angles::shortest_angular_distance(heading, goal_heading));\n      }\n    }\n  }\n\n  return heading_diff;\n}", "CodeBleu_score": 60.37064045236566}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble goal_x, goal_y, goal_heading;\n\n  //Check if the goal is already in the global plan\n  if (cell_x == global_plan_[0].x && cell_y == global_plan_[0].y) {\n    goal_x = global_plan_[0].x;\n    goal_y = global_plan_[0].y;\n    goal_heading = global_plan_[0].theta;\n  } else {\n    //Check if the goal is in the global plan\n    for (int i = global_plan_.size() - 1; i >= 0; i--) {\n      if (cell_x == global_plan_[i].x && cell_y == global_plan_[i].y) {\n        goal_x = global_plan_[i].x;\n        goal_y = global_plan_[i].y;\n        goal_heading = global_plan_[i].theta;\n        break;\n      }\n    }\n  }\n\n  //If the goal is not in the global plan, return DBL_MAX\n  if (goal_x == 0) {\n    ROS_WARN(\"Global plan does not contain goal\");\n    return DBL_MAX;\n  }\n\n  //Convert the goal cell coordinates to world coordinates\n  double goal_x_world, goal_y_world;\n  costmap_.mapToWorld(goal_x, goal_y, goal_x_world, goal_y_world);\n\n  //Calculate the shortest angular distance between the current heading and the direction to the goal point\n  double heading_diff = angles::shortest_angular_distance(heading, atan2(goal_y_world - y, goal_x_world - x));\n\n  return fabs(heading_diff);\n}", "CodeBleu_score": 55.80424732572333}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble heading_diff = DBL_MAX;\n    double heading_angle = 0.0;\n\n    //Find the farthest point along the path that the robot can see\n    for (int i = global_plan_.size() - 1; i >= 0; i--) {\n      double goal_x = global_plan_[i].pose.position.x;\n      double goal_y = global_plan_[i].pose.position.y;\n\n      if (lineCost(cell_x, cell_x + 1, cell_y, cell_y + 1) < 0) {\n        continue;\n      }\n\n      //Convert the goal point to world coordinates\n      double goal_world_x = costmap_.mapToWorld(goal_x, goal_y).x;\n      double goal_world_y = costmap_.mapToWorld(goal_x, goal_y).y;\n\n      //Calculate the heading difference between the goal point and the robot's current heading\n      heading_angle = atan2(goal_world_y - y, goal_world_x - x) - heading;\n      heading_angle = angles::normalize_angle(heading_angle);\n\n      //If the heading difference is smaller than the previous heading difference, update the heading difference\n      if (heading_angle < heading_diff) {\n        heading_diff = heading_angle;\n      }\n    }\n\n    return heading_diff;\n}", "CodeBleu_score": 56.78175197315386}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tTrajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    if (t.cost_ < 0) {\n      ROS_WARN(\"Trajectory Planner: Trajectory cost is %f, impossible cost is %f, vx_samp is %f, vy_samp is %f, vtheta_samp is %f\", t.cost_, impossible_cost, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 57.091285946354766}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tTrajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    if ( t.cost_ >= 0 ) {\n      return true;\n    }\n\n    // otherwise, log the warning.\n    ROS_WARN(\"TrajectoryPlanner::checkTrajectory: trajectory cost = %f, vx = %f, vy = %f, vtheta = %f\",\n             t.cost_, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }", "CodeBleu_score": 59.19545035454217}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tTrajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    if (t.cost_ >= 0) {\n      return true;\n    }\n\n    ROS_WARN_THROTTLE(1, \"Trajectory Planner: Trajectory Cost: %f, Sample Velocities: [%f, %f, %f]\", t.cost_, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }", "CodeBleu_score": 60.93573409112318}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_){\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized\");\n    return;\n  }\n\n  if(!global_costmap_){\n    ROS_ERROR(\"Global costmap has not been set\");\n    return;\n  }\n\n  if(!local_costmap_){\n    ROS_ERROR(\"Local costmap has not been set\");\n    return;\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if(invert_area_to_clear_){\n    ROS_WARN(\"Clearing costmaps outside of specified area\");\n  }\n  else{\n    ROS_WARN(\"Clearing costmaps inside of specified area\");\n  }\n\n  clear(global_costmap_);\n  clear(local_costmap_);\n\n  ROS_DEBUG(\"Clearing costmaps took %f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 34.36277928520055}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t// check if the object is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  // check if the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  // check if the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  // check if the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  // check if the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  // check if the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  // check if the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  // check if the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  // check if the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_)", "CodeBleu_score": 23.13164882079021}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please run initialize() before using this plugin\");\n    return;\n  }\n\n  if(!global_costmap_ || !local_costmap_){\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please run initialize() before using this plugin\");\n    return;\n  }\n\n  if(affected_maps_.size() == 0){\n    ROS_WARN(\"ClearCostmapRecovery has no affected costmaps, nothing to clear\");\n    return;\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  // clear the global costmap\n  if(affected_maps_.count(\"global\")!=0){\n    if(invert_area_to_clear_){\n      ROS_WARN(\"Clearing outside the specified area\");\n    }\n    clear(global_costmap_);\n  }\n\n  // clear the local costmap\n  if(affected_maps_.count(\"local\")!=0){\n    if(invert_area_to_clear_){\n      ROS_WARN(\"Clearing outside the specified area\");\n    }\n    clear(local_costmap_);\n  }\n\n  // update the global costmap\n  if(affected_maps_.count(\"global\")!=0 && update_global_costmap_){\n    if(invert_area_to_clear_){\n      ROS_WARN(\"Clearing outside the specified area\");\n    }\n    global_costmap_->updateMap();\n  }\n\n  // update the local costmap\n  if(affected_maps_.count(\"local\")!=0 && update_local_costmap_){\n    if(invert_area_to_clear_){\n      ROS_WARN(\"Clearing outside the specified area\");\n    }\n    local_costmap_->updateMap();\n  }\n\n  ROS_DEBUG(\"ClearCostmapRecovery took %.3f seconds to clear %s\", (ros::WallTime::now() - t0).toSec(), affected_maps_.c_str());\n}", "CodeBleu_score": 50.97632983856554}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t// Check if the polygon is empty\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\t// Initialize the PolygonOutlineCells object\n\tPolygonOutlineCells polygon_outline_cells;\n\n\t// Iterate through the polygon vertices\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\n\t\t// Get the current point\n\t\tMapLocation point = polygon[i];\n\n\t\t// Get the next point\n\t\tMapLocation next_point;\n\t\tif (i == polygon.size() - 1) {\n\t\t\tnext_point = polygon[0];\n\t\t} else {\n\t\t\tnext_point = polygon[i + 1];\n\t\t}\n\n\t\t// Gather the cells between the current point and the next point\n\t\tpolygon_outline_cells.raytraceLine(point, next_point);\n\t}\n\n\t// Close the polygon by connecting the last point to the first\n\tif (polygon.size() > 1) {\n\t\tMapLocation first_point = polygon[0];\n\t\tMapLocation last_point = polygon[polygon.size() - 1];\n\t\tpolygon_outline_cells.raytraceLine(last_point, first_point);\n\t}\n\n\t// Copy the cells to the polygon_cells vector\n\tpolygon_cells = polygon_outline_cells.cells;\n}", "CodeBleu_score": 55.1023640166071}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tif (polygon.empty()) {\n    return;\n  }\n  PolygonOutlineCells outline_cells(polygon);\n  polygon_cells.clear();\n  polygon_cells.reserve(polygon.size());\n  polygon_cells.push_back(polygon[0]);\n  for (unsigned int i = 1; i < polygon.size(); ++i) {\n    raytraceLine(polygon[i - 1], polygon[i], outline_cells);\n  }\n  if (polygon.size() > 1) {\n    raytraceLine(polygon[polygon.size() - 1], polygon[0], outline_cells);\n  }\n  polygon_cells.insert(polygon_cells.end(), outline_cells.cells.begin(), outline_cells.cells.end());\n}", "CodeBleu_score": 51.9626338815923}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t// If the polygon is empty, return an empty polygon.\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\t// If the polygon has only one point, return an empty polygon.\n\tif (polygon.size() == 1) {\n\t\treturn;\n\t}\n\n\t// If the polygon has two points, return a line between them.\n\tif (polygon.size() == 2) {\n\t\traytraceLine(polygon[0], polygon[1], polygon_cells);\n\t\treturn;\n\t}\n\n\t// If the polygon has three or more points, return a polygon formed by connecting the last point to the first.\n\tif (polygon.size() >= 3) {\n\t\traytraceLine(polygon[polygon.size() - 1], polygon[0], polygon_cells);\n\t\tfor (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n\t\t\traytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n\t\t}\n\t\treturn;\n\t}\n}", "CodeBleu_score": 57.35778397856457}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  grid_pub_.publish(grid_);\n}", "CodeBleu_score": 48.1326047314528}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t// Lock the costmap mutex.\n  costmap_->getMutex()->lock();\n\n  // Retrieve the costmap resolution.\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header.\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n\n  // Set the grid's resolution.\n  grid_.info.resolution = resolution;\n\n  // Set the grid's width and height.\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Set the grid's origin.\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Resize the grid data vector.\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Convert the map coordinates to world coordinates for the origin.\n  grid_.info.origin.position.x = costmap_->mapToWorld(0, 0).x;\n  grid_.info.origin.position.y = costmap_->mapToWorld(0, 0).y;\n\n  // Populate the grid data from the costmap's character map.\n  for (int y = 0; y < grid_.info.height; ++y) {\n    for (int x = 0; x < grid_.info.width; ++x) {\n      // Get the cell index.\n      unsigned int index = x + y * grid_.info.width;\n\n      // Get the cell value.\n      unsigned char value = costmap_->getCharMap()[index];", "CodeBleu_score": 60.68463817569896}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// Lock the costmap mutex and retrieve the resolution\n  costmap_->getMutex()->lock();\n  double resolution = costmap_->getResolution();\n  costmap_->getMutex()->unlock();\n\n  // Set the grid's header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.header.stamp = ros::Time::now();\n\n  // Set the grid's resolution, width, and height\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin and set the origin's position and orientation\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates and resize the grid data vector\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = translation_table_[costmap_->getCharMap()[i]];\n  }\n}", "CodeBleu_score": 63.5071039662894}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// Lock the mutex and get the resolution\n  boost::recursive_mutex::scoped_lock lock(*costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n\n  // Set the grid's resolution, width, and height\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Set the grid's origin\n  grid_.info.origin.position.x = costmap_->mapToWorld(0, 0).x();\n  grid_.info.origin.position.y = costmap_->mapToWorld(0, 0).y();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map\n  populateGridData();\n}", "CodeBleu_score": 54.282764650022045}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// If the new configuration is the same as the old one, return.\n  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If the new configuration contains a valid footprint string, convert the string to a footprint and set it.\n  if (new_config.footprint.size() > 0) {\n    std::vector<geometry_msgs::Point> footprint;\n    if (makeFootprintFromString(new_config.footprint, footprint)) {\n      setUnpaddedRobotFootprint(footprint);\n      return;\n    }\n  }\n\n  // If the footprint string is invalid, log an error.\n  ROS_ERROR(\"The footprint string provided is invalid.  Using the footprint based on the robot radius.\");\n\n  // If no valid footprint string is provided, set the footprint based on the robot radius.\n  setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n}", "CodeBleu_score": 70.49514706412945}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.footprint_padding == old_config.footprint_padding &&\n      new_config.robot_radius == old_config.robot_radius &&\n      new_config.footprint_spec == old_config.footprint_spec) {\n    return;\n  }\n\n  if (new_config.footprint_spec != \"\") {\n    std::vector<geometry_msgs::Point> footprint;\n    if (makeFootprintFromString(new_config.footprint_spec, footprint)) {\n      setUnpaddedRobotFootprint(footprint);\n    } else {\n      ROS_ERROR(\"Could not create footprint from string: %s\", new_config.footprint_spec.c_str());\n    }\n  } else {\n    // If no footprint string is provided, we assume the footprint is a circle with a radius equal to the robot radius.\n    std::vector<geometry_msgs::Point> footprint;\n    makeFootprintFromRadius(new_config.robot_radius, footprint);\n    setUnpaddedRobotFootprint(footprint);\n  }\n}", "CodeBleu_score": 63.813822971566445}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.footprint_padding == old_config.footprint_padding &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n  if (!new_config.footprint_padding.empty()) {\n    try {\n      std::vector<geometry_msgs::Point> footprint;\n      makeFootprintFromString(new_config.footprint_padding, footprint);\n      setUnpaddedRobotFootprint(footprint);\n    } catch (...) {\n      ROS_ERROR(\"The footprint_padding parameter in the new configuration is invalid.\");\n    }\n  } else {\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n  }\n}", "CodeBleu_score": 70.94398996360933}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// Get the robot's pose\n  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose))\n  {\n    ROS_WARN(\"Costmap2DROS: Failed to get robot pose\");\n    return;\n  }\n  // Check for movement\n  if (new_pose.pose.position.x != current_pose_.pose.position.x ||\n      new_pose.pose.position.y != current_pose_.pose.position.y ||\n      new_pose.pose.orientation.x != current_pose_.pose.orientation.x ||\n      new_pose.pose.orientation.y != current_pose_.pose.orientation.y ||\n      new_pose.pose.orientation.z != current_pose_.pose.orientation.z ||\n      new_pose.pose.orientation.w != current_pose_.pose.orientation.w)\n  {\n    // Update the robot's pose\n    current_pose_ = new_pose;\n    // Publish the robot's pose\n    robot_pose_pub_.publish(current_pose_);\n    // Update the costmap\n    updateOrigin(current_pose_.pose.position.x, current_pose_.pose.position.y);\n    updateFootprint();\n    // Update the costmap\n    updateCostmap();\n  }\n}", "CodeBleu_score": 54.07964975366535}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// get the robot's current pose\n  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose))\n  {\n    ROS_WARN(\"Costmap2DROS: Failed to get robot pose\");\n    return;\n  }\n  // check if the robot has moved\n  if (new_pose.pose.position.x != current_pose_.pose.position.x ||\n      new_pose.pose.position.y != current_pose_.pose.position.y ||\n      new_pose.pose.position.z != current_pose_.pose.position.z ||\n      new_pose.pose.orientation.x != current_pose_.pose.orientation.x ||\n      new_pose.pose.orientation.y != current_pose_.pose.orientation.y ||\n      new_pose.pose.orientation.z != current_pose_.pose.orientation.z ||\n      new_pose.pose.orientation.w != current_pose_.pose.orientation.w)\n  {\n    // if so, update the current pose and reconfigure\n    current_pose_ = new_pose;\n    reconfigure_ = true;\n  }\n}", "CodeBleu_score": 54.65989596299614}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0, \"Costmap2DROS::movementCB()\");\n  // ROS_WARN_THROTTLE(1.0", "CodeBleu_score": 9.246498340794018}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t// retrieve the list of plugins\n  std::vector<LayeredCostmap2D::Ptr> plugins = layered_costmap_->getPlugins();\n  // check if the costmap was stopped\n  if (stopped_) {\n    // re-subscribe to topics by activating each plugin\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n      plugins[i]->activate();\n    }\n    // set the stopped flag to false\n    stopped_ = false;\n  }\n  // set stop_updates_ to false\n  stop_updates_ = false;\n  // wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !initialized_ || !map_update_thread_.isRunning()) {\n    ros::spinOnce();\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 55.59011563767003}, {"code": "void Costmap2DROS::start(){\n\tif (stopped_) {\n    ROS_INFO(\"[%s] Costmap is stopped. Re-activating plugins.\", name_.c_str());\n    for (std::vector<LayeredCostmap2D::Ptr>::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n    stop_updates_ = false;\n  }\n\n  // Wait for ROS to start\n  while (!ros::isStarted()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  // Wait for the costmap to be initialized\n  while (!initialized_) {\n    ros::Duration(0.01).sleep();\n  }\n\n  // Wait for the map update thread to start\n  while (!map_update_thread_->isRunning()) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 52.59349404219002}, {"code": "void Costmap2DROS::start(){\n\tROS_INFO(\"Starting costmap\");\n  std::vector<BaseGlobalPlanner*> global_planners;\n  std::vector<BaseLocalPlanner*> local_planners;\n  std::vector<BaseCostmap*> costmaps;\n  std::vector<BaseLayer*> layers;\n  std::vector<InteractiveMarkerServer*> interactive_marker_servers;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_displays;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_old;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_old_new;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new_old;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new_old_new;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new_old_new_old;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new_old_new_old_new;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new_old_new_old_new_old;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new_old_new_old_new_old_new;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new_old_new_old_new_old_new_old;\n  std::vector<InteractiveMarkerDisplay*> interactive_marker_display_list_new_old_new", "CodeBleu_score": 7.70658929097461}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t// If we're not keeping any observations, just return\n  if (observation_keep_time_ == 0) {\n    return;\n  }\n\n  // If there are no observations, just return\n  if (observation_list_.empty()) {\n    return;\n  }\n\n  // If the first observation is older than the keep time, remove it\n  if (observation_list_.front().header.stamp + observation_keep_time_ < ros::Time::now()) {\n    observation_list_.erase(observation_list_.begin());\n  }\n\n  // Iterate through the list and remove any observations that are older than the keep time\n  for (auto it = observation_list_.begin(); it != observation_list_.end(); ++it) {\n    if (it->header.stamp + observation_keep_time_ < ros::Time::now()) {\n      observation_list_.erase(it);\n      break;\n    }\n  }\n}", "CodeBleu_score": 47.42364797987013}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0)) {\n    observation_list_.clear();\n    return;\n  }\n\n  observation_list_t::iterator it = observation_list_.begin();\n  while (it != observation_list_.end()) {\n    if ((*it).header.stamp + observation_keep_time_ < ros::Time::now()) {\n      it = observation_list_.erase(it);\n    } else {\n      break;\n    }\n  }\n}", "CodeBleu_score": 35.26416468579319}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == 0) {\n    observation_list_.clear();\n  } else {\n    ros::Time oldest_valid_observation = ros::Time::now() - observation_keep_time_;\n    observation_list_.erase(std::remove_if(observation_list_.begin(), observation_list_.end(),\n                                           [&oldest_valid_observation](const Observation& obs) {\n                                             return obs.time < oldest_valid_observation;\n                                           }),\n                            observation_list_.end());\n  }\n}", "CodeBleu_score": 39.84409971478989}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tif (start_index == end_index) {\n    ROS_WARN(\"Start and end indices are the same. No interpolation needed.\");\n    return;\n  }\n\n  // Calculate the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the yaw angles\n  double shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Calculate the incremental change in angle for each pose\n  double incremental_angle = shortest_angular_distance / (end_index - start_index);\n\n  // Interpolate the orientation of each pose in the specified range\n  for (int i = start_index; i < end_index; i++) {\n    set_angle(&path[i], start_yaw + (i - start_index) * incremental_angle);\n  }\n}", "CodeBleu_score": 61.990394905415236}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// Check if the path is empty\n  if (path.empty()) {\n    ROS_WARN_STREAM(\"Path is empty!\");\n    return;\n  }\n\n  // Check if the start index is out of bounds\n  if (start_index < 0 || start_index >= path.size()) {\n    ROS_WARN_STREAM(\"Start index is out of bounds!\");\n    return;\n  }\n\n  // Check if the end index is out of bounds\n  if (end_index < 0 || end_index >= path.size()) {\n    ROS_WARN_STREAM(\"End index is out of bounds!\");\n    return;\n  }\n\n  // Check if the start index is greater than the end index\n  if (start_index > end_index) {\n    ROS_WARN_STREAM(\"Start index is greater than end index!\");\n    return;\n  }\n\n  // Check if the start and end indices are the same\n  if (start_index == end_index) {\n    ROS_WARN_STREAM(\"Start and end indices are the same!\");\n    return;\n  }\n\n  // Check if the start index is the last index\n  if (start_index == path.size() - 1) {\n    ROS_WARN_STREAM(\"Start index is the last index!\");\n    return;\n  }\n\n  // Check if the end index is the first index\n  if (end_index == 0) {\n    ROS_WARN_STREAM(\"End index is the first index!\");\n    return;\n  }\n\n  // Check if the start index is the first index\n  if (start_index == 0) {\n    ROS_WARN_STREAM(\"Start index is the first index!\");\n    return;\n  }\n\n  // Check if the start and end indices are consecutive\n  if (start_index + 1 != end_index) {\n    ROS_WARN_STREAM(\"Start and end indices are not consecutive!\");\n    return;\n  }\n\n  // Check if the start index is the last index\n  if (end_index == path.size() - 1) {", "CodeBleu_score": 25.10658202249203}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tif (start_index == end_index) {\n    return;\n  }\n\n  double start_angle = angles::shortest_angular_distance(\n      tf2::getYaw(path[start_index].pose.orientation), 0.0);\n  double end_angle = angles::shortest_angular_distance(\n      tf2::getYaw(path[end_index].pose.orientation), 0.0);\n\n  double delta_angle = end_angle - start_angle;\n  if (delta_angle > M_PI) {\n    delta_angle -= 2 * M_PI;\n  } else if (delta_angle < -M_PI) {\n    delta_angle += 2 * M_PI;\n  }\n\n  double increment = delta_angle / (end_index - start_index);\n  for (int i = start_index; i < end_index; ++i) {\n    set_angle(&path[i], start_angle);\n    start_angle += increment;\n  }\n}", "CodeBleu_score": 56.93348621330486}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// TODO: Implement this function\n  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  bool success = makePlan(req.start, req.goal, resp.path);\n\n  // Update the response with the success status and the generated path\n  resp.plan_found = success;\n  if (success) {\n    resp.path.header.frame_id = \"map\";\n  }\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 71.55106375095036}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t//set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    //call makePlan to generate a path\n    nav_msgs::Path path = makePlan(req.start, req.goal);\n\n    //update the response with the success status and the generated path if a plan is found\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.poses = path.poses;\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.seq = 0;\n\n    //return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 53.50144077485511}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\t// Call makePlan to generate a path\n\tbool found_path = makePlan(req.start, req.goal, resp.path);\n\t// Update the response with the success status and the generated path if a plan is found\n\tresp.success = found_path;\n\tif (found_path) {\n\t\tresp.path.header.frame_id = \"map\";\n\t}\n\t// Return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 60.969227452713326}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.setCallbackQueue(&queue_);\n    private_nh.param(\"global_frame\", global_frame, string(\"map\"));\n    private_nh.param(\"global_planner_frequency\", global_planner_frequency, 1.0);\n    private_nh.param(\"global_planner_patience\", global_planner_patience, 1.0);\n    private_nh.param(\"goal_tolerance\", goal_tolerance, 0.1);\n    private_nh.param(\"max_retries\", max_retries, 5);\n    private_nh.param(\"min_dist_to_goal\", min_dist_to_goal, 0.0);\n    private_nh.param(\"min_dist_to_goal_factor\", min_dist_to_goal_factor, 0.5);\n    private_nh.param(\"max_dist_to_goal_factor\", max_dist_to_goal_factor, 2.0);\n    private_nh.param(\"goal_retry_rate\", goal_retry_rate, 0.5);\n    private_nh.param(\"goal_retry_rate_factor\", goal_retry_rate_factor, 0.5);\n    private_nh.param(\"goal_retry_rate_min\", goal_retry_rate_min, 0.1);\n    private_nh.param(\"goal_retry_rate_max\", goal_retry_rate_max, 0.9);\n    private_nh.param(\"retry_rate_decay_rate\", retry_rate_decay_rate, 0.9);\n    private_nh.param(\"retry_rate_decay_rate_factor\", retry_rate_decay_rate_factor, 0.5);\n    private_nh.param(\"retry_rate_decay_rate_min\", retry_rate_decay_rate_min, 0.1);\n    private_nh.param(\"retry_rate_decay_rate_max\", retry_rate_decay_rate_max, 0.9);", "CodeBleu_score": 31.56238676626877}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.setParam(\"global_frame\", cmap->getGlobalFrameID());\n    private_nh.setParam(\"base_frame\", cmap->getBaseFrameID());\n    private_nh.setParam(\"is_2d\", cmap->is2D());\n    private_nh.setParam(\"is_debug\", cmap->isDebug());\n    private_nh.setParam(\"is_rolling\", cmap->isRolling());\n    private_nh.setParam(\"is_tracking_unknown\", cmap->isTrackingUnknown());\n    private_nh.setParam(\"track_unknown_space\", cmap->trackUnknownSpace());\n    private_nh.setParam(\"use_maximum_score\", cmap->useMaxScore());\n    private_nh.setParam(\"use_unknown_costmap\", cmap->useUnknownCostmap());\n    private_nh.setParam(\"unknown_cost_value\", cmap->getUnknownCostValue());\n    private_nh.setParam(\"lethal_cost_value\", cmap->getLethalCostValue());\n    private_nh.setParam(\"inscribed_radius\", cmap->getInscribedRadius());\n    private_nh.setParam(\"circumscribed_radius\", cmap->getCircumscribedRadius());\n    private_nh.setParam(\"footprint_padding\", cmap->getFootprintPadding());\n    private_nh.setParam(\"transform_tolerance\", cmap->getTransformTolerance());\n    private_nh.setParam(\"rolling_window_size\", cmap->getRollingWindowSize());\n    private_nh.setParam(\"rolling_window_duration\", cmap->getRollingWindowDuration());\n    private_nh.setParam(\"costmap_track_unknown_space\", cmap->trackUnknownSpace());\n    private_nh.setParam(\"costmap_track_unknown_space_threshold\", cmap->getTrackUnknownThreshold());\n    private_nh.setParam(\"costmap_track_unknown_space_min_duration\", cmap->getTrackUnknownMinDuration());\n    private_nh.setParam(\"costmap_track_", "CodeBleu_score": 30.490800955856145}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.setCallbackQueue(&queue_);\n    private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    ROS_INFO(\"Planner %s initialized\", name_.c_str());\n}", "CodeBleu_score": 63.92731075550849}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t// TODO: Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() || wx > costmap_->getSizeInMetersX() + costmap_->getOriginX() || wy > costmap_->getSizeInMetersY() + costmap_->getOriginY()) {\n    ROS_WARN(\"GlobalPlanner::worldToMap: world coordinates are out of bounds!\");\n    return false;\n  }\n\n  // TODO: Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // TODO: Return true if the map coordinates are within the costmap's size limits; otherwise, return false.\n  if (mx < 0 || my < 0 || mx > costmap_->getSizeInCellsX() - 1 || my > costmap_->getSizeInCellsY() - 1) {\n    ROS_WARN(\"GlobalPlanner::worldToMap: map coordinates are out of bounds!\");\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 45.09395614618585}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (wx < 0 || wx > costmap_->getSizeInMetersX() || wy < 0 || wy > costmap_->getSizeInMetersY()) {\n    ROS_WARN(\"GlobalPlanner::worldToMap: world coordinates (%f, %f) are out of bounds!\", wx, wy);\n    return false;\n  }\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n  return true;\n}", "CodeBleu_score": 41.64995853837191}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (costmap_->worldToMap(wx, wy, mx, my)) {\n    if (mx >= 0 && mx < costmap_->getSizeInCellsX() && my >= 0 && my < costmap_->getSizeInCellsY()) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 34.8608221536802}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = \"map\";\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.poses = path;\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 47.06365049962291}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n        return;\n    }\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = planner_frame_;\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses = path;\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 49.73184190166601}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n        ROS_ERROR(\"Planner not initialized, please call initialize() before using this planner\");\n        return;\n    }\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses = path;\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 48.11571226023512}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Received a new goal\");\n\n  // Wrap the goal in an action goal\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n\n  // Publish the action goal\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.81986199606901}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal in action goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 76.47379818125968}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal in action goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 66.00890572784347}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tROS_INFO(\"Distance check timer triggered.\");\n    if (getSqDistance() > sq_distance_limit_) {\n      ROS_INFO(\"Distance check passed. Removing speed limit.\");\n      remove_limit_thread_.reset();\n      remove_limit_thread_.reset(new boost::thread(&MoveSlowAndClear::removeSpeedLimit, this));\n      distance_check_timer_.stop();\n    }\n  }", "CodeBleu_score": 50.71799855993911}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > sq_dist_limit_) {\n    ROS_INFO(\"Robot has moved far enough to remove speed limit\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 62.738590509809875}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tROS_DEBUG(\"distanceCheck\");\n  if (getSqDistance() > sq_limit_distance_) {\n    ROS_INFO(\"Moving robot far enough to remove speed limit.\");\n    distance_check_timer_.stop();\n    if (remove_limit_thread_ != NULL) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n  }\n}", "CodeBleu_score": 71.85898911199402}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Get the current robot pose\n    geometry_msgs::PoseStamped robot_pose = cmap_->getRobotPose();\n\n    // Create a new goal pose\n    geometry_msgs::PoseStamped goal_pose;\n    goal_pose.header = robot_pose.header;\n    goal_pose.pose = goal->pose;\n\n    // Create a new path\n    std::vector<geometry_msgs::PoseStamped> path;\n\n    // Generate a path from the current pose to the goal pose\n    if (!makePlan(robot_pose, goal_pose, path)) {\n        ROS_WARN(\"NavfnWithCostmap: No path found to goal\");\n        return;\n    }\n\n    // Publish the path\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = robot_pose.header.frame_id;\n    path_msg.header.stamp = robot_pose.header.stamp;\n    path_msg.poses = path;\n    path_pub_.publish(path_msg);\n\n    // Publish the global plan\n    nav_msgs::Path global_plan_msg;\n    global_plan_msg.header.frame_id = robot_pose.header.frame_id;\n    global_plan_msg.header.stamp = robot_pose.header.stamp;\n    global_plan_msg.poses = path;\n    global_plan_pub_.publish(global_plan_msg);\n}", "CodeBleu_score": 44.37899894963222}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Get the current pose of the robot\n  geometry_msgs::PoseStamped robot_pose = cmap_->getRobotPose();\n\n  // Create a new goal pose\n  geometry_msgs::PoseStamped goal_pose;\n  goal_pose.header = robot_pose.header;\n  goal_pose.pose = goal->pose;\n\n  // Create an empty path vector\n  std::vector<geometry_msgs::PoseStamped> path;\n\n  // Generate a path from the current pose to the goal pose\n  if (!makePlan(robot_pose, goal_pose, path)) {\n    ROS_WARN(\"NavfnWithCostmap: Could not find a path to goal.\");\n    return;\n  }\n\n  // Publish the path\n  nav_msgs::Path path_msg;\n  path_msg.header = robot_pose.header;\n  path_msg.poses = path;\n  path_pub_.publish(path_msg);\n\n  // Publish the goal pose\n  goal_pub_.publish(goal_pose);\n\n  // Publish the robot pose\n  robot_pose_pub_.publish(robot_pose);\n\n  // Publish the costmap\n  costmap_pub_.publish(cmap_->getCostmap());\n\n  // Publish the footprint\n  footprint_pub_.publish(cmap_->getRobotFootprint());\n\n  // Publish the robot's transform\n  tf::Stamped<tf::Transform> robot_transform;\n  robot_transform.stamp_ = robot_pose.header.stamp;\n  robot_transform.frame_id_ = robot_pose.header.frame_id;\n  robot_transform.setOrigin(tf::Vector3(robot_pose.pose.position.x, robot_pose.pose.position.y, 0.0));\n  robot_transform.setRotation(tf::Quaternion(robot_pose.pose.orientation.x, robot_pose.pose.orientation.y, robot_pose.pose.orientation.z, robot_pose.pose.orientation.w));\n  tf_broadcaster_.sendTransform(robot_transform);\n}", "CodeBleu_score": 43.08333768840144}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Get the current pose of the robot\n  geometry_msgs::PoseStamped current_pose = cmap_->getRobotPose();\n\n  // Create a path message to store the path to the goal\n  nav_msgs::Path path;\n\n  // Generate a path from the current pose to the goal pose\n  makePlan(current_pose, *goal, path);\n\n  // Publish the path\n  path_pub_.publish(path);\n}", "CodeBleu_score": 57.05213101121204}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a ParamSet service request\n\tmavros_msgs::ParamSet::Request request;\n\t// Assign the parameter ID and value from the provided GimbalParamSet structure\n\trequest.param_id = param_set.param_id;\n\trequest.value = param_set.value;\n\t// Call the param_set_client_ to send the request\n\tthis->param_set_client_.call(request);\n}", "CodeBleu_score": 58.17684350821042}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tparam_set_client_.waitForExistence();\n  param_set_client_.call(param_set);\n}", "CodeBleu_score": 29.42035409258894}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tparam_set_client_.request.param_id = param_set.param_id;\n    param_set_client_.request.param_value = param_set.param_value;\n    param_set_client_.request.param_type = param_set.param_type;\n    param_set_client_.call(param_set_client_.request, param_set_client_.response);\n}", "CodeBleu_score": 48.73327785957444}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t// Wait for a connection from the ground station\n\twaitConnectionFromGroundStation();\n\t\n\t// Enter a loop to accept incoming connections, receive data, and process it\n\twhile (1) {\n\t\t// Accept an incoming connection\n\t\taccept();\n\t\t\n\t\t// Receive data from the ground station\n\t\tpubMsg = recv(sockfd, buf, BUFSIZE, 0);\n\t\t\n\t\t// If data was received successfully\n\t\tif (pubMsg > 0) {\n\t\t\t// Decode the message and publish it\n\t\t\tdecodeMsg();\n\t\t}\n\t\t\n\t\t// If the received message length is zero or less, log an error and close the socket\n\t\telse {\n\t\t\tROS_ERROR(\"Error receiving data from ground station.\");\n\t\t\tclose(sockfd);\n\t\t\texit(1);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.041383348887198}, {"code": "void CommunicationBridge::serverFun(){\n\t// Wait for a connection from the ground station\n\twaitConnectionFromGroundStation();\n\n\t// Enter a loop to accept connections\n\twhile (true) {\n\t\t// Accept a connection\n\t\taccept();\n\n\t\t// Receive a message\n\t\tint recv_len = recv(sockfd, buf, sizeof(buf), 0);\n\n\t\t// Decode the message\n\t\tif (recv_len > 0) {\n\t\t\tdecodeMsg(buf);\n\t\t}\n\t\telse {\n\t\t\tperror(\"recv\");\n\t\t\tROS_ERROR(\"Received message length is zero or less\");\n\t\t\tclose(sockfd);\n\t\t\texit(1);\n\t\t}\n\t}\n}", "CodeBleu_score": 24.301675220379582}, {"code": "void CommunicationBridge::serverFun(){\n\t// Wait for a connection from the ground station\n  waitConnectionFromGroundStation();\n\n  // Enter a loop to accept incoming connections\n  while (true) {\n    // Accept a connection\n    accept();\n\n    // Receive data\n    recv();\n\n    // Decode the message\n    decodeMsg();\n\n    // Publish the message\n    pubMsg();\n\n    // Close the socket\n    close();\n  }\n}", "CodeBleu_score": 2.8142479125038973}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (this->simulation_mode_) {\n    std::map<int, std::shared_ptr<UAVBasic>>::iterator it;\n    it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n    if (it != this->swarm_control_simulation_.end()) {\n      (*it).second->uavCmdPub.publish(uav_cmd);\n    }\n  } else {\n    this->uav_basic_->uavCmdPub.publish(uav_cmd);\n  }\n}", "CodeBleu_score": 52.97115545376598}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (this->simulation_mode_) {\n    // If in simulation mode, find the corresponding UAV by ID and publish the command to the UAV\n    std::map<int, std::shared_ptr<UAVBasic>>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n    if (it != this->swarm_control_simulation_.end()) {\n      (*it).second->uavCmdPub.publish(uav_cmd);\n    }\n  } else {\n    // If not in simulation mode, publish the command to the single UAV\n    this->uav_basic_->uavCmdPub.publish(uav_cmd);\n  }\n}", "CodeBleu_score": 52.60242174199911}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t// If not in simulation mode, publish to the single UAV.\n  if (!this->simulation_mode_) {\n    this->uav_basic_->uavCmdPub.publish(uav_cmd);\n  }\n  // If in simulation mode, find the corresponding UAV by ID and publish to it.\n  else {\n    // Check if the UAV exists.\n    if (this->swarm_control_simulation_.find(uav_cmd.uav_id) == this->swarm_control_simulation_.end()) {\n      ROS_WARN_STREAM(\"UAV ID \" << uav_cmd.uav_id << \" does not exist.\");\n      return;\n    }\n    this->swarm_control_simulation_[uav_cmd.uav_id]->uavCmdPub.publish(uav_cmd);\n  }\n}", "CodeBleu_score": 34.8483741869421}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tswitch (mode_selection.mode) {\n\t\tcase REBOOTNX:\n\t\t\tsystem(\"reboot\");\n\t\t\tbreak;\n\t\tcase EXITNX:\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase CREATEMODE:\n\t\t\tcreateMode(mode_selection.use_mode);\n\t\t\tbreak;\n\t\tcase DELETEMODE:\n\t\t\tdeleteMode(mode_selection.use_mode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 24.37895288887645}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tswitch (mode_selection.mode) {\n\t\tcase REBOOTNX:\n\t\t\tsystem(\"reboot\");\n\t\t\tbreak;\n\t\tcase EXITNX:\n\t\t\tsystem(\"exit\");\n\t\t\tbreak;\n\t\tcase CREATEMODE:\n\t\t\tcreateMode(mode_selection.use_mode);\n\t\t\tbreak;\n\t\tcase DELETEMODE:\n\t\t\tdeleteMode(mode_selection.use_mode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 30.285737886653475}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tswitch (mode_selection.mode) {\n        case REBOOTNX:\n            system(\"reboot\");\n            break;\n        case EXITNX:\n            system(\"exit\");\n            break;\n        case createMode:\n            createMode(mode_selection.use_mode);\n            break;\n        case deleteMode:\n            deleteMode(mode_selection.use_mode);\n            break;\n        default:\n            cout << \"Invalid mode selection.\" << endl;\n            break;\n    }\n}", "CodeBleu_score": 36.38647787156672}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// if the heartbeat count is unchanged for a specified number of attempts, it prints an error message and triggers appropriate actions based on the type of vehicle (swarm, UAV, or UGV)\n  if (heartbeat_count == prev_heartbeat_count) {\n    ROS_ERROR(\"Heartbeat count unchanged for %d attempts. Disconnecting...\", MAX_HEARTBEAT_ATTEMPTS);\n    if (swarm_flag) {\n      triggerSwarmControl();\n    } else if (uav_flag) {\n      triggerUAV();\n    } else if (ugv_flag) {\n      triggerUGV();\n    }\n  }\n  prev_heartbeat_count = heartbeat_count;\n}", "CodeBleu_score": 23.99153104463747}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// Check heartbeat state\n    if (heartbeat_count == 0) {\n        // If the heartbeat count is 0, then the heartbeat has not been received yet.\n        // Do nothing.\n    }\n    else if (heartbeat_count == 1) {\n        // If the heartbeat count is 1, then the heartbeat has been received once.\n        // Increment the heartbeat count.\n        heartbeat_count++;\n    }\n    else if (heartbeat_count > 1) {\n        // If the heartbeat count is greater than 1, then the heartbeat has been received multiple times.\n        // Check if the heartbeat count has changed.\n        if (heartbeat_count == heartbeat_count_previous) {\n            // If the heartbeat count has not changed, then the heartbeat has not been received in a while.\n            // Print an error message.\n            ROS_ERROR(\"[CommunicationBridge::checkHeartbeatState] Heartbeat not received.\");\n\n            // Trigger appropriate actions based on the type of vehicle.\n            if (swarm_flag) {\n                // If the vehicle is a swarm, then trigger the swarm control.\n                triggerSwarmControl();\n            }\n            else if (uav_flag) {\n                // If the vehicle is a UAV, then trigger the UAV.\n                triggerUAV();\n            }\n            else if (ugv_flag) {\n                // If the vehicle is a UGV, then trigger the UGV.\n                triggerUGV();\n            }\n        }\n        else {\n            // If the heartbeat count has changed, then the heartbeat has been received.\n            // Reset the heartbeat count.\n            heartbeat_count = 1;\n            heartbeat_count_previous = heartbeat_count;\n        }\n    }\n}", "CodeBleu_score": 38.344503134371244}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// if the heartbeat count is the same as it was last time, increment the counter\n\tif (heartbeat_count == last_heartbeat_count) {\n\t\theartbeat_count_missed++;\n\t}\n\t// if the heartbeat count has changed, reset the counter\n\telse {\n\t\theartbeat_count_missed = 0;\n\t\tlast_heartbeat_count = heartbeat_count;\n\t}\n\n\t// if the heartbeat count has not changed for a specified number of attempts, print an error message\n\tif (heartbeat_count_missed >= HEARTBEAT_MISS_THRESHOLD) {\n\t\tROS_ERROR(\"Heartbeat lost\");\n\t\tswitch (vehicle_type) {\n\t\tcase SWARM_CONTROL:\n\t\t\ttriggerSwarmControl();\n\t\t\tbreak;\n\t\tcase UAV:\n\t\t\ttriggerUAV();\n\t\t\tbreak;\n\t\tcase UGV:\n\t\t\ttriggerUGV();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tROS_ERROR(\"Unknown vehicle type\");\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 30.859205399962736}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// cout << \"multitrajSubTcpCb\" << endl;\n\n    // 1. \u68c0\u67e5\u662f\u5426\u6709\u591a\u4e2a\u8f68\u8ff9\n    if(msg->traj.size() == 0)\n    {\n        cout << \"No trajectory received!\" << endl;\n        return;\n    }\n\n    // 2. \u68c0\u67e5\u662f\u5426\u6709\u591a\u4e2a\u8f68\u8ff9\n    if(msg->traj.size() > this->n_drones)\n    {\n        cout << \"Too many trajectories received!\" << endl;\n        return;\n    }\n\n    // 3. \u68c0\u67e5\u8f68\u8ff9\u662f\u5426\u6709\u6548\n    for(int i = 0; i < msg->traj.size(); i++)\n    {\n        if(msg->traj[i].knots.size() == 0)\n        {\n            cout << \"Trajectory \" << i << \" is invalid!\" << endl;\n            return;\n        }\n\n        if(msg->traj[i].pos_pts.size() == 0)\n        {\n            cout << \"Trajectory \" << i << \" is invalid!\" << endl;\n            return;\n        }\n\n        if(msg->traj[i].yaw_pts.size() == 0)\n        {\n            cout << \"Trajectory \" << i << \" is invalid!\" << endl;\n            return;\n        }\n    }\n\n    // 4. \u521d\u59cb\u5316Bspline\n    for(int i = 0; i < msg->traj.size(); i++)\n    {\n        Bspline bspline;\n\n        // 4.1 \u8bbe\u7f6eBspline\u5c5e\u6027\n        bspline.n_dims = 2;\n        bspline.n_knots = msg->traj[i].knots.size();\n        bspline.n_pts = msg->traj[i].pos_pts.size();\n        bspline.degree = 3;\n\n        // 4.2 \u8bbe\u7f6eBspline\u7684knots\n        for(int j = 0", "CodeBleu_score": 44.25379033345834}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// cout << \"multitrajSubTcpCb\" << endl;\n    // cout << \"msg->traj.size: \" << msg->traj.size() << endl;\n    // cout << \"msg->traj[0].knots.size: \" << msg->traj[0].knots.size() << endl;\n    // cout << \"msg->traj[0].pos_pts.size: \" << msg->traj[0].pos_pts.size() << endl;\n    // cout << \"msg->traj[0].yaw_pts.size: \" << msg->traj[0].yaw_pts.size() << endl;\n    // cout << \"msg->traj[0].start_time.toSec: \" << msg->traj[0].start_time.toSec() << endl;\n    // cout << \"msg->traj[0].end_time.toSec: \" << msg->traj[0].end_time.toSec() << endl;\n    // cout << \"msg->traj[0].duration: \" << msg->traj[0].duration << endl;\n    // cout << \"msg->traj[0].yaw_pts.size: \" << msg->traj[0].yaw_pts.size() << endl;\n\n    // cout << \"msg->traj[1].knots.size: \" << msg->traj[1].knots.size() << endl;\n    // cout << \"msg->traj[1].pos_pts.size: \" << msg->traj[1].pos_pts.size() << endl;\n    // cout << \"msg->traj[1].yaw_pts.size: \" << msg->traj[1].yaw_pts.size() << endl;\n    // cout << \"msg->traj[1].start_time.toSec: \" << msg->traj[1].start_time.toSec() << endl;\n    // cout << \"msg->traj[1].end_time.toSec: \" << msg->traj[1].end_time.toSec() << endl;\n    // cout << \"msg->traj[1].duration: \" << msg->tra", "CodeBleu_score": 1.2533532797780256}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tstd::cout << \"Receive multi bsplines message\" << std::endl;\n    std::cout << \"The number of trajectories: \" << msg->traj.size() << std::endl;\n\n    for (int i = 0; i < msg->traj.size(); i++)\n    {\n        std::cout << \"The drone ID: \" << msg->traj[i].drone_id << std::endl;\n        std::cout << \"The number of knots: \" << msg->traj[i].knots.size() << std::endl;\n        std::cout << \"The number of position points: \" << msg->traj[i].pos_pts.size() << std::endl;\n        std::cout << \"The number of yaw points: \" << msg->traj[i].yaw_pts.size() << std::endl;\n        std::cout << \"The start time: \" << msg->traj[i].start_time.toSec() << std::endl;\n        std::cout << \"The end time: \" << msg->traj[i].end_time.toSec() << std::endl;\n\n        Bspline bspline;\n        bspline.drone_id = msg->traj[i].drone_id;\n        bspline.knots = msg->traj[i].knots;\n        bspline.pos_pts = msg->traj[i].pos_pts;\n        bspline.yaw_pts = msg->traj[i].yaw_pts;\n        bspline.start_time = msg->traj[i].start_time;\n        bspline.end_time = msg->traj[i].end_time;\n\n        this->communication->sendMsgByTcp(this->communication->encodeMsg(bspline));\n    }\n}", "CodeBleu_score": 53.30428529154319}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// create a pcl::PointCloud from the input msg\n  pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // create a compressed data vector\n  std::vector<uint8_t> compressed_data;\n\n  // create an octree compression object\n  octree_compression octree_compression;\n\n  // compress the point cloud\n  octree_compression.setInputCloud(cloud);\n  octree_compression.encodePointCloud(compressed_data);\n\n  // create a new PointCloud2 message with the compressed data\n  sensor_msgs::PointCloud2 compressed_msg;\n  pcl::toROSMsg(*cloud, compressed_msg);\n  compressed_msg.data = compressed_data;\n\n  // return the compressed msg\n  return compressed_msg;\n}", "CodeBleu_score": 30.588601395159476}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Declare variables\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  sensor_msgs::PointCloud2 compressed_data;\n  std::vector<uint8_t> compressed_str;\n  std::stringstream ss;\n  // Convert the input message to a pcl::PointCloud\n  pcl::fromROSMsg(msg, *cloud_ptr);\n  // Compress the point cloud\n  octree_compression.setInputCloud(cloud_ptr);\n  octree_compression.encodePointCloud(cloud);\n  // Store the compressed data\n  compressed_str.resize(octree_compression.getCompressedDataSize());\n  octree_compression.getCompressedData(compressed_str.data());\n  // Create a new PointCloud2 message with the compressed data\n  compressed_data.header = msg.header;\n  compressed_data.height = msg.height;\n  compressed_data.width = msg.width;\n  compressed_data.fields = msg.fields;\n  compressed_data.is_bigendian = msg.is_bigendian;\n  compressed_data.point_step = msg.point_step;\n  compressed_data.row_step = msg.row_step;\n  compressed_data.is_dense = msg.is_dense;\n  compressed_data.data.resize(compressed_str.size());\n  // Copy the compressed data to the new message\n  std::memcpy(compressed_data.data.data(), compressed_str.data(), compressed_str.size());\n  // Return the new message\n  return compressed_data;\n}", "CodeBleu_score": 45.28176150777517}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the input message to a pcl::PointCloud.\n  pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Compress the point cloud.\n  std::vector<uint8_t> compressed_data;\n  octree_compression.setInputCloud(cloud);\n  octree_compression.encodePointCloud(compressed_data);\n\n  // Create a new PointCloud2 message with the compressed data.\n  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = msg.height;\n  compressed_msg.width = msg.width;\n  compressed_msg.fields = msg.fields;\n  compressed_msg.is_bigendian = msg.is_bigendian;\n  compressed_msg.point_step = msg.point_step;\n  compressed_msg.row_step = msg.row_step;\n  compressed_msg.is_dense = msg.is_dense;\n  compressed_msg.data.resize(compressed_data.size());\n  std::memcpy(compressed_msg.data.data(), compressed_data.data(), compressed_data.size());\n\n  // Return the new PointCloud2 message.\n  return compressed_msg;\n}", "CodeBleu_score": 38.56112914291244}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor(int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n    if(this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n      this->multi_uav_state_.uav_state_all[i] = uav_state;\n    }\n  }\n\n}", "CodeBleu_score": 74.97304431599744}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n    if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n      this->multi_uav_state_.uav_state_all[i] = uav_state;\n    }\n  }\n}", "CodeBleu_score": 84.28479326094607}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n    if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n      this->multi_uav_state_.uav_state_all[i] = uav_state;\n      break;\n    }\n  }\n\n  return;\n}", "CodeBleu_score": 91.43785142263704}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize MultiUGVState message\n    swarm_control_msgs::MultiUGVState multi_ugv_state;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n        // Populate UGVState message with ID, battery, position, velocity, and attitude data\n        swarm_control_msgs::UGVState ugv_state;\n        ugv_state.ugv_id = m_multi_ugv_state.ugv_state_all[i].ugv_id;\n        ugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n        ugv_state.position = m_multi_ugv_state.ugv_state_all[i].position;\n        ugv_state.velocity = m_multi_ugv_state.ugv_state_all[i].velocity;\n        ugv_state.attitude = m_multi_ugv_state.ugv_state_all[i].attitude;\n\n        // Increment UGV count and add each UGVState to the MultiUGVState message\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n        multi_ugv_state.ugv_count++;\n    }\n\n    // Publish assembled MultiUGVState message\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.803343974685745}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize the MultiUGVState message\n  swarm_control_msgs::MultiUGVState multi_ugv_state;\n\n  // Iterate through each UGV state in the provided MultiUGVState structure\n  for (std::vector<struct UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n    // Initialize the UGVState message\n    swarm_control_msgs::UGVState ugv_state;\n\n    // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n    ugv_state.id = it->id;\n    ugv_state.battery = it->battery;\n    ugv_state.position.x = it->position.x;\n    ugv_state.position.y = it->position.y;\n    ugv_state.position.z = it->position.z;\n    ugv_state.velocity.x = it->velocity.x;\n    ugv_state.velocity.y = it->velocity.y;\n    ugv_state.velocity.z = it->velocity.z;\n    ugv_state.attitude.x = it->attitude.x;\n    ugv_state.attitude.y = it->attitude.y;\n    ugv_state.attitude.z = it->attitude.z;\n    ugv_state.attitude.w = it->attitude.w;\n\n    // Increment the UGV count and add each UGVState to the MultiUGVState message\n    multi_ugv_state.ugv_state_count++;\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n\n  // Publish the assembled MultiUGVState message\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 48.76154392786426}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\tm_multi_ugv_state.ugv_state_all.clear();\n  for (int i = 0; i < m_ugv_count; i++) {\n    m_multi_ugv_state.ugv_state_all.push_back(m_ugv_state[i]);\n  }\n  this->all_ugv_state_pub_.publish(m_multi_ugv_state);\n}", "CodeBleu_score": 17.066969057649178}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tif (moving_objs_ == NULL)\n        return;\n\n    // initialize cost and gradient\n    cost = 0;\n    gradient.setZero();\n\n    // initialize predicted positions of moving objects\n    Eigen::MatrixXd obj_prid(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted velocities of moving objects\n    Eigen::MatrixXd obj_vel(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted accelerations of moving objects\n    Eigen::MatrixXd obj_acc(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted jerk of moving objects\n    Eigen::MatrixXd obj_jer(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted slacks of moving objects\n    Eigen::MatrixXd obj_slack(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted jerk slacks of moving objects\n    Eigen::MatrixXd obj_jer_slack(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted jerk slacks of moving objects\n    Eigen::MatrixXd obj_jer_slack_d(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted jerk slacks of moving objects\n    Eigen::MatrixXd obj_jer_slack_dd(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted jerk slacks of moving objects\n    Eigen::MatrixXd obj_jer_slack_ddd(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted jerk slacks of moving objects\n    Eigen::MatrixXd obj_jer_slack_dddd(moving_objs_->getObjNums(), 3);\n\n    // initialize predicted jerk slacks of moving objects\n    Eigen::MatrixXd obj_jer_slack_ddddd(moving_objs_->getObjNums(), 3);", "CodeBleu_score": 17.447672869978014}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// Initialization\n  cost = 0.0;\n  gradient.setZero();\n  Eigen::MatrixXd obj_prid(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_vel(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_acc(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_jerk(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_snap(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_cubic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_quartic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_quintic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_sextic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_septic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_octic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_nonic(moving_objs_->getObjNums(), 3);\n\n  Eigen::MatrixXd obj_prid_vel_cubic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_acc_quartic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_jerk_quintic(moving_objs_->getObjNums(), 3);\n  Eigen::MatrixXd obj_prid_snap_se", "CodeBleu_score": 15.644360596808154}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tint obj_nums = moving_objs_->getObjNums();\n  if (obj_nums == 0) {\n    cost = 0.0;\n    gradient.setZero();\n    return;\n  }\n  // compute the predicted positions of moving objects\n  Eigen::MatrixXd obj_prid(3, obj_nums);\n  for (int i = 0; i < obj_nums; i++) {\n    obj_prid.col(i) = moving_objs_->evaluateConstVel(q.cols(moving_objs_->getObjIdx(i)));\n  }\n  // compute the distance error between control points and objects\n  double d_err = 0.0;\n  for (int i = 0; i < cps_.points.cols(); i++) {\n    for (int j = 0; j < obj_nums; j++) {\n      d_err += pow((cps_.points.col(i) - obj_prid.col(j)).norm(), 2.0);\n    }\n  }\n  d_err = d_err / (cps_.points.cols() * obj_nums);\n  // update the cost and gradient\n  cost = d_err;\n  gradient.setZero();\n  for (int i = 0; i < cps_.points.cols(); i++) {\n    for (int j = 0; j < obj_nums; j++) {\n      gradient.col(i) += 2.0 * (cps_.points.col(i) - obj_prid.col(j)).normalized() / obj_nums;\n    }\n  }\n  gradient *= d_err;\n}", "CodeBleu_score": 43.03688976615979}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tgradient.setZero();\n  cost = 0.0;\n  for (int i = 2; i < q.cols() - 1; i++) {\n    Eigen::Vector3d x = q.col(i);\n    Eigen::Vector3d xcrossv = (ref_pts_[i] - ref_pts_[i - 2]).cross(ref_pts_[i] - ref_pts_[i - 1]);\n    Eigen::Vector3d qcrossv = (q.col(i) - q.col(i - 2)).cross(q.col(i) - q.col(i - 1));\n    double a2 = 1.0;\n    double b2 = 1.0;\n    double xdotv = x.dot(xcrossv);\n    double qdotv = q.col(i).dot(qcrossv);\n    cost += a2 * xdotv * xdotv + b2 * qdotv * qdotv;\n    gradient.col(i) += 2.0 * a2 * xdotv * xcrossv + 2.0 * b2 * qdotv * qcrossv;\n  }\n}", "CodeBleu_score": 43.23482650103775}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// Initialize cost to zero\n    cost = 0;\n    // Iterate through control points\n    for (int i = 1; i < q.cols() - 1; i++) {\n        // Compute positional error and velocity vector\n        Eigen::Vector3d error = (q.col(i) - ref_pts_[i]);\n        Eigen::Vector3d v = (q.col(i + 1) - q.col(i - 1)) / 2;\n        // Compute cost and gradient\n        cost += a2 * error.dot(error) + b2 * v.dot(v);\n        gradient.col(i) += 2 * a2 * error + 2 * b2 * v;\n    }\n}", "CodeBleu_score": 24.670610953674473}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n  gradient.setZero();\n  Eigen::MatrixXd q_dot(n_pts_, 3);\n  Eigen::MatrixXd q_cross(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm(n_pts_, 3);\n  Eigen::MatrixXd q_dot_norm(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot_cross(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot_cross_norm(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot_cross_norm_dot(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot_cross_norm_dot_cross(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot_cross_norm_dot_cross_norm(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot_cross_norm_dot_cross_norm_dot(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot_cross_norm_dot_cross_norm_dot_cross(n_pts_, 3);\n  Eigen::MatrixXd q_cross_norm_dot_cross_norm_dot_cross_norm_dot_cross_norm_dot_cross_norm(n_pts_, 3);\n  Eigen::MatrixXd q_cross", "CodeBleu_score": 13.326776491554837}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative();\n  jerk_traj = jerk_traj.getDerivative();\n\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoints();\n  Eigen::VectorXd times = jerk_traj.getKnot();\n\n  double jerk = 0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += (ctrl_pts(j, i) * (times(i + 1) - times(i)));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 66.08673282817021}, {"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative().getDerivative();\n  double jerk = 0;\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoints();\n  Eigen::VectorXd times = jerk_traj.getKnot();\n\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += (ctrl_pts(j, i) * (times(i + 1) - times(i)) * (times(i + 1) - times(i)) * (times(i + 1) - times(i)));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 69.02388516680509}, {"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative().getDerivative();\n  double jerk = 0.0;\n  double time = 0.0;\n  for (int i = 0; i < jerk_traj.getControlPoints().rows(); ++i) {\n    for (int j = 0; j < jerk_traj.getControlPoints().cols(); ++j) {\n      jerk += pow(jerk_traj.getControlPoints()(i, j), 3) * (jerk_traj.getKnot(i) - time);\n      time = jerk_traj.getKnot(i);\n    }\n  }\n  return jerk;\n}", "CodeBleu_score": 53.04046216017467}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 61.97407747520547}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t// Calculate the 4D position vector in the camera frame\n    Eigen::Vector4d pos_in_camera;\n    pos_in_camera << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1;\n\n    // Return the 4D position vector\n    return pos_in_camera;\n}", "CodeBleu_score": 43.81958164655138}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t// Calculate the 4D position vector in the camera frame\n    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n\n    // Return the 4D position vector\n    return pos;\n\n}", "CodeBleu_score": 63.44052173383843}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t// Get the drone ID from the child frame ID\n\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(1));\n\n\t\t// Call the base function\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t}\n\tcatch (std::exception& e) {\n\t\tROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n\t}\n}", "CodeBleu_score": 49.55317496923005}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        int droneID = std::stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, droneID);\n    }\n    catch (std::exception& e) {\n        std::cout << \"Exception caught in DroneDetector::rcvDroneXOdomCallback: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 55.22290953447141}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t// Extract the drone ID from the child_frame_id field of the odometry message\n    try {\n        int drone_id = std::stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    }\n    catch (const std::exception& e) {\n        std::cout << \"DroneDetector::rcvDroneXOdomCallback: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 62.1393551445368}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Declare variables\n  int x_min, x_max, y_min, y_max;\n  double true_x, true_y;\n  double true_pose_err_x, true_pose_err_y;\n  double pose_err_x, pose_err_y;\n  double true_pose_err_x_avg, true_pose_err_y_avg;\n  double pose_err_x_avg, pose_err_y_avg;\n  double true_pose_err_x_std, true_pose_err_y_std;\n  double pose_err_x_std, pose_err_y_std;\n  double true_pose_err_x_max, true_pose_err_y_max;\n  double pose_err_x_max, pose_err_y_max;\n  double true_pose_err_x_min, true_pose_err_y_min;\n  double pose_err_x_min, pose_err_y_min;\n  double true_pose_err_x_sum, true_pose_err_y_sum;\n  double pose_err_x_sum, pose_err_y_sum;\n  double true_pose_err_x_count, true_pose_err_y_count;\n  double pose_err_x_count, pose_err_y_count;\n  double true_pose_err_x_max_count, true_pose_err_y_max_count;\n  double pose_err_x_max_count, pose_err_y_max_count;\n  double true_pose_err_x_min_count, true_pose_err_y_min_count;\n  double pose_err_x_min_count, pose_err_y_min_count;\n  double true_pose_err_x_sum_count, true_pose_err_y_sum_count;\n  double pose_err_x_sum_count, pose_err_y_sum_count;\n  double true_pose_err_x_max_sum, true_pose_err_y_max_sum;\n  double pose_err_x_max", "CodeBleu_score": 9.381058341538703}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// TODO: Check if the drone is in the image\n  // If not, update the debug result and return\n  // If yes, compute the pose error and update the debug result\n  // Publish the pose error\n  // TODO: Check if the drone is in the image\n  // If not, update the debug result and return\n  // If yes, compute the pose error and update the debug result\n  // Publish the pose error\n\n\n  // TODO: Check if the drone is in the image\n  // If not, update the debug result and return\n  // If yes, compute the pose error and update the debug result\n  // Publish the pose error", "CodeBleu_score": 3.116160337984265}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Check if the drone is in the image\n  if (true_pixel.x() < 0 || true_pixel.x() >= image_width_ || true_pixel.y() < 0 || true_pixel.y() >= image_height_) {\n    // Drone is not in the image\n    // Update the debug result\n    drone_detect_debug_result_.drone_detect_debug_result[drone_id] = DroneDetectDebugResult::DroneDetectDebugResultType::DRONE_NOT_IN_IMAGE;\n    // Return\n    return;\n  }\n\n  // Get the true pose of the drone in the camera frame\n  Eigen::Vector3d true_pose_camera_frame = getTruePoseCameraFrame(drone_id, true_pixel);\n\n  // Check if the drone is in the world\n  if (true_pose_camera_frame.x() < 0 || true_pose_camera_frame.x() >= world_width_ || true_pose_camera_frame.y() < 0 || true_pose_camera_frame.y() >= world_height_) {\n    // Drone is not in the world\n    // Update the debug result\n    drone_detect_debug_result_.drone_detect_debug_result[drone_id] = DroneDetectDebugResult::DroneDetectDebugResultType::DRONE_NOT_IN_WORLD;\n    // Return\n    return;\n  }\n\n  // Get the true pose of the drone in the world frame\n  Eigen::Vector3d true_pose_world_frame = getTruePoseWorldFrame(true_pose_camera_frame);\n\n  // Get the pose error\n  Eigen::Vector3d pose_error = getPoseError(true_pose_world_frame);\n\n  // Publish the pose error\n  publishPoseError(drone_id, pose_error);\n\n  // Update the debug result\n  drone_detect_debug_result_.drone_detect_debug_result[drone_id] = DroneDetectDebugResult::DroneDetectDebugResultType::DRONE_DETECT", "CodeBleu_score": 33.949337484462866}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 88.14720026434847}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->getParent() != nullptr) {\n        current = current->getParent();\n        path.push_back(current);\n    }\n\n    reverse(path.begin(), path.end());\n\n    return path;\n}", "CodeBleu_score": 70.37417523590916}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getParent() != nullptr) {\n\t\tpath.push_back(current->getParent());\n\t\tcurrent = current->getParent();\n\t}\n\treturn path;\n}", "CodeBleu_score": 68.51460457172615}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tif (!Coord2Index(start_pt, start_idx))\n\t\treturn false;\n\tif (!Coord2Index(end_pt, end_pt))\n\t\treturn false;\n\tVector3d diff = (start_pt - end_pt).normalized();\n\twhile (CheckOccupancy(start_idx + diff)) {\n\t\tstart_idx += diff;\n\t}\n\tdiff = (end_pt - start_pt).normalized();\n\twhile (CheckOccupancy(end_idx + diff)) {\n\t\tend_idx += diff;\n\t}\n\treturn true;\n}", "CodeBleu_score": 38.97367246431188}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\t\n\tif (IsObstacle(start_idx) || IsObstacle(end_idx)) {\n\t\treturn false;\n\t}\n\t\n\tif (IsObstacle(start_idx - end_idx)) {\n\t\tstart_idx = start_idx - end_idx;\n\t\tstart_pt = Index2Coord(start_idx);\n\t\tstart_idx = Coord2Index(start_pt);\n\t}\n\t\n\tif (IsObstacle(end_idx - start_idx)) {\n\t\tend_idx = end_idx - start_idx;\n\t\tend_pt = Index2Coord(end_idx);\n\t\tend_idx = Coord2Index(end_pt);\n\t}\n\t\n\tif (IsObstacle(start_idx - end_idx)) {\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}", "CodeBleu_score": 37.86826997268156}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert the coordinates to indices.\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// If the start or end point is inside an obstacle, adjust it.\n\tif (IsInsideObstacle(start_idx)) {\n\t\tif (!AdjustStartPoint(start_pt, start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsInsideObstacle(end_idx)) {\n\t\tif (!AdjustEndPoint(end_pt, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 30.501397712918667}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// Check if the buffer is allocated\n    if (!occupancy_buffer_inflate_) {\n        ROS_ERROR(\"[GridMap] The buffer is not allocated. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_inflate_->isInitialized()) {\n        ROS_ERROR(\"[GridMap] The buffer is not initialized. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_inflate_->isInitialized()) {\n        ROS_ERROR(\"[GridMap] The buffer is not initialized. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_inflate_->isInitialized()) {\n        ROS_ERROR(\"[GridMap] The buffer is not initialized. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_inflate_->isInitialized()) {\n        ROS_ERROR(\"[GridMap] The buffer is not initialized. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_inflate_->isInitialized()) {\n        ROS_ERROR(\"[GridMap] The buffer is not initialized. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_inflate_->isInitialized()) {\n        ROS_ERROR(\"[GridMap] The buffer is not initialized. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_inflate_->isInitialized()) {\n        ROS_ERROR(\"[GridMap] The buffer is not initialized. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_inflate_->isInitialized()) {\n        ROS_ERROR(\"[GridMap] The buffer is not initialized. Call initializeBuffer() first.\");\n        return;\n    }\n\n    // Check", "CodeBleu_score": 16.44697566281906}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// Iterate over the grid coordinates and set the corresponding elements in the occupancy_buffer_inflate_ to zero.\n  for (int x = min_pos.x(); x <= max_pos.x(); ++x) {\n    for (int y = min_pos.y(); y <= max_pos.y(); ++y) {\n      for (int z = min_pos.z(); z <= max_pos.z(); ++z) {\n        // Set the occupancy value to zero.\n        occupancy_buffer_inflate_(x, y, z) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 55.01213876148192}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// Check if the buffer is allocated\n    if (!occupancy_buffer_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The occupancy buffer is not allocated.\");\n    }\n\n    // Check if the buffer is initialized\n    if (!occupancy_buffer_initialized_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The occupancy buffer is not initialized.\");\n    }\n\n    // Check if the buffer is inflated\n    if (!occupancy_buffer_inflate_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The occupancy buffer is not inflated.\");\n    }\n\n    // Check if the buffer is inflated\n    if (!distance_buffer_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The distance buffer is not allocated.\");\n    }\n\n    // Check if the buffer is initialized\n    if (!distance_buffer_initialized_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The distance buffer is not initialized.\");\n    }\n\n    // Check if the buffer is inflated\n    if (!distance_buffer_inflate_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The distance buffer is not inflated.\");\n    }\n\n    // Check if the buffer is initialized\n    if (!layer_buffer_initialized_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The layer buffer is not initialized.\");\n    }\n\n    // Check if the buffer is inflated\n    if (!layer_buffer_inflate_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The layer buffer is not inflated.\");\n    }\n\n    // Check if the buffer is initialized\n    if (!layer_buffer_initialized_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The layer buffer is not initialized.\");\n    }\n\n    // Check if the buffer is inflated\n    if (!layer_buffer_inflate_) {\n        throw std::runtime_error(\"[GridMap::resetBuffer] The layer buffer is not inflated.\");\n    }\n\n    // Check if the buffer is initialized\n    if (!layer_buffer_initialized_) {\n        throw std::runtime", "CodeBleu_score": 17.274270242012282}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d point_difference = pt - camera_pt;\n\n    double x_min = 0.0;\n    double x_max = 0.0;\n    double y_min = 0.0;\n    double y_max = 0.0;\n    double z_min = 0.0;\n    double z_max = 0.0;\n\n    // Check if the point is within the map boundaries\n    if (point_difference.x() > 0.0 && point_difference.y() > 0.0 && point_difference.z() > 0.0) {\n        return pt;\n    }\n\n    // Find the minimum and maximum translation coefficients along each axis\n    if (point_difference.x() < 0.0) {\n        x_min = (map_size_x_ - 1) / fabs(point_difference.x());\n        x_max = 0.0;\n    } else {\n        x_min = 0.0;\n        x_max = (map_size_x_ - 1) / point_difference.x();\n    }\n\n    if (point_difference.y() < 0.0) {\n        y_min = (map_size_y_ - 1) / fabs(point_difference.y());\n        y_max = 0.0;\n    } else {\n        y_min = 0.0;\n        y_max = (map_size_y_ - 1) / point_difference.y();\n    }\n\n    if (point_difference.z() < 0.0) {\n        z_min = (map_size_z_ - 1) / fabs(point_difference.z());\n        z_max = 0.0;\n    } else {\n        z_min = 0.0;\n        z_max = (map_size_z_ - 1) / point_difference.z();\n    }\n\n    // Find the minimum positive scaling factor that keeps the point within map boundaries\n    double scaling_factor = 0.0;\n    if (x_min", "CodeBleu_score": 34.22240740143291}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff_vec = pt - camera_pt;\n  double min_x = std::numeric_limits<double>::infinity();\n  double min_y = std::numeric_limits<double>::infinity();\n  double min_z = std::numeric_limits<double>::infinity();\n  double max_x = -std::numeric_limits<double>::infinity();\n  double max_y = -std::numeric_limits<double>::infinity();\n  double max_z = -std::numeric_limits<double>::infinity();\n\n  for (int i = 0; i < 3; i++) {\n    if (diff_vec[i] < 0) {\n      min_x = std::min(min_x, diff_vec[i]);\n    } else {\n      max_x = std::max(max_x, diff_vec[i]);\n    }\n  }\n\n  for (int i = 0; i < 3; i++) {\n    if (diff_vec[i] < 0) {\n      min_y = std::min(min_y, diff_vec[i]);\n    } else {\n      max_y = std::max(max_y, diff_vec[i]);\n    }\n  }\n\n  for (int i = 0; i < 3; i++) {\n    if (diff_vec[i] < 0) {\n      min_z = std::min(min_z, diff_vec[i]);\n    } else {\n      max_z = std::max(max_z, diff_vec[i]);\n    }\n  }\n\n  double min_scale_x = std::max(min_x / max_x, min_x / min_x);\n  double min_scale_y = std::max(min_y / max_y, min_y / min_y);\n  double min_scale_z = std::max(min_z / max_z, min_z / min_z);\n  double min_scale = std::min(min_scale_x, std::min(min_scale_y, min_scale_z));", "CodeBleu_score": 43.50642992521604}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff_vec = pt - camera_pt;\n\tEigen::Vector3d max_translation, min_translation;\n\tmax_translation << map_size_x_ - 1, map_size_y_ - 1, map_size_z_ - 1;\n\tmin_translation << 0, 0, 0;\n\tEigen::Vector3d scaled_diff_vec = diff_vec;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff_vec[i] > 0) {\n\t\t\tmin_translation[i] = diff_vec[i];\n\t\t}\n\t\telse {\n\t\t\tmax_translation[i] = diff_vec[i];\n\t\t}\n\t}\n\tdouble min_scale = 1.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (max_translation[i] != 0) {\n\t\t\tmin_scale = fmin(min_scale, max_translation[i] / min_translation[i]);\n\t\t}\n\t}\n\tscaled_diff_vec = min_scale * diff_vec;\n\tEigen::Vector3d closest_pt = camera_pt + scaled_diff_vec;\n\treturn closest_pt;\n}", "CodeBleu_score": 44.756619945869495}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // If an update is needed, project the depth image into points and process them with raycasting.\n  if (md_.update_occ_needed_) {\n    // Clear and inflate the local map.\n    clearAndInflateLocalMap();\n\n    // Project the depth image into points.\n    projectDepthImage();\n\n    // Process the points with raycasting.\n    raycastProcess();\n\n    // Reset the update flag.\n    md_.update_occ_needed_ = false;\n  }\n\n  // If an update is needed, project the depth image into points and process them with raycasting.\n  if (md_.update_occ_needed_) {\n    // Clear and inflate the local map.\n    clearAndInflateLocalMap();\n\n    // Project the depth image into points.\n    projectDepthImage();\n\n    // Process the points with raycasting.\n    raycastProcess();\n\n    // Reset the update flag.\n    md_.update_occ_needed_ = false;\n  }\n\n  // If an update is needed, project the depth image into points and process them with raycasting.\n  if (md_.update_occ_needed_) {\n    // Clear and inflate the local map.\n    clearAndInflateLocalMap();\n\n    // Project the depth image into points.\n    projectDepthImage();\n\n    // Process the points with raycasting.\n    raycastProcess();\n\n    // Reset the update flag.\n    md_.update_occ_needed_ = false;\n  }\n\n  // If an update is needed, project the depth image into points and process them with raycasting.\n  if (md_.update_occ_needed_) {\n    // Clear and inflate the local map.\n    clearAndInflateLocalMap();\n\n    // Project the depth image into points.\n    projectDepthImage();\n\n    // Process the points with raycasting.\n    raycastProcess();\n\n    // Reset the update flag.\n    md_.update_occ_needed_ = false;", "CodeBleu_score": 56.169837893779984}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if a local map update is needed.\n  if (md_.local_map_updated_) {\n    // Clear and inflate the local map.\n    clearAndInflateLocalMap();\n\n    // Reset the local map update flag.\n    md_.local_map_updated_ = false;\n  }\n\n  // Check if the odometry data is too old.\n  if (ros::Time::now() - md_.last_odom_update_time_ > ros::Duration(1.0)) {\n    ROS_ERROR_THROTTLE(1.0, \"Odometry data is too old.\");\n    md_.odom_timeout_ = true;\n  }\n\n  // Check if the depth data is too old.\n  if (ros::Time::now() - md_.last_depth_update_time_ > ros::Duration(1.0)) {\n    ROS_ERROR_THROTTLE(1.0, \"Depth data is too old.\");\n    md_.depth_timeout_ = true;\n  }\n\n  // Check if the odometry and depth data is available.\n  if (!md_.odom_timeout_ && !md_.depth_timeout_) {\n    // Project the depth image into points and process them with raycasting.\n    projectDepthImage();\n  }\n}", "CodeBleu_score": 57.54737332807447}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if an update is needed.\n  if (md_.last_occ_update_time_ - md_.last_occ_update_time_ < ros::Duration(1.0 / md_.map_update_rate_)) {\n    // No update needed.\n    return;\n  }\n\n  // Update the local map if necessary.\n  if (md_.local_map_updated_) {\n    clearAndInflateLocalMap();\n    md_.local_map_updated_ = false;\n  }\n\n  // Get the latest odometry.\n  nav_msgs::Odometry odom;\n  if (!getLatestOdometry(odom)) {\n    ROS_WARN(\"[GridMap] No odometry available.\");\n    md_.odom_timeout_ = true;\n    return;\n  }\n  md_.odom_timeout_ = false;\n\n  // Get the latest depth image.\n  sensor_msgs::Image depth_image;\n  if (!getLatestDepthImage(depth_image)) {\n    ROS_WARN(\"[GridMap] No depth image available.\");\n    md_.depth_timeout_ = true;\n    return;\n  }\n  md_.depth_timeout_ = false;\n\n  // Project the depth image into points.\n  std::vector<Eigen::Vector3d> points;\n  if (!projectDepthImage(odom, depth_image, points)) {\n    ROS_WARN(\"[GridMap] Projecting depth image failed.\");\n    return;\n  }\n\n  // Process the points with raycasting.\n  if (!raycastProcess(points)) {\n    ROS_WARN(\"[GridMap] Raycasting failed.\");\n    return;\n  }\n}", "CodeBleu_score": 57.88870746179335}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tvector<Ellipse> gt_ellipses;\n    vector<Ellipse> dt_ellipses;\n\n    float fmeasure = 0.f;\n    float fmeasure_accum = 0.f;\n\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        Mat3b img = imread(image_fns[i]);\n\n        float fm = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        fmeasure_accum += fm;\n        fmeasure = fmeasure_accum / (i + 1);\n    }\n\n    return fmeasure;\n}", "CodeBleu_score": 59.83892809570058}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tif (image_fns.size() != gt_fns.size() || image_fns.size() != dt_fns.size())\n    {\n        cout << \"ERROR: Image filenames, ground truth filenames, and detected ellipses filenames must be of the same size.\" << endl;\n        return 0.f;\n    }\n\n    vector<float> fms;\n    fms.reserve(image_fns.size());\n\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        Mat3b img = imread(image_fns[i]);\n        if (img.empty())\n        {\n            cout << \"ERROR: Failed to read image: \" << image_fns[i] << endl;\n            return 0.f;\n        }\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        fms.push_back(fmeasure);\n    }\n\n    float fmeasure_avg = 0.f;\n    for (unsigned i = 0; i < fms.size(); ++i)\n    {\n        fmeasure_avg += fms[i];\n    }\n    fmeasure_avg /= float(fms.size());\n\n    return fmeasure_avg;\n}", "CodeBleu_score": 50.95650443554677}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tvector<Ellipse> gt_ellipses;\n    vector<Ellipse> dt_ellipses;\n\n    float total_fmeasure = 0.f;\n\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        string img_fn = image_fns[i];\n        string gt_fn = gt_fns[i];\n        string dt_fn = dt_fns[i];\n\n        Mat3b img = imread(img_fn);\n\n        if (img.empty())\n        {\n            cout << \"Error reading: \" << img_fn << endl;\n            return -1.f;\n        }\n\n        _load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\n        total_fmeasure += fmeasure;\n    }\n\n    return total_fmeasure / float(image_fns.size());\n}", "CodeBleu_score": 52.90124756072444}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b;\n    if (foci) {\n        a = foci[0] - x;\n        b = foci[1] - y;\n        return angle_diff_signed(atan2(b, a), atan2(y, x));\n    }\n    else {\n        return atan2(y, x);\n    }\n}", "CodeBleu_score": 26.217672991582408}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b, c;\n    float f1x, f1y, f2x, f2y;\n    float a1, a2, a3, a4;\n    float result;\n    float angle_diff_signed;\n    if (foci == NULL) {\n        return 0.0;\n    }\n    f1x = foci[0];\n    f1y = foci[1];\n    f2x = foci[2];\n    f2y = foci[3];\n    a1 = x - f1x;\n    a2 = y - f1y;\n    a3 = x - f2x;\n    a4 = y - f2y;\n    a = sqrt(a1 * a1 + a2 * a2);\n    b = sqrt(a3 * a3 + a4 * a4);\n    c = sqrt(a1 * a1 + a2 * a2 + a3 * a3 + a4 * a4);\n    result = atan2(a1 * a3 + a2 * a4, c - a * b);\n    angle_diff_signed = angle_diff_signed(result, atan2(a3, a4));\n    if (angle_diff_signed > 0.0) {\n        return result;\n    }\n    return result + M_2__PI;\n}", "CodeBleu_score": 40.91502287570009}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    float angle_diff_signed(float a, float b);\n    float angle_diff_signed(float a, float b) {\n        a -= b;\n        while (a <= -M_PI) a += M_2__PI;\n        while (a >   M_PI) a -= M_2__PI;\n        return a;\n    }\n    if (foci == NULL) return 0;\n    a = foci[0];\n    b = foci[1];\n    c = x - a;\n    d = y - b;\n    e = c * c;\n    f = d * d;\n    g = e + f;\n    h = sqrt(g);\n    i = sqrt(g) * 2;\n    j = i - 2;\n    k = j / 2;\n    l = k * k;\n    m = l * l;\n    n = m * l;\n    o = n * l;\n    p = o * l;\n    q = p * l;\n    r = q * l;\n    s = r * l;\n    t = s * l;\n    u = t * l;\n    v = u * l;\n    w = v * l;\n    x = w * l;\n    y = x * l;\n    z = y * l;\n    return angle_diff_signed(atan2(d, c), atan2(y, x));\n}", "CodeBleu_score": 45.731729060635004}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tif (start > end) {\n\t\tint temp = start;\n\t\tstart = end;\n\t\tend = temp;\n\t}\n\tfloat min_x = vp1[start].x;\n\tfloat max_x = vp1[start].x;\n\tfloat min_y = vp1[start].y;\n\tfloat max_y = vp1[start].y;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\tfloat dx = max_x - min_x;\n\tfloat dy = max_y - min_y;\n\tfloat area = dx * dy;\n\tfloat integral_above = 0;\n\tfloat integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\tintegral_below += (vp1[i].x - max_x) * (vp1[i].y - max_y);\n\t}\n\tif (integral_above < integral_below) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.32794387649672}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint i;\n    double min_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_x = vp1[start].x;\n    double max_y = vp1[start].y;\n    double integral_above = 0;\n    double integral_below = 0;\n    for (i = start; i <= end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        }\n        if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n        integral_above += (vp1[i].x - min_x) * (vp1[i].y + max_y);\n        integral_below += (vp1[i].x - max_x) * (vp1[i].y + min_y);\n    }\n    if (integral_above < integral_below) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "CodeBleu_score": 36.70823852479041}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint min_x = vp1[start].x;\n\tint max_x = vp1[start].x;\n\tint min_y = vp1[start].y;\n\tint max_y = vp1[start].y;\n\tint sum_above = 0;\n\tint sum_below = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t\tsum_above += vp1[i].x * vp1[i + 1].y;\n\t\tsum_below += vp1[i].x * vp1[i - 1].y;\n\t}\n\tsum_above += vp1[end].x * vp1[start].y;\n\tsum_below += vp1[end].x * vp1[start].y;\n\tif (sum_above < sum_below) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 35.01524101819241}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].label == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_lost++;\n            num_regain = 0;\n        }\n    }\n\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    } else if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n\n    if (is_detected) {\n        ellipse_det.sight_angle = msg->detections[0].sight_angle;\n    } else {\n        ellipse_det.sight_angle = msg->detections[1].sight_angle;\n    }\n}", "CodeBleu_score": 65.64189104605151}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tint i;\n    for (i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].label == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_lost++;\n            num_regain = 0;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    ellipse_det.sight_angle = msg->detections[0].sight_angle;\n    ellipse_det.sight_distance = msg->detections[0].sight_distance;\n}", "CodeBleu_score": 64.80868637304069}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].label == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n    }\n\n    if (num_lost >= VISION_THRES) {\n        is_detected = false;\n    }\n\n    if (num_regain >= VISION_THRES) {\n        is_detected = true;\n    }\n\n    if (is_detected) {\n        ellipse_det.sight_angle = msg->detections[0].sight_angle;\n    } else {\n        ellipse_det.sight_angle = 0;\n    }\n}", "CodeBleu_score": 66.59370083804322}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t// Check if the position is safe\n\tif (occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n\n}", "CodeBleu_score": 46.30643455321148}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t// TODO: Check the safety of the current position\n    // If the position is safe, return true\n    // If the position is unsafe, return false\n    // If the position is unknown, return false\n    // If the position is invalid, return false\n\n    // Check if the current position is safe or not\n    if (occupy_map_ptr->check_safety(cur_pos, safe_distance) == true) {\n        // If the current position is safe, return true\n        return true;\n    } else {\n        // If the current position is unsafe, return false\n        return false;\n    }\n}", "CodeBleu_score": 44.91893225822101}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tbool safety_check_passed = true;\n  safety_check_passed = occupy_map_ptr_->check_safety(cur_pos, safe_distance);\n  return safety_check_passed;\n}", "CodeBleu_score": 60.3694273127312}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t//path_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node != start_node) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tpath_nodes_.push_back(start_node);\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 55.13679178544706}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t// Create a vector to store the nodes on the path\n    std::vector<NodePtr> path_nodes_;\n\n    // Start at the end node and follow the parent pointers to the start node\n    NodePtr current_node = end_node;\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->getParent();\n    }\n\n    // Reverse the order of path_nodes_ to present the path from start to end\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n\n    // Assign the path_nodes_ to the path_nodes_ member variable\n    path_nodes_ = path_nodes_;\n}", "CodeBleu_score": 60.24104496394425}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tstd::list<NodePtr>::iterator path_iter = path_nodes_.end();\n    path_iter--;\n    while (path_iter != path_nodes_.begin()) {\n        path_iter--;\n        if (path_iter == path_nodes_.end()) {\n            std::cout << \"ERROR: Path iterator went out of bounds in Astar::retrievePath\" << std::endl;\n            break;\n        }\n        if (path_iter->getParent() == NULL) {\n            std::cout << \"ERROR: Path iterator's parent is NULL in Astar::retrievePath\" << std::endl;\n            break;\n        }\n        path_nodes_.push_front(*path_iter);\n        path_iter = path_iter->getParent();\n    }\n    path_nodes_.push_front(*path_iter);\n    path_nodes_.reverse();\n}", "CodeBleu_score": 40.33304587002093}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\tif(id==0)\n    {\n        state_nei[id].x = odom->pose.pose.position.x;\n        state_nei[id].y = odom->pose.pose.position.y;\n        state_nei[id].z = odom->pose.pose.position.z;\n        state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n        state_nei[id].norm = (start_pos-state_nei[id]).norm;\n        if(sim_mode)\n        {\n            if(state_nei[id].norm>5)\n            {\n                get_nei_state[id] = false;\n            }\n            else\n            {\n                get_nei_state[id] = true;\n            }\n        }\n        else\n        {\n            get_nei_state[id] = true;\n        }\n    }\n    else\n    {\n        state_nei[id].x = odom->pose.pose.position.x;\n        state_nei[id].y = odom->pose.pose.position.y;\n        state_nei[id].z = odom->pose.pose.position.z;\n        state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n        state_nei[id].norm = (start_pos-state_nei[id]).norm;\n        if(sim_mode)\n        {\n            if(state_nei[id].norm>5)\n            {\n                get_nei_state[id] = false;\n            }\n            else\n            {\n                get_nei_state[id] = true;\n            }\n        }\n        else\n        {\n            get_nei_state[id] = true;\n        }\n    }\n}", "CodeBleu_score": 55.29497507159464}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t// Get the odometry data\n    double x = odom->pose.pose.position.x;\n    double y = odom->pose.pose.position.y;\n    double z = odom->pose.pose.position.z;\n    double qx = odom->pose.pose.orientation.x;\n    double qy = odom->pose.pose.orientation.y;\n    double qz = odom->pose.pose.orientation.z;\n    double qw = odom->pose.pose.orientation.w;\n\n    // Convert the quaternion to Euler angles\n    tf::Quaternion q(qx, qy, qz, qw);\n    tf::Matrix3x3 m(q);\n    double roll, pitch, yaw;\n    m.getRPY(roll, pitch, yaw);\n\n    // Update the state of the UGV\n    state_nei[id].x = x;\n    state_nei[id].y = y;\n    state_nei[id].z = z;\n    state_nei[id].roll = roll;\n    state_nei[id].pitch = pitch;\n    state_nei[id].yaw = yaw;\n\n    // Check if the UGV is within the specified radius of the start position\n    if (simulation_mode) {\n        if (get_nei_state) {\n            if (((start_pos-state_nei[id]).norm) > 5.0) {\n                get_nei_state = false;\n            }\n        }\n    }\n\n}", "CodeBleu_score": 42.089558782855676}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\tif (simulation_mode) {\n\t\tif ((start_pos-state_nei[id]).norm()>5) {\n\t\t\tget_nei_state[id]=false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id]=true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id]=true;\n\t}\n\n\tstate_nei[id](0)=odom->pose.pose.position.x;\n\tstate_nei[id](1)=odom->pose.pose.position.y;\n\tstate_nei[id](2)=odom->pose.pose.position.z;\n\n\tnei_state_time[id]=ros::Time::now().toSec();\n\n\t//ROS_INFO(\"nei_odom_cb: id %d, state_nei[id] (%f, %f, %f)\", id, state_nei[id](0), state_nei[id](1), state_nei[id](2));\n\n}", "CodeBleu_score": 42.28277740651235}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (!odom_ready)\n\t\treturn;\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter % 5 == 0) {\n\t\tAstar_ptr->Occupy_map_ptr->update_map(msg);\n\t\tupdate_counter = 0;\n\t}\n}", "CodeBleu_score": 49.58410062613514}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"G", "CodeBleu_score": 5.371612400622668}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// Check if odometry is ready\n    if (!odom_ready) {\n        return;\n    }\n    // Update counter\n    ++update_counter;\n    // Update map\n    if (update_counter % 5 == 0) {\n        // Convert point cloud to a map\n        pcl::PointCloud<pcl::PointXYZI> cloud;\n        pcl::fromROSMsg(*msg, cloud);\n        // Update map\n        Astar_ptr->Occupy_map_ptr->update_map(cloud);\n        // Reset update counter\n        update_counter = 0;\n    }\n    // Set sensor ready flag\n    sensor_ready = true;\n}", "CodeBleu_score": 62.17444253047631}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\n        get_gpcl = true;\n        pcl::fromROSMsg(*global_point, *global_pcl);\n        inflate_point_cloud(global_pcl);\n    }\n}", "CodeBleu_score": 51.03673037991561}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\n        get_gpcl = true;\n        pcl::fromROSMsg(*global_point, global_cloud);\n        inflate_point_cloud();\n    }\n}", "CodeBleu_score": 42.34217353492441}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t// std::cout << \"map_update_gpcl\" << std::endl;\n  if (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_point_pcl);\n    // std::cout << \"pcl::fromROSMsg\" << std::endl;\n    inflate_point_cloud();\n  }\n}", "CodeBleu_score": 44.4068968621213}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// 1. Convert the laser scan data to a PointCloud2 format\n    sensor_msgs::PointCloud2 local_point_map;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered_downsampled;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered_downsampled_transformed;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered_downsampled_transformed_projected;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered_downsampled_transformed_projected_filtered;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered_downsampled_transformed_projected_filtered_clipped;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered_downsampled_transformed_projected_filtered_clipped_transformed;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered_downsampled_transformed_projected_filtered_clipped_transformed_filtered;\n    pcl::PointCloud<pcl::PointXYZ> local_point_map_pcl_filtered_downsampled_transformed_projected_filtered_clipped_transformed_filtered_clipped;\n\n    // 2. Convert the laser scan data to a pcl::PointCloud\n    // 2.1 Project the laser scan data into a PointCloud2 format\n    projector_.projectLaser(*local_point, local_point_map);\n    // 2.2 Convert the PointCloud2 format to a pcl::PointCloud\n    pcl::fromROSMsg(local_point_map, local_", "CodeBleu_score": 34.15366480132372}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// 1. Transform the laser scan into a PointCloud2 format\n    // 2. Convert the PointCloud2 format to a pcl::PointCloud\n    // 3. If not in simulation mode, merge the local map with the provided odometry data\n    // 4. Update the occupancy map\n\n    // 1. Transform the laser scan into a PointCloud2 format\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::PointCloud<pcl::PointXYZ> local_map;\n    pcl::PointCloud<pcl::PointXYZ> local_map_odom;\n    pcl::PointCloud<pcl::PointXYZ> local_map_odom_projected;\n    pcl::PointCloud<pcl::PointXYZ> local_map_projected;\n    pcl::PointCloud<pcl::PointXYZ> local_map_projected_transformed;\n\n    // 2. Convert the PointCloud2 format to a pcl::PointCloud\n    pcl::fromROSMsg(*local_point, cloud);\n\n    // 3. If not in simulation mode, merge the local map with the provided odometry data\n    if (simulation_mode == false) {\n        // 3.1. Get the local map\n        pcl::fromROSMsg(local_map_pub_.msg, local_map);\n        // 3.2. Get the odometry data\n        local_map_odom.header = odom.header;\n        local_map_odom.header.frame_id = \"map\";\n        local_map_odom.points.resize(local_map.points.size());\n        for (int i = 0; i < local_map.points.size(); i++) {\n            local_map_odom.points[i].x = local_map.points[i].x + odom.pose.pose.position.x;\n            local_map_odom.points[i].y = local_map.points[i].y + odom.pose.pose.position.y;\n            local_map_odom.points[i].z = local_map.points[i].z + od", "CodeBleu_score": 43.48985853623479}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// if(odom.header.frame_id != \"odom\"){\n\t// \tROS_ERROR(\"odom frame_id is not odom\");\n\t// \treturn;\n\t// }\n\t// if(local_point->header.frame_id != \"base_link\"){\n\t// \tROS_ERROR(\"local_point frame_id is not base_link\");\n\t// \treturn;\n\t// }\n\t// if(odom.header.frame_id != \"odom\"){\n\t// \tROS_ERROR(\"odom frame_id is not odom\");\n\t// \treturn;\n\t// }\n\t// if(local_point->header.frame_id != \"base_link\"){\n\t// \tROS_ERROR(\"local_point frame_id is not base_link\");\n\t// \treturn;\n\t// }\n\t// if(local_point->header.frame_id != \"base_link\"){\n\t// \tROS_ERROR(\"local_point frame_id is not base_link\");\n\t// \treturn;\n\t// }\n\t// if(local_point->header.frame_id != \"base_link\"){\n\t// \tROS_ERROR(\"local_point frame_id is not base_link\");\n\t// \treturn;\n\t// }\n\t// if(local_point->header.frame_id != \"base_link\"){\n\t// \tROS_ERROR(\"local_point frame_id is not base_link\");\n\t// \treturn;\n\t// }\n\t// if(local_point->header.frame_id != \"base_link\"){\n\t// \tROS_ERROR(\"local_point frame_id is not base_link\");\n\t// \treturn;\n\t// }\n\t// if(local_point->header.frame_id != \"base_link\"){\n\t// \tROS_ERROR(\"local_point frame_id is not base_link\");\n\t// \treturn;\n\t// }\n\t// if(local_point->header.frame_id != \"base_link\"){\n\t// \tROS_ERROR(\"local_point frame", "CodeBleu_score": 9.549016679375157}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t//ROS_INFO(\"Occupy_map::pub_pcl_cb\");\n\n  // Convert the global point cloud map to a ROS message and publish it.\n  pcl::PointCloud<pcl::PointXYZI> global_pcl_msg;\n  pcl::toROSMsg(global_pcl_map, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_msg.header.stamp = ros::Time::now();\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Convert the inflated point cloud map to a ROS message and publish it.\n  pcl::PointCloud<pcl::PointXYZI> inflate_pcl_msg;\n  pcl::toROSMsg(inflate_pcl_map, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_msg.header.stamp = ros::Time::now();\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n\n}", "CodeBleu_score": 52.03431442913183}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t//ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //ROS_INFO(\"pub_pcl_cb\");\n  //", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// 1. Convert the global point cloud map to a ROS message\n\tpcl::PointCloud<pcl::PointXYZI> global_pcl;\n\tpcl::PointCloud<pcl::PointXYZI> inflate_pcl;\n\n\tpcl::fromROSMsg(global_pcl_msg, global_pcl);\n\tpcl::fromROSMsg(inflate_pcl_msg, inflate_pcl);\n\n\t// 2. Publish the global point cloud map\n\tpcl::toROSMsg(global_pcl, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// 3. Publish the inflated point cloud map\n\tpcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 46.72011546650414}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (odometry_ready) {\n        sensor_ready = true;\n    }\n    if (sensor_ready) {\n        if (Astar_ptr->Occupy_map_ptr->map_update_lpcl) {\n            Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n        }\n    }\n}", "CodeBleu_score": 56.00582418250961}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (sensor_ready == false) {\n        sensor_ready = true;\n    }\n    // Convert the sensor_msgs::PointCloud2 message to pcl::PointCloud<pcl::PointXYZI>\n    pcl::PointCloud<pcl::PointXYZI>::Ptr point_cloud_ptr(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::fromROSMsg(*msg, *point_cloud_ptr);\n    // Update the map\n    Astar_ptr->Occupy_map_ptr->update_map(point_cloud_ptr);\n    // Update the map_update_lpcl\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl = point_cloud_ptr;\n    // Update the map_update_lodom\n    Astar_ptr->Occupy_map_ptr->map_update_lodom = odom;\n    // Update the map_update_ltime\n    Astar_ptr->Occupy_map_ptr->map_update_ltime = ros::Time::now();\n    // Update the map_update_lframe\n    Astar_ptr->Occupy_map_ptr->map_update_lframe = msg->header.frame_id;\n}", "CodeBleu_score": 46.414327643057845}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// Check if the sensor is ready\n\tif (sensor_ready) {\n\n\t\t// Update the map\n\t\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n\n\t\t// Update the A* algorithm's occupancy grid\n\t\tAstar_ptr->update_map();\n\n\t}\n\n}", "CodeBleu_score": 42.99227926025109}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n    ros::Time time = ros::Time::now();\n\n    // Get the current time in the phase generation\n    champ::PhaseGenerator::Time champ_time = rosTimeToChampTime(time);\n\n    // Get the current pose of the robot\n    Eigen::Vector3d position;\n    Eigen::Quaterniond orientation;\n    body_controller_.pose(position, orientation);\n\n    // Get the current velocity of the robot\n    Eigen::Vector3d linear_velocity;\n    Eigen::Vector3d angular_velocity;\n    body_controller_.velocity(linear_velocity, angular_velocity);\n\n    // Get the current joint positions\n    float joint_positions[12];\n    body_controller_.jointPositions(joint_positions);\n\n    // Get the current joint velocities\n    float joint_velocities[12];\n    body_controller_.jointVelocities(joint_velocities);\n\n    // Get the current foot contact information\n    bool foot_contacts[4];\n    body_controller_.footContacts(foot_contacts);\n\n    // Get the current stance phase\n    float stance_phase = body_controller_.stancePhase();\n\n    // Get the current swing phase\n    float swing_phase = body_controller_.swingPhase();\n\n    // Get the current swing foot\n    int swing_foot = body_controller_.swingFoot();\n\n    // Get the current swing leg\n    int swing_leg = body_controller_.swingLeg();\n\n    // Get the current swing foot\n    int stance_leg = body_controller_.stanceLeg();\n\n    // Get the current stance foot\n    int stance_foot = body_controller_.stanceFoot();\n\n    // Get the current swing foot\n    int swing_foot_index = body_controller_.swingFootIndex();\n\n    // Get the current swing leg\n    int swing_leg_index = body_controller_.swingLegIndex();\n\n    // Get the current stance leg\n    int stance_leg_index = body_controller_.stanceLegIndex();\n\n    // Get the current stance foot\n    int stance_foot_index", "CodeBleu_score": 42.53394319821123}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t//Get the current time in nanoseconds\n    ros::Time current_time = ros::Time::now();\n\n    //Get the current time in milliseconds\n    double current_time_ms = current_time.toSec() * 1000;\n\n    //Get the current time in seconds\n    double current_time_s = current_time.toSec();\n\n    //Get the current time in microseconds\n    double current_time_us = current_time.toSec() * 1000000;\n\n    //Get the current time in nanoseconds\n    int64_t current_time_ns = current_time.toNSec();\n\n    //Get the current time in seconds\n    double current_time_sec = current_time.toSec();\n\n    //Get the current time in milliseconds\n    double current_time_ms = current_time.toSec() * 1000;\n\n    //Get the current time in microseconds\n    double current_time_us = current_time.toSec() * 1000000;\n\n    //Get the current time in nanoseconds\n    int64_t current_time_ns = current_time.toNSec();\n\n    //Get the current time in seconds\n    double current_time_sec = current_time.toSec();\n\n    //Get the current time in milliseconds\n    double current_time_ms = current_time.toSec() * 1000;\n\n    //Get the current time in microseconds\n    double current_time_us = current_time.toSec() * 1000000;\n\n    //Get the current time in nanoseconds\n    int64_t current_time_ns = current_time.toNSec();\n\n    //Get the current time in seconds\n    double current_time_sec = current_time.toSec();\n\n    //Get the current time in milliseconds\n    double current_time_ms = current_time.toSec() * 1000;\n\n    //Get the current time in microseconds\n    double current_time_us = current_time.toSec() * 100", "CodeBleu_score": 37.594032818080315}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n  ros::Time time = ros::Time::now();\n\n  // Get the time from the last iteration of this loop\n  ros::Duration dt = time - last_loop_time_;\n\n  // Update the time\n  last_loop_time_ = time;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t = rosTimeToChampTime(time);\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time dt_t = rosTimeToChampTime(dt);\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt = t + dt_t;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt_dt = t + 2.0 * dt_t;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt_dt_dt = t + 3.0 * dt_t;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt_dt_dt_dt = t + 4.0 * dt_t;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt_dt_dt_dt_dt = t + 5.0 * dt_t;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt_dt_dt_dt_dt_dt = t + 6.0 * dt_t;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt_dt_dt_dt_dt_dt_dt = t + 7.0 * dt_t;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt_dt_dt_dt_dt_dt_dt_dt = t + 8.0 * dt_t;\n\n  // Get the current time in the phase generation\n  champ::PhaseGenerator::Time t_dt_dt_dt_dt_dt_dt_dt_dt_dt =", "CodeBleu_score": 32.711323521917826}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publishing_enabled_ && !in_gazebo_) {\n    // Create a ContactsStamped message.\n    contacts_msg_.header.stamp = ros::Time::now();\n\n    // Populate the message with the current gait phase of each leg.\n    for (int i = 0; i < 4; i++) {\n      contacts_msg_.contacts[i].name = base_.legs[i]->gait_phase;\n      contacts_msg_.contacts[i].state = foot_contacts[i];\n    }\n\n    // Publish the message.\n    foot_contacts_publisher_.publish(contacts_msg_);\n  }\n}", "CodeBleu_score": 58.26129354024596}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publishing_enabled_ && !is_in_gazebo_) {\n    contacts_msg_.contacts.resize(4);\n    for (size_t i = 0; i < 4; i++) {\n      contacts_msg_.contacts[i].name = base_.legs[i]->gait_phase;\n      contacts_msg_.contacts[i].state = foot_contacts[i];\n      contacts_msg_.header.stamp = ros::Time::now();\n    }\n    foot_contacts_publisher_.publish(contacts_msg_);\n  }\n}", "CodeBleu_score": 63.63817100097775}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publishing_enabled_ && !is_in_gazebo_) {\n    contacts_msg_.contacts.resize(4);\n    for (size_t i = 0; i < 4; ++i) {\n      contacts_msg_.contacts[i].name = base_.legs[i]->gait_phase;\n      contacts_msg_.contacts[i].state = foot_contacts[i] ? ContactState::CONTACT : ContactState::NO_CONTACT;\n    }\n    contacts_msg_.header.stamp = ros::Time::now();\n    foot_contacts_publisher_.publish(contacts_msg_);\n  }\n}", "CodeBleu_score": 59.86884458916941}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t# Get the first 12 joint positions from the joints message\n    joint_positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n    # Construct a joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.position = joint_positions\n    # Publish the joints message\n    self.pub_joints.publish(joints_msg)\n    # Construct a joint trajectory message with the same positions and a specified duration\n    joint_traj_msg = JointTrajectory()\n    joint_traj_msg.header.stamp = rospy.Time.now()\n    joint_traj_msg.header.frame_id = \"base_link\"\n    joint_traj_msg.points = []\n    # Add a point to the joint trajectory message\n    joint_traj_msg.points.append(JointTrajectoryPoint())\n    joint_traj_msg.points[0].positions = joint_positions\n    joint_traj_msg.points[0].time_from_start = rospy.Duration(0.0)\n    # Publish the joint trajectory message\n    self.pub_joint_traj.publish(joint_traj_msg)\n}", "CodeBleu_score": 39.84894783929423}, {"code": "def joints_cmd_callback(self, joints){\n\trospy.loginfo(\"Got joints command\")\n    joints_msg = Joints()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.header.frame_id = \"base_link\"\n    joints_msg.name = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    joints_msg.position = [joints.joint_1, joints.joint_2, joints.joint_3, joints.joint_4, joints.joint_5, joints.joint_6, joints.joint_7, joints.joint_8, joints.joint_9, joints.joint_10, joints.joint_11, joints.joint_12]\n    self.pub_joints.publish(joints_msg)\n\n    joint_traj_msg = JointTrajectory()\n    joint_traj_msg.header.stamp = rospy.Time.now()\n    joint_traj_msg.header.frame_id = \"base_link\"\n    joint_traj_msg.joint_names = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    joint_traj_msg.points.append(JointTrajectoryPoint())\n    joint_traj_msg.points[0].positions = [joints.joint_1, joints.joint_2, joints.joint_3, joints.joint_4, joints.joint_5, joints.joint_6, joints.joint_7, joints.joint_8, joints.joint_9, joints.joint_10, joints.joint_11, joints.joint_12]\n    joint_traj", "CodeBleu_score": 33.653580615684604}, {"code": "def joints_cmd_callback(self, joints){\n\t# Create a joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.header.frame_id = \"base_link\"\n    joints_msg.names = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    joints_msg.positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n    self.pub_joints.publish(joints_msg)\n\n    # Create a joint trajectory message with the same positions and a specified duration\n    joint_traj = JointTrajectory()\n    joint_traj.header.stamp = rospy.Time.now()\n    joint_traj.header.frame_id = \"base_link\"\n    joint_traj.joint_names = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    joint_traj.points = [JointTrajectoryPoint(positions=[joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]], time_from_start=rospy.Duration(2.", "CodeBleu_score": 31.86339608146419}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false.\n  left_contact = false;\n  right_contact = false;\n\n  // For each contact in the message, split the collision string to identify the contact link.\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true.\n    if (_msg->contact(i).collision2.find(left_foot_link) != std::string::npos) {\n      left_contact = true;\n    }\n    if (_msg->contact(i).collision2.find(right_foot_link) != std::string::npos) {\n      right_contact = true;\n    }\n  }\n}", "CodeBleu_score": 36.67175845219104}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contact[i] = false;\n  }\n\n  // For each contact in the message, split the collision string to identify the contact link\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::vector<std::string> collision_string =\n        split(_msg->contact(i).collision2, '/');\n\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (collision_string[collision_string.size() - 1] ==\n        foot_links[0]) {\n      foot_contact[0] = true;\n    } else if (collision_string[collision_string.size() - 1] ==\n               foot_links[1]) {\n      foot_contact[1] = true;\n    } else if (collision_string[collision_string.size() - 1] ==\n               foot_links[2]) {\n      foot_contact[2] = true;\n    } else if (collision_string[collision_string.size() - 1] ==\n               foot_links[3]) {\n      foot_contact[3] = true;\n    }\n  }\n}", "CodeBleu_score": 51.21518083357104}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contact[i] = false;\n  }\n\n  // For each contact in the message, split the collision string to identify the contact link\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string\n    std::vector<std::string> collision_string_split;\n    boost::split(collision_string_split, _msg->contact(i).collision2, boost::is_any_of(\"::\"));\n\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (collision_string_split[1] == \"l_sole_link\") {\n      foot_contact[LEFT] = true;\n    } else if (collision_string_split[1] == \"r_sole_link\") {\n      foot_contact[RIGHT] = true;\n    } else if (collision_string_split[1] == \"l_heel_link\") {\n      foot_contact[LEFT] = true;\n    } else if (collision_string_split[1] == \"r_heel_link\") {\n      foot_contact[RIGHT] = true;\n    }\n  }\n}", "CodeBleu_score": 55.35048369015891}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  Eigen::Vector3d angular_acceleration;\n\n  ComputeDesiredAcceleration(&acceleration);\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project acceleration and angular acceleration onto body z-axis.\n  Eigen::Vector3d z_hat(Eigen::Vector3d::UnitZ());\n  Eigen::Vector3d acceleration_body_z = z_hat.dot(acceleration) * z_hat;\n  Eigen::Vector3d angular_acceleration_body_z = z_hat.dot(angular_acceleration) * z_hat;\n\n  Eigen::Vector3d desired_acceleration_and_angular_acceleration_body_z = acceleration_body_z + angular_acceleration_body_z;\n\n  // Combine acceleration and angular acceleration into a single vector.\n  Eigen::VectorXd desired_acceleration_and_angular_acceleration(Eigen::VectorXd::Zero(kNumMotors));\n  desired_acceleration_and_angular_acceleration.head<3>() = desired_acceleration_and_angular_acceleration_body_z;\n  desired_acceleration_and_angular_acceleration.tail<3>() = angular_acceleration_body_z;\n\n  // Project desired acceleration and angular acceleration onto rotor directions.\n  *rotor_velocities = rotor_direction_matrix_ * desired_acceleration_and_angular_acceleration;\n\n  // Ensure that rotor velocities are non-negative.\n  rotor_velocities->array() = rotor_velocities->array().max(0.0);\n\n  // Take the square root of each component.\n  rotor_velocities->array() = rotor_velocities->array().sqrt();", "CodeBleu_score": 52.168780458690854}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute desired acceleration and angular acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z-axis.\n  Eigen::Vector3d thrust = acceleration + angular_acceleration.cross(odometry_.position);\n  thrust.z() = 0;\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d combined_acceleration = angular_acceleration + thrust.normalized() * thrust.norm();\n\n  // Project combined acceleration onto rotor directions.\n  Eigen::VectorXd rotor_acceleration(vehicle_parameters_.rotor_configuration_.rotors.size());\n  for (size_t i = 0; i < vehicle_parameters_.rotor_configuration_.rotors.size(); i++) {\n    rotor_acceleration(i) = combined_acceleration.dot(vehicle_parameters_.rotor_configuration_.rotors[i]);\n  }\n\n  // Compute rotor velocities from acceleration.\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  *rotor_velocities = rotor_acceleration.cwiseSqrt();\n\n  // Ensure rotor velocities are non-negative.\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Zero());\n}", "CodeBleu_score": 59.17990410894143}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // Check if the controller is active.\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Calculate desired acceleration and angular acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project desired thrust onto body z-axis.\n  Eigen::Vector3d thrust = acceleration - angular_acceleration.cross(odometry_.position);\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d rotor_velocities_vector = angular_acceleration + thrust.cwiseProduct(rotor_direction_);\n\n  // Ensure all rotor velocities are non-negative.\n  rotor_velocities_vector = rotor_velocities_vector.cwiseMax(Eigen::Vector3d::Zero());\n\n  // Return rotor velocities.\n  rotor_velocities->resize(kNumRotors);\n  for (int i = 0; i < kNumRotors; ++i) {\n    (*rotor_velocities)(i) = rotor_velocities_vector[i];\n  }\n}", "CodeBleu_score": 49.03576723046287}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// TODO(rrau): Add unit tests for this function.\n  // TODO(rrau): Add logging for this function.\n\n  // Calculate the position and velocity errors.\n  Eigen::Vector3d position_error =\n      (odometry_.position - trajectory_.position).cwiseProduct(position_gain_);\n  Eigen::Vector3d velocity_error =\n      (odometry_.linear_velocity - trajectory_.linear_velocity).cwiseProduct(\n          velocity_gain_);\n\n  // Transform the commanded velocity to the world frame.\n  Eigen::Vector3d commanded_velocity =\n      odometry_.orientation.toRotationMatrix() * trajectory_.linear_velocity;\n\n  // Calculate the desired acceleration.\n  *acceleration =\n      (position_error + velocity_error).cwiseProduct(acceleration_gain_) +\n      (commanded_velocity - odometry_.linear_velocity).cwiseProduct(\n          acceleration_gain_) +\n      Eigen::Vector3d(0, 0, -gravity_);\n\n  // Adjust for vehicle mass.\n  *acceleration = (*acceleration).cwiseQuotient(mass_);\n}", "CodeBleu_score": 46.08379557495665}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// TODO(slynen): Implement this function\n  // Compute the position and velocity errors.\n  Eigen::Vector3d position_error = command_trajectory_.position() - odometry_.position;\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity() - odometry_.velocity;\n\n  // Transform the velocity to the world frame.\n  Eigen::Vector3d velocity_world = odometry_.orientation.toRotationMatrix() * velocity_error;\n\n  // Compute the desired acceleration.\n  *acceleration = position_gain_ * position_error + velocity_gain_ * velocity_world;\n\n  // Adjust for the vehicle mass and gravity.\n  *acceleration += gravity_ + mass_ * command_trajectory_.acceleration();\n}", "CodeBleu_score": 38.306049720174215}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// TODO: Implement this function\n  // Compute the position and velocity errors\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity - odometry_.velocity;\n\n  // Transform the vehicle's velocity to the world frame\n  Eigen::Vector3d velocity_world = odometry_.orientation.toRotationMatrix() * velocity_error;\n\n  // Compute the desired acceleration\n  *acceleration = (position_error.cwiseProduct(position_gains_) + velocity_world.cwiseProduct(velocity_gains_)) /\n                  (mass_ + gravity_) + command_trajectory_.acceleration;\n}", "CodeBleu_score": 40.260348119970004}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // combine angular acceleration with thrust reference\n  Eigen::VectorXd angular_acceleration_thrust(3 + 1);\n  angular_acceleration_thrust << angular_acceleration, control_thrust_reference_;\n\n  // compute rotor velocities\n  rotor_velocities->resize(rotor_count_);\n  *rotor_velocities = rotor_velocities_matrix_ * angular_acceleration_thrust;\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_count_));\n  rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 51.49494294104953}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // check if the input is valid\n  if (control_attitude_thrust_reference_.rows() != 3) {\n    LOG(ERROR) << \"Control attitude thrust reference must be a 3x1 vector\";\n    return;\n  }\n\n  if (control_attitude_thrust_reference_.rows() != gain_attitude_.rows()) {\n    LOG(ERROR) << \"Gain attitude must be a 3x1 vector\";\n    return;\n  }\n\n  if (control_attitude_thrust_reference_.rows() != gain_angular_rate_.rows()) {\n    LOG(ERROR) << \"Gain angular rate must be a 3x1 vector\";\n    return;\n  }\n\n  // resize the rotor velocities vector\n  rotor_velocities->resize(rotors_.size());\n\n  // compute desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // combine desired angular acceleration with thrust reference into a single vector\n  Eigen::VectorXd desired_angular_acceleration_thrust(angular_acceleration.rows() + 1);\n  desired_angular_acceleration_thrust << angular_acceleration, control_attitude_thrust_reference_(2);\n\n  // compute rotor velocities\n  *rotor_velocities = rotor_velocities_matrix_ * desired_angular_acceleration_thrust;\n\n  // ensure the rotor velocities are at least one\n  rotor_velocities->array() = rotor_velocities->array().max(1);\n\n  // take the square root of each component\n  rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 52.602379562308656}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!IsValid()) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: invalid input, returning\" << std::endl;\n    return;\n  }\n\n  Eigen::Vector3d angular_acceleration_thrust;\n  ComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n  // calculate rotor velocities\n  rotor_velocities->resize(rotors_.size());\n  *rotor_velocities = rotor_velocities_matrix_ * (angular_acceleration_thrust + thrust_reference_);\n\n  // ensure rotor velocities are at least one\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->size()));\n\n  // take square root of each component\n  rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 44.57839799069036}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in self.__slots__:\n        copied_obj.__setattr__(attr, getattr(self, attr)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 41.660312747074116}, {"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.__getattribute__('time') = copied_obj.__getattribute__('time')[start_index:end_index]\n    copied_obj.__getattribute__('x') = copied_obj.__getattribute__('x')[start_index:end_index]\n    copied_obj.__getattribute__('y') = copied_obj.__getattribute__('y')[start_index:end_index]\n    copied_obj.__getattribute__('z') = copied_obj.__getattribute__('z')[start_index:end_index]\n    copied_obj.__getattribute__('u') = copied_obj.__getattribute__('u')[start_index:end_index]\n    copied_obj.__getattribute__('v') = copied_obj.__getattribute__('v')[start_index:end_index]\n    copied_obj.__getattribute__('w') = copied_obj.__getattribute__('w')[start_index:end_index]\n    return copied_obj\n\n", "CodeBleu_score": 33.40809763405953}, {"code": "def slice(self, start_time, end_time)\n\t# Find the indices of the start and end times.\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # Make a deep copy of the object.\n    copied_obj = copy.deepcopy(self)\n    # Slice the attributes of the copied object.\n    copied_obj.__getattribute__('time') = self.time[start_index:end_index]\n    copied_obj.__getattribute__('x') = self.x[start_index:end_index]\n    copied_obj.__getattribute__('y') = self.y[start_index:end_index]\n    copied_obj.__getattribute__('z') = self.z[start_index:end_index]\n    copied_obj.__getattribute__('vx') = self.vx[start_index:end_index]\n    copied_obj.__getattribute__('vy') = self.vy[start_index:end_index]\n    copied_obj.__getattribute__('vz') = self.vz[start_index:end_index]\n    copied_obj.__getattribute__('mass') = self.mass[start_index:end_index]\n    copied_obj.__getattribute__('radius') = self.radius[start_index:end_index]\n    copied_obj.__getattribute__('color') = self.color[start_index:end_index]\n    copied_obj.__getattribute__('density') = self.density[start_index:end_index]\n    copied_obj.__getattribute__('momentum') = self.momentum[start_index:end_index]\n    copied_obj.__getattribute__('angular_momentum') = self.angular_momentum[start_index:end_index]\n    copied_obj.__getattribute__('energy') = self.energy[start_index:end_index]\n    copied_obj.__getattribute__('potential_energy') = self.potential_energy[start_index:end_index]\n    copied_obj.__getattribute__('kinetic_energy') = self.kinetic_energy[start_index:end", "CodeBleu_score": 28.731894601132}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tif self.last_point is None:\n        self.last_point = Point()\n    if self.last_point.x != waypoint_msg.pose.pose.position.x or self.last_point.y != waypoint_msg.pose.pose.position.y or self.last_point.z != waypoint_msg.pose.pose.position.z:\n        self.append_point(waypoint_msg.pose.pose.position)\n        self.append_times(msg_time, bag_time)\n        self.last_point = waypoint_msg.pose.pose.position\n\n", "CodeBleu_score": 18.180650316036566}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\twaypoint_position = waypoint_msg.pose.position\n    waypoint_rotation = waypoint_msg.pose.orientation\n    waypoint_point = Point(waypoint_position.x, waypoint_position.y, waypoint_position.z)\n    waypoint_yaw = euler_from_quaternion(waypoint_rotation)[2]\n    if self.last_waypoint is None:\n        self.last_waypoint = waypoint_point\n        self.last_yaw = waypoint_yaw\n        self.append_point(waypoint_point)\n        self.append_times(msg_time, bag_time)\n    elif waypoint_point != self.last_waypoint or waypoint_yaw != self.last_yaw:\n        self.append_point(waypoint_point)\n        self.append_times(msg_time, bag_time)\n        self.last_waypoint = waypoint_point\n        self.last_yaw = waypoint_yaw", "CodeBleu_score": 17.66434381735698}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tself.append_times(msg_time, bag_time)\n    if self.last_point is None:\n        self.last_point = Point()\n        self.last_point.append_point(waypoint_msg.pose.pose.position)\n        self.last_yaw = euler_from_quaternion(\n            [waypoint_msg.pose.pose.orientation.x, waypoint_msg.pose.pose.orientation.y,\n             waypoint_msg.pose.pose.orientation.z, waypoint_msg.pose.pose.orientation.w])[2]\n    elif not (self.last_point.x == waypoint_msg.pose.pose.position.x and self.last_point.y == waypoint_msg.pose.pose.position.y and self.last_point.z == waypoint_msg.pose.pose.position.z and self.last_yaw == euler_from_quaternion(\n            [waypoint_msg.pose.pose.orientation.x, waypoint_msg.pose.pose.orientation.y,\n             waypoint_msg.pose.pose.orientation.z, waypoint_msg.pose.pose.orientation.w])[2]):\n        self.last_point = Point()\n        self.last_point.append_point(waypoint_msg.pose.pose.position)\n        self.last_yaw = euler_from_quaternion(\n            [waypoint_msg.pose.pose.orientation.x, waypoint_msg.pose.pose.orientation.y,\n             waypoint_msg.pose.pose.orientation.z, waypoint_msg.pose.pose.orientation.w])[2]\n        self.append_point(self.last_point)\n        self.append_yaw(self.last_yaw)\n\n", "CodeBleu_score": 25.747932764748928}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == \"/imu/data\":\n        self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.linear_acceleration.x)\n        self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.linear_acceleration.y)\n        self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.linear_acceleration.z)\n        self.append_times(to_sec(msg.header.stamp), bag_time)\n\n", "CodeBleu_score": 33.142772305756274}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == '/imu/data':\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 34.46580203207466}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == \"/imu/data\":\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 34.46580203207466}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure(figsize=(10, 6))\n    ax = fig.add_subplot(111)\n    # Plot the x, y, and z components over time with different colors and labels\n    a_x.plot(ax=ax, color='red', label='x')\n    a_y.plot(ax=ax, color='green', label='y')\n    a_z.plot(ax=ax, color='blue', label='z')\n    # Add labels for the x and y axes and include a legend\n    pyplot.ylabel('Acceleration (m/s^2)')\n    pyplot.xlabel('Time (s)')\n    pyplot.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        filename = self.plot_prefix + plot_suffix + '.png'\n        pyplot.savefig(filename, dpi=100)\n        print('Saved plot as ' + filename)\n    # Display the plot\n    pyplot.show()\n\n", "CodeBleu_score": 33.68056865842368}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\timport matplotlib.pyplot as plt\n    import matplotlib as mpl\n    import numpy as np\n    import pandas as pd\n    from . import plot_utils\n    import os\n    import inspect\n\n    # Get the calling function's name\n    calling_function = inspect.stack()[1][3]\n\n    # Get the data from the accelerometer\n    accel_data = self.accel_data\n\n    # If there is no data, return\n    if len(accel_data) == 0:\n        print(\"No accelerometer data to plot.\")\n        return\n\n    # Get the data from the gyroscope\n    gyro_data = self.gyro_data\n\n    # Get the data from the magnetometer\n    mag_data = self.mag_data\n\n    # Get the data from the temperature\n    temp_data = self.temp_data\n\n    # Get the data from the pressure\n    press_data = self.press_data\n\n    # Get the data from the humidity\n    humidity_data = self.humidity_data\n\n    # Get the data from the light\n    light_data = self.light_data\n\n    # Get the data from the proximity\n    proximity_data = self.proximity_data\n\n    # Get the data from the orientation\n    orientation_data = self.orientation_data\n\n    # Get the data from the gravity\n    gravity_data = self.gravity_data\n\n    # Get the data from the linear acceleration\n    linear_accel_data = self.linear_accel_data\n\n    # Get the data from the rotation vector\n    rotation_vector_data = self.rotation_vector_data\n\n    # Get the data from the quaternion\n    quaternion_data = self.quaternion_data\n\n    # Get the data from the gravity\n    gravity_data = self.gravity_data\n\n    # Get the data from the step detector\n    step_detector_data = self.step_detector_data\n\n    # Get the data from the step counter\n    step_counter_data = self.step_counter_data\n\n    # Get the data from the tilt angle\n    tilt_", "CodeBleu_score": 25.065004465804723}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration Data\")\n    ax = fig.add_subplot(111)\n\n    # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels\n    for a_x in self.accelerations:\n        ax.plot(a_x.times, a_x.x, label=\"X-axis\")\n        ax.plot(a_x.times, a_x.y, label=\"Y-axis\")\n        ax.plot(a_x.times, a_x.z, label=\"Z-axis\")\n\n    # Add labels for the x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Add a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        filename = \"{0}_accelerations{1}.png\".format(self.plot_prefix, plot_suffix)\n        pyplot.savefig(filename)\n\n\n\n\n", "CodeBleu_score": 35.06406798860331}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\tif len(pose_indeces) > 1:\n        for index in range(len(pose_indeces) - 1):\n            compare_two_xyz(self.pose_list[pose_indeces[index]].position, self.pose_list[pose_indeces[index + 1]].position)\n    else:\n        print \"There must be at least two pose indices to compare positions.\"\n\n", "CodeBleu_score": 33.199666463839264}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement the compare_positions function\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement this function\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for i in range(len(self.wrench)):\n        if start_time is None and end_time is None:\n            collision_times.append(self.wrench[i].header.stamp.secs)\n        elif start_time is None and end_time is not None:\n            if self.wrench[i].header.stamp.secs <= end_time:\n                collision_times.append(self.wrench[i].header.stamp.secs)\n        elif start_time is not None and end_time is None:\n            if self.wrench[i].header.stamp.secs >= start_time:\n                collision_times.append(self.wrench[i].header.stamp.secs)\n        elif start_time is not None and end_time is not None:\n            if self.wrench[i].header.stamp.secs >= start_time and self.wrench[i].header.stamp.secs <= end_time:\n                collision_times.append(self.wrench[i].header.stamp.secs)\n    return collision_times\n\n\n\n\n\n\n", "CodeBleu_score": 34.41385295167731}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    if start_time is None:\n        start_time = self.start_time\n    if end_time is None:\n        end_time = self.end_time\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n\n\n\n\n", "CodeBleu_score": 39.50874078059425}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    if start_time is None:\n        start_time = 0\n    if end_time is None:\n        end_time = self.duration\n    for time in self.wrench.keys():\n        if time >= start_time and time <= end_time:\n            collision_times.append(time)\n    return collision_times", "CodeBleu_score": 38.21735674238309}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n\n  const float multiplier = this->dist / (this->fx * this->baseline);\n  const Eigen::Map<Eigen::ArrayXf, Eigen::Unaligned, Eigen::Stride<>>\n      data_vector_map(data, width * height);\n  const float rms_noise = this->rms_noise * multiplier;\n  const float noise = this->noise * multiplier;\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (InRange(data_vector_map(i))) {\n      data_vector_map(i) +=\n          (rand() / static_cast<float>(RAND_MAX)) * rms_noise - noise;\n    } else {\n      data_vector_map(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 51.12871015952762}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n  const float multiplier = this->dist / this->focal_length;\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  const float rms_noise = this->CalculateRmsNoise(width, height, data);\n  const float noise = this->CalculateNoise(rms_noise);\n  for (size_t i = 0; i < width * height; i++) {\n    if (this->InRange(data_vector_map[i])) {\n      data_vector_map[i] += noise * multiplier;\n    } else {\n      data_vector_map[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 53.387580438717805}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n  // Calculate multiplier based on camera parameters.\n  const float multiplier =\n      (this->dist * 1000.0) / (this->fx * this->fy * this->baseline);\n  // Map data to Eigen vector.\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  // Compute RMS noise and noise values.\n  const float rms_noise = this->noise * this->noise;\n  const Eigen::VectorXf noise_values =\n      Eigen::VectorXf::Constant(width * height, rms_noise);\n  // Apply noise.\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data_vector_map(i))) {\n      data_vector_map(i) +=\n          multiplier * noise_values(i) * (rand() / static_cast<float>(RAND_MAX));\n    } else {\n      data_vector_map(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 54.62796763445655}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  gazebo::common::Time current_time = world_->SimTime();\n  // Convert Gazebo time to ROS time\n  ros::Time current_ros_time = ros::Time(current_time.sec, current_time.nsec);\n  // Write the trajectory message to the bag file\n  trajectory_msg_bag_->write(namespace_, waypoint_topic_, current_ros_time,\n                              *trajectory_msg);\n}", "CodeBleu_score": 55.38189690170975}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  ros::Time current_time = world_->SimTime();\n  // Convert the simulation time to ROS time\n  ros::Time current_ros_time(current_time.sec, current_time.nsec);\n  // Write the trajectory message to the bag file\n  trajectory_bag_->write(waypoint_topic_ + \"/\" + namespace_,\n                         current_ros_time, trajectory_msg);\n}", "CodeBleu_score": 58.79671336841361}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time and convert it to ROS time.\n  ros::Time current_time = ros::Time::now();\n\n  // Write the trajectory message to a bag file using the specified namespace and waypoint topic.\n  writeBag(current_time, trajectory_msg, waypoint_topic_);\n}", "CodeBleu_score": 33.93696676632487}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert Gazebo time to ROS time\n    ros::Time ros_time(now.sec, now.nsec);\n    // Prepare the message for motor velocities\n    motor_velocities_msg.header.stamp = ros_time;\n    // Iterate through the motor joints\n    for (std::map<std::string, gazebo::physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n        // Calculate the slowed-down rotational velocities\n        double rot_velocity = m->second->GetVelocity(0);\n        double rot_velocity_slowed_down = rot_velocity * rot_velocity_slowdown_factor_;\n        // Assign the slowed-down rotational velocities to the message\n        rot_velocities_msg.angular_velocities.push_back(rot_velocity_slowed_down);\n    }\n    // Write the data to a bag file\n    motor_velocities_publisher_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 49.631404106675596}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time ros_time = ros::Time::now();\n    ros::Duration ros_time_offset = ros_time - ros::Time::now();\n\n    // create message\n    gazebo_msgs::ActuatorVelocities rot_velocities_msg;\n    rot_velocities_msg.header.stamp = ros_time;\n    rot_velocities_msg.header.frame_id = \"world\";\n    rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n    // get rotational velocities\n    for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n        rot_velocities_msg.angular_velocities[m->second->GetVelocity()] = m->second->GetVelocity();\n    }\n\n    // write to bag file\n    rot_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 55.68578702517155}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert Gazebo time to ROS time.\n    ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n    // Prepare a message for the motor velocities.\n    gazebo_msgs::Actuators rot_velocities_msg;\n    rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n    // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\n    for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n        rot_velocities_msg.angular_velocities[m->second->GetScopedName()] = m->second->GetVelocity(0);\n    }\n\n    // Set the message timestamp.\n    rot_velocities_msg.header.stamp = ros_now;\n\n    // Write the data to a bag file using the specified namespace and motor topic.\n    rot_velocities_publisher_->publish(rot_velocities_msg);\n}", "CodeBleu_score": 57.38363503627166}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_print_) {\n    gzmsg << \"RollPitchYawrateThrustCallback called.\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  double roll_angle = NormalizedInputToAngle(\n      ailerons_, roll_pitch_yawrate_thrust_msg->roll());\n  double pitch_angle = NormalizedInputToAngle(\n      elevator_, roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust().x;\n\n  // Set the throttle value from the thrust message.\n  throttle_ = thrust;\n\n  // Set the control surface angles.\n  ailerons_.angle = roll_angle;\n  elevator_.angle = pitch_angle;\n  rudder_.angle = yaw_rate;\n}", "CodeBleu_score": 46.883989901695536}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_) {\n    gzdbg << __FUNCTION__ << \" called.\" << std::endl;\n  }\n\n  double roll = NormalizedInputToAngle(\n      ailerons_, roll_pitch_yawrate_thrust_msg->roll());\n  double pitch = NormalizedInputToAngle(\n      elevator_, roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate = NormalizedInputToAngle(\n      rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate());\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust().x;\n\n  // Set the control surface angles.\n  SetControlSurfaceAngles(roll, pitch, yaw_rate, thrust);\n}", "CodeBleu_score": 55.36283453661054}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t// If debug printing is enabled, log that the callback was called.\n  if (debug_print_) {\n    gzdbg << __FUNCTION__ << \" called.\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to\n  // control surface angles for ailerons, elevator, and rudder respectively.\n  ailerons_angle_ = NormalizedInputToAngle(ailerons_,\n      roll_pitch_yawrate_thrust_msg->roll());\n  elevator_angle_ = NormalizedInputToAngle(elevator_,\n      roll_pitch_yawrate_thrust_msg->pitch());\n  rudder_angle_ = NormalizedInputToAngle(rudder_,\n      roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust().z;\n}", "CodeBleu_score": 50.22015882192643}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t// If there is no serial connection, return immediately.\n  if (!serial_enabled_) {\n    return;\n  }\n\n  // Convert the timeout to a timeval structure.\n  struct timeval timeout;\n  timeout.tv_sec = static_cast<long>(_dt);\n  timeout.tv_usec =\n      static_cast<decltype(timeout.tv_usec)>((_dt - timeout.tv_sec) * 1e6);\n\n  // Perform a poll operation on the file descriptors.\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n  int ret = select(_fd + 1, &fds, NULL, NULL, &timeout);\n\n  // If data is available, receive the data and parse MAVLink messages.\n  if (ret > 0) {\n    char buffer[1024];\n    ssize_t len = recv(_fd, buffer, sizeof(buffer), 0);\n    if (len <= 0) {\n      gzerr << \"Failed receiving mavlink message\n\";\n      return;\n    }\n\n    // Parse the MAVLink messages.\n    mavlink_message_t msg;\n    int i = 0;\n    while (mavlink_parse_char(MAVLINK_COMM_0, buffer[i++], &msg, &status_)) {\n      handle_message(&msg);\n    }\n  }\n}", "CodeBleu_score": 46.046309350510285}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tif (serial_enabled_) {\n    assert(is_open());\n\n    // Set a timeout for the poll operation.\n    struct timeval tv;\n    tv.tv_sec = _dt;\n    tv.tv_usec = (_timeoutMs - _dt) * 1000;\n\n    // Poll for data.\n    fd_set fds;\n    FD_ZERO(&fds);\n    FD_SET(_fd, &fds);\n\n    int ret = poll(&fds, 1, _timeoutMs);\n    if (ret < 0) {\n      gzerr << \"poll() error: \" << strerror(errno) << \"\n\";\n      return;\n    }\n\n    // If data is available, receive it.\n    if (ret > 0) {\n      if (FD_ISSET(_fd, &fds)) {\n        char buffer[MAVLINK_MAX_PACKET_LEN];\n        ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n        if (len <= 0) {\n          gzerr << \"Failed receiving data from MAVLink device\n\";\n          return;\n        }\n\n        // Parse MAVLink messages from the buffer.\n        mavlink_message_t msg;\n        mavlink_status_t status;\n        for (ssize_t i = 0; i < len;) {\n          i += mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status);\n\n          // Handle the message.\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 53.93753348747167}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tif (serial_enabled_) {\n    if (!is_open()) {\n      gzerr << \"Serial port closed! \n\";\n      return;\n    }\n\n    if (_timeoutMs == 0) {\n      _timeoutMs = 1;\n    }\n\n    struct timeval timeout;\n    timeout.tv_sec = _timeoutMs / 1000;\n    timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n    if (io_service_.poll(timeout)) {\n      do_read();\n    }\n  }\n\n  else {\n    // Check for received data.\n    fd_set fds;\n    FD_ZERO(&fds);\n    FD_SET(_fd, &fds);\n\n    struct timeval timeout;\n    timeout.tv_sec = _timeoutMs / 1000;\n    timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n    int ret = select(_fd + 1, &fds, NULL, NULL, &timeout);\n\n    if (ret > 0) {\n      do_read();\n    }\n  }\n}", "CodeBleu_score": 41.690776333114876}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex_);\n    if (is_open_) {\n        io_service_.stop();\n        serial_dev_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n        is_open_ = false;\n    }\n}", "CodeBleu_score": 64.97424601099698}, {"code": "void GazeboMavlinkInterface::close() {\n\tboost::mutex::scoped_lock lock(mutex_);\n  if (is_open_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n    is_open_ = false;\n  }\n}", "CodeBleu_score": 66.73481195698331}, {"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex_);\n    if (!is_open_)\n        return;\n\n    io_service_.stop();\n    serial_dev_.close();\n\n    if (io_thread_.joinable())\n        io_thread_.join();\n\n    is_open_ = false;\n\n}", "CodeBleu_score": 74.52604847005068}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x1, y1, z1, x2, y2, z2;\n    double x3, y3, z3;\n    double x4, y4, z4;\n    double x5, y5, z5;\n    double x6, y6, z6;\n    double x7, y7, z7;\n    double x8, y8, z8;\n    double x9, y9, z9;\n    double x10, y10, z10;\n    double x11, y11, z11;\n    double x12, y12, z12;\n    double x13, y13, z13;\n    double x14, y14, z14;\n    double x15, y15, z15;\n    double x16, y16, z16;\n    double x17, y17, z17;\n    double x18, y18, z18;\n    double x19, y19, z19;\n    double x20, y20, z20;\n    double x21, y21, z21;\n    double x22, y22, z22;\n    double x23, y23, z23;\n    double x24, y24, z24;\n    double x25, y25, z25;\n    double x26, y26, z26;\n    double x27, y27, z27;\n    double x28, y28, z28;\n    double x29, y29, z29;\n    double x30, y30, z30;\n    double x31, y31, z31;\n    double x32, y32, z32;\n    double x33, y33, z33;\n    double x34, y34, z34;\n    double x35, y35, z35;\n    double x36, y36, z36;\n    double", "CodeBleu_score": 5.846965510044074}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tstd::vector<ignition::math::Vector3d> &points,\n  double time\n}", "CodeBleu_score": 5.492664374757841}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x1, y1, z1, x2, y2, z2;\n  double x3, y3, z3;\n  double t;\n  x1 = 0.0;\n  y1 = 0.0;\n  z1 = 0.0;\n  x2 = 0.0;\n  y2 = 0.0;\n  z2 = 0.0;\n  x3 = 0.0;\n  y3 = 0.0;\n  z3 = 0.0;\n  t = 0.0;\n\n  x3 = x1 + (x2 - x1) * t;\n  y3 = y1 + (y2 - y1) * t;\n  z3 = z1 + (z2 - z1) * t;\n\n  return ignition::math::Vector3d(x3, y3, z3);\n}", "CodeBleu_score": 35.50156072475614}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t// If the animation is not enabled, do nothing\n  if (!enabled) {\n    return;\n  }\n\n  // If the new time is different from the current time, update it\n  if (_time != time) {\n    time = _time;\n\n    // If looping is enabled, wrap the time within the animation length\n    if (looping) {\n      time = fmod(time, length);\n      if (time < 0) {\n        time += length;\n      }\n    }\n    // Otherwise, clamp the time between 0 and the animation length\n    else {\n      time = ignition::math::clamp(time, 0.0, length);\n    }\n  }\n}", "CodeBleu_score": 39.890519163414936}, {"code": "void Animation::SetTime(double _time){\n\tif (this->time != _time) {\n    this->time = _time;\n    this->Update();\n  }\n}", "CodeBleu_score": 35.352069930983575}, {"code": "void Animation::SetTime(double _time){\n\tif (this->dataPtr->time != _time) {\n    this->dataPtr->time = _time;\n    this->dataPtr->time = ignition::math::clamp(\n        this->dataPtr->time, 0.0, this->dataPtr->length);\n\n    if (this->dataPtr->loop)\n      this->dataPtr->time = ignition::math::mod(\n          this->dataPtr->time, this->dataPtr->length);\n\n    this->dataPtr->time = ignition::math::clamp(\n        this->dataPtr->time, 0.0, this->dataPtr->length);\n\n    this->dataPtr->dirty = true;\n  }\n}", "CodeBleu_score": 48.20369224158244}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\tprint(\"Hovering...\")\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.set_position_target_local_ned(target_raw_pose)\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + self.vehicle_id)\n    print(\"Flight mode: \" + self.flight_mode)\n\n", "CodeBleu_score": 40.12633910101769}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n\n    self.vehicle.send_mavlink(target_raw_pose)\n    print(\"Vehicle Type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight Mode: \", self.vehicle.mode.name)\n\n", "CodeBleu_score": 44.26839843851656}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target(yaw=self.yaw)\n    self.send_mavlink(target_raw_pose)\n\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + self.flight_mode)\n\n", "CodeBleu_score": 47.25553834098781}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode+\" mode switch successful.\")\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode+\" mode switch failed.\")\n            return False", "CodeBleu_score": 54.7447149967168}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(mode=self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            print \"Service call failed: %s\"%e\n            return False\n\n", "CodeBleu_score": 45.20985374493134}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(mode=self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode+\" mode switch successful.\")\n            return True\n        except rospy.ServiceException, e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode+\" mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 54.335150147699274}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.flight_mode != 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        elif self.flight_mode == 'HOVER' and abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 65.48809253699463}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t# TODO: This function should be modified to transition the drone's flight mode based on positional and rotational thresholds.\n    # TODO: If any of the x, y, z values exceed 0.02 or w exceeds 0.005, it sets hover_flag to 0 and changes the flight mode to 'OFFBOARD'.\n    # TODO: If the flight mode is not \"HOVER\" and the conditions are met, it sets hover_flag to 1, changes the flight mode to 'HOVER', and initiates the hover action.\n    if self.flight_mode != \"HOVER\":\n        if self.hover_flag == 0:\n            if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n                self.hover_flag = 1\n                self.flight_mode = \"HOVER\"\n                self.hover()\n        elif self.hover_flag == 1:\n            if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n                self.hover_flag = 0\n                self.flight_mode = \"OFFBOARD\"\n\n", "CodeBleu_score": 72.09121852763987}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.flight_mode != \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        elif self.hover_flag == 0:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 69.56652029987687}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 16.806809161752323}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 16.806809161752323}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 16.806809161752323}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t# Update coordinate frame and motion type\n    self.coordinate_frame = 1\n    self.motion_type = 0\n\n    # Construct a target motion\n    target_raw_pose = self.construct_target()\n\n    # Send the target motion to the vehicle\n    self.vehicle.send_mavlink(target_raw_pose)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: {}, Vehicle ID: {}, Flight Mode: {}\".format(self.vehicle.vehicle_type, self.vehicle.id, self.vehicle.mode.name))\n\n", "CodeBleu_score": 36.84490807219609}, {"code": "def hover(self)\n\tprint(\"Hovering...\")\n\n    self.coordinate_frame = 1\n    self.motion_type = 2\n\n    target_raw_pose = self.construct_target()\n    self.set_position_target_local_ned(target_raw_pose)\n\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.flight_mode)\n\n", "CodeBleu_score": 32.597106398545876}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.set_position_target_local_ned(target_raw_pose)\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 36.4082381125539}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(flightMode=self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + \"Flight mode switch failed.\")\n            return False\n\n", "CodeBleu_score": 57.06141825480042}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(\"Flight mode switch failed.\")\n            return False\n\n", "CodeBleu_score": 48.87236871548829}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(mode=self.flight_mode)\n            self.flight_mode = self.flightModeService.response.mode\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 49.87395891424045}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n    return self.total_reward\n\n", "CodeBleu_score": 48.98349125946019}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 55.40188162220928}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()", "CodeBleu_score": 55.40188162220928}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\tif msg.id == i:\n        self.local_pose = msg\n        if self.local_pose.type == 1:\n            self.takeoff_target_pose.position.x = self.local_pose.position.x\n            self.takeoff_target_pose.position.y = self.local_pose.position.y\n            self.takeoff_target_pose.position.z = self.local_pose.position.z\n            self.takeoff_target_pose.orientation.x = self.local_pose.orientation.x\n            self.takeoff_target_pose.orientation.y = self.local_pose.orientation.y\n            self.takeoff_target_pose.orientation.z = self.local_pose.orientation.z\n            self.takeoff_target_pose.orientation.w = self.local_pose.orientation.w\n        if self.local_pose.type == 2:\n            self.hover_target_pose.position.x = self.local_pose.position.x\n            self.hover_target_pose.position.y = self.local_pose.position.y\n            self.hover_target_pose.position.z = self.local_pose.position.z\n            self.hover_target_pose.orientation.x = self.local_pose.orientation.x\n            self.hover_target_pose.orientation.y = self.local_pose.orientation.y\n            self.hover_target_pose.orientation.z = self.local_pose.orientation.z\n            self.hover_target_pose.orientation.w = self.local_pose.orientation.w\n\n        if self.local_pose.type == 3:\n            self.land_target_pose.position.x = self.local_pose.position.x\n            self.land_target_pose.position.y = self.local_pose.position.y\n            self.land_target_pose.position.z = self.local_pose.position.z\n            self.land_target_pose.orientation.x = self.local_pose.orientation.x\n            self.land_target_pose.orientation.y = self.local_pose.orientation.y\n            self.land_", "CodeBleu_score": 15.469296529391222}, {"code": "def local_pose_callback(self, msg, i)\n\tif msg.uav_id == i:\n        self.local_pose[i] = msg\n        if msg.command == 'takeoff':\n            self.takeoff_target_pose[i] = msg\n        elif msg.command == 'hover':\n            self.hover_target_pose[i] = msg\n        self.global_pose[i] = copy.deepcopy(self.local_pose[i])\n        self.global_pose[i].x += self.global_position_bias[0]\n        self.global_pose[i].y += self.global_position_bias[1]\n        self.global_pose[i].z += self.global_position_bias[2]\n        self.global_pose[i].uav_id = i\n        self.global_pose[i].command = 'none'\n        self.global_pose[i].target_position = [0, 0, 0]\n        self.global_pose[i].target_velocity = [0, 0, 0]\n        self.global_pose[i].target_acceleration = [0, 0, 0]\n        self.global_pose[i].target_jerk = [0, 0, 0]\n        self.global_pose[i].target_snap = [0, 0, 0]\n        self.global_pose[i].target_yaw = 0\n        self.global_pose[i].target_yaw_rate = 0\n        self.global_pose[i].target_yaw_acceleration = 0\n\n\n\n\n", "CodeBleu_score": 23.980559672408518}, {"code": "def local_pose_callback(self, msg, i)\n\tif msg.id == self.uav_id:\n        self.local_pose = msg\n        if self.uav_id == 0:\n            self.global_pose = msg\n        else:\n            self.global_pose.position.x += self.global_pose_bias[0]\n            self.global_pose.position.y += self.global_pose_bias[1]\n            self.global_pose.position.z += self.global_pose_bias[2]\n            self.global_pose.orientation.x += self.global_pose_bias[3]\n            self.global_pose.orientation.y += self.global_pose_bias[4]\n            self.global_pose.orientation.z += self.global_pose_bias[5]\n            self.global_pose.orientation.w += self.global_pose_bias[6]\n        if self.uav_id == 0:\n            self.takeoff_target_pose = self.local_pose\n            self.hover_target_pose = self.local_pose\n        else:\n            self.takeoff_target_pose.position.x = self.local_pose.position.x + self.takeoff_target_pose_bias[0]\n            self.takeoff_target_pose.position.y = self.local_pose.position.y + self.takeoff_target_pose_bias[1]\n            self.takeoff_target_pose.position.z = self.local_pose.position.z + self.takeoff_target_pose_bias[2]\n            self.hover_target_pose.position.x = self.local_pose.position.x + self.hover_target_pose_bias[0]\n            self.hover_target_pose.position.y = self.local_pose.position.y + self.hover_target_pose_bias[1]\n            self.hover_target_pose.position.z = self.local_pose.position.z + self.hover_target_pose_bias[2]\n        self.takeoff_target_pose.orientation.x = self.local_pose.orientation.x + self", "CodeBleu_score": 18.42284293293794}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\tif self.uav.altitude > 0.2 and self.uav.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 63.32851172429144}, {"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.889133687930844}, {"code": "def takeoff_detection(self)\n\tif self.uav_altitude > 0.2 and self.arm_state == 1:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.74607590912904}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\torig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    # Calculate the pairwise distances between UAVs in the original and changed formations using the Euclidean norm\n    distance_matrix = np.linalg.norm(orig_formation - change_formation, axis=1)\n    # Adjust the distances by subtracting them from 50 and converting them to integers\n    distance_matrix = distance_matrix - 50\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n", "CodeBleu_score": 16.78877455902387}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# Calculate the distance between each UAV in the original formation and the UAVs in the changed formation\n    dist_mat = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_mat[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n            dist_mat[i][j] = int(dist_mat[i][j] - 50)\n    return dist_mat\n\n", "CodeBleu_score": 28.75366506257775}, {"code": "def build_graph(self, orig_formation, change_formation)\n\torig_formation_coords = np.array([[uav.x, uav.y] for uav in orig_formation])\n    change_formation_coords = np.array([[uav.x, uav.y] for uav in change_formation])\n    dist_matrix = np.linalg.norm(orig_formation_coords - change_formation_coords, axis=1)\n    dist_matrix = dist_matrix - 50\n    dist_matrix = dist_matrix.astype(int)\n    return dist_matrix\n\n", "CodeBleu_score": 18.342000450726243}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\tfor i in range(self.num_left):\n        self.visit_left = numpy.array([False] * self.num_left)\n        self.visit_right = numpy.array([False] * self.num_right)\n        self.slack_right = numpy.array([float('inf')] * self.num_right)\n        self.match_right = numpy.array([-1] * self.num_right)\n        if not self.find_path(i):\n            self.label_left[i] += self.slack_right[numpy.argmin(self.slack_right)]\n            self.label_right[numpy.argmin(self.slack_right)] -= self.slack_right[numpy.argmin(self.slack_right)]\n\n    return self.match_right\n\n\n", "CodeBleu_score": 26.413089421494636}, {"code": "def KM(self)\n\tfor i in range(len(self.adj_matrix)):\n        self.visit_left = numpy.array([False] * len(self.adj_matrix))\n        self.visit_right = numpy.array([False] * len(self.adj_matrix))\n        self.slack_right = numpy.array([1000000000000000] * len(self.adj_matrix))\n        self.match_right = numpy.array([-1] * len(self.adj_matrix))\n        self.label_left = numpy.array([0] * len(self.adj_matrix))\n        self.label_right = numpy.array([0] * len(self.adj_matrix))\n        self.find_path(i)\n        for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n            if self.visit_right[j]:\n                self.label_left[i] += match_weight\n                self.label_right[j] += match_weight\n        if not any(self.visit_left):\n            break\n        min_slack = min(self.slack_right)\n        for j, slack in enumerate(self.slack_right, start=0):\n            if slack == min_slack:\n                self.label_left[i] += min_slack\n                self.label_right[j] -= min_slack\n\n", "CodeBleu_score": 35.75005494582994}, {"code": "def KM(self)\n\tfor i in range(self.num_uavs):\n        self.visit_left = numpy.array([False] * self.num_uavs)\n        self.visit_right = numpy.array([False] * self.num_sensors)\n        self.match_right = numpy.array([-1] * self.num_sensors)\n        self.slack_right = numpy.array([numpy.inf] * self.num_sensors)\n        self.label_left = numpy.array([0] * self.num_uavs)\n        self.label_right = numpy.array([0] * self.num_sensors)\n        self.find_path(i)\n        if not any(self.visit_left):\n            self.label_left += self.slack_right\n            self.label_right -= self.slack_right\n            continue\n        else:\n            self.slack_right = numpy.array([numpy.inf] * self.num_sensors)\n            self.label_left = numpy.array([0] * self.num_uavs)\n            self.label_right = numpy.array([0] * self.num_sensors)\n            for i in range(self.num_uavs):\n                self.visit_left[i] = False\n                self.visit_right = numpy.array([False] * self.num_sensors)\n                self.match_right = numpy.array([-1] * self.num_sensors)\n                self.slack_right = numpy.array([numpy.inf] * self.num_sensors)\n                self.label_left[i] = 0\n                self.label_right = numpy.array([0] * self.num_sensors)\n                self.find_path(i)\n                if not any(self.visit_left):\n                    self.label_left += self.slack_right\n                    self.label_right -= self.slack_right\n                    continue\n                else:\n                    self.slack_right = numpy.array([numpy.inf] * self.num_sensors)\n                    self.label_left", "CodeBleu_score": 28.01735582254271}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t# Converting the image to HSV color space\n    image_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Creating a mask for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask_yellow = cv2.inRange(image_hsv, lower_yellow, upper_yellow)\n\n    # Applying the mask to the original image\n    result_yellow = cv2.bitwise_and(image, image, mask=mask_yellow)\n\n    return result_yellow\n\n\n\n\n", "CodeBleu_score": 24.41061483491945}, {"code": "def yellow_dectection(image)\n\t# Converting the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Defining lower and upper bounds for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Creating a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t# Converting to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Creating a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res", "CodeBleu_score": 22.008472449757843}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\tstd::string id;\n    std::string descriptionContainer;\n    bool printWarning = true;\n    return findStandaloneTagDescription(id, descriptionContainer, printWarning);\n}", "CodeBleu_score": 19.779669864322585}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t// TODO: implement this function\n    return false;\n}", "CodeBleu_score": 1.6921632798137913}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tstd::string id;\n    std::string descriptionContainer;\n    bool printWarning = true;\n\n    // Check the standalone_tag_descriptions_ map for the given ID\n    if (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n        descriptionContainer = standalone_tag_descriptions_[id];\n        return true;\n    }\n\n    // If the description is not found and printWarning is true, it logs a warning message\n    if (printWarning) {\n        ROS_WARN_THROTTLE(1, \"Standalone tag description with ID %s not found!\", id.c_str());\n    }\n    return false;\n}", "CodeBleu_score": 46.334402394547936}]}
