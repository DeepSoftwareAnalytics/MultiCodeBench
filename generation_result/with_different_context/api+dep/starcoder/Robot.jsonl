{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get the list of required files from the server\n\tauto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n\t// Download the required files\n\tif (download) {\n\t\tfor (const auto &file : required_files) {\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\tLog::Info(\"Downloading file: \" + file);\n\t\t\t\tRequestFile(file);\n\t\t\t} else {\n\t\t\t\tLog::Info(\"File found in cache: \" + file);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn required_files;\n}", "CodeBleu_score": 63.25972870952808}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get the list of files in the specified folder\n\tauto files = FileTransfer::GetFilesInFolder(folder);\n\n\t// If the download flag is set to true, check if each file exists locally\n\tif (download) {\n\t\tfor (const auto &file : files) {\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\t// Request the file from the server\n\t\t\t\tRequestFile(file);\n\n\t\t\t\t// Log the download action\n\t\t\t\tLogInfo(\"File \" + file + \" downloaded\");\n\t\t\t} else {\n\t\t\t\t// Log that the file is found in the cache\n\t\t\t\tLogInfo(\"File \" + file + \" found in cache\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the list of required files\n\treturn files;\n}", "CodeBleu_score": 52.042332084322915}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get the list of files required by the server\n\tauto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n\t// If the download flag is set to true, check if each file exists locally\n\tif (download) {\n\t\tfor (const auto &file : required_files) {\n\t\t\t// If the file does not exist locally, request it from the server\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\t// Request the file from the server\n\t\t\t\tRequestFile(file);\n\n\t\t\t\t// Log the download action\n\t\t\t\tLogInfo(\"Downloaded file: \" + file);\n\t\t\t}\n\t\t\t// Otherwise, log that the file is found in the cache\n\t\t\telse {\n\t\t\t\tLogInfo(\"Found file in cache: \" + file);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the list of required files\n\treturn required_files;\n}", "CodeBleu_score": 63.34442349497722}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 8.495909444103484}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 8.495909444103484}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n_pimpl->streaming_client.Subscribe(\n      ActorId,\n      GBufferId,\n      callback);\n}", "CodeBleu_score": 22.107850630887526}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tauto token_data = _pimpl->streaming_client.Subscribe(ActorId, GBufferId);\nauto token = std::move(token_data.token);\nauto token_data_size = token_data.size;\nauto token_data_data = token_data.data;\nstd::vector<unsigned char> token_data_vector(token_data_data, token_data_data + token_data_size);\nstd::memcpy(token.data(), token_data_vector.data(), token_data_size);\n_pimpl->CallAndWait([callback, token](Status status) {\ncallback(Buffer(token));\n}, [token]() {\n_pimpl->streaming_client.Unsubscribe(token);\n});\n}", "CodeBleu_score": 52.299509515434586}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tauto token_data = _pimpl->streaming_client.SubscribeToGBuffer(ActorId, GBufferId);\ncallback(Buffer(token_data.data, token_data.size));\n}", "CodeBleu_score": 34.5918463405149}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation;\n\twhile (true) {\n\t\tnavigation = _walker_navigation.load();\n\t\tif (navigation) {\n\t\t\treturn navigation;\n\t\t}\n\t\tstd::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>();\n\t\tif (_walker_navigation.compare_exchange_strong(navigation, new_navigation)) {\n\t\t\treturn new_navigation;\n\t\t}\n\t}\n}", "CodeBleu_score": 50.02590438742447}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation;\ndo {\nnavigation = _walker_navigation.load();\nif (navigation == nullptr) {\nnavigation = std::make_shared<WalkerNavigation>();\nif (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\nnavigation = nullptr;\n}\n}\n} while (navigation == nullptr);\nreturn navigation;\n}", "CodeBleu_score": 54.72538293087904}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n\tif (navigation == nullptr) {\n\t\tstd::unique_lock<std::mutex> lock(_walker_navigation_mutex);\n\t\tnavigation = _walker_navigation.load();\n\t\tif (navigation == nullptr) {\n\t\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t\t\tif (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n\t\t\t\tnavigation = _walker_navigation.load();\n\t\t\t}\n\t\t}\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 48.13788659239665}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetState()->GetFrameNumber() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (timeout.count() > 0ms) {\n\t\t\tauto now = system_clock::now();\n\t\t\tauto elapsed = now - timeout.get_clock()->now();\n\t\t\tif (elapsed > timeout) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\ttraffic_manager.Tick();\n\treturn true;\n}", "CodeBleu_score": 36.14039827190433}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetState()->GetFrameNumber() < frame) {\n\t\tif (timeout <= time_duration::zero()) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t\ttimeout -= std::chrono::milliseconds(16);\n\t}\n\tepisode.GetTrafficManager().Tick();\n\treturn true;\n}", "CodeBleu_score": 24.880361558127444}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetState()->GetFrameNumber() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (timeout.count() > 0ms) {\n\t\t\tif (timeout <= std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - episode.GetState()->GetTimestamp())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tcarla::traffic_manager::TrafficManager::Get().Tick(episode.GetWorld());\n\treturn true;\n}", "CodeBleu_score": 35.902156117569525}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n}", "CodeBleu_score": 3.4852633042533125}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n}", "CodeBleu_score": 3.4852633042533125}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n}", "CodeBleu_score": 3.4852633042533125}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.GetAgentType() == cAirSimImageType::Camera) {\n\t\tthrow std::runtime_error(\"Cannot register a camera as an AI controller\");\n\t}\n\tconst std::string &controller_id = controller.GetId();\n\tauto walker = _agent_map.find(controller_id);\n\tif (walker == _agent_map.end()) {\n\t\tthrow std::runtime_error(\"Cannot find walker with ID \" + controller_id);\n\t}\n\tauto episode = _episode_map.find(walker->second);\n\tif (episode == _episode_map.end()) {\n\t\tthrow std::runtime_error(\"Cannot find episode for walker with ID \" + controller_id);\n\t}\n\tauto nav = _nav_map.find(episode->second);\n\tif (nav == _nav_map.end()) {\n\t\tthrow std::runtime_error(\"Cannot find navigation for episode with ID \" + episode->second);\n\t}\n\tepisode->second->CreateNavigationIfMissing();\n\tnav->second->RegisterWalker(walker->second, controller.GetDisplayId());\n}", "CodeBleu_score": 46.508208427819895}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.GetAgentType() == AgentType::AGENT_TYPE_WALKER) {\n\t\tauto walker = GetWalkerFromId(controller.GetId());\n\t\tif (walker) {\n\t\t\tauto episode = _episode.lock();\n\t\t\tassert(episode);\n\t\t\tauto nav = episode->CreateNavigationIfMissing();\n\t\t\tnav->RegisterWalker(walker);\n\t\t} else {\n\t\t\tthrow_exception(\"Walker with ID {} not found\", controller.GetId());\n\t\t}\n\t} else {\n\t\tthrow_exception(\"Cannot register a non-walker controller with the simulator\");\n\t}\n}", "CodeBleu_score": 55.22342166772843}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.GetParent() == nullptr) {\n\t\tthrow std::runtime_error(\"Controller is not attached to a walker.\");\n\t}\n\tauto walker = controller.GetParent();\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Controller is not attached to a walker.\");\n\t}\n\tauto episode = _episode.get();\n\tif (episode == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is null.\");\n\t}\n\tauto nav = episode->CreateNavigationIfMissing();\n\tif (nav == nullptr) {\n\t\tthrow std::runtime_error(\"Navigation is null.\");\n\t}\n\tnav->RegisterWalker(walker);\n}", "CodeBleu_score": 60.53091679812922}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// load the walkers\n  std::vector<WalkerHandle> walkers = Load(episode);\n\n  // check if empty\n  if (walkers.empty())\n    return;\n\n// get current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // remove any walkers that no longer exist\n  CheckIfWalkerExist(walkers, *state);\n\n  // update the vehicles in the crowd\n  UpdateVehiclesInCrowd(episode, false);\n\n  // update the crowd itself\n  _nav.UpdateCrowd();\n\n  // for each walker\n  for (auto &&walker : walkers) {\n    // get the transform\n    carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n    // get the speed\n    float speed = state->GetActorSnapshot(walker.walker).velocity.length();\n    // apply the transform and speed in a batch\n    _simulator.lock()->ApplyBatchSync({carla::command::ApplyWalkerState{walker.walker, transform, speed}}, false);\n    // check if dead\n    if (_simulator.lock()->IsActorDead(walker.walker)) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n}", "CodeBleu_score": 45.62683368152184}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n#ifdef DEBUG_WALKERS\n  std::vector<WalkerHandle> walkers = _walkers.Load();\n  if (walkers.empty()) return;\n#endif\n\n  // get current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // remove all walkers that no longer exist\n  CheckIfWalkerExist(walkers, *state);\n\n  // update the vehicles in the crowd\n  UpdateVehiclesInCrowd(episode, false);\n\n  // update the crowd itself\n  _nav.UpdateCrowd();\n\n  // apply the batch\n  std::vector<carla::rpc::Command> commands;\n  for (auto &&walker : walkers) {\n    commands.emplace_back(carla::rpc::Command{\n        walker.walker,\n        carla::rpc::Command::ApplyWalkerState,\n        carla::rpc::WalkerControl{\n            walker.controller->GetLocation(),\n            walker.controller->GetSpeed(),\n            walker.controller->GetAngularVelocity(),\n            walker.controller->GetAcceleration(),\n            walker.controller->GetTarget()\n        }});\n  }\n  _simulator.lock()->ApplyBatchSync(commands);\n\n  // check if any walker has been killed\n  for (auto &&walker : walkers) {\n    if (!_nav.IsWalkerAlive(walker.walker)) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n}", "CodeBleu_score": 48.74038493657597}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// get current state\n\tstd::shared_ptr<const EpisodeState> state = episode->GetState();\n\n\t// get all walkers from episode\n\tstd::vector<WalkerHandle> walkers;\n\tfor (auto &&actor : episode->GetActors()) {\n\t\t// only walkers\n\t\tif (actor.description.id.rfind(\"walker.\", 0) == 0) {\n\t\t\t// get the snapshot\n\t\t\tActorSnapshot snapshot = state->GetActorSnapshot(actor.id);\n\t\t\t// add to the vector\n\t\t\twalkers.emplace_back(WalkerHandle{actor.id, actor.controller, snapshot.transform, snapshot.velocity});\n\t\t}\n\t}\n\n\t// check if empty\n\tif (walkers.empty()) return;\n\n\t// update the vehicles in the crowd\n\tUpdateVehiclesInCrowd(episode, _show_debug);\n\n\t// remove any walkers that no longer exist\n\tCheckIfWalkerExist(walkers, *state);\n\n\t// apply the new states\n\t_simulator.lock()->ApplyBatchSync(state->GetActorSnapshots(), true);\n\n\t// check if any walker has been killed\n\tfor (auto &&walker : walkers) {\n\t\tif (!state->IsAlive(walker.walker)) {\n\t\t\t// remove from the crowd\n\t\t\t_nav.RemoveAgent(walker.walker);\n\t\t\t// destroy the controller\n\t\t\t_simulator.lock()->DestroyActor(walker.controller);\n\t\t\t// unregister from list\n\t\t\tUnregisterWalker(walker.walker, walker.controller);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.557483421356906}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\ndescription.uid = uid_;\ndescription.id = id_;\ndescription.attributes.reserve(attributes_.size());\nfor (auto &attribute : attributes_) {\ndescription.attributes.push_back(attribute.MakeAttribute());\n}\nreturn description;\n}", "CodeBleu_score": 71.479778971057}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\ndescription.uid = actor_uid_;\ndescription.id = actor_id_;\ndescription.attributes.resize(attributes_.size());\nfor (int i = 0; i < attributes_.size(); ++i) {\ndescription.attributes[i] = attributes_[i];\n}\nreturn description;\n}", "CodeBleu_score": 67.79553873197533}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\ndescription.uid = uid_;\ndescription.id = id_;\ndescription.attributes.reserve(attributes_.size());\nfor (const auto& attribute : attributes_) {\ndescription.attributes.push_back(attribute.MakeAttribute());\n}\nreturn description;\n}", "CodeBleu_score": 71.56203824093103}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (const auto &pair : blueprints_) {\n\t\tconst auto &blueprint = pair.second;\n\t\tif (blueprint.ContainsAttribute(name)) {\n\t\t\tconst auto &attribute = blueprint.GetAttribute(name);\n\t\t\tif (attribute.GetValue() == value ||\n\t\t\t\tattribute.GetRecommendedValues().count(value) > 0) {\n\t\t\t\tresult->AddBlueprint(pair.first, blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 42.06050114978316}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (const auto &pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tconst Attribute &attribute = pair.second.GetAttribute(name);\n\t\t\tif (attribute.GetValue() == value || attribute.GetRecommendedValues().Contains(value)) {\n\t\t\t\tresult->AddBlueprint(pair.first, pair.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 41.96095714206582}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\t// Create a new BlueprintLibrary to hold the filtered blueprints\n\tauto result = MakeShared<BlueprintLibrary>();\n\n\t// Iterate through the blueprints\n\tfor (const auto &pair : blueprints) {\n\t\t// Check if the attribute exists\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\t// Get the attribute\n\t\t\tconst auto &attribute = pair.second.GetAttribute(name);\n\n\t\t\t// Check if the attribute is a string attribute\n\t\t\tif (attribute.type == Attribute::Type::String) {\n\t\t\t\t// Check if the attribute value matches the specified value\n\t\t\t\tif (attribute.value == value) {\n\t\t\t\t\t// Add the blueprint to the result\n\t\t\t\t\tresult->AddBlueprint(pair.first, pair.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (attribute.type == Attribute::Type::StringArray) {\n\t\t\t\t// Check if the attribute value is in the recommended values\n\t\t\t\tif (attribute.values.find(value) != attribute.values.end()) {\n\t\t\t\t\t// Add the blueprint to the result\n\t\t\t\t\tresult->AddBlueprint(pair.first, pair.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the new BlueprintLibrary\n\treturn result;\n}", "CodeBleu_score": 46.00087019904846}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = base_folder_ + \"/\" + path + \"_\" + std::to_string(version_) + \".bin\";\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\tif (!out.is_open()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<const char *>(&content[0]), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 43.440414407886806}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// TODO: Check if this is necessary\n#if defined(WIN32)\n\tstd::wstring wpath = std::wstring(path.begin(), path.end());\n\tstd::wstring wbase_path = std::wstring(base_path.begin(), base_path.end());\n\tstd::wstring wfull_path = wbase_path + L\"/\" + wpath + L\".\" + std::to_wstring(version);\n\tstd::string full_path(wfull_path.begin(), wfull_path.end());\n#else\n\tstd::string full_path = base_path + \"/\" + path + \".\" + std::to_string(version);\n#endif\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<char*>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 43.77601010100391}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string full_path = GetFullVersionPath(path);\nstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\nif (!out.is_open()) {\nreturn false;\n}\nout.write(reinterpret_cast<const char *>(&content[0]), content.size());\nout.close();\nreturn true;\n}", "CodeBleu_score": 41.257493737923845}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t//  std::cout << \"MakeBounds\" << std::endl;\n  // Calculate the location of the bounding box.\n  const geom::Location location = transform.location + parent_bbox_.location;\n  // Calculate the corners of the bounding box.\n  const float half_width = parent_bbox_.half_width * transform.scale;\n  const float half_height = parent_bbox_.half_height * transform.scale;\n  const float yaw = transform.rotation.yaw * geom::Math::Pi<float>() / 180.0f;\n  const float c = std::cos(yaw);\n  const float s = std::sin(yaw);\n  const std::array<geom::Location, 4> corners = {\n      {\n          {c * half_width - s * half_height, s * half_width + c * half_height, 0.0f},\n          {c * half_width + s * half_height, s * half_width - c * half_height, 0.0f},\n          {-c * half_width + s * half_height, -s * half_width - c * half_height, 0.0f},\n          {-c * half_width - s * half_height, -s * half_width + c * half_height, 0.0f},\n      }};\n  // Rotate the corners based on the transform's rotation.\n  for (auto &corner : corners) {\n    corner = Rotate(transform.rotation.yaw, corner);\n  }\n  // Return a shared pointer to a Bounds object.\n  return std::make_shared<Bounds>(Bounds{frame, corners});\n}", "CodeBleu_score": 42.0201463350405}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t//  const geom::Location location = transform.location + parent_bounds->location;\n  const geom::Location location = transform.location;\n  const float yaw = transform.rotation.yaw;\n\n  const geom::Location left_top = Rotate(yaw - 45.0f, location);\n  const geom::Location right_top = Rotate(yaw + 45.0f, location);\n  const geom::Location right_bottom = Rotate(yaw + 135.0f, location);\n  const geom::Location left_bottom = Rotate(yaw - 135.0f, location);\n\n  return std::make_shared<Bounds>(Bounds{frame, left_top, right_top, right_bottom, left_bottom});\n}", "CodeBleu_score": 46.098935524907596}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst geom::Location location = transform.location + parent_bounds->location;\nconst geom::Location left_bottom = {\n    location.x - parent_bounds->extents.x,\n    location.y - parent_bounds->extents.y,\n    location.z};\nconst geom::Location right_bottom = {\n    location.x + parent_bounds->extents.x,\n    location.y - parent_bounds->extents.y,\n    location.z};\nconst geom::Location left_top = {\n    location.x - parent_bounds->extents.x,\n    location.y + parent_bounds->extents.y,\n    location.z};\nconst geom::Location right_top = {\n    location.x + parent_bounds->extents.x,\n    location.y + parent_bounds->extents.y,\n    location.z};\nconst geom::Location rotated_left_bottom = Rotate(transform.rotation.yaw, left_bottom);\nconst geom::Location rotated_right_bottom = Rotate(transform.rotation.yaw, right_bottom);\nconst geom::Location rotated_left_top = Rotate(transform.rotation.yaw, left_top);\nconst geom::Location rotated_right_top = Rotate(transform.rotation.yaw, right_top);\nreturn std::make_shared<Bounds>(Bounds{frame, {rotated_left_bottom, rotated_right_bottom, rotated_left_top, rotated_right_top}});\n}", "CodeBleu_score": 43.4258028759848}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t_episode.Lock()->QueryLightsStateToServer();\n\tfor (auto& light : _lights) {\n\t\tlight.second->UpdateState(_episode.Lock()->GetLightState(light.first));\n\t}\n}", "CodeBleu_score": 25.30007515885219}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\nstd::vector<LightState> light_states;\n_episode.Lock()->QueryLightsStateToServer(&light_states);\n\nfor (const LightState& light_state : light_states) {\nauto it = _lights.find(light_state.id);\nif (it == _lights.end()) {\n_lights[light_state.id] = std::make_shared<Light>(light_state);\n} else {\nit->second->UpdateState(light_state);\n}\n}\n}", "CodeBleu_score": 39.63592905408867}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n// Retrieve the light states from the server.\nstd::vector<LightState> light_states = _episode.Lock()->QueryLightsStateToServer();\n\n// Update the local light states and create new light objects if they do not exist.\nfor (const LightState& light_state : light_states) {\nauto it = _lights.find(light_state.id());\nif (it != _lights.end()) {\nit->second.UpdateState(light_state);\n} else {\n_lights.emplace(light_state.id(), Light(light_state));\n}\n}\n}", "CodeBleu_score": 38.09582645362275}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_episode.lock);\nif (_lights_changes.empty()) {\nreturn;\n}\nauto message = std::make_shared<rpc::LightState>();\nmessage->episode = _episode.episode_id;\nmessage->timestamp = _episode.timestamp;\nmessage->changes = std::move(_lights_changes);\n_lights_changes.clear();\n_episode.timestamp++;\n_episode.dirty = false;\n_episode.lock.unlock();\nauto future = _server.Send(message, discard_client);\n_episode.lock.lock();\nfuture.wait();\n}", "CodeBleu_score": 37.58243741854512}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::unique_lock<std::mutex> lock(_lights_mutex);\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\tauto message = std::make_shared<std::vector<std::uint8_t>>();\n\tfor (auto& light_change : _lights_changes) {\n\t\tmessage->push_back(light_change.light_id);\n\t\tmessage->push_back(light_change.light_state);\n\t}\n\t_lights_changes.clear();\n\tif (discard_client) {\n\t\t_lights_client_state.clear();\n\t}\n\t_lights_client_state.insert(_lights_client_state.end(), message->begin(), message->end());\n\t_lights_client_state_dirty = true;\n\t_lights_client_state_last_update = std::chrono::steady_clock::now();\n\t_lights_client_state_last_update_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n\t\t_lights_client_state_last_update.time_since_epoch()).count();\n\tlock.unlock();\n\t_lights_client_state_cv.notify_all();\n\t_lights_client_state_cv.notify_one();\n}", "CodeBleu_score": 38.84404541235742}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::unique_lock<std::mutex> lock(_mutex);\n\tif (_lights_changes.empty() && !discard_client) {\n\t\treturn;\n\t}\n\tstd::vector<LightState> states;\n\tfor (auto& light : _lights) {\n\t\tstates.push_back(light.second.GetLocation());\n\t}\n\tauto message = std::make_shared<Message>();\n\tmessage->type = MessageType::kLightState;\n\tmessage->light_states = states;\n\tmessage->light_states_change = _lights_changes;\n\t_lights_changes.clear();\n\tlock.unlock();\n\t_server.Send(message);\n}", "CodeBleu_score": 36.5022416966532}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send called on sensor with display ID \" + GetDisplayId());\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message, GetContext());\n}", "CodeBleu_score": 50.91168268365248}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetSensorId() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send called on sensor \" + GetSensorId() + \" which is not a v2x_custom sensor\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(GetSensorContext(), message);\n}", "CodeBleu_score": 52.35791261134033}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetSensorId() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send called with invalid sensor ID: {}\", GetSensorId());\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(this, message);\n}", "CodeBleu_score": 52.2552110293394}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (tm_port == 0) {\n\t\tif (enabled) {\n\t\t\ttm.RegisterVehicle(this);\n\t\t} else {\n\t\t\ttm.UnregisterVehicle(this);\n\t\t}\n\t} else {\n\t\tif (enabled) {\n\t\t\ttm_client.RegisterVehicle(this, tm_port);\n\t\t} else {\n\t\t\ttm_client.UnregisterVehicle(this, tm_port);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.30433981062789}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tauto *const walker = GetParent();\n\tauto *const episode = GetEpisode();\n\tepisode->Lock()->AddActor(walker);\n\tepisode->Lock()->SetActorLocation(walker->GetLocation(), false);\n\tepisode->Lock()->SetActorCollisions(walker, false);\n\tepisode->Lock()->SetActorSimulatePhysics(walker, false);\n}", "CodeBleu_score": 40.335919643928655}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\t// Get the pawn\n\tAPawn* Owner = GetPawn();\n\tif (!Owner) {\n\t\treturn;\n\t}\n\n\t// Get the walker from the owner\n\tWalker* Walker = Cast<Walker>(Owner);\n\tif (!Walker) {\n\t\treturn;\n\t}\n\n\t// Get the AI controller\n\tFActorSpawnParameters SpawnInfo;\n\tSpawnInfo.Owner = this;\n\tSpawnInfo.Instigator = Owner->GetInstigator();\n\tSpawnInfo.ObjectFlags |= RF_Transient;\n\n\tWalkerAIController* AIController = GetWorld()->SpawnActor<WalkerAIController>(WalkerAIControllerBlueprint, SpawnInfo);\n\tif (!AIController) {\n\t\treturn;\n\t}\n\n\t// Get the AI controller's pawn\n\tAPawn* AIControllerPawn = AIController->GetPawn();\n\tif (!AIControllerPawn) {\n\t\treturn;\n\t}\n\n\t// Get the AI controller's navigation system\n\tUNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(GetWorld());\n\tif (!NavSys) {\n\t\treturn;\n\t}\n\n\t// Add the walker to the navigation system\n\tNavSys->AddNavData(Walker);\n\n\t// Disable physics simulation and collisions for the walker\n\tWalker->GetCharacterMovement()->bSimulatePhysics = false;\n\tWalker->GetCharacterMovement()->bUseControllerDesiredRotation = true;\n\tWalker->GetCharacterMovement()->bOrientRotationToMovement = true;\n\tWalker->GetCharacterMovement()->bConstrainToPlane = true;\n\tWalker->GetCharacterMovement()->SetPlaneConstraintNormal(FVector(0, 0, 1));\n\n\t// Disable physics simulation and collisions for the AI controller\n\tAIControllerPawn->GetCharacterMovement()->bSimulatePhysics = false;\n\tAIControllerPawn->GetCharacterMovement()->bUseControllerDesiredRotation = true;\n\tAIControllerPawn->GetCharacterMovement()->bOrientRotationToMovement = true;\n\tAIControllerPawn->GetCharacterMovement()->bConstrainToPlane = true;\n\tAIControllerPawn->GetCharacterMovement()->SetPlaneConstraintNormal(FVector(0, 0, 1));\n}", "CodeBleu_score": 29.810429422468076}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\t// Get the Pawn being controlled by this AI Controller\n\tAPawn* Pawn = GetPawn();\n\tif (Pawn)\n\t{\n\t\t// Get the walker, being the Pawn being controlled by this AI Controller\n\t\tWalker = Cast<AWalker>(Pawn);\n\t\tif (Walker)\n\t\t{\n\t\t\t// Get the Pawn's controller\n\t\t\tAPawn* Controller = GetController();\n\t\t\tif (Controller)\n\t\t\t{\n\t\t\t\t// Get the Pawn's episode\n\t\t\t\tUWorld* World = GetWorld();\n\t\t\t\tif (World)\n\t\t\t\t{\n\t\t\t\t\t// Get the Pawn's navigation system\n\t\t\t\t\tUNavigationSystemV1* NavSys = World->GetNavigationSystemV1();\n\t\t\t\t\tif (NavSys)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Add the walker to the navigation system\n\t\t\t\t\t\tNavSys->AddNavData(Walker);\n\n\t\t\t\t\t\t// Disable the walker's physics simulation and collisions\n\t\t\t\t\t\tWalker->SetActorSimulatePhysics(false);\n\t\t\t\t\t\tWalker->SetActorEnableCollision(false);\n\n\t\t\t\t\t\t// Register the AI controller with the episode\n\t\t\t\t\t\tGetEpisode().Lock()->RegisterAIController(Controller);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.636045541020955}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (episode) {\n\t\tauto nav = episode->GetNavigation();\n\t\tif (nav) {\n\t\t\tauto walker = GetParent();\n\t\t\tif (walker) {\n\t\t\t\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to set walker max speed\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to find walker\");\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to get navigation\");\n\t\t}\n\t} else {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to get episode\");\n\t}\n}", "CodeBleu_score": 54.40147555600431}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (max_speed < 0.0f) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: max_speed is negative, setting to 0.0f\")\n\t\tmax_speed = 0.0f\n\t}\n\tauto episode = GetEpisode()\n\tif (episode) {\n\t\tauto nav = episode->GetNavigation()\n\t\tif (nav) {\n\t\t\tauto walker = GetParent()\n\t\t\tif (walker) {\n\t\t\t\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: could not set walker max speed\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: walker not found\")\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: navigation not found\")\n\t\t}\n\t} else {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: episode not found\")\n\t}\n}", "CodeBleu_score": 49.376233867816644}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (!m_pEpisode) {\n\t\treturn;\n\t}\n\n\tauto pNav = m_pEpisode->GetNavigation();\n\tif (!pNav) {\n\t\treturn;\n\t}\n\n\tauto walker = m_pEpisode->GetParent();\n\tif (!walker) {\n\t\treturn;\n\t}\n\n\tif (!pNav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to set walker speed\");\n\t}\n}", "CodeBleu_score": 49.60200935723324}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(std::ceil(distance / _parent->GetMap().GetResolution()));\n\tfor (auto i = _parent->GetMap().GetPrevious(GetPose(), distance); !i.IsDone(); i.Advance()) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(i.GetWaypoint()));\n\t}\n\treturn result;\n}", "CodeBleu_score": 57.3850547587341}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(std::ceil(distance / _parent->GetMap().GetResolution()));\n\tfor (double i = 0; i < distance; i += _parent->GetMap().GetResolution()) {\n\t\tresult.emplace_back(_parent->GetMap().GetPrevious(GetPose(), i));\n\t}\n\treturn result;\n}", "CodeBleu_score": 53.25721878419773}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(std::ceil(distance / _parent->GetMap().GetResolution()));\n\n\tfor (auto i = 0; i < result.capacity(); i++) {\n\t\tauto waypoint = _parent->GetMap().GetPrevious(this, distance);\n\t\tif (waypoint) {\n\t\t\tresult.emplace_back(std::make_shared<Waypoint>(waypoint, _parent));\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\tdistance -= _parent->GetMap().GetResolution();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 56.679767829114795}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nfor (const auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\nif (result.empty() || result.back()->GetSignal() != signal) {\nresult.emplace_back(std::make_shared<Landmark>(signal));\n}\n}\nreturn result;\n}", "CodeBleu_score": 28.83552457228038}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n\n/*\n * If the distance is zero, then return an empty vector\n */\nif (distance == 0) {\nreturn result;\n}\n\n/*\n * Get all signals within the distance\n */\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n/*\n * Iterate through the signals\n */\nfor (auto signal : signals) {\n/*\n * If the signal has not already been added to the result, then add it\n */\nif (result.count(signal) == 0) {\n/*\n * Create a new Waypoint\n */\nWaypoint* waypoint = new Waypoint(signal->GetX(), signal->GetY(), _parent->GetMap());\n\n/*\n * Create a new Landmark\n */\nLandmark* landmark = new Landmark(waypoint, signal->GetSignalId());\n\n/*\n * Add the new Landmark to the result\n */\nresult.emplace_back(landmark);\n}\n}\n\n/*\n * Return the result\n */\nreturn result;\n}", "CodeBleu_score": 42.81488106238657}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n\n// Get all signals within the specified distance.\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\n// Create a set to hold the unique signals.\nstd::set<SharedPtr<Signal>> added_signals;\n\n// Loop through all the signals.\nfor (const auto& signal : signals) {\n// If the signal has already been added to the set, continue.\nif (added_signals.count(signal) > 0) {\ncontinue;\n}\n\n// Add the signal to the set.\nadded_signals.insert(signal);\n\n// Create a new Waypoint object at the signal's position.\nauto new_waypoint = MakeShared<Waypoint>(signal->GetPosition());\n\n// Create a new Landmark object at the signal's position.\nauto new_landmark = MakeShared<Landmark>(signal->GetPosition());\n\n// Add the new waypoint and landmark to the result.\nresult.emplace_back(new_waypoint);\nresult.emplace_back(new_landmark);\n}\n\n// Return the result.\nreturn result;\n}", "CodeBleu_score": 48.82117260930704}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n}", "CodeBleu_score": 3.2079205477712285}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n}", "CodeBleu_score": 3.2079205477712285}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n// 1. Apply the settings to the world.\n// 2. Set a local timeout based on the provided timeout or the episode's networking timeout.\n// 3. If the settings include a fixed delta time, it attempts to verify the accuracy of this setting over a series of ticks.\n// 4. If the setting is not correctly applied after a number of attempts, a warning is logged.\n// 5. Finally, it returns the identifier of the applied settings.\n\n}", "CodeBleu_score": 3.2079205477712285}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = SegmentLengthSquared2D(segmentStart, segmentEnd);\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(point, segmentStart));\n\t}\n\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\tfloat t = Clamp(Dot2D(point - segmentStart, segmentEnd - segmentStart) / segmentLengthSquared, 0.0f, segmentLength);\n\treturn std::make_pair(t, Distance2D(point, segmentStart + t * (segmentEnd - segmentStart)));\n}", "CodeBleu_score": 43.2781112305453}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = (segment.end - segment.start).LengthSquared();\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, (point - segment.start).Length());\n\t} else {\n\t\tVector2 segmentLength = Vector2(std::sqrt(segmentLengthSquared), 0.0f);\n\t\tVector2 segmentDirection = (segment.end - segment.start) / segmentLength;\n\t\tVector2 pointDirection = (point - segment.start) / segmentLength;\n\t\tfloat dot = Dot2D(segmentDirection, pointDirection);\n\t\tif (dot < 0.0f) {\n\t\t\treturn std::make_pair(0.0f, (point - segment.start).Length());\n\t\t} else if (dot > 1.0f) {\n\t\t\treturn std::make_pair(segmentLengthSquared, (point - segment.end).Length());\n\t\t} else {\n\t\t\tVector2 projection = segment.start + segmentDirection * dot;\n\t\t\treturn std::make_pair(dot * dot * segmentLengthSquared, (point - projection).Length());\n\t\t}\n\t}\n}", "CodeBleu_score": 42.613746506463364}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat lengthSquared = Dot2D(segment.end - segment.start, segment.end - segment.start);\n\tif (lengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(segment.start, point));\n\t}\n\tfloat length = std::sqrt(lengthSquared);\n\tfloat dot = Dot2D(segment.end - segment.start, point - segment.start) / lengthSquared;\n\tdot = Clamp(dot, 0.0f, length);\n\treturn std::make_pair(dot, Distance2D(segment.start + dot * (segment.end - segment.start), point));\n}", "CodeBleu_score": 32.89729221491152}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\nindex_type index = GetVerticesNum();\nAddVertices(vertices);\nfor (size_t i = 1; i < vertices.size() - 1; i++) {\nAddIndex(index);\nAddIndex(index + i);\nAddIndex(index + i + 1);\n}\n}", "CodeBleu_score": 51.05514443846162}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\nindex_type initial_index = _vertices.size();\nAddVertices(vertices);\nfor (size_t i = 1; i < vertices.size() - 1; ++i) {\nAddIndex(initial_index);\nAddIndex(initial_index + i);\nAddIndex(initial_index + i + 1);\n}\n}", "CodeBleu_score": 51.01669078461711}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\nindex_type initial_index = _vertices.size();\nAddVertices(vertices);\nfor (size_t i = 1; i < vertices.size() - 1; ++i) {\nAddIndex(initial_index);\nAddIndex(initial_index + i);\nAddIndex(initial_index + i + 1);\n}\n}", "CodeBleu_score": 51.01669078461711}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message);\nDEBUG_ASSERT(message->empty() == false);\n\nboost::asio::post(\n  _strand, [this, message] {\n    if (_socket.is_open()) {\n      boost::asio::steady_timer deadline(_strand.context());\n      deadline.expires_from_now(_deadline);\n\n      auto handle_sent = [this, message, &deadline](const boost::system::error_code &ec, std::size_t) {\n        if (ec) {\n          log_error(\"Write failed: {}\", ec.message());\n          _socket.close();\n          return;\n        }\n\n        if (message->empty()) {\n          log_debug(\"Write succeeded\");\n          _socket.close();\n          return;\n        }\n\n        Write(message);\n      };\n\n      _socket.async_write_some(message->GetBufferSequence(), handle_sent);\n    }\n  });\n}", "CodeBleu_score": 41.560557752469975}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\nDEBUG_ASSERT(message->empty() == false);\n\nboost::asio::post(\nself->_strand,\n[self, message]() {\nif (self->_socket.is_open()) {\nself->_deadline.expires_from_now(boost::posix_time::seconds(self->_timeout));\n\nself->_socket.async_write(\nmessage->GetBufferSequence(),\n[self, message](const boost::system::error_code &ec, std::size_t /*bytes_transferred*/) {\nif (ec) {\nself->log_error(\"write error: {}\", ec.message());\n}\n\nif (message->empty()) {\nself->CloseNow();\n}\n});\n}\n});\n}", "CodeBleu_score": 36.25659646880247}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message);\nDEBUG_ASSERT(!message->empty());\n\nauto self = shared_from_this();\n\nif (self->_socket.is_open()) {\nself->_deadline.expires_from_now(boost::posix_time::seconds(1));\n\nauto handle_sent = [self, message](boost::system::error_code ec, std::size_t) {\nif (ec) {\nlog_error(\"Error while sending message: {}\", ec.message());\nself->CloseNow();\n}\n};\n\nboost::asio::async_write(self->_socket, message->GetBufferSequence(), boost::asio::bind_executor(self->_strand, handle_sent));\n} else {\nlog_error(\"Socket closed while sending message.\");\nself->CloseNow();\n}\n}", "CodeBleu_score": 42.69332279281809}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tboost::system::error_code ignored_ec;\n_deadline.cancel(ignored_ec);\nif (ec) {\nif (_socket.is_open()) {\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n_socket.close(ignored_ec);\n}\n} else {\nif (_socket.is_open()) {\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n_socket.close(ignored_ec);\n}\n}\n_on_closed(ec);\nif (ec) {\nlog_debug(\"Error closing socket: %s\", ec.message().c_str());\n} else {\nlog_debug(\"Socket closed\");\n}\n}", "CodeBleu_score": 53.47530801111602}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (_deadline) {\n_deadline->cancel();\n_deadline.reset();\n}\nif (ec) {\nif (_socket.is_open()) {\nboost::system::error_code ignored_ec;\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n_socket.close(ignored_ec);\n}\n} else {\nif (_socket.is_open()) {\nboost::system::error_code ignored_ec;\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n_socket.close(ignored_ec);\n}\n}\nif (_on_closed) {\n_on_closed(ec);\n}\nif (ec) {\nBOOST_LOG_TRIVIAL(debug) << \"Session closed due to error: \" << ec.message();\n} else {\nBOOST_LOG_TRIVIAL(debug) << \"Session closed normally\";\n}\n}", "CodeBleu_score": 53.77938176614515}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\nif (!ec && _socket.is_open()) {\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n_socket.close(ec);\n}\n_on_closed(ec);\nlog_debug(\"session closed\");\n}", "CodeBleu_score": 45.672315853485756}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tauto fut = _router->Send(std::move(Buffer(kIsAlive, kIsAliveLength)), YOU_ALIVE);\n\tLOG_INFO << \"Sending 'Are you alive?'\";\n\tauto msg = fut.get();\n\tLOG_INFO << \"Response: \" << msg.c_str();\n}", "CodeBleu_score": 32.63655426343536}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tauto buffer = std::make_shared<Buffer>(MESSAGE_SIZE);\n\tstd::memcpy(buffer->data(), MESSAGE.c_str(), MESSAGE_SIZE);\n\n\t// Log the sending action\n\tLOG_INFO(\"Sending I am alive\");\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router->WriteToNext(Commands::YOU_ALIVE, buffer);\n\n\t// Wait for and log the response from the system\n\tauto fut = _router->ReadFromPrev(Commands::YOU_ALIVE);\n\tauto msg = fut.get();\n\tLOG_INFO(\"Received %s\", msg.c_str());\n}", "CodeBleu_score": 50.85140400434776}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create the message\n\tstd::string message = \"Are you alive?\";\n\t// Create the buffer\n\tauto buffer = std::make_shared<Buffer>(message.size() + 1);\n\t// Write the message to the buffer\n\tmemcpy(buffer->data(), message.c_str(), message.size() + 1);\n\t// Log the sending action\n\tLog::GetLog()->info(\"Sending \\\"Are you alive?\\\" to the next router\");\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router->WriteToNext(Command::YOU_ALIVE, buffer);\n\t// Wait for the response\n\tauto fut = _router->ReadFromNext(Command::YOU_ALIVE);\n\tauto msg = fut.get();\n\t// Log the response\n\tLog::GetLog()->info(\"Received response: {}\", msg.c_str());\n}", "CodeBleu_score": 50.078928077326445}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tauto fut = _router->WriteToOne(_servers, ENABLE_ROS, sensor_id);\n\tauto response = fut.get();\n\tif (response.status != StatusCode::OK) {\n\t\tlog_error(\"Enable ROS failed with status {}\", response.status);\n\t}\n}", "CodeBleu_score": 25.140159393657147}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n// Check if the sensor has been activated on any secondary server.\nauto it = _servers.find(sensor_id);\nif (it == _servers.end()) {\nLOG_ERROR(\"Sensor %d not found on any server.\", sensor_id);\nreturn;\n}\n\n// Create a buffer with the sensor ID and send an ENABLE_ROS command to the server.\nauto fut = _router->WriteToOne(it->second, {ENABLE_ROS, sensor_id});\n\n// Wait for and process the server's response.\nauto response = fut.get();\nif (response.status != Status::OK) {\nLOG_ERROR(\"Server %s returned error %s.\", it->second.c_str(), GetStatusString(response.status).c_str());\nreturn;\n}\n\n// Add the server to the list of ROS enabled servers.\n_ros_enabled_servers.push_back(it->second);\n}", "CodeBleu_score": 57.482401749056145}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Get the server ID for the sensor.\n\tauto server_id = GetServerID(sensor_id);\n\tif (server_id == INVALID_SERVER_ID) {\n\t\t// The sensor was not found on any server.\n\t\tlog_error(\"Sensor %d was not found on any server.\", sensor_id);\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID.\n\tauto buffer = std::make_shared<Buffer>();\n\tbuffer->AddInt(sensor_id);\n\n\t// Send the ENABLE_ROS command to the server using the router.\n\tauto fut = _router->WriteToOne(server_id, ENABLE_ROS, buffer);\n\n\t// Wait for and process the server's response.\n\tauto response = fut.get();\n\tif (response.status != STATUS_OK) {\n\t\tlog_error(\"Received error status %d from server %d.\", response.status, server_id);\n\t\treturn;\n\t}\n}", "CodeBleu_score": 50.452871242098475}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tdata_lock.lock();\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"found a token for sensor \", sensor_id);\n    data_lock.unlock();\n    return it->second;\n  }\n  log_debug(\"asking for a token for sensor \", sensor_id);\n  token_type new_token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = new_token;\n  data_lock.unlock();\n  return new_token;\n}", "CodeBleu_score": 56.92284079548096}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\ttype: PrimaryCommands::GetToken, id: 1, stream_id: 0}", "CodeBleu_score": 3.820602543081103}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tname=\"GetToken\"\nlog_debug(\"getting token for \", sensor_id);\nauto it = _tokens.find(sensor_id);\nif (it != _tokens.end()) {\n  log_debug(\"found a token for \", sensor_id);\n  return it->second;\n}\n\nlog_debug(\"no token for \", sensor_id, \", asking for a new one\");\ntoken_type token = SendGetToken(sensor_id);\n_tokens[sensor_id] = token;\n_tokens_by_port[token.get_port()].push_back(sensor_id);\nreturn token;\n}", "CodeBleu_score": 58.837525052888694}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\n}", "CodeBleu_score": 4.959533208684141}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\n}", "CodeBleu_score": 4.959533208684141}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\n}", "CodeBleu_score": 4.959533208684141}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(m_crowd);\n\tDEBUG_ASSERT(m_ready);\n\n\t// Find the agent in the walker and vehicle mappings\n\tauto it_walker = _mapped_walkers_id.find(id);\n\tauto it_vehicle = _mapped_vehicles_id.find(id);\n\n\t// If the agent is not found, return false\n\tif (it_walker == _mapped_walkers_id.end() && it_vehicle == _mapped_vehicles_id.end()) {\n\t\treturn false;\n\t}\n\n\t// Enter a critical section to safely remove the agent from the crowd\n\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\t// Remove the agent from the crowd\n\tif (it_walker != _mapped_walkers_id.end()) {\n\t\t_walker_manager.RemoveWalker(it_walker->second);\n\t\t_mapped_walkers_id.erase(it_walker);\n\t} else {\n\t\t_crowd->removeAgent(it_vehicle->second);\n\t\t_mapped_vehicles_id.erase(it_vehicle);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 52.75309945719264}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(_crowd);\n\tif (id == INVALID_ACTOR_ID) {\n\t\treturn false;\n\t}\n\n\t// Find the agent in the walker and vehicle mappings.\n\tauto it_walker = _mapped_walkers_id.find(id);\n\tauto it_vehicle = _mapped_vehicles_id.find(id);\n\n\t// If the agent is not found in either mapping, return false.\n\tif (it_walker == _mapped_walkers_id.end() && it_vehicle == _mapped_vehicles_id.end()) {\n\t\treturn false;\n\t}\n\n\t// Enter a critical section to remove the agent from the crowd.\n\t_crowd->lock(_lock);\n\n\t// Remove the agent from the crowd.\n\tif (it_walker != _mapped_walkers_id.end()) {\n\t\t_walker_manager.RemoveWalker(it_walker->second);\n\t\t_mapped_walkers_id.erase(it_walker);\n\t} else {\n\t\t_crowd->removeAgent(it_vehicle->second);\n\t\t_mapped_vehicles_id.erase(it_vehicle);\n\t}\n\n\t// Exit the critical section.\n\t_crowd->unlock(_lock);\n\n\t// Update the vehicle manager and return true.\n\t_vehicle_manager.RemoveVehicle(id);\n\treturn true;\n}", "CodeBleu_score": 52.7030874791855}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(_crowd);\n\tDEBUG_ASSERT(_ready);\n\tbool found = false;\n\tauto it_walkers = _mapped_walkers_id.find(id);\n\tif (it_walkers != _mapped_walkers_id.end()) {\n\t\tfound = true;\n\t\tauto it_crowd = _mapped_by_index.find(it_walkers->second);\n\t\tDEBUG_ASSERT(it_crowd != _mapped_by_index.end());\n\t\t_crowd->removeAgent(it_crowd->second);\n\t\t_walker_manager.RemoveWalker(it_walkers->second);\n\t\t_mapped_walkers_id.erase(it_walkers);\n\t\t_mapped_by_index.erase(it_crowd);\n\t}\n\telse {\n\t\tauto it_vehicles = _mapped_vehicles_id.find(id);\n\t\tif (it_vehicles != _mapped_vehicles_id.end()) {\n\t\t\tfound = true;\n\t\t\tauto it_crowd = _mapped_by_index.find(it_vehicles->second);\n\t\t\tDEBUG_ASSERT(it_crowd != _mapped_by_index.end());\n\t\t\t_crowd->removeAgent(it_crowd->second);\n\t\t\t_vehicle_manager.RemoveVehicle(it_vehicles->second);\n\t\t\t_mapped_vehicles_id.erase(it_vehicles);\n\t\t\t_mapped_by_index.erase(it_crowd);\n\t\t}\n\t}\n\treturn found;\n}", "CodeBleu_score": 45.47056345970982}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n#ifndef NDEBUG\n  if (!vehicles.empty()) {\n    auto first = vehicles.front();\n    DEBUG_ASSERT(first.id != 0);\n    DEBUG_ASSERT(first.transform.location.x != 0.0f);\n    DEBUG_ASSERT(first.transform.location.y != 0.0f);\n    DEBUG_ASSERT(first.transform.location.z != 0.0f);\n    DEBUG_ASSERT(first.transform.rotation.roll == 0.0f);\n    DEBUG_ASSERT(first.transform.rotation.pitch == 0.0f);\n    DEBUG_ASSERT(first.transform.rotation.yaw != 0.0f);\n    DEBUG_ASSERT(first.bounding.extent.x != 0.0f);\n    DEBUG_ASSERT(first.bounding.extent.y != 0.0f);\n    DEBUG_ASSERT(first.bounding.extent.z != 0.0f);\n  }\n#endif\n\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // get the current list of ids\n  std::set<ActorId> current_ids;\n  for (auto &it : _mapped_vehicles_id) {\n    current_ids.insert(it.first);\n  }\n\n  // update the vehicles\n  for (auto &vehicle : vehicles) {\n    if (!AddOrUpdateVehicle(vehicle)) {\n      return false;\n    }\n  }\n\n  // remove the vehicles that are not in the list anymore\n  for (auto &id : current_ids) {\n    if (vehicles.end() == std::find_if(vehicles.begin(), vehicles.end(), [id](const VehicleCollisionInfo &v) { return v.id == id; })) {\n      if (!RemoveAgent(id)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 51.758355750792404}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n//  // check if all is ready\n//  if (!_ready) {\n//    return false;\n//  }\n//\n//  DEBUG_ASSERT(_crowd != nullptr);\n//\n//  // get the list of vehicles to be updated\n//  std::set<ActorId> updated;\n//  for (const auto &vehicle : vehicles) {\n//    updated.insert(vehicle.id);\n//  }\n//\n//  // remove vehicles not in the list\n//  for (auto it = _mapped_vehicles_id.begin(); it != _mapped_vehicles_id.end();) {\n//    if (updated.find(it->first) == updated.end()) {\n//      RemoveAgent(it->first);\n//      it = _mapped_vehicles_id.erase(it);\n//    } else {\n//      ++it;\n//    }\n//  }\n//\n//  // add or update vehicles\n//  for (const auto &vehicle : vehicles) {\n//    AddOrUpdateVehicle(vehicle);\n//  }\n//\n//  return true;\n}", "CodeBleu_score": 4.416942356730007}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n//    // check if all is ready\n//    if (!_ready) {\n//      return false;\n//    }\n//\n//    DEBUG_ASSERT(_crowd != nullptr);\n//\n//    // get the ids of all the vehicles\n//    std::set<ActorId> vehicle_ids;\n//    for (auto &vehicle : vehicles) {\n//      vehicle_ids.insert(vehicle.id);\n//    }\n//\n//    // remove all vehicles not in the list\n//    for (auto it = _mapped_vehicles_id.begin(); it != _mapped_vehicles_id.end(); ) {\n//      if (vehicle_ids.find(it->first) == vehicle_ids.end()) {\n//        RemoveAgent(it->first);\n//        it = _mapped_vehicles_id.begin();\n//      } else {\n//        it++;\n//      }\n//    }\n//\n//    // add or update the vehicles\n//    for (auto &vehicle : vehicles) {\n//      AddOrUpdateVehicle(vehicle);\n//    }\n//\n//    return true;\n}", "CodeBleu_score": 4.416942356730007}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tif (id < 0) {\n\t\treturn false;\n\t}\n\n\tauto actor = GetActor(id);\n\tif (actor == nullptr) {\n\t\treturn false;\n\t}\n\n\tauto walker = std::dynamic_pointer_cast<Walker>(actor);\n\tif (walker != nullptr) {\n\t\tauto it = _mapped_walkers_id.find(walker->GetId());\n\t\tif (it != _mapped_walkers_id.end()) {\n\t\t\treturn walker->HasVehicleNear(distance, direction);\n\t\t}\n\t}\n\n\tauto vehicle = std::dynamic_pointer_cast<Vehicle>(actor);\n\tif (vehicle != nullptr) {\n\t\tauto it = _mapped_vehicles_id.find(vehicle->GetId());\n\t\tif (it != _mapped_vehicles_id.end()) {\n\t\t\treturn vehicle->HasVehicleNear(distance, direction);\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 48.88297283909021}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t#ifdef DEBUG_NAVIGATION\n  std::cout << \"Navigation::HasVehicleNear\" << std::endl;\n#endif\n  boost::unique_lock<boost::shared_mutex> lock(_mutex);\n\n  // Check if the actor is a vehicle.\n  auto it_vehicles = _mapped_vehicles_id.find(id);\n  if (it_vehicles != _mapped_vehicles_id.end()) {\n    return HasVehicleNear(it_vehicles->second, distance, direction);\n  }\n\n  // Check if the actor is a walker.\n  auto it_walkers = _mapped_walkers_id.find(id);\n  if (it_walkers != _mapped_walkers_id.end()) {\n    return HasWalkerNear(it_walkers->second, distance, direction);\n  }\n\n  return false;\n}", "CodeBleu_score": 53.42167165304104}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the route point for the walker.\n\tRoutePoint &routePoint = info.route.GetCurrentRoutePoint();\n\t// Create the visitor.\n\tWalkerEventVisitor visitor(id, info, delta);\n\t// Visit the event.\n\tEventResult result = boost::apply_visitor(visitor, routePoint.event);\n\treturn result;\n}", "CodeBleu_score": 44.78940888521378}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tif (info.route.empty()) {\n\t\treturn EventResult::kContinue;\n\t}\n\tauto &walker = GetWalker(id);\n\tauto &route = info.route;\n\tauto &event = route.front();\n\tauto result = boost::variant2::visit(WalkerEventVisitor(walker, info, delta), event);\n\tif (result == EventResult::kContinue) {\n\t\troute.pop_front();\n\t}\n\treturn result;\n}", "CodeBleu_score": 45.85990485125014}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto route = info.route;\n\tif (!route.empty()) {\n\t\tauto point = route.front();\n\t\troute.pop_front();\n\t\tauto visitor = WalkerEventVisitor(id, info, delta);\n\t\tauto result = boost::apply_visitor(visitor, point);\n\t\treturn result;\n\t}\n\treturn EventResult::CONTINUE;\n}", "CodeBleu_score": 46.46835453635578}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * Iterates through each road node, extracting the road ID and processing each lane section within the lanes node.\n */\n    for (pugi::xml_node road_node : xml.children(\"road\")) {\n\n      // Road ID\n      const road::RoadId road_id = road_node.attribute(\"id\").as_int();\n\n      // Road Lanes\n      for (pugi::xml_node lanes_node : road_node.children(\"lanes\")) {\n\n        // Left Lane Sections\n        for (pugi::xml_node left_lanes_node : lanes_node.children(\"left\")) {\n          for (pugi::xml_node left_lane_node : left_lanes_node.children(\"lane\")) {\n            const double s = left_lane_node.attribute(\"s\").as_double();\n            ParseLanes(road_id, s, left_lane_node, map_builder);\n          }\n        }\n\n        // Center Lane Sections\n        for (pugi::xml_node center_lanes_node : lanes_node.children(\"center\")) {\n          for (pugi::xml_node center_lane_node : center_lanes_node.children(\"lane\")) {\n            const double s = center_lane_node.attribute(\"s\").as_double();\n            ParseLanes(road_id, s, center_lane_node, map_builder);\n          }\n        }\n\n        // Right Lane Sections\n        for (pugi::xml_node right_lanes_node : lanes_node.children(\"right\")) {\n          for (pugi::xml_node right_lane_node : right_lanes_node.children(\"lane\")) {\n            const double s = right_lane_node.attribute(\"s\").as_double();\n            ParseLanes(road_id, s, right_lane_node, map_builder);\n          }\n        }\n      }\n    }\n  }", "CodeBleu_score": 63.98408239355443}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node\nfor (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n  // Extract road ID\n  road::RoadId road_id = road_node.attribute(\"id\").as_int();\n\n  // Iterate through each lane section node\n  for (pugi::xml_node lane_section_node : road_node.children(\"laneSection\")) {\n\n    // Extract lane section ID\n    const road::LaneSectionId lane_section_id = lane_section_node.attribute(\"id\").as_int();\n\n    // Iterate through each left lane node\n    for (pugi::xml_node left_lane_node : lane_section_node.children(\"left\")) {\n\n      // Extract left lane ID\n      const road::LaneId left_lane_id = left_lane_node.attribute(\"id\").as_int();\n\n      // Parse left lane\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          left_lane_id,\n          left_lane_node,\n          map_builder);\n    }\n\n    // Iterate through each center lane node\n    for (pugi::xml_node center_lane_node : lane_section_node.children(\"center\")) {\n\n      // Extract center lane ID\n      const road::LaneId center_lane_id = center_lane_node.attribute(\"id\").as_int();\n\n      // Parse center lane\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          center_lane_id,\n          center_lane_node,\n          map_builder);\n    }\n\n    // Iterate through each right lane node\n    for (pugi::xml_node right_lane_node : lane_section_node.children(\"right\")) {\n\n      // Extract right lane ID\n      const road::LaneId right_lane_id = right_lane_node.attribute(\"id\").as_int();\n\n      // Parse right lane\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          right_lane_id,\n          right_lane_node,\n          map_builder);\n    }\n  }\n}\n}", "CodeBleu_score": 57.26586831718574}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node and extract the road ID\n  for (pugi::xml_node road_node : xml.children(\"road\")) {\n\n    road::RoadId road_id = road_node.attribute(\"id\").as_int();\n\n    // Iterate through each lane section\n    for (pugi::xml_node lane_section_node : road_node.children(\"lanes\")) {\n\n      // Retrieve the lane section ID\n      road::LaneSectionId lane_section_id = lane_section_node.attribute(\"id\").as_int();\n\n      // Retrieve the lane section s value\n      double s = lane_section_node.attribute(\"s\").as_double();\n\n      // Retrieve the left, center, and right lane nodes\n      pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n      pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n      pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n      // Parse the left, center, and right lane nodes\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          left_lane_node,\n          s,\n          map_builder);\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          center_lane_node,\n          s,\n          map_builder);\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          right_lane_node,\n          s,\n          map_builder);\n\n    }\n\n  }\n}", "CodeBleu_score": 63.1038072177349}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (info.current_count_change == 1) {\n\t\tif (matched_ == 0) {\n\t\t\tmatched_ = 1;\n\t\t\tmatched_writer_ = writer;\n\t\t} else {\n\t\t\tstd::cout << \"Error: received more than one matched status on CarlaListener\" << std::endl;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tif (matched_ == 1) {\n\t\t\tmatched_ = 0;\n\t\t\tmatched_writer_ = nullptr;\n\t\t} else if (matched_ == 0) {\n\t\t\tstd::cout << \"Error: received more than one unmatched status on CarlaListener\" << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Error: received invalid matched status on CarlaListener\" << std::endl;\n\t}\n}", "CodeBleu_score": 41.26056428993222}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (info.total_count == info.total_count_change) {\n\t\tif (info.total_count == 1) {\n\t\t\tmatched_ = true;\n\t\t\tmatched_count_ = info.total_count;\n\t\t\tconnection_ = writer;\n\t\t} else if (info.total_count == 0) {\n\t\t\tmatched_ = false;\n\t\t\tmatched_count_ = info.total_count;\n\t\t\tconnection_ = nullptr;\n\t\t} else {\n\t\t\tstd::cout << \"Invalid matched count: \" << info.total_count << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Invalid matched count change: \" << info.total_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 43.203983872224484}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (info.current_count_change == 1) {\n\t\tif (matched_ == 0) {\n\t\t\tmatched_ = 1;\n\t\t\tmatched_writer_ = writer;\n\t\t} else {\n\t\t\tstd::cout << \"New match discovered on topic \" << info.topic_name << std::endl;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tif (matched_ == 1 && matched_writer_ == writer) {\n\t\t\tmatched_ = 0;\n\t\t\tmatched_writer_ = nullptr;\n\t\t} else if (matched_ != 0) {\n\t\t\tstd::cout << \"Match lost on topic \" << info.topic_name << std::endl;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Unexpected change on topic \" << info.topic_name << std::endl;\n\t}\n}", "CodeBleu_score": 45.11323196840485}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// New match.\n\t\t++_matched_subscriptions;\n\t\tif (_matched_subscriptions == 1) {\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t// Removed match.\n\t\t--_matched_subscriptions;\n\t\tif (_matched_subscriptions == 0) {\n\t\t\t// No more matches.\n\t\t\t_subscriber->Destroy();\n\t\t}\n\t} else {\n\t\t// Log error.\n\t\t_log_error(\"Invalid matched count change {}.\", info.current_count_change);\n\t}\n}", "CodeBleu_score": 57.0610809999941}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t_matched_readers++;\n\t\tif (_matched_readers == 1) {\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t_matched_readers--;\n\t\tif (_matched_readers == 0) {\n\t\t\t_subscriber->destroy();\n\t\t}\n\t} else {\n\t\tCARLA_LOG_ERROR(\"Received invalid matched count change on DataReader\")\n\t}\n}", "CodeBleu_score": 52.50596279580586}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// New match.\n\t\t++_matched_subscriptions;\n\t\tif (_matched_subscriptions == 1) {\n\t\t\t// First match.\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t// Removed match.\n\t\t--_matched_subscriptions;\n\t\tif (_matched_subscriptions == 0) {\n\t\t\t// No more matches.\n\t\t\t_subscriber->destroy();\n\t\t}\n\t} else {\n\t\t// Error.\n\t\tif (info.current_count_change != 0) {\n\t\t\tUERROR(\"Unexpected count change %d on topic %s\", info.current_count_change, reader->topic().c_str());\n\t\t}\n\t}\n}", "CodeBleu_score": 51.72201391828277}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\nreturn false;\n}\n\nCarlaCollisionEvent* p_type = reinterpret_cast<CarlaCollisionEvent*>(data);\n\n// Get serialized size of key and prepare buffer\nuint32_t key_max_size = CarlaCollisionEvent::getKeyMaxCdrSerializedSize();\nbyte* buffer = (byte*) calloc(key_max_size, 1);\n\n// Serialize key into buffer\nuint32_t cdr_size = p_type->serializeKey(buffer, 0, key_max_size);\nif (cdr_size > key_max_size) {\nfree(buffer);\nreturn false;\n}\n\nassert(cdr_size <= key_max_size);\n\n// Copy buffer to handle\nif (force_md5 || m_useMd5) {\nMD5 md5;\nmd5.update(buffer, static_cast<uint32_t>(cdr_size));\nmd5.finalize();\nfor (int i = 0; i < 16; ++i) {\nhandle->at(i) = md5.digest[i];\n}\n} else {\nfor (int i = 0; i < cdr_size; ++i) {\nhandle->at(i) = buffer[i];\n}\n}\n\nfree(buffer);\nreturn true;\n}", "CodeBleu_score": 54.58389645344566}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t(void)m_md5;\n\n\n\nreturn true;\n}", "CodeBleu_score": 2.8131193264738963}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\nreturn false;\n}\nif (force_md5 || m_keyBuffer.empty()) {\nSerializedPayload_t payload(MAX_SUBMESSAGE_LENGTH);\npayload.data = static_cast<uint8_t*>(data);\npayload.max_size = MAX_SUBMESSAGE_LENGTH;\nif (!m_md5.init()) {\nreturn false;\n}\n\nm_md5.update(payload.data, static_cast<size_t>(payload.length));\nm_md5.finalize();\n\nfor (uint8_t i = 0; i < 14; ++i) {\nm_keyBuffer.push_back(m_md5.digest[i]);\n}\n} else {\nif (handle->size() != m_keyBuffer.size()) {\nhandle->clear();\nfor (uint8_t i = 0; i < m_keyBuffer.size(); ++i) {\nhandle->push_back(m_keyBuffer[i]);\n}\n}\n}\n\nreturn true;\n}", "CodeBleu_score": 47.00751454688361}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t(void)payload;\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n\n\ttry {\n\t\tcdr ser(payload+1);\n\t\tif (p_type->serialize(ser)) {\n\t\t\tpayload->length = ser.getSerializedDataLength();\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcatch (std::bad_alloc& e) {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 34.16261003994115}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t// Wrap the plain buffer into the serialized payload\n\t// to be able to add the meta-data.\n\tCdr cdr(payload);\n\tbool ok = cdr.serialize(data);\n\tif (!ok) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 19.891067185828856}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t(void)payload;\nCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\ntry {\ncdr << p_type->throttle;\ncdr << p_type->steer;\ncdr << p_type->brake;\ncdr << p_type->hand_brake;\ncdr << p_type->reverse;\ncdr << p_type->manual_gear_shift;\ncdr << p_type->gear;\ncdr << p_type->hand_brake_input;\ncdr << p_type->is_player_control;\n} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\nreturn false;\n}\n\nreturn true;\n}", "CodeBleu_score": 39.73263463924779}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (g.sysid_target != 0) {\n\t\treturn;\n\t}\n\n\tmavlink_message_t msg_copy;\n\tmavlink_msg_heartbeat_decode(&msg_copy, &msg);\n\n\tif (msg_copy.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n\t\treturn;\n\t}\n\n\tif (msg_copy.sysid != g.sysid_target) {\n\t\tg.sysid_target = msg_copy.sysid;\n\t\ttracker.gcs().request_datastream_position(g.sysid_target);\n\t\ttracker.gcs().request_datastream_airpressure(g.sysid_target);\n\t}\n\n\tg.target_set = true;\n}", "CodeBleu_score": 44.987280996195686}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n\t// If the base class handler accepted the command, set the flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\n\t// Return the result of the base class handler\n\treturn result;\n}", "CodeBleu_score": 65.54291762407973}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK_BaseClass::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_required = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 63.34510010674526}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK_BaseClass::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 64.42759279406879}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tif (packet.param1 == 1.0) {\n\t\tresult = tracker.arm_servos();\n\t}\n\telse if (packet.param1 == 0.0) {\n\t\tresult = tracker.disarm_servos();\n\t}\n\treturn result;\n}", "CodeBleu_score": 51.179656406918326}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t}\n\telse if (packet.param1 == 0.0) {\n\t\ttracker.disarm_servos();\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t}\n\treturn result;\n}", "CodeBleu_score": 57.5804987031734}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.29383879107523}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t", "CodeBleu_score": 5.5394447414533605}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t", "CodeBleu_score": 5.5394447414533605}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Check if the payload space is available for the requested data stream\n\tif (payload_space_available(sysid, compid, MAVLINK_MSG_ID_POSITION_TARGET)) {\n\t\t// Iterate over the available GCS channels\n\t\tfor (int i = 0; i < num_gcs; i++) {\n\t\t\t// Check if the GCS channel is available\n\t\t\tif (gcs_channels[i].available) {\n\t\t\t\t// Check if the GCS channel has a matching system and component ID\n\t\t\t\tif (gcs_channels[i].sysid == sysid && gcs_channels[i].compid == compid) {\n\t\t\t\t\t// Check if the GCS channel has a valid channel ID\n\t\t\t\t\tif (gcs_channels[i].channel_id != 0) {\n\t\t\t\t\t\t// Send a request to start the data stream\n\t\t\t\t\t\tmavlink_msg_request_data_stream_send(\n\t\t\t\t\t\t\tMAV_BROADCAST,\n\t\t\t\t\t\t\tgcs_channels[i].channel_id,\n\t\t\t\t\t\t\tsysid,\n\t\t\t\t\t\t\tcompid,\n\t\t\t\t\t\t\tMAVLINK_MSG_ID_POSITION_TARGET,\n\t\t\t\t\t\t\tMAVLINK_DATATYPE_FLOAT_ARRAY,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.462349533509474}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\nAP::ahrs\nif (ahrs.cos_pitch == 0) {\nreturn false;\n}\n\nef_pitch = atan2(ahrs.sin_roll * sin(pitch) + ahrs.cos_roll * cos(pitch), ahrs.cos_pitch * cos(pitch));\nef_yaw = atan2(ahrs.sin_roll * sin(yaw) + ahrs.cos_roll * cos(yaw), ahrs.cos_pitch * cos(yaw));\nreturn true;\n}", "CodeBleu_score": 50.86744246598215}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAP::ahrs\n\tif (ahrs.cos_pitch == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = atan2(ahrs.sin_roll * ahrs.sin_pitch + ahrs.cos_roll * ahrs.cos_pitch * cos(yaw), ahrs.cos_pitch * sin(yaw));\n\tef_yaw = atan2(-ahrs.cos_roll * ahrs.sin_pitch + ahrs.sin_roll * ahrs.cos_pitch * cos(yaw), ahrs.cos_roll * ahrs.cos_pitch * sin(yaw) - ahrs.sin_roll * sin(yaw));\n\treturn true;\n}", "CodeBleu_score": 40.608440546302155}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch == 0) {\n\t\treturn false;\n\t}\n\n\tef_pitch = atan2(ahrs.sin_roll * sin(pitch) + ahrs.cos_roll * cos(pitch) * cos(yaw), ahrs.cos_roll * sin(yaw) - ahrs.sin_roll * cos(yaw) * cos(pitch));\n\tef_yaw = atan2(-ahrs.sin_roll * cos(pitch) * sin(yaw) + ahrs.cos_roll * cos(yaw) * sin(pitch), ahrs.cos_roll * cos(pitch) * cos(yaw) - ahrs.sin_roll * sin(yaw) * sin(pitch));\n\n\treturn true;\n}", "CodeBleu_score": 49.87996729104972}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// get yaw and pitch targets from navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float yaw_target = wrap_180_cd(nav_status.bearing + tracker.g.yaw_trim);\n    float pitch_target = nav_status.distance_to_target;\n\n    // check if direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    calc_angle_error(pitch_target, yaw_target, direction_reversed);\n\n    // convert body frame errors to earth frame\n    float bf_pitch_err = tracker.nav_status.angle_error_pitch;\n    float bf_yaw_err = tracker.nav_status.angle_error_yaw;\n    float ef_pitch_err;\n    float ef_yaw_err;\n    convert_bf_to_ef(bf_pitch_err, bf_yaw_err, ef_pitch_err, ef_yaw_err);\n\n    // update pitch and yaw servos\n    tracker.update_pitch_servo(ef_pitch_err, direction_reversed);\n    tracker.update_yaw_servo(ef_yaw_err, direction_reversed);\n}", "CodeBleu_score": 53.15223177575774}, {"code": "void Mode::update_auto(void){\n\t\t// update yaw and pitch targets\n    Parameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    nav_status.yaw_target_cd = wrap_180_cd((nav_status.bearing+g.yaw_trim)*100);\n    nav_status.pitch_target_cd = constrain_float(nav_status.distance_cm * g.pitch_scale, g.pitch_min * 100, g.pitch_max * 100);\n\n    // check if direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error\n    calc_angle_error(nav_status.pitch_target_cd, nav_status.yaw_target_cd, direction_reversed);\n\n    // update servos\n    tracker.update_yaw_servo();\n    tracker.update_pitch_servo();\n}", "CodeBleu_score": 46.26994920733007}, {"code": "void Mode::update_auto(void){\n\t\t// update yaw and pitch from navigation status\n\tstruct Tracker::NavStatus &nav_status = tracker.nav_status;\n\tfloat yaw_cd = nav_status.bearing * 100;\n\tfloat pitch_cd = nav_status.pitch * 100;\n\n\t// check if direction is reversed\n\tbool direction_reversed = get_ef_yaw_direction();\n\n\t// calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n\tcalc_angle_error(pitch_cd, yaw_cd, direction_reversed);\n\n\t// update yaw and pitch servos\n\ttracker.update_yaw_servo();\n\ttracker.update_pitch_servo();\n}", "CodeBleu_score": 32.26250539493633}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS data\n\tgps.update();\n\t// Check if the last message time has changed\n\tif (gps.last_message_time_ms != last_message_time_ms) {\n\t\t// Update the last message time\n\t\tlast_message_time_ms = gps.last_message_time_ms;\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (gps.status >= 3) {\n\t\t\t// Update the GPS location\n\t\t\tgps_location = gps.location;\n\t\t\t// Check if the GPS location is valid\n\t\t\tif (gps_location.is_valid()) {\n\t\t\t\t// Check if the home location has been set\n\t\t\t\tif (home_location.is_valid()) {\n\t\t\t\t\t// Check if the home location is within 100m of the current location\n\t\t\t\t\tif (gps_location.distance(home_location) < 100) {\n\t\t\t\t\t\t// Check if the countdown is at zero\n\t\t\t\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t\t\t\t// Set the ground start countdown\n\t\t\t\t\t\t\tground_start_countdown = 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Reset the ground start countdown\n\t\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\tset_home();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Reset the ground start countdown\n\t\t\t\tground_start_countdown = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t// Reset the ground start countdown\n\t\t\tground_start_countdown = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.9893717482812}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS data\n\tgps.update();\n\n\t// Check if the last message time has changed\n\tif (gps.last_message_time_ms != last_gps_message_time_ms) {\n\t\t// Reset the countdown\n\t\tground_start_countdown = ground_start_countdown_max;\n\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (gps.status >= 3) {\n\t\t\t// Check if the current location is valid\n\t\t\tif (gps.location.is_valid()) {\n\t\t\t\t// Set the home location\n\t\t\t\tset_home();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Reset the countdown\n\t\t\t\tground_start_countdown = ground_start_countdown_max;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Reset the countdown\n\t\t\tground_start_countdown = ground_start_countdown_max;\n\t\t}\n\n\t\t// Update the last message time\n\t\tlast_gps_message_time_ms = gps.last_message_time_ms;\n\t}\n}", "CodeBleu_score": 36.37096876269832}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update GPS data\n\tgps.update();\n\t// Check if the last message time has changed\n\tif (gps.last_message_time_ms != last_message_time_ms) {\n\t\t// Check if the GPS status is 3D fix\n\t\tif (gps.status >= 3) {\n\t\t\t// Set the last message time\n\t\t\tlast_message_time_ms = gps.last_message_time_ms;\n\t\t\t// Check if ground start is enabled\n\t\t\tif (ground_start_enabled) {\n\t\t\t\t// Check if the countdown is at zero\n\t\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\tset_home();\n\t\t\t\t\t// Reset the countdown\n\t\t\t\t\tground_start_countdown = ground_start_delay;\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the countdown\n\t\t\t\t\tground_start_countdown--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.94433577698169}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0) {\n\t\tif (pitch < 90.0) {\n\t\t\t_pitch_onoff_servo.set_output_position(pitch);\n\t\t} else {\n\t\t\t_pitch_onoff_servo.set_output_position(90.0);\n\t\t}\n\t} else {\n\t\tif (pitch > -90.0) {\n\t\t\t_pitch_onoff_servo.set_output_position(pitch);\n\t\t} else {\n\t\t\t_pitch_onoff_servo.set_output_position(-90.0);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.051426470851435}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (fabsf(pitch) < 0.01) {\n\t\tif (_pitch_onoff_servo_enabled) {\n\t\t\t_pitch_onoff_servo.set_output_raw(0);\n\t\t\t_pitch_onoff_servo_enabled = false;\n\t\t}\n\n\t} else {\n\t\tif (!_pitch_onoff_servo_enabled) {\n\t\t\t_pitch_onoff_servo.set_output_raw(1000);\n\t\t\t_pitch_onoff_servo_enabled = true;\n\t\t}\n\n\t\t_pitch_onoff_servo.set_output_raw(constrain_int(int(1000.0f * pitch), 1000, 2000));\n\t}\n}", "CodeBleu_score": 23.56207610423854}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\n#ifdef DEBUG_PRINT\n    Serial.print(\"update_pitch_onoff_servo: \");\n    Serial.println(pitch);\n#endif\n\n    if (pitch < 0) {\n        // turn on servo\n        if (pitch_onoff_servo_pos < 127) {\n            pitch_onoff_servo_pos++;\n        }\n    } else {\n        // turn off servo\n        if (pitch_onoff_servo_pos > 0) {\n            pitch_onoff_servo_pos--;\n        }\n    }\n\n    if (pitch_onoff_servo_pos > 0) {\n        digitalWrite(PITCH_ONOFF_SERVO_PIN, HIGH);\n    } else {\n        digitalWrite(PITCH_ONOFF_SERVO_PIN, LOW);\n    }\n\n    pwmWrite(PITCH_ONOFF_SERVO_PIN, pitch_onoff_servo_pos);\n}", "CodeBleu_score": 32.40505763732645}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// check if we have a valid baro reference\nif (baro.last_update_time == 0) {\nif (display_failure) {\narming_check_failed(ARMING_CHECK_BARO, \"Baro reference not set\");\n}\nreturn false;\n}\n// get the baro altitude\nfloat baro_alt_cm = baro.get_altitude_cm();\n// get the inertial nav altitude\nfloat nav_alt_cm = copter.inertial_nav.get_altitude_cm();\n// calculate the disparity\nfloat disparity = fabsf(baro_alt_cm - nav_alt_cm);\n// check if the disparity is too high\nif (disparity > ARMING_CHECK_BARO_MAX_DISPARITY_CM) {\nif (display_failure) {\narming_check_failed(ARMING_CHECK_BARO, \"Baro altitude disparity too large\");\n}\nreturn false;\n}\n// disparity is within limits\nreturn true;\n}", "CodeBleu_score": 40.126904823523134}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\nreturn false;\n}\nif (g.baro_check_enabled) {\nfloat baro_alt_cm = g.baro_alt_estimate.get_relative_altitude(g.baro_alt_estimate_home);\nfloat nav_alt_cm = copter.inertial_nav.get_position_z_up_cm();\nif (fabsf(baro_alt_cm - nav_alt_cm) > BARO_ARMING_ALT_DISPARITY_CM) {\nif (display_failure) {\narming_failure(ARMING_CHECK_BARO, \"Barometer altitude disparity too large\");\n}\nreturn false;\n}\n}\nreturn true;\n}", "CodeBleu_score": 44.93926343357955}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tbool success = AP_Arming::barometer_checks(display_failure);\n\nif (success && (g.baro_enabled == true) && (g.baro_check_enabled == true) && (g.baro_check_alt_enabled == true)) {\nfloat baro_alt_cm = g.baro_alt_cm;\nfloat inertial_alt_cm = copter.inertial_nav.get_position_z_up_cm();\nfloat baro_alt_error_cm = baro_alt_cm - inertial_alt_cm;\n\nif (fabsf(baro_alt_error_cm) > g.baro_check_alt_max_error_cm) {\nif (display_failure) {\narming_check_fail(ARMING_CHECK_BARO, ARMING_CHECK_FAIL_ALT_ERROR);\n}\nreturn false;\n}\n}\nreturn true;\n}", "CodeBleu_score": 44.79432971094155}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t", "CodeBleu_score": 4.940593392785424}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (_mode->get_alt_type() == RangeFinder) {\nreturn false;\n}\nif (_mode->get_alt_type() == Terrain && _mode->get_rtl_alt_type() == RangeFinder) {\nreturn true;\n}\nreturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 55.94751867188093}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t// If the terrain source is from a rangefinder, it returns false.\nif (_copter.get_terrain_source() == RangeFinder) {\nreturn false;\n}\n// If the terrain source is from the terrain database and the RTL altitude type is terrain, it returns true.\nif (_copter.get_terrain_source() == TerrainDB && _copter.mode_rtl.get_alt_type() == RangeFinder::Terrain) {\nreturn true;\n}\n// Otherwise, it defers to the base class implementation of terrain_database_required.\nreturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.95175072631145}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// set dt for attitude, position, and motor controllers using the last loop time from the scheduler\n\tattitude_control->set_dt(AP.scheduler.get_last_loop_time_s());\n\tpos_control->set_dt(AP.scheduler.get_last_loop_time_s());\n\tmotors->set_dt(AP.scheduler.get_last_loop_time_s());\n\n\t// run attitude controller\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 44.15225485780314}, {"code": "void Copter::run_rate_controller(){\n\t\n// get the last loop time from the scheduler\nfloat dt = AP_Scheduler::get_instance()->get_last_loop_time_s();\n\n// set dt for controllers\nattitude_control->set_dt(dt);\npos_control->set_dt(dt);\nmotors->set_dt(dt);\n\n// run the attitude controller\nattitude_control->rate_controller_run();\n}", "CodeBleu_score": 60.530002890361104}, {"code": "void Copter::run_rate_controller(){\n\t\t// set dt for attitude and rate controllers\n\trate_controller_run();\n\t// run attitude controller\n\tattitude_control->run();\n}", "CodeBleu_score": 11.439359395062732}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// get next waypoint\n\tconst Location &wp = get_wp();\n\n\t// check if the old and new locations are the same\n\tif (old_loc.same_loc_as(wp) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n\t\t// if the old and new locations are the same, update the target location\n\t\tset_target_location(wp);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 60.65466215163826}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t#if FRAME_CONFIG == HELI_FRAME\n    // if the old and new locations are the same, return true\n    if (old_loc.same_loc_as(new_loc)) {\n        return true;\n    }\n#else\n    // if the old and new locations are the same, return true\n    if (old_loc.get_lat() == new_loc.get_lat() &&\n        old_loc.get_lng() == new_loc.get_lng() &&\n        old_loc.get_alt() == new_loc.get_alt()) {\n        return true;\n    }\n#endif\n\n    // if the old location matches the next waypoint and the altitude frames are the same, set the new location as the target and return true\n    if (new_loc.get_alt_frame() == old_loc.get_alt_frame() &&\n        new_loc.get_lat() == wp_nav.get_wp_location(wp_nav.get_current_wp()).lat &&\n        new_loc.get_lng() == wp_nav.get_wp_location(wp_nav.get_current_wp()).lng) {\n        set_target_location(new_loc);\n        return true;\n    }\n\n    // if the old location does not match the next waypoint, return false\n    return false;\n}", "CodeBleu_score": 52.86681213973017}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t//    // exit if vehicle is not in Guided mode or Auto-Guided mode\n//    if (!flightmode->in_guided_mode()) {\n//        return false;\n//    }\n//\n//    // get the next waypoint location\n//    Location wp = get_wp();\n//\n//    // if the old location matches the next waypoint location and the altitude frames of the old and new locations are the same\n//    if (old_loc.same_loc_as(wp) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n//        // set the new location as the target\n//        set_target_location(new_loc);\n//\n//        // return true\n//        return true;\n//    }\n//\n//    // return false\n//    return false;\n}", "CodeBleu_score": 6.5492355507845295}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AUX_SWITCH_POS_HIGH) {\nif (mode == mode_number) {\nrc().reset_mode_switch();\n} else {\nset_mode(mode);\n}\n} else {\nif (mode == mode_number) {\nrc().reset_mode_switch();\n}\n}\n}", "CodeBleu_score": 51.17342833831384}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t", "CodeBleu_score": 6.660368524040123}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (set_mode(mode)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (mode == _mode_switch_mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 41.40469037094111}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\n}", "CodeBleu_score": 2.7694730809033348}, {"code": "void Copter::save_trim(){\n\t\t// get the control inputs\n\tfloat roll_in = channel_roll->get_control_in(0);\n\tfloat pitch_in = channel_pitch->get_control_in(0);\n\n\t// convert to radians\n\tfloat roll = ToRad(roll_in);\n\tfloat pitch = ToRad(pitch_in);\n\n\t// add to the trim\n\tahrs.add_trim(roll, pitch);\n\n\t// log the event\n\tlog_message(mavlink_msg_id_command_ack, 0, \"roll trim: %.1f, pitch trim: %.1f\", roll_in, pitch_in);\n\n\t// send a confirmation message\n\tgcs().send_text_fmt(PSTR(\"roll trim: %.1f, pitch trim: %.1f\"), roll_in, pitch_in);\n}", "CodeBleu_score": 46.71271769196272}, {"code": "void Copter::save_trim(){\n\t\tfloat roll_trim_input = 0;\n\tfloat pitch_trim_input = 0;\n\tfloat roll_trim_radians = 0;\n\tfloat pitch_trim_radians = 0;\n\n\t/*\n\t * Get the roll and pitch trim inputs from the control inputs of the roll and pitch channels.\n\t */\n\troll_trim_input = channel_roll->get_control_in();\n\tpitch_trim_input = channel_pitch->get_control_in();\n\n\t/*\n\t * Convert the trim inputs from degrees to radians.\n\t */\n\troll_trim_radians = roll_trim_input * (M_PI / 180.0f);\n\tpitch_trim_radians = pitch_trim_input * (M_PI / 180.0f);\n\n\t/*\n\t * Add the trim values to the AHRS trim.\n\t */\n\tahrs.add_trim(roll_trim_radians, pitch_trim_radians);\n\n\t/*\n\t * Log the trim values.\n\t */\n\tlog_message(mavlink_msg_id_command_long_encode(0, 0, MAVLINK_MSG_ID_COMMAND_LONG, 2, 1, 176, 0, 0, 0, 0, 0, 0, roll_trim_input, pitch_trim_input, 0, 0, 0, 0), \"roll_trim_input: %f, pitch_trim_input: %f\", roll_trim_input, pitch_trim_input);\n\n\t/*\n\t * Send a confirmation message with MAV_SEVERITY_INFO.\n\t */\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Saved trim values\");\n}", "CodeBleu_score": 45.958549647090194}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// Retrieve the copter's velocity\nVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n// Calculate the speed squared\nfloat speed_sq = vel.xy().length_squared();\n// If the copter's position is valid and the speed exceeds the minimum threshold, update the look-ahead yaw angle\nif (copter.position_ok && speed_sq > MIN_SPEED_SQ) {\n// Calculate the look-ahead yaw angle\nfloat look_ahead_yaw = atan2f(vel.y, vel.x);\n// Wrap the angle to be within the range [-pi, pi]\nlook_ahead_yaw = wrap_pi(look_ahead_yaw);\n// Update the look-ahead yaw angle\nlook_ahead_yaw_angle = look_ahead_yaw;\n}\n// Return the look-ahead yaw angle\nreturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 59.91788244716535}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (copter.position_ok) {\n\t\tfloat speed_squared = vel.xy().length_squared();\n\t\tif (speed_squared > MIN_SPEED_SQUARED) {\n\t\t\tfloat yaw_angle = atan2f(vel.y, vel.x);\n\t\t\treturn degrees(yaw_angle);\n\t\t}\n\t}\n\treturn 0.0f;\n}", "CodeBleu_score": 35.24224477956667}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\nfloat yaw_angle = 0.0f;\n\nif (copter.position_ok) {\n\n// Get the velocity vector of the copter in the body frame\nVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n// Calculate the speed squared\nfloat speed_squared = vel.xy().length_squared();\n\n// If the speed is greater than the minimum threshold, compute the look-ahead yaw angle\nif (speed_squared > MIN_SPEED_SQUARED) {\n\n// Compute the look-ahead yaw angle\nyaw_angle = atan2f(vel.y, vel.x);\n}\n}\n\nreturn yaw_angle;\n}", "CodeBleu_score": 47.80720611703355}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER && (g.disable_rudder_arming || get_throttle_input() != 0)) {\nreturn false;\n}\nif (g.disable_arming_checks || hal.util->was_watchdog_armed()) {\nreturn true;\n}\nreturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 45.07014889734509}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (arming_checks_disabled() || hal.util->was_watchdog_armed()) {\nreturn true;\n}\nswitch (method) {\ncase AP_Arming::RUDDER:\nif (plane.get_throttle_input() != 0) {\nreturn false;\n}\nif (g.disable_rudder_arming) {\nreturn false;\n}\nbreak;\ndefault:\nbreak;\n}\nreturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 40.19308096495774}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (g.ARMED == AP_HAL::Arming_State::ARMED || g.ARMED == AP_HAL::Arming_State::ALWAYS_ARMED) {\nreturn true;\n}\nif (method == AP_Arming::RUDDER) {\nif (g.rc_rudder_reverse == AP_Param::RC_REVERSE::ALWAYS_REVERSE || (g.rc_rudder_reverse == AP_Param::RC_REVERSE::NORMAL && gcs.radio.rudder_available())) {\nreturn !gcs.radio.rudder_enabled() || !gcs.radio.rudder_override() || g.throttle_zero_override;\n} else {\nreturn false;\n}\n}\nif (hal.util.get_soft_armed()) {\nreturn true;\n}\nif (hal.util.was_watchdog_armed()) {\nreturn true;\n}\nreturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 54.94439282898136}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// check if the vehicle is already armed\n    if (armed) {\n        if (display_failure) {\n            // display a failure message\n            AP_Notify::object_arming_failed(AP_Notify::REASON_ALREADY_ARMED);\n        }\n        return true;\n    }\n\n    // check if the vehicle has a disarm function\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            // display a failure message\n            AP_Notify::object_arming_failed(AP_Notify::REASON_NO_DISARM_FUNCTION);\n        }\n        return false;\n    }\n\n    // perform the standard pre-arm checks\n    return AP_Arming::pre_arm_checks();\n}", "CodeBleu_score": 59.92894887174693}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\n#if defined(HAS_DISARM_FUNCTION)\n    // make sure the craft has a disarm button assigned before it is armed\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            // no disarm function, display message\n            sub.arming_failure_reason = AP_Arming::k_no_disarm_function;\n            sub.arming_check_failed();\n        }\n        return false;\n    }\n#endif // HAS_DISARM_FUNCTION\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 55.89374388123919}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // in SITL mode, we always arm the vehicle\n    return true;\n#endif\n\n    // check if the vehicle is already armed\n    if (armed()) {\n        return true;\n    }\n\n    // check if the vehicle has a disarm function\n    if (!has_disarm_function()) {\n        // if no disarm function is configured, display a failure message\n        if (display_failure) {\n            AP_Notify::object_arming_failed(AP_Notify::REASON_NO_DISARM_FUNCTION);\n        }\n        return false;\n    }\n\n    // proceed with standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 66.60249513906525}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tfloat temp_y = y;\n\n\tx = temp_x * cos_yaw + temp_y * sin_yaw;\n\ty = temp_x * -sin_yaw + temp_y * cos_yaw;\n}", "CodeBleu_score": 35.75165889773331}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tx = cos_yaw * temp_x + sin_yaw * y;\n\ty = -sin_yaw * temp_x + cos_yaw * y;\n}", "CodeBleu_score": 33.73072258610567}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tx = cos_yaw * temp_x + sin_yaw * y;\n\ty = -sin_yaw * temp_x + cos_yaw * y;\n}", "CodeBleu_score": 33.73072258610567}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Make sure the command is valid\n\tif (!is_valid_MAV_CMD_CONDITION_YAW(packet)) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Get the yaw angle\n\tfloat yaw_angle = packet.param4;\n\n\t// Get the yaw heading mode\n\tuint8_t yaw_mode = packet.param1;\n\n\t// Get the yaw speed\n\tfloat yaw_speed = packet.param2;\n\n\t// Get the yaw relative to direction flag\n\tbool yaw_relative = (packet.param3 == 1);\n\n\t// Get the yaw angle limit\n\tfloat yaw_angle_limit = packet.param5;\n\n\t// Get the yaw speed limit\n\tfloat yaw_speed_limit = packet.param6;\n\n\t// Get the yaw condition\n\tuint8_t yaw_condition = packet.param7;\n\n\t// Get the yaw direction\n\tuint8_t yaw_direction = packet.param8;\n\n\t// Set the yaw heading\n\tset_yaw_heading(yaw_angle, yaw_mode, yaw_speed, yaw_relative, yaw_angle_limit, yaw_speed_limit, yaw_condition, yaw_direction);\n\n\t// Return that the command was accepted\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 48.388734577513375}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 3.5541344618719917}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_DENIED;\n\n\t// check if the yaw angle and param4 values are within acceptable ranges\n\tif (is_within_range(packet.param1, CONDITION_YAW_ANGLE_MIN, CONDITION_YAW_ANGLE_MAX) && is_within_range(packet.param4, CONDITION_YAW_SPEED_MIN, CONDITION_YAW_SPEED_MAX)) {\n\t\t// set the yaw heading using the provided parameters\n\t\tset_auto_yaw_look_at_heading(packet.param1, packet.param4);\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 35.52311039406986}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == AUTO || control_mode == GUIDED) {\n\t\treturn (wp_bearing_to_destination + 18000) / 2;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 37.946170476238585}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n\t\treturn (wp_nav.get_wp_bearing_to_destination() + 18000) / 2;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 41.909775874312174}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn mavlink_msg_high_latency_state_get_high_latency_tgt_heading(msg);\n}", "CodeBleu_score": 7.059392305085363}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tuint8_t buf[sizeof(LogPacketHeader) + sizeof(int32_t)];\n\t\tLogPacketHeader *header = (LogPacketHeader *)buf;\n\t\theader->magic = LOG_PACKET_MAGIC;\n\t\theader->size = sizeof(LogPacketHeader) + sizeof(int32_t);\n\t\theader->id = id;\n\t\theader->time_us = AP_HAL::micros64();\n\t\tmemcpy(buf + sizeof(LogPacketHeader), &value, sizeof(int32_t));\n\t\tlogger.WriteCriticalBlock(buf, sizeof(buf));\n\t}\n}", "CodeBleu_score": 46.23640715459108}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tLogPacketHeader header = LOG_PACKET_HEADER_INIT;\n\t\theader.id = id;\n\t\theader.size = sizeof(value);\n\t\theader.time = hal.scheduler->micros64();\n\t\tlogger.WriteCriticalBlock(&header, &value);\n\t}\n}", "CodeBleu_score": 44.83541828933427}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tuint8_t buffer[sizeof(LogPacket) + sizeof(int32_t)];\n\t\tLogPacket *packet = (LogPacket *)buffer;\n\t\tpacket->header = LOG_PACKET_HEADER_INIT;\n\t\tpacket->id = id;\n\t\tpacket->length = sizeof(int32_t);\n\t\t*(int32_t *)(packet->data) = value;\n\t\tlogger.WriteCriticalBlock(buffer, sizeof(buffer));\n\t}\n}", "CodeBleu_score": 45.27400696609594}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (!ahrs.home_is_set()) {\n\t\tif (motors.armed()) {\n\t\t\tset_home_to_current_location_inflight();\n\t\t} else {\n\t\t\tset_home_to_current_location(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.54884154520296}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 33.4623035435935}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 33.4623035435935}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!motors.armed()) {\n\t\t// Motors are not armed, so set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(SPOOL_UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t// Motors are armed, so set the spool state to unlimited throttle.\n\tmotors.set_desired_spool_state(SPOOL_UNLIMITED_THROTTLE);\n\n\t// Convert pilot inputs to desired body frame rates.\n\tfloat roll_rate_bf = get_pilot_desired_angle_rates(channel_roll);\n\tfloat pitch_rate_bf = get_pilot_desired_angle_rates(channel_pitch);\n\tfloat yaw_rate_bf = get_pilot_desired_angle_rates(channel_yaw);\n\n\t// Run the attitude controller with these rates.\n\tattitude_control->input_rate_bf_roll_pitch_yaw(roll_rate_bf, pitch_rate_bf, yaw_rate_bf);\n\n\t// Set the forward and lateral motor inputs based on pilot controls.\n\tmotors.set_forward(norm_input(channel_throttle));\n\tmotors.set_lateral(norm_input(channel_lateral));\n\n\t// Set the throttle output without angle boost.\n\tattitude_control->set_throttle_out(norm_input(channel_throttle));\n}", "CodeBleu_score": 49.72985406443982}, {"code": "void ModeAcro::run(){\n\t\tif(!motors.armed()) {\n\t\tset_throttle_out(0.0f);\n\t\tset_desired_spool_state(SPOOL_STATE_UNLIMITED_THROTTLE);\n\t\trelax_attitude_controllers();\n\t\treturn;\n\t}\n\n\tset_desired_spool_state(SPOOL_STATE_UNLIMITED_THROTTLE);\n\n\tfloat roll_rate = get_pilot_desired_angle_rates().roll;\n\tfloat pitch_rate = get_pilot_desired_angle_rates().pitch;\n\tfloat yaw_rate = get_pilot_desired_angle_rates().yaw;\n\n\tinput_rate_bf_roll_pitch_yaw(roll_rate, pitch_rate, yaw_rate);\n\n\tset_throttle_out(get_control_in(channel_throttle));\n\tset_forward(get_control_in(channel_forward));\n\tset_lateral(get_control_in(channel_lateral));\n}", "CodeBleu_score": 41.80657329020019}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed()) {\n\t\t// If motors are not armed, set throttle to zero and exit\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\treturn;\n\t}\n\n\t// If motors are armed, set spool state to unlimited throttle\n\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\n\t// Convert pilot inputs to desired body frame rates\n\tfloat roll_rate_bf = get_control_in(ControlIn::ROLL_RATE_BF);\n\tfloat pitch_rate_bf = get_control_in(ControlIn::PITCH_RATE_BF);\n\tfloat yaw_rate_bf = get_control_in(ControlIn::YAW_RATE_BF);\n\n\t// Run attitude controller with desired body frame rates\n\tattitude_control->input_rate_bf_roll_pitch_yaw(roll_rate_bf, pitch_rate_bf, yaw_rate_bf);\n\n\t// Set pilot's throttle input without angle boost\n\tfloat throttle_out = attitude_control->get_throttle_out();\n\tmotors.set_throttle(throttle_out);\n\n\t// Set forward and lateral motor inputs based on pilot controls\n\tfloat forward_in = get_control_in(ControlIn::FORWARD);\n\tfloat lateral_in = get_control_in(ControlIn::LATERAL);\n\tmotors.set_forward(forward_in);\n\tmotors.set_lateral(lateral_in);\n}", "CodeBleu_score": 48.88000526846667}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set mode to position control\n\tset_mode(MODE_POS_CONTROL);\n\n\t// initialize waypoint navigation\n\tsub.wp_nav.wp_and_spline_init();\n\n\t// set the waypoint destination\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\n\t// set the yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 40.77196253475125}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t#if defined(CONFIG_HAL_BOARD) && (CONFIG_HAL_BOARD == HAL_BOARD_PX4)\n    // reset the controller's state\n    sub.controller.reset_state();\n#endif\n\n    // get the stopping point\n    Vector2f stopping_point;\n    sub.wp_nav.get_wp_stopping_point(stopping_point);\n\n    // set the stopping point as the waypoint destination\n    sub.wp_nav.set_wp_destination(stopping_point);\n\n    // set the default auto yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 54.75333355699}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set position control mode\n\tsub.control_mode = MODE_POSCTL;\n\n\t// set wpnav mode\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\n\t// set auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(sub.rtl_state.rtl_mode));\n}", "CodeBleu_score": 37.160272498591475}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set the max speeds and accelerations\n\tset_max_speed_accel_xy(sub.pilot_max_speed_xy, sub.pilot_max_accel_xy);\n\tset_max_speed_accel_z(sub.pilot_max_speed_z, sub.pilot_max_accel_z);\n\n\t// Set the yaw control mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n\n\t// Initialise the velocity controllers\n\tinit_xy_controller();\n\tinit_z_controller();\n}", "CodeBleu_score": 29.50067753807574}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set mode\n\tsub.guided_mode = GUIDED_VEL_CONTROL;\n\n\t// set pilot-defined maximum speeds and accelerations\n\tposition_control->set_max_speed_accel_z();\n\n\t// initialise velocity controllers\n\tposition_control->init_xy_controller();\n\tposition_control->init_z_controller();\n\n\t// set yaw control mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 35.73410979728032}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set the pilot's desired velocity to zero\n\tsub.pilot_desired_velocity = Vector3f(0, 0, 0);\n\n\t// Set the maximum speeds and accelerations for the vertical velocity controller\n\tposition_control->set_max_speed_accel_z(sub.pilot_max_speed_z, sub.pilot_max_accel_z);\n\n\t// Initialize the vertical velocity controller\n\tposition_control->init_z_controller();\n\n\t// Initialize the horizontal velocity controller\n\tposition_control->init_xy_controller();\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 47.41356287046968}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t", "CodeBleu_score": 1.2887052532981327}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if we have exceeded the timeout\n\tif (millis() - _start_time > _timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if we have reached the minimum altitude\n\tif (curr_pos.z < _min_alt) {\n\t\treturn true;\n\t}\n\n\t// Check if we have reached the maximum altitude\n\tif (curr_pos.z > _max_alt) {\n\t\treturn true;\n\t}\n\n\t// Check if we have exceeded the horizontal distance limit\n\tif (get_horizontal_distance_cm() > _max_dist) {\n\t\treturn true;\n\t}\n\n\t// If we are still going, return false\n\treturn false;\n}", "CodeBleu_score": 21.69756459860438}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\n// Check if a timeout has been exceeded\nif (hal.scheduler->millis() - _start_time > GUIDED_TIMEOUT_MS) {\nreturn true;\n}\n\n// Check if the current altitude is below the minimum threshold\nif (curr_pos.z < GUIDED_MIN_ALT_CM) {\nreturn true;\n}\n\n// Check if the current altitude is above the maximum threshold\nif (curr_pos.z > GUIDED_MAX_ALT_CM) {\nreturn true;\n}\n\n// Check if the horizontal distance moved exceeds the limit\nif (get_horizontal_distance_cm() > GUIDED_MAX_DIST_CM) {\nreturn true;\n}\n\n// If none of the above conditions are met, return false\nreturn false;\n}", "CodeBleu_score": 22.791302247898827}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\t// Get the current time.\n\tuint32_t now = AP_HAL::millis();\n\n\t// If the test has timed out, record the failure time and return false.\n\tif (now - _test_start_time > 2000) {\n\t\t_test_start_time = now;\n\t\t_test_failed_time = now;\n\t\treturn false;\n\t}\n\n\t// If the test has not timed out, check if the test has passed.\n\tif (_test_start_time != 0 && now - _test_start_time > 2000) {\n\t\t// The test has passed.\n\t\treturn true;\n\t}\n\n\t// The test has not passed or has not timed out.\n\treturn false;\n}", "CodeBleu_score": 41.747614098808654}, {"code": "bool Sub::verify_motor_test(){\n\t\t// TODO: Add code to verify motor test\n\treturn true;\n}", "CodeBleu_score": 4.877943933983955}, {"code": "bool Sub::verify_motor_test(){\n\t\t// Verify the motor test by checking if motor test requests are received at least every 2 Hz.\n\tif (millis() - last_motor_test_request >= 500) {\n\t\t// The test has timed out. Send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false.\n\t\tgcs->send_text(MAV_SEVERITY_ERROR, \"Motor test timed out\");\n\t\tpass = false;\n\t\tmotor_test_enabled = false;\n\t\tgcs->arm(false);\n\t\tfailure_time = millis();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.41949498492475}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tint16_t roll_raw = wp_nav.get_roll();\n\tint16_t pitch_raw = wp_nav.get_pitch();\n\n\troll_raw = constrain_int16(roll_raw, -WPNAV_MAX_ANGLE_CD, WPNAV_MAX_ANGLE_CD);\n\tpitch_raw = constrain_int16(pitch_raw, -WPNAV_MAX_ANGLE_CD, WPNAV_MAX_ANGLE_CD);\n\n\tfloat roll_norm = (float)roll_raw / (float)WPNAV_MAX_ANGLE_CD;\n\tfloat pitch_norm = (float)pitch_raw / (float)WPNAV_MAX_ANGLE_CD;\n\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 48.24251156588416}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_in, pitch_in;\n\troll_in = wp_nav.get_roll();\n\tpitch_in = wp_nav.get_pitch();\n\troll_in = constrain_int16(roll_in, -WPNAV_MAX_ANGLE_CD, WPNAV_MAX_ANGLE_CD);\n\tpitch_in = constrain_int16(pitch_in, -WPNAV_MAX_ANGLE_CD, WPNAV_MAX_ANGLE_CD);\n\troll_in = (float)roll_in / 100.0f;\n\tpitch_in = (float)pitch_in / 100.0f;\n\tlateral_out = -pitch_in;\n\tforward_out = roll_in;\n}", "CodeBleu_score": 42.97365342008275}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_out, pitch_out;\n\troll_out = constrain_int16(wp_nav.get_roll(), -WPNAV_MAX_ANGLE, WPNAV_MAX_ANGLE);\n\tpitch_out = constrain_int16(wp_nav.get_pitch(), -WPNAV_MAX_ANGLE, WPNAV_MAX_ANGLE);\n\troll_out = (roll_out + WPNAV_MAX_ANGLE) / (WPNAV_MAX_ANGLE * 2);\n\tpitch_out = (pitch_out + WPNAV_MAX_ANGLE) / (WPNAV_MAX_ANGLE * 2);\n\tlateral_out = roll_out;\n\tforward_out = pitch_out;\n}", "CodeBleu_score": 40.79952002508862}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// Check if the barometer is healthy\n\tif (barometer.healthy()) {\n\t\t// Update the barometer data\n\t\tbarometer.update();\n\n\t\t// Check if the barometer is above sea level\n\t\tif (barometer.get_altitude() > 0.0f) {\n\t\t\t// Update the barometer calibration\n\t\t\tbarometer.update_calibration();\n\t\t}\n\n\t\t// Check if a depth sensor is present\n\t\tif (depth_sensor != nullptr) {\n\t\t\t// Check if the barometer is healthy\n\t\t\tif (barometer.healthy()) {\n\t\t\t\t// Update the depth sensor health status\n\t\t\t\tdepth_sensor->set_health_status(Health::OK);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Update the depth sensor health status\n\t\t\t\tdepth_sensor->set_health_status(Health::WARNING);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 58.733010909686755}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (barometer.healthy()) {\n\t\tstatus.barometer_health = 1;\n\t} else {\n\t\tstatus.barometer_health = 0;\n\t}\n}", "CodeBleu_score": 57.534590240093976}, {"code": "void Sub::read_barometer(){\n\t\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\n\t// If a depth sensor is present, update the sensor health status\n\tif (depth_sensor != nullptr) {\n\t\tdepth_sensor->set_healthy(barometer.healthy());\n\t}\n}", "CodeBleu_score": 57.736074020933096}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t", "CodeBleu_score": 1.8482588980119046}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (motors.armed) {\n\t\tif (ahrs.is_mag_calibrated) {\n\t\t\tif (ahrs.is_attitude_valid) {\n\t\t\t\tif (!ahrs.is_yaw_aligned) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (ahrs.is_in_air) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (ahrs.is_static) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (ahrs.is_rotating) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (ahrs.is_yaw_rate_aligned) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 41.96237916474552}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\tif (status.flags & STATUS_FLAGS_POS_HORIZ_ABS) {\n\t\treturn true;\n\t}\n\n\tif (status.flags & STATUS_FLAGS_POS_HORIZ_REL) {\n\t\treturn true;\n\t}\n\n\tif (status.flags & STATUS_FLAGS_POS_HORIZ_PRED) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 35.11094025381989}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// check if the current control mode requires position or velocity\nif (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\nreturn true;\n}\n\n// call the parent class's GPS checks\nif (!AP_Arming::gps_checks(display_failure)) {\nreturn false;\n}\n\n// check if the AHRS system is ready\nif (!ahrs.initialised()) {\nif (display_failure) {\nrover.console->println_P(PSTR(\"GPS: AHRS not initialised\"));\n}\nreturn false;\n}\n\n// check if the EKF failsafe is active\nif (rover.ekf_ok_status != AP_EKF_OK_STATUS_GPS_OK) {\nif (display_failure) {\nrover.console->println_P(PSTR(\"GPS: EKF failsafe active\"));\n}\nreturn false;\n}\n\n// check if the position estimate is valid\nif (!rover.ekf_position_ok()) {\nif (display_failure) {\nrover.console->println_P(PSTR(\"GPS: EKF position invalid\"));\n}\nreturn false;\n}\n\n// if all checks pass, return true\nreturn true;\n}", "CodeBleu_score": 51.23836966849979}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\nreturn true;\n}\nif (!AP_Arming::gps_checks(display_failure)) {\nreturn false;\n}\nif (!ahrs.pre_arm_check(display_failure)) {\nreturn false;\n}\nif (!rover.ekf_position_ok) {\nif (display_failure) {\nrover.console->println_P(PSTR(\"EKF has failed\"));\n}\nreturn false;\n}\nif (!rover.position_ok()) {\nif (display_failure) {\nrover.console->println_P(PSTR(\"Position estimate invalid\"));\n}\nreturn false;\n}\nreturn true;\n}", "CodeBleu_score": 48.24645887831519}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\nreturn true;\n}\nif (!AP_Arming::gps_checks(display_failure)) {\nreturn false;\n}\nif (!rover.ahrs.pre_arm_check()) {\nreturn false;\n}\nif (!rover.ekf_position_ok()) {\nreturn false;\n}\nif (!rover.position_ok()) {\nreturn false;\n}\nreturn true;\n}", "CodeBleu_score": 38.32361929317446}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // if in SITL mode, always arm\n    set_armed(true);\n    return true;\n#else\n    // if in HITL mode, always disarm\n    if (hal.util->get_soft_armed()) {\n        set_armed(false);\n        return true;\n    }\n\n    // check if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // if arming checks are disabled, arm\n    if (!do_arming_checks) {\n        set_armed(true);\n        return true;\n    }\n\n    // check if we should arm\n    if (!should_arm()) {\n        return false;\n    }\n\n    // check if the system is ready to arm\n    if (!ready_to_arm()) {\n        return false;\n    }\n\n    // attempt to arm\n    if (!attempt_arm(method)) {\n        return false;\n    }\n\n    // set the home location\n    g2.smart_rtl.set_home();\n\n    // initialize the simple mode heading\n    mode_simple.init_heading();\n\n    // record the home heading for sail vehicles\n    g2.windvane.record_home_heading();\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arm_disarm_statustext();\n\n    return true;\n#endif\n}", "CodeBleu_score": 48.52230207652002}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (status_message.charging_allowed && checkShouldCharge()) {\n\t\tif (status_message.charging_enabled) {\n\t\t\t// Charging is allowed and should continue.\n\t\t\tdigitalWrite(charging_enabled_pin, HIGH);\n\t\t} else {\n\t\t\t// Charging is allowed but should not continue.\n\t\t\tdigitalWrite(charging_enabled_pin, LOW);\n\t\t\tstatus_message.charging_disabled_time = millis();\n\t\t}\n\t} else {\n\t\t// Charging is not allowed.\n\t\tif (status_message.charging_enabled) {\n\t\t\t// Charging was previously enabled.\n\t\t\tdigitalWrite(charging_enabled_pin, LOW);\n\t\t\tstatus_message.charging_disabled_time = millis();\n\t\t} else {\n\t\t\t// Charging was previously disabled.\n\t\t\tif (millis() - status_message.charging_disabled_time > 1000) {\n\t\t\t\t// It has been more than 1 second since charging was disabled.\n\t\t\t\t// Retry enabling charging.\n\t\t\t\tdigitalWrite(charging_enabled_pin, HIGH);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 48.9052021194046}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tif (!charging_enabled) {\n\t\t\t\t// Record the time when charging should resume\n\t\t\t\tcharging_resume_time = millis() + charging_resume_delay;\n\t\t\t\tdigitalWrite(CHARGE_ENABLE_PIN, HIGH);\n\t\t\t\tcharging_enabled = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_enabled) {\n\t\t\t\t// Disable charging\n\t\t\t\tdigitalWrite(CHARGE_ENABLE_PIN, LOW);\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_resume_time = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\t// Disable charging\n\t\t\tdigitalWrite(CHARGE_ENABLE_PIN, LOW);\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_resume_time = 0;\n\t\t}\n\t\tif (charging_retry_time == 0) {\n\t\t\t// Record the time when charging should be retried\n\t\t\tcharging_retry_time = millis() + charging_retry_delay;\n\t\t} else if (millis() > charging_retry_time) {\n\t\t\t// Retry enabling charging\n\t\t\tdigitalWrite(CHARGE_ENABLE_PIN, HIGH);\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_retry_time = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.03477333225011}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tif (!charging_enabled) {\n\t\t\t\t// Disable charging and record the time\n\t\t\t\tdigitalWrite(CHARGER_EN_PIN, LOW);\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_disabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\t// Re-enable charging if it should be enabled\n\t\t\tif (charging_enabled) {\n\t\t\t\tdigitalWrite(CHARGER_EN_PIN, HIGH);\n\t\t\t\tcharging_enabled = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// If charging is not allowed, try to re-enable it\n\t\tif (charging_enabled) {\n\t\t\tif (millis() - charging_disabled_time > CHARGING_DISABLE_DELAY) {\n\t\t\t\tdigitalWrite(CHARGER_EN_PIN, HIGH);\n\t\t\t\tcharging_enabled = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 60.239916775723756}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif(rosRunning) {\n\t\tif(size >= 4) {\n\t\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\t\tuint8_t crcBytes[2];\n\t\t\tcrcBytes[0] = crc >> 8;\n\t\t\tcrcBytes[1] = crc & 0xFF;\n\t\t\tpacketSerial.write(message, size);\n\t\t\tpacketSerial.write(crcBytes, 2);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.76206850467187}, {"code": "void sendMessage(void *message, size_t size){\n\t\t// Check if ROS is running\n\tif (rosRunning) {\n\t\t// Check if the message size is at least 4 bytes\n\t\tif (size >= 4) {\n\t\t\t// Calculate a CRC for the message\n\t\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\t\t// Append the CRC to the message\n\t\t\tmemcpy(message + size, &crc, sizeof(crc));\n\t\t\t// Send the message\n\t\t\tpacketSerial.write(message, size + sizeof(crc));\n\t\t}\n\t}\n}", "CodeBleu_score": 33.55754305762354}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tmemcpy(&message[size], &crc, sizeof(crc));\n\t\tpacketSerial.write(message, size + sizeof(crc));\n\t}\n}", "CodeBleu_score": 32.346745657218406}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\treturn active_sounds.size();\n\t}\n\tif (myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\tmyMP3.play(active_sounds.back());\n\tactive_sounds.pop_back();\n\treturn active_sounds.size();\n}", "CodeBleu_score": 46.21548009356336}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || isPlaying)\n\t\treturn active_sounds.size();\n\telse {\n\t\tactive_sounds.pop_back();\n\t\tisPlaying = true;\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 38.513342266413986}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tactive_sounds.pop_back();\n\t\tactive_sounds.back().play();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 35.95246460969594}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *ac = (AbstractCamera *) d;\nbool handled = false;\nswitch (command) {\ncase C_CAMERA_MEMORY_MAPPED_FILE:\nif (ac->memory_mapped_file != NULL) {\nwb_memory_mapped_file_delete(ac->memory_mapped_file);\nac->memory_mapped_file = NULL;\n}\nac->memory_mapped_file = wb_memory_mapped_file_new(ac->requested_memory_mapped_file_path, ac->requested_memory_mapped_file_size);\nhandled = true;\nbreak;\ndefault:\nbreak;\n}\nreturn handled;\n}", "CodeBleu_score": 51.1613857024671}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tbool handled = true;\n\nswitch (command) {\ncase C_CAMERA_MEMORY_MAPPED_FILE:\nimage_cleanup();\nimage_setup(r);\nbreak;\ndefault:\nhandled = false;\n}\n\nreturn handled;\n}", "CodeBleu_score": 44.0905057130158}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tbool handled = true;\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE:\n\t\t\twb_abstract_camera_cleanup(ac);\n\t\t\timage_setup(ac, r);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thandled = false;\n\t\t\tbreak;\n\t}\n\treturn handled;\n}", "CodeBleu_score": 52.34549976513904}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tint height = -1;\n\n\tif (ac == NULL)\n\t\treturn -1;\n\n\trobot_mutex_lock(ac->mutex);\n\tif (ac->has_image)\n\t\theight = ac->image.height;\n\trobot_mutex_unlock(ac->mutex);\n\n\treturn height;\n}", "CodeBleu_score": 43.286234102429795}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tif (!d || d->type != WB_NODE_CAMERA)\n\t\treturn -1;\n\tif (d->tag != WB_CAMERA_TAG)\n\t\treturn -1;\n\tif (!d->abstract_camera)\n\t\treturn -1;\n\n\twb_robot_mutex_lock(d->mutex);\n\tint height = d->abstract_camera->height;\n\twb_robot_mutex_unlock(d->mutex);\n\n\treturn height;\n}", "CodeBleu_score": 38.189481546421014}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tint result;\n\trobot_mutex_lock(ac->mutex);\n\tif (ac->camera_data)\n\t\tresult = ac->camera_data->height;\n\telse\n\t\tresult = -1;\n\trobot_mutex_unlock(ac->mutex);\n\treturn result;\n}", "CodeBleu_score": 45.38973354775404}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tstruct _accelerometer *accelerometer;\n\tif (tag < 0 || tag >= WB_DEVICES_COUNT || devices[tag].type != WB_NODE_ACCELEROMETER) {\n\t\tfprintf(stderr, \"Error: invalid device tag.\n\");\n\t\treturn -1;\n\t}\n\trobot_mutex_lock(devices[tag].mutex);\n\taccelerometer = (struct _accelerometer *) devices[tag].device;\n\tsampling_period = accelerometer->sampling_period;\n\trobot_mutex_unlock(devices[tag].mutex);\n\treturn sampling_period;\n}", "CodeBleu_score": 45.0382039874471}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = -1;\n\tstruct accelerometer *accelerometer;\n\trobot_mutex_lock(accelerometer_mutex);\n\taccelerometer = robot_get_device(tag);\n\tif (accelerometer)\n\t\tsampling_period = accelerometer->sampling_period;\n\telse\n\t\tfprintf(stderr, \"Error: invalid device tag.\n\");\n\trobot_mutex_unlock(accelerometer_mutex);\n\treturn sampling_period;\n}", "CodeBleu_score": 56.05022518903393}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tstruct wb_accelerometer_struct *accelerometer;\n\n\trobot_mutex_lock(accelerometer_mutex);\n\taccelerometer = robot_get_device_by_tag(tag);\n\tif (accelerometer == NULL) {\n\t\tfprintf(stderr, \"Error: wb_accelerometer_get_sampling_period() tag %d does not correspond to any existing accelerometer device.\\\n\", tag);\n\t\trobot_mutex_unlock(accelerometer_mutex);\n\t\treturn -1;\n\t}\n\tsampling_period = accelerometer->sampling_period;\n\trobot_mutex_unlock(accelerometer_mutex);\n\treturn sampling_period;\n}", "CodeBleu_score": 48.32181405522391}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = dms;\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 41.90011620056393}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.245249918562564}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tdouble degrees, minutes, seconds;\n\tstring dmsString;\n\tchar *dmsCharString;\n\tdmsCharString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree, &degrees, &minutes, &seconds);\n\tdmsString = dmsCharString;\n\tfree(dmsCharString);\n\treturn dmsString;\n}", "CodeBleu_score": 42.14586891238522}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && plane);\n\tconst dReal *p = dGeomGetPosition(g);\n\tdReal lz = z - p[2];\n\tdReal ly = y - p[1];\n\tdReal lx = x - p[0];\n\tconst dReal *R = dGeomGetRotation(g);\n\tconst dReal *extents = dGeomBoxGetLengths(g);\n\tdReal lxx = R[0] * lx + R[1] * ly + R[2] * lz;\n\tdReal lyy = R[4] * lx + R[5] * ly + R[6] * lz;\n\tdReal lzz = R[8] * lx + R[9] * ly + R[10] * lz;\n\tdReal den = dFabs(lxx) + dFabs(lyy) + dFabs(lzz);\n\tif (den < dEpsilon) {\n\t\tplane[0] = 1;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t\tplane[3] = -p[0];\n\t}\n\telse {\n\t\tdReal rec = 1.0f / den;\n\t\tplane[0] = R[0] * rec;\n\t\tplane[1] = R[4] * rec;\n\t\tplane[2] = R[8] * rec;\n\t\tplane[3] = -(plane[0] * p[0] + plane[1] * p[1] + plane[2] * p[2]);\n\t}\n}", "CodeBleu_score": 34.570230753029854}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && plane);\n\tdGeomBox *b = (dGeomBox*) g;\n\tdVector3 p;\n\tdReal sign;\n\tdVector3Clear (plane);\n\tp [0] = x - b->final_posr->pos [0];\n\tp [1] = y - b->final_posr->pos [1];\n\tp [2] = z - b->final_posr->pos [2];\n\tsign = REAL(0.0);\n\tif (dFabs (p [0]) > b->side[0] * REAL(0.5)) {\n\t\tplane [0] = REAL(1.0);\n\t\tsign = REAL(-1.0);\n\t}\n\tif (dFabs (p [1]) > b->side[1] * REAL(0.5)) {\n\t\tplane [1] = REAL(1.0);\n\t\tsign = REAL(-1.0);\n\t}\n\tif (dFabs (p [2]) > b->side[2] * REAL(0.5)) {\n\t\tplane [2] = REAL(1.0);\n\t\tsign = REAL(-1.0);\n\t}\n\tplane [3] = sign * dCalcVectorDot3 (p, plane);\n}", "CodeBleu_score": 28.84431507279517}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box && box->body, \"Invalid box or body\");\ndUASSERT (fluidPlane, \"Invalid fluid plane\");\ndUASSERT (immersion, \"Invalid immersion data\");\ndUASSERT (flags == 0 || flags == dIMMERSE_BOX_TEST_ALL_FACES ||\n      flags == dIMMERSE_BOX_TEST_ALL_FACES_BUT_TOP, \"Invalid flags\");\n\ndInitBoxImmersionData (box, fluidPlane, flags, immersion);\nreturn dPerformBoxImmersionChecking (immersion);\n}", "CodeBleu_score": 45.20945654492658}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box && box->body, \"Invalid box or body\");\ndUASSERT (fluidPlane && immersion, \"Invalid plane or immersion\");\ndUASSERT (flags >= 0 && flags < 8, \"Invalid flags\");\n\nsBoxImmersionData data (box, fluidPlane, flags, immersion);\nreturn data.performImmersionChecking();\n}", "CodeBleu_score": 58.17739083370225}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->type == dBoxClass,\"The first argument of dImmerseBoxCapsule must be a box\");\n\tdUASSERT(o2->type == dCapsuleClass,\"The second argument of dImmerseBoxCapsule must be a capsule\");\n\n\tsBoxCapsuleImmersionData data(o1, o2, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 27.6030046856656}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\n\tdUASSERT(o1->type == dBoxClass,\"This function is only for boxes\");\n\tdUASSERT(o2->type == dCapsuleClass,\"This function is only for capsules\");\n\n\tsBoxCapsuleImmersionData data(o1, o2, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 23.917384032888535}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->type == dBoxClass,\"The first geom is not a box\");\n\tdUASSERT(o2->type == dCapsuleClass,\"The second geom is not a capsule\");\n\n\tsBoxCapsuleImmersionData data(o1, o2, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 24.305585648241568}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(o2->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsCapsuleImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 32.75222205418621}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(o2->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(o1->type == dCapsuleClass, \"This function is only valid for capsule-trimesh immersion checking\");\n\tdUASSERT(o2->type == dTriMeshClass, \"This function is only valid for capsule-trimesh immersion checking\");\n\n\tsCapsuleImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 38.098350052464546}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->type == dTriMeshClass,\"This is not a trimesh\");\n\tdUASSERT(o2->type == dCapsuleClass,\"This is not a capsule\");\n\n\tsCapsuleImmersionData data(o2, o1, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 28.735213062654847}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the sleep duration in milliseconds from the input.\nstd::chrono::milliseconds sleep_duration = getInput<std::chrono::milliseconds>(\"sleep_duration\");\n// If the duration is missing or non-positive, return SUCCESS.\nif (!sleep_duration.count()) {\nROS_WARN_STREAM_NAMED(\"sleep_node\", \"The sleep duration is missing or non-positive. The node will return SUCCESS.\");\nreturn NodeStatus::SUCCESS;\n}\n// Set the node status to RUNNING.\nsetStatus(NodeStatus::RUNNING);\n// Start a timer.\ntimer_ = create_timer(sleep_duration, &SleepNode::onTimer, this);\n// Set a callback to emit a wake-up signal when the timer expires.\ntimer_.setCallback(&SleepNode::onTimer, this);\n// Return RUNNING.\nreturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 42.04103864098708}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the sleep duration in milliseconds from the input.\nconst std::chrono::milliseconds sleep_duration = std::chrono::milliseconds(getInput<int64_t>(\"sleep_duration_ms\"));\n// If the duration is missing or non-positive, return SUCCESS.\nif (!sleep_duration.count()) {\nROS_INFO_STREAM(\"Sleep duration is missing or non-positive; returning SUCCESS\");\nreturn NodeStatus::SUCCESS;\n}\n// Set the node status to RUNNING.\nROS_INFO_STREAM(\"Setting node status to RUNNING\");\nsetStatus(NodeStatus::RUNNING);\n// Start a timer.\ntimer_ = createTimer(sleep_duration, std::bind(&SleepNode::onTimer, this));\n// Set a callback to emit a wake-up signal when the timer expires.\ntimer_.setCallback(std::bind(&SleepNode::onTimer, this));\n// Reset the timer_waiting_ flag.\ntimer_waiting_ = false;\n// Return RUNNING.\nreturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 41.116962302382184}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the sleep duration in milliseconds from the input.\n// If the duration is missing or non-positive, return SUCCESS.\n// Otherwise, set the node status to RUNNING, start a timer, and set a callback to emit a wake-up signal when the timer expires.\n// If the timer is aborted, ensure the timer_waiting_ flag is reset.\nif (!getInput(\"duration\", duration_)) {\nROS_ERROR_STREAM(\"Missing input: duration\");\nreturn NodeStatus::SUCCESS;\n}\nif (duration_ <= 0) {\nROS_WARN_STREAM(\"Sleep duration must be positive, using default\");\nduration_ = 1000;\n}\nROS_INFO_STREAM(\"Sleeping for \" << duration_ << \" milliseconds\");\nsetStatus(NodeStatus::RUNNING);\ntimer_.setDuration(duration_);\ntimer_.start();\ntimer_.setCallback(std::bind(&SleepNode::onTimer, this));\ntimer_waiting_ = false;\nreturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 43.49348094486138}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the entry\n\tstd::shared_ptr<Blackboard::Entry> entry = config().blackboard->getEntry(config().name);\n\n\t// If the entry is not found, return FAILURE\n\tif (!entry) {\n\t\tROS_ERROR_STREAM(\"EntryUpdatedAction: Entry '\" << config().name << \"' not found in the blackboard\");\n\t\treturn FAILURE;\n\t}\n\n\t// Lock the entry's mutex\n\tentry->mutex.lock();\n\n\t// If the sequence IDs are different, update the stored sequence ID and return SUCCESS\n\tif (entry->sequence_id != entry->last_sequence_id) {\n\t\tentry->last_sequence_id = entry->sequence_id;\n\t\tentry->mutex.unlock();\n\t\treturn SUCCESS;\n\t}\n\n\t// Otherwise, unlock the mutex and return FAILURE\n\tentry->mutex.unlock();\n\treturn FAILURE;\n}", "CodeBleu_score": 35.36128835845187}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the blackboard entry\n\tstd::shared_ptr<Blackboard> blackboard = this->blackboard_ptr_.lock();\n\tif (blackboard == nullptr) {\n\t\tROS_ERROR_STREAM(\"Blackboard not found\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\t// Get the entry\n\tstd::shared_ptr<BlackboardEntry> entry = blackboard->getEntry(this->entry_name_);\n\tif (entry == nullptr) {\n\t\tROS_ERROR_STREAM(\"Entry not found in blackboard: \" << this->entry_name_);\n\t\treturn NodeStatus::FAILURE;\n\t}\n\t// Lock the entry\n\tif (!entry->lock()) {\n\t\tROS_ERROR_STREAM(\"Could not lock entry: \" << this->entry_name_);\n\t\treturn NodeStatus::FAILURE;\n\t}\n\t// Compare the sequence IDs\n\tif (entry->getSequenceID() != this->sequence_id_) {\n\t\tthis->sequence_id_ = entry->getSequenceID();\n\t\tROS_INFO_STREAM(\"Entry updated: \" << this->entry_name_);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tROS_DEBUG_STREAM(\"Entry not updated: \" << this->entry_name_);\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 34.684905919283636}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry\n\tBlackboard::Ptr blackboard = getBlackboard();\n\tBlackboard::PtrEntry entry = blackboard->getEntry(this->entry_name_);\n\tif (entry) {\n\t\t// Lock the entry\n\t\tentry->lock();\n\n\t\t// Retrieve the sequence ID\n\t\tint64_t sequence_id = entry->getSequenceID();\n\n\t\t// Compare the sequence ID with the previously stored one\n\t\tif (sequence_id != this->sequence_id_) {\n\t\t\t// Update the stored sequence ID\n\t\t\tthis->sequence_id_ = sequence_id;\n\n\t\t\t// Return SUCCESS\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\n\t// Return FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 35.51628426532838}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn static_cast<size_t>(std::max(static_cast<int>(children_nodes_.size()), success_threshold_));\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 54.48797251338806}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(static_cast<size_t>(success_threshold_ * children_nodes_.size()), static_cast<size_t>(0));\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 54.145294845155775}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(size_t(1), static_cast<size_t>(-success_threshold_ * children_nodes_.size()));\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 53.92192641409975}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t#ifdef DEBUG_MONITOR\n  std::cout << \"Groot2Publisher::heartbeatLoop started\" << std::endl;\n#endif\n\n  while(_p->is_running) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    if(_p->last_heartbeat_time.time_since_epoch().count() == 0) {\n      continue;\n    }\n\n    auto now = std::chrono::system_clock::now();\n    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(now - _p->last_heartbeat_time);\n    if(diff.count() > _p->heartbeat_timeout_ms) {\n      if(_p->heartbeat_enabled) {\n        _p->heartbeat_enabled = false;\n        enableAllHooks(false);\n#ifdef DEBUG_MONITOR\n        std::cout << \"Groot2Publisher::heartbeatLoop: disabling hooks\" << std::endl;\n#endif\n      }\n    }\n    else {\n      if(!_p->heartbeat_enabled) {\n        _p->heartbeat_enabled = true;\n        enableAllHooks(true);\n#ifdef DEBUG_MONITOR\n        std::cout << \"Groot2Publisher::heartbeatLoop: enabling hooks\" << std::endl;\n#endif\n      }\n    }\n  }\n}", "CodeBleu_score": 46.59221054423396}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif(_p->heartbeat_status != _p->heartbeat_status_prev) {\n\t\t\t_p->heartbeat_status_prev = _p->heartbeat_status;\n\t\t\tif(_p->heartbeat_status == HeartbeatStatus::HEALTHY) {\n\t\t\t\tenableAllHooks(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tenableAllHooks(false);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.656638691773566}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\t\tfor(auto& [node_uid, hook] : _p->pre_hooks) {\n\t\t\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\t\t\tif(hook->mode == Monitor::Hook::Mode::HEARTBEAT) {\n\t\t\t\tif(hook->lastHeartbeatTime.time_since_epoch().count() != hook->heartbeatTime.time_since_epoch().count()) {\n\t\t\t\t\thook->lastHeartbeatTime = hook->heartbeatTime;\n\t\t\t\t\tif(hook->enabled) {\n\t\t\t\t\t\thook->enabled = false;\n\t\t\t\t\t\tlk.unlock();\n\t\t\t\t\t\thook->wakeup.notify_all();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.324766689389605}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> msgpack_dump;\n\tnlohmann::json json_dump;\n\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\tfor (auto bb_name : bb_names) {\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it != _p->subtrees.end()) {\n\t\t\tauto subtree_lock = it->second.lock();\n\t\t\tif (subtree_lock) {\n\t\t\t\tnlohmann::json subtree_json = ExportBlackboardToJSON(subtree_lock);\n\t\t\t\tjson_dump[bb_name] = subtree_json;\n\t\t\t}\n\t\t}\n\t}\n\n\tmsgpack::pack(msgpack_dump, json_dump);\n\treturn msgpack_dump;\n}", "CodeBleu_score": 53.34374552799309}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> msgpack_dump;\n\tnlohmann::json json_dump;\n\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n\tfor (const std::string& bb_name : bb_names) {\n\t\tstd::unique_lock<std::mutex> lock(_blackboards_mutex);\n\t\tconst auto it = _blackboards.find(bb_name);\n\t\tif (it != _blackboards.end()) {\n\t\t\tconst auto& subtree = it->second.subtree;\n\t\t\tif (subtree) {\n\t\t\t\tconst auto json = ExportBlackboardToJSON(subtree.get());\n\t\t\t\tjson_dump[bb_name] = json;\n\t\t\t}\n\t\t}\n\t}\n\n\tmsgpack_dump = nlohmann::json::to_msgpack(json_dump);\n\treturn msgpack_dump;\n}", "CodeBleu_score": 50.12676857331139}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> dump;\n\nnlohmann::json json_dump;\n\nstd::vector<std::string> bb_names;\nboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\nfor (const auto& bb_name : bb_names) {\nstd::unique_lock<std::mutex> lock(_subtrees_mutex);\nconst auto& subtree_it = _subtrees.find(bb_name);\nif (subtree_it != _subtrees.end()) {\nconst auto& subtree = subtree_it->second.lock();\nif (subtree) {\nnlohmann::json json_bb = ExportBlackboardToJSON(subtree);\njson_dump[bb_name] = json_bb;\n}\n}\n}\n\ndump = nlohmann::json::to_msgpack(json_dump);\n\nreturn dump;\n}", "CodeBleu_score": 50.65300049077841}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif(it == _p->nodes_by_uid.end())\n\t{\n\t\treturn false;\n\t}\n\tauto hook = getHook(pos, node_uid);\n\tif(!hook)\n\t{\n\t\treturn false;\n\t}\n\tstd::unique_lock<std::mutex> lk(hook->lock);\n\tif(hook->status != NodeStatus::BREAKPOINT)\n\t{\n\t\treturn false;\n\t}\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 62.07027272275367}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t//  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto hook = getHook(pos, node_uid);\n  if(!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->lock);\n  if(hook->status != NodeStatus::BREAKPOINT) {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 46.85130828192074}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t//  auto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if(it == _p->nodes_by_uid.end())\n  {\n    return false;\n  }\n  auto hook = it->second.lock();\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->lock);\n  if(hook->status != NodeStatus::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 59.72826717786287}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t#ifdef DEBUG_THREAD_NAME\n  pthread_setname_np(pthread_self(), name_.c_str());\n#endif\n  if(status_ == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_ = false;\n    thread_ = std::async(std::launch::async, &ThreadedAction::tickThread, this);\n  }\n\n  if(thread_.valid()) {\n    thread_.wait();\n  }\n\n  if(thread_.get_id() != std::this_thread::get_id()) {\n    return status_;\n  }\n\n  if(status_ != NodeStatus::RUNNING) {\n    return status_;\n  }\n\n  if(halt_requested_) {\n    setStatus(NodeStatus::IDLE);\n    return status_;\n  }\n\n  if(exception_) {\n    std::rethrow_exception(exception_);\n  }\n\n  return status_;\n}", "CodeBleu_score": 45.83252786869654}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t//  std::cout << \"executeTick \" << getName() << \" \" << std::this_thread::get_id() << std::endl;\n  if (status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_ = false;\n    std::thread([this](){\n      try {\n        tick_functor_(*this);\n      } catch (const std::exception& e) {\n        setStatus(NodeStatus::IDLE);\n        std::cerr << \"Caught exception in \" << getName() << \": \" << e.what() << std::endl;\n      } catch (...) {\n        setStatus(NodeStatus::IDLE);\n        std::cerr << \"Caught exception in \" << getName() << \": Unknown\" << std::endl;\n      }\n    }).detach();\n  }\n\n  if (status() == NodeStatus::RUNNING && !halt_requested_) {\n    setStatus(tick_functor_(*this));\n  }\n\n  if (status() == NodeStatus::RUNNING && halt_requested_) {\n    setStatus(NodeStatus::IDLE);\n  }\n\n  std::exception_ptr e = std::current_exception();\n  if (e) {\n    std::rethrow_exception(e);\n  }\n\n  return status();\n}", "CodeBleu_score": 52.65952810905783}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t//  std::cout << \"executeTick\" << std::endl;\n  NodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  std::future<NodeStatus> async_future = std::async(&ThreadedAction::tick, this);\n\n  if(async_future.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n    NodeStatus status = async_future.get();\n    if(status != prev_status) {\n      setStatus(status);\n    }\n    return status;\n  }\n\n  if(halt_requested_) {\n    setStatus(NodeStatus::IDLE);\n    return NodeStatus::IDLE;\n  }\n\n  try {\n    status = async_future.get();\n  } catch(std::exception& e) {\n    std::string msg = \"Caught exception in action '\" + registrationName_ + \"': \" + e.what();\n    throw BT::RuntimeError(msg);\n  }\n\n  if(status != prev_status) {\n    setStatus(status);\n  }\n  return status;\n}", "CodeBleu_score": 49.27867357741597}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// Define a lambda function to handle the printing.\nauto print_node = [&stream](const TreeNode* node, int depth) {\n// Print the node's name.\nfor (int i = 0; i < depth; ++i) {\nstream << \"  \";\n}\nstream << node->name << std::endl;\n};\n// Define a lambda function to recursively print the children.\nauto print_children = [&print_node, &stream](const TreeNode* node, int depth) {\n// Recursively print the children.\nfor (const TreeNode* child : node->children) {\nprint_node(child, depth + 1);\nprint_children(child, depth + 1);\n}\n};\n// Print the root node's name.\nstream << root_node->name << std::endl;\n// Print the children.\nprint_children(root_node, 1);\n}", "CodeBleu_score": 36.36865005957163}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// Print the root node's name and depth.\nstream << std::string(root_node->depth(), ' ') << root_node->name() << std::endl;\n\n// Handle the root node's children.\nif (const ControlNode* control = dynamic_cast<const ControlNode*>(root_node)) {\nfor (const TreeNode* child : control->children()) {\nprintTreeRecursively(child, stream);\n}\n} else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(root_node)) {\nprintTreeRecursively(decorator->child(), stream);\n}\n}", "CodeBleu_score": 28.508417205553766}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"----------------------------------------\" << std::endl;\n\tstd::function<void(const TreeNode*, unsigned int)> print_tree_recursively = [&stream, &print_tree_recursively](const TreeNode* node, unsigned int depth) {\n\t\tstream << std::string(depth, '\\t') << node->name << std::endl;\n\t\tif (const auto control = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children) {\n\t\t\t\tprint_tree_recursively(child, depth + 1);\n\t\t\t}\n\t\t} else if (const auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tprint_tree_recursively(decorator->child, depth + 1);\n\t\t}\n\t};\n\tprint_tree_recursively(root_node, 0);\n\tstream << \"----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 43.84562847318022}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node) {\nthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n}\n\nvisitor(node);\n\nif(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\nfor(const auto& child : control->children()) {\napplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n}\n} else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\napplyRecursiveVisitor(decorator->child(), visitor);\n}\n}", "CodeBleu_score": 96.11413984683801}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node) {\nthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n}\n\nvisitor(node);\n\nif(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\nfor(const auto& child : control->children()) {\napplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n}\n} else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\napplyRecursiveVisitor(decorator->child(), visitor);\n}\n}", "CodeBleu_score": 96.11413984683801}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node) {\nthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n}\n\nvisitor(node);\n\nif(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\nfor(const auto& child : control->children()) {\napplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n}\n} else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\napplyRecursiveVisitor(decorator->child(), visitor);\n}\n}", "CodeBleu_score": 96.11413984683801}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\t// Check if the registration ID already exists in the builders map\n\tif (_p->builders.find(manifest.registration_id) != _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\"A node builder with the same registration ID already exists\");\n\t}\n\n\t// Insert the builder and manifest into their respective maps using the registration ID\n\t_p->builders[manifest.registration_id] = builder;\n\t_p->manifests[manifest.registration_id] = manifest;\n}", "CodeBleu_score": 48.97232499895225}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\n}", "CodeBleu_score": 4.889503087170041}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\n}", "CodeBleu_score": 4.889503087170041}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\nauto builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n  return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n};\n\nTreeNodeManifest manifest(ID, NodeType::SIMPLE_ACTION, ports);\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 56.28411880827494}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\nBehaviorTreeFactory::NodeBuilder builder = [tick_functor](const std::string& ID,\n                                                          const NodeConfiguration& config) {\n  return std::make_unique<SimpleActionNode>(ID, config, tick_functor);\n};\n\nTreeNodeManifest manifest = { ID, NodeType::SIMPLE_ACTION, ports };\n\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 67.39695610247949}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\nNodeBuilder builder = [tick_functor, ports](const std::string& ID) {\n  return std::make_unique<SimpleActionNode>(ID, tick_functor, ports);\n};\n\nTreeNodeManifest manifest = { ID, NodeType::SIMPLE_ACTION, ports };\n\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 59.37461933399474}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backup;\n\tbb_backup.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tBlackboard::Ptr bb = Blackboard::create();\n\t\tsubtree->blackboard->cloneInto(bb.get());\n\t\tbb_backup.push_back(bb);\n\t}\n\treturn bb_backup;\n}", "CodeBleu_score": 58.745120824848705}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backups;\n\tbb_backups.reserve(tree.subtrees.size());\n\tfor (auto subtree : tree.subtrees) {\n\t\tauto bb = std::make_shared<Blackboard>();\n\t\tsubtree->blackboard->cloneInto(bb);\n\t\tbb_backups.push_back(bb);\n\t}\n\treturn bb_backups;\n}", "CodeBleu_score": 56.55054646284903}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb_backups;\nbb_backups.reserve(tree.subtrees.size());\nfor (const auto& subtree : tree.subtrees) {\nBlackboard::Ptr bb = Blackboard::create();\nsubtree->blackboard->cloneInto(bb.get());\nbb_backups.push_back(bb);\n}\nreturn bb_backups;\n}", "CodeBleu_score": 59.163741080570276}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t auto executor = ParseScript(script);\n if(executor.has_value()) {\n  return executor.value()(env);\n }\n else {\n  return nonstd::make_unexpected(executor.error());\n }\n}", "CodeBleu_score": 86.40183907960095}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\nif(executor.has_value()) {\ntry {\nreturn executor.value()(env);\n} catch(RuntimeError& err) {\nreturn nonstd::make_unexpected(err.what());\n}\n} else {\nreturn nonstd::make_unexpected(executor.error());\n}\n}", "CodeBleu_score": 79.69610203508269}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\nif(executor.has_value()) {\nreturn executor.value()(env);\n}\nelse {\nreturn executor.error();\n}\n}", "CodeBleu_score": 72.29818431012325}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (isLoaded()) throw RuntimeError(\"Library is already loaded\");\n\tstd::string error;\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\terror = dlerror();\n\t\tthrow RuntimeError(error);\n\t}\n\tlibraryPath = path;\n}", "CodeBleu_score": 51.6525292994358}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tif (loaded_) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (loaded_) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tdlerror();\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tconst char* error = dlerror();\n\tif (error != NULL) {\n\t\tthrow RuntimeError(error);\n\t}\n\tloaded_ = true;\n\tpath_ = path;\n}", "CodeBleu_score": 55.66785127447238}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tif (this->loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tthis->path = path;\n\tthis->handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!this->handle) {\n\t\tthrow RuntimeError(\"dlopen failed: \" + std::string(dlerror()));\n\t}\n\tthis->loaded = true;\n}", "CodeBleu_score": 37.57794247575889}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.trim();\n\tif (stripped.front() != '{' || stripped.back() != '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer != NULL) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 22.992311406507607}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView trimmed_str = str.trim();\n\n\tif (trimmed_str.front() != '{' || trimmed_str.back() != '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = trimmed_str.substr(1, trimmed_str.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 23.017586249745452}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tstr.trim();\n\tif (str.front() != '{' || str.back() != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 20.893359004624863}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\n}", "CodeBleu_score": 4.1204656963574955}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\n}", "CodeBleu_score": 4.1204656963574955}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\n}", "CodeBleu_score": 4.1204656963574955}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty())  {\n\t\tROS_WARN_STREAM(\"Path is empty. Not publishing plan\");\n\t\treturn;\n\t}\n\tROS_INFO_STREAM(\"Publishing plan of length \" << path.size());\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tgui_path.header.stamp = path.front().header.stamp;\n\tgui_path.poses.resize(path.size());\n\tgui_path.poses = path;\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 49.31378857943599}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Path is empty. Not publishing plan\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tgui_path.header.stamp = path.front().header.stamp;\n\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 70.03422743183651}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\nROS_WARN_STREAM(\"Cannot publish empty path\");\nreturn;\n}\n\nnav_msgs::Path gui_path;\ngui_path.header.frame_id = path.front().header.frame_id;\ngui_path.header.stamp = path.front().header.stamp;\ngui_path.poses.resize(path.size());\n\nfor (size_t i = 0; i < path.size(); ++i) {\ngui_path.poses[i] = path[i];\n}\n\npub.publish(gui_path);\n}", "CodeBleu_score": 68.29125601779232}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}", "CodeBleu_score": 63.0430762213567}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// TODO: Implement this function\n\t// Return true if the robot is stopped, false otherwise\n\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\tif (fabs(rot_vel) <= rot_stopped_velocity && fabs(trans_vel) <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.40126584661024}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) && (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}", "CodeBleu_score": 54.695409491608004}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\tsetup_ = true;\n\t} else if (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\tstd::lock_guard<std::mutex> lock(config_mutex_);\n\tcurrent_limits_ = config;\n}", "CodeBleu_score": 63.23491566625642}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig = default_limits;\n\t\tsetup = false;\n\t}\n\tif (!setup) {\n\t\tdefault_limits = config;\n\t\tsetup = true;\n\t}\n\tstd::lock_guard<std::mutex> lock(mutex);\n\tcurrent_limits = config;\n}", "CodeBleu_score": 52.25899311616586}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// Check if the cell is an obstacle or unknown.\nif (check_cell->cost >= costmap.getCostmap()->getObstacleCost()) {\n// If the cell is an obstacle, set the target distance to the maximum obstacle cost.\ncurrent_cell->target_distance = costmap.getCostmap()->getObstacleCost();\nreturn false;\n}\n// If the cell is not an obstacle, calculate a new target distance.\ndouble new_target_distance = current_cell->cost + check_cell->cost;\n// Check if the new target distance is shorter than the current target distance.\nif (new_target_distance < current_cell->target_distance) {\ncurrent_cell->target_distance = new_target_distance;\nreturn true;\n}\nreturn false;\n}", "CodeBleu_score": 39.554163337412994}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n// Check if the cell is an obstacle or has no information.\nif (check_cell->isObstacle() || !check_cell->hasInfo()) {\ncurrent_cell->setCost(obstacleCosts);\nreturn false;\n}\n\n// Calculate the new target distance.\ndouble new_cost = current_cell->getCost() + costmap.getCost(check_cell->getIndex());\n\n// Update the cell's target distance if the new distance is shorter.\nif (new_cost < current_cell->getCost()) {\ncurrent_cell->setCost(new_cost);\nreturn true;\n}\n\nreturn false;\n}", "CodeBleu_score": 35.35751802431538}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t//  if (check_cell->isObstacle()) {\n//    check_cell->target_dist = obstacleCosts;\n//    return false;\n//  }\n//  if (check_cell->isUnknown()) {\n//    check_cell->target_dist = obstacleCosts;\n//    return false;\n//  }\n//  double new_dist = current_cell->dist + costmap.getCost(check_cell->x, check_cell->y);\n//  if (new_dist < check_cell->target_dist) {\n//    check_cell->target_dist = new_dist;\n//    return true;\n//  }\n//  return false;\n}", "CodeBleu_score": 6.256796312639722}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t_\n\n\n}", "CodeBleu_score": 2.521565991195874}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t_\n\n\n}", "CodeBleu_score": 2.521565991195874}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In setOdomTopic with topic %s\", odom_topic.c_str());\n  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 52.612164122600234}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic != odom_topic_) {\n\t\tif (!odom_topic.empty()) {\n\t\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t\todom_topic_ = odom_topic;\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t\todom_topic_ = odom_topic;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.16675051769223}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In setOdomTopic with topic %s\", odom_topic.c_str());\n  boost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to odometry topic: %s\", odom_topic_.c_str());\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    } else {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Shutting down odometry subscriber\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 47.74782958325326}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat dist = (pos - prev).squaredNorm();\n\tfloat angle = fabs(angle_diff(pos, prev));\n\n\tif (dist > 0.01) {\n\t\tresetOscillationFlags();\n\t} else if (angle > 0.2) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 31.611835668973043}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t", "CodeBleu_score": 5.324294863153016}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tif (prev.norm() == 0) {\n\t\treturn;\n\t}\n\n\tfloat dist = (pos - prev).squaredNorm();\n\tif (dist > 0.00001) {\n\t\tfloat angle = fabs(angleBetweenVectors(pos, prev));\n\t\tif (angle > 0.00001) {\n\t\t\tresetOscillationFlags();\n\t\t}\n\t}\n}", "CodeBleu_score": 29.94835898989824}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\nstd::cout << \"target vel: \" << sample_target_vel.transpose() << std::endl;\nstd::cout << \"current vel: \" << vel.transpose() << std::endl;\nstd::cout << \"acc limits: \" << acclimits.transpose() << std::endl;\nstd::cout << \"dt: \" << dt << std::endl;\n\nEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\nif (sample_target_vel.norm() > 0) {\n    for (int i = 0; i < 3; i++) {\n        // Check if we are already at the target velocity\n        if (std::abs(sample_target_vel[i]) < std::abs(vel[i])) {\n            new_vel[i] = sample_target_vel[i];\n        } else {\n            // Otherwise, compute the new velocity\n            new_vel[i] = vel[i] + acclimits[i] * dt;\n            if (new_vel[i] > sample_target_vel[i]) {\n                new_vel[i] = sample_target_vel[i];\n            } else if (new_vel[i] < -sample_target_vel[i]) {\n                new_vel[i] = -sample_target_vel[i];\n            }\n        }\n    }\n}\n\nstd::cout << \"new vel: \" << new_vel.transpose() << std::endl;\n\nreturn new_vel;\n}", "CodeBleu_score": 57.31639901911478}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\nstd::cout << \"SimpleTrajectoryGenerator::computeNewVelocities\" << std::endl;\nstd::cout << \"sample_target_vel: \" << sample_target_vel.transpose() << std::endl;\nstd::cout << \"vel: \" << vel.transpose() << std::endl;\nstd::cout << \"acclimits: \" << acclimits.transpose() << std::endl;\nstd::cout << \"dt: \" << dt << std::endl;\nEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n// Compute new velocities for each of the three components.\nfor (int i = 0; i < 3; i++) {\n\n// If the target velocity is less than the current velocity, decrease the velocity.\nif (sample_target_vel[i] < vel[i]) {\n\n// If the decrease in velocity will result in a velocity less than the acceleration limit, set the new velocity to the acceleration limit.\nif (vel[i] - sample_target_vel[i] < acclimits[i] * dt) {\nnew_vel[i] = vel[i] - acclimits[i] * dt;\n}\n\n// Otherwise, set the new velocity to the target velocity.\nelse {\nnew_vel[i] = sample_target_vel[i];\n}\n\n}\n\n// If the target velocity is greater than the current velocity, increase the velocity.\nelse {\n\n// If the increase in velocity will result in a velocity greater than the acceleration limit, set the new velocity to the acceleration limit.\nif (sample_target_vel[i] - vel[i] < acclimits[i] * dt) {\nnew_vel[i] = vel[i] + acclimits[i] * dt;\n}\n\n// Otherwise, set the new velocity to the target velocity.\nelse {\nnew_vel[i] = sample_target_vel[i];\n}\n\n}\n\n}\n\nstd::cout << \"new_vel: \" << new_vel.transpose() << std::endl;\nreturn new_vel;\n}", "CodeBleu_score": 59.43090663845829}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\nstd::min\nstd::max\nEigen::Vector3f::Zero\nstd::min\nstd::max\nEigen::Vector3f::Zero\nstd::min\nstd::max\nEigen::Vector3f::Zero\n\n}", "CodeBleu_score": 13.912321831967017}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//  ROS_INFO(\"headingDiff: %d %d %f %f %f\", cell_x, cell_y, x, y, heading);\n\n  // Find the farthest point on the global plan with a clear line of sight from the robot's current cell.\n  int i = 0;\n  int max_dist = 0;\n  int goal_x = 0;\n  int goal_y = 0;\n  double max_dist_x = 0;\n  double max_dist_y = 0;\n  double goal_x_world = 0;\n  double goal_y_world = 0;\n  double goal_heading = 0;\n\n  while (i < global_plan_.size()) {\n    if (global_plan_[i].is_in_free_space) {\n      if (lineOfSight(cell_x, cell_y, global_plan_[i].x, global_plan_[i].y)) {\n        int dist = hypot(cell_x - global_plan_[i].x, cell_y - global_plan_[i].y);\n        if (dist > max_dist) {\n          max_dist = dist;\n          goal_x = global_plan_[i].x;\n          goal_y = global_plan_[i].y;\n          max_dist_x = global_plan_[i].x;\n          max_dist_y = global_plan_[i].y;\n        }\n      }\n    }\n    i++;\n  }\n\n  // If a valid point was found, convert the goal cell coordinates to world coordinates and return the absolute value of the shortest angular distance between the current heading and the direction to the goal point.\n  if (max_dist > 0) {\n    goal_x_world = costmap_.mapToWorld(goal_x, goal_y).x;\n    goal_y_world = costmap_.mapToWorld(goal_x, goal_y).y;\n    goal_heading = atan2(goal_y_world - y, goal_x_world - x);\n    return fabs(angles::shortest_angular_distance(heading, goal_heading));\n  }\n\n  // If no valid point was found, return DBL_MAX.\n  else {\n    return DBL_MAX;\n  }\n}", "CodeBleu_score": 45.559787719008725}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t// Iterate through the global plan in reverse until a valid point is found\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Convert the goal cell coordinates to world coordinates\n\t\tdouble gx = costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y).x;\n\t\tdouble gy = costmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y).y;\n\n\t\t// Check if a clear line of sight exists between the current cell and the goal point\n\t\tif (lineOfSight(cell_x, cell_y, gx, gy)) {\n\t\t\t// Return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n\t\t\treturn fabs(angles::shortest_angular_distance(heading, atan2(gy - y, gx - x)));\n\t\t}\n\t}\n\n\t// Return DBL_MAX if no valid point is found\n\treturn DBL_MAX;\n}", "CodeBleu_score": 56.78132021514127}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t", "CodeBleu_score": 10.045376955426562}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t", "CodeBleu_score": 10.045376955426562}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\nROS_INFO(\"Checking trajectory with vx_samp=%f vy_samp=%f vtheta_samp=%f\", vx_samp, vy_samp, vtheta_samp);\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n        ROS_WARN(\"Sampled velocities were out of bounds. vx_samp=%f vy_samp=%f vtheta_samp=%f cost=%f\", vx_samp, vy_samp, vtheta_samp, cost);\n        return false;\n    }\n    return true;\n  }", "CodeBleu_score": 71.87667077487194}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\nROS_ERROR(\"This object must be initialized before runBehavior() can be called\");\nreturn;\n}\n\nif (global_costmap_ == NULL) {\nROS_ERROR(\"The global costmap is NULL, cannot clear\");\nreturn;\n}\n\nif (local_costmap_ == NULL) {\nROS_ERROR(\"The local costmap is NULL, cannot clear\");\nreturn;\n}\n\nif (clear_inside_radius_ > 0.0) {\nROS_WARN(\"Clearing inside a radius of %f\", clear_inside_radius_);\n}\n\nif (clear_outside_radius_ > 0.0) {\nROS_WARN(\"Clearing outside a radius of %f\", clear_outside_radius_);\n}\n\nif (clear_inside_radius_ > 0.0 && clear_outside_radius_ > 0.0) {\nROS_ERROR(\"Both inside and outside radii specified, cannot clear\");\nreturn;\n}\n\n// clear the costmaps\nros::WallTime t0 = ros::WallTime::now();\n\nif (affected_maps_ == CLEAR_ALL) {\nclear();\n} else if (affected_maps_ == CLEAR_GLOBAL_AND_LOCAL_COSTS) {\nclear();\n} else if (affected_maps_ == CLEAR_GLOBAL_COSTMAP_ONLY) {\nclear();\n} else if (affected_maps_ == CLEAR_LOCAL_COSTMAP_ONLY) {\nclear();\n} else {\nROS_ERROR(\"Unknown affected_maps_ value\");\nreturn;\n}\n\nROS_DEBUG(\"Clearing costmaps took %f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 45.57366847047095}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\nROS_ERROR(\"ClearCostmapRecovery has not been initialized, cannot run\");\nreturn;\n}\n\nif (global_costmap_ == NULL) {\nROS_ERROR(\"Global costmap is NULL, cannot run\");\nreturn;\n}\n\nif (local_costmap_ == NULL) {\nROS_ERROR(\"Local costmap is NULL, cannot run\");\nreturn;\n}\n\nif (global_costmap_->getRobotPose().isZero() || local_costmap_->getRobotPose().isZero()) {\nROS_ERROR(\"Cannot clear map because pose cannot be retrieved\");\nreturn;\n}\n\ngeometry_msgs::PoseStamped pose;\n\nif(!global_costmap_->getRobotPose(pose)){\nROS_ERROR(\"Cannot clear map because pose cannot be retrieved\");\nreturn;\n}\n\ndouble x = pose.pose.position.x;\ndouble y = pose.pose.position.y;\n\nif (invert_area_to_clear_) {\nif (x > x_min_ && x < x_max_ && y > y_min_ && y < y_max_) {\nROS_WARN(\"Clearing costmap outside specified area\");\n}\n}\nelse {\nif (x > x_min_ && x < x_max_ && y > y_min_ && y < y_max_) {\nROS_WARN(\"Clearing costmap inside specified area\");\n}\n}\n\nif (affected_maps_ & CLEAR_GLOBAL_COSTMAP) {\nROS_DEBUG(\"Clearing global costmap\");\nt0 = ros::WallTime::now();\nglobal_costmap_->updateMap();\nROS_DEBUG(\"Time to update global costmap: %f\", (ros::WallTime::now() - t0).toSec());\n}\n\nif (affected_maps_ & CLEAR_LOCAL_COSTMAP) {\nROS_DEBUG(\"Clearing local costmap\");\nt0 = ros::WallTime::now();\nlocal_costmap_->updateMap();\nROS_DEBUG(\"Time to update local costmap: %f\", (ros::WallTime::now() - t0).toSec());\n}\n\n}", "CodeBleu_score": 53.177913649616436}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells outline_cells;\n\tpolygon_cells.clear();\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tif (i + 1 < polygon.size()) {\n\t\t\traytraceLine(polygon[i], polygon[i + 1], outline_cells);\n\t\t} else {\n\t\t\traytraceLine(polygon[i], polygon[0], outline_cells);\n\t\t}\n\t}\n\tif (polygon.size() > 0) {\n\t\tpolygon_cells.insert(polygon_cells.end(), outline_cells.begin(), outline_cells.end());\n\t}\n}", "CodeBleu_score": 52.63657037115349}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outline_cells;\n\n\tfor (size_t i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(polygon[i], polygon[i + 1], outline_cells);\n\t}\n\n\traytraceLine(polygon[polygon.size() - 1], polygon[0], outline_cells);\n\n\tpolygon_cells = outline_cells.cells;\n}", "CodeBleu_score": 49.205432533120664}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tpolygon_cells.clear();\n\tpolygon_cells.reserve(polygon.size());\n\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\traytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n\t}\n\traytraceLine(polygon.back(), polygon.front(), polygon_cells);\n}", "CodeBleu_score": 44.9946283432833}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tROS_DEBUG(\"New subscriber to costmap\");\n\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 66.39572633874744}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\npub.publish(grid_);\n}", "CodeBleu_score": 93.87790599234785}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tmutex_.lock();\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tint translation_table[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\tfor (int i = 0; i < 10; i++) {\n\t\ttranslation_table[i] = costmap_->getCharMap()[i];\n\t}\n\tfor (int i = 0; i < grid_.info.height; i++) {\n\t\tfor (int j = 0; j < grid_.info.width; j++) {\n\t\t\tgrid_.data[i * grid_.info.width + j] = translation_table[costmap_->getCharMap()[i * grid_.info.width + j]];\n\t\t}\n\t}\n\tmutex_.unlock();\n}", "CodeBleu_score": 59.05514450190591}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tif (!costmap_) {\n\t\tROS_ERROR(\"No costmap specified. Nothing to publish.\");\n\t\treturn;\n\t}\n\n\t// Lock the costmap\n\tboost::recursive_mutex::scoped_lock lock(*costmap_->getMutex());\n\n\t// Get the resolution\n\tresolution_ = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the grid's resolution, width, and height\n\tgrid_.info.resolution = resolution_;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tgeometry_msgs::Point origin_world_point;\n\tcostmap_->mapToWorld(0, 0, origin_world_point.x, origin_world_point.y);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin_world_point.x;\n\tgrid_.info.origin.position.y = origin_world_point.y;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_x_ = grid_.info.origin.position.x;\n\torigin_y_ = grid_.info.origin.position.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tunsigned int i = 0;\n\tunsigned int j = 0;\n\tfor (int y = 0; y < costmap_->getSizeInCellsY(); y++) {\n\t\tfor (int x = 0; x < costmap_->getSizeInCellsX(); x++) {\n\t\t\tunsigned char value = costmap_->getCharMap()[y * costmap_->getSizeInCellsX() + x];\n\t\t\tgrid_.data[i] = translation_table_[value];\n\t\t\ti++;\n\t\t}\n\t}\n}", "CodeBleu_score": 61.75446514937004}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tmutex_.lock();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = costmap_->getResolution();\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Set the origin\n\tgeometry_msgs::Pose origin;\n\torigin.position.x = costmap_->getOriginX();\n\torigin.position.y = costmap_->getOriginY();\n\torigin.position.z = 0;\n\torigin.orientation.x = 0;\n\torigin.orientation.y = 0;\n\torigin.orientation.z = 0;\n\torigin.orientation.w = 1;\n\tgrid_.info.origin = origin;\n\n\t// Resize the data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data\n\tfor (unsigned int i = 0; i < grid_.data.size(); i++) {\n\t\tgrid_.data[i] = costmap_->getCharMap()[i];\n\t}\n\tmutex_.unlock();\n}", "CodeBleu_score": 50.19428204320512}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t//  if (new_config.robot_radius == old_config.robot_radius && new_config.footprint == old_config.footprint) {\n//    return;\n//  }\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    if (!makeFootprintFromString(new_config.footprint, points)) {\n      ROS_ERROR(\"Invalid footprint provided. Using default footprint instead.\");\n    } else {\n      setUnpaddedRobotFootprint(points);\n    }\n  } else {\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n  }\n}", "CodeBleu_score": 50.53637021913341}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t", "CodeBleu_score": 4.722552995136935}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n}", "CodeBleu_score": 4.80081231526899}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\n}", "CodeBleu_score": 9.421357781568524}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\n}", "CodeBleu_score": 9.421357781568524}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped new_pose;\nif (!getRobotPose(new_pose)) {\nROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\nreconfigure_server_.cancel();\nreturn;\n}\n\n// check if the pose has changed\nif (new_pose.pose.position.x != last_pose_.pose.position.x || new_pose.pose.position.y != last_pose_.pose.position.y || new_pose.pose.position.z != last_pose_.pose.position.z || new_pose.pose.orientation.x != last_pose_.pose.orientation.x || new_pose.pose.orientation.y != last_pose_.pose.orientation.y || new_pose.pose.orientation.z != last_pose_.pose.orientation.z || new_pose.pose.orientation.w != last_pose_.pose.orientation.w) {\n// store the new pose\nlast_pose_ = new_pose;\n// update the costmap\nupdateCostmap(last_pose_);\n}\n}", "CodeBleu_score": 64.90337995912817}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t// Retrieve the list of plugins\npluginlib::ClassLoader<costmap_2d::Costmap2D> *loader = NULL;\nloader = pluginlib::ClassLoader<costmap_2d::Costmap2D>::getLoader();\nstd::vector<std::string> plugins = loader->getDeclaredClasses();\n\n// Check if the costmap is stopped\nif (stopped_) {\n// Loop through the plugins\nfor (std::vector<std::string>::iterator plugin = plugins.begin(); plugin != plugins.end(); ++plugin) {\n// Activate the plugin\nROS_DEBUG(\"Activating plugin %s\", (*plugin).c_str());\npluginlib::ClassLoader<costmap_2d::Costmap2D>::loadLibrary(*plugin);\nCostmap2D *plugin_instance = loader->createInstance(*plugin);\nlayered_costmap_->addCostmap(plugin_instance);\nplugin_instance->activate();\n}\n\n// Set the stopped flag to false\nstopped_ = false;\n\n// Set the stop_updates_ flag to false\nstop_updates_ = false;\n\n// Wait for the costmap to be initialized\nwhile (!initialized_) {\nros::WallDuration(0.01).sleep();\n}\n\n// Wait for the map update thread to be active\nwhile (!update_thread_->isActive()) {\nros::WallDuration(0.01).sleep();\n}\n}\n\n// Wait for ROS to be running\nwhile (!ros::ok()) {\nros::WallDuration(0.01).sleep();\n}\n}", "CodeBleu_score": 46.6696266593496}, {"code": "void Costmap2DROS::start(){\n\t\tif (initialized_) {\n\t\tROS_INFO(\"Costmap2DROS is already initialized, not re-initializing\");\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\tROS_WARN(\"ROS is not yet initialized, waiting for it to become available...\");\n\t\twhile (!ros::ok()) {\n\t\t\tros::WallDuration(0.1).sleep();\n\t\t}\n\t\tROS_INFO(\"ROS is now available\");\n\t}\n\tif (initialized_ && !stop_updates_) {\n\t\tROS_INFO(\"Costmap2DROS is already initialized and not stopped, not re-activating plugins\");\n\t\treturn;\n\t}\n\tif (initialized_) {\n\t\tROS_WARN(\"Costmap2DROS is already initialized, but is stopped. Activating plugins...\");\n\t}\n\tstop_updates_ = false;\n\tinitialized_ = true;\n\tplugins->begin();\n\twhile (plugins->hasNext()) {\n\t\tboost::shared_ptr<Costmap2DPlugin> plugin = plugins->next();\n\t\tplugin->activate();\n\t}\n\tplugins->end();\n\twhile (!initialized_ || !map_update_thread_->isActive()) {\n\t\tros::WallDuration(0.1).sleep();\n\t}\n\tROS_INFO(\"Costmap2DROS is now initialized\");\n}", "CodeBleu_score": 42.69186897210119}, {"code": "void Costmap2DROS::start(){\n\t//  ROS_INFO(\"Starting costmap\");\n\n  // Retrieve list of plugins\n  std::vector<Costmap2DPlugin*>* plugins = layered_costmap_->getPlugins();\n\n  // Check if costmap is stopped\n  if (stop_updates_) {\n    // Loop through plugins\n    for (std::vector<Costmap2DPlugin*>::iterator plugin = plugins->begin(); plugin != plugins->end(); ++plugin) {\n      // Activate plugin\n      (*plugin)->activate();\n    }\n\n    // Clear stop flag\n    stop_updates_ = false;\n  }\n\n  // Wait until costmap is initialized and update thread is active\n  while (!initialized_ || !update_thread_->isActive()) {\n    r.sleep();\n  }\n}", "CodeBleu_score": 59.359938943923375}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0)) {\nROS_DEBUG_STREAM(\"ObservationBuffer: Keeping only the most recent observation\");\nobservation_list_.erase(observation_list_.begin(), --observation_list_.end());\n} else {\nROS_DEBUG_STREAM(\"ObservationBuffer: Removing observations older than \" << observation_keep_time_);\nfor (auto it = observation_list_.begin(); it != observation_list_.end();) {\nif ((*it).header.stamp + observation_keep_time_ < ros::Time::now()) {\nit = observation_list_.erase(it);\n} else {\nbreak;\n}\n}\n}\n}", "CodeBleu_score": 40.30391193636087}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tObservationList::iterator it = observation_list_.begin();\nwhile (it != observation_list_.end()) {\nif (it->second.isStale(observation_keep_time_)) {\nit = observation_list_.erase(it);\n} else {\n++it;\n}\n}\n}", "CodeBleu_score": 26.576370112375063}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t//  // ROS_DEBUG_STREAM(\"ObservationBuffer::purgeStaleObservations\");\n  if (observation_keep_time_ == ros::Duration(0)) {\n    // If the observation keep time is zero, we keep only the most recent observation\n    if (observation_list_.size() > 0) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.begin() + observation_list_.size() - 1);\n    }\n  } else {\n    // Otherwise, we iterate through the list and remove observations that are older than the specified keep time\n    ObservationList::iterator it = observation_list_.begin();\n    while (it != observation_list_.end()) {\n      if (it->header.stamp < ros::Time::now() - observation_keep_time_) {\n        it = observation_list_.erase(it);\n      } else {\n        ++it;\n      }\n    }\n  }\n}", "CodeBleu_score": 47.06538595916714}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t", "CodeBleu_score": 6.399560589259802}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t:\n  // If the start and end indices are the same, do nothing\n  if (start_index == end_index) {\n    return;\n  }\n  // Get the yaw angles at the start and end indices\n  double start_angle = getYaw(path[start_index].pose.orientation);\n  double end_angle = getYaw(path[end_index].pose.orientation);\n  // Calculate the shortest angular distance between the start and end angles\n  double shortest_angular_distance = shortestAngularDistance(start_angle, end_angle);\n  // If the shortest angular distance is greater than the threshold, update the path\n  if (shortest_angular_distance > threshold_angle_) {\n    // Calculate the incremental change in angle for each pose in the path\n    double angle_increment = shortest_angular_distance / (end_index - start_index);\n    // Update the orientation of each pose in the path\n    for (int i = start_index + 1; i < end_index; i++) {\n      set_angle(&path[i], angle_increment * (i - start_index));\n    }\n  }\n}", "CodeBleu_score": 53.69966533568118}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t,\n  // Get the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Compute the shortest angular distance between the yaw angles\n  double yaw_diff = shortest_angular_distance(start_yaw, end_yaw);\n\n  // Compute the incremental change in angle for each pose\n  double angle_diff = yaw_diff / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i <= end_index; i++) {\n    set_angle(&path[i], angle_diff * (i - start_index));\n  }\n}", "CodeBleu_score": 59.813002044148575}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make plan request\");\n\tresp.status.status = resp.status.SUCCESS;\n\tresp.status.text = \"Received a make plan request\";\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.start.pose.position.x = req.start.pose.position.x;\n\tresp.plan.start.pose.position.y = req.start.pose.position.y;\n\tresp.plan.start.pose.position.z = req.start.pose.position.z;\n\tresp.plan.start.pose.orientation.x = req.start.pose.orientation.x;\n\tresp.plan.start.pose.orientation.y = req.start.pose.orientation.y;\n\tresp.plan.start.pose.orientation.z = req.start.pose.orientation.z;\n\tresp.plan.start.pose.orientation.w = req.start.pose.orientation.w;\n\tresp.plan.goal.pose.position.x = req.goal.pose.position.x;\n\tresp.plan.goal.pose.position.y = req.goal.pose.position.y;\n\tresp.plan.goal.pose.position.z = req.goal.pose.position.z;\n\tresp.plan.goal.pose.orientation.x = req.goal.pose.orientation.x;\n\tresp.plan.goal.pose.orientation.y = req.goal.pose.orientation.y;\n\tresp.plan.goal.pose.orientation.z = req.goal.pose.orientation.z;\n\tresp.plan.goal.pose.orientation.w = req.goal.pose.orientation.w;\n\tmakePlan(resp.plan);\n\treturn true;\n}", "CodeBleu_score": 32.684421983208814}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make plan request\");\n\n\t// Set the start and goal frame ids to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a plan\n\tmakePlan(req, resp);\n\n\t// Indicate success\n\treturn true;\n}", "CodeBleu_score": 39.02541889382023}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make plan request\");\n\tROS_INFO(\"Frame ID: %s\", req.start.header.frame_id.c_str());\n\tROS_INFO(\"Start: (%f, %f, %f)\", req.start.pose.position.x, req.start.pose.position.y, req.start.pose.position.z);\n\tROS_INFO(\"Goal: (%f, %f, %f)\", req.goal.pose.position.x, req.goal.pose.position.y, req.goal.pose.position.z);\n\n\t// Set the frame_id to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tmakePlan(req, resp);\n\n\t// Return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 46.64791130359846}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n}", "CodeBleu_score": 18.654488076502528}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\nprivate_nh = ros::NodeHandle(\"~/\" + name);\n\nmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\ngoal_sub = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n\n}", "CodeBleu_score": 67.59719144102544}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh = ros::NodeHandle(\"~/\" + name);\nmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\ngoal_sub = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 60.88952243598514}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() ||\n\t\twy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 42.393818200095204}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n\t\tROS_ERROR(\"GlobalPlanner::worldToMap: world coordinates (%.2f, %.2f) are outside the costmap's origin (%.2f, %.2f)\", wx, wy, costmap_->getOriginX(), costmap_->getOriginY());\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\tif (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n\t\tROS_ERROR(\"GlobalPlanner::worldToMap: map coordinates (%.2f, %.2f) are outside the costmap's size limits (%d, %d)\", mx, my, costmap_->getSizeInCellsX(), costmap_->getSizeInCellsY());\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 43.57364509139876}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\t// Check if the world coordinates are within the bounds of the costmap's origin\n\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() || wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n\t\treturn false;\n\t}\n\t// Calculate the map coordinates using the costmap's resolution and an offset\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 42.38908397336759}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"Global planner has not been initialized yet, path cannot be published\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses.push_back(path[i]);\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 68.96214765541546}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tROS_INFO(\"Publishing plan\");\n\tif (!initialized_) {\n\t\tROS_ERROR(\"The planner has not been initialized, cannot publish plan\");\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = \"map\";\n\tgui_path.header.stamp = ros::Time::now();\n\tgui_path.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 75.10331429755882}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tROS_ERROR_COND(initialized_, \"Global planner is not initialized!\");\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\tgui_path.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tROS_DEBUG_STREAM(\"Publishing plan of length \" << path.size());\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 71.89678269424668}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Received a new goal\");\n\n// Create a new MoveBaseActionGoal\nactionlib_msgs::MoveBaseActionGoal action_goal;\n\n// Set the timestamp of the action goal to the current time\naction_goal.header.stamp = ros::Time::now();\n\n// Assign the goal to the action goal\naction_goal.goal = *goal;\n\n// Publish the action goal to the action server\naction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.5260371683322}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_STREAM(\"Received goal\");\nMoveBaseActionGoal action_goal;\naction_goal.header.stamp = ros::Time::now();\naction_goal.header.frame_id = goal->header.frame_id;\naction_goal.goal.target_pose = *goal;\naction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.66747712884568}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Goal received\");\n\n/*\n * Create a MoveBaseActionGoal object.\n */\nMoveBaseActionGoal action_goal;\n\n/*\n * Set the timestamp to the current time.\n */\naction_goal.header.stamp = ros::Time::now();\n\n/*\n * Assign the goal to the target_pose field of the action_goal.\n */\naction_goal.goal.target_pose = *goal;\n\n/*\n * Publish the action goal to the action_goal_pub_ topic.\n */\naction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 67.70334656348554}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t//  std::cout << \"distanceCheck\" << std::endl;\n  double sq_distance = getSqDistance();\n//  std::cout << \"sq_distance: \" << sq_distance << std::endl;\n  if (sq_distance > sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved %f, stopping limit\", sqrt(sq_distance));\n    remove_limit_thread_->join();\n    delete remove_limit_thread_;\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 61.60939418521934}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tdouble sq_distance = getSqDistance();\nif (sq_distance > sq_distance_limit_) {\nROS_INFO(\"Robot has moved %f m away from the speed limit.\", sqrt(sq_distance));\nremove_limit_thread_->join();\ndelete remove_limit_thread_;\nremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\ndistance_check_timer_.stop();\n}\n}", "CodeBleu_score": 59.71961650992924}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 5.741983659080917}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current pose of the robot.\n\tgeometry_msgs::PoseStamped current_pose;\n\tcurrent_pose = getRobotPose();\n\n\t// Generate a plan from the current pose to the goal pose.\n\tnav_msgs::Path plan;\n\tplan = makePlan(current_pose, goal, plan);\n\n\t// Publish the plan.\n\tplan_pub_.publish(plan);\n}", "CodeBleu_score": 52.035469691667814}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tgeometry_msgs::PoseStamped global_pose = getRobotPose();\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tmakePlan(global_pose, goal, path);\n}", "CodeBleu_score": 50.81898978188125}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current robot pose.\n\tgeometry_msgs::PoseStamped current_pose = getRobotPose();\n\t// Generate a path from the current pose to the goal pose.\n\tmakePlan(current_pose, goal, path_);\n}", "CodeBleu_score": 35.35664840775853}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Set the service request parameters\n\tthis->gimbal_param_set_client_.request.param_id = param_set.param_id;\n\tthis->gimbal_param_set_client_.request.value = param_set.value;\n\n\t// Call the service\n\tthis->gimbal_param_set_client_.call\n}", "CodeBleu_score": 36.361513242452325}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t", "CodeBleu_score": 4.9810584283921004}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t", "CodeBleu_score": 4.9810584283921004}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t\tROS_INFO(\"Server thread started\");\n\tros::NodeHandle n;\n\tros::Rate loop_rate(10);\n\n\t// Create a TCP/IP socket\n\tint sock = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tperror(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\n\t// Bind the socket to the port\n\tstruct sockaddr_in serv_addr;\n\tmemset((char *) &serv_addr, 0, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(serverPort);\n\tif (bind(sock, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tperror(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\n\t// Listen for incoming connections\n\tlisten(sock, 5);\n\tROS_INFO(\"Waiting for a connection from ground station\");\n\n\twhile (ros::ok()) {\n\t\t// Accept a connection\n\t\tstruct sockaddr_in cli_addr;\n\t\tsocklen_t clilen = sizeof(cli_addr);\n\t\tint newsockfd = accept(sock, (struct sockaddr *) &cli_addr, &clilen);\n\t\tif (newsockfd < 0) {\n\t\t\tperror(\"ERROR on accept\");\n\t\t\texit(1);\n\t\t}\n\t\tROS_INFO(\"Accepted connection from ground station\");\n\n\t\t// Receive data\n\t\tchar buffer[256];\n\t\tint n = recv(newsockfd, buffer, 256, 0);\n\t\tif (n <= 0) {\n\t\t\tROS_ERROR(\"ERROR in recv\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Decode the message\n\t\tstd_msgs::String msg;\n\t\tmsg.data = buffer;\n\n\t\t// Publish the message\n\t\tpubMsg(msg);\n\n\t\t// Close the socket\n\t\tclose(newsockfd);\n\n\t\t// Sleep for a while\n\t\tros::spinOnce();\n\t\tloop_rate.sleep();\n\t}\n\n\t// Close the socket\n\tclose(sock);\n}", "CodeBleu_score": 41.059705430223644}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!simulation_) {\n\t\tuav_basic_->uavCmdPub.publish(uav_cmd);\n\t} else {\n\t\tauto it = swarm_control_simulation_.find(uav_cmd.id);\n\t\tif (it != swarm_control_simulation_.end()) {\n\t\t\t(*it).second->uavCmdPub.publish(uav_cmd);\n\t\t}\n\t}\n}", "CodeBleu_score": 44.26077531986622}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (this->simulation_mode_ == false) {\nthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n} else {\nstd::map<int, UAVCommand>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\nif (it != this->swarm_control_simulation_.end()) {\n(*it).second.uav_id = uav_cmd.uav_id;\n(*it).second.uav_cmd = uav_cmd.uav_cmd;\n(*it).second.uav_cmd_seq = uav_cmd.uav_cmd_seq;\n(*it).second.uav_state = uav_cmd.uav_state;\n(*it).second.uav_state_seq = uav_cmd.uav_state_seq;\nthis->swarm_control_simulation_[uav_cmd.uav_id] = (*it).second;\n} else {\nROS_ERROR(\"UAV ID %d not found in swarm_control_simulation_.\", uav_cmd.uav_id);\n}\n}\n}", "CodeBleu_score": 51.26681943713645}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_) {\n\t\t// In simulation mode, find the UAV by ID and publish the command to it\n\t\tauto it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it != this->swarm_control_simulation_.end()) {\n\t\t\tit->second->uav_cmd_pub.publish(uav_cmd);\n\t\t}\n\t} else {\n\t\t// In non-simulation mode, publish the command to all UAVs\n\t\tthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 49.646083499175}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.mode) {\n\t\tcase REBOOTNX:\n\t\t\tsystem(\"reboot -f\");\n\t\t\tbreak;\n\t\tcase EXITNX:\n\t\t\tsystem(\"reboot\");\n\t\t\tbreak;\n\t\tcase CREATE_MODE:\n\t\t\tcreateMode(mode_selection.mode_name, mode_selection.mode_description, mode_selection.mode_code, mode_selection.mode_icon);\n\t\t\tbreak;\n\t\tcase DELETE_MODE:\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 41.69886115848278}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.mode) {\n\tcase REBOOTNX:\n\t\tsystem(\"reboot -f\");\n\t\tbreak;\n\tcase EXITNX:\n\t\tsystem(\"shutdown -h now\");\n\t\tbreak;\n\tcase CREATEMODE:\n\t\tcreateMode(mode_selection.mode_name, mode_selection.use_mode);\n\t\tbreak;\n\tcase DELETEMODE:\n\t\tdeleteMode(mode_selection.mode_name);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 34.232500926568534}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"poweroff\");\n\t} else if (mode_selection.use_mode == CREATE_MODE) {\n\t\tcreateMode(mode_selection.mode_name, mode_selection.mode_description);\n\t} else if (mode_selection.use_mode == DELETE_MODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 50.386100583939175}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t//check for heartbeat\n\tif (heartbeat_count_ == 0) {\n\t\t//if heartbeat is lost, set the flag\n\t\tif (ros::Time::now() - heartbeat_time_ > ros::Duration(HEARTBEAT_TIMEOUT)) {\n\t\t\tROS_ERROR(\"Heartbeat lost! Disconnecting...\");\n\t\t\tdisconnect_flag_ = true;\n\t\t\t//if the vehicle is a swarm, trigger the swarm control\n\t\t\tif (swarm_flag_) {\n\t\t\t\tROS_ERROR(\"Swarm lost! Triggering Swarm Control...\");\n\t\t\t\ttriggerSwarmControl();\n\t\t\t}\n\t\t\t//if the vehicle is a UAV, trigger the UAV control\n\t\t\telse if (uav_flag_) {\n\t\t\t\tROS_ERROR(\"UAV lost! Triggering UAV Control...\");\n\t\t\t\ttriggerUAV();\n\t\t\t}\n\t\t\t//if the vehicle is a UGV, trigger the UGV control\n\t\t\telse if (ugv_flag_) {\n\t\t\t\tROS_ERROR(\"UGV lost! Triggering UGV Control...\");\n\t\t\t\ttriggerUGV();\n\t\t\t}\n\t\t}\n\t}\n\t//if heartbeat is received, reset the counter and time\n\telse {\n\t\theartbeat_count_ = 0;\n\t\theartbeat_time_ = ros::Time::now();\n\t}\n}", "CodeBleu_score": 30.10151938888701}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif(heartbeat_count == 0) {\n\t\theartbeat_count = 1;\n\t} else {\n\t\theartbeat_count++;\n\t}\n\n\tif(heartbeat_count > 5) {\n\t\tROS_ERROR(\"Lost connection to vehicle. Resetting vehicle state.\");\n\t\tif(vehicle_type == \"UAV\") {\n\t\t\ttriggerUAV();\n\t\t} else if(vehicle_type == \"UGV\") {\n\t\t\ttriggerUGV();\n\t\t} else if(vehicle_type == \"Swarm\") {\n\t\t\ttriggerSwarmControl();\n\t\t}\n\t\theartbeat_count = 0;\n\t\tdisconnect_flag = true;\n\t}\n}", "CodeBleu_score": 30.422968652216863}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t//    printf(\"multitrajSubTcpCb start\n\");\n\n//    // 1. Get drone ID from header\n//    int drone_id = msg->header.frame_id;\n//    printf(\"drone_id: %d\n\", drone_id);\n\n//    // 2. Extract trajectory data from message\n//    for (int i = 0; i < msg->traj.size(); i++) {\n//        // 2.1. Initialize Bspline struct\n//        Bspline bspline;\n\n//        // 2.2. Set Bspline struct attributes\n//        bspline.id = drone_id;\n//        bspline.duration = msg->traj[i].duration;\n//        bspline.period = msg->traj[i].period;\n//        bspline.order = msg->traj[i].order;\n\n//        // 2.3. Populate Bspline struct knots, position points, and yaw points\n//        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n//            bspline.knots.push_back(msg->traj[i].knots[j]);\n//        }\n//        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n//            bspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n//        }\n//        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n//            bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n//        }\n\n//        // 2.4. Send encoded Bspline data via TCP\n//        this->communication->encodeMsg(bspline);\n//        this->communication->sendMsgByTcp(this->communication->msg_buff);\n//    }\n\n//    printf(\"multitrajSubTcpCb end\n\");\n}", "CodeBleu_score": 1.2915073360288183}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t//    std::cout << \"Entered multitrajSubTcpCb\" << std::endl;\n    int drone_id = msg->id;\n    //    std::cout << \"drone_id: \" << drone_id << std::endl;\n\n    // Initialize the Bspline struct\n    Bspline bspline;\n\n    // Set the Bspline attributes\n    bspline.id = drone_id;\n    bspline.traj_type = msg->traj_type;\n    bspline.traj_order = msg->traj_order;\n    bspline.traj_dim = msg->traj_dim;\n    bspline.traj_size = msg->traj.size();\n    bspline.knots.clear();\n    bspline.pos_pts.clear();\n    bspline.yaw_pts.clear();\n\n    // Populate the Bspline knots, position points, and yaw points\n    for (int i = 0; i < bspline.traj_size; i++) {\n        bspline.knots.push_back(msg->traj[i].knots.size());\n        bspline.pos_pts.push_back(msg->traj[i].pos_pts.size());\n        bspline.yaw_pts.push_back(msg->traj[i].yaw_pts.size());\n    }\n\n    // Send the Bspline data via TCP\n    this->communication->sendMsgByTcp(this->multitraj_pub, bspline);\n}", "CodeBleu_score": 39.4576569594711}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input PointCloud2 message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Compress the pcl::PointCloud\n\tstd::vector<uint8_t> compressed_data;\n\toctree_compression.encodePointCloud(cloud, compressed_data);\n\n\t// Convert the compressed data to a PointCloud2 message\n\tsensor_msgs::PointCloud2 output;\n\toutput.header.stamp = msg.header.stamp;\n\toutput.header.frame_id = msg.header.frame_id;\n\toutput.height = 1;\n\toutput.width = compressed_data.size();\n\toutput.fields.resize(1);\n\toutput.fields[0].name = \"data\";\n\toutput.fields[0].offset = 0;\n\toutput.fields[0].datatype = sensor_msgs::PointField::UINT8;\n\toutput.fields[0].count = 1;\n\toutput.is_bigendian = false;\n\toutput.point_step = 1;\n\toutput.row_step = output.point_step * output.width;\n\toutput.is_dense = false;\n\toutput.data.resize(output.row_step);\n\tmemcpy (&output.data[0], &compressed_data[0], compressed_data.size());\n\n\treturn output;\n}", "CodeBleu_score": 33.70891377515237}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Compress the point cloud using an octree\n\tstd::vector<uint8_t> compressed_data;\n\toctree_compression.encodePointCloud(*cloud, compressed_data);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 output;\n\toutput.header = msg.header;\n\toutput.height = 1;\n\toutput.width = compressed_data.size();\n\toutput.fields.resize(1);\n\toutput.fields[0].name = \"data\";\n\toutput.fields[0].offset = 0;\n\toutput.fields[0].datatype = sensor_msgs::PointField::UINT8;\n\toutput.fields[0].count = 1;\n\toutput.is_bigendian = false;\n\toutput.point_step = 1;\n\toutput.row_step = output.point_step * output.width;\n\toutput.is_dense = false;\n\toutput.data = compressed_data;\n\n\treturn output;\n}", "CodeBleu_score": 32.57579540598874}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a pcl::PointCloud from the PointCloud2 message.\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg (msg, *cloud);\n\n\t// Create a vector to store the compressed data.\n\tstd::vector<uint8_t> compressed_data;\n\n\t// Compress the point cloud.\n\toctree_compression.setInputCloud (cloud);\n\toctree_compression.encodePointCloud (compressed_data);\n\n\t// Create a new PointCloud2 message.\n\tsensor_msgs::PointCloud2 output;\n\n\t// Copy the header from the input message to the output message.\n\toutput.header = msg.header;\n\n\t// Set the frame_id to the frame_id of the input message.\n\toutput.header.frame_id = msg.header.frame_id;\n\n\t// Set the sequence number to the sequence number of the input message.\n\toutput.header.seq = msg.header.seq;\n\n\t// Set the height to the height of the input message.\n\toutput.height = msg.height;\n\n\t// Set the width to the width of the input message.\n\toutput.width = msg.width;\n\n\t// Set the point step to the point step of the input message.\n\toutput.point_step = msg.point_step;\n\n\t// Set the row step to the row step of the input message.\n\toutput.row_step = msg.row_step;\n\n\t// Set the is_dense field to the is_dense field of the input message.\n\toutput.is_dense = msg.is_dense;\n\n\t// Set the is_bigendian field to the is_bigendian field of the input message.\n\toutput.is_bigendian = msg.is_bigendian;\n\n\t// Set the data field to the compressed data.\n\toutput.data = compressed_data;\n\n\t// Return the output message.\n\treturn output;\n}", "CodeBleu_score": 32.47315067735663}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.7039515344895}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_state_all.resize(m_multi_ugv_state.ugv_state_all.size());\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.ugv_id = m_multi_ugv_state.ugv_state_all[i].ugv_id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\t\tugv_state.position = m_multi_ugv_state.ugv_state_all[i].position;\n\t\tugv_state.velocity = m_multi_ugv_state.ugv_state_all[i].velocity;\n\t\tugv_state.attitude = m_multi_ugv_state.ugv_state_all[i].attitude;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\tall_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 39.54880171145847}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Clear the cost and gradient\n\tcost = 0.0;\n\tgradient.setZero();\n\n\t// Get the number of control points\n\tint num_cps = cps_.points.cols();\n\n\t// Iterate through the control points\n\tfor (int i = 0; i < num_cps; i++) {\n\t\t// Get the control point position\n\t\tEigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(q, i);\n\n\t\t// Evaluate the distance between the control point and the object\n\t\tdouble dist = (cps_.points.col(i) - obj_prid).norm();\n\n\t\t// If the distance is less than the clearance, update the cost and gradient\n\t\tif (dist < clearance_) {\n\t\t\tcost += pow(dist, 2);\n\t\t\tgradient.col(i) = 2 * (cps_.points.col(i) - obj_prid).normalized();\n\t\t}\n\t}\n}", "CodeBleu_score": 35.009397085302304}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t//ROS_INFO(\"calcMovingObjCost\");\n\t//if (moving_objs_ == NULL)\n\t//\treturn;\n\t//moving_objs_->updateObjPositions(q);\n\t//cost = 0.0;\n\t//gradient.resize(cps_.points.rows(), cps_.points.cols());\n\t//gradient.setZero();\n\t//for (int i = 0; i < cps_.points.cols(); ++i) {\n\t//\tEigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(cps_.points.col(i), q);\n\t//\tdouble dist = (cps_.points.col(i) - obj_prid).norm();\n\t//\tif (dist < moving_objs_->getClearance()) {\n\t//\t\tcost += dist;\n\t//\t\tgradient.col(i) = (cps_.points.col(i) - obj_prid).normalized();\n\t//\t}\n\t//}\n}", "CodeBleu_score": 3.845811572351676}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Check if there are moving objects\n\tif (moving_objs_->getObjNums() == 0) {\n\t\treturn;\n\t}\n\n\t// Get the number of control points\n\tint num_cps = cps_.points.cols();\n\n\t// Initialize the cost and gradient\n\tcost = 0.0;\n\tgradient.setZero(3, num_cps);\n\n\t// Iterate through the control points\n\tfor (int i = 0; i < num_cps; i++) {\n\t\t// Predict the position of the moving objects\n\t\tEigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(q, i);\n\n\t\t// Evaluate the distance between the control point and the predicted position\n\t\tdouble dist = (cps_.points.col(i) - obj_prid).norm();\n\n\t\t// If the distance is less than the clearance, update the cost and gradient\n\t\tif (dist < clearance_) {\n\t\t\tcost += pow(dist, 2);\n\t\t\tgradient.col(i) = (cps_.points.col(i) - obj_prid).normalized() * 2 * dist;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.11785016087558}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost and gradient to zero.\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.cols(), 3);\n\n\t// Iterate through the control points of the trajectory.\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// Calculate the error vector and velocity vector.\n\t\tEigen::Vector3d ref_pt = ref_pts_[i];\n\t\tEigen::Vector3d x = q.col(i);\n\t\tEigen::Vector3d xcrossv = (ref_pt - x).cross(ref_pt_vels_[i]);\n\t\tEigen::Vector3d v = (ref_pt - ref_pts_[i - 2]).normalized();\n\n\t\t// Update the cost and gradient.\n\t\tcost += a2_ * xcrossv.squaredNorm() + b2_ * v.squaredNorm();\n\t\tgradient.col(i) = 2 * a2_ * xcrossv + 2 * b2_ * v;\n\t}\n}", "CodeBleu_score": 31.149477073158792}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tint num_points = q.cols();\n\tdouble a2 = 1.0 / (2.0 * a_ * a_);\n\tdouble b2 = 1.0 / (2.0 * b_ * b_);\n\tcost = 0.0;\n\tgradient.setZero();\n\tfor (int i = 0; i < num_points; i++) {\n\t\t// Compute the position error and velocity vector\n\t\tEigen::Vector3d xcrossv = (ref_pts_[i] - ref_pts_[i - 2]).cross(q.col(i) - q.col(i - 2));\n\t\tEigen::Vector3d xdotv = (ref_pts_[i] - ref_pts_[i - 2]).dot(q.col(i) - q.col(i - 2));\n\t\tEigen::Vector3d xcrossv_norm = xcrossv.normalized();\n\t\tEigen::Vector3d xdotv_norm = xdotv.normalized();\n\t\t// Update the cost\n\t\tcost += a2 * xdotv.squaredNorm() + b2 * xcrossv.squaredNorm();\n\t\t// Update the gradient\n\t\tgradient.col(i) = 2.0 * a2 * xdotv_norm - 2.0 * b2 * xcrossv_norm;\n\t}\n}", "CodeBleu_score": 40.89306344143001}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost and gradient\n\tcost = 0.0;\n\tgradient.setZero();\n\n\t// Iterate through control points\n\tfor (int i = 0; i < q.cols(); ++i) {\n\t\t// Compute the error between the current point and reference points\n\t\tEigen::Vector3d x = q.col(i);\n\t\tEigen::Vector3d xdiff = x - ref_pts_[i];\n\t\tEigen::Vector3d xdiff_norm = xdiff.normalized();\n\t\tEigen::Vector3d xcrossv = x.cross(ref_vels_[i]);\n\n\t\t// Add to cost function\n\t\tcost += a2_ * xdiff.squaredNorm() + b2_ * xcrossv.squaredNorm();\n\n\t\t// Compute the gradient for the current point\n\t\tEigen::Vector3d xcrossv_norm = xcrossv.normalized();\n\t\tEigen::Vector3d xdot = x.dot(ref_vels_[i]) * ref_vels_[i].normalized();\n\t\tEigen::Vector3d xdot_norm = xdot.normalized();\n\t\tEigen::Vector3d xcrossv_norm_cross_xdot_norm = xcrossv_norm.cross(xdot_norm);\n\n\t\t// Add to gradient\n\t\tgradient.col(i) += 2.0 * a2_ * xdiff_norm + 2.0 * b2_ * xcrossv_norm_cross_xdot_norm;\n\t}\n}", "CodeBleu_score": 34.1039626333529}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tEigen::MatrixXd ctrl_pts = getControlPoints();\nEigen::MatrixXd jerk_ctrl_pts = getDerivative().getDerivative().getDerivativeControlPoints();\n\nEigen::MatrixXd times = getKnot();\n\ndouble jerk = 0.0;\n\nfor (int i = 0; i < ctrl_pts.cols(); i++) {\nfor (int j = 0; j < ctrl_pts.rows(); j++) {\njerk += (ctrl_pts(j, i) * ctrl_pts(j, i)) * (times(i + 1) - times(i));\n}\n}\n\nreturn jerk;\n}", "CodeBleu_score": 59.74736120445752}, {"code": "double UniformBspline::getJerk(){\n\tEigen::MatrixXd ctrl_pts = getControlPoints();\nEigen::MatrixXd jerk_ctrl_pts = getDerivative().getDerivative().getDerivativeControlPoints();\n\nEigen::MatrixXd knots = getKnot();\ndouble jerk = 0.0;\n\nfor (int i = 0; i < ctrl_pts.rows(); i++) {\nfor (int j = 0; j < ctrl_pts.cols(); j++) {\njerk += pow(jerk_ctrl_pts(i, j), 2) * pow(knots(i + 1) - knots(i), 3);\n}\n}\n\nreturn jerk;\n}", "CodeBleu_score": 60.480883270053}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctp = getJerkControlPoints();\n\tUniformBspline jerk_traj(ctp, p_ - 1, interval_);\n\n\t/* cut the first and last knot */\n\tEigen::VectorXd knot(u_.rows() - 2);\n\tknot = u_.segment(1, u_.rows() - 2);\n\tjerk_traj.setKnot(knot);\n\n\tdouble jerk = 0;\n\tfor (int i = 0; i < ctp.rows(); i++) {\n\t\tfor (int j = 0; j < ctp.cols(); j++) {\n\t\t\tjerk += (ctp(i, j) * (u_(i + 1) - u_(i)));\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 54.97908045672204}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1;\n\treturn pos;\n}", "CodeBleu_score": 60.79764647195039}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos_in_camera;\n\tpos_in_camera << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n\treturn pos_in_camera;\n}", "CodeBleu_score": 52.2596848142844}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d position;\n\tposition << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n\treturn position;\n}", "CodeBleu_score": 48.90240214893515}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\nint droneID = std::stoi(odom.child_frame_id.substr(10));\nrcvDroneOdomCallbackBase(odom, droneID);\n}\ncatch (std::invalid_argument& e) {\nROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: Could not extract drone ID from child_frame_id field of Odometry message.\");\n}\ncatch (std::out_of_range& e) {\nROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: Could not extract drone ID from child_frame_id field of Odometry message.\");\n}\n}", "CodeBleu_score": 47.65530979480701}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string drone_id = odom.child_frame_id.substr(0, odom.child_frame_id.find('_'));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (const std::exception& e) {\n\t\tstd::cout << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 59.47369253383488}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(6));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t}\n\tcatch (const std::exception& e) {\n\t\tROS_ERROR_STREAM(e.what());\n\t}\n}", "CodeBleu_score": 49.70237739881417}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = getTruePose(drone_id, true_pixel);\n\n\t// Check if the drone is present in the camera frame\n\tif (true_pose.norm() > 0.0) {\n\t\t// Compute the pose error\n\t\tEigen::Vector3d pose_error = true_pose - drones_[drone_id].pose;\n\n\t\t// Update the debug result\n\t\tdrones_[drone_id].pose_error = pose_error;\n\t\tdrones_[drone_id].detected = true;\n\n\t\t// Publish the pose error\n\t\tpose_error_pub_[drone_id].publish(pose_error);\n\t} else {\n\t\t// Update the debug result\n\t\tdrones_[drone_id].detected = false;\n\t}\n}", "CodeBleu_score": 33.13623064741474}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the current camera pose.\n\ttf::Stamped<tf::Pose> camera_pose;\n\ttf_listener_.lookupTransform(\"/world\", \"/camera\", ros::Time(0), camera_pose);\n\n\t// Get the current drone pose.\n\ttf::Stamped<tf::Pose> drone_pose;\n\ttf_listener_.lookupTransform(\"/world\", \"/drone_\" + std::to_string(drone_id), ros::Time(0), drone_pose);\n\n\t// Compute the true pose of the drone in the camera frame.\n\ttf::Stamped<tf::Pose> true_pose;\n\ttrue_pose.setIdentity();\n\ttrue_pose.frame_id_ = \"/camera\";\n\ttrue_pose.child_frame_id_ = \"/drone_\" + std::to_string(drone_id);\n\ttf::Vector3 true_position(true_pixel[0], true_pixel[1], 0);\n\ttf::Quaternion true_orientation;\n\ttrue_orientation.setRPY(0, 0, 0);\n\ttrue_pose.setOrigin(true_position);\n\ttrue_pose.setRotation(true_orientation);\n\ttf::Stamped<tf::Pose> true_drone_pose = tf_listener_.transformPose(\"/camera\", true_pose);\n\n\t// Compute the pose error.\n\ttf::Vector3 true_drone_position = true_drone_pose.getOrigin();\n\ttf::Vector3 drone_position = drone_pose.getOrigin();\n\ttf::Vector3 error = true_drone_position - drone_position;\n\tdouble pose_error = sqrt(error[0] * error[0] + error[1] * error[1] + error[2] * error[2]);\n\n\t// Check if the drone is present.\n\tif (pose_error < pose_error_threshold_) {\n\t\t// Publish the pose error.\n\t\tpose_error_pub_[drone_id].publish(pose_error);\n\n\t\t// Update the debug result.\n\t\tdebug_result_[drone_id] = true;\n\t} else {\n\t\t// Update the debug result.\n\t\tdebug_result_[drone_id] = false;\n\t}\n}", "CodeBleu_score": 37.159556567869515}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != startNode) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 70.39951580741194}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 70.23339106455427}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\n\twhile (current != start) {\n\t\tcurrent = cameFrom[current->getIndex()];\n\t\tpath.push_back(current);\n\t}\n\n\treturn path;\n}", "CodeBleu_score": 70.73632631585319}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tVector3d start_pt_copy = start_pt;\n\tVector3d end_pt_copy = end_pt;\n\tVector3i start_idx_copy = start_idx;\n\tVector3i end_idx_copy = end_idx;\n\tif (ConvertPointToIndex(start_pt, start_idx)) {\n\t\tif (ConvertPointToIndex(end_pt, end_idx)) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn AdjustPointToNotBeInObstacle(start_pt_copy, end_pt_copy, start_idx_copy, end_idx_copy);\n\t\t}\n\t}\n\telse {\n\t\tif (ConvertPointToIndex(end_pt, end_idx)) {\n\t\t\treturn AdjustPointToNotBeInObstacle(end_pt_copy, start_pt_copy, end_idx_copy, start_idx_copy);\n\t\t}\n\t\telse {\n\t\t\tif (AdjustPointToNotBeInObstacle(start_pt_copy, end_pt_copy, start_idx_copy, end_idx_copy)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn AdjustPointToNotBeInObstacle(end_pt_copy, start_pt_copy, end_idx_copy, start_idx_copy);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.17313404531047}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start point to index\n\tif (!Coord2Index(start_pt, start_idx)) {\n\t\tROS_ERROR(\"Start point (%f, %f, %f) is out of bounds.\", start_pt.x(), start_pt.y(), start_pt.z());\n\t\treturn false;\n\t}\n\n\t// Convert end point to index\n\tif (!Coord2Index(end_pt, end_idx)) {\n\t\tROS_ERROR(\"End point (%f, %f, %f) is out of bounds.\", end_pt.x(), end_pt.y(), end_pt.z());\n\t\treturn false;\n\t}\n\n\t// Adjust start point\n\tif (!AdjustStartPoint(start_pt, start_idx, end_idx)) {\n\t\tROS_ERROR(\"Start point (%f, %f, %f) is inside an obstacle.\", start_pt.x(), start_pt.y(), start_pt.z());\n\t\treturn false;\n\t}\n\n\t// Adjust end point\n\tif (!AdjustEndPoint(end_pt, start_idx, end_idx)) {\n\t\tROS_ERROR(\"End point (%f, %f, %f) is inside an obstacle.\", end_pt.x(), end_pt.y(), end_pt.z());\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 40.77660269094605}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\n\tif (!checkOccupancy(start_idx)) {\n\t\tVector3i diff = (end_idx - start_idx).cwiseAbs();\n\t\tVector3i diff_idx = diff.cwiseQuotient(diff.cwiseAbs().cwiseMax(Vector3i(1)));\n\t\tVector3d diff_pt = Index2Coord(diff_idx);\n\n\t\twhile (checkOccupancy(start_idx)) {\n\t\t\tstart_idx += diff_idx;\n\t\t\tstart_pt += diff_pt;\n\t\t}\n\t}\n\n\tif (!checkOccupancy(end_idx)) {\n\t\tVector3i diff = (end_idx - start_idx).cwiseAbs();\n\t\tVector3i diff_idx = diff.cwiseQuotient(diff.cwiseAbs().cwiseMax(Vector3i(1)));\n\t\tVector3d diff_pt = Index2Coord(diff_idx);\n\n\t\twhile (checkOccupancy(end_idx)) {\n\t\t\tend_idx -= diff_idx;\n\t\t\tend_pt -= diff_pt;\n\t\t}\n\t}\n\n\treturn checkOccupancy(start_idx) && checkOccupancy(end_idx);\n}", "CodeBleu_score": 37.82248722886271}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = getCoordinatesFromPosition(min_pos);\n\tEigen::Vector3i max_id = getCoordinatesFromPosition(max_pos);\n\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0.0;\n\t\t\t\tdistance_buffer_inflate_(i, j, k) = 0.0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.17414032033259}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = gridWorld2GridIndex(min_pos);\n\tEigen::Vector3i max_id = gridWorld2GridIndex(max_pos);\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0.0;\n\t\t\t\tdistance_buffer_inflate_(x, y, z) = 0.0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.507743590472366}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tgetCoordinates(min_pos, min_id);\n\tgetCoordinates(max_pos, max_id);\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.80387077787487}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_trans = Eigen::Vector3d::Zero();\n\tEigen::Vector3d max_trans = Eigen::Vector3d::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tmin_trans[i] = -diff[i] < 0 ? -diff[i] : 0;\n\t\tmax_trans[i] = diff[i] > map_size_[i] - 1 ? diff[i] - (map_size_[i] - 1) : 0;\n\t}\n\tdouble max_trans_mag = max_trans.norm();\n\tdouble min_trans_mag = min_trans.norm();\n\tdouble trans_mag = max_trans_mag > min_trans_mag ? max_trans_mag : min_trans_mag;\n\tif (trans_mag == 0) {\n\t\treturn pt;\n\t}\n\tEigen::Vector3d trans = trans_mag * diff.normalized();\n\tEigen::Vector3d new_pt = pt + trans;\n\treturn new_pt;\n}", "CodeBleu_score": 46.70686792203291}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_trans = diff;\n\tEigen::Vector3d max_trans = diff;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff[i] < 0) {\n\t\t\tmin_trans[i] = diff[i];\n\t\t\tmax_trans[i] = 0;\n\t\t} else {\n\t\t\tmin_trans[i] = 0;\n\t\t\tmax_trans[i] = diff[i];\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_trans[i] > max_trans[i]) {\n\t\t\tdouble temp = min_trans[i];\n\t\t\tmin_trans[i] = max_trans[i];\n\t\t\tmax_trans[i] = temp;\n\t\t}\n\t}\n\tdouble min_trans_coef = 1;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_trans[i] > 0) {\n\t\t\tmin_trans_coef = min_trans[i] / (min_trans[i] + max_trans[i]);\n\t\t}\n\t}\n\tEigen::Vector3d new_pt = pt - min_trans_coef * diff;\n\treturn new_pt;\n}", "CodeBleu_score": 42.68032505689044}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d max_coeff = diff.cwiseAbs().cwiseMax(Eigen::Vector3d(0.0, 0.0, 0.0));\n\tEigen::Vector3d min_coeff = diff.cwiseAbs().cwiseMin(Eigen::Vector3d(0.0, 0.0, 0.0));\n\tdouble max_scale = max_coeff.norm();\n\tdouble min_scale = min_coeff.norm();\n\tdouble scale = 0.0;\n\tif (max_scale > min_scale) {\n\t\tscale = min_scale;\n\t} else {\n\t\tscale = max_scale;\n\t}\n\tif (scale == 0.0) {\n\t\treturn pt;\n\t}\n\tEigen::Vector3d scaled_diff = diff / scale;\n\tEigen::Vector3d new_pt = camera_pt + scaled_diff;\n\treturn new_pt;\n}", "CodeBleu_score": 40.0248030690438}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\tif (!initialized_) {\nROS_ERROR(\"Grid map not initialized!\");\nreturn;\n}\n\n// Update last occupancy update time.\nmd_.last_occ_update_time_ = ros::Time::now();\n\n// Check if occupancy update is needed.\nif (!update_occupancy_ || !isDataOk()) {\nreturn;\n}\n\n// Project depth image into points.\nif (!projectDepthImage()) {\nreturn;\n}\n\n// Process points with raycasting.\nif (!raycastProcess()) {\nreturn;\n}\n\n// Clear and inflate local map if needed.\nif (update_local_map_) {\nclearAndInflateLocalMap();\nupdate_local_map_ = false;\n}\n\n}", "CodeBleu_score": 26.873293716762113}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last occupancy update time.\nmd_.last_occ_update_time_ = ros::Time::now();\n// Check if an update is needed.\nif (md_.last_occ_update_time_ - md_.last_occ_update_time_prev_ < update_duration_) {\nreturn;\n}\nmd_.last_occ_update_time_prev_ = md_.last_occ_update_time_;\n// Check if the local map has been updated.\nif (md_.local_map_updated_) {\n// Clear the local map.\nclearAndInflateLocalMap();\nmd_.local_map_updated_ = false;\n}\n// Get the latest depth image.\nsensor_msgs::Image::ConstPtr depth_msg;\ntry {\ndepth_msg = ros::Time::now() - md_.last_depth_msg_time_ < depth_timeout_ ? md_.latest_depth_msg_ : ros::Subscriber::getLatestMessage(depth_sub_);\n} catch (ros::Exception & /*e*/) {\nROS_ERROR(\"GridMap::updateOccupancyCallback: No depth image received!\");\nmd_.last_depth_msg_time_ = ros::Time();\nmd_.latest_depth_msg_ = sensor_msgs::Image();\nreturn;\n}\n// Project the depth image into points.\npcl::PointCloud<pcl::PointXYZ>::Ptr points(new pcl::PointCloud<pcl::PointXYZ>);\nprojectDepthImage(depth_msg, points);\n// Process the points.\nraycastProcess(points);\n}", "CodeBleu_score": 55.8633543860369}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure = 0.f;\n\tunsigned n = image_fns.size();\n\n\tfor (unsigned i = 0; i<n; ++i)\n\t{\n\t\t// Load the ground truth and detected ellipses for this image\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\t// Load the image\n\t\tMat3b img = imread(image_fns[i]);\n\n\t\t// Evaluate the detection performance for this image\n\t\tfloat fmeasure_i = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\n\t\tfmeasure += fmeasure_i;\n\t}\n\n\treturn fmeasure / float(n);\n}", "CodeBleu_score": 53.54527257903716}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat sum_fmeasure = 0.f;\n\tunsigned n_images = unsigned(image_fns.size());\n\n\tfor (unsigned i = 0; i < n_images; ++i) {\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tMat3b img = imread(image_fns[i], CV_LOAD_IMAGE_COLOR);\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\n\t\tsum_fmeasure += fmeasure;\n\t}\n\n\treturn sum_fmeasure / float(n_images);\n}", "CodeBleu_score": 53.73881757322996}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure_sum = 0.f;\n\tunsigned n_images = image_fns.size();\n\n\tfor (unsigned i = 0; i < n_images; ++i) {\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tMat3b img = imread(image_fns[i]);\n\n\t\tfmeasure_sum += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\n\treturn fmeasure_sum / float(n_images);\n}", "CodeBleu_score": 56.58805134945983}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_x, angle_y;\n\tif (foci) {\n\t\tangle_x = atan2(foci[1] - y, foci[0] - x);\n\t\tangle_y = atan2(foci[1] - y, foci[0] - x);\n\t}\n\telse {\n\t\tangle_x = atan2(y, x);\n\t\tangle_y = atan2(y, x);\n\t}\n\tfloat angle = angle_diff_signed(angle_x, angle_y);\n\tif (angle < -M_PI) angle += M_2__PI;\n\tif (angle >  M_PI) angle -= M_2__PI;\n\treturn angle;\n}", "CodeBleu_score": 44.92620420937653}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t", "CodeBleu_score": 2.6118173022443996}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == NULL) {\n\t\tfprintf(stderr, \"Ellipse foci must be non-null\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tfloat angle1 = atan2(foci[1] - y, foci[0] - x);\n\tfloat angle2 = atan2(y - foci[1], x - foci[0]);\n\tfloat angle = angle_diff_signed(angle1, angle2);\n\treturn angle;\n}", "CodeBleu_score": 41.323385558294625}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x, max_x = vp1[start].x, min_y = vp1[start].y, max_y = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\tdouble integral_above = 0, integral_below = 0;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\tintegral_below += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n\t}\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 33.93688497376217}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tfloat min_x = FLT_MAX;\n\tfloat max_x = -FLT_MAX;\n\tfloat min_y = FLT_MAX;\n\tfloat max_y = -FLT_MAX;\n\tfor (int i = start; i <= end; i++) {\n\t\tmin_x = min(min_x, vp1[i].x);\n\t\tmax_x = max(max_x, vp1[i].x);\n\t\tmin_y = min(min_y, vp1[i].y);\n\t\tmax_y = max(max_y, vp1[i].y);\n\t}\n\tfloat a = min_y;\n\tfloat b = max_y;\n\tfloat c = max_x;\n\tfloat d = min_x;\n\treturn (a * c - b * d) < 0;\n}", "CodeBleu_score": 33.34448361704543}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\tdouble area_above = 0.0;\n\tdouble area_below = 0.0;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tarea_above += vp1[i].x * (vp1[i].y - min_y);\n\t\tarea_below += vp1[i].x * (max_y - vp1[i].y);\n\t}\n\treturn (area_above > area_below);\n}", "CodeBleu_score": 31.5450873162603}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tprometheus_msgs::DetectionInfo::ConstPtr target;\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\ttarget = msg->detection_infos[i];\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t}\n\tif (num_lost > VISION_THRES) {\n\t\tis_detected = false;\n\t}\n\tif (num_regain > VISION_THRES) {\n\t\tis_detected = true;\n\t}\n\tif (target != NULL) {\n\t\tsight_angle = target->angle;\n\t}\n}", "CodeBleu_score": 56.577281440133056}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// Iterate through each detection info\n\tfor (int i = 0; i < msg->objects.size(); i++) {\n\t\t// If an object named \"T\" is detected, increment num_regain and reset num_lost\n\t\tif (msg->objects[i].id == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t}\n\t\t// Otherwise, reset num_regain and increment num_lost\n\t\telse {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\t// If num_lost exceeds VISION_THRES, set is_detected to false\n\t\tif (num_lost >= VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\t// If num_regain exceeds VISION_THRES, set is_detected to true\n\t\tif (num_regain >= VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\t// Swap the sight_angle values of ellipse_det\n\t\tfloat temp = ellipse_det.sight_angle;\n\t\tellipse_det.sight_angle = ellipse_det.sight_angle_2;\n\t\tellipse_det.sight_angle_2 = temp;\n\t}\n}", "CodeBleu_score": 56.85195354420867}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t//ROS_INFO(\"Ellipse Det Callback\");\n\tprometheus_msgs::DetectionInfo::ConstPtr det;\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tdet = msg->detection_infos[i];\n\t\tif (det->name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t\tif (num_lost >= VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain >= VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (is_detected) {\n\t\t\tsight_angle = det->angle;\n\t\t} else {\n\t\t\tsight_angle = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 56.87416701231213}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// TODO: Fill in this function to check if the current position is safe.\n\t// 1. Check if the current position is within the Occupy_map_ptr's bounding box. If not, return false.\n\t// 2. Get the index of the current position in the Occupy_map_ptr.\n\t// 3. Check if the current position is safe based on the Occupy_map_ptr.\n\t// 4. Return the result of the check.\n\tEigen::Vector3i cur_pos_index;\n\tcur_pos_index[0] = (int) (cur_pos[0] / resolution);\n\tcur_pos_index[1] = (int) (cur_pos[1] / resolution);\n\tcur_pos_index[2] = (int) (cur_pos[2] / resolution);\n\tif (cur_pos_index[0] < 0 || cur_pos_index[0] >= Occupy_map_ptr->get_map_size() ||\n\t\tcur_pos_index[1] < 0 || cur_pos_index[1] >= Occupy_map_ptr->get_map_size() ||\n\t\tcur_pos_index[2] < 0 || cur_pos_index[2] >= Occupy_map_ptr->get_map_size()) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn Occupy_map_ptr->is_occupied(cur_pos_index, safe_distance);\n\t}\n}", "CodeBleu_score": 43.270795426404376}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// TODO: Implement the function\n\t// Check if the position is within the bounds of the Occupy_map_ptr\n\tif (cur_pos.x() < 0 || cur_pos.x() > Occupy_map_ptr->get_map_size() || cur_pos.y() < 0 || cur_pos.y() > Occupy_map_ptr->get_map_size()) {\n\t\treturn false;\n\t}\n\t// Check if the position is within the safety distance of the Occupy_map_ptr\n\tif (Occupy_map_ptr->get_costmap()[(int)cur_pos.x()][(int)cur_pos.y()] < safe_distance) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 33.891267826688235}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tif (cur_pos.x() < 0 || cur_pos.x() > map_width || cur_pos.y() < 0 || cur_pos.y() > map_height || cur_pos.z() < 0 || cur_pos.z() > map_height) {\n\t\treturn false;\n\t}\n\telse if (cur_pos.z() < safe_distance) {\n\t\treturn false;\n\t}\n\telse if (cur_pos.z() > map_height - safe_distance) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn Occupy_map_ptr->check_safety(cur_pos);\n\t}\n}", "CodeBleu_score": 42.25390550539635}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node != nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.95542764363434}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Check if the end node is the same as the start node.\n\tif (end_node == start_node_) {\n\t\tpath_nodes_.push_back(end_node);\n\t\treturn;\n\t}\n\n\t// Recursively trace the path back to the start node.\n\tretrievePath(end_node->parent_);\n\n\t// Push the end node onto the path.\n\tpath_nodes_.push_back(end_node);\n}", "CodeBleu_score": 36.75869402340104}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node != nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.95542764363434}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].v = odom->twist.twist.linear.x;\n\tstate_nei[id].w = odom->twist.twist.angular.z;\n\n\tif (sim_mode) {\n\t\tif ((start_pos-state_nei[id]).norm > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t} else {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t} else {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 55.473428423183535}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].roll = odom->pose.pose.orientation.x;\n\tstate_nei[id].pitch = odom->pose.pose.orientation.y;\n\tstate_nei[id].yaw = odom->pose.pose.orientation.z;\n\tstate_nei[id].vx = odom->twist.twist.linear.x;\n\tstate_nei[id].vy = odom->twist.twist.linear.y;\n\tstate_nei[id].vz = odom->twist.twist.linear.z;\n\tstate_nei[id].vr = odom->twist.twist.angular.x;\n\tstate_nei[id].vp = odom->twist.twist.angular.y;\n\tstate_nei[id].vyaw = odom->twist.twist.angular.z;\n\tif (sim_mode) {\n\t\tif ((start_pos-state_nei[id]).norm > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t} else {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t} else {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 55.639459534259395}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (sim_mode) {\n\t\tif ((start_pos-state_nei[id]).norm > 5.0) {\n\t\t\tget_nei_state = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state = true;\n\t\t}\n\t}\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n}", "CodeBleu_score": 34.82238203483677}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tupdate_counter++;\n\t\tif (update_counter == 5) {\n\t\t\tAstar_ptr->Occupy_map_ptr->update_map(msg);\n\t\t\tupdate_counter = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 48.64429608168134}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter % 5 == 0) {\n\t\tupdate_counter = 0;\n\t\tAstar_ptr->Occupy_map_ptr->update_map(msg);\n\t}\n}", "CodeBleu_score": 55.67131151505289}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odometry_ready == false) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter >= 5) {\n\t\tupdate_counter = 0;\n\t\tAstar_ptr->Occupy_map_ptr->update_map(msg);\n\t}\n}", "CodeBleu_score": 51.286792409765404}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\nget_gpcl = true;\npcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud (new pcl::PointCloud<pcl::PointXYZ>);\npcl::fromROSMsg(*global_point, *global_cloud);\npcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud_inflated (new pcl::PointCloud<pcl::PointXYZ>);\ninflate_point_cloud(global_cloud, global_cloud_inflated);\nglobal_map = *global_cloud_inflated;\n}\n}", "CodeBleu_score": 50.37026144436334}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tget_gpcl = true;\n\t\tinflate_point_cloud();\n\t}\n}", "CodeBleu_score": 37.75518989648117}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tgpcl_inflated = gpcl;\n\t\tinflate_point_cloud();\n\t}\n}", "CodeBleu_score": 49.47401870338036}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\tif (local_point->header.frame_id != \"base_footprint\") {\n\t\tROS_ERROR(\"Laser scan not in base_footprint frame\");\n\t\treturn;\n\t}\n\tif (local_point->header.stamp.toSec() - last_laser_update_time_ > 0.1) {\n\t\tROS_WARN(\"Laser scan too old. Dropping it...\");\n\t\treturn;\n\t}\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_laser_cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\tprojector_.projectLaser(*local_laser_cloud, *local_point);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_laser_cloud_filtered (new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PassThrough<pcl::PointXYZ> pass;\n\tpass.setInputCloud (local_laser_cloud);\n\tpass.setFilterFieldName (\"x\");\n\tpass.setFilterLimits (0.0, 20.0);\n\tpass.filter (*local_laser_cloud_filtered);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_laser_cloud_filtered_downsampled (new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::VoxelGrid<pcl::PointXYZ> grid;\n\tgrid.setInputCloud (local_laser_cloud_filtered);\n\tgrid.setLeafSize (0.2, 0.2, 0.2);\n\tgrid.filter (*local_laser_cloud_filtered_downsampled);\n\tif (not in_simulation_) {\n\t\tlocal_map_merge_odom(local_laser_cloud_filtered_downsampled, odom);\n\t}\n\telse {\n\t\tlocal_map_merge(local_laser_cloud_filtered_downsampled);\n\t}\n\tlast_laser_update_time_ = local_point->header.stamp.toSec();\n}", "CodeBleu_score": 43.865183951308964}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan data to a PointCloud2\n\tsensor_msgs::PointCloud2 local_point_cloud;\n\tprojector_.projectLaser(local_point, local_point_cloud);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_point_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(local_point_cloud, *local_point_cloud_pcl);\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif (not sim_mode_) {\n\t\tlocal_point_cloud_pcl = local_map_merge_odom(local_point_cloud_pcl, odom);\n\t}\n\n\t// Update the occupancy map\n\tmap_update_point_cloud(local_point_cloud_pcl);\n}", "CodeBleu_score": 48.96684626720501}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n}", "CodeBleu_score": 6.889598850697095}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tpcl::toROSMsg(global_map, global_pcl);\nglobal_pcl.header.frame_id = \"world\";\nglobal_pcl_pub.publish(global_pcl);\npcl::toROSMsg(inflate_map, inflate_pcl);\ninflate_pcl.header.frame_id = \"world\";\ninflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 42.82545179833775}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tpcl::toROSMsg(*global_map, global_pcl);\nglobal_pcl.header.frame_id = \"world\";\nglobal_pcl_pub.publish(global_pcl);\npcl::toROSMsg(*inflate_map, inflate_pcl);\ninflate_pcl.header.frame_id = \"world\";\ninflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 47.789805525411175}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\tif (in_gazebo_) {\n\t\treturn;\n\t}\n\n\t// Get the current time in the robot's time base\n\tros::Time current_time = ros::Time::now();\n\tdouble dt = (current_time - last_time_).toSec();\n\tlast_time_ = current_time;\n\n\t// Get the current pose of the robot in the robot's base frame\n\tchamp::Pose robot_pose = body_controller_.pose();\n\n\t// Get the desired pose of the robot in the robot's base frame\n\tchamp::Pose desired_pose = desired_pose_command_.pose();\n\n\t// Get the desired velocity of the robot in the robot's base frame\n\tchamp::Twist desired_twist = desired_velocity_command_.twist();\n\n\t// Compute the desired foot positions for the robot\n\tchamp::Pose desired_foot_positions[4];\n\tbody_controller_.control(robot_pose, desired_pose, desired_twist, desired_foot_positions);\n\n\t// Compute the desired joint positions for the robot\n\tfloat target_joints[12];\n\tkinematics_.inverse(desired_foot_positions, target_joints);\n\n\t// Publish the desired foot positions and joint positions\n\tpublishFootContacts_(base_.foot_contacts());\n\tpublishJoints_(target_joints);\n}", "CodeBleu_score": 51.72191916508563}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contact_for_gazebo_ && !in_gazebo_) {\n// Create the message.\ngait_msgs::ContactsStamped contacts_msg;\ncontacts_msg.header.stamp = ros::Time::now();\ncontacts_msg.header.frame_id = robot_name_ + \"/base_link\";\n// Set the gait phase for each leg.\nfor (int i = 0; i < 4; ++i) {\ncontacts_msg.contacts.push_back(gait_msgs::ContactState());\ncontacts_msg.contacts[i].contact_name = leg_names_[i] + \"_foot\";\ncontacts_msg.contacts[i].contact_state = foot_contacts[i] ? gait_msgs::ContactState::CONTACT_STATE_IN_CONTACT :\ngait_msgs::ContactState::CONTACT_STATE_NOT_IN_CONTACT;\ncontacts_msg.contacts[i].gait_phase = base_.legs[i]->gait_phase;\n}\n// Publish the message.\nfoot_contacts_publisher_.publish(contacts_msg);\n}\n}", "CodeBleu_score": 56.49957779342258}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contact_for_gazebo_ && !in_gazebo_) {\nfor (int i = 0; i < 4; ++i) {\ncontacts_msg.contacts.resize(contacts_msg.contacts.size() + 1);\ncontacts_msg.contacts[i].position.z = robot_model_.base_.legs[i]->foot_pos_in_base_.z();\ncontacts_msg.contacts[i].position.x = robot_model_.base_.legs[i]->foot_pos_in_base_.x();\ncontacts_msg.contacts[i].position.y = robot_model_.base_.legs[i]->foot_pos_in_base_.y();\ncontacts_msg.contacts[i].normal.z = robot_model_.base_.legs[i]->contact_force_.z();\ncontacts_msg.contacts[i].normal.x = robot_model_.base_.legs[i]->contact_force_.x();\ncontacts_msg.contacts[i].normal.y = robot_model_.base_.legs[i]->contact_force_.y();\n}\nfoot_contacts_publisher_.publish(contacts_msg);\n}\n}", "CodeBleu_score": 56.20164942502526}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t", "CodeBleu_score": 3.1254227762308044}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\t// Create a message to send joint commands.\n\tsensor_msgs.msg.JointState msg;\n\tmsg.header.stamp = self.get_clock().now().to_msg();\n\tmsg.name = self.joint_names;\n\tmsg.position = joints.position;\n\tmsg.velocity = [];\n\tmsg.effort = [];\n\tself.joints_pub.publish(msg);\n\t// Create a message to send joint trajectory commands.\n\ttrajectory_msgs.msg.JointTrajectory msg2;\n\tmsg2.joint_names = self.joint_names;\n\tmsg2.points = [];\n\ttrajectory_msgs.msg.JointTrajectoryPoint point;\n\tpoint.positions = joints.position;\n\tpoint.velocities = [];\n\tpoint.accelerations = [];\n\tpoint.effort = [];\n\tpoint.time_from_start = self.get_clock().now().to_msg();\n\tmsg2.points.append(point);\n\tself.joint_trajectory_pub.publish(msg2);\n}", "CodeBleu_score": 46.09491907982739}, {"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a message to send the joint positions to the robot\n\tmsg = JointState()\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.name = self.joint_names\n\tmsg.position = joints.position[:12]\n\n\t# Publish the joint positions to the robot\n\tself.pub.publish(msg)\n\n\t# Construct a joint trajectory message to follow the joint positions\n\ttraj = JointTrajectory()\n\ttraj.joint_names = self.joint_names\n\ttraj.points.append(JointTrajectoryPoint())\n\ttraj.points[0].positions = joints.position[:12]\n\ttraj.points[0].time_from_start = rospy.Duration(3)\n\n\t# Publish the joint trajectory message to the robot\n\tself.traj_pub.publish(traj)\n}", "CodeBleu_score": 46.91859645409149}, {"code": "def joints_cmd_callback(self, joints){\n\t\tself.joints_msg.positions = joints.positions[0:12]\n\tself.joints_msg.header.stamp = rospy.Time.now()\n\tself.joints_pub.publish(self.joints_msg)\n\tself.traj_msg.joint_names = self.joints_msg.name\n\tself.traj_msg.points.positions = self.joints_msg.positions\n\tself.traj_msg.points.velocities = [0.0 for i in range(12)]\n\tself.traj_msg.points.accelerations = [0.0 for i in range(12)]\n\tself.traj_msg.points.effort = [0.0 for i in range(12)]\n\tself.traj_msg.points.time_from_start = rospy.Duration(1.0)\n\tself.traj_pub.publish(self.traj_msg)\n}", "CodeBleu_score": 44.28357022267381}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t//  ROS_INFO(\"Contacts: %d\", _msg->contact_size);\n  for (int i = 0; i < _msg->contact_size; i++) {\n    std::string collision1 = _msg->contact(i).collision1;\n    std::string::size_type loc = collision1.find(\"::\");\n    if (loc != std::string::npos) {\n      std::string link = collision1.substr(0, loc);\n      if (link == \"l_sole\") {\n        left_contact_ = true;\n      } else if (link == \"r_sole\") {\n        right_contact_ = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 39.49023934061677}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t//  printf(\"contacts received\n\");\n//  printf(\"contact size: %d\n\", _msg->contact_size);\n\n  for (int i = 0; i < _msg->contact_size; i++) {\n    std::string collision1 = _msg->contact(i).collision1;\n    std::string collision2 = _msg->contact(i).collision2;\n\n    std::size_t found = collision1.find(\"::\");\n    std::string link1 = collision1.substr(found + 2);\n\n    found = collision2.find(\"::\");\n    std::string link2 = collision2.substr(found + 2);\n\n    if (link1 == \"l_foot\" || link1 == \"r_foot\") {\n      foot_contact_[link1] = true;\n    }\n\n    if (link2 == \"l_foot\" || link2 == \"r_foot\") {\n      foot_contact_[link2] = true;\n    }\n  }\n}", "CodeBleu_score": 46.0299125698604}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t//    std::cout << \"Gazebo callback called\" << std::endl;\n//    std::cout << \"Number of contacts: \" << _msg->contact_size << std::endl;\n    for (int i = 0; i < _msg->contact_size; i++) {\n        std::string link_name = _msg->contact(i).collision1.substr(0, _msg->contact(i).collision1.find(\"::\"));\n        if (link_name == \"left_foot\" || link_name == \"right_foot\") {\n            foot_contacts[link_name] = true;\n        }\n    }\n}", "CodeBleu_score": 33.835586769892124}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n}", "CodeBleu_score": 3.0243722721573207}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\nif (!controller_parameters_.active_) {\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  rotor_velocities->setZero();\n  return;\n}\n\nEigen::Vector3d acceleration;\nComputeDesiredAcceleration(&acceleration);\n\nEigen::Vector3d angular_acceleration;\nComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\nEigen::VectorXd angular_acceleration_thrust(vehicle_parameters_.rotor_configuration_.rotors.size());\nangular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\nangular_acceleration_thrust.block<3, 1>(3, 0) = vehicle_parameters_.rotor_configuration_.thrust_coefficient_ * acceleration;\n\n// Ensure that all rotor velocities are non-negative.\nrotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\nrotor_velocities->setZero();\nrotor_velocities->cwiseMax(*angular_acceleration_thrust);\nrotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 56.05561879941908}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n// Check if controller is active.\nif (!controller_active_) {\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  rotor_velocities->setZero();\n  return;\n}\n\n// Ensure input and parameters are valid.\nassert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\nassert(rotor_velocities->cols() == 1);\n\n// Compute desired acceleration and angular acceleration.\nEigen::Vector3d acceleration;\nComputeDesiredAcceleration(&acceleration);\n\nEigen::Vector3d angular_acceleration;\nComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n// Project thrust onto body z-axis.\nEigen::Vector3d thrust_body_z;\nthrust_body_z = vehicle_parameters_.rotor_configuration_.rotors[0].thrust_moment_matrix_body_ * acceleration;\n\n// Combine thrust and angular acceleration.\nEigen::Vector3d thrust_moment_body;\nthrust_moment_body = angular_acceleration + thrust_body_z;\n\n// Compute rotor velocities.\nEigen::VectorXd angular_velocity_thrust(vehicle_parameters_.rotor_configuration_.rotors.size());\nangular_velocity_thrust.block<3, 1>(0, 0) = thrust_moment_body;\n\nfor (int i = 0; i < vehicle_parameters_.rotor_configuration_.rotors.size(); ++i) {\n  // Ensure non-negative values.\n  if (angular_velocity_thrust(i) < 0.0) {\n    angular_velocity_thrust(i) = 0.0;\n  }\n\n  // Take square root.\n  angular_velocity_thrust(i) = sqrt(angular_velocity_thrust(i));\n}\n\n// Copy result to output.\n*rotor_velocities = angular_velocity_thrust;\n}", "CodeBleu_score": 59.0013325329778}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position error\n\tEigen::Vector3d position_error;\n\tposition_error << odometry_.position.x() - command_trajectory_.position.x(), odometry_.position.y() - command_trajectory_.position.y(), odometry_.position.z() - command_trajectory_.position.z();\n\n\t// Compute the velocity error\n\tEigen::Vector3d velocity_error;\n\tvelocity_error << odometry_.velocity.x() - command_trajectory_.velocity.x(), odometry_.velocity.y() - command_trajectory_.velocity.y(), odometry_.velocity.z() - command_trajectory_.velocity.z();\n\n\t// Transform the vehicle's velocity to the world frame\n\tEigen::Vector3d world_velocity = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n\t// Compute the desired acceleration\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error + mass_ * gravity_ + acceleration_gain_ * (command_trajectory_.acceleration - world_velocity);\n}", "CodeBleu_score": 43.95151789293011}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tconst double kTimeStep = 0.005;\nEigen::Vector3d position_error;\nEigen::Vector3d velocity_error;\nEigen::Vector3d velocity_world;\nEigen::Vector3d acceleration_world;\nEigen::Vector3d acceleration_body;\nEigen::Vector3d commanded_acceleration;\n\n// Compute the position error.\nposition_error = ComputePositionError();\n\n// Compute the velocity error.\nvelocity_error = ComputeVelocityError();\n\n// Transform the vehicle's velocity to the world frame.\nvelocity_world = odometry_.orientation.toRotationMatrix() * velocity_;\n\n// Transform the vehicle's acceleration to the world frame.\nacceleration_world = odometry_.orientation.toRotationMatrix() * acceleration_;\n\n// Transform the vehicle's commanded acceleration to the world frame.\ncommanded_acceleration = odometry_.orientation.toRotationMatrix() * commanded_acceleration_;\n\n// Transform the vehicle's velocity and acceleration to the body frame.\nvelocity_body = odometry_.orientation.toRotationMatrix().transpose() * velocity_world;\nacceleration_body = odometry_.orientation.toRotationMatrix().transpose() * acceleration_world;\n\n// Compute the desired acceleration in the body frame.\nacceleration_body += (position_error * position_gain_ + velocity_error * velocity_gain_) / mass_ - gravity_;\n\n// Transform the desired acceleration back to the world frame.\nacceleration_world = odometry_.orientation.toRotationMatrix() * acceleration_body;\n\n// Transform the desired acceleration to the world frame.\n*acceleration = acceleration_world;\n\n// Adjust the acceleration based on the acceleration limits.\nacceleration->cwiseMin(max_acceleration_);\nacceleration->cwiseMax(min_acceleration_);\n\n// Adjust the acceleration based on the commanded acceleration.\nacceleration->cwiseMax(commanded_acceleration);\n}", "CodeBleu_score": 44.31165691070118}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// Compute position and velocity errors.\nEigen::Vector3d position_error;\nEigen::Vector3d velocity_error;\nComputePositionAndVelocityErrors(position_error, velocity_error);\n// Transform the velocity error to the world frame.\nvelocity_error = odometry_.orientation.toRotationMatrix() * velocity_error;\n// Compute the desired acceleration.\n*acceleration = position_gain_ * position_error +\nvelocity_gain_ * velocity_error +\ngravity_ +\ncommanded_acceleration_;\n}", "CodeBleu_score": 26.823134893429796}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n// Check input\nassert(rotor_velocities->rows() == kNumRotors);\n\n// Resize rotor_velocities if necessary\nif (rotor_velocities->cols() != 1) {\nrotor_velocities->resize(kNumRotors, 1);\n}\n\n// Compute desired angular acceleration\nEigen::Vector3d angular_acceleration_thrust;\nComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n// Calculate rotor velocities\n*rotor_velocities = rotor_thrust_matrix_ * (angular_acceleration_thrust + thrust_reference_);\nrotor_velocities->cwiseSqrt();\n\n// Ensure rotor velocities are at least one\nrotor_velocities->cwiseMax(Eigen::VectorXd::Ones(kNumRotors, 1));\n}", "CodeBleu_score": 50.53875089950894}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n// ensure input is valid\nassert(control_attitude_thrust_reference_.rows() == 3);\nassert(control_attitude_thrust_reference_.cols() == 1);\n\n// ensure parameters are valid\nassert(gain_attitude_.rows() == 3);\nassert(gain_attitude_.cols() == 1);\nassert(gain_angular_rate_.rows() == 3);\nassert(gain_angular_rate_.cols() == 1);\n\n// resize rotor velocities vector to match the number of rotors\nrotor_velocities->resize(rotor_thrust_moments_.rows());\n\n// calculate desired angular acceleration\nEigen::Vector3d angular_acceleration_thrust;\nComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n// compute rotor velocities\n*rotor_velocities = rotor_thrust_moments_.block<3, 1>(0, 0) + rotor_thrust_moments_.block<3, 1>(3, 0) * angular_acceleration_thrust.block<3, 1>\nComputeDesiredAngularAcc\nrotor_velocities->cwiseSqrt\nrotor_velocities->rows\nrotor_velocities->resize\nrotor_velocities->cwiseMax\nangular_acceleration_thrust\ncontrol_attitude_thrust_reference_\nassert\nEigen::VectorXd::Ones\n\n}", "CodeBleu_score": 51.60974339077002}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n// check input\nassert(control_attitude_thrust_reference_.rows() == 3);\nassert(control_attitude_thrust_reference_.cols() == 1);\n\nassert(attitude_.rows() == 3);\nassert(attitude_.cols() == 3);\n\nassert(angular_rate_.rows() == 3);\nassert(angular_rate_.cols() == 1);\n\nassert(gain_attitude_.rows() == 3);\nassert(gain_attitude_.cols() == 1);\n\nassert(gain_angular_rate_.rows() == 3);\nassert(gain_angular_rate_.cols() == 1);\n\nassert(thrust_reference_.rows() == 4);\nassert(thrust_reference_.cols() == 1);\n\n// resize rotor velocities\nrotor_velocities->resize(rotor_velocities->rows());\n\n// compute desired angular acceleration\nEigen::Vector3d angular_acceleration_thrust;\nComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n// compute rotor velocities\n*rotor_velocities = thrust_reference_.segment(0, 3) + angular_acceleration_thrust;\nrotor_velocities->cwiseSqrt();\nrotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n}", "CodeBleu_score": 48.678231575700636}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices of the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # Make a deep copy of the object\n    copied_obj = deepcopy(self)\n    # Slice each attribute of the copied object\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.position = copied_obj.position[start_index:end_index]\n    copied_obj.velocity = copied_obj.velocity[start_index:end_index]\n    copied_obj.acceleration = copied_obj.acceleration[start_index:end_index]\n    copied_obj.jerk = copied_obj.jerk[start_index:end_index]\n    copied_obj.snap = copied_obj.snap[start_index:end_index]\n    copied_obj.crackle = copied_obj.crackle[start_index:end_index]\n    copied_obj.pop = copied_obj.pop[start_index:end_index]\n    return copied_obj", "CodeBleu_score": 26.764835670779384}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    if start_index >= end_index:\n        raise ValueError('start_time must be before end_time')\n    new_obj = copy.deepcopy(self)\n    new_obj.time = self.time[start_index:end_index]\n    new_obj.value = self.value[start_index:end_index]\n    new_obj.index = self.index[start_index:end_index]\n    new_obj.time_units = self.time_units\n    new_obj.value_units = self.value_units\n    return new_obj", "CodeBleu_score": 49.61538066005732}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in self.data_attrs:\n        copied_obj.__setattr__(attr, self.__getattribute__(attr)[start_index:end_index])\n    return copied_obj\n", "CodeBleu_score": 42.10353159791636}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.position\n    orientation = waypoint_msg.orientation\n    # Convert the quaternion to Euler angles\n    (roll, pitch, yaw) = euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    # Check if the waypoint is different from the last one\n    if (self.last_point.x != point.x or self.last_point.y != point.y or self.last_point.z != point.z or self.last_yaw != yaw):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n        # Update the last_point and last_yaw variables\n        self.last_point = point\n        self.last_yaw = yaw\n", "CodeBleu_score": 25.803957476437546}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    self.append_times(msg_time, bag_time)\n    # Extract the position and rotation from the message\n    position = waypoint_msg.pose.pose.position\n    orientation = waypoint_msg.pose.pose.orientation\n    # Convert the quaternion to Euler angles\n    euler = euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    # Append the point to the arrays\n    self.append_point(point)\n    self.append_yaw(euler[2])\n    # Check if the current waypoint is different from the last one\n    if not numpy.array_equal(self.point, point) or not numpy.array_equal(self.yaw, euler[2]):\n        self.point = point\n        self.yaw = euler[2]\n        return True\n    return False\n", "CodeBleu_score": 24.02862941948545}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = [waypoint_msg.pose.pose.position.x, waypoint_msg.pose.pose.position.y, waypoint_msg.pose.pose.position.z]\n    quaternion = [waypoint_msg.pose.pose.orientation.x, waypoint_msg.pose.pose.orientation.y, waypoint_msg.pose.pose.orientation.z, waypoint_msg.pose.pose.orientation.w]\n    euler = euler_from_quaternion(quaternion)\n    yaw = euler[2]\n    if not numpy.array_equal(self.last_point, position) or not numpy.array_equal(self.last_yaw, yaw):\n        self.append_point(Point(position[0], position[1], position[2]))\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_point = position\n        self.last_yaw = yaw\n", "CodeBleu_score": 28.273037748998526}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9\n    self.append_times(msg_time, bag_time)\n    if topic == \"/imu/data\":\n        self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.linear_acceleration.x)\n        self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.linear_acceleration.y)\n        self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw\":\n        self.raw_linear_acceleration_x = numpy.append(self.raw_linear_acceleration_x, msg.linear_acceleration.x)\n        self.raw_linear_acceleration_y = numpy.append(self.raw_linear_acceleration_y, msg.linear_acceleration.y)\n        self.raw_linear_acceleration_z = numpy.append(self.raw_linear_acceleration_z, msg.linear_acceleration.z)\n    elif topic == \"/imu/mag\":\n        self.magnetic_field_x = numpy.append(self.magnetic_field_x, msg.magnetic_field.x)\n        self.magnetic_field_y = numpy.append(self.magnetic_field_y, msg.magnetic_field.y)\n        self.magnetic_field_z = numpy.append(self.magnetic_field_z, msg.magnetic_field.z)\n    elif topic == \"/imu/mag_raw\":\n        self.raw_magnetic_field_x = numpy.append(self.raw_magnetic_field_x, msg.magnetic_field.x)\n        self.raw_magnetic_field_y = numpy.append(self.raw_magnetic_field_y, msg.magnetic_field.y)\n        self.raw_magnetic_field_z = numpy.append(self.raw_magnetic_field_z, msg.magnetic_field.z)\n\n", "CodeBleu_score": 22.390840530955114}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n    elif topic == '/imu/data_raw':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n    elif topic == '/imu/mag':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.x = numpy.append(self.x, msg.magnetic_field.x)\n        self.y = numpy.append(self.y, msg.magnetic_field.y)\n        self.z = numpy.append(self.z, msg.magnetic_field.z)\n    elif topic == '/imu/data_raw_mag':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        self.x = numpy.append(self.x, msg.magnetic_field.x)\n        self.y = numpy.append(self.y, msg.magnetic_field.y)\n        self.z = numpy.append(self.z, msg.magnetic_field.z)\n    elif topic == '/imu/data_raw_accel':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self", "CodeBleu_score": 30.795477934921756}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.append_times(msg.header.stamp.secs, bag_time)\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw\":\n        self.append_times(msg.header.stamp.secs, bag_time)\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n    elif topic == \"/imu/mag\":\n        self.append_times(msg.header.stamp.secs, bag_time)\n        self.x = numpy.append(self.x, msg.magnetic_field.x)\n        self.y = numpy.append(self.y, msg.magnetic_field.y)\n        self.z = numpy.append(self.z, msg.magnetic_field.z)\n    elif topic == \"/imu/mag_raw\":\n        self.append_times(msg.header.stamp.secs, bag_time)\n        self.x = numpy.append(self.x, msg.magnetic_field.x)\n        self.y = numpy.append(self.y, msg.magnetic_field.y)\n        self.z = numpy.append(self.z, msg.magnetic_field.z)\n    elif topic == \"/imu/data_raw_mag\":\n        self.append_times(msg.header.stamp.secs, bag_time)\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        self.x = numpy.append(self.x, msg.magnetic_field.x)\n        self.y = numpy.append(self.y, msg.magnetic_field.y", "CodeBleu_score": 29.791459504869295}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create figure\n    fig = pyplot.figure()\n    # Create subplot\n    ax = fig.add_subplot(1, 1, 1)\n    # Plot acceleration data\n    for i, (name, data) in enumerate(self.accelerations.items()):\n        ax.plot(data.index, data.x, label=f\"x_{name}\")\n        ax.plot(data.index, data.y, label=f\"y_{name}\")\n        ax.plot(data.index, data.z, label=f\"z_{name}\")\n    # Add labels\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    # Add legend\n    ax.legend()\n    # Construct filename\n    filename = \"accelerations\"\n    if plot_suffix is not None:\n        filename += f\"_{plot_suffix}\"\n    filename += \".png\"\n    # Save plot\n    if self.save_plots:\n        pyplot.savefig(filename)\n    # Show plot\n    pyplot.show()\n", "CodeBleu_score": 35.150493205876195}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure and subplot\n    fig = pyplot.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    # Plot the x, y, and z components of each acceleration dataset\n    for i, dataset in enumerate(self.accelerations):\n        ax.plot(dataset.time, dataset.x, label=f'x {i}', color=f'C{i}')\n        ax.plot(dataset.time, dataset.y, label=f'y {i}', color=f'C{i}')\n        ax.plot(dataset.time, dataset.z, label=f'z {i}', color=f'C{i}')\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Add a legend\n    ax.legend()\n\n    # Construct a filename for the plot and save the plot\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        filename = f'accelerations{plot_suffix}.png'\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 32.22206207145657}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle('Accelerations')\n    for i, dataset in enumerate(self.accelerations):\n        ax = fig.add_subplot(3, 1, i + 1)\n        ax.plot(dataset[:, 0], dataset[:, 1], 'r', label='x')\n        ax.plot(dataset[:, 0], dataset[:, 2], 'g', label='y')\n        ax.plot(dataset[:, 0], dataset[:, 3], 'b', label='z')\n        ax.set_ylabel(str(i))\n        ax.legend()\n    ax.set_xlabel('Time (s)')\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        pyplot.savefig(self.prefix + 'accelerations' + plot_suffix + '.png')\n    pyplot.show()\n", "CodeBleu_score": 39.6020808843338}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print\n        'Error: At least two pose indices must be provided.'\n    else:\n        for i in range(len(pose_indeces) - 1):\n            compare_two_xyz(self.xyz_list[pose_indeces[i]], self.xyz_list[pose_indeces[i + 1]])\n\n", "CodeBleu_score": 19.882550494150934}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in pose_indeces:\n        for j in pose_indeces[i:]:\n            if i != j:\n                if compare_two_xyz(self.pose_list[i].xyz, self.pose_list[j].xyz):\n                    print(\"Pose {} is similar to Pose {}.\".format(i, j))\n                else:\n                    print(\"Pose {} is not similar to Pose {}.\".format(i, j))\n", "CodeBleu_score": 35.521513208221556}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for i in self.wrench:\n        if i[0] >= start_time and i[0] <= end_time:\n            collision_times.append(i[0])\n    return collision_times\n", "CodeBleu_score": 29.286528944467914}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 36.74172620165253}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time is None and end_time is None:\n            collision_times.append(time)\n        elif start_time is None and end_time is not None:\n            if time <= end_time:\n                collision_times.append(time)\n        elif start_time is not None and end_time is None:\n            if time >= start_time:\n                collision_times.append(time)\n        else:\n            if start_time <= time <= end_time:\n                collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 40.69431888919432}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n}", "CodeBleu_score": 2.7370175023774364}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == NULL) {\nreturn;\n}\n\nconst float multiplier = GetMultiplier(width, height);\n\nEigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\nEigen::VectorXf rms_noise =\nEigen::VectorXf::Constant(width * height, this->noise_sigma_meters *\nthis->noise_sigma_meters);\n\nEigen::VectorXf noise = Eigen::VectorXf::Random(width * height);\n\nfor (uint32_t i = 0; i < width * height; i++) {\nif (InRange(data_vector_map[i] * multiplier)) {\ndata_vector_map[i] += noise[i] * rms_noise[i];\n} else {\ndata_vector_map[i] = this->bad_point_value;\n}\n}\n}", "CodeBleu_score": 51.36793080494273}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\nreturn;\n}\nconst float multiplier = this->GetMultiplier(width, height);\nconst float min_depth = this->min_depth;\nconst float max_depth = this->max_depth;\nconst float bad_point = this->bad_point;\n\nconst float max_dist = max_depth * multiplier;\nconst float min_dist = min_depth * multiplier;\n\nconst Eigen::Map<const Eigen::ArrayXf> data_vector_map(data, width * height);\n\nconst Eigen::ArrayXf rms_noise = this->dist\nstd::min\n(data_vector_map * 1000.0).array().square\nrms_noise.array().square\nInRange\nrms_noise.array\n(data_vector_map * 1000.0).array\ntanf\nnoise\n\nfor (uint32_t i = 0; i < width * height; ++i) {\nif (InRange(data_vector_map[i] * multiplier)) {\ndata[i] = data_vector_map[i] * multiplier + noise[i];\n} else {\ndata[i] = bad_point;\n}\n}\n}", "CodeBleu_score": 53.37414038842928}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n// Get the current simulation time.\nros::Time current_time = this->ros_node_->GetSimTime();\n\n// Convert the current simulation time to ROS time.\nros::Time ros_time(current_time.sec, current_time.nsec);\n\n// Write the trajectory message to a bag file using the specified namespace and waypoint topic.\nthis->ros_bag_.write(this->namespace_ + \"/\" + this->waypoint_topic_, ros_time, trajectory_msg);\n}", "CodeBleu_score": 53.39870309888666}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n// Get the current simulation time.\nros::Time current_time = gazebo_ros_->GetWorld()->SimTime();\n\n// Convert the simulation time to a ROS time.\nros::Time ros_time = gazebo_ros_->Convert(current_time);\n\n// Write the trajectory message to the bag file.\nbag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, trajectory_msg);\n\n}", "CodeBleu_score": 55.80275047141576}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n// Get the current simulation time.\nros::Time current_time = world_->SimTime();\n\n// Convert the simulation time to a ROS time.\nros::Time ros_time(current_time.sec, current_time.nsec);\n\n// Write the trajectory message to the bag file.\nbag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, trajectory_msg);\n\n}", "CodeBleu_score": 65.78359098851429}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n// Convert the simulation time to ROS time.\nros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n// Prepare a message for actuator velocities.\nsensor_msgs::JointState rot_velocities_msg;\nrot_velocities_msg.header.stamp = ros_time;\nrot_velocities_msg.name.resize(motor_joints_.size());\nrot_velocities_msg.position.resize(motor_joints_.size());\nrot_velocities_msg.velocity.resize(motor_joints_.size());\nrot_velocities_msg.effort.resize(motor_joints_.size());\n\n// Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\nfor (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); m++) {\nrot_velocities_msg.name[m->second->GetScopedName().substr(1).find(\"_\") + 1] = m->first;\nrot_velocities_msg.position[m->second->GetScopedName().substr(1).find(\"_\") + 1] = m->second->GetAngle(0).Radian();\nrot_velocities_msg.velocity[m->second->GetScopedName().substr(1).find(\"_\") + 1] = m->second->GetVelocity(0);\nrot_velocities_msg.effort[m->second->GetScopedName().substr(1).find(\"_\") + 1] = m->second->GetForce(0);\n}\n\n// Write the message to a bag file using the specified namespace and motor topic.\nbag_.write(namespace_ + \"/\" + motor_topic_, ros_time, rot_velocities_msg);\n}", "CodeBleu_score": 54.62485188485362}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time ros_time = ros::Time(now.sec, now.nsec);\n\nif (ros_time < start_time_) {\nreturn;\n}\n\nif (ros_time > end_time_) {\nreturn;\n}\n\ngazebo::common::Time gz_time = gazebo::common::Time(now.sec, now.nsec);\n\ngazebo::math::Vector3 vel;\n\nfor (auto m = motor_joints_.begin(); m != motor_joints_.end(); m++) {\nvel = m->second->GetVelocity(gz_time);\n\ndouble rot_vel = vel.x * 0.5;\n\nrot_velocities_msg.angular_velocities.push_back(rot_vel);\n}\n\nrot_velocities_msg.header.stamp = ros_time;\n\nrosbag::Bag bag;\nbag.open(bag_file_, rosbag::bagmode::Append);\nbag.write(namespace_ + \"/\" + motor_topic_, rot_velocities_msg.header.stamp,\nrot_velocities_msg);\nbag.close();\n}", "CodeBleu_score": 52.731387233076696}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert the simulation time to ROS time.\nros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n// Prepare a message for actuator velocities.\ngazebo_msgs::JointCmd rot_velocities_msg;\nrot_velocities_msg.header.stamp = ros_time;\nrot_velocities_msg.name.resize(motor_joints_.size());\nrot_velocities_msg.position.resize(motor_joints_.size());\nrot_velocities_msg.velocity.resize(motor_joints_.size());\nrot_velocities_msg.effort.resize(motor_joints_.size());\n\n// Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\ngazebo::physics::Joint_V::iterator m;\nfor (m = motor_joints_.begin(); m != motor_joints_.end(); m++) {\nrot_velocities_msg.name[m->first - 1] = m->second->GetScopedName();\nrot_velocities_msg.position[m->first - 1] = m->second->GetAngle(0).Radian();\nrot_velocities_msg.velocity[m->first - 1] = m->second->GetVelocity(0);\nrot_velocities_msg.effort[m->first - 1] = m->second->GetForce(0);\n}\n\n// Write the data to a bag file using the specified namespace and motor topic.\nbag_.write(namespace_ + \"/\" + motor_topic_, ros_time, rot_velocities_msg);\n}", "CodeBleu_score": 59.031543058002114}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_PLUGIN_VERBOSE\n  gzmsg << \"RollPitchYawrateThrustCallback() called\n\";\n#endif\n\n  // Convert normalized input values to control surface angles\n  double roll_angle = NormalizedInputToAngle(roll_surface_,\n                                            roll_pitch_yawrate_thrust_msg->roll());\n  double pitch_angle = NormalizedInputToAngle(pitch_surface_,\n                                             roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n\n  // Set control surface angles\n  aileron_angle_ = roll_angle;\n  elevator_angle_ = pitch_angle;\n  rudder_angle_ = yaw_rate;\n\n  // Set throttle value\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 42.77139481243397}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\nif (debug_printing_enabled_) {\nROS_DEBUG_NAMED(\"gazebo_fw_dynamics_plugin\", \"RollPitchYawrateThrustCallback called\");\n}\n\n// Convert normalized input values to control surface angles.\nroll_ = NormalizedInputToAngle(roll_surface_, roll_pitch_yawrate_thrust_msg->roll());\npitch_ = NormalizedInputToAngle(pitch_surface_, roll_pitch_yawrate_thrust_msg->pitch());\nyaw_rate_ = roll_pitch_yawrate_thrust_msg->yaw_rate();\n\n// Set the throttle value from the thrust message.\nthrust_ = roll_pitch_yawrate_thrust_msg->thrust();\n\n// Publish the control surface angles and the thrust value.\nPublishControlSurfaceAngles();\nPublishThrust();\n}", "CodeBleu_score": 36.1175066113799}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_FW_DYNAMICS_DEBUG_PRINT\n  gzdbg << \"RollPitchYawrateThrustCallback called.\n\";\n#endif\n\n  // Convert normalized input values to control surface angles.\n  double aileron = NormalizedInputToAngle(ailerons_, roll_pitch_yawrate_thrust_msg->roll());\n  double elevator = NormalizedInputToAngle(elevators_, roll_pitch_yawrate_thrust_msg->pitch());\n  double rudder = NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  SetThrottle(roll_pitch_yawrate_thrust_msg->thrust());\n\n  // Publish the control surface angles.\n  PublishControlSurfaceAngles(aileron, elevator, rudder);\n}", "CodeBleu_score": 43.773246507983266}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t//  struct timeval timeout;\n//  timeout.tv_sec = static_cast<time_t>(_timeoutMs / 1000);\n//  timeout.tv_usec = static_cast<suseconds_t>(_timeoutMs % 1000) * 1000;\n\n//  fd_set rfds;\n//  FD_ZERO(&rfds);\n//  FD_SET(_fd, &rfds);\n\n//  int ret = select(_fd + 1, &rfds, nullptr, nullptr, &timeout);\n//  if (ret > 0) {\n//    struct sockaddr_in srcaddr;\n//    socklen_t addrlen = sizeof(srcaddr);\n//    char buf[1024];\n\n//    ssize_t len = recvfrom(\n//        _fd, buf, sizeof(buf), 0, (struct sockaddr*)&srcaddr, &addrlen);\n//    if (len > 0) {\n//      //      printf(\"Received %d bytes\n\", len);\n//      mavlink_message_t msg;\n//      mavlink_status_t status;\n\n//      for (int i = 0; i < len; ++i) {\n//        mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status);\n\n//        if (status.got_packet) {\n//          handle_message(&msg);\n//        }\n//      }\n//    }\n//  }\n}", "CodeBleu_score": 1.4726803394282788}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n  common::Time timeout = common::Time(0, _timeoutMs * 1000);\n  common::Time start_time = world_->SimTime();\n  while (world_->SimTime() - start_time < timeout) {\n    io_service_.poll();\n    {\n      lock_guard lock(mutex_);\n      if (!tx_q_.empty()) {\n        do_write(true);\n      }\n    }\n  }\n#else\n  struct timeval timeout;\n  timeout.tv_sec = 0;\n  timeout.tv_usec = _timeoutMs * 1000;\n  fd_set rfds;\n  FD_ZERO(&rfds);\n  FD_SET(_fd, &rfds);\n  select(_fd + 1, &rfds, NULL, NULL, &timeout);\n  if (FD_ISSET(_fd, &rfds)) {\n    struct sockaddr_in srcaddr;\n    socklen_t addrlen = sizeof(srcaddr);\n    ssize_t len = recvfrom(\n        _fd, rx_buffer_, sizeof(rx_buffer_), 0, (struct sockaddr*)&srcaddr,\n        &addrlen);\n    if (len > 0) {\n      mavlink_message_t msg;\n      while (mavlink_parse_char(MAVLINK_COMM_0, rx_buffer_, len, &msg) > 0) {\n        handle_message(&msg);\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 48.96429799105127}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n  int timeout = _timeoutMs / 1000;\n#else\n  int timeout = _timeoutMs / 1000;\n#endif\n\n  // Get the time of the last message received.\n  common::Time lastMsgTime = last_msg_time_;\n\n  // Get the current time.\n  common::Time currentTime = world_->SimTime();\n\n  // Compute the time difference between the last message received and the current time.\n  common::Time elapsedTime = currentTime - lastMsgTime;\n\n  // If the elapsed time is less than the specified timeout, poll for messages.\n  if (elapsedTime.sec < _timeoutMs / 1000.0) {\n    struct timeval tv;\n    tv.tv_sec = 0;\n    tv.tv_usec = timeout * 1000;\n    fd_set rfds;\n    FD_ZERO(&rfds);\n    FD_SET(_fd, &rfds);\n    int ret = select(_fd + 1, &rfds, NULL, NULL, &tv);\n    if (ret == 0) {\n      return;\n    }\n    if (ret < 0) {\n      perror(\"select\");\n      return;\n    }\n  }\n\n  // Receive data from the serial port.\n  char buffer[MAVLINK_MAX_PACKET_LEN];\n  int bytes_received = 0;\n  {\n    lock_guard lock(mutex_);\n    bytes_received = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n  }\n\n  // If data was received, parse the messages.\n  if (bytes_received > 0) {\n    uint8_t* buffer_ptr = reinterpret_cast<uint8_t*>(buffer);\n    while (mavlink_parse_char(MAVLINK_COMM_0, buffer_ptr, &rx_msg_,\n                             bytes_received)) {\n      handle_message(&rx_msg_);\n      last_msg_time_ = world_->SimTime();\n    }\n  }\n\n  // If the serial port is enabled, send any messages in the transmit queue.\n  if (serial_enabled_) {\n    io_service_.post(\n        std::bind(&GazeboMavlinkInterface::do_write, this, false));\n  }\n}", "CodeBleu_score": 42.212817710719975}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tboost::mutex::scoped_lock lock(mutex_);\nif (is_open_) {\nio_service_.stop();\nserial_dev_.close();\nif (io_thread_.joinable()) {\nio_thread_.join();\n}\nis_open_ = false;\n}\n}", "CodeBleu_score": 66.09979360728776}, {"code": "void GazeboMavlinkInterface::close() {\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex_);\n\n\t// Check if the interface is open\n\tif (is_open_)  {\n\t\t// Stop the I/O service\n\t\tio_service_.stop();\n\n\t\t// Close the serial device\n\t\tserial_dev_.close();\n\n\t\t// If the I/O thread is joinable, join it\n\t\tif (io_thread_.joinable())  {\n\t\t\tio_thread_.join();\n\t\t}\n\n\t\t// Set the interface as closed\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 65.24632487378332}, {"code": "void GazeboMavlinkInterface::close() {\n\t\t// Lock mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex_);\n\n\t// Check if interface is open\n\tif (is_open_) {\n\t\t// Stop I/O service\n\t\tio_service_.stop();\n\n\t\t// Close serial device\n\t\tserial_dev_.close();\n\n\t\t// If thread is joinable, join it\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\n\t\t// Set interface as closed\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 65.28947523098043}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d result;\n\tresult.X() = (x2 - x1) / (y2 - y1) * (value - y1) + x1;\n\tresult.Y() = value;\n\tresult.Z() = 0;\n\treturn result;\n}", "CodeBleu_score": 27.66214928315604}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d result;\n\tresult.X() = (x2 - x1) * (position - x1) / (x2 - x1) + x1;\n\tresult.Y() = (y2 - y1) * (position - x1) / (x2 - x1) + y1;\n\tresult.Z() = (z2 - z1) * (position - x1) / (x2 - x1) + z1;\n\treturn result;\n}", "CodeBleu_score": 39.00586046974271}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (m_time != _time) {\n\t\tm_time = _time;\n\t\tif (m_looping) {\n\t\t\tm_time = fmod(m_time, m_length);\n\t\t} else {\n\t\t\tm_time = clamp(m_time, 0.0, m_length);\n\t\t}\n\t\tm_dirty = true;\n\t}\n}", "CodeBleu_score": 31.331694203040616}, {"code": "void Animation::SetTime(double _time){\n\t\tif (m_time == _time) return;\n\n\tm_time = _time;\n\tif (m_looping) m_time = fmod(m_time, m_length);\n\telse m_time = Clamp(m_time, 0.0, m_length);\n\n\tm_frame = (int)m_time * m_fps;\n\tif (m_frame >= m_lengthFrames) m_frame = m_lengthFrames - 1;\n\n\tm_time = m_frame / m_fps;\n}", "CodeBleu_score": 32.931174185995815}, {"code": "void Animation::SetTime(double _time){\n\t\tif (m_time != _time) {\n\t\tm_time = _time;\n\t\tm_time = std::fmod(m_time, m_length);\n\t\tif (m_time < 0.0)\n\t\t\tm_time += m_length;\n\t\tif (m_looping)\n\t\t\tm_time = std::fmod(m_time, m_length);\n\t\telse\n\t\t\tm_time = Clamp(m_time, 0.0, m_length);\n\t\tm_time = std::fmod(m_time, m_length);\n\t}\n}", "CodeBleu_score": 33.25738130875456}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target()\n    self.print_info()\n", "CodeBleu_score": 38.15549950319762}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.local_position[0], y=self.local_position[1], z=self.local_position[2], yaw=self.attitude[2])\n    self.print_vehicle_state()\n\n", "CodeBleu_score": 60.017969812697416}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.send_target(target_raw_pose)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + self.flight_mode)\n    print(\"", "CodeBleu_score": 42.081301625459524}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(0, self.flight_modes[self.flight_mode])\n            self.flight_mode = self.flight_mode\n            return True\n        except:\n            print('Failed to switch to flight mode: '+self.flight_mode)\n            return False\n", "CodeBleu_score": 37.54661360879477}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+\"Mode Switch Failed\")\n            return False\n\n", "CodeBleu_score": 57.10273838192985}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            return True\n        except:\n            print(\"Flight mode switch failed\")\n            return False\n", "CodeBleu_score": 31.911505304051897}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(x=msg.linear.x, y=msg.linear.y, z=msg.linear.z,\n                                                       vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       afx=0, afy=0, afz=0,\n                                                       yaw=self.current_yaw, yaw_rate=msg.angular.z)\n", "CodeBleu_score": 57.936149629652824}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x, y, z, w)\n    if self.hover_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(x=x, y=y, z=z, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=w)\n", "CodeBleu_score": 37.14088516227092}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(x=msg.linear.x, y=msg.linear.y, z=msg.linear.z,\n                                                       vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       afx=0, afy=0, afz=0, yaw=0, yaw_rate=msg.angular.z)\n", "CodeBleu_score": 58.72120740802601}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode == \"HOVER\":\n        if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02) or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        else:\n            self.hover_flag = 1\n    else:\n        if (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02) and abs(w) < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n\n", "CodeBleu_score": 69.99608963478696}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02) or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        if self.hover_flag == 1:\n            self.hover_flag = 0\n            self.flight_mode = \"HOVER\"\n            self.hover()\n    else:\n        if (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02) and abs(w) < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = \"OFFBOARD\"\n            self.hover()\n\n", "CodeBleu_score": 63.45126761107562}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif self.hover_flag == 0 and self.flight_mode == 'OFFBOARD':\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n\n", "CodeBleu_score": 75.90289757404206}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 17.485641283375248}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.vehicle.send_mavlink(target_raw_pose)\n    print(\"Vehicle type: {}, Vehicle ID: {}, Flight Mode: {}\".format(self.vehicle_type, self.vehicle_id, self.flight_mode))\n\n", "CodeBleu_score": 36.73645920023}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 3\n    self.target_motion = self.construct_target()\n    self.print()\n    self.send_target_motion()\n    self.print_flight_mode()\n\n", "CodeBleu_score": 28.36769577747494}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 3\n    self.target_raw = self.construct_target(x=self.local_position[0], y=self.local_position[1], z=self.local_position[2], yaw=self.attitude[2])\n    self.print()\n\n", "CodeBleu_score": 43.20088412412334}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":Failed to switch to flight mode \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 59.309803487695646}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            self.flight_mode = self.flight_modes[self.flight_modes.index(self.flight_mode) + 1]\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":Failed to switch flight mode.\")\n            return False\n\n", "CodeBleu_score": 56.398390561545355}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print('Flight mode switch failed for ' + self.vehicle_type + '_' + self.vehicle_id + \".\")\n            return False\n", "CodeBleu_score": 55.72362749724352}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n    return self.total_reward\n", "CodeBleu_score": 52.43689793432701}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n\n    if msg.header.seq == self.uav_id:\n        self.local_pose = msg\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x + self.bias_x\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y + self.bias_y\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z + self.bias_z\n        self.local_pose.pose.orientation = self.local_pose.pose.orientation\n        self.local_pose.header.frame_id = 'uav' + str(self.uav_id)\n        self.local_pose.header.stamp = rospy.Time.now()\n        self.global_pose = self.tf_listener.transformPose(\"world\", self.local_pose)\n        self.global_pose.header.frame_id = 'world'\n        self.global_pose.header.stamp = rospy.Time.now()\n\n        if self.uav_id == 1:\n            self.takeoff_target_pose = self.global_pose\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 2:\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 3:\n            self.takeoff_target_pose = self.global_pose\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 4:\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 5:\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 6:\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 7:\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 8:\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 9:\n            self.hover_target_pose = self.global_pose\n\n        if self.uav_id == 10:\n           ", "CodeBleu_score": 18.993635950153006}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose = msg\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x + self.bias[0]\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y + self.bias[1]\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z + self.bias[2]\n        self.local_pose.pose.orientation = self.local_pose.pose.orientation\n        self.global_pose = self.local_pose\n        self.global_pose.pose.position.x = self.global_pose.pose.position.x + self.bias[0]\n        self.global_pose.pose.position.y = self.global_pose.pose.position.y + self.bias[1]\n        self.global_pose.pose.position.z = self.global_pose.pose.position.z + self.bias[2]\n        if self.takeoff_target_pose.header.frame_id == self.local_pose.header.frame_id:\n            self.takeoff_target_pose.pose = self.local_pose.pose\n            self.hover_target_pose.pose = self.local_pose.pose\n        else:\n            self.hover_target_pose.pose = self.hover_target_pose.pose\n        self.takeoff_target_pose.header.stamp = self.local_pose.header.stamp\n        self.hover_target_pose.header.stamp = self.local_pose.header.stamp\n        self.global_pose.header.stamp = self.local_pose.header.stamp\n        self.local_pose_pub.publish(self.local_pose)\n        self.global_pose_pub.publish(self.global_pose)\n        self.takeoff_target_pose_pub.publish(self.takeoff_target_pose)\n        self.hover_target_pose_pub.publish(self.hover_target_pose)\n        self.pose_lock.acquire()\n        self.pose_list[i] = self.global_pose\n        self.pose_lock.release()\n", "CodeBleu_score": 21.4450702553658}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose = msg.pose\n        self.local_pose.position.x += self.bias_x\n        self.local_pose.position.y += self.bias_y\n        self.local_pose.position.z += self.bias_z\n        self.global_pose = deepcopy(self.local_pose)\n        self.global_pose.position.x += self.global_pose_bias_x\n        self.global_pose.position.y += self.global_pose_bias_y\n        self.global_pose.position.z += self.global_pose_bias_z\n        if self.takeoff_target_pose != None:\n            self.hover_target_pose = deepcopy(self.global_pose)\n            self.hover_target_pose.position.x += self.hover_target_pose_bias_x\n            self.hover_target_pose.position.y += self.hover_target_pose_bias_y\n            self.hover_target_pose.position.z += self.hover_target_pose_bias_z\n        if self.hover_target_pose != None:\n            self.takeoff_target_pose = deepcopy(self.global_pose)\n            self.takeoff_target_pose.position.x += self.takeoff_target_pose_bias_x\n            self.takeoff_target_pose.position.y += self.takeoff_target_pose_bias_y\n            self.takeoff_target_pose.position.z += self.takeoff_target_pose_bias_z\n        if self.hover_target_pose != None:\n            self.land_target_pose = deepcopy(self.global_pose)\n            self.land_target_pose.position.x += self.land_target_pose_bias_x\n            self.land_target_pose.position.y += self.land_target_pose_bias_y\n            self.land_target_pose.position.z += self.land_target_pose_bias_z\n        if self.hover_target_pose != None:\n            self.path_target_pose = deepcopy(self.global_pose)\n            self.path_target_pose.position.x += self.path_target_pose_bias_x\n            self.path_target_", "CodeBleu_score": 17.674052550758606}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.pose.position.z > 0.2 and self.arm_state == 'active':\n        return True\n    else:\n        return False\n", "CodeBleu_score": 65.05804354888443}, {"code": "def takeoff_detection(self)\n\t\n    if self.alt > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 69.72643164437362}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state == \"active\":\n        if self.current_altitude > 0.2:\n            return True\n        else:\n            return False\n    else:\n        return False\n\n", "CodeBleu_score": 59.48773999218345}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # orig_formation and change_formation are lists of lists.\n    # Each list contains the x, y, and z coordinates of the UAVs in the formation.\n    # Each list is ordered from left to right, top to bottom, and front to back.\n    # For example, orig_formation[0] is the x, y, and z coordinates of the UAV at the front left corner of the formation.\n    # change_formation is the changed version of orig_formation.\n    # The distance between UAVs in orig_formation and change_formation is the Euclidean norm of the difference in their x, y, and z coordinates.\n    # The distance matrix is a list of lists.\n    # Each list contains the distances between UAVs in the original and changed formations.\n    # The distance matrix is ordered from left to right, top to bottom, and front to back.\n    # For example, distance_matrix[0] is the distances between UAVs in the front left corner of the original and changed formations.\n    # The distance matrix is symmetric.\n    # For example, distance_matrix[0][0] is the distance between UAVs in the front left corner of the original and changed formations.\n    # distance_matrix[0][1] is the distance between UAVs in the front right corner of the original and changed formations.\n    # distance_matrix[1][0] is the distance between UAVs in the back left corner of the original and changed formations.\n    # distance_matrix[1][1] is the distance between UAVs in the back right corner of the original and changed formations.\n    # distance_matrix[0][2] is the distance between UAVs in the front left corner of the original and back left corner of the changed formation.\n    # distance_matrix[1][2] is the distance between UAVs in the back left corner of the original and back right corner of the changed formation.\n    # distance_matrix[2][0] is the distance between UAVs in the front left corner of the changed and back left corner of the original formation.\n    # distance_matrix[2][1] is the distance between UAVs in the back right corner of the changed and back left corner of the original formation.\n    # distance_matrix[2][2] is the distance between UAVs in the back right corner of the changed and", "CodeBleu_score": 1.3540510543840176}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create a distance matrix for the original formation\n    dist_matrix_orig = np.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            if i != j:\n                dist_matrix_orig[i, j] = norm(orig_formation[i] - orig_formation[j])\n\n    # Create a distance matrix for the changed formation\n    dist_matrix_change = np.zeros((len(change_formation), len(change_formation)))\n    for i in range(len(change_formation)):\n        for j in range(len(change_formation)):\n            if i != j:\n                dist_matrix_change[i, j] = norm(change_formation[i] - change_formation[j])\n\n    # Subtract the distance matrix for the original formation from the distance matrix for the changed formation\n    dist_matrix_diff = dist_matrix_change - dist_matrix_orig\n\n    # Convert the distance matrix to integers\n    dist_matrix_diff = dist_matrix_diff.astype(int)\n\n    return dist_matrix_diff\n", "CodeBleu_score": 23.793425736759215}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n            dist_matrix[i][j] = 50 - dist_matrix[i][j]\n            dist_matrix[i][j] = int(dist_matrix[i][j])\n    return dist_matrix\n\n", "CodeBleu_score": 28.94485379224002}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.n_uav):\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n        self.slack_right[i] = float('inf')\n    for i in range(self.n_uav):\n        while not self.find_path(i):\n            delta = float('inf')\n            for j in range(self.n_uav):\n                if self.visit_right[j] and self.slack_right[j] < delta:\n                    delta = self.slack_right[j]\n                    i_min = j\n            for j in range(self.n_uav):\n                if self.visit_left[j]:\n                    self.label_left[j] -= delta\n                    self.label_right[j] += delta\n            self.slack_right[i_min] = float('inf')\n    return self.match_right\n", "CodeBleu_score": 31.134863078132696}, {"code": "def KM(self)\n\t\n    for i in range(self.n_left):\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n        self.match_right[i] = -1\n        self.slack_right[i] = float('inf')\n    for i in range(self.n_left):\n        while True:\n            self.visit_left[i] = True\n            for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n                if self.visit_right[j]:\n                    continue\n                gap = self.label_left[i] + self.label_right[j] - match_weight\n                if gap == 0:\n                    self.visit_right[j] = True\n                    if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                        self.match_right[j] = i\n                        break\n                else:\n                    self.slack_right[j] = min(gap, self.slack_right[j])\n            else:\n                break\n        for j in range(self.n_right):\n            if self.visit_right[j]:\n                self.label_right[j] -= self.slack_right[j]\n                self.slack_right[j] = float('inf')\n    for i in range(self.n_left):\n        if self.match_right[i] == -1:\n            self.label_left[i] -= min(self.label_left[i], self.label_right)\n    return self.match_right\n", "CodeBleu_score": 27.118874237185288}, {"code": "def KM(self)\n\t\n    while True:\n        self.reset_visit()\n        for i in range(self.n_uavs):\n            if not self.find_path(i):\n                self.adjust_labels(i)\n        if self.check_all_visited():\n            break\n    return self.match_right\n", "CodeBleu_score": 10.717578662246565}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert to HSV color space and separate the V channel\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    h, s, v = cv2.split(hsv)\n\n    # Threshold the V channel\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 25.886339779438593}, {"code": "def yellow_dectection(image)\n\t\n    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([15, 100, 100])\n    upper_yellow = np.array([35, 255, 255])\n    mask = cv2.inRange(hsv_img, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 27.202122376504146}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([18, 94, 140])\n    upper_yellow = np.array([48, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 29.874331121547975}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t// Check if the tag ID is in the map.\n\tif (standalone_tag_descriptions_.find(tag_id) == standalone_tag_descriptions_.end()) {\n\t\t// If not, check if we should print a warning.\n\t\tif (printWarning) {\n\t\t\tROS_WARN_THROTTLE(1, \"Standalone tag with ID %d not found.\", tag_id);\n\t\t}\n\t\t// Return false if we should not print a warning.\n\t\treturn false;\n\t}\n\t// If we get here, the tag ID is in the map.\n\t// Set the descriptionContainer to the tag's description.\n\tdescriptionContainer = standalone_tag_descriptions_[tag_id];\n\t// Return true.\n\treturn true;\n}", "CodeBleu_score": 31.860872593071658}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tbool found = false;\n\ttag_descriptions::TagDescriptionContainer *descriptionContainer = NULL;\n\tif (standalone_tag_descriptions_.find(id, descriptionContainer)) {\n\t\tdescriptionContainer_ = descriptionContainer;\n\t\tfound = true;\n\t} else if (printWarning) {\n\t\tROS_WARN_THROTTLE(1.0, \"TagDetector: Could not find tag description for tag ID %d. Ignoring tag.\", id);\n\t}\n\treturn found;\n}", "CodeBleu_score": 30.56635024004011}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n}", "CodeBleu_score": 0.6648108845887202}]}
