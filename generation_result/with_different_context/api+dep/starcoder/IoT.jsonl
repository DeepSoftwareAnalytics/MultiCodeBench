{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t * p = (uint8_t *) desc;\n\tuint8_t * end = (uint8_t *) desc + desc->bLength;\n\twhile (p < end) {\n\t\tif (p[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += p[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.4089666297264}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t * p = (uint8_t *) desc;\n\tuint8_t * end = (uint8_t *) desc + desc->bLength;\n\twhile (p < end) {\n\t\tuint8_t len = p[0];\n\t\tif (p[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += len;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 35.88448550192201}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t * p = (uint8_t *) desc;\n\tuint8_t len = desc->bLength;\n\n\twhile (len) {\n\t\tif (p[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += len;\n\t\tlen = p[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 31.689170990001088}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t", "CodeBleu_score": 3.3394715816443945}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t", "CodeBleu_score": 3.3394715816443945}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tuint16_t len;\n\tuint8_t *payload;\n\tuint16_t ep_status;\n\n\t/* Get the endpoint number and the length of the request */\n\tep_num = udc_req_std_get_ep_num();\n\tlen = udc_req_std_get_len();\n\n\t/* Check if the request length is correct */\n\tif (len != 2) {\n\t\treturn false;\n\t}\n\n\t/* Check if the endpoint number is valid */\n\tif (ep_num > UDC_NUM_EP_MAX) {\n\t\treturn false;\n\t}\n\n\t/* Check if the endpoint is halted */\n\tep_status = udd_ep_is_halted(ep_num);\n\n\t/* Set the response payload to the endpoint status */\n\tpayload = udc_req_std_get_payload();\n\tpayload[0] = (uint8_t)ep_status;\n\tpayload[1] = (uint8_t)(ep_status >> 8);\n\n\t/* Return \"true\" to indicate that the request was handled */\n\treturn true;\n}", "CodeBleu_score": 31.87751161990085}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t", "CodeBleu_score": 1.917982802830473}, {"code": "static bool udc_req_iface(void){\n\t", "CodeBleu_score": 1.917982802830473}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tbool result = false;\n\n\t// Check if the device is in a configured state\n\tif (true == udc_is_configured()) {\n\t\t// Get interface number and alternate setting number\n\t\tiface_num = udc_ctrl_request.wIndex & 0xFF;\n\t\tsetting_num = udc_ctrl_request.wValue & 0xFF;\n\n\t\t// Update interface descriptor to default setting\n\t\tif (true == udc_update_iface_desc(iface_num, 0)) {\n\t\t\t// Update interface descriptor to current setting\n\t\t\tif (true == udc_update_iface_desc(iface_num, setting_num)) {\n\t\t\t\t// Forward SETUP request to UDI\n\t\t\t\tresult = udi_api->setup();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 39.59811474828666}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t//  uint8_t i;\n\n  // Initialize the CBW reception\n  udi_msc_cbw_init();\n\n  // Check if the MSC interface is enabled\n  if (!udi_msc_is_enabled()) {\n    // MSC interface not enabled\n    return false;\n  }\n\n  // Get the number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n  if (!udi_msc_nb_lun) {\n    // No LUN available\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (i = 0; i < udi_msc_nb_lun; i++) {\n    if (!mem_unload(i)) {\n      return false;\n    }\n  }\n\n  // Start the MSC process\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 46.47056832316815}, {"code": "bool udi_msc_enable(void){\n\t\tuint8_t i;\n\tuint8_t nb_lun;\n\tbool    ret;\n\n\t// Initialize the CBW reception\n\tudi_msc_cbw_init();\n\n\t// Get the number of LUNs\n\tnb_lun = get_nb_lun();\n\n\t// Check if LUNs are available\n\tif (nb_lun == 0) {\n\t\treturn false;\n\t}\n\n\t// Unload the medium\n\tfor (i = 0; i < nb_lun; i++) {\n\t\tif (!mem_unload(i)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Enable the MSC interface\n\tret = UDI_MSC_ENABLE_EXT();\n\tif (ret) {\n\t\t// Start the MSC process\n\t\tudi_msc_cbw_wait();\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 39.294171266517644}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED\nstatus\nnb_sent\nep\n\n  if (status == UDD_EP_TRANSFER_OK) {\n    // Data sent successfully\n    udi_msc_cbw.dCBWDataTransferLength -= nb_sent;\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    udi_msc_csw_process();\n  } else {\n    // Error while sending data\n    // Stall endpoint\n    udd_ep_set_halt(ep);\n    // Wait for a new CBW\n    while (1) {\n      if (udd_msc_setup_received()) {\n        // New CBW received\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 60.10022725034149}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED\nstatus\nnb_sent\nep\n\n  if (USB_ERR_OK != status) {\n    // Error\n    // Stall endpoint\n    if (udd_ep_dir(ep))\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    // Wait for a MSC setup reset\n    while (1) {\n      if (udd_msc_setup_received())\n        break;\n    }\n  } else {\n    // Data successfully sent\n    // Update CSW\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 60.88169242747276}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep)\n  if (status == UDD_EP_TRANSFER_OK) {\n    // Data successfully sent\n    udi_msc_cbw.dCBWDataTransferLength -= nb_sent;\n    udi_msc_cbw.dCBWLength -= nb_sent;\n    udi_msc_cbw.dCBWLength = cpu_to_le32(udi_msc_cbw.dCBWLength);\n    udi_msc_cbw.dCBWFlags &= ~USB_CBW_DIRECTION_MASK;\n    if (0 == udi_msc_cbw.dCBWDataTransferLength) {\n      // Data transfer completed\n      udi_msc_sense_pass();\n      udi_msc_csw_process();\n    }\n  } else {\n    // Error during data transfer\n    udi_msc_sense_pass();\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 48.243818677585374}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tif (udi_msc_cbw.data_residue) {\n\t\t// Stall the next request on the IN endpoint\n\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t}\n\t// Prepare the CSW\n\tudi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_csw.tag = udi_msc_cbw.tag;\n\tudi_msc_csw.data_residue = cpu_to_le32(udi_msc_cbw.data_residue);\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 51.21644373079548}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Check if there is a data residue\n\tif (udi_msc_cbw.data_len != 0) {\n\t\t// Stall the next request from the host on the appropriate endpoint based on the direction of the CBW\n\t\tif (udi_msc_cbw.flags & UDI_MSC_DIR_IN) {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t}\n\t\telse {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t}\n\t}\n\t// Prepare the CSW\n\tudi_msc_csw.tag = udi_msc_cbw.tag;\n\tudi_msc_csw.data_residue = cpu_to_le32(udi_msc_cbw.data_len);\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 60.28828570164128}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint16_t\ttmp;\n\n\t// Check if a data transfer is in progress\n\tif (udi_msc_cbw_data_len) {\n\t\t// Check the direction of the request\n\t\tif (udi_msc_cbw.bCBW_Flags & CBW_DIR_IN) {\n\t\t\t// IN transfer\n\t\t\t// Stall the next IN request\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t}\n\t\telse {\n\t\t\t// OUT transfer\n\t\t\t// Stall the next OUT request\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\n\t// Fill the CSW with the data residue\n\ttmp = udi_msc_cbw_data_len;\n\tudi_msc_csw.dCSWSignature = CSW_SIGNATURE;\n\tudi_msc_csw.bCSWStatus = CSW_STATUS_PASSED;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(tmp);\n\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 50.787717111363825}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_MAX_NUM_PORTS) {\n\t\treturn;\n\t}\n\tif (b_enable) {\n\t\tif (cdc_line_coding[port].dwDTERate == 1200) {\n\t\t\tif (!cdc_line_coding[port].bDTR) {\n\t\t\t\tcdc_line_coding[port].bDTR = true;\n\t\t\t\tif (!cdc_reset_scheduled[port]) {\n\t\t\t\t\tcdc_reset_scheduled[port] = true;\n\t\t\t\t\treset_controller_set(RESET_CONTROLLER_RESET);\n\t\t\t\t\tinitiateReset();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (cdc_line_coding[port].bDTR) {\n\t\t\t\tcdc_line_coding[port].bDTR = false;\n\t\t\t\tif (cdc_reset_scheduled[port]) {\n\t\t\t\t\tcdc_reset_scheduled[port] = false;\n\t\t\t\t\tcancelReset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cdc_line_coding[port].bDTR) {\n\t\t\tcdc_line_coding[port].bDTR = false;\n\t\t\tif (cdc_reset_scheduled[port]) {\n\t\t\t\tcdc_reset_scheduled[port] = false;\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.45632213063074}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_MAX_CDC_PORT) return;\n\tif (b_enable) {\n\t\tif (cdc_port[port].dtr_rate == 1200) {\n\t\t\tif (!cdc_port[port].b_dtr_enabled) {\n\t\t\t\tcancelReset();\n\t\t\t\tcdc_port[port].b_dtr_enabled = true;\n\t\t\t}\n\t\t} else {\n\t\t\tcdc_port[port].b_dtr_enabled = true;\n\t\t}\n\t} else {\n\t\tif (cdc_port[port].dtr_rate == 1200) {\n\t\t\tif (cdc_port[port].b_dtr_enabled) {\n\t\t\t\tcdc_port[port].b_dtr_enabled = false;\n\t\t\t\tif (cdc_port[port].dtr_rate == 1200) {\n\t\t\t\t\tinitiateReset();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcdc_port[port].b_dtr_enabled = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.366244650535144}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_NUM_CDC_PORTS) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\tif (usb_cdc_ports[port].b_dtr) {\n\t\t\treturn;\n\t\t}\n\n\t\tusb_cdc_ports[port].b_dtr = true;\n\n\t\tif (usb_cdc_ports[port].b_dtr_rate_1200) {\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tif (!usb_cdc_ports[port].b_dtr) {\n\t\t\treturn;\n\t\t}\n\n\t\tusb_cdc_ports[port].b_dtr = false;\n\n\t\tif (usb_cdc_ports[port].b_dtr_rate_1200) {\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.13633611495503}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t\tusb_setup_packet_t *setup_packet = (usb_setup_packet_t *) &usb_control_request_buffer[0];\n\tif (setup_packet->request_type == USB_SETUP_TYPE_VENDOR) {\n\t\tif (setup_packet->request == USB_REQUEST_MS_OS_DESCRIPTOR) {\n\t\t\tif (setup_packet->value == 0x0100) {\n\t\t\t\tusb_control_request_payload = (uint8_t *) &ms_os_20_descriptor[0];\n\t\t\t\tusb_control_request_length = sizeof(ms_os_20_descriptor);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 16.087116283055455}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 43.58391002658322}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tuint8_t i;\n\tuint8_t j;\n\n\t// Set the SPI to read mode\n\tSPCR = (1 << SPE) | (1 << MSTR);\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\t// Send a dummy byte to the SPI transmit data register\n\t\tSPDR = 0xFF;\n\n\t\t// Wait for a byte to be received\n\t\twhile (!(SPSR & (1 << SPIF)));\n\n\t\t// Store the received byte into the buffer\n\t\tbuf[i] = SPDR;\n\t}\n\n\t// Read the last byte using the \"spiRec\" function and store it in the buffer\n\tbuf[nbyte - 1] = spiRec();\n\n\t// Set the SPI to write mode\n\tSPCR = (1 << SPE) | (1 << MSTR) | (1 << CPOL) | (1 << CPHA);\n}", "CodeBleu_score": 44.46061390696455}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\twhile (nbyte--) {\n\t\tSPI_TDR = 0xFF;\n\t\twhile (!(SPI_SR & SPI_SR_RDRF))\n\t\t\t;\n\t\t*buf++ = SPI_RDR;\n\t}\n\t*buf = spiRec();\n}", "CodeBleu_score": 27.30169901478564}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t", "CodeBleu_score": 3.528701867557328}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tuint32_t *relocated_table_addr;\n\tuint32_t original_handler;\n\n\t// Get the address of the relocated interrupt vector table\n\trelocated_table_addr = get_relocated_table_addr();\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Get the original handler for the specified IRQ\n\toriginal_handler = relocated_table_addr[irq];\n\n\t// Replace the original handler with the new handler\n\trelocated_table_addr[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn (pfnISR_Handler)original_handler;\n}", "CodeBleu_score": 45.55297197226782}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *relocatedTableAddr;\n\tuint32_t oldInterruptStatus;\n\n\t/*\n\t * Get the address of the relocated interrupt vector table.\n\t */\n\trelocatedTableAddr = get_relocated_table_addr();\n\n\t/*\n\t * Disable global interrupts to ensure atomic operation.\n\t */\n\toldInterruptStatus = __get_PRIMASK();\n\t__disable_irq();\n\n\t/*\n\t * Get the current handler for the specified IRQ.\n\t */\n\toldHandler = (pfnISR_Handler) relocatedTableAddr[irq];\n\n\t/*\n\t * Replace the current handler with the new handler.\n\t */\n\trelocatedTableAddr[irq] = (uint32_t) newHandler;\n\n\t/*\n\t * Re-enable global interrupts.\n\t */\n\t__set_PRIMASK(oldInterruptStatus);\n\n\t/*\n\t * Return the original ISR handler.\n\t */\n\treturn oldHandler;\n}", "CodeBleu_score": 47.72642283769773}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\t// Check if there is a character available in the USB buffer\n\tif (udi_cdc_is_rx_ready()) {\n\t\t// If there is a character available, read it and return it\n\t\treturn (int)udi_cdc_getc();\n\t}\n\t// If there is no character available, return -1\n\treturn -1;\n}", "CodeBleu_score": 8.617220708302845}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_task_cdc_isenabled()) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\treturn udi_cdc_getc();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 10.104863096714118}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.enabled) {\n    if (emergency_parser.peek()) return emergency_parser.last_char;\n  }\n#endif\n\n  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      return udi_cdc_getc();\n    }\n  }\n\n  return -1;\n}", "CodeBleu_score": 31.622929149868018}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\t// If a character is available, return it\n\tif (m_rx_buffer.count()) {\n\t\treturn m_rx_buffer.pop_front();\n\t}\n\t// If USB CDC is enabled and configured, return -1\n\tif (!usb_task_cdc_isenabled()) {\n\t\treturn -1;\n\t}\n\t// If there are bytes available to read from the PC, return -1\n\tif (!udi_cdc_is_rx_ready()) {\n\t\treturn -1;\n\t}\n\t// Read a character from the PC\n\tuint8_t c;\n\tudi_cdc_getc(&c);\n\t// Update the emergency parser if enabled\n\tif (m_emergency_parser.enabled) {\n\t\tm_emergency_parser.update(c);\n\t}\n\treturn c;\n}", "CodeBleu_score": 41.227530651744345}, {"code": "int MarlinSerialUSB::read(){\n\t\t// Return a pending character if available\n\tif (rx_buffer_head != rx_buffer_tail) {\n\t\tint c = rx_buffer[rx_buffer_tail];\n\t\trx_buffer_tail = (rx_buffer_tail + 1) & (RX_BUFFER_SIZE - 1);\n\t\treturn c;\n\t}\n\n\t// Return -1 if USB CDC is not enabled\n\tif (!usb_task_cdc_isenabled()) return -1;\n\n\t// Return -1 if no bytes available\n\tif (!udi_cdc_is_rx_ready()) return -1;\n\n\t// Read a byte\n\tint c = udi_cdc_getc();\n\n\t// Update the emergency parser\n\tif (emergency_parser.enabled) emergency_parser.update(c);\n\n\treturn c;\n}", "CodeBleu_score": 58.643378450061}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (m_rx_buffer_head != m_rx_buffer_tail) {\n\t\t// Return a character from the receive buffer\n\t\tint c = m_rx_buffer[m_rx_buffer_tail];\n\t\tm_rx_buffer_tail = (m_rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n\t\treturn c;\n\t}\n\telse if (m_enabled && m_configured) {\n\t\t// Check if there is a character available to read from the PC\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\t// Read a character from the PC\n\t\t\tint c = udi_cdc_getc();\n\t\t\tif (m_emergency_parser.enabled) {\n\t\t\t\tm_emergency_parser.update(c);\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 44.37231386941624}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (cdc_rx_count) {\n\t\treturn cdc_rx_count;\n\t}\n\tif (cdc_rx_enabled && cdc_rx_ready) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 30.445700912133724}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (MarlinSerial::available()) return 1;\n\tif (usb_cdc_is_rx_ready()) return 1;\n\treturn 0;\n}", "CodeBleu_score": 35.119633523002655}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (m_cdc_rx_buffer_head != m_cdc_rx_buffer_tail) {\n\t\treturn (m_cdc_rx_buffer_head - m_cdc_rx_buffer_tail);\n\t}\n\telse if (m_cdc_enabled && usb_cdc_is_rx_ready()) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 34.07453300132445}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n}", "CodeBleu_score": 7.532854251021931}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint8_t *p = value;\n\twhile (size--) {\n\t\tif (writing) {\n\t\t\t*p = ee_Read(pos);\n\t\t\tcrc16(crc, p, 1);\n\t\t}\n\t\telse {\n\t\t\t*crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)ee_Read(pos)) << 8));\n\t\t\tfor (uint8_t i = 0; i < 8; i++)\n\t\t\t\t*crc = (uint16_t)((*crc & 0x8000) ? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n\t\t}\n\t\tpos++;\n\t\tp++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 46.403125433083936}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n}", "CodeBleu_score": 7.532854251021931}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (value > 255) value = 255;\n\tif (value == 0) {\n\t\tdigitalWrite(pin, LOW);\n\t\treturn;\n\t}\n\tif (value == 255) {\n\t\tdigitalWrite(pin, HIGH);\n\t\treturn;\n\t}\n\tif (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n\t\tint8_t cid = get_pwm_channel(pin, freq, res);\n\t\tif (cid >= 0) {\n\t\t\tledcWrite(cid, value);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (WITHIN(pin, 1, MAX_IOPIN)) {\n\t\tpin_state_t *ps = &pinState[pin];\n\t\tif (ps->mode == PIN_PWM) {\n\t\t\tps->pwm.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n\tpinMode(pin, OUTPUT);\n\tpinState[pin].mode = PIN_PWM;\n\tpinState[pin].pwm.value = value;\n\tpinState[pin].pwm.next = 0;\n\tpinState[pin].pwm.timer = NULL;\n\tpinState[pin].pwm.period = 0;\n\tpinState[pin].pwm.count = 0;\n\tif (pinState[pin].pwm.timer == NULL) {\n\t\tpinState[pin].pwm.timer = timerBegin(0, 80, true);\n\t\ttimerAttachInterrupt(pinState[pin].pwm.timer, &pwm_timer_isr, true);\n\t\ttimerAlarmWrite(pinState[pin].pwm.timer, 1000, true);\n\t\ttimerAlarmEnable(pinState[pin].pwm.timer);\n\t}\n}", "CodeBleu_score": 45.35662602221454}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (value > 0) {\n\t\tuint8_t pwm_channel = get_pwm_channel(pin, freq, res);\n\t\tif (pwm_channel >= 0) {\n\t\t\tledcWrite(pwm_channel, value);\n\t\t}\n\t\telse {\n\t\t\t// Software PWM\n\t\t\tuint8_t i = pwm_index_for_pin(pin);\n\t\t\tif (i >= NUM_PWM_PINS) {\n\t\t\t\t// No software PWM state for this pin, so allocate a new one\n\t\t\t\tfor (i = 0; i < NUM_PWM_PINS; i++) {\n\t\t\t\t\tif (pwm_pin[i] == 0) {\n\t\t\t\t\t\tpwm_pin[i] = pin;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < NUM_PWM_PINS) {\n\t\t\t\t// Set the new PWM value\n\t\t\t\tpwm_value[i] = value;\n\t\t\t\t// Start the timer if it is not already running\n\t\t\t\tif (pwm_timer_running == false) {\n\t\t\t\t\tpwm_timer_running = true;\n\t\t\t\t\tHAL_timer_start(TIMER_PWM);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tanalogWrite(pin, 0);\n\t}\n}", "CodeBleu_score": 43.884593559377834}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#ifdef WITH_PWM\n  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n#endif\n\n  // Software PWM\n  uint8_t i = pwm_for_pin(pin);\n  if (i == 0) {\n    // Allocate new software PWM state\n    for (i = 0; i < MAX_PWM_PINS; i++) {\n      if (pwm_pin[i] == 0) {\n        pwm_pin[i] = pin;\n        pwm_value[i] = 0;\n        pwm_freq[i] = freq;\n        pwm_res[i] = res;\n        pwm_count++;\n        if (pwm_count == 1) {\n          // Start PWM timer if this is the first pin\n          HAL_timer_start(TIMER_PWM, TIMER_PWM_FREQ, TIMER_PWM_RES);\n        }\n        break;\n      }\n    }\n  }\n  if (i < MAX_PWM_PINS) {\n    pwm_value[i] = value;\n    pwm_freq[i] = freq;\n    pwm_res[i] = res;\n  }\n}", "CodeBleu_score": 55.31386235123518}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#ifdef SERVO_DELAY_ARRAY_LENGTH\n  static_assert(SERVO_DELAY_ARRAY_LENGTH > 0, \"SERVO_DELAY_ARRAY_LENGTH must be greater than zero\");\n#endif\n\n  if (channel < 0) {\n    attach();\n  }\n  write(value);\n  safe_delay(SERVO_DELAY_ARRAY_ARRAY[channel]);\n  if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n    detach();\n  }\n}", "CodeBleu_score": 48.41129560466113}, {"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH < SERVO_CHANNELS\n  static_assert(false, \"SERVO_DELAY_ARRAY_LENGTH must be >= SERVO_CHANNELS\");\n#endif\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 50.90421963828477}, {"code": "void Servo::move(const int value){\n\t#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n  write(value);\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n  delay(servo_delay[channel]);\n  attach();\n#endif\n}", "CodeBleu_score": 40.08669447892169}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}, {"code": "void i2s_push_sample(){\n\t\t// Update the PWM states for each pin\n\tfor (uint8_t i = 0; i < NUM_PINS; i++) {\n\t\tif (pins[i].duty_cycle > 0) {\n\t\t\tpins[i].tick_count--;\n\t\t\tif (pins[i].tick_count == 0) {\n\t\t\t\tpins[i].tick_count = pins[i].duty_cycle;\n\t\t\t\tif (pins[i].state == HIGH) {\n\t\t\t\t\tpins[i].state = LOW;\n\t\t\t\t} else {\n\t\t\t\t\tpins[i].state = HIGH;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Write the resulting data to the DMA buffer\n\tfor (uint8_t i = 0; i < NUM_PINS; i++) {\n\t\tuint8_t pin_state = (pins[i].state == HIGH) ? 0xFF : 0x00;\n\t\tuint8_t pin_data = (pin_state << pins[i].pin_num) & 0xFF;\n\t\tuint8_t pin_mask = (1 << pins[i].pin_num);\n\t\tuint8_t *buffer_ptr = (uint8_t *)DMA_BUFFER_ADDR;\n\t\tbuffer_ptr[DMA_BUFFER_POS] = (buffer_ptr[DMA_BUFFER_POS] & ~pin_mask) | pin_data;\n\t\tDMA_BUFFER_POS++;\n\t\tif (DMA_BUFFER_POS >= DMA_BUFFER_SIZE) {\n\t\t\tDMA_BUFFER_POS = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 31.831394979759754}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn HAL_timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.888117861936223}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn HAL_timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.888117861936223}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn HAL_timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.888117861936223}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t#ifdef DEBUG_EEPROM\n  Serial.print(F(\"Reading data from EEPROM at position \"));\n  Serial.println(pos);\n#endif\n  for (size_t i = 0; i < size; i++) {\n    value[i] = EEPROM.read(pos);\n    if (writing)\n      buffer[i] = value[i];\n    if (crc)\n      *crc = (uint16_t)(*crc ^ (uint16_t)(value[i] << 8));\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 53.207880355437844}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (pos < 0) {\n\t\treturn false;\n\t}\n\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos);\n\t\tif (writing) {\n\t\t\t*crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)value[i]) << 8));\n\t\t}\n\t\tpos++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 54.215146861198434}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t#ifdef ARDUINO_ARCH_ESP8266\n  uint16_t crc_local = 0;\n#else\n  uint16_t crc_local = *crc;\n#endif\n  uint8_t *ptr = (uint8_t *)value;\n  while (size--) {\n    uint8_t data = EEPROM.read(pos);\n    if (writing) *ptr++ = data;\n    crc_local = (uint16_t)(crc_local ^ (uint16_t)(data << 8));\n    for (uint8_t i = 0; i < 8; i++)\n      crc_local = (uint16_t)((*crc_local & 0x8000) ? ((uint16_t)(crc_local << 1) ^ 0x1021) : (crc_local << 1));\n    pos++;\n  }\n#ifdef ARDUINO_ARCH_ESP8266\n  *crc = crc_local;\n#else\n  *crc = crc_local ^ 0xFFFF;\n#endif\n  return false;\n}", "CodeBleu_score": 42.140212198554835}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t", "CodeBleu_score": 3.4428888816077743}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (sdio_handle == NULL) {\n\t\tprintf(\"SD card not initialized!\\r\n\");\n\t\treturn false;\n\t}\n\tif (src == NULL) {\n\t\tprintf(\"Source pointer is NULL!\\r\n\");\n\t\treturn false;\n\t}\n\tuint32_t retry = 0;\n\twhile (retry < 10) {\n\t\tif (SDCARD_WriteBlocks(sdio_handle, block, src, 1) == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tretry++;\n\t}\n\tprintf(\"Failed to write block %d!\\r\n\", block);\n\treturn false;\n}", "CodeBleu_score": 35.938099332731085}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tSD_Error status;\n\tuint32_t timeout = 0;\n\tSD_HandleTypeDef sdHandle;\n\tif ((NULL == src) || (NULL == hsd)) {\n\t\treturn false;\n\t}\n\tsdHandle = *hsd;\n\tstatus = SD_WriteBlock(&sdHandle, src, block, 5000);\n\twhile ((status != SD_OK) && (timeout < 5000)) {\n\t\tstatus = SD_WriteBlock(&sdHandle, src, block, 5000);\n\t\ttimeout++;\n\t}\n\tif (SD_OK == status) {\n\t\treturn true;\n\t} else {\n\t\tprintf(\"SD write error: %d\n\", status);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.26127306633448}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t", "CodeBleu_score": 2.9267475901190156}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_CHANNEL_TEMP) {\n\t\ttimer_num->setPrescaleValue(TEMPERATURE_TIMER_PRESCALE);\n\t\ttimer_num->setMode(TIMER_MODE_PERIODIC);\n\t\ttimer_num->setPeriod(1000000 / frequency);\n\t\ttimer_num->setCallback(temperatureTimerCallback);\n\t\ttimer_num->setCallbackPriority(TEMPERATURE_TIMER_PRIORITY);\n\t\ttimer_num->start();\n\t} else if (timer_num == TIMER_CHANNEL_STEP) {\n\t\ttimer_num->setPrescaleValue(STEPPER_TIMER_PRESCALE);\n\t\ttimer_num->setMode(TIMER_MODE_PERIODIC);\n\t\ttimer_num->setPeriod(1000000 / frequency);\n\t\ttimer_num->setCallback(stepTimerCallback);\n\t\ttimer_num->setCallbackPriority(STEPPER_TIMER_PRIORITY);\n\t\ttimer_num->start();\n\t} else {\n\t\tCORE_ASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 47.20894581844139}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t", "CodeBleu_score": 2.9267475901190156}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tif (this->is_initialized) {\n\t\treturn true;\n\t}\n\tif (this->file_handle != NULL) {\n\t\tfclose(this->file_handle);\n\t}\n\tthis->file_handle = fopen(this->file_name, \"r+b\");\n\tif (this->file_handle == NULL) {\n\t\treturn false;\n\t}\n\tthis->file_size = fseek(this->file_handle, 0, SEEK_END);\n\tif (this->file_size < this->eeprom_size) {\n\t\tthis->file_size = fseek(this->file_handle, 0, SEEK_SET);\n\t\tmemset(this->eeprom_buffer, this->erase_value, this->eeprom_size);\n\t\tfwrite(this->eeprom_buffer, this->eeprom_size, 1, this->file_handle);\n\t\tthis->file_size = fseek(this->file_handle, 0, SEEK_END);\n\t} else {\n\t\tthis->file_size = fseek(this->file_handle, 0, SEEK_SET);\n\t\tfread(this->eeprom_buffer, this->eeprom_size, 1, this->file_handle);\n\t}\n\tfclose(this->file_handle);\n\tthis->file_handle = NULL;\n\tthis->is_initialized = true;\n\treturn true;\n}", "CodeBleu_score": 25.01046514541146}, {"code": "bool PersistentStore::access_start(){\n\t\tif (this->file_handle != NULL) {\n\t\treturn false;\n\t}\n\tthis->file_handle = fopen(this->file_name, \"r+b\");\n\tif (this->file_handle == NULL) {\n\t\treturn false;\n\t}\n\tthis->file_size = fseek(this->file_handle, 0, SEEK_END);\n\tif (this->file_size < 0) {\n\t\treturn false;\n\t}\n\tif (this->file_size < this->eeprom_size) {\n\t\tfseek(this->file_handle, 0, SEEK_SET);\n\t\tmemset(this->eeprom_buffer, this->erase_value, this->eeprom_size);\n\t\tfwrite(this->eeprom_buffer, 1, this->eeprom_size, this->file_handle);\n\t} else {\n\t\tfseek(this->file_handle, 0, SEEK_SET);\n\t\tfread(this->eeprom_buffer, 1, this->eeprom_size, this->file_handle);\n\t}\n\treturn true;\n}", "CodeBleu_score": 19.616709136561443}, {"code": "bool PersistentStore::access_start(){\n\t\tif (file_open) {\n\t\treturn false;\n\t}\n\tfile_open = true;\n\tfile = fopen(file_name, \"r+b\");\n\tif (file == NULL) {\n\t\tfile = fopen(file_name, \"w+b\");\n\t\tif (file == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tmemset(buffer, erase_value, sizeof(buffer));\n\t} else {\n\t\tfseek(file, 0, SEEK_END);\n\t\tfile_size = ftell(file);\n\t\tif (file_size < sizeof(buffer)) {\n\t\t\tfseek(file, 0, SEEK_SET);\n\t\t\tmemset(buffer, erase_value, sizeof(buffer));\n\t\t} else {\n\t\t\tfseek(file, 0, SEEK_SET);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.22519887033674}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t r = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tHAL_Delay(SPI_DELAY_NS / 1000);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tHAL_Delay(SPI_DELAY_NS / 1000);\n\t\tr <<= 1;\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin)) {\n\t\t\tr |= 0x01;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(SPI_DELAY_NS / 1000);\n\treturn r;\n}", "CodeBleu_score": 35.80361433818363}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t data = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_RESET);\n\t\tHAL_Delay(DELAY_NS);\n\t\tHAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_SET);\n\t\tHAL_Delay(DELAY_NS);\n\t\tif (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin)) {\n\t\t\tdata |= 1;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(DELAY_NS);\n\treturn data;\n}", "CodeBleu_score": 37.187765573300965}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t r = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI1_NSS_GPIO_Port, SPI1_NSS_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, b & 0x80);\n\t\tb <<= 1;\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_RESET);\n\t\tr <<= 1;\n\t\tif (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin)) {\n\t\t\tr |= 1;\n\t\t}\n\t}\n\tHAL_Delay(SPI_DELAY_MS);\n\treturn r;\n}", "CodeBleu_score": 38.543189072066276}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 83.96887672648454}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\t/* The clock is disabled */\n\tif (NewState == DISABLE) {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n\t/* The clock is enabled */\n\telse {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 79.68413482331852}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 83.96887672648454}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tMSerialT *self = static_cast<MSerialT*>(obj);\n\tuint8_t c = self->uart->read();\n\tif (c == self->emergency_parser.update(c)) {\n\t\tif (self->rx_buffer.space_available()) {\n\t\t\tself->rx_buffer.store_char(c);\n\t\t\tself->rx_buffer.advance_head();\n\t\t}\n\t}\n}", "CodeBleu_score": 31.057167975268474}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t", "CodeBleu_score": 2.355873403718772}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t#if ENABLED(EMERGENCY_PARSER)\n  emergency_parser.update(obj->rx_buffer[obj->rx_buffer_head]);\n#endif\n  if (obj->rx_buffer_head == (obj->rx_buffer_tail + SERIAL_BUFFER_SIZE - 1)) {\n    obj->rx_buffer_head = 0;\n  }\n  else {\n    obj->rx_buffer_head++;\n  }\n}", "CodeBleu_score": 32.04400010740097}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num] != NULL && !timer_instance[timer_num]->hasInterrupt) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 55.36356737576439}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->hasInterrupt) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t}\n\t\telse if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 60.15219040538867}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (HAL_timer_initialized[timer_num] && !timer_instance[timer_num]->hasInterrupt) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 56.993333742979566}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\thashsep, pow := HashStrRev(sep)\n\tvar hash uint32\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\thash = hash*PrimeRK + uint32(s[i])\n\t\tif hash == hashsep && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 39.40560906307803}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\thashsep, pow := HashStrRev(sep)\n\th := HashStrRev(s[:len(s)-len(sep)])\n\tif h == hashsep && s[len(s)-len(sep):] == sep {\n\t\treturn len(s) - len(sep)\n\t}\n\tfor i := len(s) - len(sep) - 1; i >= 0; i-- {\n\t\th = h*PrimeRK - pow*uint32(s[i])\n\t\th += uint32(s[i+len(sep)])\n\t\tif h == hashsep && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 47.35868855702678}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\thsep, pow := HashStrRev(sep)\n\tn := len(s)\n\tm := len(sep)\n\tvar i, j int\n\tfor i = n - m; i >= 0; i-- {\n\t\tif s[i] == sep[0] {\n\t\t\tfor j = 1; j < m; j++ {\n\t\t\t\tif s[i+j] != sep[j] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif j == m {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\tif i > 0 {\n\t\t\th := hsep\n\t\t\tfor j = 0; j < m; j++ {\n\t\t\t\th += uint32(s[i+j]) * pow\n\t\t\t\th -= uint32(s[i+j-m]) * pow\n\t\t\t\th *= PrimeRK\n\t\t\t}\n\t\t\tif h == 0 {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 44.274169935078234}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.txBuffer.DisableInterrupts()\n\tif usbcdc.txBuffer.GetLen() > 0 {\n\t\tusbcdc.txBuffer.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tusbcdc.txBuffer.RestoreInterrupts()\n}", "CodeBleu_score": 41.07118731424725}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tinterrupt.Disable()\n\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.GetLen() > 0 {\n\t\t// Send the data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// There is no data in the transmit buffer, so we can wait for a USB IN packet\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore interrupts\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.20879098452254}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.GetLen() > 0 {\n\t\tusbcdc.txBuffer.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.43066102903291}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.HasBits(i2c.crReg.START))\n\ti2c.crReg.SetBits(i2c.crReg.START)\n\ti2c.writeByte(address<<1 | uint8(write))\n}", "CodeBleu_score": 32.75554372007352}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(0)\n\ti2c.crReg.Set(I2C_CR_START)\n\ti2c.crReg.Set(I2C_CR_SWRST)\n\ti2c.crReg.Set(I2C_CR_EN)\n\tfor !i2c.crReg.HasBits(I2C_CR_START) {\n\t}\n\ti2c.crReg.Set(I2C_CR_START)\n\tif write {\n\t\ti2c.crReg.Set(I2C_CR_TXMODE)\n\t} else {\n\t\ti2c.crReg.Set(I2C_CR_RXMODE)\n\t}\n\ti2c.writeByte(address << 1)\n}", "CodeBleu_score": 31.73068415658726}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear interrupt flag\n\ti2c.crReg.SetBits(I2C_CR_INT)\n\n\t// Set start condition\n\ti2c.crReg.SetBits(I2C_CR_STA)\n\n\t// Enable I2C module\n\ti2c.crReg.SetBits(I2C_CR_EN)\n\n\t// Wait for start condition to be transmitted\n\tfor i2c.crReg.HasBits(I2C_CR_STA) {\n\t}\n\n\t// Send 7-bit shifted peripheral address\n\tif write {\n\t\ti2c.writeByte(address << 1)\n\t} else {\n\t\ti2c.writeByte((address << 1) | 1)\n\t}\n}", "CodeBleu_score": 36.7304404240967}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address of the block to erase.\n\tstartAddress := uint32(start * f.EraseBlockSize)\n\t// Check if the flash is busy.\n\tif f.IsBusy() {\n\t\treturn errors.New(\"flash is busy\")\n\t}\n\t// Configure the flash for erasing.\n\tf.SetErase()\n\t// Erase each block.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Wait for any ongoing flash operations to complete.\n\t\twaitWhileFlashBusy()\n\t\t// Erase the block.\n\t\tf.ErasePage(startAddress)\n\t\t// Wait until the flash is no longer busy.\n\t\twaitWhileFlashBusy()\n\t\t// Increment the start address.\n\t\tstartAddress += f.EraseBlockSize\n\t}\n\t// Set the flash back to read mode.\n\tf.SetRead()\n\t// Return successfully.\n\treturn nil\n}", "CodeBleu_score": 34.23614350028689}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := start * f.EraseBlockSize\n\tendAddr := startAddr + (len * f.EraseBlockSize)\n\tif startAddr >= endAddr {\n\t\treturn fmt.Errorf(\"invalid block erase range: %d-%d\", start, len)\n\t}\n\tif err := f.EraseBlock(start); err != nil {\n\t\treturn err\n\t}\n\tfor i := start + 1; i < start+len; i++ {\n\t\tif err := f.EraseBlock(i); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.97619090458021}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t", "CodeBleu_score": 1.6190016653733672}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 {\nreturn 0, errors.New(\"invalid offset\")\n}\nif uint64(off) >= f.Size() {\nreturn 0, errors.New(\"offset exceeds flash size\")\n}\nif uint64(len(p)) > f.WriteBlockSize() {\nreturn 0, errors.New(\"write exceeds block size\")\n}\n// Pad the data to fit the write block size.\np = append(p, make([]byte, f.WriteBlockSize()-len(p))...)\n// Calculate the start address for writing.\nstartAddr := uint32(off)\n// Enable write mode.\nerr = nrf.NVMC.SetCONFIG_WEN(nrf.NVMC.CONFIG_WEN_WEN)\nif err != nil {\nreturn 0, err\n}\n// Write the data in blocks.\nfor len(p) > 0 {\n// Calculate the number of bytes to write.\nif uint32(len(p)) > f.WriteBlockSize() {\nn = f.WriteBlockSize()\n} else {\nn = len(p)\n}\n// Write the data.\nerr = nrf.NVMC.EraseWrite(startAddr, p[:n])\nif err != nil {\nreturn 0, err\n}\n// Wait for the flash memory to be ready.\nerr = nrf.NVMC.WaitReady()\nif err != nil {\nreturn 0, err\n}\n// Update the byte slice and offset.\np = p[n:]\nstartAddr += uint32(n)\noff += int64(n)\n}\n// Disable write mode.\nerr = nrf.NVMC.SetCONFIG_WEN(nrf.NVMC.CONFIG_WEN_Ren)\nif err != nil {\nreturn 0, err\n}\nreturn len(p), nil\n}", "CodeBleu_score": 36.0752073108807}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 {\nreturn 0, errors.New(\"invalid offset\")\n}\nif uint64(off) > f.Size() {\nreturn 0, errors.New(\"offset out of bounds\")\n}\nif uint64(len(p)) > f.Size() {\nreturn 0, errors.New(\"write exceeds block size\")\n}\naddr := uint32(off)\nif addr%f.WriteBlockSize() != 0 {\naddr += f.WriteBlockSize() - (addr % f.WriteBlockSize())\n}\nif addr+uint32(len(p)) > f.Size() {\np = p[:f.Size()-addr]\n}\nf.NVMC.SetCONFIG_WEN(true)\ndefer f.NVMC.SetCONFIG_WEN(false)\nfor len(p) > 0 {\nf.NVMC.SetADDR(addr)\nwaitWhileFlashBusy\nint\nlen\nbinary.LittleEndian.Uint32\n(*uint32)\nf.WriteBlockSize\nuintptr\nunsafe.Pointer\nf.pad\nf.NVMC.SetERASE(true)\nwaitWhileFlashBusy\nint\nlen\nbinary.LittleEndian.Uint32\n(*uint32)\nf.WriteBlockSize\nuintptr\nunsafe.Pointer\nf.pad\nf.NVMC.SetERASE(false)\nwaitWhileFlashBusy\nint\nlen\nbinary.LittleEndian.Uint32\n(*uint32)\nf.WriteBlockSize\nuintptr\nunsafe.Pointer\nf.pad\nf.NVMC.SetCONFIG_WEN(true)\nwaitWhileFlashBusy\nint\nlen\nbinary.LittleEndian.Uint32\n(*uint32)\nf.WriteBlockSize\nuintptr\nunsafe.Pointer\nf.pad\nf.NVMC.SetCONFIG_WEN(false)\nwaitWhileFlashBusy\nint\nlen\nbinary.LittleEndian.Uint32\n(*uint32)\nf.WriteBlockSize\nuintptr\nunsafe.Pointer\nf.pad\nreturn len(p), nil\n}\nreturn 0, nil\n}", "CodeBleu_score": 33.37986939578603}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 {\nreturn 0, errors.New(\"can't write to negative offset\")\n}\nif off >= f.Size() {\nreturn 0, io.EOF\n}\nif uint64(off)+uint64(len(p)) > f.Size() {\nreturn 0, io.EOF\n}\nif len(p) == 0 {\nreturn 0, nil\n}\n// Check if the write operation exceeds the flash memory bounds.\nif uint64(off)+uint64(len(p)) > f.Size() {\nreturn 0, io.EOF\n}\n// Calculate the start address for writing.\naddr := uint32(off)\n// Pad the byte slice to fit the write block size.\np = f.pad(p)\n// Enable write mode on the flash memory controller.\nif err = nrf.NVMC.SetCONFIG_WEN(true); err != nil {\nreturn 0, err\n}\n// Write the data in blocks.\nfor len(p) > 0 {\n// Calculate the block size.\nblockSize := uint32(len(p))\nif blockSize > f.WriteBlockSize() {\nblockSize = f.WriteBlockSize()\n}\n// Write the data in the block.\nif err = f.writeBlock(addr, p[:blockSize]); err != nil {\nreturn 0, err\n}\n// Update the data slice.\np = p[blockSize:]\n// Update the address.\naddr += blockSize\n}\n// Wait for the flash memory to be ready after each write operation.\nif err = f.waitWhileFlashBusy(); err != nil {\nreturn 0, err\n}\n// Disable write mode on the flash memory controller.\nif err = nrf.NVMC.SetCONFIG_WEN(false); err != nil {\nreturn 0, err\n}\n// Return the number of bytes written.\nreturn len(p), nil\n}", "CodeBleu_score": 37.794225392994825}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tfdDup, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Check for errors.\n\tif fdDup < 0 {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to duplicate file descriptor: %s\", err)\n\t}\n\t// Open the directory.\n\tdirp, err := syscall.Fdopendir(fdDup)\n\tif err != nil {\n\t\t// If the error is \"syscall.EINTR\", try again.\n\t\tif err == syscall.EINTR {\n\t\t\tdirp, err = syscall.Fdopendir(fdDup)\n\t\t}\n\t\t// If the error is \"syscall.EINVAL\", close the file descriptor and return the error.\n\t\tif err == syscall.EINVAL {\n\t\t\tsyscall.Close(fdDup)\n\t\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %s\", err)\n\t\t}\n\t\t// Otherwise, return the error.\n\t\treturn 0, \"\", err\n\t}\n\t// Otherwise, return the directory pointer.\n\treturn dirp, \"\", nil\n}", "CodeBleu_score": 58.87208684246148}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor\n\tfdDup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"unable to duplicate file descriptor: %s\", err)\n\t}\n\tdefer syscall.Close(fdDup)\n\n\t// Attempt to open the directory\n\tdir, err := syscall.Fdopendir(fdDup)\n\tif err == nil {\n\t\treturn dir, \"\", nil\n\t}\n\n\t// If the error was \"EINTR\", attempt to open the directory again\n\tif err == syscall.EINTR {\n\t\tdir, err = syscall.Fdopendir(fdDup)\n\t\tif err == nil {\n\t\t\treturn dir, \"\", nil\n\t\t}\n\t}\n\n\treturn 0, \"\", fmt.Errorf(\"unable to open directory: %s\", err)\n}", "CodeBleu_score": 52.033211181991554}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor and check for errors.\n\tfdDup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(fdDup)\n\tif fdDup < 0 {\n\t\treturn 0, \"\", syscall.EIO\n\t}\n\n\t// Repeatedly attempt to open the directory until it succeeds or an error occurs other than \"syscall.EINTR\".\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fdDup)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 70.67365786258655}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t desc;\n\tesp_err_t err = esp_app_desc_get_by_offs(&desc, 0);\n\tif (err != ESP_OK) {\n\t\treturn 0;\n\t}\n\tif (response) {\n\t\treturn desc.sketch_size - desc.sketch_head;\n\t} else {\n\t\treturn desc.sketch_size;\n\t}\n}", "CodeBleu_score": 35.741828509038385}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tconst esp_partition_t *boot = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, NULL);\n\tesp_image_metadata_t metadata;\n\tesp_image_metadata_load(running, &metadata);\n\tuint32_t sketch_size = metadata.image_size;\n\tif (response) {\n\t\treturn running->size - sketch_size;\n\t} else {\n\t\treturn sketch_size;\n\t}\n}", "CodeBleu_score": 46.015157421988626}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tconst esp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, running->label);\n\tif (!partition) {\n\t\treturn 0;\n\t}\n\tif (response) {\n\t\treturn esp_partition_get_size(partition) - esp_partition_get_offset(partition);\n\t}\n\treturn esp_partition_get_size(partition);\n}", "CodeBleu_score": 42.83197924890286}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t#define MSC_BUF_SIZE 1024\n  static uint8_t msc_buf[MSC_BUF_SIZE];\n  uint8_t *buf = msc_buf;\n  uint8_t *buf_end = msc_buf + sizeof(msc_buf);\n  uint32_t buf_size = 0;\n  uint32_t total_sectors;\n  uint32_t fat_flags = 0;\n  bool ret = false;\n\n  total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors == 0) {\n    log_e(\"No free space for MSC update\");\n    return false;\n  }\n\n  /* Allocate memory for the disk */\n  buf_size = total_sectors * DISK_SECTOR_SIZE;\n  buf = calloc(buf_size);\n  if (!buf) {\n    log_e(\"Failed to allocate %u bytes for MSC disk\", buf_size);\n    return false;\n  }\n  buf_end = buf + buf_size;\n\n  /* Set up the boot sector */\n  if (!fat_add_boot_sector(buf, buf_end, volume_label, serial_number)) {\n    log_e(\"Failed to add boot sector\");\n    goto fail;\n  }\n\n  /* Set up the file allocation table */\n  if (!fat_add_table(buf, buf_end, total_sectors, fat_flags)) {\n    log_e(\"Failed to add file allocation table\");\n    goto fail;\n  }\n\n  /* Add a root directory entry for the running partition */\n  if (msc_run_partition) {\n    if (!fat_add_root_file(buf, buf_end, msc_run_partition->label, msc_run_partition->label_len, msc_run_partition->size)) {\n      log_e(\"Failed to add root directory entry\");\n      goto fail;\n    }\n  }\n\n  /* Setup the MSC device */\n  if (!msc_disk_init(buf, total_sectors, DISK_SECTOR_SIZE)) {\n    log_e(\"Failed to initialize MSC disk\");\n    goto fail;\n  }\n\n  ret = true;\n\nfail:\n  if (buf != msc_buf) {\n    free(buf);\n  }\n  return ret;\n}", "CodeBleu_score": 47.99286520504982}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint8_t *disk_data = NULL;\n\tsize_t disk_sectors = msc_update_get_required_disk_sectors();\n\tif (disk_sectors == 0) {\n\t\tlog_e(\"Failed to get required disk sectors\");\n\t\treturn false;\n\t}\n\tdisk_data = calloc(disk_sectors, DISK_SECTOR_SIZE);\n\tif (!disk_data) {\n\t\tlog_e(\"Failed to allocate memory for disk data\");\n\t\treturn false;\n\t}\n\tmsc_update_init_disk(disk_data, disk_sectors, volume_label, serial_number);\n\tif (msc_run_partition) {\n\t\tlog_d(\"Adding APP file\");\n\t\tif (!fat_add_root_file(msc_run_partition, disk_data)) {\n\t\t\tlog_e(\"Failed to add APP file\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (msc_ota_partition) {\n\t\tlog_d(\"Adding OTA file\");\n\t\tif (!fat_add_root_file(msc_ota_partition, disk_data)) {\n\t\t\tlog_e(\"Failed to add OTA file\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 38.25383675874551}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % partition->sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%08x is not aligned with the sector size 0x%08x\", offset, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % partition->sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Size 0x%08x is not aligned with the sector size 0x%08x\", size, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\tESP_LOGD(TAG, \"Updating partition %s, pos 0x%08x, size 0x%08x\", partition->label, offset, size);\n\terr = esp_partition_erase_range(partition, offset, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase partition %s at offset 0x%08x, size 0x%08x\", partition->label, offset, size);\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write partition %s at offset 0x%08x, size 0x%08x\", partition->label, offset, size);\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 51.60957712459706}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % SPI_FLASH_SEC_SIZE != 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not sector aligned!\", offset);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % SPI_FLASH_SEC_SIZE != 0) {\n\t\tESP_LOGE(TAG, \"Size 0x%x is not sector aligned!\", size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\tif (size == 0) {\n\t\treturn ESP_OK;\n\t}\n\terr = msc_erase_sector(partition, offset, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector at offset 0x%x\", offset);\n\t\treturn err;\n\t}\n\terr = msc_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write data at offset 0x%x\", offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 52.59582374252973}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t", "CodeBleu_score": 5.717441331318144}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\tsize_t j = 0;\n\tuint8_t c;\n\n\twhile (i < maxlen && in[j] != 0) {\n\t\tc = hex_char_to_byte(in[j]);\n\t\tif (c < 0x10) {\n\t\t\tout[i++] = c;\n\t\t\tj++;\n\t\t} else {\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn i;\n}", "CodeBleu_score": 33.742396404243536}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = 0;\n\twhile (len < maxlen) {\n\t\tuint8_t c = hex_char_to_byte(*in++);\n\t\tif (c >= 16) {\n\t\t\t// skip non-hexadecimal characters\n\t\t\tcontinue;\n\t\t}\n\t\tuint8_t c2 = hex_char_to_byte(*in++);\n\t\tif (c2 >= 16) {\n\t\t\t// skip non-hexadecimal characters\n\t\t\tin--;\n\t\t\tcontinue;\n\t\t}\n\t\tout[len++] = (c << 4) | c2;\n\t}\n\treturn len;\n}", "CodeBleu_score": 41.19533329781856}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i, j;\n\tuint8_t c;\n\tfor (i = j = 0; i < maxlen && in[i] != '\\0'; i++) {\n\t\tc = hex_char_to_byte(in[i]);\n\t\tif (c < 0x10) {\n\t\t\tif (j > 0) {\n\t\t\t\tout[j] = (out[j] << 4) | c;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\treturn j;\n}", "CodeBleu_score": 36.888316207056675}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tint freeSpace = 0;\n\tif (txRingbuffer != NULL) {\n\t\tif (xSemaphoreTake(txRingbufferLock, pdMS_TO_TICKS(1000)) == pdTRUE) {\n\t\t\tfreeSpace = xRingbufferGetCurFreeSize(txRingbuffer);\n\t\t\txSemaphoreGive(txRingbufferLock);\n\t\t}\n\t}\n\treturn freeSpace;\n}", "CodeBleu_score": 44.825257443845054}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint freeSize = 0;\n\tif (xRingbufferHandle == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(xRingbufferLock, portMAX_DELAY) == pdTRUE) {\n\t\tfreeSize = xRingbufferGetCurFreeSize(xRingbufferHandle);\n\t\txSemaphoreGive(xRingbufferLock);\n\t}\n\treturn freeSize;\n}", "CodeBleu_score": 53.187134149682194}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (!this->txBuffer) {\n\t\treturn 0;\n\t}\n\tif (!this->txLock) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(this->txLock, 1000 / portTICK_RATE_MS) == pdTRUE) {\n\t\tint ret = xRingbufferGetCurFreeSize(this->txBuffer);\n\t\txSemaphoreGive(this->txLock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 32.709698366627414}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t//  log_w(\"onReceive\");\n  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n    _uart->setRxFIFOFullInterrupt(_rx_buffer_size / 2);\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 37.19434121033921}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#ifdef CONFIG_ARDUINO_SERIAL_USE_MUTEX\n  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    if (_rxBufferSize == 0) {\n      _rxBufferSize = ARDUINO_SERIAL_RX_BUFFER_SIZE;\n    }\n    if (_rxBufferSize > ARDUINO_SERIAL_RX_BUFFER_SIZE) {\n      _rxBufferSize = ARDUINO_SERIAL_RX_BUFFER_SIZE;\n    }\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n    _setRxFIFOFullThreshold(ARDUINO_SERIAL_RX_BUFFER_SIZE / 2);\n  }\n  HSERIAL_MUTEX_UNLOCK\n#endif\n}", "CodeBleu_score": 49.29418024546468}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (_onReceiveCB) {\n\t\t_rx_buffer.setRxFIFOFullCallback(_onReceiveCB);\n\t\t_rx_buffer.setRxFIFOFullThreshold(1);\n\t\tif (_eventTask == NULL) {\n\t\t\t_createEventTask(NULL);\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 38.463849764300974}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t#if defined(ESP8266)\n  size_t count = 0;\n  char c;\n  while (count < length) {\n    c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    if (c == terminator) {\n      break;\n    }\n    buffer[count++] = c;\n  }\n  return count;\n#else\n  return readBytesUntil(terminator, buffer, length, _timeout);\n#endif\n}", "CodeBleu_score": 58.30399529930557}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\tint c;\n\n\twhile (index < length) {\n\t\tc = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = (char)c;\n\t\tindex++;\n\t}\n\treturn index;\n}", "CodeBleu_score": 61.6164408595683}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t#if defined(ESP8266) || defined(ESP32)\n  int c;\n  size_t i = 0;\n  while (i < length) {\n    c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[i++] = c;\n    if (c == terminator) {\n      break;\n    }\n  }\n  return i;\n#else\n  return readBytesUntil(terminator, buffer, length, _timeout);\n#endif\n}", "CodeBleu_score": 59.34422145355062}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_v(\"tone: pin=%d, frequency=%d, duration=%d\", pin, frequency, duration);\n\n\t// Check if the pin is available\n\tif (gpio_get_pin_function(pin) == GPIO_FUNC_SIO) {\n\t\t// The pin is available\n\t\tlog_v(\"The pin is available\");\n\t\t// Check if the pin is already in use\n\t\tif (gpio_get_pin_pull(pin) == GPIO_PULL_NONE) {\n\t\t\t// The pin is not in use\n\t\t\tlog_v(\"The pin is not in use\");\n\t\t\t// Initialize the tone\n\t\t\tlog_v(\"Initializing the tone\");\n\t\t\tif (tone_init() == 1) {\n\t\t\t\t// The tone queue is available\n\t\t\t\tlog_v(\"The tone queue is available\");\n\t\t\t\t// Create a message to send\n\t\t\t\tlog_v(\"Creating a message to send\");\n\t\t\t\ttone_msg_t msg = {\n\t\t\t\t\t.pin = pin,\n\t\t\t\t\t.frequency = frequency,\n\t\t\t\t\t.duration = duration,\n\t\t\t\t\t.action = TONE_START\n\t\t\t\t};\n\t\t\t\t// Send the message to the tone task\n\t\t\t\tlog_v(\"Sending the message to the tone task\");\n\t\t\t\txQueueSend(_tone_queue, &msg, portMAX_DELAY);\n\t\t\t} else {\n\t\t\t\t// The tone queue is not available\n\t\t\t\tlog_e(\"The tone queue is not available\");\n\t\t\t}\n\t\t} else {\n\t\t\t// The pin is in use\n\t\t\tlog_e(\"The pin is in use\");\n\t\t}\n\t} else {\n\t\t// The pin is not available\n\t\tlog_e(\"The pin is not available\");\n\t}\n}", "CodeBleu_score": 55.74115913801212}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin < 0 || pin > 15) {\n\t\tlog_e(\"Invalid pin number %d\", pin);\n\t\treturn;\n\t}\n\n\tif (frequency == 0) {\n\t\tlog_e(\"Invalid tone frequency %d\", frequency);\n\t\treturn;\n\t}\n\n\tif (duration == 0) {\n\t\tlog_e(\"Invalid tone duration %d\", duration);\n\t\treturn;\n\t}\n\n\tif (g_pin_used[pin]) {\n\t\tlog_e(\"Pin %d is already in use\", pin);\n\t\treturn;\n\t}\n\n\tg_pin_used[pin] = 1;\n\n\tlog_d(\"Pin %d, frequency %d, duration %d\", pin, frequency, duration);\n\n\ttone_msg_t msg = {\n\t\t.pin = pin,\n\t\t.frequency = frequency,\n\t\t.duration = duration\n\t};\n\n\txQueueSend(_tone_queue, &msg, portMAX_DELAY);\n}", "CodeBleu_score": 55.79684336692545}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"tone(%d, %d, %d)\", pin, frequency, duration);\n\tif (pin < 2 || pin > 13) {\n\t\tlog_e(\"Invalid pin\");\n\t\treturn;\n\t}\n\tif (frequency < 1 || frequency > 10000) {\n\t\tlog_e(\"Invalid frequency\");\n\t\treturn;\n\t}\n\tif (duration < 1 || duration > 10000) {\n\t\tlog_e(\"Invalid duration\");\n\t\treturn;\n\t}\n\tif (digitalRead(pin) == HIGH) {\n\t\tlog_e(\"Pin in use\");\n\t\treturn;\n\t}\n\tif (tone_init() == 0) {\n\t\tlog_e(\"Tone init failed\");\n\t\treturn;\n\t}\n\ttone_msg_t msg = {\n\t\t.pin = pin,\n\t\t.frequency = frequency,\n\t\t.duration = duration,\n\t\t.state = TONE_START\n\t};\n\tif (xQueueSend(_tone_queue, &msg, portMAX_DELAY) != pdPASS) {\n\t\tlog_e(\"Could not send message to tone queue\");\n\t}\n}", "CodeBleu_score": 57.839800398474}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!USB.hasStarted()) {\n\t\t_webUSBEnabled = enabled;\n\t\tif (enabled && USB.getVersion() < 0x0210) {\n\t\t\tUSB.setVersion(0x0210);\n\t\t}\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (USB.getVersion() < 0x0210) {\n\t\t\tUSB.setVersion(0x0210);\n\t\t}\n\t\t_webUSBEnabled = true;\n\t} else {\n\t\t_webUSBEnabled = false;\n\t}\n\treturn false;\n}", "CodeBleu_score": 45.83909985684264}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_started) {\n\t\tif (enabled) {\n\t\t\tif (usb_version >= 0x0210) {\n\t\t\t\tusb_web_enabled = true;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tusb_web_enabled = false;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tusb_web_enabled = enabled;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 34.77163639896484}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (usb_started) {\n\t\t\tif (usb_version >= 0x0210) {\n\t\t\t\twebusb_enabled = true;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\twebusb_enabled = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\twebusb_enabled = false;\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 29.952710386548283}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\t// Read data into the buffer\n\tsize_t read = tud_cdc_n_read(cdc_it, (uint8_t*)rx_buffer, sizeof(rx_buffer));\n\tif (read > 0) {\n\t\t// Send the data to the receive queue\n\t\tif (!xQueueSend(rx_queue, &read, 0)) {\n\t\t\t// If the queue is full, log an error\n\t\t\tlog_e(\"Receive queue overflow: %d bytes dropped\", read);\n\t\t\t// Post an overflow event\n\t\t\tarduino_usb_event_post(ARDUINO_USB_EVENT_CDC_RX_OVERFLOW, &read);\n\t\t} else {\n\t\t\t// If data was successfully read, post a receive event\n\t\t\tarduino_usb_event_post(ARDUINO_USB_EVENT_CDC_RX_DATA, &read);\n\t\t}\n\t}\n}", "CodeBleu_score": 17.62854811984592}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data;\n\tsize_t bytesRead = 0;\n\tsize_t bytesDropped = 0;\n\twhile (bytesRead < sizeof(this->rxBuffer)) {\n\t\tif (tud_cdc_n_read(CDC_RX_EP, &data, 1) == 1) {\n\t\t\tif (xQueueSend(this->rxQueue, &data, 0) == pdFALSE) {\n\t\t\t\tbytesDropped++;\n\t\t\t}\n\t\t\tbytesRead++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bytesDropped > 0) {\n\t\tthis->log_e(\"RX overflow: %d bytes dropped\", bytesDropped);\n\t\txEventGroupSetBits(this->eventGroup, USBCDC_EVENT_RX_OVERFLOW);\n\t}\n\tif (bytesRead > 0) {\n\t\txEventGroupSetBits(this->eventGroup, USBCDC_EVENT_RX);\n\t}\n}", "CodeBleu_score": 20.271281012091638}, {"code": "void USBCDC::_onRX(){\n\tuint8_t data;\nuint16_t nBytes;\nuint16_t nDropped = 0;\n\nnBytes = tud_cdc_n_read(CDC_RX_EP, &data, 1);\nif (nBytes > 0) {\nif (xQueueSend(rxQueue, &data, portMAX_DELAY) != pdTRUE) {\nnDropped = nDropped + 1;\n}\n} else if (nBytes < 0) {\nlog_e(\"CDC receive error: %d\", nBytes);\n}\n\nif (nDropped > 0) {\nlog_e(\"CDC receive overflow: dropped %d bytes\", nDropped);\nevent_post(CDC_RECEIVE_OVERFLOW, &nDropped);\n}\n\nif (nBytes > 0) {\nevent_post(CDC_RECEIVE, &nBytes);\n}\n}", "CodeBleu_score": 19.639105186894994}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the name of the robot from the URL parameters.\n\tname := req.URL.Query().Get(\"name\")\n\n\t// Check if a robot with the given name exists.\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\t// No robot was found with the given name, so return an error response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"no robot found with name '%s'\", name),\n\t\t})\n\t\treturn\n\t}\n\n\t// Gather all of the devices associated with the robot into a JSON format.\n\tdevices := []map[string]string{}\n\trobot.Devices().Each(func(d *gobot.Device) {\n\t\tdevices = append(devices, map[string]string{\n\t\t\t\"name\": d.Name(),\n\t\t\t\"type\": d.Type(),\n\t\t})\n\t})\n\n\t// Write the response to the HTTP response writer.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 47.39381276221511}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Check if a robot with the given name exists.\n\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\tres.WriteJSON(map[string]string{\"error\": \"no robot name given\"})\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.WriteJSON(map[string]string{\"error\": \"no robot found with name \" + name})\n\t\treturn\n\t}\n\t// Gather all devices associated with the robot and write a JSON response.\n\tdevices := []map[string]string{}\n\trobot.Devices().Each(func(d gobot.Device) {\n\t\tdevices = append(devices, map[string]string{\n\t\t\t\"name\":  d.Name(),\n\t\t\t\"type\":  d.Type(),\n\t\t\t\"adaptor\": d.Adaptor().Name(),\n\t\t})\n\t})\n\tres.WriteJSON(devices)\n}", "CodeBleu_score": 51.046443245381866}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot name from the request URL query parameters.\n\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\t// If no robot name was specified, return an error.\n\t\ta.writeJSON(res, http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"no robot name specified\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Retrieve the robot with the specified name.\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\t// If no robot was found with the specified name, return an error.\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"robot '%s' not found\", name),\n\t\t})\n\t\treturn\n\t}\n\n\t// Gather all devices associated with the robot.\n\tdevices := make([]map[string]interface{}, 0)\n\trobot.Devices().Each(func(name string, device gobot.Device) {\n\t\t// For each device, create a JSON object representing the device.\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"name\": name,\n\t\t\t\"pins\": device.Pins(),\n\t\t})\n\t})\n\n\t// Write the JSON response to the HTTP response writer.\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 49.59855122884297}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"missing robot name\"))\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"robot not found\"))\n\t\treturn\n\t}\n\tres.WriteHeader(http.StatusOK)\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write([]byte(\"[\n\"))\n\tfirst := true\n\trobot.Connections().Each(func(conn gobot.Connection) {\n\t\tif !first {\n\t\t\tres.Write([]byte(\",\n\"))\n\t\t}\n\t\tfirst = false\n\t\ta.writeJSON(res, conn)\n\t})\n\tres.Write([]byte(\"\n]\"))\n}", "CodeBleu_score": 35.8632908320993}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\tname := req.URL.Query().Get(\"name\")\n\n\t// Check if the robot exists.\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"no robot with name '\" + name + \"' was found\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections, convert them to JSON format, and write them to the HTTP response.\n\tconnections := []map[string]string{}\n\trobot.Connections().Each(func(conn gobot.Connection) bool {\n\t\tconnections = append(connections, conn.Connection().(map[string]string))\n\t\treturn true\n\t})\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 52.212122524062195}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\tname := req.URL.Query().Get(\"name\")\n\n\t// Check if the robot exists.\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\tres.Write([]byte(fmt.Sprintf(\"no robot named %s found\", name)))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections, convert them to JSON format, and write them to the HTTP response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\ta.writeJSON(res, robot.Connections())\n}", "CodeBleu_score": 27.824787610658902}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\t// Check if the device exists\n\tdevice := a.jsonDeviceFor(robotName, deviceName)\n\tif device == nil {\n\t\t// If the device doesn't exist, write an error message as a JSON response\n\t\terrMsg := fmt.Sprintf(\"No device named '%s' found on robot '%s'\", deviceName, robotName)\n\t\terr := errors.New(errMsg)\n\t\ta.writeJSON(res, err, http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\terr := a.executeCommand(device, req.URL.Query().Get(\":command\"))\n\tif err != nil {\n\t\t// If an error occurs, write an error message as a JSON response\n\t\ta.writeJSON(res, err, http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Write a success message as a JSON response\n\ta.writeJSON(res, \"Command executed successfully\", http.StatusOK)\n}", "CodeBleu_score": 50.8733329979765}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tvar err error\n\tvar command string\n\n\t// Get the command from the URL query parameters\n\tcommand = req.URL.Query().Get(\":command\")\n\n\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\t// Check if the robot and device names are valid\n\tif robotName == \"\" {\n\t\terr = errors.New(\"robot name is empty\")\n\t} else if deviceName == \"\" {\n\t\terr = errors.New(\"device name is empty\")\n\t}\n\n\t// Check if the robot exists\n\tif err == nil {\n\t\tif _, ok := a.master.Robots[robotName]; !ok {\n\t\t\terr = errors.New(\"robot does not exist\")\n\t\t}\n\t}\n\n\t// Check if the device exists\n\tif err == nil {\n\t\tif _, ok := a.master.Robots[robotName].Devices[deviceName]; !ok {\n\t\t\terr = errors.New(\"device does not exist\")\n\t\t}\n\t}\n\n\t// Execute the command on the device\n\tif err == nil {\n\t\terr = a.master.Robots[robotName].Devices[deviceName].(gobot.Commander).Command(command)\n\t}\n\n\t// Write the error as a JSON response\n\tif err != nil {\n\t\ta.writeJSON(res, err, http.StatusNotFound)\n\t}\n}", "CodeBleu_score": 40.21635126759173}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters.\n\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\n\t// Check if the device exists.\n\td, err := a.jsonDeviceFor(robot, device)\n\tif err != nil {\n\t\t// Write the error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\terr = d.(gobot.Commander).Command(req.URL.Query().Get(\":command\"))\n\tif err != nil {\n\t\t// Write the error message as a JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Write the success message as a JSON response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\ta.writeJSON(res, map[string]string{\"success\": \"Command executed successfully\"})\n}", "CodeBleu_score": 53.68881104461734}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\texpected := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tactual := r.Header.Get(\"Authorization\")\n\t\tif !secureCompare(actual, expected) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+username+`\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tr.Header.Del(\"Authorization\")\n\t\tr.Header.Del(\"Proxy-Authorization\")\n\t\tr.ParseForm()\n\t\tr.ParseMultipartForm(32 << 20)\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 56.72589932166581}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tb, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 47.50341937619115}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+username+`\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authentication succeeded, call the next handler.\n\t\tr.URL.User = url.User(user)\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 52.31064200062323}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.sensorCfg.connectionType != ConnectionTypeAnalog {\n\t\treturn 0, 0, fmt.Errorf(\"connection type is not analog\")\n\t}\n\n\trawValue, err := a.Connection().AnalogRead(a.sensorCfg.pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"error reading analog pin: %s\", err)\n\t}\n\n\tscaledValue := float64(rawValue) * a.sensorCfg.scale\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 49.577487546823704}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.sensorCfg.supportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor %s does not support analog read\", a.sensorCfg.name)\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.sensorCfg.scale(raw)\n\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 50.990998381912156}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the sensor supports analog reading\n\tif a.sensorCfg.analogPin == -1 {\n\t\treturn 0, 0, errors.New(\"Analog reading not supported by this sensor\")\n\t}\n\n\t// Read the raw sensor value\n\traw := a.Connection().AnalogRead(a.sensorCfg.analogPin)\n\n\t// Scale the raw value\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\t// Update the last read values\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\t// Return the raw and scaled values\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 36.281268289934864}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\treturn &GroveSoundSensorDriver{\n\t\tDefaultAnalogSensorDriver{\n\t\t\ta,\n\t\t\tpin,\n\t\t\topts...,\n\t\t},\n\t}\n}", "CodeBleu_score": 20.15746741516909}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tvar name string\n\tif len(opts) > 0 {\n\t\tname = opts[0].(string)\n\t} else {\n\t\tname = gobot.DefaultName\n\t}\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: *gobot.NewAnalogSensorDriver(a, pin),\n\t}\n}", "CodeBleu_score": 34.63555387248415}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tgsd := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tanalogSensorDriver: NewAnalogSensorDriver(a, pin),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt.(func(*GroveSoundSensorDriver))(gsd)\n\t}\n\n\tgsd.Add(gsd.analogSensorDriver)\n\treturn gsd\n}", "CodeBleu_score": 33.016131423509734}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write the command for soft reset.\n\td.writeCommand(PCD_SOFT_RESET)\n\t// The datasheet says the oscillator start-up time is the start up time of the crystal + 14ms.\n\t// We add 100ms to be sure.\n\ttime.Sleep(15 * time.Millisecond)\n\t// Check the reset has finished.\n\tif d.readStatus()&0x08 != 0 {\n\t\treturn fmt.Errorf(\"timeout waiting for reset\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.260212391118525}, {"code": "func (d *MFRC522Common) softReset() error{\n\t", "CodeBleu_score": 2.257776667160384}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tvar err error\n\tvar status byte\n\t// Write soft reset command to the command register.\n\terr = d.writeCommand(PCD_SOFT_RESET)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Delay for a short period before reading the command register.\n\ttime.Sleep(100 * time.Millisecond)\n\t// Read the status register.\n\tstatus, err = d.readStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check for the power down bit.\n\tif (status & 0x01) != 0 {\n\t\treturn fmt.Errorf(\"failed to enter soft reset\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.987238345301044}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar err error\n\tvar length uint8\n\tvar status uint8\n\tlength, err = d.readByte(CommandGetFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif length > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"Byte slice too small to hold %d bytes\", length)\n\t}\n\tfor i := uint8(0); i < length; i++ {\n\t\tbackData[i], err = d.readByte(CommandReadFIFO)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tstatus, err = d.readByte(CommandGetFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn status, nil\n}", "CodeBleu_score": 45.59818772597345}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check length\n\tlength, err := d.getFifoLevel()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif uint8(len(backData)) != length {\n\t\treturn 0, fmt.Errorf(\"Length of provided byte slice (%d) does not match the length of the FIFO (%d)\", len(backData), length)\n\t}\n\t// Read data\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read status register\n\tlastBits, err := d.readByteData(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 48.65436271579556}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check length of slice and number of bytes available in FIFO\n\tif len(backData) != d.getFIFOLevel() {\n\t\treturn 0, errors.New(\"Byte slice length does not match number of bytes available in FIFO\")\n\t}\n\n\t// Read data from FIFO\n\tfor i := range backData {\n\t\t// Read from FIFO\n\t\tdata, err := d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\t// Write data to slice\n\t\tbackData[i] = data\n\t}\n\n\t// Read control register\n\tdata, err := d.readByteData(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Return last bits received and any errors encountered\n\treturn data, nil\n}", "CodeBleu_score": 40.405988257061345}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"halting PICC\")\n\t}\n\ttx := []byte{PICC_HALT}\n\ttx = append(tx, calculateCRC(tx))\n\tif d.communicateWithPICC(tx) == nil {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"failed to halt PICC\")\n}", "CodeBleu_score": 28.53141793549913}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif Debug {\n\t\tfmt.Println(\"Halting PICC\")\n\t}\n\n\t// Create the command for halting PICC communication.\n\tcmd := []byte{PICC_HALT}\n\n\t// Calculate CRC for the command.\n\tcrc := d.calculateCRC(cmd[:])\n\n\t// Append CRC to the end of the command.\n\tcmd = append(cmd, crc)\n\n\t// Send the command.\n\tif err := d.communicateWithPICC(cmd); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 28.61107768069956}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halting PICC\")\n\t}\n\n\t// Create the command for halting\n\tcmd := []byte{PICC_HALT}\n\n\t// Calculate CRC for the command\n\tcrc := d.calculateCRC(cmd[:])\n\n\t// Add CRC to the command\n\tcmd = append(cmd, crc)\n\n\t// Send the command\n\tif err := d.communicateWithPICC(cmd); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 28.334184995666238}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar command [18]byte\n\tcommand[0] = PICC_READ\n\tcommand[1] = block\n\tcrc := d.calculateCRC(command[:2])\n\tcommand[2] = crc[0]\n\tcommand[3] = crc[1]\n\tdata, err := d.communicateWithPICC(command, 18)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(data) != 16 {\n\t\treturn nil, errors.New(\"piccRead: byte count mismatch\")\n\t}\n\treturn data, nil\n}", "CodeBleu_score": 31.578033687463027}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar command [18]byte\n\tvar backData []byte\n\tvar err error\n\tvar status uint8\n\n\tcommand[0] = PCD_READ\n\tcommand[1] = block & 0x07\n\tcommand[2] = 0x00\n\tcommand[3] = 0x00\n\tcommand[4] = 0x08\n\tcommand[5] = 0x00\n\tcommand[6] = 0x00\n\tcommand[7] = 0x00\n\tcommand[8] = 0x00\n\tcommand[9] = 0x00\n\tcommand[10] = 0x00\n\tcommand[11] = 0x00\n\tcommand[12] = 0x00\n\tcommand[13] = 0x00\n\tcommand[14] = 0x00\n\tcommand[15] = 0x00\n\tcommand[16] = 0x00\n\tcommand[17] = 0x00\n\n\td.calculateCRC(&command[0], 17, &backData, &status)\n\n\tif status != 0x00 {\n\t\treturn nil, fmt.Errorf(\"PCD_Read failed: %v\", status)\n\t}\n\n\treturn d.communicateWithPICC(&command[0], 18, &backData, &status)\n}", "CodeBleu_score": 24.598586417154102}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Create byte array for command data.\n\tdata := []byte{piccCommandRead, block}\n\n\t// Calculate CRC for the command.\n\tcrc := d.calculateCRC(data[:2])\n\n\t// Append CRC to the command.\n\tdata = append(data, crc)\n\n\t// Send the command.\n\tresponse, err := d.communicateWithPICC(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check that the response is the correct size.\n\tif len(response) != 18 {\n\t\treturn nil, errors.New(\"Received unexpected number of bytes from PICC\")\n\t}\n\n\t// Check the CRC.\n\tif response[len(response)-2] != d.calculateCRC(response[:len(response)-2]) {\n\t\treturn nil, errors.New(\"Received invalid CRC from PICC\")\n\t}\n\n\t// Return data bytes.\n\treturn response[len(response)-10:], nil\n}", "CodeBleu_score": 42.90287770127218}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"PICC response buffer too short: %d\", len(answer))\n\t}\n\n\t// Clear bits in CollReg\n\td.clearRegisterBitMask(CollReg, 0x80|0x40|0x20|0x10|0x08|0x04|0x02|0x01)\n\n\t// Set the bits defined in reqMode\n\td.setRegisterBitMask(TxModeReg, reqMode)\n\n\t// We need at least 10 bytes for the data request command.\n\tif len(answer) < 10 {\n\t\tanswer = append(answer, make([]byte, 10-len(answer))...)\n\t}\n\n\t// Transceive the data\n\terr := d.communicateWithPICC(PCD_TRANSCEIVE, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check for errors\n\tif (answer[0] & 0x1B) != 0x00 {\n\t\treturn fmt.Errorf(\"PCD_TRANSCEIVE returns error code: %02x\", answer[0])\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 50.64634571162989}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tvar err error\n\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: buffer too small to hold the result\")\n\t}\n\n\t// Clear the collision register by calling calculateCRC for all 16 bits.\n\tfor i := byte(0); i < 16; i++ {\n\t\td.calculateCRC(i, 0)\n\t}\n\n\t// Set the bits used for the CRC in the last byte.\n\td.clearRegisterBitMask(mfrc522CrcReg, 0x04)\n\tif reqMode == piccReqIDL {\n\t\t// Set the bits used for the CRC in the last byte.\n\t\td.setRegisterBitMask(mfrc522CrcReg, 0x04)\n\t}\n\n\t// Transmit the request.\n\tif err = d.communicateWithPICC(reqMode, 0, 0, answer); err != nil {\n\t\treturn err\n\t}\n\n\t// Check that the response is 16 bytes long.\n\tif len(answer) != 16 {\n\t\treturn fmt.Errorf(\"piccRequest: received %d bytes instead of 16\", len(answer))\n\t}\n\n\t// Check the CRC.\n\tif !d.checkCRC(answer[:15]) {\n\t\treturn fmt.Errorf(\"piccRequest: CRC mismatch\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 50.724333479209584}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest needs at least 2 bytes in the answer buffer\")\n\t}\n\td.clearRegisterBitMask(mfrc522RegisterColl, 0x80)\n\tif reqMode == piccRequestModeTypeA {\n\t\td.setRegisterBits(mfrc522RegisterTxLastBits, 0x07)\n\t}\n\terr := d.communicateWithPICC(reqMode, 0, 0, 0, 0, answer)\n\td.setRegisterBits(mfrc522RegisterTxLastBits, 0x80)\n\treturn err\n}", "CodeBleu_score": 40.92094799258651}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the valueMutex to ensure thread safety\n\td.valueMutex.Lock()\n\n\t// Trigger a valid step\n\terr := d.digitalWrite(d.stepPin, gpio.Low)\n\tif err != nil {\n\t\t// Unlock the valueMutex to ensure thread safety\n\t\td.valueMutex.Unlock()\n\t\treturn err\n\t}\n\n\t// Wait for a delay\n\ttime.Sleep(d.getDelayPerStep())\n\n\t// Set the step pin high\n\terr = d.digitalWrite(d.stepPin, gpio.High)\n\tif err != nil {\n\t\t// Unlock the valueMutex to ensure thread safety\n\t\td.valueMutex.Unlock()\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number based on the direction\n\tif d.direction == gpio.Low {\n\t\td.stepNumber--\n\t} else {\n\t\td.stepNumber++\n\t}\n\n\t// Unlock the valueMutex to ensure thread safety\n\td.valueMutex.Unlock()\n\n\treturn nil\n}", "CodeBleu_score": 61.028115632956116}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the valueMutex to ensure thread safety while accessing shared variables.\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a valid step by setting the step pin low.\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for a delay.\n\ttime.Sleep(d.getDelayPerStep())\n\n\t// Set the step pin high.\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction.\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 74.22970447284499}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the valueMutex to ensure thread safety while accessing shared variables.\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a valid step by setting the step pin low, waiting for a delay, and setting the step pin high.\n\tif err := d.digitalWrite(d.stepPin, d.low); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.stepPin, d.high); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction.\n\tif d.direction == d.forward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 76.60163416271762}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 75.65386166360287}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 75.3634867285451}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 75.3634867285451}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(channel int, pulseDuration time.Duration, deviceID string, timestamp uint32, messageID uint32) {\n\t\tif pulseDuration > 0 {\n\t\t\td.publishMessage(channel, pulseDuration, deviceID, timestamp, messageID)\n\t\t}\n\t\td.startTimestamp = time.Now()\n\t}\n}", "CodeBleu_score": 41.10370824905692}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(gpio int, duration time.Duration, channel string, timestamp uint32, nanos uint32) {\n\t\t// Record the timestamp of the rising edge\n\t\tif gpio == d.echoPin {\n\t\t\td.startTimestamp = timestamp\n\t\t\td.startNanos = nanos\n\t\t}\n\n\t\t// Record the timestamp of the falling edge\n\t\tif gpio == d.trigPin {\n\t\t\t// Calculate the duration of the pulse\n\t\t\tpulseDuration := time.Duration(nanos-d.startNanos) * time.Nanosecond\n\t\t\t// Send the duration of the pulse to a channel\n\t\t\td.sendPulseDuration(channel, pulseDuration)\n\t\t\t// Reset the start timestamp\n\t\t\td.startTimestamp = 0\n\t\t\td.startNanos = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 40.082750791853705}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(gpio int, level time.Duration, event string, timestamp uint32, nanos uint32) {\n\t\tif level == time.Low {\n\t\t\td.startTimestamp = timestamp\n\t\t\td.startNanos = nanos\n\t\t} else if level == time.High {\n\t\t\tduration := d.calculateDuration()\n\t\t\td.sendDuration(duration)\n\t\t\td.startTimestamp = 0\n\t\t\td.startNanos = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 42.81470575733351}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\n\t// Trigger the sensor\n\terr := d.emitTrigger()\n\tif err != nil {\n\t\t// Unlock the measurement mutex\n\t\td.measureMutex.Unlock()\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measureComplete:\n\t\t// Unlock the measurement mutex\n\t\td.measureMutex.Unlock()\n\tcase <-time.After(d.timeout):\n\t\t// Unlock the measurement mutex\n\t\td.measureMutex.Unlock()\n\n\t\t// Return an error\n\t\treturn fmt.Errorf(\"timeout while waiting for measurement to complete\")\n\t}\n\n\t// Return success\n\treturn nil\n}", "CodeBleu_score": 50.15724632953218}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access.\n\td.measureMutex.Lock()\n\n\t// Trigger the sensor.\n\td.emitTrigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur.\n\tselect {\n\tcase <-d.measureComplete:\n\t\t// The measurement is complete.\n\tcase <-time.After(d.timeout):\n\t\t// The measurement timed out.\n\t\treturn fmt.Errorf(\"timeout while waiting for the measurement to complete\")\n\t}\n\n\t// Unlock the measurement mutex.\n\td.measureMutex.Unlock()\n\n\t// Return nil to indicate success.\n\treturn nil\n}", "CodeBleu_score": 27.920487929237392}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\t// Trigger the sensor\n\td.emitTrigger()\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measureComplete:\n\t\t// Unlock the measurement mutex\n\t\td.measureMutex.Unlock()\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// Unlock the measurement mutex\n\t\td.measureMutex.Unlock()\n\t\treturn fmt.Errorf(\"timeout waiting for measurement to complete\")\n\t}\n}", "CodeBleu_score": 29.66415151361204}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if self.access_token_env_var:\n        self.access_token = os.getenv(self.access_token_env_var)\n    if not self.access_token:\n        self.access_token, self.expires_at = self.get_local_session()\n    if self.access_token and self.expires_at > time.time():\n        return self.access_token\n    if self.refresh_token:\n        try:\n            data = self.fetch_json_data(\n                \"POST\",\n                self.auth_url,\n                data={\n                    \"grant_type\": \"refresh_token\",\n                    \"client_id\": self.client_id,\n                    \"client_secret\": self.client_secret,\n                    \"refresh_token\": self.refresh_token,\n                },\n            )\n            self.access_token = data[\"access_token\"]\n            self.expires_at = time.time() + data[\"expires_in\"]\n            self.update_local_session(self.access_token, self.expires_at)\n            return self.access_token\n        except AccountError:\n            pass\n    raise AccountNotAuthorized(\n        \"Account not authorized. Please run `neuro login` to authorize.\"\n    )\n\n", "CodeBleu_score": 40.56768646280483}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\"TOKEN\")\n    if token:\n        return token\n    else:\n        token = self.get_state_item(\"token\")\n        if token:\n            expiration_time = self.get_state_item(\"expiration_time\")\n            if expiration_time and expiration_time > time.time():\n                return token\n            else:\n                refresh_token = self.get_state_item(\"refresh_token\")\n                if refresh_token:\n                    try:\n                        data = self.fetch_json_data(\n                            \"https://accounts.spotify.com/api/token\",\n                            method=\"POST\",\n                            headers={\n                                \"Authorization\": \"Basic {}\".format(\n                                    base64.b64encode(\n                                        \"{}:{}\".format(\n                                            self.client_id, self.client_secret\n                                        ).encode(\"ascii\")\n                                    ).decode(\"ascii\")\n                                )\n                            },\n                            data={\"grant_type\": \"refresh_token\", \"refresh_token\": refresh_token},\n                        )\n                        self.set_state_item(\"token\", data[\"access_token\"])\n                        self.set_state_item(\"expiration_time\", int(time.time()) + data[\"expires_in\"])\n                        self.set_state_item(\"refresh_token\", data.get(\"refresh_token\"))\n                        return data[\"access_token\"]\n                    except AccountError:\n                        self.delete_local_session()\n                        raise AccountNotAuthorized(\"The access token has expired.\") from None\n                else:\n                    raise AccountNotAuthorized(\"No refresh token is available.\") from None\n        else:\n            raise AccountNotAuthorized(\"No authentication token is available.\") from None\n\n", "CodeBleu_score": 42.20749085722878}, {"code": "def fetch_authentication_token(self)\n\t\n    # Check if the token is available in the environment variables\n    if self.auth_token is None:\n        # Check if the access token is available in the local state\n        access_token = self.get_state_item(\"access_token\")\n        if access_token is None:\n            # If the access token is not available, check if the refresh token is available\n            refresh_token = self.get_state_item(\"refresh_token\")\n            if refresh_token is None:\n                raise AccountNotAuthorized(\n                    \"The access token is not available and the refresh token is not available. Please log in.\"\n                )\n            # If the refresh token is available, attempt to fetch a new access token\n            try:\n                response = self.refresh_access_token(refresh_token)\n                self.set_state_item(\"access_token\", response[\"access_token\"])\n                self.set_state_item(\"token_expiration\", response[\"expires_in\"])\n            except AccountError:\n                # If the refresh token is invalid, delete the local state and raise an exception\n                self.delete_local_session()\n                raise AccountNotAuthorized(\n                    \"The refresh token is invalid. Please log in.\"\n                )\n        else:\n            # If the access token is available, check if it is expired\n            token_expiration = self.get_state_item(\"token_expiration\")\n            if token_expiration is not None:\n                current_time = time.time()\n                if current_time >= token_expiration:\n                    # If the access token is expired, check if a refresh token is available\n                    refresh_token = self.get_state_item(\"refresh_token\")\n                    if refresh_token is None:\n                        # If the refresh token is not available, delete the local state and raise an exception\n                        self.delete_local_session()\n                        raise AccountNotAuthorized(\n                            \"The access token has expired. Please log in.\"\n                        )\n                    # If the refresh token is available, attempt to fetch a new access token\n                    try:\n                        response = self.refresh_access_token(refresh_token)\n                        self.set_state_item(\"access_token\", response[\"access_token\"])\n                        self.set_state_item(\"token_expiration\", response[\"expires_in\"])\n                    except AccountError:\n                        # If the refresh token is invalid, delete the local state and raise an exception\n                        self.delete_local_session()\n                        raise AccountNotAuthorized(", "CodeBleu_score": 36.57401039261325}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            json={\"refresh_token\": refresh_token},\n            headers=self.headers,\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 63.37384378158413}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\"POST\", \"/v1/logout\", json={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 62.90597708859879}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n    except AccountError:\n        pass\n    else:\n        self.delete_local_session()\n        try:\n            self.fetch_json_data(\n                \"POST\",\n                \"v1/logout\",\n                headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n                timeout=10,\n            )\n        except AccountError:\n            pass\n    return True\n", "CodeBleu_score": 58.58875188840309}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, spec in self.options.get('packages', {}).items():\n        if spec.get('optional'):\n            continue\n        package = self.get_package(name, spec)\n        if package:\n            result.append({\n                'name': name,\n                'version': package.version,\n                'external': package.external,\n                'url': package.url,\n                'description': package.description,\n            })\n    return result\n\n", "CodeBleu_score": 34.61904201747821}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for name, spec in self.pm.get_used_packages(self.options.get('packages')).items():\n        pkg = self.get_package(name, spec)\n        if pkg.external:\n            packages.append({'name': name, 'version': pkg.version, 'url': pkg.url})\n        else:\n            packages.append({'name': name, 'version': pkg.version})\n    return packages\n", "CodeBleu_score": 31.326137461061503}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, spec in self.items():\n        if spec.get(\"optional\"):\n            continue\n        package = self.get_package(name, spec)\n        if package.external:\n            result.append((name, package.version, package.source_url))\n        else:\n            result.append((name, package.version))\n    return result\n\n", "CodeBleu_score": 30.6043985676124}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    targets = targets or []\n    try:\n        platform_spec = config.get(\n            \"environments\", env, default=None\n        )  # type: Optional[str]\n    except exception.InvalidProjectConfError:\n        raise exception.UndefinedEnvPlatformError(env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    p = cls(platform_spec, autoinstall=autoinstall)\n    p.set_env(env)\n    p.configure_project_packages(env, targets)\n    return p\n\n", "CodeBleu_score": 42.23594530068865}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if targets is None:\n        targets = []\n    env_name = env or \"default\"\n    env_spec = cls.get_env_spec(env_name)\n    if env_spec is None:\n        raise UndefinedEnvPlatformError(env_name)\n    p = cls(env_spec, autoinstall=autoinstall)\n    p.configure_project_packages(env_name, targets)\n    return p\n", "CodeBleu_score": 43.148853200599206}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n    try:\n        env_platform = cls.get_platform_from_config(env)\n    except configparser.Error as exc:\n        raise exception.InvalidProjectConfError(cls.path, str(exc))\n    except KeyError:\n        raise exception.UndefinedEnvPlatformError(env)\n    env = cls(env_platform, autoinstall)\n    env.set_project_environment(env)\n    env.configure_project_packages(env, targets)\n    return env\n\n", "CodeBleu_score": 34.766814230420536}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tuint8_t i = 0;\n\twhile (Wire1.available()) {\n\t\tBuff[i] = Wire1.read();\n\t\ti++;\n\t}\n}", "CodeBleu_score": 59.31098395654839}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission(false);\n\tWire1.requestFrom(0x34, Size);\n\tuint8_t i = 0;\n\twhile (Wire1.available()) {\n\t\tBuff[i] = Wire1.read();\n\t\ti++;\n\t}\n}", "CodeBleu_score": 54.763116948529685}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, (uint8_t)Size);\n\tuint8_t i = 0;\n\twhile (Wire1.available()) {\n\t\tBuff[i++] = Wire1.read();\n\t}\n}", "CodeBleu_score": 62.64437274723805}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_DEBUG\n    Serial.println(\"Entering deep sleep...\");\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        // Enable timer wakeup\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        // Disable timer wakeup\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 68.71820707278346}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_DEBUG\n    Serial.println(\"Entering deep sleep...\");\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        // enable timer wakeup\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    }\n    // enter deep sleep\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 55.76505511279164}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_DEBUG\n    Serial.printf(\"Entering deep sleep for %llu us\n\", time_in_us);\n#endif\n    SetSleep();\n    if (time_in_us) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_ALL);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 60.560925048304085}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n  int y = tft.gety();\n  tft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n  y += tft.fontHeight();\n  y %= tft.height() - BOTTOM_FIXED_AREA;\n  if (y < TOP_FIXED_AREA) {\n    y = TOP_FIXED_AREA;\n  }\n  scrollAddress(y);\n  return y;\n#endif\n}", "CodeBleu_score": 19.76778833461101}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = scrollY;\n\tscrollY += tft.fontHeight();\n\tif (scrollY > tft.height() - tft.fontHeight() - 1) {\n\t\tscrollY = 0;\n\t\tif (tteBar) {\n\t\t\tscrollY = tft.height() - tft.fontHeight() - tft.fontHeight() / 2;\n\t\t}\n\t}\n\ttft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n\tscrollAddress(scrollY);\n\treturn y;\n}", "CodeBleu_score": 15.470617229301764}, {"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n  uint16_t y = scrollY;\n  scrollY += tft.fontHeight();\n  if (scrollY >= tft.height() - BOTTOM_FIXED_AREA) {\n    scrollY = TOP_FIXED_AREA;\n    if (tteBar) {\n      scrollY = TOP_FIXED_AREA_BAR;\n    }\n  }\n  tft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n  scrollAddress(scrollY);\n  return y;\n#endif\n}", "CodeBleu_score": 19.961171493360307}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// set APs\n\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\n\t// set HTML content\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 61.874474982232385}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t", "CodeBleu_score": 9.66405520281211}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// set up the access points\n\tif (!this->setAP(ssids, access_points)) {\n\t\treturn false;\n\t}\n\n\t// set up the HTML content\n\tif (!this->setHtml()) {\n\t\treturn false;\n\t}\n\n\t// start the portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 72.53253761233728}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag == false) {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 13.49682550352348}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tthis->flush_queue();\n\t}\n\telse {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t\tthis->text = \"\";\n\t\tthis->text_in = \"\";\n\t}\n}", "CodeBleu_score": 22.04001669644164}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag == true) {\n\t\tthis->flush_queue();\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 20.019939618545067}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\t// Check if the queue exists and contains elements\n\tif(this->queue != NULL && this->queue->size > 0) {\n\t\t// Create a new queue\n\t\tthis->new_queue = new Queue<String>();\n\n\t\t// Delete the old queue\n\t\tdelete this->queue;\n\t}\n\n\t// If the queue does not exist, create a new one\n\telse if(this->queue == NULL) {\n\t\tthis->new_queue = new Queue<String>();\n\t}\n\n\t// Update the queue pointer\n\tthis->queue = this->new_queue;\n}", "CodeBleu_score": 22.724438959301324}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea) {\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = new Queue<NmeaSentence>();\n\t} else {\n\t\tthis->queue_nmea = new Queue<NmeaSentence>();\n\t}\n}", "CodeBleu_score": 21.700430382944557}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea != NULL) {\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = NULL;\n\t}\n\tthis->queue_nmea = new std::queue<std::string>;\n}", "CodeBleu_score": 14.155858641458366}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n//    uint32_t w = lv_area_get_width(area);\n//    uint32_t h = lv_area_get_height(area);\n\n//    uint32_t x1 = lv_area_get_x(area);\n//    uint32_t y1 = lv_area_get_y(area);\n\n//    uint32_t x2 = x1 + w - 1;\n//    uint32_t y2 = y1 + h - 1;\n\n//    uint32_t x;\n//    uint32_t y;\n\n//    uint32_t size = w * h;\n\n//    uint32_t *p = (uint32_t *)color_p;\n\n//    // Send the 'start write' command\n//    disp->flush_cb(disp, area, disp->color_p);\n\n//    // Set the address window\n//    disp->set_px_cb(disp, x1, y1, x2, y2);\n\n//    // Write pixels\n//    for (y = 0; y < h; y++) {\n//        for (x = 0; x < w; x++) {\n//            disp->write_cb(disp, *p);\n//            p++;\n//        }\n//    }\n\n//    // Send the 'end write' command\n//    disp->flush_cb(disp, area, disp->color_p);\n//  }", "CodeBleu_score": 3.2016194322392506}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n/* The most simple case: the area is the whole display */\n    if(area->x2 == disp->hor_res && area->y2 == disp->ver_res) {\n        /* In this case there is no need to copy the buffer.\n         * Just flush the pixels to the display. */\n        lv_disp_flush_ready(disp);\n        return;\n    }\n\n/* In the remaining cases there is an area which is not the whole display */\n\n/* Start the display write transaction.\n * It must be called before any drawing operation. */\n    lv_disp_flush_ready(disp);\n\n    /* Set the address window.\n     * This function is used to set the coordinates of the display area which needs to be updated. */\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n/* Iterate through the pixels in the specified area.\n * In this case the area is the same as the display. */\n    for(int32_t y = area->y1; y <= area->y2; y++) {\n        for(int32_t x = area->x1; x <= area->x2; x++) {\n            /* Get the pixel color from the color buffer */\n            lv_color_t color = color_p[y * disp->hor_res + x];\n\n            /* Write the pixel to the display */\n            display_obj.tft.writeColor(color.full);\n        }\n    }\n\n/* Call the display refresh function.\n * It must be called after all the drawing operations are finished. */\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 59.584449353881816}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tSerial.println(\"\");\n\tfor (int i = 0; i < menu->size(); i++) {\n\t\tSerial.print(menu->get(i)->getName());\n\t\tSerial.print(\"  \");\n\t}\n\tSerial.println(\"\");\n}", "CodeBleu_score": 45.45155519624469}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->size(); i++) {\n\t\tSerial.print(getIndentation(layer));\n\t\tSerial.println(menu->get(i)->getName());\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 45.912806687292495}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu->getHead() == NULL) {\n\t\tSerial.println();\n\t\treturn;\n\t}\n\tMenuNode * node = menu->getHead();\n\twhile (node != NULL) {\n\t\tprintMenuNode(node, layer);\n\t\tnode = node->getNext();\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 33.13406509350031}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t", "CodeBleu_score": 1.5471157130300377}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint channel;\n\tint mac;\n\tString ssid;\n\tfor (i = 0; i < count; i++) {\n\t\tchannel = random(1, 11);\n\t\tmac = random(1, 1000000000);\n\t\tssid = \"ssid\" + String(i);\n\t\tWiFi.softAP(ssid.c_str(), \"password\", channel, mac);\n\t\tSerial.println(ssid);\n\t\tssids->add(ssid);\n\t}\n\treturn ssids->size();\n}", "CodeBleu_score": 33.89513232272885}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i;\nint channel;\nint macAddr;\nString ssid;\nfor (i = 0; i < count; i++) {\nchannel = random(1, 11);\nmacAddr = random(1, 1000000000);\nssid = \"SSID\";\nssid.concat(i);\nssid.concat(macAddr);\nSerial.print(\"Generated SSID: \");\nSerial.println(ssid);\nssids->add(ssid, channel, macAddr);\n}\nreturn count;\n}", "CodeBleu_score": 34.329495139574675}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print\n    'Creating JWT using {} from private key file {}'.format(algorithm, private_key_file)\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 69.15791421017906}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print private_key\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 58.14256423733411}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print(private_key)\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 58.21640720214055}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload\n    if type(payload) is bytes:\n        payload = payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        path = '/tmp/picam.jpg'\n        preview_capture(path)\n        url = upload_file(path, bucket_name)\n        unused_client.publish(topic, url)\n    else:\n        print('off')\n", "CodeBleu_score": 46.397836609587806}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload)\n    print(\"Received message '\" + payload + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        path = \"image.jpg\"\n        preview_capture(path)\n        url = upload_file(path, bucket_name)\n        print(url)\n        unused_client.publish(topic_name, url)\n    else:\n        print(\"off\")\n", "CodeBleu_score": 29.321281279152416}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '\" + payload + \"' on topic '\"\n          + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        path = \"/tmp/image.jpg\"\n        preview_capture(path)\n        url = upload_file(path, bucket_name)\n        unused_client.publish(event_topic, url)\n        print(\"Published image URL to event topic.\")\n    else:\n        print(\"Turning off camera.\")", "CodeBleu_score": 32.00789503820924}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name.\")\n    parser.add_argument(\n        \"--registry_id\",\n        required=True,\n        help=\"Cloud IoT Core registry id\")\n    parser.add_argument(\n        \"--device_id\",\n        required=True,\n        help=\"Cloud IoT Core device id\")\n    parser.add_argument(\n        \"--private_key_file\",\n        required=True,\n        help=\"Path to private key file.\")\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\")\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Type of message to publish.\")\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\")\n    parser.add_argument(\n        \"--mqtt_bridge_port\", default=8883, help=\"MQTT bridge port.\")\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=20,\n        type=int,\n        help=\"Expiration time, in minutes, for JWT tokens.\")\n    parser.add_argument(\n        \"--mqtt_topic\", default=\"/devices/{}/{}\".format(\n            registry_id, device_id), help=\"MQTT topic name.\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 43.209731563652475}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument('project_id', help='GCP cloud project name')\n    parser.add_argument('subscription_name', help='Cloud IoT Core subscription name')\n    parser.add_argument('--algorithm', choices=['RS256', 'ES256'], default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--private_key_file', default='rsa_private.pem', help='Path to private key file.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--num_messages', default=100, type=int, help='Number of messages to publish.')\n    parser.add_argument('--message_type', default='event', choices=['event', 'state'], help='Type of message to publish. \"event\" messages will get QoS 1 assured delivery. \"state\" messages do not.')\n    parser.add_argument('--message_data', default='Hello there', help='Message data sent in messages.')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--verbosity', choices=[x.name for x in io.LogLevel], default=io.LogLevel.INFO.name, help='Logging verbosity')\n    args = parser.parse_args()\n    return args\n", "CodeBleu_score": 36.235664779915396}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name.\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT registry id.\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT device id.\"\n    )\n    parser.add_argument(\n        \"--private_key_file\", required=True, help=\"Path to private key file.\"\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=None,\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\"\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Type of message to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", default=8883, help=\"MQTT bridge port.\"\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=20,\n        type=int,\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n    )\n    parser.add_argument(\n        \"--mqtt_topic\", default=\"events\", help=\"MQTT topic name to publish device events.\"\n    )\n    parser.add_argument(\n        \"--service_account_json\",\n        default=None,\n        help=\"Path to service account json file.\",\n    )\n\n    args = parser.parse_args()\n    return args\n", "CodeBleu_score": 42.76988635561548}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Define the necessary scopes for the Cloud IoT Core service\n    CLOUD_IOT_CORE_SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Define the version of the Cloud IoT Core service to use\n    CLOUD_IOT_CORE_API_VERSION = 'v1'\n\n    # Define the URL to the Cloud IoT Core service\n    CLOUD_IOT_CORE_DISCOVERY_URL = 'https://{api}.googleapis.com/$discovery/rest?version={apiVersion}'\n\n    # Use the discovery URL to build and return the service object\n    return discovery.build(\n        'cloudiot',\n        CLOUD_IOT_CORE_API_VERSION,\n        discoveryServiceUrl=CLOUD_IOT_CORE_DISCOVERY_URL.format(\n            api='cloudiot',\n            apiVersion=CLOUD_IOT_CORE_API_VERSION\n        ),\n        credentials=service_account.Credentials.from_service_account_file(service_account_json, scopes=CLOUD_IOT_CORE_SCOPES)\n    )\n\n", "CodeBleu_score": 23.94642987464923}, {"code": "def get_client(service_account_json)\n\t\n    # Define the necessary scopes for the Cloud IoT Core service\n    CLOUD_CONFIG_SCOPE = 'https://www.googleapis.com/auth/cloud-platform'\n    # Specify the discovery URL for the Cloud IoT Core service\n    CLOUD_CONFIG_DISCOVERY_URL = ('https://{api}.googleapis.com/$discovery/rest?version={apiVersion}'.format(api='cloudiot',apiVersion='v1'))\n    # Load the service account credentials\n    creds = ServiceAccountCredentials.from_json_keyfile_name(service_account_json, CLOUD_CONFIG_SCOPE)\n    # Use the credentials to build the Cloud IoT Core service object\n    return discovery.build('cloudiot', 'v1', credentials=creds, discoveryServiceUrl=CLOUD_CONFIG_DISCOVERY_URL)\n", "CodeBleu_score": 22.279283134716216}, {"code": "def get_client(service_account_json)\n\t\n\n    # Define the necessary API scopes, version, and discovery URL\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n    API_VERSION = 'v1'\n    DISCOVERY_URL = ('https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(API_VERSION))\n\n    # Load the service account credentials\n    service_account_info = json.loads(open(service_account_json).read())\n\n    # Scope the credentials appropriately\n    credentials = ServiceAccountCredentials.from_service_account_info(service_account_info, scopes=SCOPES)\n\n    # Use the credentials to build and return the client for the Cloud IoT Core service using the discovery API URL\n    return discovery.build('cloudiot', API_VERSION, credentials=credentials, discoveryServiceUrl=DISCOVERY_URL)\n\n", "CodeBleu_score": 35.117001495903224}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    if hash_method not in HASH_METHODS:\n        raise ValueError('Invalid hash method')\n\n    asn1_code = HASH_METHODS[hash_method]\n\n    hash_value = asn1_code + hash_value\n\n    padded_hash = _pad_for_signing(hash_value, priv_key.byte_size)\n\n    return priv_key.blinded_encrypt(padded_hash)\n", "CodeBleu_score": 31.987545220766435}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    if hash_method == 'sha256':\n        asn1_hash_method = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'sha384':\n        asn1_hash_method = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'sha512':\n        asn1_hash_method = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n\n    hash_value = asn1_hash_method + hash_value\n\n    padded_hash = _pad_for_signing(hash_value, common.byte_size(priv_key.n))\n\n    signature = priv_key.blinded_encrypt(padded_hash)\n\n    return signature\n\n", "CodeBleu_score": 32.41506026197977}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = HASH_METHODS.get(hash_method)\n    if hash_method_asn1 is None:\n        raise ValueError('Invalid hash method %s' % hash_method)\n\n    hash_asn1 = hash_method_asn1 + hash_value\n    padded_hash = _pad_for_signing(hash_asn1, priv_key.byte_size)\n    signature = priv_key.blinded_encrypt(padded_hash)\n    return signature\n\n", "CodeBleu_score": 35.55635309154697}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    clearsig = transform.bytes2int(signature)\n    clearsig = core.decrypt_int(clearsig, pub_key)\n    method_hash = _find_method_hash(clearsig)\n    computed_hash = compute_hash(message, method_hash)\n    expected_hash = _pad_for_signing(computed_hash, common.byte_size(clearsig))\n    if expected_hash != clearsig:\n        raise VerificationError('Verification failed')\n    return method_hash\n", "CodeBleu_score": 24.872457315817556}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    clearsig = core.decrypt_int(signature, pub_key)\n\n    # find the hash method\n    method_name = _find_method_hash(clearsig)\n\n    # compute the hash of the message\n    hash_value = compute_hash(message, method_name)\n\n    # reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(hash_value, common.byte_size(clearsig))\n\n    # compare the expected hash with the clear signature\n    if clearsig != expected_hash:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 21.851497453605006}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer\n    clearsig = transform.bytes2int(signature)\n\n    # Decrypt the signature\n    clearsig = core.decrypt_int(clearsig, pub_key)\n\n    # Find the hash method\n    method_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    digest = compute_hash(message, method_name)\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(digest, common.byte_size(clearsig))\n\n    # Check the signature\n    if expected_padded_hash != clearsig:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 27.098429659806584}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t epoch = time(NULL);\n\tdebug_printInfo(\"Time: %s\", ctime(&epoch));\n\n\tif (epoch > 0) {\n\t\tupdateJWT(epoch);\n\t\tMQTT_CLIENT_connect();\n\t}\n}", "CodeBleu_score": 20.95617193498137}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tuint8_t res = CRYPTO_CLIENT_getEpochTime(&epoch);\n\tif (res == 0) {\n\t\tdebug_printInfo(\"Time: %s\", ctime(&epoch));\n\t\tupdateJWT(epoch);\n\t\tMQTT_CLIENT_connect();\n\t} else {\n\t\tdebug_printError(\"Time: Error(%d)\", res);\n\t}\n}", "CodeBleu_score": 17.58759138304196}, {"code": "static void connectMQTT(){\n\t\t// Retrieve the current time and convert it to a UNIX time format\n\ttime_t now;\n\ttime(&now);\n\tuint32_t epoch = (uint32_t) now;\n\tdebug_printInfo(\"Current time: %s\", ctime(&now));\n\tdebug_printInfo(\"Current UNIX time: %lu\", epoch);\n\t\n\t// Update the JWT\n\tupdateJWT(epoch);\n\t\n\t// Connect to the MQTT client\n\tMQTT_CLIENT_connect();\n}", "CodeBleu_score": 41.212427351514805}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint8_t digit;\n\tuint32_t value;\n\tint i;\n\n\tvalue = 0;\n\tfor (i = 0; i < width; i++) {\n\t\tdigit = *str;\n\t\tif (digit < '0' || digit > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tvalue = value * 10 + digit - '0';\n\t\tstr++;\n\t}\n\t*num = value;\n\treturn str;\n}", "CodeBleu_score": 28.39457950547835}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\tfor (i=0; i<width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tvalue = value * 10 + (str[i] - '0');\n\t}\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 25.63406146510229}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t val = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tval = val * 10 + (str[i] - '0');\n\t}\n\t*num = val;\n\treturn str + width;\n}", "CodeBleu_score": 26.270626522392345}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n}", "CodeBleu_score": 8.707806121624742}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n}", "CodeBleu_score": 8.707806121624742}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n}", "CodeBleu_score": 8.707806121624742}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tbool found = false;\n\ttimerStruct_t *prev = NULL;\n\ttimerStruct_t *curr = *list;\n\n\t// Make sure list is not NULL and timer is not NULL\n\tif (*list == NULL || timer == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\t// Find the timer in the list\n\twhile (curr != NULL && !found)\n\t{\n\t\tif (curr == timer)\n\t\t{\n\t\t\tfound = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = curr;\n\t\t\tcurr = curr->next;\n\t\t}\n\t}\n\n\t// Make sure timer was found\n\tif (!found)\n\t{\n\t\treturn false;\n\t}\n\n\t// Remove timer from list\n\tif (prev == NULL)\n\t{\n\t\t*list = curr->next;\n\t}\n\telse\n\t{\n\t\tprev->next = curr->next;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 35.753085029480694}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t#line 103 \"C:/Users/pwesty/Desktop/SD-Source/novicedirect-embedded-sd-reader/dataLogger/dataLogger/dataLogger.ino\"\n    if (list == NULL) {\n#line 104 \"C:/Users/pwesty/Desktop/SD-Source/novicedirect-embedded-sd-reader/dataLogger/dataLogger/dataLogger.ino\"\n        return false;\n    }\n    if (timer == NULL) {\n#line 106 \"C:/Users/pwesty/Desktop/SD-Source/novicedirect-embedded-sd-reader/dataLogger/dataLogger/dataLogger.ino\"\n        return false;\n    }\n    if (*list == NULL) {\n#line 108 \"C:/Users/pwesty/Desktop/SD-Source/novicedirect-embedded-sd-reader/dataLogger/dataLogger/dataLogger.ino\"\n        return false;\n    }\n    if (*list == timer) {\n#line 110 \"C:/Users/pwesty/Desktop/SD-Source/novicedirect-embedded-sd-reader/dataLogger/dataLogger/dataLogger.ino\"\n        *list = timer->next;\n        return true;\n    }\n    timerStruct_t *prev = *list;\n    while (prev->next != NULL) {\n#line 114 \"C:/Users/pwesty/Desktop/SD-Source/novicedirect-embedded-sd-reader/dataLogger/dataLogger/dataLogger.ino\"\n        if (prev->next == timer) {\n#line 115 \"C:/Users/pwesty/Desktop/SD-Source/novicedirect-embedded-sd-reader/dataLogger/dataLogger/dataLogger.ino\"\n            prev->next = timer->next;\n            return true;\n        }\n        prev = prev->next;\n    }\n    return false;\n}", "CodeBleu_score": 36.59624765871339}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t// NOTE: listHead must NOT equal NULL at this point.\n\n    if (listHead == NULL)\n    {\n        return false;\n    }\n\n    if (listHead == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *current = listHead;\n    while (current->next != timer)\n    {\n        if (current->next == NULL)\n        {\n            return false;\n        }\n        current = current->next;\n    }\n\n    current->next = timer->next;\n    return true;\n}", "CodeBleu_score": 33.16251367290784}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint ret = 0;\n\tsint8 s8Ret = SOCK_ERR_INVALID_ARG;\n\tM2M_INFO(\"BSD_close socket <%d>\n\", socket);\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\tuint8\tu8Cmd = SOCKET_CMD_CLOSE;\n\t\ttstrCloseCmd strclose;\n\t\tstrclose.sock = socket; \n\t\tstrclose.u16SessionID\t\t= gastrSockets[socket].u16SessionID;\n\t\t\n\t\tgastrSockets[socket].bIsUsed = 0;\n\t\tgastrSockets[socket].u16SessionID =0;\n\t\t\n\t\tif(gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE)\n\t\t{\n\t\t\tu8Cmd = SOCKET_CMD_SSL_CLOSE;\n\t\t}\n\t\ts8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t\tm2m_memset((uint8*)&gastrSockets[socket], 0, sizeof(tstrSocket));\n\t}\n\telse\n\t{\n\t\tret = -1;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 40.86994894955407}, {"code": "int BSD_close(int socket){\n\t\tint ret = -1;\n\tsint8 s8Ret;\n\tM2M_INFO(\"BSD_close: sock to delete <%d>\n\", socket);\n\tif (socket >= 0 && (gastrSockets[socket].bIsUsed == 1)) {\n\t\tuint8 u8Cmd = SOCKET_CMD_CLOSE;\n\t\ttstrCloseCmd strclose;\n\t\tstrclose.sock = socket;\n\t\tstrclose.u16SessionID = gastrSockets[socket].u16SessionID;\n\n\t\tgastrSockets[socket].bIsUsed = 0;\n\t\tgastrSockets[socket].u16SessionID = 0;\n\n\t\tif (gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE) {\n\t\t\tu8Cmd = SOCKET_CMD_SSL_CLOSE;\n\t\t}\n\t\ts8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL, 0, 0);\n\t\tif (s8Ret != SOCK_ERR_NO_ERROR) {\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t\tm2m_memset((uint8*)&gastrSockets[socket], 0, sizeof(tstrSocket));\n\t\tret = 0;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 40.262978699948384}, {"code": "int BSD_close(int socket){\n\t\tint\t\ts8Ret = SOCK_ERR_INVALID;\n\tsint8\ts8BSDRet = SOCK_ERR_INVALID;\n\tif (socket >= 0 && socket < MAX_SOCK_NUM) {\n\t\tif (gastrSockets[socket].bIsUsed) {\n\t\t\ts8BSDRet = close(socket);\n\t\t\tif (s8BSDRet == SOCK_ERR_NO_ERROR) {\n\t\t\t\ts8Ret = BSD_SUCCESS;\n\t\t\t} else {\n\t\t\t\ts8Ret = BSD_ERROR;\n\t\t\t\tbsd_setErrNo(BSD_EUNKNOWN);\n\t\t\t}\n\t\t} else {\n\t\t\ts8Ret = BSD_ERROR;\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t}\n\t} else {\n\t\ts8Ret = BSD_ERROR;\n\t\tbsd_setErrNo(BSD_EBADF);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 31.688548202925215}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint\t\ts8Ret = BSD_ERROR;\n\n\ts8Ret = listen(socket, backlog);\n\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tBSD_setErrno(s8Ret);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 23.920714663219165}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = BSD_ERROR;\n\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ttstrListenCmd\t\tstrListen;\n\n\t\tstrListen.sock = socket;\n\t\tstrListen.u8BackLog = backlog;\n\t\tstrListen.u16SessionID\t\t= gastrSockets[socket].u16SessionID;\n\n\t\tret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);\n\t\tif(ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(ret);\n\t\t\tret = BSD_ERROR;\n\t\t}\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 44.10022420981116}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = BSD_ERROR;\n\n\tif (socket >= 0 && socket < BSD_MAX_SOCKETS) {\n\t\tret = listen(socket, backlog);\n\t\tif (ret == SOCK_ERR_NO_ERROR) {\n\t\t\tret = BSD_SUCCESS;\n\t\t} else {\n\t\t\tbsd_setErrNo(ret);\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 39.24742308802226}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\t// Get current time in UNIX format\n\ttime_t now = time(NULL);\n\tdebug_printInfo(\"Time: %s\", ctime(&now));\n\n\t// Check if time is valid\n\tif (now < 1514764800) {\n\t\tdebug_printError(\"Time is not valid\");\n\t\treturn;\n\t}\n\n\t// Update JWT\n\tupdateJWT(now);\n\n\t// Connect to MQTT broker\n\tMQTT_CLIENT_connect();\n}", "CodeBleu_score": 24.15862085273581}, {"code": "static void connectMQTT(){\n\t\ttime_t now = time(NULL);\n\tstruct tm timeinfo;\n\tlocaltime_r(&now, &timeinfo);\n\tif (timeinfo.tm_year < 2019 || timeinfo.tm_year > 2030) {\n\t\tdebug_printError(\"Invalid current time. Please check your system clock.\");\n\t\treturn;\n\t}\n\tupdateJWT(now);\n\tMQTT_CLIENT_connect();\n}", "CodeBleu_score": 21.487374124872883}, {"code": "static void connectMQTT(){\n\t\t// Retrieve the current time in UNIX format\n\ttime_t epoch = time(NULL);\n\tdebug_printInfo(\"MQTT: Current time: %s\", ctime(&epoch));\n\n\t// Check if the current time is valid\n\tif (epoch < UNIX_OFFSET) {\n\t\tdebug_printError(\"MQTT: Current time is invalid\");\n\t\treturn;\n\t}\n\n\t// Update the JWT with the current time offset\n\tupdateJWT(epoch);\n\n\t// Connect to the MQTT broker\n\tMQTT_CLIENT_connect();\n}", "CodeBleu_score": 50.54262613863397}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tif (mqttState == CONNECTED) {\n\t\tMQTT_Disconnect(&mqttConnectionInfo);\n\t\tdebug_printError(\"Disconnected from cloud service\");\n\t}\n}", "CodeBleu_score": 48.93999638988609}, {"code": "void CLOUD_disconnect(void){\n\t\tif (mqttState == CONNECTED) {\n\t\tMQTT_Disconnect(&client_info);\n\t\tdebug_printError(DEBUG_GENERAL, \"MQTT Disconnected\");\n\t}\n}", "CodeBleu_score": 44.260843001481135}, {"code": "void CLOUD_disconnect(void){\n\t\tMQTT_Disconnect(&client_info);\n\tdebug_printError(\"Disconnected from the cloud service\");\n}", "CodeBleu_score": 15.62501853936536}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrM2mWifiInitParam param;\n\tsint8 ret;\n\tif (passed_wifi_creds) {\n\t\t// WiFi credentials are provided, use them\n\t\tparam.pfAppWifiCb = wifi_cb;\n\t\tparam.pfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, (void *)&wifi_state);\n\t\tret = m2m_wifi_connect((char *)ssid, strlen((char *)ssid), M2M_WIFI_SEC_WPA_PSK, (void *)passphrase, M2M_WIFI_CH_ALL);\n\t} else {\n\t\t// Use default WiFi credentials\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret == M2M_SUCCESS) {\n\t\treturn true;\n\t} else {\n\t\tdebug_printError(\"wifi_connectToAp(): Failed to connect to AP\");\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 54.63653170354005}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tbool wifiConnected = false;\n\ttstrM2mWifiStateChanged *wifiState;\n\tsint8 ret;\n\tuint8_t wifi_creds[128];\n\tuint8_t wifi_creds_len = 0;\n\tuint8_t wifi_auth_type = M2M_WIFI_SEC_OPEN;\n\tuint8_t wifi_ch = 0;\n\n\tif (passed_wifi_creds) {\n\t\twifi_creds_len = sizeof(wifi_creds);\n\t\twifi_creds_len = get_wifi_credentials(wifi_creds, &wifi_creds_len);\n\t\twifi_auth_type = wifi_creds[0];\n\t\twifi_ch = wifi_creds[1];\n\t}\n\n\tret = m2m_wifi_connect((char *)wifi_creds, wifi_creds_len, wifi_auth_type, NULL, wifi_ch);\n\tif (ret == M2M_SUCCESS) {\n\t\twifiConnected = true;\n\t} else {\n\t\tdebug_printError(\"m2m_wifi_connect\", ret);\n\t}\n\n\treturn wifiConnected;\n}", "CodeBleu_score": 45.87034777515447}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\nuri: 'https://api.sensor.community/v1/graphql',\n});\n\nconst response = await client.query({\nquery: gql`\nquery {\nlistSensors {\nid\nname\ndescription\ngeo {\nlatitude\nlongitude\n}\n}\n}\n`,\n});\n\nconsole.log(response);\n\nif (response.data.listSensors) {\nconsole.log('Retrieved sensors');\nresponse.data.listSensors.forEach(sensor => {\nconst marker = document.createElement('div');\nmarker.className = 'marker';\nmarker.id = sensor.id;\n\nconst sensorMarker = new Marker({\nelement: marker,\n});\n\nsensorMarker.setLngLat([sensor.geo.longitude, sensor.geo.latitude]);\n\nsensorMarker.addTo(map);\n});\n}\n}", "CodeBleu_score": 45.30607419345258}, {"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\nuri: \"https://api.githunt.io/graphql\",\n});\n\nconst response = await client.query({\nquery: listSensors,\n});\n\nconsole.log(\"Retrieved sensors from the API\");\n\nresponse.data.listSensors.forEach(sensor => {\nconst marker = document.createElement(\"div\");\nmarker.className = \"marker\";\n\nconst sensorMarker = new Marker({\nelement: marker,\n});\n\nsensorMarker.setLngLat([sensor.geo.longitude, sensor.geo.latitude]);\n\nmap.addLayer(sensorMarker);\n});\n}", "CodeBleu_score": 46.352071000702686}, {"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\nuri: \"https://api.ttn.com/v3/graphql\",\nheaders: {\nauthorization: \"Bearer \" + \"<KEY>\",\n},\n});\n\n// Send a GraphQL query to fetch sensor data\nconst response = await client.query({\nquery: listSensors,\n});\n\n// Log the API response\nconsole.log(response);\n\n// If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\nif (response.data.listSensors) {\nconsole.log(\"Retrieved \" + response.data.listSensors.length + \" sensors\");\nresponse.data.listSensors.forEach((sensor) => {\nconst marker = document.createElement(\"div\");\nmarker.className = \"marker\";\n\n// Create a marker for each sensor\nnew Marker({ element: marker })\n.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n.addTo(map);\n});\n}\n}", "CodeBleu_score": 49.68316176933958}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div')\n\tmarker.id = sensor.id\n\tmarker.className = 'sensor-marker'\n\tmarker.style.backgroundColor = '#000'\n\tmarker.style.border = '2px solid #000'\n\treturn marker\n}", "CodeBleu_score": 41.143065884325054}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className = 'sensor-marker';\n\tmarker.style.backgroundColor = '#000';\n\tmarker.style.border = '2px solid #000';\n\treturn marker;\n}", "CodeBleu_score": 45.12918674114219}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className = 'sensor';\n\tmarker.style.backgroundColor = 'black';\n\tmarker.style.border = '2px solid black';\n\treturn marker;\n}", "CodeBleu_score": 41.721396338553824}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_{module_name}\"\n    module = await async_import_module(hass, module_path)\n    if not hasattr(module, \"async_setup\"):\n        raise HomeAssistantError(f\"Invalid MFA module {module_path}\")\n    return module\n", "CodeBleu_score": 17.41242360831741}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    mfa_module_path = f\"{MFA_MODULE_PREFIX}.{module_name}\"\n    try:\n        mfa_module = await async_import_module(hass, mfa_module_path)\n    except ImportError as error:\n        _LOGGER.error(\n            \"Unable to load authentication module %s: %s\", mfa_module_path, error\n        )\n        raise HomeAssistantError(\n            f\"Unable to load authentication module {mfa_module_path}: {error}\"\n        ) from error\n    if not hasattr(mfa_module, \"async_validate_login\"):\n        _LOGGER.error(\n            \"Authentication module %s does not implement the required async_validate_login method\",\n            mfa_module_path,\n        )\n        raise HomeAssistantError(\n            f\"Authentication module {mfa_module_path} does not implement the required async_validate_login method\"\n        )\n    return mfa_module\n", "CodeBleu_score": 42.130604553019744}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{MFA_MODULE_PREFIX}.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as import_error:\n        _LOGGER.error(\n            \"The multi-factor authentication (MFA) module '%s' could not be loaded: %s\",\n            module_path,\n            import_error,\n        )\n        raise HomeAssistantError(\n            f\"The multi-factor authentication (MFA) module '{module_path}' could not be loaded\"\n        ) from import_error\n    except Exception as exception:\n        _LOGGER.error(\n            \"Unexpected error loading multi-factor authentication (MFA) module '%s': %s\",\n            module_path,\n            exception,\n        )\n        raise HomeAssistantError(\n            f\"Unexpected error loading multi-factor authentication (MFA) module '{module_path}'\"\n        ) from exception\n\n    if not hasattr(module, \"async_setup\"):\n        _LOGGER.error(\n            \"The multi-factor authentication (MFA) module '%s' does not define an async_setup() function\",\n            module_path,\n        )\n        raise HomeAssistantError(\n            f\"The multi-factor authentication (MFA) module '{module_path}' does not define an async_setup() function\"\n        )\n\n    if not hasattr(module, \"DOMAIN\"):\n        _LOGGER.error(\n            \"The multi-factor authentication (MFA) module '%s' does not define a DOMAIN attribute\",\n            module_path,\n        )\n        raise HomeAssistantError(\n            f\"The multi-factor authentication (MFA) module '{module_path}' does not define a DOMAIN attribute\"\n        )\n\n    if not module.DOMAIN:\n        _LOGGER.error(\n            \"The multi-factor authentication (MFA) module '%s' has an empty DOMAIN attribute\",\n            module_path,\n        )\n        raise HomeAssistantError(\n            f\"The multi-factor authentication (MFA) module '{module_path}' has an empty DOMAIN attribute\"\n        )\n\n    if not hasattr(module, \"NAME\"):\n        _LOGGER.error(\n            \"The multi-factor authentication (MFA) module '%s' does not define a NAME attribute\",\n            module_path,\n        )\n        raise HomeAssistantError(\n            f\"The multi-factor authentication (MFA) module '{module_path}' does not define a NAME attribute\"\n       ", "CodeBleu_score": 33.35133836411989}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not self._data_list.get(user_id):\n        self._data_list[user_id] = setup_data\n    else:\n        self._data_list[user_id] = setup_data\n    await self.async_save_data_list()\n", "CodeBleu_score": 25.987288534174674}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if self.data is None:\n        raise RuntimeError(\"No data available\")\n\n    if user_id in self.data:\n        self.data[user_id] = setup_data\n    else:\n        self.data[user_id] = setup_data\n\n    return self.data[user_id]\n\n", "CodeBleu_score": 33.33041880204272}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Extract the PIN from the setup data\n    pin = setup_data.get(\"pin\")\n    if pin is None:\n        raise ValueError(\"No PIN provided\")\n    # Check if the user already has an entry in the internal data list\n    for user in self.data:\n        if user.get(\"user_id\") == user_id:\n            # Update the PIN\n            user[\"pin\"] = pin\n            return\n    # Add a new entry to the internal data list\n    self.data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 49.97080728326647}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if self._load_lock.locked():\n        return\n\n    async with self._load_lock:\n        if self._loaded:\n            return\n\n        data = await self._store.async_load()\n\n        if not data:\n            data = {}\n\n        self._data = data\n        self._loaded = True\n\n        for user_id, user_data in self._data.items():\n            self._users[user_id] = NotifySetting(\n                user_id,\n                user_data.get(\"notify_services\", []),\n                user_data.get(\"notify_events\", []),\n                user_data.get(\"notify_devices\", []),\n                user_data.get(\"notify_user_id\", []),\n                user_data.get(\"notify_group_id\", []),\n                user_data.get(\"notify_broadcast\", []),\n                user_data.get(\"notify_all\", False),\n                user_data.get(\"notify_ios\", False),\n                user_data.get(\"notify_android\", False),\n                user_data.get(\"notify_alexa\", False),\n                user_data.get(\"notify_gios\", False),\n                user_data.get(\"notify_lgw\", False),\n                user_data.get(\"notify_xiaomi\", False),\n                user_data.get(\"notify_windows\", False),\n                user_data.get(\"notify_browser\", False),\n                user_data.get(\"notify_desktop\", False),\n                user_data.get(\"notify_mobile\", False),\n                user_data.get(\"notify_tv\", False),\n                user_data.get(\"notify_door\", False),\n                user_data.get(\"notify_lock\", False),\n                user_data.get(\"notify_problem\", False),\n                user_data.get(\"notify_command\", False),\n                user_data.get(\"notify_service\", False),\n                user_data.get(\"notify_state\", False),\n                user_data.get(\"notify_action\", False),\n                user_data.get(\"notify_automation\", False),\n                user_data.get(\"notify_script\", False),\n                user_data.get(\"notify_scene\", False),\n                user_data.get(\"notify_mqtt\", False),\n                user_data.get(\"notify_zha\", False),\n                user_data.get(\"notify_zwave\", False),\n                user_data.get(\"notify_", "CodeBleu_score": 20.032941465603763}, {"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n\n    async with self._lock:\n        if self._initialized:\n            return\n\n        if not (data := await self._store.async_load()):\n            data = {}\n\n        self._data = data\n\n        if self._data.get(\"version\") != __version__:\n            _LOGGER.warning(\n                \"Your configuration version is outdated, make sure you run the latest version of Home Assistant before reporting a bug.\"\n            )\n\n        if self._data.get(\"notifications\") is None:\n            self._data[\"notifications\"] = {}\n\n        self._notifications = {\n            user_id: NotifySetting(\n                user_id=user_id,\n                name=user_data.get(\"name\"),\n                targets=user_data.get(\"targets\"),\n                default_notification=user_data.get(\"default_notification\"),\n            )\n            for user_id, user_data in self._data[\"notifications\"].items()\n        }\n\n        self._initialized = True\n\n", "CodeBleu_score": 33.26469747028258}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n\n        data = await self._store.async_load()\n        if not data:\n            data = {}\n\n        self._loaded = True\n\n        self._latitude = data.get(\"latitude\")\n        self._longitude = data.get(\"longitude\")\n        self._elevation = data.get(\"elevation\")\n        self._unit_system = data.get(\"unit_system_v2\")\n        self._location_name = data.get(\"location_name\")\n        self._time_zone = data.get(\"time_zone\")\n        self._external_url = data.get(\"external_url\", UNDEFINED)\n        self._internal_url = data.get(\"internal_url\", UNDEFINED)\n        self._currency = data.get(\"currency\")\n        self._country = data.get(\"country\")\n        self._language = data.get(\"language\")\n        self._radius = data.get(\"radius\", DEFAULT_RADIUS)\n\n        for user_id, user_data in data.get(\"users\", {}).items():\n            self._users[user_id] = NotifySetting(\n                user_id=user_id,\n                targets=user_data.get(\"targets\", {}),\n                default_targets=user_data.get(\"default_targets\", {}),\n                created_at=user_data.get(\"created_at\"),\n                updated_at=user_data.get(\"updated_at\"),\n                mode=user_data.get(\"mode\", DEFAULT_MODE),\n            )\n\n", "CodeBleu_score": 29.056656122721336}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    settings = self._settings_data.get(user_id)\n    if settings is None:\n        return False\n    if user_input[CONF_OTP] != settings[CONF_OTP]:\n        return False\n    return True", "CodeBleu_score": 38.47282184909808}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    user_input = user_input.get(ATTR_USER_INPUT)\n    if user_input is None:\n        return False\n    user_input = cast(dict[str, Any], user_input)\n    if ATTR_OTP not in user_input:\n        return False\n    otp = user_input[ATTR_OTP]\n    if otp is None:\n        return False\n    otp = cast(str, otp)\n    if not self._otp_valid(otp):\n        return False\n    return True", "CodeBleu_score": 49.68636535582201}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    user_settings = self._users_data.get(user_id)\n    if user_settings is None:\n        return False\n    return await async_validate_user_input(user_settings, user_input)", "CodeBleu_score": 40.05600552178499}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.async_get_entity_entry(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = perm_lookup.async_get_device_entry(entity_entry.device_id)\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 54.5035466533414}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    if (\n        entity_entry := perm_lookup.async_get_entity_entry(entity_id)\n    ) is None or (\n        device_entry := perm_lookup.async_get_device_entry(entity_entry.device_id)\n    ) is None or (\n        area_id := device_entry.area_id\n    ) is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 47.070289777372395}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.async_get_entity_entry(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.async_get_device_entry(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 62.0269466856611}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    return _merge_policies(policies)\n\n", "CodeBleu_score": 7.368620174802142}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    return _merge_policies(policies)\n", "CodeBleu_score": 7.368620174802142}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    return _merge_policies(policies)\n", "CodeBleu_score": 7.368620174802142}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in AUTH_PROVIDER_MODULES:\n        return AUTH_PROVIDER_MODULES[provider]\n\n    module = await async_import_module(hass, f\"homeassistant.auth_providers.{provider}\")\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed = hass.data.setdefault(DATA_AUTH_PROVIDERS_PROCESSED, set())\n\n    for req in module.REQUIREMENTS:\n        if req in processed:\n            continue\n        processed.add(req)\n        await async_process_requirements(hass, req)\n\n    AUTH_PROVIDER_MODULES[provider] = module\n    return module\n", "CodeBleu_score": 39.9997037216028}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth_providers.{provider}\")\n    except ImportError as err:\n        raise HomeAssistantError(f\"Error loading {provider} auth provider\") from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        processed = hass.data.setdefault(DATA_AUTH_PROVIDERS_PROCESSED, set())\n        if provider in processed:\n            return module\n        processed.add(provider)\n        await async_process_requirements(hass, module.REQUIREMENTS)\n\n    return module\n", "CodeBleu_score": 43.38010370265812}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth_providers.{provider}\")\n    except ImportError as err:\n        raise HomeAssistantError(\n            f\"Error loading {provider} auth provider - {err}\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if module.REQUIREMENTS == \"skip\":\n        return module\n    if not isinstance(module.REQUIREMENTS, list):\n        raise HomeAssistantError(\n            f\"Invalid REQUIREMENTS in {provider} auth provider - {module.REQUIREMENTS}\"\n        )\n    processed = hass.data.setdefault(DATA_AUTH_PROVIDERS_PROCESSED, set())\n    for requirement in module.REQUIREMENTS:\n        if requirement in processed:\n            continue\n        processed.add(requirement)\n        await async_process_requirements(hass, requirement)\n    return module\n", "CodeBleu_score": 48.61492727773983}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid credentials\")\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth(\"Invalid credentials\")\n    else:\n        raise InvalidAuth(\"Invalid credentials\")\n", "CodeBleu_score": 37.44392098961317}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth(\"Invalid username or password\")\n    raise InvalidAuth(\"Invalid username or password\")", "CodeBleu_score": 46.53049791797902}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b'', bcrypt.gensalt())\n    for user in self.users:\n        if user['username'] == username:\n            password_hash = base64.b64decode(user['password'])\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth('Invalid username or password')\n    raise InvalidAuth('Invalid username or password')\n", "CodeBleu_score": 45.46365737420612}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    self.users.remove(username)\n\n", "CodeBleu_score": 24.731220588872958}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    self.users.pop(username)\n", "CodeBleu_score": 24.664428813842715}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 37.1802918522876}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        self._data = {}\n    try:\n        await self.async_remove_auth(credentials.data[CONF_USERNAME])\n        await self.async_save()\n    except KeyError:\n        pass\n", "CodeBleu_score": 39.71172784950361}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n    try:\n        await self._store.async_remove_auth(credentials.data[\"username\"])\n    except KeyError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 56.084486196710394}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        self._data = {}\n    if self._data.get(\"auth\") is None:\n        self._data[\"auth\"] = {}\n    try:\n        del self._data[\"auth\"][credentials.data[\"username\"]]\n    except KeyError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 45.39721027687473}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    start = time.monotonic()\n    for thread in threads:\n        thread_timeout = timeout - (time.monotonic() - start)\n        if thread_timeout <= 0:\n            break\n        thread.join(thread_timeout)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            joined.add(thread)\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                async_raise(thread.ident, SystemExit)\n            except OSError:\n                pass\n    return threads - joined\n\n", "CodeBleu_score": 51.89772832626836}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    if timeout is None:\n        timeout = 1.0\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            async_raise(thread.ident, SystemExit)\n        joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 59.32683798725276}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    threads_to_join = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is not None:\n                threads_to_join.add(thread)\n                timeout_for_thread = timeout / len(threads_to_join)\n            else:\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    for thread in threads_to_join:\n        thread.join(timeout_for_thread)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            joined.add(thread)\n        else:\n            joined.add(thread)\n    for thread in threads - joined:\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 56.94658160486177}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    _LOGGER.warning(\"Attempting deadlock-safe shutdown\")\n    _LOGGER.warning(\"Shutting down %d threads\", threading.active_count())\n    timeout = SHUTDOWN_TIMEOUT / (threading.active_count() - 1)\n    for thread in threading.enumerate():\n        if thread != threading.main_thread() and not thread.daemon and thread.is_alive():\n            thread.join(timeout=timeout)\n            if thread.is_alive():\n                _LOGGER.warning(\"Thread %s did not stop\", thread.name)\n    _LOGGER.warning(\"Deadlock-safe shutdown complete\")\n", "CodeBleu_score": 30.785112362736367}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    _LOGGER.warning(\"Shutting down\")\n    non_main_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread != threading.main_thread() and not thread.daemon\n    ]\n    timeout = SHUTDOWN_TIMEOUT / len(non_main_threads)\n    for thread in non_main_threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\"Unable to join thread %s\", thread.name)\n\n", "CodeBleu_score": 35.15679397853774}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    if threading.current_thread() != threading.main_thread():\n        raise RuntimeError(\"deadlock_safe_shutdown must be called from the main thread\")\n    timeout = _shutdown_timeout / (len(threading.enumerate()) - 1)\n    for thread in threading.enumerate():\n        if thread != threading.main_thread() and not thread.daemon and thread.is_alive():\n            thread.join(timeout)\n            if thread.is_alive():\n                _LOGGER.warning(\"Unable to join thread %s within timeout of %s seconds\", thread.name, timeout)\n", "CodeBleu_score": 37.60949780177507}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher_send_internal(\n            self._async_dispatcher_signal, remaining_with_setup_started\n        )\n    else:\n        self._async_dispatcher_send_internal(\n            self._async_dispatcher_signal_no_setups, None\n        )\n    self._async_dispatcher_remaining_with_setup_started = remaining_with_setup_started\n\n", "CodeBleu_score": 39.59203881932475}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_with_setup_started = remaining_with_setup_started != {}\n\n", "CodeBleu_score": 39.61134488043655}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    else:\n        self._async_dispatcher_send_internal(None)\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n", "CodeBleu_score": 36.11699527891818}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if (\n        not config.config_type\n        or config.config_type != ConfigType.CUSTOMIZE\n        or config.key != \"bluetooth.py\"\n    ):\n        return\n\n    try:\n        content = config.async_get_original_content()\n    except FileNotFoundError:\n        content = None\n\n    generated = generate_and_validate(integrations)\n\n    if content == generated:\n        return\n\n    config.add_error(\n        \"bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n        fixable=True,\n    )\n\n", "CodeBleu_score": 50.80064515691335}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    config.cache[\"bluetooth\"] = generate_and_validate(integrations)\n    config.cache[\"bluetooth_integrations\"] = [\n        domain for domain in sorted(integrations) if integrations[domain].manifest.get(\"bluetooth\")\n    ]\n\n    if not config.specific_integrations:\n        return\n\n    if config.cache[\"bluetooth\"] == config.cache[\"bluetooth_generated\"]:\n        return\n\n    config.add_error(\n        \"The bluetooth.py file for Home Assistant is not up to date. Run python3 -m script.hassfest\",\n        fixable=True,\n    )\n\n", "CodeBleu_score": 48.791537245606904}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    config.cache[\"bluetooth\"] = generate_and_validate(integrations)\n\n    if config.specific_integrations:\n        return\n\n    current_content = config.cache.get(\"bluetooth_current_content\")\n\n    if current_content is None:\n        try:\n            with open(config.root / \"homeassistant/generated/bluetooth.py\") as fp:\n                current_content = fp.read()\n        except OSError:\n            config.cache[\"bluetooth_current_content\"] = \"\"\n            return\n\n        config.cache[\"bluetooth_current_content\"] = current_content\n\n    if config.cache[\"bluetooth\"] != current_content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n\n", "CodeBleu_score": 60.56259857822845}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp oauth2TokenResponse\n\tvar e error\n\t// Send a POST request to the Dropbox OAuth2 token endpoint with the refresh token, app key, and app secret.\n\t// If the request succeeds, it updates the access token; otherwise, it logs the response and returns an error if any issues occur.\n\tif err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(oauth2TokenURL); err != nil {\n\t\tlogger.Error(err)\n\t\treturn err\n\t}\n\t// Update the access token\n\td.AccessToken = resp.AccessToken\n\t// Update the refresh token\n\td.RefreshToken = resp.RefreshToken\n\t// Update the token type\n\td.TokenType = resp.TokenType\n\t// Update the expiry time\n\td.Expiry = time.Now().Add(time.Duration(resp.ExpiresIn) * time.Second)\n\t// Return nil\n\treturn nil\n}", "CodeBleu_score": 62.171498905682284}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Set up the logger with the current context\n\tlogger := d.Logger.With(\n\t\tzap.String(\"dropbox\", d.Name),\n\t\tzap.String(\"function\", \"refreshToken\"),\n\t)\n\n\t// Set up the request\n\treq := base.RestyClient.R().SetResult(&d.AccessToken).SetError(&d.Error).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenEndpoint)\n\n\t// Send the request\n\tlogger.Info(\"Sending request to refresh the access token\")\n\tresp, e := req.Send()\n\tif e != nil {\n\t\tlogger.Error(\"Failed to refresh the access token\", zap.Error(e))\n\t\treturn e\n\t}\n\n\t// Log the response\n\tlogger.Info(\"Successfully refreshed the access token\", zap.String(\"response\", resp.String()))\n\n\t// Return any errors\n\treturn d.Error\n}", "CodeBleu_score": 53.928870888050696}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp TokenResponse\n\tvar e error\n\n\t// Send POST request to the Dropbox OAuth2 token endpoint\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.TokenURL)\n\n\t// If the request succeeded, update the access token\n\tif e == nil {\n\t\td.AccessToken = resp.AccessToken\n\t\td.RefreshToken = resp.RefreshToken\n\n\t\t// Log the refresh token\n\t\tlogger.Info(\"Successfully refreshed access token\",\n\t\t\tzap.String(\"refresh_token\", d.RefreshToken),\n\t\t\tzap.String(\"access_token\", d.AccessToken),\n\t\t)\n\n\t\t// Return nil\n\t\treturn nil\n\t}\n\n\t// Otherwise, log the error and return it\n\tlogger.Error(\"Failed to refresh access token\",\n\t\tzap.Error(e),\n\t)\n\treturn e\n}", "CodeBleu_score": 56.73382628462518}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R()\n\treq.SetResult(resp)\n\treq.SetError(base.ErrResponse)\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\treq.SetQueryParam(\"prettyPrint\", \"false\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tfor {\n\t\tvar err error\n\t\tvar respBody []byte\n\t\trespBody, err = req.Execute(method, url)\n\t\tif err != nil {\n\t\t\tif strings.Contains(err.Error(), \"401\") {\n\t\t\t\tif d.refreshToken() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\treturn respBody, nil\n\t}\n}", "CodeBleu_score": 53.150060022733655}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size\n\tchunkSize := d.getChunkSize(stream.GetSize())\n\t// Create a new request\n\treq := d.client.NewRequest(\"POST\", url)\n\t// Upload each chunk\n\tfinish := int64(0)\n\tfor {\n\t\t// Check for context cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t\t// Create a new chunk reader\n\t\tchunkReader := io.LimitReader(stream.GetReadCloser(), chunkSize)\n\t\t// Create a new chunk writer\n\t\tchunkWriter := d.newChunkWriter(req, finish, chunkSize)\n\t\t// Copy the chunk data from the reader to the writer\n\t\tif _, err := io.Copy(chunkWriter, chunkReader); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Close the writer\n\t\tif err := chunkWriter.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Check for context cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t\t// Set the finish offset\n\t\tfinish += chunkSize\n\t\t// Check if the entire file has been uploaded\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t\t// Check if the chunk size is greater than the file size\n\t\tif chunkSize > stream.GetSize()-finish {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t}\n\t// Execute the request\n\t_, err := d.client.Do(ctx, req)\n\treturn err\n}", "CodeBleu_score": 48.447425069797276}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := stream.GetChunkSize()\n\tfinish := int64(0)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tif err := d.uploadChunk(ctx, stream, url, finish, chunkSize); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfinish += chunkSize\n\t\t}\n\t}\n}", "CodeBleu_score": 22.063711123147236}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size\n\tchunkSize := d.calculateChunkSize(stream)\n\t// Upload each chunk sequentially\n\tfinish := int64(0)\n\tfor {\n\t\t// Check for context cancellation\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\t// Upload the current chunk\n\t\tif err := d.uploadChunk(ctx, stream, url, finish, chunkSize); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Update the finish position\n\t\tfinish += chunkSize\n\t\t// Check if the entire file has been uploaded\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t}\n\t// Complete the upload\n\tif err := d.completeUpload(ctx, stream, url); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.370594811556174}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context.\n\tif err := ctx.Bind(new(UnmountStorageRequest)); err != nil {\n\t\treturn common_err.GetBadRequestResponse(ctx, err)\n\t}\n\t// Retrieve the \"mount_point\" value.\n\tmountPoint := strings.ReplaceAll(ctx.JSON(new(UnmountStorageRequest)).(*UnmountStorageRequest).MountPoint, \"\\\\\", \"/\")\n\t// If the mount point is empty, return a client error response.\n\tif mountPoint == \"\" {\n\t\treturn common_err.GetBadRequestResponse(ctx, errors.New(\"the mount point cannot be empty\"))\n\t}\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn common_err.GetInternalServerResponse(ctx, err)\n\t}\n\t// Delete the corresponding configuration.\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn common_err.GetInternalServerResponse(ctx, err)\n\t}\n\t// Return a success response.\n\treturn ctx.JSON(new(UnmountStorageResponse), new(UnmountStorageResponse))\n}", "CodeBleu_score": 44.07452360814004}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context\n\tif err := ctx.Bind(new(UnmountStorageRequest)); err != nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\n\t// Retrieve the \"mount_point\" value\n\tmountPoint := ctx.JSON().Get(\"mount_point\")\n\n\t// If the mount point is empty, return a client error response\n\tif mountPoint == \"\" {\n\t\treturn common_err.NewBadRequestError(\"Mount point cannot be empty\")\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn common_err.NewServiceError(err.Error())\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn common_err.NewServiceError(err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, \"Storage unmounted\")\n}", "CodeBleu_score": 38.72497948835102}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context\n\tif err := ctx.Bind(new(UnmountStorageRequest)); err != nil {\n\t\treturn err\n\t}\n\n\t// Retrieve the \"mount_point\" value\n\tmountPoint := ctx.JSON().Get(\"mount_point\").MustString()\n\tif mountPoint == \"\" {\n\t\treturn client_err.New(common_err.GetMsg(ctx, \"mount_point_empty\"))\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn service_err.New(common_err.GetMsg(ctx, err.Error()))\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn service_err.New(common_err.GetMsg(ctx, err.Error()))\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, SuccessResponse{\n\t\tSuccess: true,\n\t})\n}", "CodeBleu_score": 43.697508586157866}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingParam, \"path\"))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\t// Return an error message\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound, filePath))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 38.697178947445835}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingParam, \"path\"))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound, filePath))\n\t}\n\n\t// Serve the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 42.230113230962715}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingPathParam))\n\t}\n\n\t// Check if the file exists.\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client.\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.85894703362133}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification.\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"status\": \"success\",\n\t})\n}", "CodeBleu_score": 60.44475812316163}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tmessage := make(map[string]string)\n\terr := ctx.Bind(&message)\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification.\n\terr = service.MyService.Notify().SendNotify(name, message)\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusCreated)\n}", "CodeBleu_score": 53.95897219982601}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification.\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusOK)\n}", "CodeBleu_score": 51.59466780442467}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection.\n\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service.\n\tgo sendMeg()\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\tmt, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// The WebSocket connection has been closed.\n\t\t\treturn nil\n\t\t}\n\n\t\t// Print the message type and message.\n\t\tfmt.Println(mt, string(msg))\n\t}\n}", "CodeBleu_score": 47.927036746621646}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\n\t// Upgrade initial GET request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start sending messages to the new connection\n\tgo func() {\n\t\tfor {\n\t\t\t// Read message from WebSocket connection\n\t\t\tmsgType, msg, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\t// Check if the error is due to closed connection\n\t\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {\n\t\t\t\t\tlog.Printf(\"error: %v\n\", err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Print message type, message, and error (if any)\n\t\t\tlog.Printf(\"message type: %v\n\", msgType)\n\t\t\tlog.Printf(\"message: %s\n\", msg)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"error: %v\n\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 42.615869375599345}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running\n\tgo SendMeg()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(msgType, string(msg), err)\n\t}\n}", "CodeBleu_score": 46.85121939062967}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system hardware information\n\tsysInfo := system.HardwareInfo()\n\n\t// Check if the system has a CPU\n\tif sysInfo.CPU == nil {\n\t\t// Return a success message\n\t\treturn ctx.JSON(http.StatusOK, common_err.NewBadRequest(\"The system has no CPU\"))\n\t}\n\n\t// Return the system hardware information\n\treturn ctx.JSON(http.StatusOK, sysInfo)\n}", "CodeBleu_score": 12.972950554821583}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system hardware information\n\thardwareInfo := service.MyService.System().GetHardwareInfo()\n\n\t// Check if the CPU information is available\n\tif hardwareInfo.CPU != nil {\n\t\t// Return the system hardware information as a JSON response\n\t\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n\t}\n\n\t// Return an error response\n\treturn common_err.NewBadRequestError(\"CPU information is not available\")\n}", "CodeBleu_score": 16.78777551324718}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Create an empty map to hold the hardware information\n\thardwareInfo := make(map[string]interface{})\n\n\t// Get the drive model and architecture\n\tdriveInfo, err := GetDriveInfo()\n\tif err != nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\thardwareInfo[\"drive_model\"] = driveInfo.Model\n\thardwareInfo[\"drive_architecture\"] = driveInfo.Architecture\n\n\t// Get the CPU information\n\tcpuInfo, err := GetCpuInfo()\n\tif err != nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\thardwareInfo[\"cpu_info\"] = cpuInfo\n\n\t// Get the device tree information\n\tdeviceTreeInfo, err := GetDeviceTree()\n\tif err != nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\thardwareInfo[\"device_tree\"] = deviceTreeInfo\n\n\t// Return the hardware information as a JSON response\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}", "CodeBleu_score": 23.663090840032883}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\t// Get a list of services matching \"casaos*\"\n\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Separate the services into running and not running lists based on their status\n\trunningServices := []string{}\n\tnotRunningServices := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\t// Return a map with boolean keys indicating the running status, each pointing to the corresponding list of service names\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 66.64870968879228}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif strings.Contains(service, \"running\") {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 63.50581001920232}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif strings.Contains(service.Name, \"casaos\") {\n\t\t\tif service.ActiveState == \"active\" {\n\t\t\t\trunning = append(running, service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 69.81784382685714}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Create a new event with the given name.\n\tevent := i.bus.NewEvent(name)\n\n\t// Marshal the message values to JSON strings and set them on the event.\n\tfor k, v := range message {\n\t\tevent.Set(k, json.Marshal(v))\n\t}\n\n\t// Publish the event to the message bus and log any errors.\n\tresponse := i.bus.PublishEventWithResponse(context.Background(), event)\n\tif response.Status() != http.StatusOK {\n\t\ti.logger.Error(\"failed to send notification\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(response.Error()))\n\t}\n}", "CodeBleu_score": 34.76744181166521}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tctx := context.Background()\n\tlogger := i.logger.With(zap.String(\"name\", name))\n\tmessageJSON, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\terr = i.messageBus.PublishEventWithResponse(ctx, name, messageJSON)\n\tif err != nil {\n\t\tlogger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\tlogger.Info(\"published event\")\n}", "CodeBleu_score": 43.367719196562696}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tctx := context.Background()\n\tevent := notify.NewNotifyEvent(name, message)\n\tresponse := i.messageBus.PublishEventWithResponse(ctx, event)\n\tif response.Status() != eventbus.StatusOK {\n\t\ti.logger.Error(\n\t\t\t\"failed to send notify event\",\n\t\t\tzap.String(\"name\", name),\n\t\t\tzap.Any(\"message\", message),\n\t\t\tzap.Error(response.Error()),\n\t\t\tzap.Int(\"status_code\", response.StatusCode()),\n\t\t)\n\t}\n}", "CodeBleu_score": 29.775363721007142}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.server)\n\terr := client.Init()\n\tif err != nil {\n\t\tclient.SetServer(fmt.Sprintf(\"Error: %s\", err))\n\t}\n\treturn client\n}", "CodeBleu_score": 25.579422110443073}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.conn)\n\tserver := c.runtime_path\n\tif server == \"\" {\n\t\tserver = \"The server address could not be retrieved. \" +\n\t\t\t\"Please check that the runtime is running.\"\n\t}\n\tclient.SetServer(server)\n\treturn client\n}", "CodeBleu_score": 24.827508954015908}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.server)\n\tc.server = client.Client.Endpoint\n\treturn client\n}", "CodeBleu_score": 20.46418908482201}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \",\") {\n\t\tip = strings.Split(ip, \", \")[0]\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.67547999187685}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\t// Remove port\n\tif strings.Contains(ip, \":\") {\n\t\tip = strings.Split(ip, \":\")[0]\n\t}\n\t// Remove IPv6 prefix\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" || ip == \"127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 66.49570744007876}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\t// The IP address is a comma delimited list, so we need to split\n\t// it and take the first one.\n\tips := strings.Split(ip, \",\")\n\tip = strings.TrimSpace(ips[0])\n\n\t// If the IP address is a loopback address, then we need to\n\t// convert it to 127.0.0.1.\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.HasPrefix(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 55.652644825236386}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Create the modules directory if it does not exist.\n\tif _, err := os.Stat(c.modulesDir); os.IsNotExist(err) {\n\t\tif err := os.Mkdir(c.modulesDir, 0755); err != nil {\n\t\t\tlogger.Error(err)\n\t\t}\n\t}\n\n\t// Create the entry file if it does not exist.\n\tif _, err := os.Stat(c.entryFile); os.IsNotExist(err) {\n\t\tif err := os.Create(c.entryFile); err != nil {\n\t\t\tlogger.Error(err)\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files.\n\tvar modules []string\n\tif files, err := ioutil.ReadDir(c.modulesDir); err == nil {\n\t\tfor _, file := range files {\n\t\t\tif file.IsDir() {\n\t\t\t\tmodules = append(modules, file.Name())\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlogger.Error(err)\n\t}\n\n\t// Concatenate each entry.json file into a single JSON array.\n\tvar entries []string\n\tfor _, module := range modules {\n\t\tif file, err := os.Open(filepath.Join(c.modulesDir, module, \"entry.json\")); err == nil {\n\t\t\tif content, err := ioutil.ReadAll(file); err == nil {\n\t\t\t\tentries = append(entries, string(content))\n\t\t\t} else {\n\t\t\t\tlogger.Error(err)\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.Error(err)\n\t\t}\n\t}\n\n\t// Write the JSON array to the entry file.\n\tif err := ioutil.WriteFile(c.entryFile, []byte(\"[\n\"+strings.Join(entries, \",\n\")+\"\n]\"), 0644); err != nil {\n\t\tlogger.Error(err)\n\t}\n}", "CodeBleu_score": 44.84286088220303}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tentryFilePath := filepath.Join(c.modulesDir, \"entry.json\")\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t// The entry file does not exist, so create it\n\t\tif err := os.WriteFile(entryFilePath, []byte(\"[]\"), 0644); err != nil {\n\t\t\tc.logger.Error(\"failed to create system entry file\", zap.Error(err))\n\t\t}\n\t}\n\t// Read each module directory for entry.json files\n\tmodules, err := os.ReadDir(c.modulesDir)\n\tif err != nil {\n\t\tc.logger.Error(\"failed to read module directories\", zap.Error(err))\n\t\treturn\n\t}\n\tvar moduleEntries []ModuleEntry\n\tfor _, module := range modules {\n\t\t// Read each entry.json file in the module directory\n\t\tmoduleEntryFilePath := filepath.Join(c.modulesDir, module.Name(), \"entry.json\")\n\t\tmoduleEntryFile, err := os.ReadFile(moduleEntryFilePath)\n\t\tif err != nil {\n\t\t\tc.logger.Error(\"failed to read module entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\t// Deserialize the module entry JSON\n\t\tvar moduleEntry ModuleEntry\n\t\tif err := json.Unmarshal(moduleEntryFile, &moduleEntry); err != nil {\n\t\t\tc.logger.Error(\"failed to deserialize module entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\t// Append the module entry to the list of module entries\n\t\tmoduleEntries = append(moduleEntries, moduleEntry)\n\t}\n\t// Serialize the list of module entries into a JSON array\n\tmoduleEntriesJSON, err := json.Marshal(moduleEntries)\n\tif err != nil {\n\t\tc.logger.Error(\"failed to serialize module entries\", zap.Error(err))\n\t\treturn\n\t}\n\t// Write the list of module entries to the entry file\n\tif err := os.WriteFile(entryFilePath, moduleEntriesJSON, 0644); err != nil {\n\t\tc.logger.Error(\"failed to write system entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 42.07297685380434}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range ifaces {\n\t\tif i.Name == \"eth0\" {\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No MAC address found\")\n}", "CodeBleu_score": 53.27580800904737}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnetNames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tfor _, name := range netNames {\n\t\t\tif name == iface.Name {\n\t\t\t\treturn iface.MacAddress, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 58.68953853173067}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.System().GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"could not find matching interface\")\n}", "CodeBleu_score": 63.20876599726447}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tint32_t tmp;\n\n\t/* add a reference to the request object */\n\ttmp = atomic_add_fetch_64(&pRequest->refCount, 1);\n\tif (tmp < 1) {\n\t\trc = -1;\n\t\tgoto cleanup;\n\t}\n\n\t/* increment the request count for the associated TSC object */\n\ttmp = atomic_add_fetch_64(&pTscObj->requestCount, 1);\n\tif (tmp < 1) {\n\t\trc = -1;\n\t\tgoto cleanup;\n\t}\n\n\t/* update the application's request summary */\n\tif (pTscObj->appInfo.appType != TSC_APP_TYPE_NONE) {\n\t\ttmp = atomic_add_fetch_64(&pTscObj->appInfo.requestCount, 1);\n\t\tif (tmp < 1) {\n\t\t\trc = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ttmp = atomic_add_fetch_64(&pTscObj->appInfo.currentRequestCount, 1);\n\t\tif (tmp < 1) {\n\t\t\trc = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* log debug information about the new request */\n\tTSC_LOG_DEBUG(\"request=%p, tsc=%p, type=%d, status=%d, refCount=%d, requestCount=%d, currentRequestCount=%d\", pRequest, pTscObj, pRequest->type, pRequest->status, pRequest->refCount, pTscObj->requestCount, pTscObj->appInfo.currentRequestCount);\n\ncleanup:\n\treturn rc;\n}", "CodeBleu_score": 47.238884125457034}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = pRequest->pQuery->pDb;\n\tif (pDb == NULL) {\n\t\treturn false;\n\t}\n\tif (strcmp(pDb, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\tchar *pDbName = pDb;\n\twhile (*pDbName != '\\0') {\n\t\tif (*pDbName == '.') {\n\t\t\tpDbName++;\n\t\t}\n\t\tpDbName++;\n\t}\n\twhile (*pDb != '\\0') {\n\t\tif (*pDb == '.') {\n\t\t\t*pDb = '\\0';\n\t\t\tpDb++;\n\t\t}\n\t\tpDb++;\n\t}\n\tif (strcmp(pDb, exceptDb) == 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.026820254995755}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDbName = pRequest->pDbName;\n\tchar *pDbNameEnd = pDbName + strlen(pDbName);\n\n\tif (pDbName == NULL) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * The primary database of the request is not the exception database.\n\t */\n\tif (strcmp(pDbName, exceptDb) != 0) {\n\t\t/*\n\t\t * Iterate through the list of databases in the request, ignoring any schema prefixes.\n\t\t */\n\t\twhile (pDbName < pDbNameEnd) {\n\t\t\t/*\n\t\t\t * Check if the current database matches the exception database.\n\t\t\t */\n\t\t\tif (strncmp(pDbName, exceptDb, strlen(exceptDb)) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Skip past the current database name.\n\t\t\t */\n\t\t\twhile (*pDbName != 0 && pDbName < pDbNameEnd) {\n\t\t\t\tpDbName++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Skip past the schema prefix.\n\t\t\t */\n\t\t\twhile (*pDbName != 0 && pDbName < pDbNameEnd) {\n\t\t\t\tpDbName++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 43.54458364425934}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TCLI_NEED_REDIRECT_ERROR) {\n\t\tif (msgType == TMSG_FETCH_RESPONSE || msgType == TMSG_EXECUTE_RESPONSE || msgType == TMSG_CLOSE_RESULTSET_RESPONSE || msgType == TMSG_FETCH_NEXT_RESPONSE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 44.526455512978}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tTaoHashIterate(pRequests, (void (*)(void *, void *))stopRequest, NULL);\n}", "CodeBleu_score": 6.67560354338488}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint32_t ret = 0;\n\tSHashIterator iter;\n\tint64_t rid;\n\ttaos_stop_query *pQuery;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\tfor (iter = sh_begin(pRequests); iter != sh_end(pRequests); iter = sh_next(iter)) {\n\t\trid = (int64_t)iter->key;\n\t\tpQuery = (taos_stop_query *)iter->value;\n\n\t\tif (pQuery != NULL) {\n\t\t\tret = acquireRequest(rid);\n\t\t\tif (ret != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttaos_stop_query(pQuery);\n\t\t\treleaseRequest(rid);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.83454932342194}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\t/*\n\t * Iterate through the hash table and stop the query associated with each request.\n\t */\n\tSHashIter iter;\n\tSHashObj *pRequest;\n\tint64_t rid;\n\n\tfor (pRequest = s_hash_iter_init(pRequests, &iter); pRequest != NULL; pRequest = s_hash_iter_next(&iter)) {\n\t\trid = (int64_t)s_hash_obj_key(pRequest);\n\t\tacquireRequest(rid);\n\t\tif (pRequest->data != NULL) {\n\t\t\ttaos_stop_query(pRequest->data);\n\t\t\tpRequest->data = NULL;\n\t\t}\n\t\treleaseRequest(rid);\n\t}\n}", "CodeBleu_score": 47.359084634829415}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&clientStop, 0, 1) != 0) {\n\t\ttscLogMessage(TSC_LOG_TYPE_ERROR, \"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\twhile (clientStop != 0) {\n\t\ttscSleep(100);\n\t}\n}", "CodeBleu_score": 58.755242600581916}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 0, 1) == 0) {\n\t\ttscLogMessage(TSC_LOG_ERROR, \"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\n\twhile (clientStop != 0) {\n\t\ttscSleep(1);\n\t}\n}", "CodeBleu_score": 55.835553141372664}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportingEnabled) {\n\t\tif (atomic_val_compare_exchange_32(&clientStop, 0, 1)) {\n\t\t\twhile (clientStop) {\n\t\t\t\ttscSleep(1000);\n\t\t\t}\n\t\t} else {\n\t\t\ttscLog(\"Crash report thread is already stopped\");\n\t\t}\n\t}\n}", "CodeBleu_score": 49.27760347654687}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tCallbackData *data = (CallbackData *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 77.30931228824086}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tstruct CallbackData *data = (struct CallbackData *) callbackData;\n\n\tdata->contentLength = properties->contentLength;\n\treturn S3StatusOK;\n}", "CodeBleu_score": 50.504017212735164}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tstruct callbackData *data = (struct callbackData *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 76.32571732613623}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n  taosMkDir(path);\n#else\n  taosMkDir(tsCheckpointBackupDir);\n#endif\n  removeEmptyDir();\n\n  if (generateConfigFile(tsRsyncConfFile) != 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --config=%s\", tsRsyncConfFile);\n  uDebug(\"[rsync] command:%s\", command);\n\n  if (system(command) != 0) {\n    uError(\"[rsync] start rsync error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n  uInfo(\"[rsync] start rsync ok\");\n}", "CodeBleu_score": 40.984394948008465}, {"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosMkDir(tsCheckpointBackupDir, 0700) != 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsRsyncConfFile) != 0) {\n    uError(\"[rsync] generate rsync conf file error, conf:%s\", tsRsyncConfFile);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --config %s\", tsRsyncConfFile);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start rsync server error, cmd:%s\", cmd);\n  } else {\n    uInfo(\"[rsync] rsync server started, cmd:%s\", cmd);\n  }\n}", "CodeBleu_score": 55.13176278216311}, {"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n  taosMulMkDir(path);\n#else\n  taosMulMkDir(tsCheckpointBackupDir);\n#endif\n  removeEmptyDir();\n  if (generateConfigFile(tsRsyncConfFile) != 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4, \"%s -c %s\", tsRsyncBin, tsRsyncConfFile);\n  uInfo(\"[rsync] start cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n  uInfo(\"[rsync] start success\");\n}", "CodeBleu_score": 45.02410315823834}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher \" + dispatcherId + \" is not registered\");\n\t}\n}", "CodeBleu_score": 45.52753857572373}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"Dispatcher \" + dispatcherId + \" is not registered\");\n\t}\n\tdispatcher.shutdownNow();\n\tdispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 58.94043891041116}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n}", "CodeBleu_score": 47.204727966519506}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//        List<TbActorId> children = childrenMap.get(parent);\n//        if (children != null) {\n//            children.stream()\n//                    .filter(childFilter)\n//                    .forEach(child -> tell(child, msg, highPriority));\n//        } else {\n//            log.warn(\"[{}] No children found for parent [{}]\", self, parent);\n//        }\n    }", "CodeBleu_score": 13.466092382761225}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t forEach(parent, childFilter, child -> {\n try {\n tell(child, msg, highPriority);\n } catch (Exception e) {\n log.warn(\"Failed to send message [{}] to actor [{}]\", msg, child, e);\n }\n });\n }", "CodeBleu_score": 36.742445941259895}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t forEachChild(parent, childFilter, child -> {\n if (highPriority) {\n tell(child, msg, true);\n } else {\n tell(child, msg, false);\n }\n });\n }", "CodeBleu_score": 22.96783121264781}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (!destroying.get() || (highPriority && msg.getMsgType() == RULE_NODE_UPDATED_MSG)) {\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue(true);\n} else if (highPriority && msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n    log.trace(\"[{}] Actor is being destroyed, re-initializing\", selfId);\n    initActor();\n} else {\n    msg.onTbActorStopped();\n}\n}", "CodeBleu_score": 52.54309663613014}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\nif (log.isTraceEnabled()) {\n            log.trace(\"[{}] Enqueueing msg: {} [{}]\", selfId, msg, highPriority ? \"high-priority\" : \"normal-priority\");\n        }\n        if (destroying.get() == DESTROYING) {\n            if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n                if (failedToInit.get() == FAILED_TO_INIT) {\n                    log.info(\"[{}] Actor failed to initialize, reinitializing...\", selfId);\n                    failedToInit.set(NOT_FAILED_TO_INIT);\n                    initActor();\n                }\n            } else {\n                log.info(\"[{}] Actor is being destroyed, not processing msg: {}\", selfId, msg);\n                msg.onTbActorStopped(selfId);\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 58.734209762213965}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\n}", "CodeBleu_score": 7.321102717991194}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\twhile (true) {\n    try {\n        if (!highPriorityMsgs.isEmpty()) {\n            processMessages(highPriorityMsgs, actor::process);\n        } else if (!normalPriorityMsgs.isEmpty()) {\n            processMessages(normalPriorityMsgs, actor::process);\n        } else {\n            ready.set(FREE);\n            break;\n        }\n    } catch (ActorInitializationException e) {\n        stopReason = e.getStopReason();\n        destroy(e);\n        break;\n    } catch (Exception e) {\n        log.warn(\"[{}] Failed to process message: {}\", selfId, e);\n        try {\n            actor.processFailure(e);\n        } catch (Exception e2) {\n            log.warn(\"[{}] Failed to process failure: {}\", selfId, e2);\n        }\n    }\n}\n}", "CodeBleu_score": 30.174271705112965}, {"code": "private void processMailbox(){\n\ttry {\n    if (destroyInProgress.get()) {\n        return;\n    }\n    if (actor.init()) {\n        processMessages(highPriorityMsgs, actor::process);\n        processMessages(normalPriorityMsgs, actor::process);\n        if (stopReason == null) {\n            ready.set(FREE);\n            tryProcessQueue(false);\n        } else {\n            actor.destroy(stopReason, null);\n        }\n    } else {\n        stopReason = TbActorStopReason.INIT_FAILED;\n        ready.set(NOT_READY);\n        actor.destroy(stopReason, null);\n    }\n} catch (ActorInitializationException e) {\n    stopReason = TbActorStopReason.INIT_FAILED;\n    ready.set(NOT_READY);\n    actor.destroy(stopReason, e);\n} catch (Throwable e) {\n    if (stopReason == null) {\n        stopReason = TbActorStopReason.PROCESSING_FAILED;\n    }\n    actor.onProcessFailure(e);\n    ready.set(NOT_READY);\n    actor.destroy(stopReason, e);\n}\n}", "CodeBleu_score": 29.931537341876748}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\n}", "CodeBleu_score": 1.5678822020925003}, {"code": "public void destroy(Throwable cause){\n\t\n}", "CodeBleu_score": 1.5678822020925003}, {"code": "public void destroy(Throwable cause){\n\t\n}", "CodeBleu_score": 1.5678822020925003}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tLimitLevelEntityName limitLevelEntityName = getLimitLevelEntityName(api, level);\nif (tenantId.getId().equals(getSysTenantId()) || limitLevelEntityName == null) {\nreturn true;\n}\n\nTenantId tenantIdToFetch = getTenantId(tenantId, ignoreTenantNotFound);\nif (tenantIdToFetch == null) {\nreturn true;\n}\n\nProfileConfiguration profileConfiguration = getProfileConfiguration(tenantIdToFetch);\nif (profileConfiguration == null) {\nif (ignoreTenantNotFound) {\nreturn true;\n}\n\nthrow new TenantProfileNotFoundException(tenantIdToFetch);\n}\n\nRateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\nif (rateLimitConfiguration == null) {\nreturn true;\n}\n\nreturn checkRateLimit(api, tenantIdToFetch, limitLevelEntityName, rateLimitConfiguration);\n}", "CodeBleu_score": 43.20105531429266}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\nLimitLevelEntityName limitLevelEntityName = LimitLevelEntityName.valueOf(level.toString());\n\nMap<LimitLevelEntityName, String> map = new HashMap<>();\nmap.put(limitLevelEntityName, tenantId.getId());\n\nTenantProfile tenantProfile = getProfileConfiguration(map, ignoreTenantNotFound);\n\nif (tenantProfile == null) {\n    return true;\n}\n\nLimitConfiguration limitConfiguration = tenantProfile.getRateLimitConfiguration();\n\nif (limitConfiguration == null) {\n    return true;\n}\n\nLimitLevel limitLevel = limitConfiguration.getLimitLevel(limitLevelEntityName);\n\nif (limitLevel == null) {\n    return true;\n}\n\nif (isSysTenantId(tenantId)) {\n    return true;\n}\n\nreturn checkRateLimit(api, limitLevel);\n}", "CodeBleu_score": 43.35755157687821}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tSet<Entry<Long, DtlsSession>> entries = sessions.entrySet();\n\tfor (Entry<Long, DtlsSession> entry : entries) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(entry.getKey());\n\t\t\tlogger.info(\"Removed expired session: \" + entry.getValue());\n\t\t}\n\t}\n}", "CodeBleu_score": 37.17899548236373}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tSet<Entry<String, DtlsSession>> entries = sessions.entrySet();\n\tfor (Entry<String, DtlsSession> entry : entries) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tString id = entry.getKey();\n\t\t\tsessions.remove(id);\n\t\t\tlogger.info(\"Removed expired DTLS session with ID: \" + id);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.7216328065321}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tSet<Entry<String, DtlsSession>> entries = sessions.entrySet();\n\tfor (Entry<String, DtlsSession> entry : entries) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tString sessionID = entry.getKey();\n\t\t\tsessions.remove(sessionID);\n\t\t\tlogger.fine(\"Removed session with ID \" + sessionID + \" from session map\");\n\t\t}\n\t}\n}", "CodeBleu_score": 36.0035924092465}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t} else {\n\t\tList<TsKvEntry> result = new ArrayList<>();\n\t\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\t\tString key = entry.getKey();\n\t\t\tList<JsonNode> values = entry.getValue();\n\t\t\tfor (JsonNode value : values) {\n\t\t\t\tresult.add(parseValue(key, value));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}", "CodeBleu_score": 41.06779739785156}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries == null || timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tfor (JsonNode value : entry.getValue()) {\n\t\t\tresult.add(parseValue(entry.getKey(), value));\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 39.95817614712324}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n}\nList<TsKvEntry> result = new ArrayList<>();\nfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\nString key = entry.getKey();\nList<JsonNode> values = entry.getValue();\nfor (JsonNode value : values) {\nresult.add(parseValue(key, value));\n}\n}\nreturn result;\n}", "CodeBleu_score": 38.80499192049028}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\t// Create request map\n\tMap<String, Object> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\n\t// Send request\n\tResponseEntity<String> responseEntity = this.postForEntity(this.refreshEndpoint, requestMap, String.class);\n\n\t// Update token information\n\tthis.setTokenInfo(System.currentTimeMillis(), new ObjectMapper().readTree(responseEntity.getBody()));\n}", "CodeBleu_score": 44.83547244252314}, {"code": "public void refreshToken(){\n\t\tif (this.refreshTokenExpTs < currentTimeMillis()) {\n\t\tthrow new TokenExpiredException(\"Refresh token has expired.\");\n\t}\n\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\ttry {\n\t\tResponseEntity<String> responseEntity = this.postForEntity(this.authEndpoint, requestMap, String.class);\n\t\tif (responseEntity.getStatusCode().is2xxSuccessful()) {\n\t\t\tsetTokenInfo(currentTimeMillis(), new ObjectMapper().readTree(responseEntity.getBody()));\n\t\t} else {\n\t\t\tthrow new AuthenticationException(responseEntity.getStatusCode().toString());\n\t\t}\n\t} catch (RestClientException e) {\n\t\tthrow new AuthenticationException(e.getMessage());\n\t}\n}", "CodeBleu_score": 41.06041082167747}, {"code": "public void refreshToken(){\n\t\ttry {\n\t\tMap<String, Object> requestMap = new HashMap<>();\n\t\trequestMap.put(\"refreshToken\", this.refreshToken);\n\t\trequestMap.put(\"clientServerTimeDiff\", this.clientServerTimeDiff);\n\t\tString response = this.postForEntity(this.authEndpoint + \"/refresh\", requestMap, String.class).getBody();\n\t\tthis.setTokenInfo(System.currentTimeMillis(), this.mapper.readTree(response));\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 45.8927436148985}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\t// Create the request body\n\tMap<String, String> requestBody = new HashMap<>();\n\trequestBody.put(\"username\", username);\n\trequestBody.put(\"password\", password);\n\t// Send the request\n\tResponseEntity<String> response = postForEntity(url + \"/api/auth/login\", requestBody, String.class);\n\t// Check the response\n\tif (response.getStatusCode() != HttpStatus.OK) {\n\t    throw new RuntimeException(\"Login request failed with status code \" + response.getStatusCode());\n\t}\n\t// Get the response body\n\tString responseBody = response.getBody();\n\t// Decode the response body\n\tJsonNode tokenInfo = Json.mapper.readTree(responseBody);\n\t// Get the current timestamp\n\tlong ts = currentTimeMillis();\n\t// Update the token information\n\tsetTokenInfo(ts, tokenInfo);\n\t// Log the login\n\tlog.info(\"Login successful\");\n    }", "CodeBleu_score": 48.67196894466462}, {"code": " private void doLogin(){\n\t\tlong ts = currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", password);\n\tResponseEntity<String> response = postForEntity(baseUrl + \"/api/auth/login\", loginRequest, String.class);\n\tsetTokenInfo(ts, response.getBody());\n}", "CodeBleu_score": 63.58426408488924}, {"code": " private void doLogin(){\n\t\tlong ts = currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", password);\n\ttry {\n\t\tResponseEntity<String> response = postForEntity(authUrl + \"/api/auth/login\", loginRequest, String.class);\n\t\tsetTokenInfo(ts, new ObjectMapper().readTree(response.getBody()));\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(\"Failed to login\", e);\n\t}\n}", "CodeBleu_score": 60.179188354701395}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n    return Optional.ofNullable(restTemplate.getForEntity(\n        String.format(\"%s/api/device/%s\", baseUrl, deviceId),\n        Device.class\n    ).getBody());\n} catch (HttpClientErrorException e) {\n    if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n        return Optional.empty();\n    } else {\n        throw e;\n    }\n}\n}", "CodeBleu_score": 49.565824641266296}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n    return Optional.ofNullable(restTemplate.getForEntity(\n        \"http://localhost:8080/api/device/{deviceId}\",\n        Device.class,\n        deviceId.getId()\n    ).getBody());\n} catch (HttpClientErrorException.NotFound ex) {\n    return Optional.empty();\n}\n}", "CodeBleu_score": 29.368822709611457}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponse response = client.target(uri).path(\"api/device/{deviceId}\".replace(\"{deviceId}\", deviceId.toString())).request().get();\n\t\tif (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else if (response.getStatus() != 200) {\n\t\t\tthrow new RuntimeException(\"Failed : HTTP error code : \" + response.getStatus());\n\t\t}\n\t\treturn Optional.of(response.readEntity(Device.class));\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t\treturn Optional.empty();\n\t}\n}", "CodeBleu_score": 49.41769179237608}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.setContentType(MediaType.APPLICATION_JSON);\n\t\tHttpEntity<Device> entity = new HttpEntity<Device>(device, headers);\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", entity, Device.class);\n\t\tif (response.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.of(response.getBody());\n\t} catch (Exception e) {\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 47.728167604861596}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tHttpEntity<DeviceCredentials> requestEntity = new HttpEntity<>(credentials);\n\t\tResponseEntity<Device> responseEntity = restTemplate.postForEntity(url + \"/api/device-with-credentials\", requestEntity, Device.class);\n\t\tif (responseEntity.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.of(responseEntity.getBody());\n\t} catch (Exception e) {\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 54.943542684927394}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\n// Create the request\nDeviceWithCredentialsRequest request = new DeviceWithCredentialsRequest();\nrequest.setDevice(device);\nrequest.setCredentials(credentials);\n\n// Send the request\nDeviceWithCredentialsResponse response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, DeviceWithCredentialsResponse.class).getBody();\n\n// Return the response\nreturn Optional.ofNullable(response.getDevice());\n}\ncatch (HttpClientErrorException ex) {\n// If a 404 error occurs, return an empty Optional\nif (ex.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n}\n\n// Otherwise, rethrow the exception\nthrow ex;\n}\n}", "CodeBleu_score": 56.5117902080341}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}, {"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}, {"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\n  bound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\n  if (this[key] && typeof this[key] === \"function\") {\n    bound[key] = this[key].bind(this, addr);\n  }\n});\nreturn bound;\n}", "CodeBleu_score": 97.50366938393864}, {"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}, {"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\nbound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\nif (this[key] && typeof this[key] === \"function\") {\nbound[key] = this[key].bind(this, addr);\n}\n});\nreturn bound;\n}", "CodeBleu_score": 96.20205970950842}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tif (typeof methods === 'string') methods = [methods]\n\tmethods.forEach(method => {\n\t\ttarget[method + 'All'] = (duration, callback) => {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration\n\t\t\t\tduration = 1000\n\t\t\t}\n\t\t\tlet promises = []\n\t\t\tthis.forEach(element => {\n\t\t\t\tpromises.push(element[method](duration))\n\t\t\t})\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback()\n\t\t\t})\n\t\t}\n\t})\n}", "CodeBleu_score": 30.41621718488538}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\tconst fn = Collection.prototype[method]\n\t\ttarget[method] = (collection, callback, duration = 1000) => {\n\t\t\tconst promises = []\n\t\t\tcollection.forEach(element => {\n\t\t\t\tconst promise = fn.call(collection, element, duration, callback)\n\t\t\t\tpromises.push(promise)\n\t\t\t})\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback()\n\t\t\t})\n\t\t}\n\t})\n}", "CodeBleu_score": 28.685949617144445}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tfor (let method of methods) {\n\t\tlet original = target[method]\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tlet promises = []\n\t\t\tfor (let element of this) {\n\t\t\t\tlet promise = original.call(element, duration, callback)\n\t\t\t\tif (promise) {\n\t\t\t\t\tpromises.push(promise)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (promises.length) {\n\t\t\t\treturn Promise.all(promises).then(() => {\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 30.412378657236328}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\nconst state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 91.30552758648074}, {"code": "listen(){\n\t\nconst state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 91.30552758648074}, {"code": "listen(){\n\t\nconst state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 91.30552758648074}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tconst struct adc_channel_cfg *channel_cfg;\n\tuint16_t size;\n\tuint8_t num_channels = 0U;\n\tuint8_t i;\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0U; i < sequence->num_channels; i++) {\n\t\tchannel_cfg = &sequence->channels[i];\n\t\tif (channel_cfg->channel_id >= config->info.channel_count) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel_cfg->channel_id == ADC_CHANNEL_TEMP) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel_cfg->channel_id == ADC_CHANNEL_VREF) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (channel_cfg->channel_id == ADC_CHANNEL_GND) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnum_channels++;\n\t}\n\n\tif (num_channels == 0U) {\n\t\treturn -EINVAL;\n\t}\n\n\tsize = num_channels * sizeof(uint16_t);\n\tif (sequence->buffer_size < size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 55.9492637202571}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tu16_t active_channels = 0;\n\tu16_t needed_buffer_size = 0;\n\n\tfor (u16_t i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels == 1) {\n\t\t\tneeded_buffer_size = 1;\n\t\t} else {\n\t\t\tneeded_buffer_size = 2;\n\t\t}\n\n\t\tif (sequence->channels == 1) {\n\t\t\tactive_channels = 1;\n\t\t} else {\n\t\t\tactive_channels = 2;\n\t\t}\n\t}\n\n\tif (active_channels > config->channels) {\n\t\tLOG_ERR(\"Too many channels selected. Maximum number of channels is %d\",\n\t\t\tconfig->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution > config->resolution) {\n\t\tLOG_ERR(\"Too many bits selected. Maximum number of bits is %d\",\n\t\t\tconfig->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (needed_buffer_size * sequence->channels > config->buffer_size) {\n\t\tLOG_ERR(\"Buffer size too small. Minimum buffer size is %d\",\n\t\t\tneeded_buffer_size * sequence->channels);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 34.49592573409172}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tuint8_t num_channels = 0;\n\tuint8_t data_size = 0;\n\tuint8_t buffer_size = 0;\n\tuint8_t i;\n\n\t/*\n\t * Check if the number of channels is within the range supported by the driver.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i].channel_cfg.channel_id >= config->num_channels) {\n\t\t\tLOG_ERR(\"Channel %d is not supported by the driver.\",\n\t\t\t\tsequence->channels[i].channel_cfg.channel_id);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tnum_channels++;\n\t}\n\n\t/*\n\t * Check if the data size is within the range supported by the driver.\n\t */\n\tif (sequence->resolution == 12) {\n\t\tdata_size = 2;\n\t} else if (sequence->resolution == 14) {\n\t\tdata_size = 4;\n\t} else {\n\t\tLOG_ERR(\"Resolution %d is not supported by the driver.\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * Calculate the buffer size needed for the sequence.\n\t */\n\tbuffer_size = num_channels * data_size;\n\n\t/*\n\t * Check if the provided buffer size is sufficient.\n\t */\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size %d is insufficient for the sequence.\",\n\t\t\tsequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 35.91997875593938}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t2}", "CodeBleu_score": 4.522944496805616}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t_\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_context *context = sequence->user_data;\n\tint err;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution for this device\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~config->channels) {\n\t\tLOG_ERR(\"Invalid channel selection\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tcontext->buffer = sequence->buffer;\n\tcontext->buffer_len = sequence->buffer_size / sizeof(uint16_t);\n\tcontext->channels = sequence->channels;\n\tcontext->repeat = sequence->options;\n\tcontext->buffer_idx = 0;\n\tcontext->async = (sequence->options & ADC_READ_ASYNC);\n\n\tadc_context_start_read(context, dev);\n\n\tadc_context_wait_for_completion(context);\n\n\treturn 0;\n}", "CodeBleu_score": 46.73077300864868}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t_\n\tconst struct ad559x_config *config = dev->config;\n\tuint8_t channels;\n\tuint8_t resolution;\n\tuint8_t channel_mask;\n\tsize_t needed;\n\tint rc;\n\n\tchannels = POPCOUNT(sequence->channels);\n\tresolution = config->resolution;\n\n\tif (sequence->resolution != resolution) {\n\t\tLOG_ERR(\"Invalid resolution. Got %u, expected %u\", sequence->resolution, resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (channels > AD559X_MAX_CHANNELS) {\n\t\tLOG_ERR(\"Too many channels. Got %u, max is %u\", channels, AD559X_MAX_CHANNELS);\n\t\treturn -EINVAL;\n\t}\n\n\tchannel_mask = sequence->channels;\n\tneeded = channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < needed) {\n\t\tLOG_ERR(\"Buffer size too small. Got %zu, need %zu\", sequence->buffer_size, needed);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = adc_context_start_read(&config->ctx, sequence);\n\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\treturn adc_context_wait_for_completion(&config->ctx);\n}", "CodeBleu_score": 54.86621721779525}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tint err;\n\n\t/* Make sure the DMA output buffer is ready to be written to. */\n\terr = dma_buf_begin_cpu_access(ctx->buffer, DMA_BUF_WRITE);\n\tif (err < 0) {\n\t\tprintk(\"adc_context_start_sampling: Failed to begin cpu access: %d\n\", err);\n\t\treturn;\n\t}\n\n\t/* Set the channels to be sampled. */\n\terr = adc_tm_channel_setup(ctx->adc, ctx->channels);\n\tif (err < 0) {\n\t\tprintk(\"adc_context_start_sampling: Failed to set up channels: %d\n\", err);\n\t\treturn;\n\t}\n\n\t/* Initialize the repeat buffer. */\n\tctx->repeat_buffer.data = ctx->buffer->data;\n\tctx->repeat_buffer.len = ctx->buffer->size;\n\n\t/* Release the semaphore to signal the start of sampling. */\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 37.56349406451477}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tint err;\n\tstruct adc_chan_config chans[CONFIG_ADC_MAX_CHANNELS];\n\tstruct device *dev = ctx->dev;\n\tconst struct adc_sequence *sequence = &ctx->sequence;\n\tstruct adc_data *buffer = ctx->buffer;\n\tu16_t channel_count = 0;\n\tu16_t i;\n\n\t/* Retrieve channels configuration */\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tconst struct adc_channel_cfg *channel = &sequence->channels[i];\n\n\t\tif (channel->channel_id >= dev->config->channel_count) {\n\t\t\tLOG_ERR(\"Channel %d is not valid on this device\",\n\t\t\t\tchannel->channel_id);\n\t\t\treturn;\n\t\t}\n\n\t\tif (channel->channel_id == 16) {\n\t\t\tLOG_ERR(\"Channel %d is not valid on this device\",\n\t\t\t\tchannel->channel_id);\n\t\t\treturn;\n\t\t}\n\n\t\tchans[channel_count].gain = channel->gain;\n\t\tchans[channel_count].reference = channel->reference;\n\t\tchans[channel_count].acquisition_time = channel->acquisition_time;\n\t\tchans[channel_count].channel_id = channel->channel_id;\n\t\tchannel_count++;\n\t}\n\n\t/* Set channels configuration */\n\terr = adc_chan_configure(dev, chans, channel_count);\n\tif (err) {\n\t\tLOG_ERR(\"ADC channel setup failed (%d)\", err);\n\t\treturn;\n\t}\n\n\t/* Setup repeat buffer */\n\tfor (i = 0; i < sequence->resolution; i++) {\n\t\tbuffer[i].buffer = sequence->buffer +\n\t\t\t(i * sequence->channels * sizeof(s16_t));\n\t\tbuffer[i].buffer_size = sequence->channels;\n\t}\n\n\t/* Start sampling */\n\tk_sem_init(&ctx->sem, 0, UINT_MAX);\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 34.544434463878936}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buf_ptr = ctx->repeat_buf_ptr;\n\t} else {\n\t\tctx->buf_ptr = ctx->buf;\n\t}\n}", "CodeBleu_score": 45.63918319110813}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->buffer_repeat;\n\t}\n\telse {\n\t\tctx->buffer = ctx->buffer_raw;\n\t}\n}", "CodeBleu_score": 45.849027876409835}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\t/* Update buffer pointer to new data buffer */\n\t\tctx->buffer = ctx->buffer_2;\n\t} else {\n\t\t/* Update buffer pointer to new data buffer */\n\t\tctx->buffer = ctx->buffer_1;\n\t}\n}", "CodeBleu_score": 44.97704461011548}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < data->dev->channels; channel++) {\n\t\t\tif (data->dev->channel_active[channel]) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d (ret %d)\", channel, ret);\n\t\t\t\t\tdata->dev->ctx->error = ret;\n\t\t\t\t\tdata->dev->ctx->buffer = NULL;\n\t\t\t\t\tdata->dev->ctx->buffer_size = 0;\n\t\t\t\t\tadc_context_complete(data->dev->ctx, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer[channel] = result;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(data->dev->ctx, data->buffer, sizeof(data->buffer));\n\t}\n}", "CodeBleu_score": 55.737794787024775}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tconst struct device *mfd_dev = config->mfd_dev;\n\tstruct adc_sequence *sequence = ctx->sequence;\n\tuint8_t channel;\n\tuint16_t *buffer;\n\tuint8_t channel_active;\n\tuint8_t channel_mask;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tchannel_active = 0;\n\t\tchannel_mask = 0;\n\t\tbuffer = sequence->buffer;\n\n\t\tfor (channel = 0; channel < sequence->channels; channel++) {\n\t\t\tif (sequence->channels == 1) {\n\t\t\t\tret = adc_ad559x_read_channel(dev, sequence->channels, buffer);\n\t\t\t} else {\n\t\t\t\tret = adc_ad559x_read_channel(dev, channel, buffer);\n\t\t\t}\n\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d (%d)\", channel, ret);\n\t\t\t\tadc_context_event_send(ctx, channel, ret);\n\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbuffer++;\n\t\t\tchannel_active |= BIT(channel);\n\t\t\tchannel_mask |= BIT(sequence->channels + channel);\n\t\t}\n\n\t\t/*\n\t\t * If all channels are inactive, then the sampling is complete.\n\t\t * Otherwise, continue with the next acquisition.\n\t\t */\n\t\tif (channel_active == 0) {\n\t\t\tadc_context_on_sampling_done(ctx, channel_mask, buffer - sequence->buffer);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.535444398904964}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_sequence *sequence = data->sequence;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < sequence->channels; channel++) {\n\t\t\tret = adc_ad559x_read_channel(dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d (%d)\", channel, ret);\n\t\t\t\tadc_context_complete(dev, NULL, ret);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsequence->buffer[channel] = result;\n\t\t}\n\n\t\tadc_context_on_sampling_done(dev, sequence);\n\t}\n}", "CodeBleu_score": 52.25810835136803}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[1];\n\tint rc;\n\n\tk_sleep(K_USEC(config->ready_time_us));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tif (!(reg_val[0] & ADS1112_CONFIG_OS)) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 28.694964620829683}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[2] = {0};\n\tint rc;\n\n\tk_sleep(K_USEC(config->ready_time_us));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tif (reg_val[0] & ADS1112_CONFIG_OS_BUSY) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 30.992904319413217}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[2] = {0};\n\tint rc = 0;\n\tint i = 0;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\tfor (i = 0; i < 10; i++) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, buf);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (buf[0] & ADS1112_CONFIG_OS_MASK) {\n\t\t\tbreak;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n\n\tif (i == 10) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.10992621091069}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\tint num_samplings = 0;\n\tint extra_samplings = 0;\n\tint i;\n\n\t/*\n\t * Calculate the number of samplings in the sequence.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tnum_samplings += sequence->channels[i].decimation.sampling_count;\n\t}\n\n\t/*\n\t * Calculate the number of extra samplings.\n\t */\n\tif (sequence->options) {\n\t\textra_samplings = sequence->options->extra_samplings;\n\t}\n\n\t/*\n\t * Calculate the required buffer size.\n\t */\n\tbuffer_size = num_samplings + extra_samplings;\n\n\t/*\n\t * Check if the buffer size is sufficient.\n\t */\n\tif (buffer_size < sequence->buffer_size) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The buffer size is not sufficient.\n\t */\n\tdev_err(&g_ads1112_info.client->dev, \"buffer size %d is less than the required size %d\n\",\n\t\tsequence->buffer_size, buffer_size);\n\treturn -E2BIG;\n}", "CodeBleu_score": 35.51615987560269}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_size = 0;\n\tsize_t i;\n\tint err = 0;\n\n\t/*\n\t * Calculate the required buffer size.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\trequired_size += sequence->channels[i].num_samplings;\n\t}\n\n\t/*\n\t * Check if the buffer size is sufficient.\n\t */\n\tif (required_size > sequence->options.buffer_size) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&sequence->dev->dev,\n\t\t\t\"adc_buffer_size (%zu) is less than the required size (%zu)\n\",\n\t\t\tsequence->options.buffer_size, required_size);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 33.78428688291958}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size;\n\tint num_samplings;\n\tint num_extra_samplings;\n\tint i;\n\n\t/*\n\t * Calculate the number of samplings in the sequence.\n\t */\n\tnum_samplings = 0;\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tnum_samplings += sequence->channels[i].count;\n\t}\n\n\t/*\n\t * Calculate the number of extra samplings specified in the sequence options.\n\t */\n\tnum_extra_samplings = 0;\n\tif (sequence->options) {\n\t\tnum_extra_samplings = sequence->options->extra_samplings;\n\t}\n\n\t/*\n\t * Calculate the required buffer size.\n\t */\n\tbuffer_size = num_samplings + num_extra_samplings;\n\n\t/*\n\t * Check if the buffer size is sufficient.\n\t */\n\tif (buffer_size < ADS1112_MIN_BUFFER_SIZE) {\n\t\tdev_err(&g_ads1112_info.client->dev, \"buffer size is less than the required size\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.182773650842464}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint error_code = 0;\n\n\tif (data->async) {\n\t\tLOG_ERR(\"Busy\");\n\t\treturn -EBUSY;\n\t}\n\n\terror_code = ads1112_validate_sequence(dev, sequence);\n\tif (error_code) {\n\t\treturn error_code;\n\t}\n\n\tdata->async = true;\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->buffer_count = 0;\n\tdata->sequence = sequence;\n\n\terror_code = ads1112_context_start_read(dev, sequence, wait);\n\tif (error_code) {\n\t\tdata->async = false;\n\t}\n\n\treturn error_code;\n}", "CodeBleu_score": 51.611067823741706}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_len = sequence->buffer_size;\n\tdata->buffer_remaining = sequence->buffer_size;\n\tdata->async = wait;\n\n\treturn adc_context_start_read(&data->ctx, sequence, adc_callback, dev);\n}", "CodeBleu_score": 55.34514147635794}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_len = sequence->buffer_size;\n\tdata->buffer_index = 0;\n\n\tadc_context_start_read(&data->ctx, sequence, ads1112_adc_convert_callback,\n\t\t\t      wait);\n\n\treturn 0;\n}", "CodeBleu_score": 56.35718762940209}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tconst char *dev_name = argv[1];\n\tstruct device *dev;\n\tstruct audio_codec_cfg_data cfg = {0};\n\tstruct audio_codec_properties *prop;\n\n\tdev = device_get_binding(dev_name);\n\tif (!dev) {\n\t\tLOG_ERR(\"Cannot find %s device\", dev_name);\n\t\treturn -ENODEV;\n\t}\n\n\tprop = dev->config->config_info;\n\n\tcfg.is_playback = prop->is_playback;\n\tcfg.is_capture = prop->is_capture;\n\tcfg.bit_width = prop->bit_width;\n\tcfg.format = prop->format;\n\tcfg.rate = prop->rate;\n\tcfg.channels = prop->channels;\n\n\tret = audio_codec_apply_properties(dev, &cfg);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to apply audio codec properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.88523779646492}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"No device specified\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Cannot get device\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Cannot apply properties\");\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 61.75010912420876}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tARG_UNUSED(argc);\n\tint ret;\n\tstruct device *dev;\n\tconst char *dev_name = argv[1];\n\n\tdev = device_get_binding(dev_name);\n\tif (!dev) {\n\t\tshell_error(sh, \"Cannot get device %s\", dev_name);\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties to device %s\", dev_name);\n\t\treturn -EIO;\n\t}\n\n\tshell_print(sh, \"Successfully applied properties to device %s\", dev_name);\n\treturn 0;\n}", "CodeBleu_score": 54.138491545201184}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_dev_cfg *cfg = DEV_CFG(dev);\n\tstruct mpxxdtyy_dev_data *data = DEV_DATA(dev);\n\tint ret;\n\n\t/* Check device state */\n\tif (data->state == MPXXDTTYY_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\t/* Stop command */\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t\tif (ret != 0) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = MPXXDTTYY_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"I2S trigger command not supported in active state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (data->state == MPXXDTTYY_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t/* Start command */\n\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t\tif (ret != 0) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = MPXXDTTYY_STATE_ACTIVE;\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\t/* Stop command */\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t\tif (ret != 0) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = MPXXDTTYY_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"I2S trigger command not supported in configured state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"I2S trigger command not supported in %s state\", mpxxdtyy_state_to_str(data->state));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.61777152108423}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t", "CodeBleu_score": 4.702895929663203}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_config *config = dev->config;\n\tuint8_t reg_val;\n\tint ret;\n\n\tif (!dev) {\n\t\tLOG_ERR(\"Device not found. Is the device connected?\");\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (config->state != STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device is not in configured state\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* Set the I2S start command */\n\t\tret = mpxxdtyy_i2s_write(dev, MPXXDTYY_I2S_CMD_START);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Set the state to active */\n\t\tconfig->state = STATE_ACTIVE;\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (config->state != STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device is not in active state\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* Set the I2S stop command */\n\t\tret = mpxxdtyy_i2s_write(dev, MPXXDTYY_I2S_CMD_STOP);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Set the state to configured */\n\t\tconfig->state = STATE_CONFIGURED;\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.22804974722189}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_4_BIT) {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_4_BIT_MODE_CMD;\n\t} else {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_8_BIT_MODE_CMD;\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_CURSOR_BLINK_CMD;\n\t}\n\n\tif (config->cursor_visible) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_CURSOR_VISIBLE_CMD;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ENABLED_CMD;\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, config->display_mode);\n}", "CodeBleu_score": 65.05551348057554}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd = config->display_mode_cmd;\n\n\t\tif (config->cursor_blink) {\n\t\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t\t}\n\n\t\tif (config->display_blink) {\n\t\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_BLINK;\n\t\t}\n\n\t\tif (config->cursor_pos) {\n\t\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_POS;\n\t\t}\n\t}\n\n\tif (config->display_enabled != enabled) {\n\t\tconfig->display_enabled = enabled;\n\n\t\tif (enabled) {\n\t\t\tauxdisplay_hd44780_command(dev, true, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n\t\t} else {\n\t\t\tauxdisplay_hd44780_command(dev, true, AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_OFF,\n\t\t\t\t\t\tAUXDISPLAY_HD44780_MODE_8_BIT);\n\t\t}\n\t}\n}", "CodeBleu_score": 64.21456672993814}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\tuint8_t mode = AUXDISPLAY_HD44780_MODE_8_BIT;\n\n\tif (enabled) {\n\t\tcmd = config->display_mode_enabled_cmd;\n\t\tmode = AUXDISPLAY_HD44780_MODE_8_BIT;\n\t} else {\n\t\tcmd = config->display_mode_disabled_cmd;\n\t\tmode = AUXDISPLAY_HD44780_MODE_8_BIT;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_ENABLED_BIT;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CURSOR_BLINK_ENABLED_BIT;\n\t}\n\n\tif (config->display_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ENABLED_BIT;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_DISPLAY_ENABLED_BIT;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ENABLED_BIT;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CURSOR_ENABLED_BIT;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_ENABLED_BIT;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CURSOR_BLINK_ENABLED_BIT;\n\t}\n\n\tif (config->cursor_blink_block) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_BLOCK_BIT;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CURSOR_BLINK_BLOCK_BIT;\n\t}\n\n\tauxdisplay_hd44780_command(dev, 0, cmd, mode);\n}", "CodeBleu_score": 58.80977659700226}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = DEV_CFG(dev);\n\tint result = 0;\n\n\tif (config->busy_gpio_port == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tresult = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (result < 0) {\n\t\treturn result;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 60.75009624000523}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *cfg = DEV_CFG(dev);\n\tint ret;\n\tbool busy;\n\t/* Check if the busy GPIO port is defined */\n\tif (cfg->busy_gpio_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\t/* Get the status of the busy GPIO pin */\n\tbusy = gpio_pin_get(cfg->busy_gpio_port, cfg->busy_gpio_pin);\n\t/* Return the result */\n\treturn busy;\n}", "CodeBleu_score": 63.27734882055657}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\n\tif (!config->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 66.03560550391697}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t command_buffer[2];\n\tint err;\n\n\tcommand_buffer[0] = config->special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\terr = i2c_write_dt(dev, command_buffer, sizeof(command_buffer));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\n\treturn 0;\n}", "CodeBleu_score": 65.00141710126505}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tuint8_t buf[2];\n\tint ret;\n\n\tbuf[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuf[1] = command;\n\n\tret = i2c_write_dt(dev, buf, sizeof(buf));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(CONFIG_AUXDISPLAY_SERLCD_SPECIAL_COMMAND_DELAY));\n\n\treturn 0;\n}", "CodeBleu_score": 47.4035355701973}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t command_buffer[2];\n\n\tcommand_buffer[0] = config->special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\treturn i2c_write_dt(dev, command_buffer, sizeof(command_buffer), I2C_MSG_WRITE);\n}", "CodeBleu_score": 61.76067536199701}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_dev = dev->data;\n\tuint8_t *mem = data_dev->memory;\n\tsize_t mem_size = data_dev->memory_size;\n\n\tif (offset >= mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.98259953076622}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tint err_code = 0;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\terr_code = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (offset + size > data_dev->size) {\n\t\terr_code = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(data, data_dev->memory + offset, size);\n\nout:\n\treturn err_code;\n}", "CodeBleu_score": 58.41817868248875}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_dev = dev->data;\n\tbool is_invalid = data_dev->status.is_invalid;\n\tsize_t mem_size = config->size;\n\n\tif (offset + size > mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, data_dev->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 69.66836094009332}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data = dev->data;\n\tint rc = 0;\n\n\tif (size > config->size) {\n\t\treturn -EFBIG;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EFBIG;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&data->memory[offset], data, size);\n\n\treturn rc;\n}", "CodeBleu_score": 61.27353632750834}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tuint8_t *mem_dev = data_dev->mem_dev;\n\tbool is_invalid = data_dev->status.is_invalid;\n\n\tif (size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset > BBRAM_EMUL_SIZE - size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&mem_dev[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 49.04909645970208}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\n\tif (offset > data_dev->size || offset + size > data_dev->size) {\n\t\tLOG_ERR(\"Invalid offset %d or size %d\", offset, size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Invalid BBRAM\");\n\t\treturn -EIO;\n\t}\n\n\tif (data_dev->write_cb) {\n\t\tif (data_dev->write_cb(data_dev, offset, size, data) != 0) {\n\t\t\tLOG_ERR(\"Write callback failed\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tmemcpy(&data_dev->mem[offset], data, size);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 55.958865392235104}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"No BBRAM device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 84.40351242784028}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc == 1) {\n\t\tshell_error(sh, \"No BBRAM device specified\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Cannot get BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 77.7889610700047}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"BBRAM device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Could not get BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 85.54513101482087}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tuint8_t *hdr = &h4_hdr_buf[h4_hdr_len];\n\tint ret;\n\tuint8_t len;\n\n\tlen = h4_hdr_buf[0] + 1;\n\tif (len > H4_HDR_BUF_SIZE) {\n\t\tLOG_ERR(\"Invalid header length\");\n\t\treturn;\n\t}\n\tif (h4_hdr_len + len > H4_HDR_BUF_SIZE) {\n\t\tLOG_ERR(\"Invalid header length\");\n\t\treturn;\n\t}\n\tif (h4_hdr_len + len > h4_hdr_rem) {\n\t\tLOG_ERR(\"Invalid header length\");\n\t\treturn;\n\t}\n\tret = uart_fifo_read(dev, hdr, len - h4_hdr_len);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"UART read error\");\n\t\treturn;\n\t}\n\th4_hdr_len += ret;\n\th4_hdr_rem -= ret;\n}", "CodeBleu_score": 39.10190135932329}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t", "CodeBleu_score": 5.485908994710939}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t", "CodeBleu_score": 5.485908994710939}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read;\n\n\twhile (len > 0) {\n\t\tbytes_read = uart_fifo_read(uart, buf, min(len, sizeof(buf)));\n\t\tif (bytes_read == 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART device\");\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= bytes_read;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 46.154220226188336}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read = 0;\n\tint err;\n\n\twhile (len) {\n\t\terr = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Unable to read %d bytes from UART device %s (%d)\", len, uart->name, err);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= err;\n\t\tbytes_read += err;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 57.23157388115555}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t ret = 0;\n\tuint8_t buf[33];\n\twhile (len) {\n\t\tsize_t tmp = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\t\tif (tmp == 0) {\n\t\t\tLOG_ERR(\"Failed to read %zu bytes from UART FIFO\", len);\n\t\t\treturn ret;\n\t\t}\n\t\tlen -= tmp;\n\t\tret += tmp;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 51.17670198277388}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *o;\n\tint hop = ZBUS_HOP_INVALID;\n\tint i;\n\n\tzbus_spinlock_lock(&chan->lock);\n\tfor (i = 0; i < chan->observer_count; i++) {\n\t\to = &chan->observer[i];\n\t\tif (o->enabled && o->priority < hop) {\n\t\t\thop = o->priority;\n\t\t}\n\t}\n\tchan->hop = hop;\n\tzbus_spinlock_unlock(&chan->lock);\n}", "CodeBleu_score": 24.830687600349517}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = 0;\n\tint i;\n\tzbus_spinlock_lock(&chan->lock);\n\tfor (i = 0; i < ZBUS_CHANNEL_MAX_OBSERVERS; i++) {\n\t\tif (chan->observers[i].priority < hop && chan->observers[i].enabled) {\n\t\t\thop = chan->observers[i].priority;\n\t\t}\n\t}\n\tchan->hop = hop;\n\tzbus_spinlock_unlock(&chan->lock);\n}", "CodeBleu_score": 20.385709272804228}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tzbus_spinlock_lock(&chan->lock);\n\tuint16_t hop = 0;\n\tstruct zbus_observer *o = chan->observers;\n\twhile (o) {\n\t\tif (o->priority < hop && o->enabled) hop = o->priority;\n\t\to = o->next;\n\t}\n\tchan->hop = hop;\n\tzbus_spinlock_unlock(&chan->lock);\n}", "CodeBleu_score": 17.369560303886107}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tint chan_highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tif (!chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tobs->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 17.981858682861713}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *chan;\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel, i, &chan);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(chan != NULL, \"chan must be not NULL\");\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs || !observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.158487436130205}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *chan;\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_list_size;\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel, i, &chan);\n\t\t\tSTRUCT_SECTION_FOREACH(zbus_channel_observation, observation, &chan->data->observers) {\n\t\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, observation->index, &observation_mask);\n\n\t\t\t\tif (observation->obs != obs || !observation_mask->enabled) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchan_update_hop(chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 20.2878070811237}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint ret;\n\n\t/*\n\t * Assert that the operation is not being performed in an ISR.\n\t */\n\tk_is_in_isr();\n\n\t/*\n\t * Assert that the observer is not null.\n\t */\n\tzassert_not_null(obs, ASSERT_MSG_OBS_NOT_NULL);\n\n\t/*\n\t * Lock a spinlock.\n\t */\n\tret = k_spin_lock(&obs->lock);\n\tzassert_equal(ret, 0, ASSERT_MSG_LOCK_FAIL);\n\n\t/*\n\t * Set the observer's priority to the minimum thread priority.\n\t */\n\tobs->priority = K_LOWEST_APPLICATION_THREAD_PRIO;\n\n\t/*\n\t * Update all channels associated with the observer.\n\t */\n\tupdate_all_channels_hop(obs);\n\n\t/*\n\t * Return 0.\n\t */\n\treturn 0;\n}", "CodeBleu_score": 34.962140659072205}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(obs != NULL, \"NULL observer\");\n\t_ZBUS_ASSERT(!k_is_in_isr(), \"Cannot attach observer from ISR\");\n\tk_spinlock_key_t key = k_spin_lock(&zbus_obs_lock);\n\t_ZBUS_ASSERT(obs->priority != 0, \"Observer priority cannot be 0\");\n\tobs->priority = K_THREAD_PRIO_HIGHEST;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_obs_lock, key);\n\treturn 0;\n}", "CodeBleu_score": 57.78579162361459}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(k_is_in_isr() == false, \"zbus_obs_attach_to_thread: cannot be called from ISR\");\n\t_ZBUS_ASSERT(obs != NULL, \"zbus_obs_attach_to_thread: observer cannot be NULL\");\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_obs_lock);\n\tobs->priority = K_THREAD_PRIO_HIGHEST;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_obs_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 56.53119689200415}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"channel is NULL\");\n\n\tk_timeout_t adjusted_timeout = timeout;\n\n\tif (k_is_in_isr()) {\n\t\tadjusted_timeout = sys_timepoint_timeout_from_ms(\n\t\t\tsys_time_ms_from_k_timeout(timeout));\n\t}\n\n\tk_timepoint_t end_time = sys_time_get() + adjusted_timeout;\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, adjusted_timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 53.074212278639045}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan is NULL\");\n\n\tk_timeout_t adjusted_timeout = timeout;\n\tint prio = ZBUS_MIN_THREAD_PRIORITY;\n\n\tif (k_is_in_isr()) {\n\t\tadjusted_timeout = sys_timepoint_timeout(sys_timepoint_from_ms(timeout));\n\t}\n\n\tint err = chan_lock(chan, adjusted_timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_from_ms(timeout);\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 52.90066902563918}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\tk_timeout_t end_time;\n\n\tif (k_is_in_isr()) {\n\t\tend_time = sys_timepoint_timeout_start(timeout);\n\t} else {\n\t\tend_time = timeout;\n\t}\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 54.89759670806944}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n}", "CodeBleu_score": 4.451885662912518}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n}", "CodeBleu_score": 4.451885662912518}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_FUNCTIONAL_STATE(enable));\n\tif (enable != DISABLE) {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MACMIIAR |= ETH_MACMIIAR_CR_Msk;\n\t\t}\n\t\tif (Int & IS_ETH_INT_ABNORMAL) {\n\t\t\tETH->MACMIIAR |= ETH_MACMIIAR_NCR_Msk;\n\t\t}\n\t} else {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MACMIIAR &= ~ETH_MACMIIAR_CR_Msk;\n\t\t}\n\t\tif (Int & IS_ETH_INT_ABNORMAL) {\n\t\t\tETH->MACMIIAR &= ~ETH_MACMIIAR_NCR_Msk;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.21859283326898}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\tpTxDesc = &TxDesc[0];\n\tfor (i = 0; i < NUM_TX_DESC; i++) {\n\t\tif ((pTxDesc->status & ETH_DMATXDESC_OWN) == (uint32_t)RESET) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tpTxDesc++;\n\t}\n\treturn (ETH_TX_DESC *)0;\n}", "CodeBleu_score": 31.298714829204922}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\n\tpTxDesc = (ETH_TX_DESC *) ETH_TxDescListStart;\n\twhile (pTxDesc != (ETH_TX_DESC *) ETH_TxDescListEnd) {\n\t\tif (pTxDesc->Status & ETH_DMATXDESC_OWN) {\n\t\t\tpTxDesc = (ETH_TX_DESC *) ((uint32_t) pTxDesc + 1);\n\t\t\tif (pTxDesc == (ETH_TX_DESC *) ETH_TxDescListEnd) {\n\t\t\t\tpTxDesc = (ETH_TX_DESC *) ETH_TxDescListStart;\n\t\t\t}\n\t\t} else {\n\t\t\treturn pTxDesc;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 47.682120640124595}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t dwReg;\n\tuint32_t dwStartAddr = (uint32_t)g_pTxDescList;\n\tuint32_t dwEndAddr = dwStartAddr + (sizeof(ETH_TX_DESC) * ETH_TX_DESC_CNT);\n\n\tpTxDesc = (ETH_TX_DESC *)dwStartAddr;\n\n\twhile (dwStartAddr != dwEndAddr) {\n\t\tdwReg = pTxDesc->dwCtrlStatus;\n\t\tif ((dwReg & ETH_TX_CTRL_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tdwStartAddr += sizeof(ETH_TX_DESC);\n\t\tpTxDesc = (ETH_TX_DESC *)dwStartAddr;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.09964342203751}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t ret = RT_EOK;\n\trt_uint32_t cyp_dac_channel = 0;\n\n\tRT_ASSERT(device != RT_NULL);\n\tRT_ASSERT(device->parent.user_data != RT_NULL);\n\tRT_ASSERT(value != RT_NULL);\n\n\tcyp_dac_channel = cyp_dac_get_channel(channel);\n\n\tret = Cy_CSDIDAC_OutputEnable(device->parent.user_data, cyp_dac_channel, *value);\n\n\tif (ret != CY_RET_SUCCESS) {\n\t\tLOG_E(\"cyp_dac_output_enable: failed to enable DAC channel %d\", channel);\n\t\treturn -RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 56.48368506932542}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device != RT_NULL);\n\tRT_ASSERT(value != RT_NULL);\n\trt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\trt_err_t result = RT_EOK;\n\n\tCy_CSDIDAC_Init(CY_CSD_IDAC_BASE, cyp_dac_channel);\n\tCy_CSDIDAC_Enable(CY_CSD_IDAC_BASE, cyp_dac_channel);\n\tCy_CSDIDAC_SetValue(CY_CSD_IDAC_BASE, cyp_dac_channel, *value);\n\n\tif (Cy_CSDIDAC_OutputEnable(CY_CSD_IDAC_BASE, cyp_dac_channel) != CY_CSD_IDAC_SUCCESS) {\n\t\tresult = -RT_ERROR;\n\t\tLOG_E(\"The DAC channel %d output enable failed.\", cyp_dac_channel);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 51.6250841994528}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\tcy_stc_csd_context_t *context = (cy_stc_csd_context_t *)device->parent.parent.user_data;\n\tcy_en_csd_dac_channel_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\tcy_en_csd_status_t status = CY_CSD_SUCCESS;\n\n\tif (context == RT_NULL) {\n\t\tresult = -RT_ERROR;\n\t} else {\n\t\tstatus = Cy_CSDIDAC_OutputEnable(context->base, cyp_dac_channel, *value);\n\t\tif (status != CY_CSD_SUCCESS) {\n\t\t\tresult = -RT_ERROR;\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 48.140450363783785}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t flash_end_addr;\n\n\t/* Check if the read operation would exceed the flash memory's end address */\n\tflash_end_addr = ifx_flash_get_end_addr();\n\tif (addr + size > flash_end_addr) {\n\t\tIFX_FLASH_LOG_E(\"Read operation would exceed the flash memory's end address\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* Read the specified size of data from the flash memory address into the buffer, byte by byte */\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = ifx_flash_read_byte(addr + i);\n\t}\n\n\t/* Return the number of bytes read */\n\treturn size;\n}", "CodeBleu_score": 44.92512368338645}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tint ret;\n\trt_uint32_t addr_end;\n\n\t/* Check if the read operation would exceed the flash memory's end address. */\n\taddr_end = addr + size;\n\tif (addr_end > IFX_FLASH_END_ADDR) {\n\t\trt_kprintf(\"ifx_flash_read_32k: Read operation would exceed flash memory's end address.\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read the specified size of data from the flash memory address into the buffer, byte by byte. */\n\twhile (size > 0) {\n\t\tret = ifx_flash_read_byte(addr, buf);\n\t\tif (ret != 0) {\n\t\t\trt_kprintf(\"ifx_flash_read_32k: Read operation failed.\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Update the address and the buffer. */\n\t\taddr++;\n\t\tbuf++;\n\t\tsize--;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 41.30282286519006}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tCY_ASSERT(NULL != timer);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t*)timer->parent.user_data;\n\trt_uint32_t count = cyhal_timer_read(timer_obj);\n\treturn count;\n}", "CodeBleu_score": 54.927235278925565}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer != RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 30.92013937546092}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer != RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\tRT_ASSERT(timer_obj != RT_NULL);\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 58.00653176468879}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\trt_mutex_take(&g_dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.377330385796944}, {"code": "void dfs_lock(void){\n\t\tint ret;\n\trt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n\tRT_ASSERT(dfs_lock_count >= 0);\n\tdfs_lock_count++;\n\trt_mutex_release(dfs_lock_mutex);\n}", "CodeBleu_score": 10.223082034495675}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(g_dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.404565786908461}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (fdt->fds[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\tindex = fd_slot_expand(fdt, startfd);\n\tif (index < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (fd = startfd; fd < index; fd++) {\n\t\tfdt->fds[fd] = NULL;\n\t}\n\n\treturn index;\n}", "CodeBleu_score": 46.03358707043984}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (!fdt->fds[fd]) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\treturn fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 27.394616333110104}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t#define FD_SLOT_ALLOC_STEP  32\n    int fd;\n\n    if (startfd < 0) {\n        startfd = 0;\n    }\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* no empty slot found, expand the fd table */\n    fd = fd_slot_expand(fdt, startfd);\n    if (fd < 0) {\n        return -1;\n    }\n\n    /* find the empty slot in the expanded fd table */\n    for (; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* no empty slot found, re-expand the fd table */\n    fd = fd_slot_expand(fdt, fdt->maxfd);\n    if (fd < 0) {\n        return -1;\n    }\n\n    /* find the empty slot in the re-expanded fd table */\n    for (; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* no empty slot found, try to re-expand the fd table again */\n    fd = fd_slot_expand(fdt, fdt->maxfd);\n    if (fd < 0) {\n        return -1;\n    }\n\n    /* find the empty slot in the re-re-expanded fd table */\n    for (; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* no empty slot found, return error */\n    return -1;\n}", "CodeBleu_score": 44.521278530227455}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < sizeof(rt_err_str) / sizeof(rt_err_str[0]); i++) {\n\t\tif (rt_err_str[i].err == error) {\n\t\t\treturn rt_err_str[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 57.84357201621829}, {"code": "const char *rt_strerror(rt_err_t error){\n\t", "CodeBleu_score": 3.4236961536175192}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < sizeof(rt_err_str) / sizeof(rt_err_str[0]); i++) {\n\t\tif (error == rt_err_str[i].err) {\n\t\t\treturn rt_err_str[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 59.603387862309134}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\trt_thread_idle_hook_t *hook_ptr;\n\trt_thread_idle_hook_t *hook_ptr_tmp;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* lock thread */\n\trt_spin_lock(&rt_thread_idle_hook_lock);\n\n\t/* find an empty slot */\n\thook_ptr = &rt_thread_idle_hook_list;\n\thook_ptr_tmp = hook_ptr->next;\n\twhile (hook_ptr_tmp != &rt_thread_idle_hook_list) {\n\t\tif (hook_ptr_tmp->func == RT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t\thook_ptr = hook_ptr_tmp;\n\t\thook_ptr_tmp = hook_ptr->next;\n\t}\n\n\t/* if no empty slot is found, release lock and return error */\n\tif (hook_ptr_tmp == &rt_thread_idle_hook_list) {\n\t\trt_kprintf(\"no empty slot found!\n\");\n\t\trt_spin_unlock(&rt_thread_idle_hook_lock);\n\t\tresult = -RT_EFULL;\n\t\tgoto __exit;\n\t}\n\n\t/* if an empty slot is found, assign the hook and return success */\n\thook_ptr->func = hook;\n\tresult = RT_EOK;\n\n\t/* release lock */\n\trt_spin_unlock(&rt_thread_idle_hook_lock);\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n__exit:\n\treturn result;\n}", "CodeBleu_score": 42.6342564544055}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_thread_idle_hook_t *idle_hook;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* find an empty slot */\n\tfor (idle_hook = &rt_thread_idle_hook_list; idle_hook != RT_NULL; idle_hook = idle_hook->next) {\n\t\tif (idle_hook->func == RT_NULL) {\n\t\t\t/* found */\n\t\t\tidle_hook->func = hook;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\tif (idle_hook->func == RT_NULL) {\n\t\treturn -RT_EFULL;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 36.92520137247391}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\trt_thread_idle_hook_t *idle_hook;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* lock the idle hook list */\n\trt_spin_lock_irqsave(&rt_thread_idle_hook_list_lock, level);\n\n\t/* find an empty slot */\n\tidle_hook = &rt_thread_idle_hook_list[0];\n\twhile (idle_hook->next != RT_NULL) {\n\t\tidle_hook = idle_hook->next;\n\t}\n\n\t/* if no empty slot is available */\n\tif (idle_hook->next == RT_NULL) {\n\t\t/* release the idle hook list */\n\t\trt_spin_unlock_irqrestore(&rt_thread_idle_hook_list_lock, level);\n\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\t/* set the hook */\n\t\tidle_hook->next = hook;\n\t\tidle_hook->arg = RT_NULL;\n\n\t\t/* release the idle hook list */\n\t\trt_spin_unlock_irqrestore(&rt_thread_idle_hook_list_lock, level);\n\n\t\tresult = RT_EOK;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 40.69009543412344}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\tstruct rt_thread *thread;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (hook == RT_NULL) {\n\t\tresult = RT_ERROR;\n\t} else {\n\t\tfor (thread = idle_thread; thread != RT_NULL; thread = thread->parent.next) {\n\t\t\tif (thread->idle_hook == hook) {\n\t\t\t\tthread->idle_hook = RT_NULL;\n\t\t\t\tresult = RT_EOK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (thread == RT_NULL) {\n\t\t\tresult = RT_ERROR;\n\t\t}\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 43.155899112446264}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\trt_thread_idle_hook_t *hook_ptr;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* find the hook in idle hook list */\n\thook_ptr = &rt_thread_idle_hook;\n\twhile (hook_ptr->next != RT_NULL) {\n\t\tif (hook_ptr->next == hook) {\n\t\t\t/* found, remove it */\n\t\t\thook_ptr->next = hook_ptr->next->next;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t\thook_ptr = hook_ptr->next;\n\t}\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 36.18191817951225}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_uint32_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tif (hook == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_object_get_type(&idle_object) != RT_Object_Class_Thread) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (idle_object.info.hook == hook) {\n\t\tidle_object.info.hook = RT_NULL;\n\t} else {\n\t\trt_list_t *node = idle_object.info.list.next;\n\t\twhile (node != &idle_object.info.list) {\n\t\t\tif (node->next != &idle_object.info.list) {\n\t\t\t\tif (node->next->data == hook) {\n\t\t\t\t\trt_list_del(node->next);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trt_kprintf(\"The hook is not found.\n\");\n\t\t\t\tresult = -RT_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnode = node->next;\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 39.50685850711259}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t", "CodeBleu_score": 6.3287479533471265}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t ret;\n\trt_thread_t thread;\n\trt_bool_t is_scheduler_locked;\n\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* ensure the scheduler is unlocked */\n\tlevel = rt_hw_interrupt_disable();\n\tis_scheduler_locked = rt_thread_is_scheduler_locked();\n\trt_hw_interrupt_enable(level);\n\tif (is_scheduler_locked == RT_TRUE) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* resume all threads in the list */\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\t/* dequeue a thread from the list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, suspended);\n\t\trt_list_del(&thread->suspended);\n\n\t\t/* resume the thread */\n\t\tthread->error = thread_error;\n\t\tret = rt_thread_resume(thread);\n\t\tif (ret != RT_EOK) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 34.82756556557369}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_err_t result;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check parameter */\n\tRT_ASSERT(susp_list != RT_NULL);\n\n\t/* resume all threads in the list */\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\t/* dequeue a thread from the list */\n\t\tthread = (rt_thread_t)rt_list_dequeue(susp_list);\n\n\t\t/* resume the thread */\n\t\tresult = rt_thread_resume(thread);\n\t\tif (result != RT_EOK) {\n\t\t\t/* if resume failed, enqueue the thread to the list */\n\t\t\trt_list_insert_before(susp_list, &(thread->tlist));\n\t\t}\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 36.58347297165147}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t console, device;\n\n\t/* save current console */\n\tconsole = rt_console_get_device();\n\n\t/* find new console device */\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\treturn console;\n\t}\n\n\t/* check if it is the same as the current console device */\n\tif (console == device) {\n\t\treturn console;\n\t}\n\n\t/* close current console device */\n\tif (console != RT_NULL) {\n\t\trt_device_close(console);\n\t}\n\n\t/* open new console device */\n\trt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\n\t/* set new console device */\n\trt_console_set_device(device);\n\n\treturn console;\n}", "CodeBleu_score": 49.46932956092351}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device, old_device;\n\told_device = rt_console_get_device();\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\trt_kprintf(\"find console device:%s failed\n\", name);\n\t\treturn old_device;\n\t}\n\tif (old_device != RT_NULL && old_device != device) {\n\t\trt_device_close(old_device);\n\t}\n\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)) {\n\t\trt_kprintf(\"open console device:%s failed\n\", name);\n\t\treturn old_device;\n\t}\n\trt_console_set_device(device);\n\treturn old_device;\n}", "CodeBleu_score": 54.4664607053455}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device, old_device;\n\n\told_device = rt_console_get_device();\n\n\t/* find device by name */\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\t/* check device type */\n\tif (device->type != RT_Device_Class_Char) {\n\t\treturn old_device;\n\t}\n\n\t/* close old device */\n\tif (old_device != RT_NULL) {\n\t\trt_device_close(old_device);\n\t}\n\n\t/* open device with read/write and stream flags */\n\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)) {\n\t\treturn old_device;\n\t}\n\n\t/* set new console device */\n\trt_console_set_device(device);\n\n\treturn old_device;\n}", "CodeBleu_score": 50.54619826274087}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_object_information *information;\n\n\tif (type >= RT_Object_Class_Max)\n\t\treturn 0;\n\n\tinformation = &rt_object_information_table[type];\n\n\trt_spin_lock_irqsave(information->object_list_lock);\n\n\trt_list_for_each_entry(struct rt_object, object, &information->object_list, list) {\n\t\tcount++;\n\t}\n\n\trt_spin_unlock_irqrestore(information->object_list_lock);\n\n\treturn count;\n}", "CodeBleu_score": 50.60862549283783}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_object_information_t *information;\n\trt_list_t *list;\n\trt_object_t *object;\n\trt_size_t count;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* get object list */\n\tlist = information->object_list;\n\tif (list == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* lock the spinlock */\n\trt_spin_lock_irqsave(information->object_list_lock);\n\n\t/* count the number of objects */\n\tcount = 0;\n\trt_list_for_each_entry(object, list, list) {\n\t\tcount ++;\n\t}\n\n\t/* release the spinlock */\n\trt_spin_unlock_irqrestore(information->object_list_lock);\n\n\treturn count;\n}", "CodeBleu_score": 51.207591608185965}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_base_t level;\n\trt_object_information_t *information;\n\trt_object_t *object;\n\tint count;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* lock object list */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* count objects */\n\tcount = 0;\n\tfor (object = information->object_list; object != RT_NULL; object = object->information->next) {\n\t\tcount ++;\n\t}\n\n\t/* unlock object list */\n\trt_hw_interrupt_enable(level);\n\n\treturn count;\n}", "CodeBleu_score": 43.411887336201225}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tif (object != RT_NULL) {\n\t\trt_object_information_t info;\n\n\t\t/* check object */\n\t\tRT_ASSERT(object->type != 0);\n\n\t\t/* get object information */\n\t\tinfo = (rt_object_information_t)object->type;\n\n\t\t/* call hook function */\n\t\tif (info->destructor != RT_NULL) {\n\t\t\tinfo->destructor(object);\n\t\t}\n\n\t\t/* remove object from list */\n\t\trt_list_remove(&(object->list));\n\n\t\t/* unlock object */\n\t\trt_spin_unlock(&(info->lock));\n\n\t\t/* set object type to RT_Object_Class_Unknown */\n\t\tobject->type = 0;\n\t}\n}", "CodeBleu_score": 44.41322567900075}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object != RT_NULL);\n\tif (object->type != RT_Object_Class_Unknown) {\n\t\trt_object_information_t info;\n\t\tinfo = (rt_object_information_t)object;\n\t\tif (info->object_detach_hook != RT_NULL) {\n\t\t\tinfo->object_detach_hook(object);\n\t\t}\n\t\trt_spin_lock_irqsave(&info->object_lock);\n\t\trt_list_remove(&(info->object_list));\n\t\tinfo->type = RT_Object_Class_Unknown;\n\t\trt_spin_unlock_irqrestore(&info->object_lock);\n\t}\n}", "CodeBleu_score": 53.12827809709636}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tRT_DEBUG_NULL_POINTER(object);\n\n\trt_object_information_t info;\n\n\t/* check object */\n\tRT_ASSERT(object->type != RT_Object_Class_Unknown);\n\n\t/* call hook */\n\tif (object->type != RT_Object_Class_Static) {\n\t\tif (object->parent.type != RT_Object_Class_Static) {\n\t\t\tif (object->parent.type == RT_Object_Class_Device) {\n\t\t\t\trt_device_t device;\n\t\t\t\tdevice = (rt_device_t)object;\n\t\t\t\tif (device->parent.type != RT_Object_Class_Static) {\n\t\t\t\t\tif (device->ops && device->ops->deinit) {\n\t\t\t\t\t\tdevice->ops->deinit(device);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (object->parent.type == RT_Object_Class_Module) {\n\t\t\t\trt_module_t module;\n\t\t\t\tmodule = (rt_module_t)object;\n\t\t\t\tif (module->parent.type != RT_Object_Class_Static) {\n\t\t\t\t\tif (module->deinit) {\n\t\t\t\t\t\tmodule->deinit(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* get object's information */\n\tinfo = object->information;\n\tRT_ASSERT(info != RT_NULL);\n\n\t/* lock object */\n\trt_spin_lock(&info->lock);\n\n\t/* remove object from list */\n\trt_list_remove(&(info->list));\n\n\t/* unlock object */\n\trt_spin_unlock(&info->lock);\n\n\t/* set object type to RT_Object_Class_Unknown */\n\tobject->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 46.04715226573536}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result;\n\n/* object check */\nRT_ASSERT(obj != RT_NULL);\nRT_ASSERT((obj->type & RT_Object_Class_Mask) == RT_Object_Class_Custom);\n\n/* call custom object's destroy function */\nresult = ((rt_custom_object_t)obj)->parent.parent.destroy(obj);\n\n/* delete the object */\nrt_object_delete(obj);\n\nreturn result;\n}", "CodeBleu_score": 43.35966726005259}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result;\n\trt_object_information_t information;\n\n\t/* object check */\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\t/* get object information */\n\tinformation = rt_object_get_information(obj->type);\n\tRT_ASSERT(information != RT_NULL);\n\n\t/* check if object has a destroy method */\n\tif (information->object_destroy != RT_NULL) {\n\t\t/* call destroy method */\n\t\tresult = information->object_destroy(obj);\n\n\t\t/* delete object */\n\t\trt_object_delete(obj);\n\n\t\t/* return result of destroy method */\n\t\treturn result;\n\t} else {\n\t\t/* delete object */\n\t\trt_object_delete(obj);\n\n\t\t/* return RT_EOK */\n\t\treturn RT_EOK;\n\t}\n}", "CodeBleu_score": 42.7399946965832}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result;\n\trt_object_information_t information;\n\n\t/* object check */\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\t/* get object information */\n\tinformation = rt_object_get_information((enum rt_object_class_type)obj->type);\n\tRT_ASSERT(information != RT_NULL);\n\n\t/* call object destroy */\n\tif (information->object_destroy != RT_NULL) {\n\t\tresult = information->object_destroy(obj);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 42.351898467210326}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\trt_base_t level;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\tRT_ASSERT(thread != RT_NULL);\n\n\t/* close current thread */\n\tlevel = rt_hw_interrupt_disable();\n\tthread->stat = RT_THREAD_CLOSE;\n\trt_hw_interrupt_enable(level);\n\n\t/* add thread to defunct thread list */\n\trt_thread_defunct_enqueue(thread);\n\n\t/* trigger a context switch */\n\trt_schedule();\n}", "CodeBleu_score": 60.95705108907556}, {"code": "static void _thread_exit(void){\n\t#ifdef RT_USING_HOOK\n    /* invoke thread exit hook */\n    rt_thread_exit_t exit_hook;\n\n    exit_hook = rt_thread_self()->exit_hook;\n    if (exit_hook != RT_NULL)\n    {\n        exit_hook();\n    }\n#endif\n\n    /* close thread */\n    rt_thread_close(rt_thread_self());\n\n    /* add thread to defunct list */\n    rt_thread_defunct_enqueue(rt_thread_self());\n\n    /* switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 49.259063977359055}, {"code": "static void _thread_exit(void){\n\t#ifdef RT_USING_HOOK\n    /* invoke thread exit hook */\n    rt_thread_exit_t exit_hook = rt_thread_self()->cleanup;\n    if (exit_hook != RT_NULL)\n    {\n        exit_hook();\n    }\n#endif /* RT_USING_HOOK */\n\n    /* close thread */\n    rt_thread_close(rt_thread_self());\n\n    /* add thread to defunct thread list */\n    rt_thread_defunct_enqueue(rt_thread_self());\n\n    /* trigger scheduling */\n    rt_schedule();\n}", "CodeBleu_score": 48.196649315497254}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\n\tthread = (struct rt_thread *)parameter;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\tRT_ASSERT(thread->parent.flag & RT_THREAD_FLAG_SUSPENDED);\n\tRT_ASSERT(thread->error == RT_EOK);\n\n\t/* suspend thread */\n\trt_thread_suspend(thread);\n\n\t/* set thread error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->parent.suspend_thread));\n\n\t/* insert thread into ready list */\n\trt_sched_insert_thread(thread);\n\n\t/* resume scheduler */\n\trt_schedule();\n}", "CodeBleu_score": 59.406146078413215}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\trt_base_t level;\n\tstruct rt_thread *t;\n\n\tthread = (rt_thread_t)parameter;\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check parameter */\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check thread status */\n\tif (thread->stat != RT_THREAD_SUSPEND) {\n\t\trt_kprintf(\"thread:%s is not suspend\n\", thread->name);\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* set thread error number */\n\tthread->error = -ETIME;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->suspend_list));\n\n\t/* insert thread into ready list */\n\trt_list_insert_before(&(rt_thread_self()->parent.parent.suspend_list), &(thread->parent.parent));\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\t/* resume thread */\n\trt_schedule();\n}", "CodeBleu_score": 43.20581607523446}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tRT_DEBUG_SCHEDULER_NOT_LOCKED;\n\tthread = (rt_thread_t)parameter;\n\t/* parameter check */\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(rt_object_is_systemobject((rt_object_t)thread));\n\tRT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\t/* set error number */\n\tthread->error = -ETIME;\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->suspend_list));\n\t/* insert thread into ready list */\n\trt_sched_insert_thread(thread);\n\t/* resume thread */\n\trt_schedule();\n}", "CodeBleu_score": 44.526906025697166}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_list_t *pos, *n;\n\trt_thread_mutex_t mutex;\n\n\tlevel = rt_hw_interrupt_disable();\n\t/* check if thread is waiting on a mutex */\n\tif (thread->object_type == RT_Object_Class_Mutex) {\n\t\tmutex = (rt_thread_mutex_t)thread->parent.data;\n\t\trt_list_for_each_safe(pos, n, &mutex->wait_list) {\n\t\t\tif (rt_list_entry(pos, struct rt_thread, list) == thread) {\n\t\t\t\trt_list_remove(pos);\n\t\t\t\tthread->object_type = RT_Object_Class_Null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* release all mutexes the thread has taken */\n\tpos = &thread->mutexes;\n\twhile (pos->next != &thread->mutexes) {\n\t\trt_thread_mutex_t mutex = rt_list_entry(pos->next, struct rt_thread_mutex, list);\n\t\trt_mutex_release(mutex);\n\t\tpos = pos->next;\n\t}\n\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 47.147827387583966}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t", "CodeBleu_score": 1.5259533266411016}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_mutex_t mutex;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* detach from any mutex the thread is waiting on */\n\tif (thread->parent.type == RT_Object_Class_Mutex) {\n\t\tmutex = (rt_mutex_t)thread->parent.parent.parent.data;\n\t\trt_mutex_detach_thread(mutex, thread);\n\t}\n\n\t/* detach from any mutex the thread has taken */\n\twhile (thread->mutex_list != RT_NULL) {\n\t\trt_mutex_t mutex;\n\n\t\tmutex = thread->mutex_list;\n\t\trt_mutex_detach_thread(mutex, thread);\n\t}\n\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 37.06344470709018}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\trt_thread_init_t init;\n\trt_thread_control_t control;\n\trt_uint8_t state;\n\trt_uint8_t flag;\n\trt_uint8_t level;\n\trt_err_t result;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\tif (thread->init_flag == RT_THREAD_INIT_FLAG) {\n\t\tLOG_D(\"thread start: %s, init_flag: %d\", thread->parent.name, thread->init_flag);\n\n\t\t/* set thread's priority */\n\t\tif (thread->init_priority != 0) {\n\t\t\trt_thread_set_priority(thread, thread->init_priority);\n\t\t}\n\n\t\t/* reset thread's state */\n\t\tstate = thread->parent.current_state;\n\t\tflag = thread->init_flag;\n\t\tlevel = thread->init_sl;\n\n\t\trt_thread_reset(thread);\n\n\t\tthread->parent.current_state = state;\n\t\tthread->init_flag = flag;\n\t\tthread->init_sl = level;\n\n\t\t/* start thread */\n\t\tresult = rt_thread_resume(thread);\n\n\t\tif (result == RT_EOK) {\n\t\t\trt_schedule();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 49.35187409734137}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_err_t error;\n\n\t/* parameter check */\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\tif (thread->stat != RT_THREAD_INIT) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\tlevel = rt_hw_interrupt_disable();\n\n\tif (thread->init_flag == RT_THREAD_FLAG_DEATH) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn -RT_ERROR;\n\t}\n\n\tthread->init_flag = RT_THREAD_FLAG_READY;\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\trt_hw_interrupt_enable(level);\n\n\terror = rt_thread_resume(thread);\n\n\tif (error == RT_EOK) {\n\t\tif (rt_thread_self() != RT_NULL) {\n\t\t\trt_schedule();\n\t\t}\n\t}\n\n\treturn error;\n}", "CodeBleu_score": 51.28853833869118}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_timer_t timer;\n\trt_list_t *list_head;\n\trt_list_t *list_next;\n\trt_list_t *timer_list_head;\n\trt_list_t *timer_list_next;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\ttimer_list_head = &timer_list[0];\n\tlist_head = timer_list_head->next;\n\n\tif (rt_list_isempty(list_head)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\ttimer_list_next = list_head->next;\n\ttimer = rt_list_entry(timer_list_next, struct rt_timer, list);\n\t*timeout_tick = timer->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.407329122750454}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list_head;\n\trt_list_t *list_node;\n\trt_timer_t timer;\n\n\t/* get the head of the highest level skip list */\n\tlist_head = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n\t/* check if the list is empty */\n\tif (rt_list_isempty(list_head)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\t/* get the first node of the highest level skip list */\n\tlist_node = rt_list_entry(list_head->next, struct rt_timer, list);\n\n\t/* get the first timer entry */\n\ttimer = rt_list_entry(list_node, struct rt_timer, list);\n\n\t/* set the timeout tick */\n\t*timeout_tick = timer->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 55.98868016922406}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t", "CodeBleu_score": 5.182189237133654}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_HEAP\n    rt_timer_t timer;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check parameter */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time != 0);\n\n    /* allocate a timer object */\n    timer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* insert timer to system timer list */\n    rt_timer_insert(timer);\n\n    /* set timer name */\n    rt_object_set_name((rt_object_t)timer, name);\n\n    return timer;\n#else\n    return RT_NULL;\n#endif /* RT_USING_HEAP */\n}", "CodeBleu_score": 65.8539341788477}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\tRT_ASSERT(timeout != RT_NULL)\n\tRT_ASSERT(time != 0)\n\tRT_ASSERT(time < (RT_TICK_MAX - 1))\n\n\trt_timer_t timer;\n\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer);\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t_timer_init(timer, timeout, parameter, time, flag);\n\n\t/* set timer name */\n\trt_object_init(&(timer->parent), name, RT_Object_Class_Timer);\n\n\t/* insert timer to system timer list */\n\trt_timer_insert(timer);\n\n\treturn timer;\n}", "CodeBleu_score": 66.29879065022715}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_HEAP\n    rt_timer_t timer;\n#endif\n\n    RT_ASSERT(timeout != RT_NULL)\n    RT_ASSERT(time > 0)\n\n    /* allocate memory */\n#ifdef RT_USING_HEAP\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer);\n    if (timer == RT_NULL) return RT_NULL;\n#else\n    extern rt_timer_t rt_timer_list;\n    timer = rt_timer_list;\n#endif\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* insert timer to timer list */\n    rt_list_insert_after(&(rt_timer_list->parent), &(timer->parent));\n\n    return timer;\n}", "CodeBleu_score": 58.04299249968445}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder to record the response.\n\trec := httptest.NewRecorder()\n\n\t// Copy the request so that it can be used in the handlers.\n\treq = req.Clone(req.Context())\n\n\t// Create a context to pass to the handlers.\n\tctx := context.WithValue(req.Context(), ctxKey, a)\n\n\t// Process the request.\n\tfor _, handler := range a.router.ServeHTTP:\n\t\t// Run the handler.\n\t\thandler.ServeHTTP(rec, req.WithContext(ctx))\n\n\t\t// Check if the request was unauthorized.\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\t// Send a \"Not Authorized\" error response.\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}", "CodeBleu_score": 50.49904650610837}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tdefer rec.Flush()\n\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 63.37327562017513}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tvar rec *httptest.ResponseRecorder\n\tif a.Recorder != nil {\n\t\trec = a.Recorder(req)\n\t\tdefer rec.Flush()\n\t}\n\tif a.Authorizer != nil {\n\t\tif !a.Authorizer(req) {\n\t\t\tif rec != nil {\n\t\t\t\trec.Code = http.StatusUnauthorized\n\t\t\t\trec.Body = []byte(http.StatusText(http.StatusUnauthorized))\n\t\t\t\tfor k, v := range rec.HeaderMap {\n\t\t\t\t\tres.Header()[k] = v\n\t\t\t\t}\n\t\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\t\t\thttp.Error(res, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\thandler := a.Router\n\tif a.Handler != nil {\n\t\thandler = a.Handler\n\t}\n\thandler.ServeHTTP(res, req)\n\tif rec != nil {\n\t\tfor k, v := range rec.HeaderMap {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tres.WriteHeader(rec.Code)\n\t\tio.Copy(res, rec.Body)\n\t}\n}", "CodeBleu_score": 42.776923426316856}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Retrieve the requested asset based on the URL path.\n\tpath := req.URL.Path[len(\"/robeaux/\"):]\n\tif path == \"\" {\n\t\tpath = \"index.html\"\n\t}\n\tcontent, err := a.Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\t// Set the appropriate Content-Type header based on the file extension.\n\text := path[strings.LastIndex(path, \".\"):len(path)]\n\tswitch ext {\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t}\n\t// Write the asset content to the response.\n\tres.Write(content)\n}", "CodeBleu_score": 57.50042553573175}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the requested asset.\n\tasset, err := a.assets.Open(req.URL.Path)\n\tif err != nil {\n\t\t// If the asset doesn't exist, return a 404 error.\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\n\t// Get the asset content.\n\tcontent, err := ioutil.ReadAll(asset)\n\tif err != nil {\n\t\t// If there is an error reading the asset, return a 500 error.\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Get the asset content type.\n\tcontentType := mime.TypeByExtension(filepath.Ext(req.URL.Path))\n\tif contentType == \"\" {\n\t\t// If the content type is empty, use a default value.\n\t\tcontentType = \"text/plain\"\n\t}\n\n\t// Set the content type header.\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the asset content to the response.\n\tres.Write(content)\n}", "CodeBleu_score": 52.963710288711205}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Parse the URL path to get the asset name.\n\turl := req.URL\n\tname := url.Path[len(\"/robeaux/\"):]\n\n\t// Open the asset.\n\tf, err := a.assets.Open(name)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\t// Get the content type from the asset name.\n\tcontentType := mime.TypeByExtension(filepath.Ext(name))\n\tif contentType == \"\" {\n\t\t// Use a default content type if the asset name does not have a file extension.\n\t\tcontentType = \"text/plain\"\n\t}\n\n\t// Set the content type header.\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the asset content to the response.\n\tio.Copy(res, f)\n}", "CodeBleu_score": 47.82628520916976}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSONError(res, http.StatusBadRequest, \"No robot name specified\")\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSONError(res, http.StatusNotFound, \"No robot found with name \"+name)\n\t\treturn\n\t}\n\tvar connections []*Connection\n\trobot.Connections().Each(func(conn interface{}) bool {\n\t\tconnections = append(connections, conn.(*Connection))\n\t\treturn true\n\t})\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 50.24012093882438}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write(a.writeJSON(map[string]interface{}{\n\t\t\t\"error\": fmt.Sprintf(\"No robot found with name '%s'\", name),\n\t\t}))\n\t\treturn\n\t}\n\tconnections := []map[string]interface{}{}\n\trobot.Connections().Each(func(conn gobot.Connection) bool {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\":         conn.Name(),\n\t\t\t\"adaptor\":      conn.Adaptor().Name(),\n\t\t\t\"port\":         conn.Port(),\n\t\t\t\"pin\":          conn.Pin(),\n\t\t\t\"address\":      conn.Address(),\n\t\t\t\"interval\":     conn.Interval(),\n\t\t\t\"max_attempts\": conn.MaxAttempts(),\n\t\t})\n\t\treturn true\n\t})\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(a.writeJSON(map[string]interface{}{\n\t\t\"connections\": connections,\n\t}))\n}", "CodeBleu_score": 48.38352548031238}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"No robot found with name: %s\", robotName)})\n\t\treturn\n\t}\n\n\tconnections := []string{}\n\trobot.Connections().Each(func(conn interface{}) {\n\t\tconnections = append(connections, conn.(string))\n\t})\n\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 51.90047442370367}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair) != 2 || !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 50.27380484687204}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth = strings.SplitN(auth, \" \", 2)[1]\n\t\tuser, pass, ok := decodeBasicAuth(auth)\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.82478235171444}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(u, username) || !secureCompare(p, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authorization was successful\n\t}\n}", "CodeBleu_score": 53.111067334716196}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation.\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\n\t// Return a function that performs the scaling.\n\treturn func(input float64) (value int) {\n\t\t// Calculate the output value.\n\t\tvalue = int(slope * input + intercept)\n\n\t\t// Clamp the output value.\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t} else if value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.218195679121926}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(math.Min(slope*input+intercept, toMax), toMin))\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.30718858721427}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(toMin, math.Min(toMax, slope*input + intercept)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.6283554241579}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection == nil {\n\t\treturn 0, 0, errors.New(\"connection not set\")\n\t}\n\n\tif !a.Connection.AnalogInput() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog input\")\n\t}\n\n\traw, err := a.Connection.AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.sensorCfg.scale(raw)\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 50.2643700210041}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().AnalogInput() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog input\", a.Connection().Name())\n\t}\n\n\traw := a.Pin().AnalogRead()\n\tscaled := a.sensorCfg.scale(raw)\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 38.784746645980796}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().AnalogInput() {\n\t\treturn 0, 0.0, fmt.Errorf(\"connection %s does not support analog input\", a.Connection().Name())\n\t}\n\n\traw, err := a.Pin().AnalogRead()\n\tif err != nil {\n\t\treturn raw, 0.0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 47.78046177001693}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 40.09414721088014}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 40.09414721088014}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 43.474581804469395}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tanalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.AddEvent(\"vibration\")\n\tg.analogSensorDriver.AddEventListener(\"data\", func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tg.Publish(\"vibration\")\n\t\t}\n\t})\n\tif err := g.analogSensorDriver.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\treturn g\n}", "CodeBleu_score": 50.17064034833473}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"Grove Piezo Vibration Sensor\"),\n\t\tanalogReader: a,\n\t\tpin: pin,\n\t}\n\td.AddEvent(d.Event(\"vibration\"))\n\tfor _, opt := range opts {\n\t\topt.(func(*GrovePiezoVibrationSensorDriver))(d)\n\t}\n\tvar err error\n\td.read, err = d.analogReader.AnalogPin(d.pin)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo d.start()\n\treturn d\n}", "CodeBleu_score": 44.52556014324872}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tanalogReader: a,\n\t\tpin: pin,\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase string:\n\t\t\td.name = o\n\t\tdefault:\n\t\t\tpanic(\"Invalid option\")\n\t\t}\n\t}\n\n\td.AddEvent(d.Event(\"vibration\"))\n\n\tgo func() {\n\t\tfor {\n\t\t\td.AddEvent(d.Event(\"vibration\"))\n\t\t\td.Publish(d.Event(\"vibration\"), d.analogReader.Read(d.pin))\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}()\n\n\treturn d\n}", "CodeBleu_score": 33.536969135382336}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"frequency must be greater than zero\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"duration must be greater than zero\")\n\t}\n\tperiod := 1.0 / hz\n\ttempo := 60.0 / d.Bpm\n\tcycles := duration * tempo\n\tcycleTime := period / 2\n\thighTime := period - cycleTime\n\tfor i := 0; i < int(cycles); i++ {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(cycleTime * time.Second)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(highTime * time.Second)\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.44333611749681}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"frequency must be greater than 0\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"duration must be greater than 0\")\n\t}\n\n\tperiod := 1.0 / hz\n\tdelay := period / 2\n\tcycles := int(duration * float64(d.bpm))\n\tfor i := 0; i < cycles; i++ {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay * time.Second)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay * time.Second)\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.57863215994142}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.On {\n\t\treturn errors.New(\"buzzer already on\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"frequency must be greater than zero\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"duration must be greater than zero\")\n\t}\n\tperiod := 1.0 / hz\n\ttempo := d.BeatsPerMinute()\n\tif tempo <= 0 {\n\t\treturn errors.New(\"tempo must be greater than zero\")\n\t}\n\tbeats := duration * float64(tempo)\n\tdelay := time.Duration(period / 2)\n\tfor i := 0.0; i < beats; i++ {\n\t\td.On = true\n\t\ttime.Sleep(delay)\n\t\td.On = false\n\t\ttime.Sleep(delay)\n\t}\n\treturn nil\n}", "CodeBleu_score": 35.86175012019235}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\tif d.sleepPin.Read() == gpio.High {\n\t\treturn fmt.Errorf(\"sleep pin already high\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, gpio.Low)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 41.693151624775105}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"no sleep pin configured\")\n\t}\n\tif d.running {\n\t\td.stopIfRunning()\n\t}\n\td.digitalWrite(d.sleepPin, LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 34.0551877739714}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.78412909705358}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin = a.sys.NewAnalogPin(pin.Name, pin.Pin)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 58.31699290106498}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.RLock()\n\tdefer a.mutex.RUnlock()\n\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPins map not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.sys.NewAnalogPin(path)\n\tif pin == nil {\n\t\treturn nil, fmt.Errorf(\"Invalid analog pin: %s\", id)\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 56.35546752310297}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.sys.NewAnalogPin(path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 53.610080005127806}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id, gobot.Output)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 65.78646084730781}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\ta.mutex.Unlock()\n\t\treturn err\n\t}\n\tpin.Write(val)\n\ta.mutex.Unlock()\n\treturn nil\n}", "CodeBleu_score": 54.22827128602681}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 65.821263485048}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connected == false {\n\t\treturn nil, fmt.Errorf(\"digitalPin: no pins connected\")\n\t}\n\tpin, err := a.sys.NewDigitalPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\tpin.ApplyOptions()\n\tif pin.Name() == \"\" {\n\t\tpin.SetName(id)\n\t}\n\tif _, exists := a.pins[pin.Name()]; exists == false {\n\t\ta.pins[pin.Name()] = pin\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 38.969214552928996}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.sys == nil {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor not connected\")\n\t}\n\tpin, err := a.sys.NewDigitalPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin.ApplyOptions(opts...)\n\treturn pin, nil\n}", "CodeBleu_score": 26.82778222093586}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.Connected() == false {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor %v is not connected\", a.Name())\n\t}\n\n\tpin, err := a.Pin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\tif pin.DigitalPin == nil {\n\t\tpin.DigitalPin = a.sys.NewDigitalPin(\n\t\t\tpin.Chip,\n\t\t\tpin.Line,\n\t\t\tpin.Options,\n\t\t)\n\t\tif pin.DigitalPin == nil {\n\t\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor %v failed to create digital pin\", a.Name())\n\t\t}\n\t\terr = pin.DigitalPin.ApplyOptions(pin.Options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.digitalPins[pin.ID] = pin\n\t}\n\n\treturn pin.DigitalPin, nil\n}", "CodeBleu_score": 49.603652094091025}]}
