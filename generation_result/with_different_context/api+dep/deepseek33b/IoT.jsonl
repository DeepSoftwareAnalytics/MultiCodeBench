{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *) desc;\n\twhile ((desc_ptr < (uint8_t *) (desc + desc->bLength)) &&\n\t\t\t(*desc_ptr != desc_id)) {\n\t\tdesc_ptr += *(desc_ptr + 1);\n\t}\n\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n}", "CodeBleu_score": 28.173301847047032}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength != 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 37.31385895777869}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint16_t len = desc->bLength;\n\twhile (len > 0) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + len);\n\t\tlen = desc->bLength;\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 35.14104813456882}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t  if (!udc_get_eof_conf()) {\n    return false;\n  }\n\n  if (iface_num >= USB_NUM_INTERFACES) {\n    return false;\n  }\n\n  uint8_t *desc_ptr = udc_get_conf_desc();\n  while (desc_ptr < udc_get_eof_conf()) {\n    uint8_t desc_type = *desc_ptr;\n    if (desc_type == USB_DESC_TYPE_INTERFACE) {\n      uint8_t iface_index = desc_ptr[USB_INTF_DESC_INDEX_IFACE_NUMBER];\n      uint8_t alt_setting = desc_ptr[USB_INTF_DESC_INDEX_ALT_SETTING];\n      if (iface_index == iface_num && alt_setting == setting_num) {\n        return true;\n      }\n    }\n    desc_ptr += desc_ptr[0];\n  }\n  return false;\n}", "CodeBleu_score": 37.534708779082024}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    struct usb_config_descriptor *conf_desc;\n    struct usb_interface_descriptor *iface_desc;\n    struct usb_interface_assoc_descriptor *iface_assoc_desc;\n    uint8_t *desc_ptr;\n    uint8_t *desc_end;\n    bool found = false;\n\n    conf_desc = (struct usb_config_descriptor *)udc_get_eof_conf();\n    if (conf_desc == NULL) {\n        return false;\n    }\n\n    if (iface_num >= conf_desc->bNumInterfaces) {\n        return false;\n    }\n\n    desc_ptr = (uint8_t *)conf_desc;\n    desc_end = (uint8_t *)conf_desc + conf_desc->wTotalLength;\n\n    while (desc_ptr < desc_end) {\n        if (*desc_ptr == USB_DESC_INTERFACE) {\n            iface_desc = (struct usb_interface_descriptor *)desc_ptr;\n            if (iface_desc->bInterfaceNumber == iface_num) {\n                if (iface_desc->bAlternateSetting == setting_num) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n        desc_ptr += desc_ptr[0];\n    }\n\n    return found;\n}", "CodeBleu_score": 45.41187145411557}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tbool found = false;\n\tstruct usb_interface_descriptor *iface_desc = NULL;\n\n\tif (!udc_get_eof_conf()) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= USB_MAX_INTERFACES) {\n\t\treturn false;\n\t}\n\n\tiface_desc = (struct usb_interface_descriptor *)udc_get_conf_desc();\n\n\twhile (iface_desc) {\n\t\tif (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tiface_desc = (struct usb_interface_descriptor *)usb_desc_next(iface_desc);\n\t}\n\n\treturn found;\n}", "CodeBleu_score": 32.84745084990534}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udd_ep_get_status_length != sizeof(udd_ep_status)) {\n        return false;\n    }\n\n    udd_ep_status = udd_ep_is_halted(udd_ep_get_status_ep) ? UDD_EP_STATUS_HALTED : 0;\n    udd_set_setup_payload((uint8_t *)&udd_ep_status, sizeof(udd_ep_status));\n    return true;\n}", "CodeBleu_score": 40.18007387589234}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t  if (udd_ep_is_halted(udd_ep_get_in_num())) {\n    udd_set_setup_payload(udd_ep_get_in_num(), UDC_EP_STATUS_HALTED);\n  } else {\n    udd_set_setup_payload(udd_ep_get_in_num(), 0);\n  }\n  return true;\n}", "CodeBleu_score": 19.849817535325798}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udd_req_wLength() != sizeof(udd_ep_status_t)) {\n        return false;\n    }\n\n    udd_ep_status_t ep_status;\n    if (udd_ep_is_halted(udd_req_wIndex())) {\n        ep_status = UDD_EP_STATUS_HALTED;\n    } else {\n        ep_status = 0;\n    }\n\n    udd_set_setup_payload((uint8_t*)&ep_status, sizeof(ep_status));\n    return true;\n}", "CodeBleu_score": 38.24685353754425}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\t// Check if device is in a configured state\n\tif (udc_state != UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\t// Get the interface number\n\tiface_num = udc_setup_req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Get the alternate setting number\n\tsetting_num = udc_setup_req.wIndex >> 8;\n\n\t// Update the interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the setup request to the corresponding UDI handler\n\treturn udi_api->setup(udc_setup_req.bRequest, udc_setup_req.wValue,\n\t\t\tudc_setup_req.wIndex, udc_setup_req.wLength);\n}", "CodeBleu_score": 62.51936821402151}, {"code": "static bool udc_req_iface(void){\n\t\tbool result;\n\n\tif (0 == udc_num_configuration) {\n\t\t// Device not configured\n\t\treturn false;\n\t}\n\n\tif (udc_req.wIndex > udc_ptr_conf->desc->bNumInterfaces) {\n\t\t// Interface number is invalid\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(udc_req.wIndex, 0)) {\n\t\t// Interface descriptor not found\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(udc_req.wIndex, udc_ptr_iface->bAlternateSetting)) {\n\t\t// Interface descriptor not found\n\t\treturn false;\n\t}\n\n\t// Forward setup request to UDI handler\n\tresult = udi_api->setup(udc_req.bmRequestType, udc_req.bRequest,\n\t\t\tudc_req.wValue, udc_req.wIndex, udc_req.wLength,\n\t\t\tudc_ptr_iface->bInterfaceClass,\n\t\t\tudc_ptr_iface->bInterfaceSubClass,\n\t\t\tudc_ptr_iface->bInterfaceProtocol,\n\t\t\tudc_ptr_iface->iInterface);\n\n\treturn result;\n}", "CodeBleu_score": 57.69177126890275}, {"code": "static bool udc_req_iface(void){\n\t\tbool ret;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (udc_req.wIndex > udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tret = udc_update_iface_desc(udc_req.wIndex, 0);\n\tif (!ret) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tret = udc_update_iface_desc(udc_req.wIndex, udc_ptr_iface->bAlternateSetting);\n\tif (!ret) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tret = udi_api->setup(udc_req.bRequest, udc_req.wValue, udc_req.wIndex,\n\t\t\tudc_req.wLength);\n\n\treturn ret;\n}", "CodeBleu_score": 58.168486749681605}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t  // Check if the MSC interface is already enabled\n  if (udi_msc_enable_count > 0) {\n    // Increment the enable count\n    udi_msc_enable_count++;\n    return true;\n  }\n\n  // Check if the external enable function is available and returns false\n  if (udi_msc_enable_ext && !udi_msc_enable_ext()) {\n    return false;\n  }\n\n  // Set the MSC interface as enabled\n  udi_msc_enable_count++;\n\n  // Get the number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n\n  // Check if there are any LUNs available\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t lun = 0; lun < udi_msc_nb_lun; lun++) {\n    mem_unload(lun);\n  }\n\n  // Start the MSC process by waiting for a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 53.260768455233396}, {"code": "bool udi_msc_enable(void){\n\t  // Check if the external enable function is available\n  if (!UDI_MSC_ENABLE_EXT) {\n    return false;\n  }\n\n  // Check if the external enable function fails\n  if (!UDI_MSC_ENABLE_EXT()) {\n    return false;\n  }\n\n  // Set initial states for several flags\n  udi_msc_cbw_state = UDI_MSC_CBW_STATE_IDLE;\n  udi_msc_cbw_error = UDI_MSC_CBW_STATE_IDLE;\n  udi_msc_cbw_pending = false;\n\n  // Retrieve the number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n\n  // Check if there are any LUNs available\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_nb_lun; i++) {\n    mem_unload(i);\n  }\n\n  // Start the MSC process by waiting for a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 56.09082307561511}, {"code": "bool udi_msc_enable(void){\n\t  // Set initial state\n  udi_msc_cbw_state = UDI_MSC_CBW_STATE_IDLE;\n  udi_msc_cbw_count = 0;\n  udi_msc_cbw_lun = 0;\n  udi_msc_cbw_lun_nb = get_nb_lun();\n\n  // Check if any LUN is available\n  if (udi_msc_cbw_lun_nb == 0) {\n    return false;\n  }\n\n  // Unload medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_cbw_lun_nb; i++) {\n    mem_unload(i);\n  }\n\n  // Start MSC process\n  if (!UDI_MSC_ENABLE_EXT()) {\n    return false;\n  }\n\n  // Wait for CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 51.2899906295422}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_TRANSFER_OK) {\n    // Wait for MSC setup reset to restart CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_update_sense(nb_sent);\n  // Decrease data residue in CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 71.70918057135025}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_TRANSFER_OK) {\n    // Wait for MSC setup reset to restart CBW reception\n    udi_msc_sense_pass();\n    udi_msc_csw.dCSWDataResidue = 0;\n    udi_msc_csw_process();\n    return;\n  }\n  // Update sense data\n  if (ep == UDI_MSC_EP_IN) {\n    udi_msc_sense_pass();\n  } else {\n    // Decrease data residue in CSW by amount of data sent\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n  }\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 58.138129185329454}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status == UDD_EP_TRANSFER_OK) {\n    // Data transfer successful\n    udi_msc_clear_sense();\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    udi_msc_csw_process();\n  } else {\n    // Data transfer error\n    // Wait for MSC setup reset to restart CBW reception\n    udi_msc_sense_pass();\n    udi_msc_csw.bCSWStatus = USB_CSW_STATUS_FAILED;\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 62.131569081630786}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t  // Process CSW\n  if (udi_msc_csw.bCSWSignature == UDI_MSC_CSW_SIGNATURE) {\n    // Check CSW signature\n    if (udi_msc_csw.bCSWTag == udi_msc_cbw.bCBWTag) {\n      // Check CSW tag\n      if (udi_msc_csw.dCSWDataResidue != 0) {\n        // If data residue is not zero\n        // then stall next request\n        udd_ep_set_halt(UDI_MSC_EP_IN, true);\n        udd_ep_set_halt(UDI_MSC_EP_OUT, true);\n      }\n    }\n  }\n\n  // Prepare CSW\n  udi_msc_csw.bCSWSignature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw.bCSWTag = udi_msc_cbw.bCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 60.71127663512957}, {"code": "static void udi_msc_csw_process(void){\n\t  // Process CSW on OUT endpoint\n  if (udi_msc_cbw.dCBWDataTransferLength != 0) {\n    // Data residue, stall next request\n    if (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_FLAG_OUT) {\n      udd_ep_set_stall(UDI_MSC_EP_OUT, true);\n    } else {\n      udd_ep_set_stall(UDI_MSC_EP_IN, true);\n    }\n  }\n  // Prepare CSW\n  udi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n  udi_msc_csw.bmCSWStatus = UDI_MSC_CSW_STATUS_SUCCESS;\n  udi_msc_csw_send();\n}", "CodeBleu_score": 55.070837955917575}, {"code": "static void udi_msc_csw_process(void){\n\t  // Process CSW\n  if (udi_msc_csw.bCSWSignature != UDI_MSC_CSW_SIGNATURE) {\n    // CSW Signature error\n    udi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_FAILED;\n  }\n\n  if (udi_msc_csw.bCSWStatus == UDI_MSC_CSW_STATUS_PASSED) {\n    // Check if data residue\n    if (udi_msc_csw.dwResidue) {\n      // Stall next request\n      if (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_FLAG_DIR_IN) {\n        // IN direction\n        udd_ep_set_stall(UDI_MSC_EP_IN, true);\n      } else {\n        // OUT direction\n        udd_ep_set_stall(UDI_MSC_EP_OUT, true);\n      }\n    }\n  }\n\n  // Prepare CSW\n  udi_msc_csw.dwTag = cpu_to_le32(udi_msc_cbw.dwTag);\n  udi_msc_csw.dwResidue = cpu_to_le32(udi_msc_csw.dwResidue);\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 55.07588257170062}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (port == 0) {\n        if (b_enable) {\n            // DTR is enabled, cancel any scheduled reset\n            cancelReset();\n        } else {\n            // DTR is disabled, schedule a delayed system reset\n            if (usb_task_cdc_get_line_coding(port).dwDTERate == 1200) {\n                // DTR rate is 1200, schedule a delayed system reset\n                initiateReset();\n            }\n        }\n    }\n}", "CodeBleu_score": 34.050525234246635}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (b_enable) {\n        usb_task_cdc_dtr_enable(port);\n        cancelReset();\n    } else {\n        usb_task_cdc_dtr_disable(port);\n        if (usb_task_cdc_dtr_get_rate(port) == 1200) {\n            usb_task_cdc_dtr_disable(port);\n            initiateReset();\n        }\n    }\n}", "CodeBleu_score": 43.78815387966821}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (b_enable) {\n        // DTR is enabled, cancel reset\n        cancelReset();\n    } else {\n        // DTR is disabled, schedule reset\n        if (usb_cdc_get_line_coding(port).dwDTERate == 1200) {\n            initiateReset();\n        }\n    }\n}", "CodeBleu_score": 35.11434638211571}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t    if (Udd_setup_type == USB_SETUP_TYPE_STANDARD) {\n        switch (Udd_setup_request) {\n        case 0x04:\n            Udd_setup_payload_ptr = (uint8_t *)&Microsoft_compatible_ID_descriptor;\n            Udd_setup_payload_size = sizeof(Microsoft_compatible_ID_descriptor);\n            break;\n        case 0x05:\n            Udd_setup_payload_ptr = (uint8_t *)&Microsoft_extended_properties_descriptor;\n            Udd_setup_payload_size = sizeof(Microsoft_extended_properties_descriptor);\n            break;\n        default:\n            return false;\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 21.776425041231096}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t\tbool ret = false;\n\tswitch (Udd_setup_type) {\n\tcase USB_SETUP_TYPE_STANDARD:\n\t\tswitch (Udd_setup_request) {\n\t\tcase 0x04:\n\t\t\tUdd_control_request_payload = (uint8_t *)&Udd_ms_os_desc;\n\t\t\tUdd_control_request_payload_size = sizeof(Udd_ms_os_desc);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tUdd_control_request_payload = (uint8_t *)&Udd_ms_ext_prop_desc;\n\t\t\tUdd_control_request_payload_size = sizeof(Udd_ms_ext_prop_desc);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 18.388773648680036}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tSPI_PCS |= SPI_SS_bm;\n\twhile (nbyte--) {\n\t\tspiRec();\n\t\t*buf++ = spiRec();\n\t}\n\t*buf = spiRec();\n\tSPI_PCS &= ~SPI_SS_bm;\n}", "CodeBleu_score": 33.29963926778354}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0) {\n        return;\n    }\n\n    nbyte--;\n    spiRec();\n    while (nbyte--) {\n        spiRec();\n        spiRec();\n    }\n    spiRec();\n}", "CodeBleu_score": 28.661357939264708}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0)\n        return;\n    spiSend(SPI_PCS, buf[0]);\n    while (--nbyte > 0) {\n        spiSend(SPI_PCS, 0xFF);\n        buf[0] = spiRec(SPI_PCS);\n        buf++;\n    }\n    buf[0] = spiRec(SPI_PCS);\n}", "CodeBleu_score": 36.45467440044373}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = NULL;\n    uint32_t *pIsr = get_relocated_table_addr();\n\n    __disable_irq();\n    oldHandler = (pfnISR_Handler)pIsr[irq + 16];\n    pIsr[irq + 16] = (uint32_t)newHandler;\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 61.427902735605656}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\n\tuint32_t *pVectorTable;\n\tuint32_t *pOldVector;\n\tuint32_t *pNewVector;\n\tuint32_t *pOldVectorTable;\n\tuint32_t *pNewVectorTable;\n\n\tCRITICAL_SECTION_START\n\n\t/* Get the address of the relocated interrupt vector table. */\n\tpVectorTable = get_relocated_table_addr();\n\n\t/* Get the address of the current interrupt vector. */\n\tpOldVector = (uint32_t *)pVectorTable[irq];\n\n\t/* Replace the current interrupt vector with the new handler. */\n\tpNewVector = (uint32_t *)newHandler;\n\tpVectorTable[irq] = (uint32_t)pNewVector;\n\n\t/* Get the address of the current interrupt vector table. */\n\tpOldVectorTable = (uint32_t *)pVectorTable;\n\n\t/* Replace the current interrupt vector table with the new table. */\n\tpNewVectorTable = (uint32_t *)pVectorTable;\n\tpVectorTable = (uint32_t *)pNewVectorTable;\n\n\tCRITICAL_SECTION_END\n\n\t/* Return the original interrupt handler. */\n\treturn (pfnISR_Handler)pOldVector;\n}", "CodeBleu_score": 41.2971303889064}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler originalHandler;\n\n    CRITICAL_SECTION_START\n    pfnISR_Handler *pHandler = &get_relocated_table_addr()[irq];\n    originalHandler = *pHandler;\n    *pHandler = newHandler;\n    CRITICAL_SECTION_END\n\n    return originalHandler;\n}", "CodeBleu_score": 48.08489669071704}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (is_enabled() && is_connected()) {\n    int c = udi_cdc_getc();\n    if (c != -1) {\n      #if ENABLED(EMERGENCY_PARSER)\n        if (parser.seen('M')) {\n          if (parser.seen('112')) {\n            emergency_parser.M112();\n            return -1;\n          }\n          else if (parser.seen('114')) {\n            emergency_parser.M114();\n            return -1;\n          }\n        }\n      #endif\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 35.05390326991653}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready()) {\n    const int c = udi_cdc_getc();\n    if (TERN_(EMERGENCY_PARSER, emergency_parser.update(c)))\n      return c;\n    else\n      return -1;\n  }\n  else\n    return -1;\n}", "CodeBleu_score": 37.03100351037645}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled()) {\n    int c = udi_cdc_getc();\n    if (c >= 0) {\n      if (TERN_(EMERGENCY_PARSER, ENABLED)) emergency_parser.update(c);\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 40.40867188922609}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      const int c = udi_cdc_getc();\n      if (c != -1) {\n        emergency_parser.update(c);\n      }\n      return c;\n    }\n  }\n  else\n    return -1;\n}", "CodeBleu_score": 32.96984725941739}, {"code": "int MarlinSerialUSB::read(){\n\t    int c = -1;\n\n    if (usb_task_cdc_isenabled()) {\n        if (pending_byte) {\n            c = pending_byte;\n            pending_byte = 0;\n        } else if (udi_cdc_is_rx_ready()) {\n            udi_cdc_getc(&c);\n            if (emergency_parser.enabled) emergency_parser.update(c);\n        }\n    }\n\n    return c;\n}", "CodeBleu_score": 45.675275412031965}, {"code": "int MarlinSerialUSB::read(){\n\t    if (udi_cdc_is_rx_ready()) {\n        return udi_cdc_getc();\n    }\n    if (!usb_task_cdc_isenabled()) return -1;\n    if (!udi_cdc_is_rx_ready()) return -1;\n    int c = udi_cdc_getc();\n    #if ENABLED(EMERGENCY_PARSER)\n      if (TERN_(EMERGENCY_PARSER, parser.seen('M'))) {\n        parser.copy_buffer(c);\n        if (TERN_(EMERGENCY_PARSER, parser.complete())) {\n          parser.process_command();\n          parser.clear_buffer();\n        }\n      }\n    #endif\n    return c;\n}", "CodeBleu_score": 56.56271183239856}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      return 1;\n    }\n    return 0;\n  }\n  return usb_task_cdc_rx_available();\n}", "CodeBleu_score": 23.69470294744474}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled()) {\n    return usb_task_cdc_rx_ready();\n  } else {\n    return 0;\n  }\n}", "CodeBleu_score": 22.39569884786004}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled()) {\n    return udi_cdc_is_rx_ready();\n  }\n  return 0;\n}", "CodeBleu_score": 22.573788354455992}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value++ = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 65.80663681108155}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n  while (size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 76.85718888453839}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 76.74303381053437}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= MAX_PWM_IOPIN) return; // Not a PWM pin\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == res) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid < 0) return;\n  ledcWrite(cid, value);\n}", "CodeBleu_score": 36.480836273159255}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= MAX_PWM_IOPIN || pin < 0) return;\n\n  int8_t cid = channel_for_pin(pin);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n\n  // Allocate a new channel\n  cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n}", "CodeBleu_score": 34.40716737107422}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= MAX_PWM_IOPIN) return;\n\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n  else {\n    int8_t sid = get_sw_pwm_slot(pin);\n    if (sid < 0) {\n      sid = alloc_sw_pwm_slot(pin);\n      if (sid < 0) return;\n      HAL_timer_start(pin, freq, res);\n      pwm_used++;\n    }\n    pwm_state[sid].value = value;\n  }\n}", "CodeBleu_score": 48.6293327491711}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 40.689774758976164}, {"code": "void Servo::move(const int value){\n\t  static_assert(COUNT(servo_delay) == NUM_SERVOS, \"SERVO_DELAY must be defined for all NUM_SERVOS\");\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 61.43662002174255}, {"code": "void Servo::move(const int value){\n\t  #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n    constexpr bool UNUSE_CHANNEL = true;\n  #else\n    constexpr bool KEEP_CHANNEL = false;\n  #endif\n\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      if (UNUSE_CHANNEL) detach();\n    #endif\n  }\n}", "CodeBleu_score": 55.01244500177476}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t    // Loop through all pins\n    for (int i = 0; i < NUM_PINS; i++) {\n        // Check if the pin has active PWM\n        if (pins[i].duty_cycle > 0) {\n            // If the PWM tick count reaches zero, toggle the pin state and reset the tick count\n            if (pins[i].tick_count == 0) {\n                pins[i].state = !pins[i].state;\n                pins[i].tick_count = pins[i].duty_cycle;\n            } else {\n                // Decrement the tick count\n                pins[i].tick_count--;\n            }\n        }\n        // Set the pin state in the port data\n        if (pins[i].state) {\n            pins[i].port_data |= pins[i].pin_mask;\n        } else {\n            pins[i].port_data &= ~pins[i].pin_mask;\n        }\n    }\n    // Store the updated port data into the current position of the DMA buffer\n    dma_buffer[dma_buffer_pos] = pins[0].port_data;\n    // Increment the buffer position\n    dma_buffer_pos++;\n}", "CodeBleu_score": 41.51456129027139}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}, {"code": "void i2s_push_sample(){\n\t  uint32_t mask;\n  uint32_t port;\n  uint32_t bit;\n  uint32_t state;\n  uint32_t next;\n\n  for (uint32_t i = 0; i < NUM_I2S_PINS; i++) {\n    mask = i2s_pins[i].mask;\n    port = i2s_pins[i].port;\n    bit = i2s_pins[i].bit;\n    state = i2s_pins[i].state;\n    next = i2s_pins[i].next;\n\n    if (next == 0) {\n      if (state) {\n        next = i2s_pins[i].on_time;\n        i2s_pins[i].state = 0;\n        i2s_pins[i].port_regs->SODR.reg = mask;\n      } else {\n        next = i2s_pins[i].off_time;\n        i2s_pins[i].state = 1;\n        i2s_pins[i].port_regs->CODR.reg = mask;\n      }\n    }\n\n    i2s_pins[i].next = next - 1;\n  }\n\n  i2s_buffer[i2s_buffer_index] = port;\n  i2s_buffer_index = (i2s_buffer_index + 1) % I2S_BUFFER_SIZE;\n}", "CodeBleu_score": 28.28555376274139}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    // Check if the timer number is valid\n    if (timer_num >= NUM_OF_HW_TIMERS) {\n        return 0;\n    }\n\n    // Retrieve the current counter value from the timer\n    return timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 20.681853198621557}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t timer_count;\n    switch (timer_num) {\n        case 0:\n            timer_count = timer_get_counter_value(TIMER0);\n            break;\n        case 1:\n            timer_count = timer_get_counter_value(TIMER1);\n            break;\n        case 2:\n            timer_count = timer_get_counter_value(TIMER2);\n            break;\n        case 3:\n            timer_count = timer_get_counter_value(TIMER3);\n            break;\n        default:\n            break;\n    }\n    return timer_count;\n}", "CodeBleu_score": 39.006815400980905}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  hal_timer_t count;\n  switch (timer_num) {\n    case TIMER_0:\n      count = timer_get_counter_value(TIMER0);\n      break;\n    case TIMER_1:\n      count = timer_get_counter_value(TIMER1);\n      break;\n    case TIMER_2:\n      count = timer_get_counter_value(TIMER2);\n      break;\n    case TIMER_3:\n      count = timer_get_counter_value(TIMER3);\n      break;\n    default:\n      count = 0;\n      break;\n  }\n  return count;\n}", "CodeBleu_score": 40.06424526491491}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  while (size_t bytes_read = (pos & (SPI_FLASH_SEC_SIZE - 1)), bytes_read && size) {\n    bytes_read = min(bytes_read, size);\n    size -= bytes_read;\n    if (writing)\n      memcpy(value, (const void *)pos, bytes_read);\n    crc16(crc, (const uint8_t *)pos, bytes_read);\n    pos += bytes_read;\n    value += bytes_read;\n  }\n  if (size >= SPI_FLASH_SEC_SIZE) {\n    size_t secs = size / SPI_FLASH_SEC_SIZE;\n    if (writing)\n      flashmem_read(pos, value, secs * SPI_FLASH_SEC_SIZE);\n    crc16(crc, (const uint8_t *)pos, secs * SPI_FLASH_SEC_SIZE);\n    pos += secs * SPI_FLASH_SEC_SIZE;\n    value += secs * SPI_FLASH_SEC_SIZE;\n    size -= secs * SPI_FLASH_SEC_SIZE;\n  }\n  if (size) {\n    if (writing)\n      flashmem_read(pos, value, size);\n    crc16(crc, (const uint8_t *)pos, size);\n    pos += size;\n    value += size;\n  }\n  return false;\n}", "CodeBleu_score": 42.62228627385251}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint8_t *ptr = value;\n  while (size--) {\n    *ptr = EEPROM.read(pos);\n    crc16(crc, ptr, 1);\n    if (writing)\n      *ptr++ = *ptr;\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 45.9941229230654}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t c = EEPROM.read(pos);\n    if (writing)\n      *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    if (writing)\n      value++;\n  }\n  return false;\n}", "CodeBleu_score": 66.29217488210914}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    SD_HandleTypeDef *hsd = SD_GetHandle();\n    assert_param(hsd != NULL);\n    assert_param(src != NULL);\n\n    uint32_t retry = 0;\n    HAL_StatusTypeDef status;\n    do {\n        status = HAL_SD_WriteBlocks(hsd, src, block, 1);\n        if (status == HAL_OK) {\n            return true;\n        }\n        retry++;\n    } while (retry < SD_WRITE_RETRY);\n\n    printf(\"SDIO_WriteBlock failed: %d\n\", status);\n    return false;\n}", "CodeBleu_score": 40.006073655772745}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert(sdio_handle != NULL);\n    assert(src != NULL);\n\n    int retries = 5;\n    while (retries--) {\n        if (SDIO_WriteBlock_DMA(sdio_handle, block, src) == HAL_OK) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock failed\n\");\n    return false;\n}", "CodeBleu_score": 33.6407424151447}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert(sdio_handle != NULL);\n    assert(src != NULL);\n\n    for (int retry = 0; retry < SDIO_MAX_RETRY; retry++) {\n        if (SDIO_WriteBlock_DMA(block, src) == true) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock: failed\n\");\n    return false;\n}", "CodeBleu_score": 32.6969321944841}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_DEBUG_PRINTF(\"HAL_timer_start(%d, %d)\n\", timer_num, frequency);\n\n    if (timer_num == TIMER_CHANNEL_TEMP) {\n        timer_num->start(frequency, TEMP_TIMER_PRESCALE);\n        timer_num->setCallbackPriority(TEMP_TIMER_CALLBACK_PRIORITY);\n    } else if (timer_num == TIMER_CHANNEL_STEP) {\n        timer_num->start(frequency, STEPPER_TIMER_PRESCALE);\n        timer_num->setCallbackPriority(STEPPER_TIMER_CALLBACK_PRIORITY);\n    } else {\n        CORE_ASSERT_FAIL(\"Invalid timer channel\");\n    }\n}", "CodeBleu_score": 55.713164651804156}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_DEBUG_PRINTF(\"HAL_timer_start: %d, %d\n\", timer_num, frequency);\n\n    if (timer_num == TIMER_CHANNEL_TEMP) {\n        timer_num->start(frequency, TIMER_TEMP_PRESCALE);\n        timer_num->setCallbackPriority(TIMER_CHANNEL_TEMP, TIMER_CHANNEL_TEMP_PRIORITY);\n    } else if (timer_num == TIMER_CHANNEL_STEP) {\n        timer_num->start(frequency, TIMER_STEP_PRESCALE);\n        timer_num->setCallbackPriority(TIMER_CHANNEL_STEP, TIMER_CHANNEL_STEP_PRIORITY);\n    } else {\n        CORE_ASSERT_FAIL(\"HAL_timer_start: Invalid timer channel\");\n    }\n}", "CodeBleu_score": 59.162009397368756}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_DEBUG_PRINTF(\"HAL_timer_start(%d, %d)\n\", timer_num, frequency);\n    if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n        timer_num->start(frequency, TEMPERATURE_TIMER_PRESCALE);\n        timer_num->setCallbackPriority(TEMPERATURE_TIMER_CALLBACK_PRIORITY);\n    } else if (timer_num == TIMER_CHANNEL_STEP) {\n        timer_num->start(frequency, STEPPER_TIMER_PRESCALE);\n        timer_num->setCallbackPriority(STEPPER_TIMER_CALLBACK_PRIORITY);\n    } else {\n        CORE_ASSERT_FAIL(\"Unknown timer channel\");\n    }\n}", "CodeBleu_score": 55.29809170080154}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t    if (!file) {\n        file = fopen(filename, \"r+\");\n        if (!file) {\n            file = fopen(filename, \"w+\");\n        }\n    }\n    if (!file) {\n        return false;\n    }\n    fseek(file, 0, SEEK_END);\n    int size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n    if (size < EEPROM_SIZE) {\n        memset(buffer, 0xFF, EEPROM_SIZE);\n    } else {\n        fread(buffer, 1, EEPROM_SIZE, file);\n    }\n    return true;\n}", "CodeBleu_score": 43.24967247185229}, {"code": "bool PersistentStore::access_start(){\n\t    if (!this->eeprom_file) {\n        this->eeprom_file = fopen(this->eeprom_path, \"r+\");\n        if (!this->eeprom_file) {\n            this->eeprom_file = fopen(this->eeprom_path, \"w+\");\n            if (!this->eeprom_file) {\n                return false;\n            }\n        }\n    }\n\n    if (fseek(this->eeprom_file, 0, SEEK_END) != 0) {\n        return false;\n    }\n\n    long eeprom_size = ftell(this->eeprom_file);\n    if (eeprom_size < 0) {\n        return false;\n    }\n\n    if (eeprom_size < (long)this->eeprom_size) {\n        memset(this->eeprom_buffer, this->erase_value, this->eeprom_size);\n    }\n\n    if (fseek(this->eeprom_file, 0, SEEK_SET) != 0) {\n        return false;\n    }\n\n    if (eeprom_size > 0) {\n        if (fread(this->eeprom_buffer, this->eeprom_size, 1, this->eeprom_file) != 1) {\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 20.48350204513071}, {"code": "bool PersistentStore::access_start(){\n\t    if (!this->eeprom_file) {\n        this->eeprom_file = fopen(EEPROM_FILE_NAME, \"rb+\");\n    }\n    if (!this->eeprom_file) {\n        this->eeprom_file = fopen(EEPROM_FILE_NAME, \"wb+\");\n    }\n    if (!this->eeprom_file) {\n        return false;\n    }\n    fseek(this->eeprom_file, 0, SEEK_END);\n    size_t file_size = ftell(this->eeprom_file);\n    fseek(this->eeprom_file, 0, SEEK_SET);\n    if (file_size < EEPROM_SIZE) {\n        memset(this->eeprom_buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n        fwrite(this->eeprom_buffer, EEPROM_SIZE, 1, this->eeprom_file);\n    } else {\n        fread(this->eeprom_buffer, EEPROM_SIZE, 1, this->eeprom_file);\n    }\n    return true;\n}", "CodeBleu_score": 32.729424770699026}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t i;\n    uint8_t r = 0;\n\n    for (i = 0; i < 8; i++) {\n        WRITE(SPI_MOSI_PIN, (b & 0x80) != 0);\n        WRITE(SPI_SCK_PIN, 0);\n        DELAY_NS(SPI_DELAY_NS);\n        r <<= 1;\n        r |= READ(SPI_MISO_PIN);\n        WRITE(SPI_SCK_PIN, 1);\n        DELAY_NS(SPI_DELAY_NS);\n        b <<= 1;\n    }\n\n    DELAY_NS(SPI_DELAY_NS);\n\n    return r;\n}", "CodeBleu_score": 45.46390274224434}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n\n  for (int i = 0; i < 8; i++) {\n    HAL_GPIO_WritePin(SPI_SCK_PORT, SPI_SCK_PIN, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_SCK_PORT, SPI_SCK_PIN, GPIO_PIN_SET);\n    r <<= 1;\n    r |= HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN);\n    b <<= 1;\n  }\n\n  delaySPIFunc(DELAY_NS);\n\n  return r;\n}", "CodeBleu_score": 42.49035877224725}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t i;\n    uint8_t r = 0;\n\n    for (i = 0; i < 8; i++) {\n        CLK_LOW();\n        if (b & 0x80) {\n            MOSI_HIGH();\n        } else {\n            MOSI_LOW();\n        }\n        CLK_HIGH();\n        r <<= 1;\n        if (MISO_READ()) {\n            r |= 0x01;\n        }\n        b <<= 1;\n        DELAY_NS();\n    }\n    DELAY_NS();\n    return r;\n}", "CodeBleu_score": 40.81377514220561}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.69690496231567}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.69690496231567}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\n    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.79020628658785}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->is_parity_error()) return;\n  uint8_t data = obj->read();\n  if (rx_buffer_head < RX_BUFFER_SIZE) {\n    rx_buffer[rx_buffer_head] = data;\n    rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n  }\n  if (emergency_parser.enabled) emergency_parser.update(data);\n}", "CodeBleu_score": 32.813620746665265}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->is_parity_error) return;\n  uint8_t data = obj->data_register;\n  if (rx_buffer_head < RX_BUFFER_SIZE) {\n    rx_buffer[rx_buffer_head] = data;\n    rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n  }\n  if (emergency_parser.enabled) emergency_parser.update(data);\n}", "CodeBleu_score": 32.82846434203407}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->is_error()) {\n    obj->is_error_irq();\n  } else {\n    const uint8_t c = obj->getc();\n    if (obj->is_recv_enabled()) {\n      obj->_push_unchecked(c);\n      obj->_recv_byte_isr();\n      obj->_recv_irq();\n    }\n    if (obj->is_emergency_enabled()) {\n      emergency_parser.update(c);\n    }\n  }\n}", "CodeBleu_score": 34.19070875484979}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->hasInterrupt) {\n        switch (timer_num) {\n            case MF_TIMER_STEP:\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n                break;\n            case MF_TIMER_TEMP:\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n                break;\n        }\n        timer_instance[timer_num]->hasInterrupt = true;\n    }\n}", "CodeBleu_score": 81.67202248883406}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (!timer_instance[timer_num]->hasInterrupt) {\n            timer_instance[timer_num]->attachInterrupt(Step_Handler);\n            timer_instance[timer_num]->hasInterrupt = true;\n        }\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (!timer_instance[timer_num]->hasInterrupt) {\n            timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n            timer_instance[timer_num]->hasInterrupt = true;\n        }\n    }\n}", "CodeBleu_score": 54.458567594098284}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_instance[timer_num]->isInitialized() && !timer_instance[timer_num]->hasInterrupt()) {\n        switch (timer_num) {\n            case MF_TIMER_STEP:\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n                break;\n            case MF_TIMER_TEMP:\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n                break;\n        }\n    }\n}", "CodeBleu_score": 87.63422168968556}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(sep)\n\tswitch {\n\tcase n == 0:\n\t\treturn len(s)\n\tcase n == len(s):\n\t\tif s == sep {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\tcase n > len(s):\n\t\treturn -1\n\t}\n\t// hashsep is the hash of the reverse of sep that is used to\n\t// shift the index of the Rabin fingerprint.\n\thashsep, pow := HashStrRev(sep)\n\tlast := len(s) - n\n\tvar h uint32\n\tfor i := len(s) - 1; i >= last; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashsep && s[last:] == sep {\n\t\treturn last\n\t}\n\tfor i := last - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && s[i:i+n] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 70.45168152131858}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(sep)\n\tswitch {\n\tcase n == 0:\n\t\treturn len(s)\n\tcase n == 1:\n\t\treturn LastIndexByte(s, sep[0])\n\tcase n == len(s):\n\t\tif sep == s {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\tcase n > len(s):\n\t\treturn -1\n\t}\n\thashsep, pow := HashStrRev(sep)\n\tlast := len(s) - n\n\tvar h uint32\n\tfor i := len(s) - 1; i >= last; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashsep && s[last:] == sep {\n\t\treturn last\n\t}\n\tfor i := last - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && s[i:i+n] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 66.31137822306474}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(sep)\n\tswitch {\n\tcase n == 0:\n\t\treturn len(s)\n\tcase n == 1:\n\t\treturn LastIndexByte(s, sep[0])\n\tcase n == len(s):\n\t\tif sep == s {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\tcase n > len(s):\n\t\treturn -1\n\t}\n\t// Rabin-Karp search from the end of the string\n\thashsep, pow := HashStrRev(sep)\n\tlast := len(s) - n\n\tvar h uint32\n\tfor i := len(s) - 1; i >= last; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashsep && s[last:] == sep {\n\t\treturn last\n\t}\n\tfor i := last - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && s[i:i+n] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 66.31137822306474}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txBuffer.Get())\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.760476939812634}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txBuffer.Get())\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.760476939812634}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 47.74822518324097}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Set control register to clear interrupt flag, put start condition on SDA line, and enable I2C module\n\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.ClearInterrupt | i2c.crReg.Start | i2c.crReg.Enable))\n\n\t// Wait for start condition to be transmitted\n\tfor !i2c.crReg.HasBits(i2c.crReg.StartConditionInterrupt) {\n\t}\n\n\t// Write 7-bit shifted peripheral address to bus\n\ti2c.writeByte(uint8(address<<1) | (uint8(write) & 0x01))\n}", "CodeBleu_score": 39.154896841273676}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.HasBits(i2c.crReg.ClearInterrupt)\n\ti2c.crReg.HasBits(i2c.crReg.StartCondition)\n\ti2c.crReg.HasBits(i2c.crReg.Enable)\n\ti2c.waitForInterruptFlag()\n\ti2c.writeByte(uint16(address) << 1)\n\tif !write {\n\t\ti2c.crReg.HasBits(i2c.crReg.Read)\n\t}\n\ti2c.crReg.HasBits(i2c.crReg.Start)\n}", "CodeBleu_score": 34.469661793099974}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.HasBits(i2c.crReg.ClearInterruptFlag | i2c.crReg.Start | i2c.crReg.Enable)\n\n\tfor !i2c.crReg.HasBits(i2c.crReg.StartConditionInterruptFlag) {\n\t}\n\n\ti2c.writeByte(address<<1 | uint8(write))\n}", "CodeBleu_score": 37.59431934490161}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := f.FlashDataStart + uintptr(start)*uintptr(f.EraseBlockSize)\n\n\tfor i := uint32(0); i < uint32(len); i++ {\n\t\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Wen)\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(startAddr) + (i * f.EraseBlockSize))\n\t\twaitWhileFlashBusy()\n\t}\n\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 44.178397114266}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := f.FlashDataStart + start*int64(f.EraseBlockSize)\n\tfor i := startAddr; i < startAddr+len*int64(f.EraseBlockSize); i += int64(f.EraseBlockSize) {\n\t\tf.waitWhileFlashBusy()\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(uintptr(i)))\n\t\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Een)\n\t}\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\treturn nil\n}", "CodeBleu_score": 44.756760345796984}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := f.StartAddress + uintptr(start)*f.EraseBlockSize\n\tendAddr := startAddr + uintptr(len)*f.EraseBlockSize\n\n\t// Erase the flash pages.\n\tfor addr := startAddr; addr < endAddr; addr += f.EraseBlockSize {\n\t\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Een)\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(addr))\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// Set flash in read mode.\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 45.894142032464735}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif uint32(off) >= f.Size() {\n\t\treturn 0, errors.New(\"flashBlockDevice: write exceeds flash memory bounds\")\n\t}\n\n\tstart := uintptr(f.pad.Start()) + uintptr(off)\n\tp = pad(p, f.WriteBlockSize)\n\n\tf.nrf.NVMC.SetCONFIG_WEN()\n\n\tfor len(p) > 0 {\n\t\tf.nrf.NVMC.WriteBytes(start, p[:f.WriteBlockSize])\n\t\tf.waitWhileFlashBusy()\n\t\tstart += uintptr(f.WriteBlockSize)\n\t\tp = p[f.WriteBlockSize:]\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 30.026403536383846}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif uint32(off) >= f.Size() {\n\t\treturn 0, errFlashOutOfBounds\n\t}\n\n\taddr := uintptr(f.start) + uintptr(off)\n\tlength := uint32(len(p))\n\n\tpadding := f.pad(p)\n\tbuffer := make([]byte, length+padding)\n\tcopy(buffer, p)\n\n\tnrf.NVMC.SetCONFIG_WEN()\n\n\tn, err = f.WriteBlockSize(addr, buffer)\n\tif err != nil {\n\t\treturn int(n), err\n\t}\n\n\treturn int(n), nil\n}", "CodeBleu_score": 29.62029230849712}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif uint32(off) >= f.Size() {\n\t\treturn 0, errFlashOutOfBounds\n\t}\n\tstart := uint32(off)\n\tend := start + uint32(len(p))\n\tif end > f.Size() {\n\t\tend = f.Size()\n\t}\n\tpadded := p[:end-start]\n\tpadLen := f.WriteBlockSize - (len(padded) % f.WriteBlockSize)\n\tif padLen != f.WriteBlockSize {\n\t\tpadded = append(padded, make([]byte, padLen)...)\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\tfor i := 0; i < len(padded); i += f.WriteBlockSize {\n\t\tnrf.NVMC.SetCONFIG_WEN\n\t\twaitWhileFlashBusy\n\t\tint\n\t\tlen\n\t\tbinary.LittleEndian.Uint32\n\t\t(*uint32)\n\t\tFlashDataEnd\n\t\tf.WriteBlockSize\n\t\tuintptr\n\t\tunsafe.Pointer\n\t\tf.pad\n\t\tn += f.WriteBlockSize\n\t}\n\treturn\n}", "CodeBleu_score": 38.319165842018386}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdupfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupfd)\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tsyscall.Close(dupfd)\n\t\treturn 0, \"\", err\n\t}\n\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 80.8337170610343}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdupfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupfd)\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dupfd)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 60.061677172005844}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdupfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to duplicate file descriptor: %v\", err)\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupfd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dupfd)\n\t\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %v\", err)\n\t\t}\n\t}\n}", "CodeBleu_score": 51.017732473483235}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *partition = esp_ota_get_running_partition();\n  esp_image_metadata_t data;\n  const esp_partition_pos_t p_pos = {\n      .offset = response ? partition->size - 4 : 0,\n      .index = 0,\n  };\n  esp_err_t err = esp_image_verify(ESP_IMAGE_VERIFY, &data, partition, &p_pos);\n  return (err == ESP_OK) ? data.image_len : 0;\n}", "CodeBleu_score": 44.93497548471282}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    const esp_partition_t *running = esp_ota_get_running_partition();\n\n    if (!running) {\n        return 0;\n    }\n\n    if (response == FreeSketchSpace) {\n        const esp_partition_t *updatePartition = esp_ota_get_next_update_partition(NULL);\n\n        if (!updatePartition) {\n            return 0;\n        }\n\n        return updatePartition->size - running->size;\n    }\n\n    return running->size;\n}", "CodeBleu_score": 48.88675601610563}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *running = esp_ota_get_running_partition();\n  if (running == NULL) {\n    return 0;\n  }\n  esp_image_metadata_t data;\n  const esp_partition_t *updatePartition = esp_ota_get_next_update_partition(NULL);\n  const esp_partition_t *bootPartition = esp_ota_get_boot_partition();\n  const esp_partition_t *runningPartition = esp_ota_get_running_partition();\n  if (bootPartition == NULL || runningPartition == NULL) {\n    return 0;\n  }\n  if (updatePartition != NULL) {\n    esp_ota_img_states_t ota_state;\n    if (esp_ota_get_state_partition(updatePartition, &ota_state) == ESP_OK) {\n      if (ota_state == ESP_OTA_IMG_PENDING_VERIFY) {\n        bootPartition = updatePartition;\n      }\n    }\n  }\n  if (esp_image_verify(bootPartition, &data) != ESP_OK) {\n    return 0;\n  }\n  if (response == freeSketchSpace) {\n    uint32_t free_size = runningPartition->size - data.image_len;\n    return free_size;\n  } else {\n    return data.image_len;\n  }\n}", "CodeBleu_score": 49.25754169517751}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_disk_sectors = calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk_sectors) {\n    log_e(\"Failed to allocate %u sectors for RAM disk\", total_sectors);\n    return false;\n  }\n  log_d(\"RAM disk allocated at %p\", msc_disk_sectors);\n  fat_file_system_type fs_type = mcs_is_fat16 ? FAT_FSTYPE_FAT16 : FAT_FSTYPE_FAT12;\n  fat_add_boot_sector(msc_disk_sectors, volume_label, serial_number, fs_type);\n  fat_add_table(msc_disk_sectors, msc_table_sectors, msc_table_sectors + 1, msc_table_sectors + 2);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_disk_sectors, msc_run_partition->label, msc_run_partition->size);\n  }\n  return true;\n}", "CodeBleu_score": 41.48656689275941}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_ram_disk = calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_ram_disk) {\n    log_e(\"Failed to allocate RAM disk\");\n    return false;\n  }\n  fat_file_system_type = mcs_is_fat16 ? FAT_FILESYSTEM_TYPE_FAT16 : FAT_FILESYSTEM_TYPE_FAT12;\n  fat_add_boot_sector(msc_ram_disk, total_sectors, fat_file_system_type, volume_label, serial_number);\n  fat_add_table(msc_ram_disk, total_sectors, msc_table_sectors, fat_file_system_type);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_ram_disk, total_sectors, msc_table_sectors, fat_file_system_type, \"firmware.bin\", fw_size);\n  }\n  return true;\n}", "CodeBleu_score": 39.83378310866203}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_ram_disk = calloc(1, total_sectors * DISK_SECTOR_SIZE);\n  if (!msc_ram_disk) {\n    log_e(\"Failed to allocate memory for RAM disk\");\n    return false;\n  }\n  fat_file_system_type = mcs_is_fat16 ? FS_FAT16 : FS_FAT12;\n  fat_add_boot_sector(msc_ram_disk, total_sectors, fat_file_system_type);\n  fat_add_table(msc_ram_disk, total_sectors, msc_table_sectors, fat_file_system_type);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_ram_disk, msc_run_partition->label, msc_run_partition->size);\n  }\n  return true;\n}", "CodeBleu_score": 33.82411602024714}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t ret = ESP_OK;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        ret = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (ret != ESP_OK) {\n            log_v(\"Failed to erase partition %s at offset 0x%x\", partition->label, offset);\n            return ret;\n        }\n    }\n    ret = esp_partition_write(partition, offset, data, size);\n    return ret;\n}", "CodeBleu_score": 60.02731943168297}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        log_v(\"Offset is not aligned with the flash sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n    err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        log_e(\"Failed to erase partition %s at offset 0x%x\", partition->label, offset);\n        return err;\n    }\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 54.87384353598603}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n\n    // Check if the offset is aligned with the flash sector size\n    if ((offset % SPI_FLASH_SEC_SIZE) == 0) {\n        // Erase the sector before writing new data\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            log_v(\"Failed to erase partition %s at offset 0x%x, error %d\", partition->label, offset, err);\n            return err;\n        }\n    }\n\n    // Write the data to the specified offset\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        log_v(\"Failed to write partition %s at offset 0x%x, error %d\", partition->label, offset, err);\n    }\n\n    return err;\n}", "CodeBleu_score": 66.46785848805672}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  while (i < maxlen && in[i * 2] && in[i * 2 + 1]) {\n    out[i] = (hex_char_to_byte(in[i * 2]) << 4) | hex_char_to_byte(in[i * 2 + 1]);\n    i++;\n  }\n  return i;\n}", "CodeBleu_score": 37.61581353141522}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  while (i < maxlen && *in) {\n    if (*in == ' ') {\n      in++;\n      continue;\n    }\n    unsigned char c = hex_char_to_byte(*in++);\n    if (c == 0x10) {\n      return i;\n    }\n    unsigned char d = hex_char_to_byte(*in++);\n    if (d == 0x10) {\n      return i;\n    }\n    out[i++] = (c << 4) | d;\n  }\n  return i;\n}", "CodeBleu_score": 46.6044417596572}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  size_t j = 0;\n\n  while (in[i] && j < maxlen) {\n    uint8_t b = hex_char_to_byte(in[i++]);\n    if (b == 0x10) {\n      continue;\n    }\n    out[j++] = b;\n    if (in[i]) {\n      b = hex_char_to_byte(in[i++]);\n      if (b == 0x10) {\n        continue;\n      }\n      out[j++] = b;\n    }\n  }\n  return j;\n}", "CodeBleu_score": 46.773431647333474}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t  if (tx_ring_buffer == NULL || tx_ring_buffer_lock == NULL) {\n    return 0;\n  }\n\n  if (xSemaphoreTake(tx_ring_buffer_lock, portMAX_DELAY) == pdTRUE) {\n    int free_size = xRingbufferGetCurFreeSize(tx_ring_buffer);\n    xSemaphoreGive(tx_ring_buffer_lock);\n    return free_size;\n  }\n\n  return 0;\n}", "CodeBleu_score": 67.86648197665285}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (tx_ringbuffer == NULL) {\n        return 0;\n    }\n    if (xSemaphoreTake(tx_ringbuffer_lock, 100 / portTICK_PERIOD_MS) != pdTRUE) {\n        return 0;\n    }\n    size_t free = xRingbufferGetCurFreeSize(tx_ringbuffer);\n    xSemaphoreGive(tx_ringbuffer_lock);\n    return free;\n}", "CodeBleu_score": 64.35043606602761}, {"code": "int HWCDC::availableForWrite(void){\n\t    int ret = 0;\n    if (m_tx_ringbuffer && m_tx_ringbuffer_lock) {\n        if (xSemaphoreTake(m_tx_ringbuffer_lock, TX_RINGBUFFER_LOCK_TIMEOUT) == pdTRUE) {\n            ret = xRingbufferGetCurFreeSize(m_tx_ringbuffer);\n            xSemaphoreGive(m_tx_ringbuffer_lock);\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 43.5823909852837}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    uartSetRxFIFOFull(_uart_nr, ARDUINO_SERIAL_FIFO_FULL_THRESHOLD);\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 40.513520789297885}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    // Set FIFO full threshold\n    uartSetRxFIFOFull(uart_nr, ARDUINO_SERIAL_FIFO_FULL_THRESHOLD);\n    // Create event task if it does not already exist\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 40.36931811768002}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  if (onlyOnTimeout) {\n    _rxTimeout = 0;\n  }\n  if (_onReceiveCB != NULL) {\n    uartSetRxFIFOFull(_uart_nr, ARDUINO_SERIAL_FIFO_SIZE - 1);\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 42.37530448324296}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, not including null terminator\n}", "CodeBleu_score": 99.80465478981657}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, excluding null terminator\n}", "CodeBleu_score": 99.45743761910349}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, not including null terminator\n}", "CodeBleu_score": 99.80465478981657}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"tone(pin: %u, freq: %u, duration: %lu)\", pin, frequency, duration);\n\n  if (pin >= NUM_DIGITAL_PINS) {\n    log_e(\"Pin %u is not a valid pin\", pin);\n    return;\n  }\n\n  if (digitalPinIsAttached(pin)) {\n    log_e(\"Pin %u is already in use\", pin);\n    log_e(\"Call stopTone() first\");\n    return;\n  }\n\n  // Initialize the tone\n  if (!tone_init()) {\n    log_e(\"Failed to initialize tone\");\n    return;\n  }\n\n  // Send the start command to the queue\n  tone_msg_t msg = {\n    .cmd = TONE_START,\n    .pin = pin,\n    .frequency = frequency,\n    .duration = duration\n  };\n  if (!xQueueSend(_tone_queue, &msg, 0)) {\n    log_e(\"Failed to send start command to tone queue\");\n  }\n}", "CodeBleu_score": 60.6480109920271}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"Tone: pin=%d, freq=%d, duration=%d\", pin, frequency, duration);\n  if (pin >= NUM_DIGITAL_PINS) {\n    log_e(\"Invalid pin number\");\n    return;\n  }\n  if (frequency == 0 || duration == 0) {\n    log_e(\"Invalid frequency or duration\");\n    return;\n  }\n  if (digitalPinIsAttached(pin)) {\n    log_e(\"Pin is already attached to a different tone\");\n    return;\n  }\n  if (digitalPinIsAttached(pin) && !digitalPinIsTone(pin)) {\n    log_e(\"Pin is already attached to a different function\");\n    return;\n  }\n  if (digitalPinIsTone(pin)) {\n    log_e(\"Pin is already attached to a tone, stop the current tone first\");\n    return;\n  }\n  if (tone_init() == 0) {\n    log_e(\"Could not initialize tone\");\n    return;\n  }\n\n  tone_msg_t msg = {\n    .cmd = TONE_START,\n    .pin = pin,\n    .freq = frequency,\n    .duration = duration,\n    .callback = NULL\n  };\n  if (xQueueSend(_tone_queue, &msg, 0) != pdTRUE) {\n    log_e(\"Could not send tone start message to queue\");\n    return;\n  }\n}", "CodeBleu_score": 54.15560216079429}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_v(\"Tone on pin %d with frequency %d and duration %d\", pin, frequency, duration);\n  if (pin != _tone_pin) {\n    if (_tone_pin != PIN_NOT_AVAIL) {\n      log_e(\"Tone on pin %d is already in use, please stop it first\", _tone_pin);\n      return;\n    }\n    _tone_pin = pin;\n  }\n\n  tone_msg_t msg = {\n    .pin = pin,\n    .frequency = frequency,\n    .duration = duration,\n    .start = 1\n  };\n  xQueueSend(_tone_queue, &msg, 1000 / portTICK_PERIOD_MS);\n}", "CodeBleu_score": 60.25480256545106}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (ESPUSB::usb_started) {\n        if (enabled) {\n            usb_device_webusb_enable();\n        } else {\n            usb_device_webusb_disable();\n        }\n    } else {\n        ESPUSB::webUSB_enabled = enabled;\n        if (enabled) {\n            usb_device_webusb_enable();\n            if (usb_device_get_version() < 0x0210) {\n                usb_device_set_version(0x0210);\n            }\n        }\n    }\n    return !ESPUSB::usb_started;\n}", "CodeBleu_score": 39.935473900627336}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (usb_started) {\n        if (enabled) {\n            if (usb_version < 0x0210) {\n                usb_version = 0x0210;\n            }\n            usb_webUSB_enabled = true;\n        } else {\n            usb_webUSB_enabled = false;\n        }\n        return false;\n    } else {\n        usb_webUSB_enabled = enabled;\n        return true;\n    }\n}", "CodeBleu_score": 55.4363566800094}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!usb_started) {\n    webUSB_enabled = enabled;\n    if (enabled) {\n      if (usb_version < 0x0210) {\n        usb_version = 0x0210;\n      }\n    }\n    return true;\n  }\n  if (enabled) {\n    usb_device.enableWebUSB();\n  } else {\n    usb_device.disableWebUSB();\n  }\n  return false;\n}", "CodeBleu_score": 63.83667425093471}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t    uint8_t buffer[64];\n    size_t len = tud_cdc_n_read(0, buffer, sizeof(buffer));\n    if (len > 0) {\n        size_t dropped = 0;\n        for (size_t i = 0; i < len; i++) {\n            if (!xQueueSend(_rxQueue, &buffer[i], 0)) {\n                dropped++;\n            }\n        }\n        if (dropped > 0) {\n            log_e(\"CDC RX queue overflow %d bytes\", dropped);\n            tud_cdc_n_write_flush(0);\n            _eventPost(USBCDC_EVENT_RX_OVERFLOW, &dropped, sizeof(dropped));\n        }\n        _eventPost(USBCDC_EVENT_RX_DONE, &len, sizeof(len));\n    }\n}", "CodeBleu_score": 31.402707667058372}, {"code": "void USBCDC::_onRX(){\n\t    int len = tud_cdc_n_read(_itf, _rx_buffer, sizeof(_rx_buffer));\n    if (len > 0) {\n        for (int i = 0; i < len; i++) {\n            if (!xQueueSend(_rx_queue, &_rx_buffer[i], 0)) {\n                _rx_overflow++;\n                log_e(\"CDC RX queue overflow\");\n            }\n        }\n        _rx_pending = true;\n        _rx_event.post(len);\n    }\n}", "CodeBleu_score": 23.579774912215782}, {"code": "void USBCDC::_onRX(){\n\t  uint8_t buf[128];\n  uint32_t count = tud_cdc_n_read(0, buf, sizeof(buf));\n  if (count > 0) {\n    if (tud_cdc_n_write_available(0) < count) {\n      // Dropping data\n      log_e(\"USBCDC::_onRX: Overflow, dropping %u bytes\", count);\n      arduino_usb_event_post(ARDUINO_USB_EVENT_CDC_RX_OVERFLOW, count, 0);\n    } else {\n      // Copying data to the queue\n      tud_cdc_n_write(0, buf, count);\n      tud_cdc_n_write_flush(0);\n      arduino_usb_event_post(ARDUINO_USB_EVENT_CDC_RX, count, 0);\n    }\n  }\n}", "CodeBleu_score": 21.338172135958622}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, &errorJSON{\n\t\t\tMessage: fmt.Sprintf(\"Robot with name %s not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tdevices := []*deviceJSON{}\n\trobot.Devices().Each(func(device gpio.Device) {\n\t\tdevices = append(devices, &deviceJSON{\n\t\t\tName:        device.Name(),\n\t\t\tDescription: device.Description(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, &devicesJSON{\n\t\tRobot:   robotName,\n\t\tDevices: devices,\n\t})\n}", "CodeBleu_score": 48.83411144751394}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, &JSONRobot{\n\t\t\tName:  robotName,\n\t\t\tError: \"Robot not found\",\n\t\t})\n\t\treturn\n\t}\n\n\tdevices := []*JSONDevice{}\n\trobot.Devices().Each(func(device gpio.Device) {\n\t\tdevices = append(devices, &JSONDevice{\n\t\t\tName: device.Name(),\n\t\t\tType: device.Type(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, &JSONRobot{\n\t\tName:    robotName,\n\t\tDevices: devices,\n\t})\n}", "CodeBleu_score": 50.101492437188824}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(JSONRobot{\n\t\t\tJSONRobot: &gobot.JSONRobot{\n\t\t\t\tName: robotName,\n\t\t\t\tCommands: []string{},\n\t\t\t\tConnections: []string{},\n\t\t\t\tDevices: []string{},\n\t\t\t},\n\t\t\tRobot: nil,\n\t\t})\n\t} else {\n\t\tdevices := []string{}\n\t\trobot.Devices().Each(func(device gobot.Device) {\n\t\t\tdevices = append(devices, device.Name())\n\t\t})\n\t\ta.writeJSON(res, JSONRobot{\n\t\t\tJSONRobot: &gobot.JSONRobot{\n\t\t\t\tName: robot.Name,\n\t\t\t\tCommands: []string{},\n\t\t\t\tConnections: []string{},\n\t\t\t\tDevices: devices,\n\t\t\t},\n\t\t\tRobot: robot,\n\t\t})\n\t}\n}", "CodeBleu_score": 48.10320986486904}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, &struct{}{})\n\t} else {\n\t\tconnections := []*Connection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections = append(connections, newConnection(c))\n\t\t})\n\t\ta.writeJSON(res, http.StatusOK, connections)\n\t}\n}", "CodeBleu_score": 45.52898142336431}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSONError{\n\t\t\tCode:    http.StatusNotFound,\n\t\t\tMessage: fmt.Sprintf(\"robot with name %q not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\tconnections := []JSONConnection{}\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, JSONConnection{\n\t\t\tName: connection.Name(),\n\t\t\tType: connection.ConnectionType(),\n\t\t})\n\t})\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 50.369315210520746}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": fmt.Sprintf(\"robot with name %s not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := []JSON{}\n\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, connection.ToJSON())\n\t})\n\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 51.7735213789359}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Device \" + req.URL.Query().Get(\":device\") + \" not found\"})\n\t\treturn\n\t}\n\tif _, err := device.(gobot.Commander).Command(req.URL.Query().Get(\":command\")); err != nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Command \" + req.URL.Query().Get(\":command\") + \" not found\"})\n\t\treturn\n\t}\n\ta.executeCommand(device.(gobot.Commander), req.URL.Query().Get(\":command\"))\n\ta.writeJSON(res, http.StatusOK, a.jsonDeviceFor(robot, device))\n}", "CodeBleu_score": 56.14806816663348}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, jsonError{\n\t\t\tMessage: fmt.Sprintf(\"Device %s not found\", req.URL.Query().Get(\":device\")),\n\t\t})\n\t\treturn\n\t}\n\n\tcommand, err := device.(gobot.Commander).Command(req.URL.Query().Get(\":command\"))\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusNotFound, jsonError{\n\t\t\tMessage: fmt.Sprintf(\"Command %s not found\", req.URL.Query().Get(\":command\")),\n\t\t})\n\t\treturn\n\t}\n\n\targs := map[string]interface{}{}\n\tjson.NewDecoder(req.Body).Decode(&args)\n\n\tresult := command.Call(args)\n\n\ta.writeJSON(res, http.StatusOK, result)\n}", "CodeBleu_score": 53.57560462276905}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": \"Device \" + req.URL.Query().Get(\":device\") + \" not found\",\n\t\t})\n\t\treturn\n\t}\n\n\tcmd := device.(gobot.Commander).Command(req.URL.Query().Get(\":command\"))\n\tif cmd == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": \"Command \" + req.URL.Query().Get(\":command\") + \" not found\",\n\t\t})\n\t\treturn\n\t}\n\n\t_, err := cmd()\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, JSON{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, JSON{\n\t\t\"status\":  \"ok\",\n\t\t\"message\": \"executed \" + req.URL.Query().Get(\":command\") + \" on \" + req.URL.Query().Get(\":robot\") + \" \" + req.URL.Query().Get(\":device\"),\n\t})\n}", "CodeBleu_score": 53.02157266119305}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\treqUsername, reqPassword, ok := r.BasicAuth()\n\t\tif !ok || reqUsername != username || reqPassword != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authentication successful, proceed to the next handler\n\t\t// ...\n\t}\n}", "CodeBleu_score": 51.487892851759966}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tgivenUsername, givenPassword, ok := r.BasicAuth()\n\t\tif !ok || givenUsername != username || givenPassword != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Authentication successful, proceed to the next handler\n\t\t// ...\n\t}\n}", "CodeBleu_score": 51.50365077645761}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tgivenUsername, givenPassword, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(username, givenUsername) || !secureCompare(password, givenPassword) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the authentication succeeds, you can proceed to the next handler.\n\t\t// ...\n\t}\n}", "CodeBleu_score": 52.50134691525123}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaled := gobot.ToScale(a.sensorCfg.scale, float64(raw))\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 40.1920786990556}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"AnalogSensor has no valid connection\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := gobot.ToScale(a.sensorCfg.Driver, float64(raw), a.sensorCfg.scale)\n\n\ta.lastRaw = raw\n\ta.lastValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.52909516974209}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"AnalogSensor %v not connected\", a.Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaled := gobot.ToScale(a.sensorCfg.scale, float64(raw))\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.43095601462212}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: *NewAnalogSensorDriver(a, pin, \"500\", opts...),\n\t}\n\td.AddEvent(SoundDetected)\n\td.AddEvent(SoundAbsent)\n\td.DefaultName = DefaultName(\"GroveSoundSensor\")\n\treturn d\n}", "CodeBleu_score": 43.3206393569072}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := NewAnalogSensorDriver(a, pin, \"500\")\n\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: s,\n\t\tname:               gobot.DefaultName(\"GroveSoundSensor\"),\n\t\th:                  &EventHandler{},\n\t}\n\n\tfor _, option := range opts {\n\t\toption(g)\n\t}\n\n\tg.AddEvent(SoundDetected)\n\tg.AddEvent(SoundStopped)\n\n\treturn g\n}", "CodeBleu_score": 37.39072529880927}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := NewAnalogSensorDriver(a, pin, 1*time.Second)\n\ts.SetName(gobot.DefaultName(\"GroveSoundSensor\"))\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: s,\n\t}\n}", "CodeBleu_score": 37.15343275882277}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(regCommand, cmdSoftReset); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(50 * time.Millisecond)\n\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val&(1<<4) == 0 {\n\t\treturn fmt.Errorf(\"soft reset command failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 73.9403531046813}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Soft reset command\n\tcmd := byte(0x01)\n\n\t// Write the soft reset command to the command register\n\td.writeByteData(RegCommand, cmd)\n\n\t// Wait for the initialization time\n\ttime.Sleep(5 * time.Millisecond)\n\n\t// Read the command register to check the status\n\tval, err := d.readByteData(RegCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set\n\tif (val & (1 << 4)) != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed, power-down bit still set\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 53.630995366705534}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\n\tval, _ := d.readByteData(CommandReg)\n\tif val&(1<<4) != 0 {\n\t\treturn fmt.Errorf(\"soft reset command failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 35.08266476498843}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.readReg(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(backData) != int(n) {\n\t\treturn 0, fmt.Errorf(\"readFifo: n = %d, but backData has length %d\", n, len(backData))\n\t}\n\n\tfor i := 0; i < int(n); i++ {\n\t\tv, err := d.readReg(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = v\n\t}\n\n\tv, err := d.readReg(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn v & 0x07, nil\n}", "CodeBleu_score": 58.70653078654777}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := d.readFIFO()\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"bad length in readFifo()\")\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i] = d.readFIFO()\n\t}\n\n\treturn d.readFIFO(), nil\n}", "CodeBleu_score": 20.752899060780308}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := d.readFIFOLen()\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"bad length in readFifo()\")\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i], _ = d.readFIFO()\n\t}\n\td.writeByteData(RegFIFOLevel, 0x80) // FlushBuffer = 1, FIFO initialization\n\treturn d.readByteData(RegControl) & 0x07, nil\n}", "CodeBleu_score": 25.546764279606638}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debugging {\n\t\tlog.Println(\"Halting PICC...\")\n\t}\n\tbuff := []byte{0x50, 0x00, 0x00, 0x00}\n\tcrc := d.calculateCRC(buff)\n\tresult := append(buff, crc[1], crc[0])\n\t_, err := d.communicateWithPICC(result)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error halting PICC: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 29.400621510884612}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debugging {\n\t\tlog.Println(\"Halting PICC...\")\n\t}\n\tbuff := []byte{0x50, 0, 0, 0}\n\td.calculateCRC(buff, 4)\n\tresult, err := d.communicateWithPICC(d.PCD_TRANSCEIVE, buff)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(result) != 1 || result[0] != 0x00 {\n\t\treturn fmt.Errorf(\"PICC responded with unexpected HALT response: %v\", result)\n\t}\n\treturn nil\n}", "CodeBleu_score": 31.540181721256623}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debugging {\n\t\tlog.Println(\"Halting PICC...\")\n\t}\n\tcmd := []uint8{0x50, 0x00, 0x00, 0x00}\n\td.calculateCRC(cmd, 4)\n\t_, err := d.communicateWithPICC(0x00, cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error halting PICC: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 25.600565279649917}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := []byte{\n\t\tuint8(0x30),\n\t\tblock,\n\t}\n\td.calculateCRC(cmd, 2)\n\t_, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuf := []byte{\n\t\tuint8(0x30),\n\t\tblock,\n\t}\n\td.calculateCRC(buf, 2)\n\t_, err = d.communicateWithPICC(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf[:16], nil\n}", "CodeBleu_score": 41.32902838187197}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := make([]byte, 2)\n\tcmd[0] = piccReadCmd\n\tcmd[1] = block\n\td.calculateCRC(cmd, 2)\n\td.communicateWithPICC(piccTransceiveCmd, cmd)\n\tdata, err := d.communicateWithPICC(piccTransceiveCmd, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}", "CodeBleu_score": 29.975273754979305}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := make([]byte, 5)\n\tcmd[0] = 0x30\n\tcmd[1] = block\n\td.calculateCRC(cmd, 2)\n\n\t_, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := make([]byte, 18)\n\t_, err = d.communicateWithPICC(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf[:16], nil\n}", "CodeBleu_score": 34.067689688280616}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\tswitch reqMode {\n\tcase PiccRequestIDLE:\n\t\td.clearRegisterBitMask(CollReg, 0x20)\n\t\tbreak\n\tcase PiccRequestAll:\n\t\td.setRegisterBitMask(CollReg, 0x20)\n\t\tbreak\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid request mode\")\n\t}\n\n\tif reqMode != PiccRequestIDLE {\n\t\td.clearRegisterBitMask(CollReg, 0x80)\n\t}\n\n\tresult, err := d.communicateWithPICC(reqMode, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif reqMode == PiccRequestIDLE {\n\t\td.setRegisterBitMask(CollReg, 0x80)\n\t}\n\n\treturn result\n}", "CodeBleu_score": 53.30418302527005}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\tswitch reqMode {\n\tcase PiccRequestIDLE:\n\t\tbreak\n\tcase PiccRequestAll:\n\t\td.setRegisterBitMask(CollReg, 0x20)\n\t\tbreak\n\tcase PiccRequestSelect:\n\t\td.setRegisterBitMask(CollReg, 0x40)\n\t\tbreak\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid request mode\")\n\t}\n\n\tresult, err := d.communicateWithPICC(reqMode, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif result != 0 {\n\t\treturn fmt.Errorf(\"PICC did not respond to request\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.05755304881145}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\tswitch reqMode {\n\tcase PiccRequestIdle:\n\t\td.clearRegisterBitMask(CollReg, 0x20)\n\t\tbreak\n\n\tcase PiccRequestAll:\n\t\td.setRegisterBitMask(CollReg, 0x20)\n\t\tbreak\n\n\tcase PiccRequestSelect:\n\t\td.setRegisterBitMask(CollReg, 0x40)\n\t\tbreak\n\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid request mode\")\n\t}\n\n\tresult, err := d.communicateWithPICC(reqMode, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(result) != 0 {\n\t\treturn fmt.Errorf(\"unexpected response\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 55.54145820282395}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.getDelayPerStep())\n\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 87.74225277256038}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.digitalWrite(d.stepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, 1)\n\n\tif d.direction {\n\t\td.currentStep++\n\t} else {\n\t\td.currentStep--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.2471407959736}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.getDelayPerStep())\n\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 87.74225277256038}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\td.distanceMonitorStopWaitGroup.Done()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 61.290512932409825}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already started\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\n\treturn nil\n}", "CodeBleu_score": 82.7983997470321}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\td.distanceMonitorStopWaitGroup.Done()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 61.007128559342675}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(pin int, duration time.Duration, eventType string, timestamp uint32, seqno uint32) {\n\t\tif eventType == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if eventType == \"falling\" {\n\t\t\td.duration <- (time.Now().Sub(startTimestamp))\n\t\t\tstartTimestamp = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 40.62779983529209}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\n\treturn func(pin int, duration time.Duration, eventType string, timestamp uint32, seqno uint32) {\n\t\tif eventType == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if eventType == \"falling\" {\n\t\t\tduration := time.Since(startTimestamp)\n\t\t\td.pulseDurationChannel <- duration\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.648294435027815}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, timestamp time.Duration, event string, sequence uint32, sequenceID uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\tduration := time.Since(startTimestamp)\n\t\t\td.distanceChannel <- duration\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.29142633994461}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerSensor(); err != nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase <-d.echoInterrupt:\n\t\td.measurement = time.Now().Sub(d.measurementStart)\n\tcase <-time.After(maxTimeout):\n\t\treturn fmt.Errorf(\"timeout waiting for echo interrupt\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.553502559732074}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.triggerPin.Low()\n\ttime.Sleep(1 * time.Microsecond)\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\tselect {\n\tcase <-d.echoPin.WaitForEdge(time.Second):\n\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\tcase <-d.echoPin.WaitForEdge(time.Second):\n\t\td.measuredTime = time.Since(d.startTime)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 50.81210578095978}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor by setting the triggerPin high for 10 microseconds\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\t// Wait for the echoPin to go high or for a timeout to occur\n\tstartTime := time.Now()\n\tfor d.echoPin.Read() == gpio.Low {\n\t\tif time.Since(startTime) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo signal\")\n\t\t}\n\t}\n\n\t// Wait for the echoPin to go low or for a timeout to occur\n\tstartTime = time.Now()\n\tfor d.echoPin.Read() == gpio.High {\n\t\tif time.Since(startTime) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo signal\")\n\t\t}\n\t}\n\n\t// Calculate the duration of the echo signal\n\tduration := time.Since(startTime)\n\n\t// Convert the duration to microseconds\n\tdurationMicros := duration.Microseconds()\n\n\t// Store the measured time in microseconds\n\td.measuredTime = durationMicros\n\n\treturn nil\n}", "CodeBleu_score": 52.1047911186477}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if self.auth_token_env_var_name in os.environ:\n        return os.environ[self.auth_token_env_var_name]\n\n    local_auth_data = self.get_local_auth_data()\n    access_token = local_auth_data.get(\"access_token\")\n    refresh_token = local_auth_data.get(\"refresh_token\")\n    expiry_time = local_auth_data.get(\"expiry_time\")\n\n    if access_token and expiry_time and time.time() < expiry_time:\n        return access_token\n\n    if refresh_token:\n        try:\n            new_auth_data = self.fetch_new_authentication_data(refresh_token)\n            self.update_local_auth_data(new_auth_data)\n            return new_auth_data[\"access_token\"]\n        except HTTPClientError as exc:\n            raise AccountNotAuthorized(exc) from exc\n\n    raise AccountNotAuthorized(\n        \"No authentication token available. Please run `account login` first.\"\n    )\n\n", "CodeBleu_score": 38.1883939668729}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.env_access_token:\n        return self.env_access_token\n    if self.local_session_data:\n        if self.local_session_data[\"expires_at\"] > time.time():\n            return self.local_session_data[\"access_token\"]\n        if self.local_session_data[\"refresh_token\"]:\n            try:\n                self.fetch_authentication_data()\n                return self.local_session_data[\"access_token\"]\n            except AccountNotAuthorized:\n                self.delete_local_session()\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 22.067970335135605}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.auth_token:\n        return self.auth_token\n    if self.auth_token_expiry:\n        if self.auth_token_expiry > time.time():\n            return self.auth_token\n    if self.refresh_token:\n        try:\n            auth_data = self.fetch_json_data(\n                \"https://auth.getmondo.co.uk/oauth2/token\",\n                method=\"POST\",\n                body={\n                    \"grant_type\": \"refresh_token\",\n                    \"client_id\": self.client_id,\n                    \"client_secret\": self.client_secret,\n                    \"refresh_token\": self.refresh_token,\n                },\n            )\n        except HTTPClientError as exc:\n            raise AccountNotAuthorized(exc) from exc\n        self.auth_token = auth_data[\"access_token\"]\n        self.auth_token_expiry = time.time() + auth_data[\"expires_in\"]\n        self.refresh_token = auth_data[\"refresh_token\"]\n        self.save_local_session()\n        return self.auth_token\n    raise AccountNotAuthorized(\"No authentication token available\")\n\n", "CodeBleu_score": 42.23208239814904}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 48.71265429435486}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 48.71265429435486}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post_json(\n            \"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n            ignore_errors=True,\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 57.07399940783401}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.pm.iter_packages():\n        if pkg.is_optional():\n            continue\n        name = pkg.name\n        version = pkg.version\n        metadata = pkg.metadata\n        if metadata.get('external'):\n            result.append((name, version, metadata['external']))\n        else:\n            result.append((name, version))\n    return result\n\n", "CodeBleu_score": 33.12856385009769}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.pm.iter_packages():\n        if pkg.is_optional():\n            continue\n        result.append({\n            'name': pkg.name,\n            'version': pkg.version,\n            'source': pkg.source_url if pkg.is_external() else None\n        })\n    return result\n\n", "CodeBleu_score": 27.748223469776768}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, items in self.pm.used_packages.items():\n        if items.optional:\n            continue\n        result.append(name)\n        result.append(str(items.version))\n        if items.metadata:\n            if items.metadata.get('external'):\n                result.append(items.metadata.get('external'))\n    return result\n\n", "CodeBleu_score": 36.33104489070853}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = cls.get_platform_spec(env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 25.600386881387944}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = config.get(\"env\", env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.set_project_env(env)\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 36.581148154251174}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = cls.get_platform_spec(env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.set_project_env(env)\n    instance.configure_project_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 26.92203669404396}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, (int)Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 97.59822825178871}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n\n    Wire1.requestFrom(0x34, (int)Size);\n    for (int i = 0; i < Size; i++) {\n        *(Buff + i) = Wire1.read();\n    }\n}", "CodeBleu_score": 99.72950129925083}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, (int)Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 97.59822825178871}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tteBar ? TTE_TOP_FIXED_AREA : TOP_FIXED_AREA;\n  int h = tteBar ? TTE_TOP_FIXED_AREA_HEIGHT : TOP_FIXED_AREA_HEIGHT;\n  int y_old = y;\n  scrollAddress(y);\n  tft.fillRect(0, y, tft.width(), h, color);\n  y += h;\n  if (y + h > tft.height() - BOTTOM_FIXED_AREA_HEIGHT) y = 0;\n  scrollAddress(y);\n  return y_old;\n}", "CodeBleu_score": 24.948492979118644}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int16_t ypos = tteBar ? 2 : 20;\n  int16_t h = tteBar ? 20 : 24;\n  int16_t prev_ypos = ypos;\n\n  ypos = (ypos + h) % (tft.height() - 24);\n  tft.fillRect(0, prev_ypos, tft.width(), h, color);\n  scrollAddress(ypos);\n  return prev_ypos;\n}", "CodeBleu_score": 17.935997396003966}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tteBar ? TTE_TOP_FIXED_AREA_Y : TOP_FIXED_AREA_Y;\n  int prev_y = y;\n  y = (y + tft.height() - BOTTOM_FIXED_AREA_Y) % (tft.height() - BOTTOM_FIXED_AREA_Y);\n  tft.fillRect(0, prev_y, tft.width(), tft.height() - BOTTOM_FIXED_AREA_Y, color);\n  scrollAddress(y);\n  return prev_y;\n}", "CodeBleu_score": 16.838186665149255}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  if (!this->setAP(ssids, access_points))\n    return false;\n\n  if (!this->setHtml())\n    return false;\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 89.34361353116358}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  if (!this->setAP(ssids)) {\n    return false;\n  }\n\n  if (!this->setHtml(access_points)) {\n    return false;\n  }\n\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 64.62195820151926}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // setup access points\n  if (!this->setAP(ssids, access_points)) {\n    return false;\n  }\n\n  // setup html\n  if (!this->setHtml()) {\n    return false;\n  }\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 75.10211382154785}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t    if (queue_enabled_flag) {\n        // If the queue is already enabled, ensure that the queue, text, and text_in are initialized\n        queue = std::queue<std::string>();\n        text = \"\";\n        text_in = \"\";\n    } else {\n        // If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n        flush_queue();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 15.064783426994344}, {"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag) {\n        this->flush_queue();\n        this->new_queue();\n    } else {\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 21.83846227522183}, {"code": "void GpsInterface::enable_queue(){\n\t  if (queue_enabled_flag) {\n    // If the queue is already enabled, ensure that the queue, text, and text_in are initialized\n    if (queue == NULL) {\n      queue = xQueueCreate(QUEUE_SIZE, sizeof(char));\n    }\n    if (text == NULL) {\n      text = (char *)malloc(sizeof(char) * MAX_TEXT_LENGTH);\n    }\n    if (text_in == NULL) {\n      text_in = (char *)malloc(sizeof(char) * MAX_TEXT_LENGTH);\n    }\n  } else {\n    // If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n    flush_queue();\n    queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 14.548289348380763}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        if (this->queue->size() > 0) {\n            this->new_queue = new std::queue<std::string>;\n            delete this->queue;\n            this->queue = this->new_queue;\n        }\n    } else {\n        this->queue = new std::queue<std::string>;\n    }\n}", "CodeBleu_score": 23.44938328224876}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue) {\n        if (this->queue->size > 0) {\n            this->new_queue = new Queue<std::string>();\n            delete this->queue;\n            this->queue = this->new_queue;\n        }\n    } else {\n        this->queue = new Queue<std::string>();\n    }\n}", "CodeBleu_score": 24.320665995196016}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\n\tif (this->queue->size > 0) {\n\t\tthis->new_queue = new Queue(this->queue->size);\n\t\tdelete this->queue;\n\t\tthis->queue = this->new_queue;\n\t} else {\n\t\tthis->queue = new Queue(10);\n\t}\n}", "CodeBleu_score": 20.049126180394666}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    /* The most simple case (but also the slowest) to put all pixels to the screen one-by-one */\n    int32_t x, y;\n    lv_disp_flush_ready(disp); /*It tells the graphics library that you are ready with the flushing*/\n\n    lv_color_t *c = color_p;\n    for (y = area->y1; y <= area->y2; y++) {\n        for (x = area-; x <= area->x2; x++) {\n            display_obj.tft.writePixel(x, y, *c);\n            c++;\n        }\n    }\n\n    /* IMPORTANT!!!\n     * Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 49.47642541735462}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    /* Get the display driver object */\n    my_disp_t *my_disp = (my_disp_t *)disp->user_data;\n\n    /* Start a write transaction */\n    my_disp->start_write();\n\n    /* Set the address window to the specified area */\n    my_disp->set_addr_window(area->x1, area->y1, area->x2, area->y2);\n\n    /* Iterate through each pixel in the area */\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        /* Write the corresponding color from the provided color buffer */\n        my_disp->write_color(color_p->full);\n        color_p++;\n      }\n    }\n\n    /* End the write transaction */\n    my_disp->end_write();\n\n    /* Notify that the display flush is complete */\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 61.98634461428908}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    for (int i = 0; i < menu->list->size; i++) {\n        for (int j = 0; j < layer; j++) {\n            Serial.print(\"  \");\n        }\n        Serial.println(menu->list->get(i)->name);\n    }\n    Serial.println();\n}", "CodeBleu_score": 67.22953297628729}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  int i;\n  for (i = 0; i < menu->list->size; i++) {\n    Serial.print(\" \");\n  }\n  Serial.println(menu->list->get(i)->name);\n}", "CodeBleu_score": 39.762152044230405}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  int i = 0;\n  for (i = 0; i < menu->list->size(); i++) {\n    Serial.print(menu->list->get(i)->name);\n    Serial.print(\" \");\n    Serial.println(menu->list->get(i)->value);\n  }\n  Serial.println(\"\");\n}", "CodeBleu_score": 58.48544714730982}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  int generated = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += random(0, 26) + 'a';\n    }\n    int channel = random(1, 12);\n    String mac = \"\";\n    for (int j = 0; j < 12; j++) {\n      mac += String(random(0, 16), HEX);\n      if (j % 2 == 1 && j != 11) {\n        mac += \":\";\n      }\n    }\n    ssids->add(ssid);\n    Serial.println(ssid + \",\" + String(channel) + \",\" + mac);\n    generated++;\n  }\n  return generated;\n}", "CodeBleu_score": 44.98457055183722}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    int generated = 0;\n    for (int i = 0; i < count; i++) {\n        String ssid = \"\";\n        for (int j = 0; j < 6; j++) {\n            ssid += random(0, 255);\n        }\n        int channel = random(1, 14);\n        String mac = \"\";\n        for (int j = 0; j < 6; j++) {\n            mac += String(random(0, 255), HEX);\n            if (j < 5) {\n                mac += \":\";\n            }\n        }\n        ssidList.add(ssid);\n        Serial.println(\"SSID: \" + ssid + \" Channel: \" + String(channel) + \" MAC: \" + mac);\n        generated++;\n    }\n    return generated;\n}", "CodeBleu_score": 42.899138788450074}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int n = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int i = 0; i < 6; i++) {\n      ssid += (char)random(32, 127);\n    }\n    int channel = random(1, 12);\n    String mac = WiFi.macAddress();\n    ssids->add(ssid);\n    Serial.println(ssid);\n    n++;\n  }\n  return n;\n}", "CodeBleu_score": 39.81721517664471}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create JWT\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        preview_capture('image.jpg')\n        url = upload_file('image.jpg', args.bucket_name)\n        unused_client.publish(\n                'events/{}/{}'.format(args.device_id, args.registry_id),\n                payload=url,\n                qos=1,\n                hostname=args.mqtt_bridge_hostname,\n                port=args.mqtt_bridge_port,\n                client_id=args.device_id,\n                auth={\n                    'username': 'unused',\n                    'password': create_jwt(\n                            args.project_id, args.private_key_file,\n                            args.algorithm)\n                })\n    elif payload == 'off':\n        print('off')\n\n", "CodeBleu_score": 45.81780007476701}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            message.payload, message.topic, str(message.qos)))\n    if message.payload == 'on':\n        preview_capture('image.jpg')\n        url = upload_file('image.jpg', bucket_name)\n        print('Publishing to {}'.format(mqtt_event_topic))\n        client.publish(mqtt_event_topic, url, qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 38.77952733718703}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            message.payload, message.topic, str(message.qos)))\n    if message.payload.decode() == 'on':\n        preview_capture(path)\n        url = upload_file(path, bucket_name)\n        print(url)\n        unused_client.publish(mqtt_event_topic, url, qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 38.357499502218026}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--subscription_name\", required=True, help=\"Name of Cloud Pub/Sub subscription\")\n    return parser.parse_args()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 48.286506366570286}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--subscription_name\", required=True, help=\"GCP PubSub subscription name\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), required=True, help=\"The encryption algorithm to use to verify the JWT token.\")\n    parser.add_argument(\"--ca_certs\", default=\"roots.pem\", help=(\"CA root from https://pki.google.com/roots.pem\"))\n    return parser.parse_args()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 41.88917282609984}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Example Google Cloud IoT MQTT device connection code.')\n    parser.add_argument('--project_id', default=os.environ.get('GOOGLE_CLOUD_PROJECT'), help='GCP cloud project name.')\n    parser.add_argument('--subscription_name', required=True, help='Name of the Pub/Sub subscription to monitor.')\n    return parser.parse_args()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 52.44322871901017}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_name = 'cloudiotcore'\n\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    discovery_url = '{}?version={}'.format(\n        discovery_url, api_version)\n\n    return discovery.build(\n        service_name,\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials)\n\n", "CodeBleu_score": 71.68139398577875}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_name = 'cloudiotcore'\n\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    discovery_url = '{}?version={}'.format(\n        discovery_api, api_version)\n\n    return discovery.build(\n        service_name,\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials)\n\n", "CodeBleu_score": 75.12474100380247}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_name = 'cloudiotcore'\n\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    discovery_url = discovery_api_url + '?version=' + api_version\n    service = discovery.build(service_name, api_version, discoveryServiceUrl=discovery_url, credentials=scoped_credentials)\n\n    return service\n\n", "CodeBleu_score": 62.30990749728262}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    # Retrieve the ASN1 code for the hash method\n    asn1 = _get_hash_method_asn1(hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    hash_block = asn1 + hash_value\n\n    # Pad the hash block for signing\n    padded_hash_block = _pad_for_signing(hash_block, priv_key.key_size)\n\n    # Encrypt the padded hash block using the private key\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash_block)\n\n    # Return the encrypted signature as a byte block\n    return encrypted_signature\n\n", "CodeBleu_score": 13.674576870472038}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_asn1 = hash_method.asn1\n    if not hash_asn1:\n        raise ValueError('%s is not supported by this backend' % hash_method)\n\n    der_data = hash_asn1 + hash_value\n    sig = priv_key.blinded_encrypt(\n        _pad_for_signing(der_data, priv_key.size_in_bytes()),\n        randfunc=None)\n\n    return transform.int2bytes(sig, priv_key.size_in_bytes())\n\n", "CodeBleu_score": 32.63568679829551}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    # Get the ASN1 code for the hash method\n    asn1_code = get_asn1_code(hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    block = asn1_code + hash_value\n\n    # Pad the block for signing\n    block = _pad_for_signing(block, priv_key.n.bit_length() + 7 // 8)\n\n    # Encrypt the padded hash using the private key\n    encrypted_signature = priv_key.blinded_encrypt(block)\n\n    # Return the encrypted signature as a byte block\n    return transform.int2bytes(encrypted_signature)\n\n", "CodeBleu_score": 14.235552948759251}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    clearsig = transform.bytes2int(signature)\n    clearsig = core.decrypt_int(clearsig, pub_key)\n    clearsig = transform.int2bytes(clearsig, common.byte_size(pub_key.n))\n    hash_method = _find_method_hash(clearsig)\n    hashed = compute_hash(message, hash_method)\n    padded = _pad_for_signing(hashed, common.byte_size(pub_key.n))\n    if clearsig != padded:\n        raise VerificationError('Verification failed')\n    return hash_method\n\n", "CodeBleu_score": 29.334999279163288}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt the signature using the public key\n    clearsig = core.decrypt_int(signature_int, pub_key)\n\n    # Determine the hash method used\n    method_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hashed = compute_hash(message, method_name)\n\n    # Reconstruct the expected padded hash\n    padded_hash = _pad_for_signing(hashed, common.byte_size(pub_key.n))\n\n    # Compare the expected padded hash with the clear signature\n    if padded_hash != clearsig:\n        raise VerificationError('Verification failed')\n\n    return method_name\n\n", "CodeBleu_score": 28.909786689953126}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt the signature integer using the public key\n    clearsig = core.decrypt_int(signature_int, pub_key.e, pub_key.n)\n\n    # Find the hash method used in the signature\n    method_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message using the same hash method\n    hashed = compute_hash(message, method_name)\n\n    # Reconstruct the expected padded hash\n    padded = _pad_for_signing(hashed, common.byte_size(pub_key.n))\n\n    # Check if the expected padded hash matches the clear signature\n    if clearsig != padded:\n        raise VerificationError('Verification failed')\n\n    return method_name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 28.891674812290262}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t   uint32_t epoch = time(NULL);\n   if (epoch > 0) {\n      updateJWT(epoch);\n      MQTT_CLIENT_connect(cid, mqttUsername, mqttPassword, mqttTopic, 1);\n      mqttConnected = 1;\n   }\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 53.94935106120895}, {"code": "static void connectMQTT(){\n\t   uint32_t epoch = time(NULL);\n   if (epoch > UNIX_OFFSET) {\n      updateJWT(epoch);\n   }\n   MQTT_CLIENT_connect(cid, mqttUserName, mqttPassword, mqttTopic);\n   mqtt_send_subscribe = 1;\n   debug_printInfo(\"MQTT: connecting\");\n}", "CodeBleu_score": 53.25087009924946}, {"code": "static void connectMQTT(){\n\t   time_t epoch = time(NULL);\n   if (epoch != -1) {\n      updateJWT(epoch);\n      MQTT_CLIENT_connect();\n      sendSubscribe = 1;\n   }\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 30.272358110641846}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    for (int i = 0; i < width; i++) {\n        uint8_t c = str[i];\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        value = value * 10 + (c - '0');\n    }\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 24.650870942437603}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    int i;\n    uint32_t n = 0;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        n = n * 10 + (str[i] - '0');\n    }\n    *num = n;\n    return str + width;\n}", "CodeBleu_score": 26.889726244878087}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    uint32_t max_value = 0xFFFFFFFF;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        uint8_t digit = str[i] - '0';\n        if (digit > 9) {\n            return str;\n        }\n        if (value > max_value / 10) {\n            return str;\n        }\n        value = value * 10 + digit;\n        if (value > max_value) {\n            return str;\n        }\n    }\n\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 33.76724095353076}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def == NULL || build_state->cert_def->cert_def_static == NULL || build_state->cert_def->cert_def_static->cert_def == NULL || build_state->cert == NULL || build_state->cert_size == 0)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    ret = atcacert_gen_cert_sign(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->signer_cert, build_state->signer_cert_size, build_state->signer_key, build_state->signer_key_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 65.55889628604054}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n    uint8_t* cert = build_state->cert;\n    size_t cert_size = build_state->cert_size;\n    const atcacert_def_t* cert_def = build_state->cert_def;\n\n    if (build_state == NULL || cert == NULL || cert_def == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Add the SN to the cert\n    ret = atcacert_gen_cert_sn(cert_def, cert, cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Add the Subject Key ID to the cert\n    ret = atcacert_gen_cert_skid(cert_def, cert, cert_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Add the Authority Key ID to the cert\n    ret = atcacert_gen_cert_akid(cert_def, cert, cert_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Add the Authority Key ID to the cert\n    ret = atcacert_gen_cert_akid(cert_def, cert, cert_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Add the signature to the cert\n    ret = atcacert_gen_cert_sig(cert_def, cert, cert_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 61.53913661322458}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    uint8_t tbs_digest[32];\n    int ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    uint8_t signature[64];\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return atcab_verify_extern(tbs_digest, signature, ca_public_key);\n}", "CodeBleu_score": 62.95462872503611}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 80.75710935228567}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    if (atcab_verify_extern(tbs_digest, signature, ca_public_key)) {\n        return ATCACERT_E_VERIFY;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 78.27329201571149}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *prev = list;\n    while (*prev != NULL)\n    {\n        if (*prev == timer)\n        {\n            *prev = timer->next;\n            return true;\n        }\n        prev = &(*prev)->next;\n    }\n    return false;\n}", "CodeBleu_score": 21.451153198592166}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *list = &listHead;\n    timerStruct_t * volatile *prev = list;\n    timerStruct_t * volatile *current = *list;\n\n    while (current != NULL)\n    {\n        if (current == timer)\n        {\n            *prev = current->next;\n            return true;\n        }\n        prev = &current->next;\n        current = current->next;\n    }\n    return false;\n}", "CodeBleu_score": 28.057865365974532}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    volatile timerStruct_t * volatile *prev = list;\n    volatile timerStruct_t * volatile *next = &(*prev)->next;\n\n    while (*next != NULL)\n    {\n        if (*next == timer)\n        {\n            *prev = (*next)->next;\n            return true;\n        }\n        prev = next;\n        next = &(*prev)->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 26.805599075895003}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t    int ret;\n    tstrSocketInfo socketInfo;\n\n    ret = getSocketInfo(socket, &socketInfo);\n    if (ret != 0) {\n        bsd_setErrNo(BSD_ENOTSOCK);\n        return BSD_ERROR;\n    }\n\n    socketInfo.state = NOT_A_SOCKET;\n\n    ret = close(socket);\n    if (ret != 0) {\n        bsd_setErrNo(BSD_EIO);\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 37.221962052883846}, {"code": "int BSD_close(int socket){\n\t    tstrSocketInfo sockInfo;\n    sint8 s8Ret = SOCK_ERR_NO_ERROR;\n\n    // Retrieve socket information\n    if (getSocketInfo(socket, &sockInfo) != BSD_SUCCESS) {\n        return BSD_ERROR;\n    }\n\n    // Set socket state to \"NOT_A_SOCKET\"\n    sockInfo.u8State = SOCKET_STATE_NOT_A_SOCKET;\n\n    // Call close function\n    s8Ret = close(socket);\n\n    // Check for errors\n    if (s8Ret != SOCK_ERR_NO_ERROR) {\n        // Set error number based on error type\n        if (s8Ret == SOCK_ERR_INVALID_ARG) {\n            bsd_setErrNo(BSD_EINVAL);\n        } else if (s8Ret == SOCK_ERR_INVALID) {\n            bsd_setErrNo(BSD_EINVAL);\n        } else {\n            bsd_setErrNo(BSD_EIO);\n        }\n\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 51.88161310350421}, {"code": "int BSD_close(int socket){\n\t\tSOCKET sock;\n\t\n\tsock = getSocketInfo(socket);\n\tif (sock == -1) {\n\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (close(sock) != SOCK_ERR_NO_ERROR) {\n\t\tbsd_setErrNo(BSD_EIO);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 26.024197591029214}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t    int ret = listen(socket, backlog);\n    if (ret < 0) {\n        bsd_setErrNo(SOCK_ERR_INVALID_ARG);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 21.48564697577119}, {"code": "int BSD_listen(int socket, int backlog){\n\t    // Check if the socket and backlog are valid\n    if (socket < 0 || backlog < 0) {\n        BSD_setErrNo(SOCK_ERR_INVALID_ARG);\n        return SOCK_ERR_INVALID_ARG;\n    }\n\n    // Call the listen function\n    int result = listen(socket, backlog);\n\n    // Check if an error occurred\n    if (result < 0) {\n        // Set the appropriate error number based on the response\n        BSD_setErrNo(SOCK_ERR_INVALID);\n        return SOCK_ERR_INVALID;\n    }\n\n    // No error occurred, return success\n    return SOCK_ERR_NO_ERROR;\n}", "CodeBleu_score": 33.37654834014094}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret;\n\t\n\tret = listen(socket, backlog);\n\tif (ret < 0) {\n\t\tBSD_setErrNo(ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.712275946634293}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = SOCK_ERR_INVALID_ARG;\n\tstruct bsd_sockaddr_in *addr_in;\n\tstruct bsd_sockaddr_in6 *addr_in6;\n\tuint8 len;\n\n\tif (socket < 0 || socket >= BSD_SOCKET_COUNT) {\n\t\tret = SOCK_ERR_INVALID_ARG;\n\t\tgoto out;\n\t}\n\n\tif (!addr || !addrlen) {\n\t\tret = SOCK_ERR_INVALID_ARG;\n\t\tgoto out;\n\t}\n\n\tswitch (gastrSockets[socket].sockaddr.sa_family) {\n\tcase BSD_AF_INET:\n\t\taddr_in = (struct bsd_sockaddr_in *) addr;\n\t\tlen = sizeof(struct bsd_sockaddr_in);\n\t\tbreak;\n\tcase BSD_AF_INET6:\n\t\taddr_in6 = (struct bsd_sockaddr_in6 *) addr;\n\t\tlen = sizeof(struct bsd_sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\tret = SOCK_ERR_INVALID_ARG;\n\t\tgoto out;\n\t}\n\n\tret = accept(socket, (struct bsd_sockaddr *) addr, &len);\n\tif (ret < 0) {\n\t\tgoto out;\n\t}\n\n\tret = SOCK_ERR_NO_ERROR;\nout:\n\treturn ret;\n}", "CodeBleu_score": 41.93625521990813}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = -1;\n\tstruct sockaddr_in6 addr6;\n\tstruct sockaddr_in addr4;\n\tint sockaddr_size = sizeof(struct sockaddr_in6);\n\n\tif (addr) {\n\t\tif (addr->sa_family == AF_INET) {\n\t\t\tsockaddr_size = sizeof(struct sockaddr_in);\n\t\t} else if (addr->sa_family == AF_INET6) {\n\t\t\tsockaddr_size = sizeof(struct sockaddr_in6);\n\t\t} else {\n\t\t\tBSD_set_errno(EAFNOSUPPORT);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = accept(socket, (struct sockaddr *) addr, &sockaddr_size);\n\tif (ret < 0) {\n\t\tBSD_set_errno(errno);\n\t\treturn -1;\n\t}\n\n\tif (addr) {\n\t\tif (addr->sa_family == AF_INET) {\n\t\t\tmemset(&addr4, 0, sizeof(struct sockaddr_in));\n\t\t\tgetsockname(ret, (struct sockaddr *) &addr4, &sockaddr_size);\n\t\t\tmemcpy(addr, &addr4, sizeof(struct sockaddr_in));\n\t\t} else if (addr->sa_family == AF_INET6) {\n\t\t\tmemset(&addr6, 0, sizeof(struct sockaddr_in6));\n\t\t\tgetsockname(ret, (struct sockaddr *) &addr6, &sockaddr_size);\n\t\t\tmemcpy(addr, &addr6, sizeof(struct sockaddr_in6));\n\t\t}\n\t}\n\n\tif (addrlen) {\n\t\t*addrlen = sockaddr_size;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 43.641177200116246}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t   time_t epoch = time(NULL);\n   if (epoch > 0) {\n      updateJWT(epoch);\n      MQTT_CLIENT_connect(mqttClient, mqttHost, mqttPort, mqttUser, mqttPassword, cid, mqttTopic);\n      debug_printInfo(\"MQTT: Connecting to %s:%d\", mqttHost, mqttPort);\n      sendSubscribe = 1;\n   }\n}", "CodeBleu_score": 48.65973801307014}, {"code": "static void connectMQTT(){\n\t   time_t epoch = time(NULL);\n   if (epoch > UNIX_OFFSET) {\n      updateJWT(epoch);\n      MQTT_CLIENT_connect();\n      debug_printInfo(\"MQTT: Connecting...\");\n      sendSubscribe = 1;\n   }\n}", "CodeBleu_score": 56.1223905233532}, {"code": "static void connectMQTT(){\n\t   uint32_t epoch = time(NULL);\n   if (epoch < UNIX_OFFSET) {\n      debug_printInfo(\"Time is not set\");\n      return;\n   }\n   updateJWT(epoch);\n   MQTT_CLIENT_connect(cid, mqttUser, mqttPassword, mqttTopic, mqttHost, mqttPort);\n   debug_printInfo(\"MQTT: Connecting...\");\n   sendSubscribe = 1;\n}", "CodeBleu_score": 51.67619400798388}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t   mqttClientConnectionInfo* clientConnectionInfo;\n\n   DEBUG_PRINT(\"Disconnecting from cloud service\n\");\n\n   if (MQTT_GetConnectionState() == CONNECTED) {\n      clientConnectionInfo = MQTT_GetClientConnectionInfo();\n\n      MQTT_Disconnect(clientConnectionInfo);\n   }\n}", "CodeBleu_score": 63.45336935298141}, {"code": "void CLOUD_disconnect(void){\n\t   mqttClientConnectionInfo* connectionInfo;\n\n   debug_printError(\"Disconnecting from cloud service\n\");\n\n   if (MQTT_GetConnectionState() == CONNECTED) {\n      connectionInfo = MQTT_GetClientConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n   }\n}", "CodeBleu_score": 65.40140253767481}, {"code": "void CLOUD_disconnect(void){\n\t   debug_printError(CLOUD_DEBUG_DISCONNECT, \"disconnecting from cloud\n\");\n\n   if (MQTT_GetConnectionState() == CONNECTED) {\n      MQTT_GetClientConnectionInfo(&clientConnectionInfo);\n      MQTT_Disconnect(&clientConnectionInfo);\n   }\n}", "CodeBleu_score": 62.84915632762973}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    if (passed_wifi_creds) {\n        // Connect to the Wi-Fi access point using new credentials\n        if (m2m_wifi_connect(wifi_ssid, strlen(wifi_ssid), M2M_WIFI_SEC_WPA_PSK, wifi_pass, 0) != M2M_SUCCESS) {\n            // Log an error message if the connection fails\n            debug_printError(\"Failed to connect to the Wi-Fi access point\n\");\n            // Update the networking error status\n            networking_error = true;\n            // Return false to indicate failure\n            return false;\n        }\n    } else {\n        // Connect to the Wi-Fi access point using default credentials\n        if (m2m_wifi_default_connect() != M2M_SUCCESS) {\n            // Log an error message if the connection fails\n            debug_printError(\"Failed to connect to the Wi-Fi access point\n\");\n            // Update the networking error status\n            networking_error = true;\n            // Return false to indicate failure\n            return false;\n        }\n    }\n    // Return true to indicate success\n    return true;\n}", "CodeBleu_score": 43.52465095858625}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    sint8 s8Ret;\n    if (passed_wifi_creds) {\n        s8Ret = m2m_wifi_connect(g_wifi_ssid, strlen(g_wifi_ssid), g_wifi_security, g_wifi_password, g_wifi_ch);\n    } else {\n        s8Ret = m2m_wifi_default_connect();\n    }\n    if (s8Ret != 0) {\n        debug_printError(\"Failed to connect to AP: %d\", s8Ret);\n        g_wifi_error_status = true;\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 50.79364274768656}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    if (passed_wifi_creds) {\n        if (m2m_wifi_connect(wifi_ssid, strlen(wifi_ssid), M2M_WIFI_SEC_WPA_PSK, wifi_password, 0) != 0) {\n            debug_printError(\"Failed to connect to AP\n\");\n            networking_error_status = 1;\n            return false;\n        }\n    } else {\n        if (m2m_wifi_default_connect() != 0) {\n            debug_printError(\"Failed to connect to AP\n\");\n            networking_error_status = 1;\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 45.865132528732644}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t    const client = generateClient();\n    const response = await client.graphql(\n        `\n            query {\n                listSensors {\n                    items {\n                        id\n                        geo {\n                            latitude\n                            longitude\n                        }\n                    }\n                }\n            }\n        `\n    );\n\n    console.log(\"Sensors: \", response.data.listSensors.items);\n    response.data.listSensors.items.forEach((sensor) => {\n        const marker = document.createElement(\"div\");\n        marker.className = \"marker\";\n        marker.style.backgroundImage = \"url('https://placekitten.com/g/50/50')\";\n        marker.style.width = \"50px\";\n        marker.style.height = \"50px\";\n        new Marker({element: marker})\n            .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n            .addTo(map);\n    });\n}", "CodeBleu_score": 52.03061614671783}, {"code": "async function DisplaySensors(map){\n\t  // Generate a client to interact with the API\n  const client = generateClient();\n\n  // Send a GraphQL query to fetch sensor data\n  const response = await client.graphql(\n    `\n    query {\n      listSensors {\n        items {\n          id\n          name\n          geo {\n            latitude\n            longitude\n          }\n        }\n      }\n    }\n  `\n  );\n\n  // Log the API response\n  console.log(response);\n\n  // If the response contains data, log the retrieval of sensors\n  if (response.data) {\n    console.log(\"Retrieved sensors\");\n\n    // Iterate through each sensor and create a marker\n    response.data.listSensors.items.forEach((sensor) => {\n      // Create a marker for the sensor\n      const marker = CreateSensorMarker(sensor);\n\n      // Place the marker on the map at the sensor's geographical coordinates\n      new Marker({ element: marker })\n        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n        .addTo(map);\n    });\n  }\n}", "CodeBleu_score": 59.599614060039826}, {"code": "async function DisplaySensors(map){\n\t    // Generate a client\n    const client = generateClient();\n\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.graphql(\n        `\n        query {\n            listSensors {\n                items {\n                    id\n                    name\n                    geo {\n                        longitude\n                        latitude\n                    }\n                }\n            }\n        }\n        `\n    );\n\n    // Log the API response\n    console.log(response);\n\n    // If the response contains data, log the retrieval of sensors\n    if (response.data) {\n        console.log(\"Retrieved sensors\");\n\n        // Iterate through each sensor to create a marker\n        response.data.listSensors.forEach((sensor) => {\n            // Create a marker for the sensor\n            const marker = CreateSensorMarker(sensor);\n\n            // Place the marker on the map at the sensor's geographical coordinates\n            new Marker({ element: marker })\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 55.11445565907176}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.classList.add('marker');\n    marker.style.backgroundColor = 'red';\n    marker.style.border = '1px solid black';\n    return marker;\n}", "CodeBleu_score": 45.215621940829074}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = `marker-${sensor.id}`;\n  marker.className = 'marker';\n  marker.style.backgroundColor = '#FF0000';\n  marker.style.border = '1px solid #000000';\n  return marker;\n}", "CodeBleu_score": 44.750227416827826}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.classList.add(\"marker\");\n  marker.style.backgroundColor = \"red\";\n  marker.style.border = \"1px solid white\";\n  return marker;\n}", "CodeBleu_score": 43.16923111351329}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.mfa.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"MFA module not found: %s\", module_path)\n        raise HomeAssistantError(\"MFA module not found\") from None\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        processed = hass.data.setdefault(DATA_PIP_LOCK, {})\n        if module_path not in processed:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n            processed.add(module_path)\n\n    return module\n\n", "CodeBleu_score": 51.940017826501304}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.mfa.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Unable to find module %s\", module_path)\n        raise HomeAssistantError(\n            f\"Unable to find module {module_path}\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS\n        ):\n            raise HomeAssistantError(\"Unable to install requirements\")\n\n    if hasattr(module, \"DEPENDENCIES\"):\n        await async_process_dependencies(hass, module_path, module.DEPENDENCIES)\n\n    return module\n\n", "CodeBleu_score": 48.21313138054296}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{__package__}.mfa.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"MFA module not found: %s\", module_path)\n        raise HomeAssistantError(f\"MFA module not found: {module_path}\") from None\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        processed = hass.data.setdefault(DATA_MFA_PROCESSED, set())\n        if module_name not in processed:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n            processed.add(module_name)\n\n    return module\n\n", "CodeBleu_score": 52.21644291204599}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    entry = await self.async_get_or_create_entry(user_id)\n    entry.pin = pin\n    return entry\n\n", "CodeBleu_score": 26.44197822056186}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    found = False\n    for index, entry in enumerate(self._data[\"users\"]):\n        if entry[\"user_id\"] == user_id:\n            self._data[\"users\"][index][\"pin\"] = pin\n            found = True\n            break\n    if not found:\n        self._data[\"users\"].append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 44.578094901439556}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    if user_id in self._data:\n        self._data[user_id] = pin\n    else:\n        self._data[user_id] = pin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 31.747629135541644}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        self._user_settings = {}\n        data = await self._store.async_load()\n\n        if data is None:\n            data = {}\n\n        for user_id, settings in data.items():\n            self._user_settings[user_id] = NotifySetting(\n                user_id=user_id,\n                send_to=settings.get(CONF_NOTIFY_TO, []),\n                send_to_all=settings.get(CONF_NOTIFY_TO_ALL, False),\n                send_to_admins=settings.get(CONF_NOTIFY_TO_ADMINS, False),\n            )\n\n", "CodeBleu_score": 42.68275812931076}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._initialization_lock:\n        if self._user_settings is not None:\n            return\n        user_settings = await self._store.async_load()\n        if user_settings is None:\n            user_settings = {}\n        self._user_settings = {\n            user_id: NotifySetting(**settings)\n            for user_id, settings in user_settings.items()\n        }\n\n", "CodeBleu_score": 46.191015436622045}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        self._user_settings = {}\n\n        data = await self._store.async_load()\n\n        if data is None:\n            data = {}\n\n        for user in data:\n            self._user_settings[user] = NotifySetting(\n                user,\n                data[user].get(CONF_NOTIFY_SERVICE),\n                data[user].get(CONF_NOTIFY_TARGET),\n                data[user].get(CONF_NOTIFY_TITLE_TEMPLATE),\n                data[user].get(CONF_NOTIFY_MESSAGE_TEMPLATE),\n                data[user].get(CONF_NOTIFY_DATA_TEMPLATE),\n                data[user].get(CONF_NOTIFY_TITLE_TEMPLATE_DEFAULT),\n                data[user].get(CONF_NOTIFY_MESSAGE_TEMPLATE_DEFAULT),\n                data[user].get(CONF_NOTIFY_DATA_TEMPLATE_DEFAULT),\n                data[user].get(CONF_NOTIFY_TITLE_TEMPLATE_DEFAULT_EN),\n                data[user].get(CONF_NOTIFY_MESSAGE_TEMPLATE_DEFAULT_EN),\n                data[user].get(CONF_NOTIFY_DATA_TEMPLATE_DEFAULT_EN),\n                data[user].get(CONF_NOTIFY_TITLE_TEMPLATE_DEFAULT_ZH),\n                data[user].get(CONF_NOTIFY_MESSAGE_TEMPLATE_DEFAULT_ZH),\n                data[user].get(CONF_NOTIFY_DATA_TEMPLATE_DEFAULT_ZH),\n                data[user].get(CONF_NOTIFY_TITLE_TEMPLATE_DEFAULT_JA),\n                data[user].get(CONF_NOTIFY_MESSAGE_TEMPLATE_DEFAULT_JA),\n                data[user].get(CONF_NOTIFY_", "CodeBleu_score": 27.24210331401033}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    user_settings = self._user_settings.get(user_id)\n    if user_settings is None:\n        return False\n    notification_settings = user_settings.get(\"notification_settings\")\n    if notification_settings is None:\n        return False\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n    return await self._hass.async_add_executor_job(\n        self._validate_otp, notification_settings, otp\n    )\n\n", "CodeBleu_score": 54.405537403477936}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    user_settings = self._user_settings.get(user_id)\n    if user_settings is None:\n        return False\n    notification_settings = user_settings.get(\"notification_settings\")\n    if notification_settings is None:\n        return False\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n    otp_valid = await self._hass.async_add_executor_job(\n        validate_otp,\n        notification_settings.get(\"otp_secret\"),\n        otp,\n    )\n    return otp_valid\n\n", "CodeBleu_score": 50.61595812934103}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    user_settings = self._user_settings.get(user_id)\n    if user_settings is None:\n        return False\n    notification_settings = user_settings.notification_settings\n    if notification_settings is None:\n        return False\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n    otp_valid = await self._hass.async_add_executor_job(\n        validate_otp, notification_settings.otp_secret, otp\n    )\n    return otp_valid\n\n", "CodeBleu_score": 51.12467916734915}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n\n    if device_entry is None or device_entry.area_id is None:\n        return None\n\n    area_id = device_entry.area_id\n    return area_dict.get(area_id)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 79.21330451259959}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n    device_id = entity_entry.device_id\n    if device_id is None:\n        return None\n    area_id = entity_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 54.69292086023396}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n\n    if entity_entry is None:\n        return None\n\n    device_id = entity_entry.device_id\n\n    if device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n\n    if device_entry is None or device_entry.area_id is None:\n        return None\n\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 77.94127958171536}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n\n    for category, sources in _get_categories(policies).items():\n        if category in seen:\n            continue\n        seen.add(category)\n\n        policy[category] = _merge_policies(sources)\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 49.109876959227506}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        for category in policy_:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [p.get(category) for p in policies if category in p]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 62.337618195801625}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n\n    for policy_dict in policies:\n        for category in policy_dict:\n            if category not in seen:\n                seen.add(category)\n                policy[category] = _merge_policies(\n                    [src.get(category) for src in policies if isinstance(src, dict)]\n                )\n\n    return cast(PolicyType, policy)\n", "CodeBleu_score": 58.148621525141195}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Unable to load auth provider %s: %s\", provider, err)\n        raise HomeAssistantError(err) from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        processed = hass.data.setdefault(DATA_SETUP_PROCESSED, set())\n        if module.REQUIREMENTS not in processed:\n            await requirements.async_process_requirements(\n                hass, module.REQUIREMENTS, \"auth_provider\", provider\n            )\n            processed.add(module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 51.28060463115395}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Unable to find authentication provider %s\", provider)\n        raise HomeAssistantError() from None\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not await requirements.async_process_requirements(\n        hass,\n        f\"auth provider {provider}\",\n        requirements.REQUIREMENTS_FILE,\n        module.REQUIREMENTS,\n    ):\n        raise HomeAssistantError()\n\n    return module", "CodeBleu_score": 40.99934831434036}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Unable to load auth provider %s\", provider)\n        raise HomeAssistantError(f\"Unable to load auth provider {provider}\") from None\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if module.REQUIREMENTS and not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, \"auth_provider\"\n        )\n\n    processed.add(provider)\n    return module\n\n", "CodeBleu_score": 43.9757987475754}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    if data is None:\n        data = {\"users\": []}\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 46.273006560317306}, {"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    if data is None:\n        data = {\"users\": []}\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 46.273006560317306}, {"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    if data is None:\n        data = {\"users\": []}\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 46.273006560317306}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt()).decode()\n\n    for user in self.users:\n        if normalized_username == user[\"username\"]:\n            stored_hash = user[\"password\"].encode(\"utf-8\")\n            password_bytes = password.encode(\"utf-8\")\n            if not bcrypt.checkpw(password_bytes, stored_hash):\n                raise InvalidAuth(\"Invalid password\")\n            return\n\n    # Perform a dummy hash check to prevent timing attacks\n    bcrypt.checkpw(b\"password\", dummy_hash.encode(\"utf-8\"))\n\n    raise InvalidAuth(\"Invalid username\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 39.34414521108724}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n    for user in self.users:\n        if user['username'] == username:\n            stored_hash = base64.b64decode(user['password'].encode('utf-8'))\n            if not bcrypt.checkpw(password.encode('utf-8'), stored_hash):\n                raise InvalidAuth('Invalid password')\n            return\n    bcrypt.checkpw(password.encode('utf-8'), dummy_hash.encode('utf-8'))\n    raise InvalidAuth('Invalid username')", "CodeBleu_score": 41.609351804339}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n    for user in self.users:\n        if user['username'] == username:\n            stored_hash = user['password'].encode('utf-8')\n            if not bcrypt.checkpw(password.encode('utf-8'), stored_hash):\n                raise InvalidAuth('Invalid password')\n            return\n    # Perform a dummy hash check to prevent timing attacks\n    bcrypt.checkpw(password.encode('utf-8'), dummy_hash.encode('utf-8'))\n    raise InvalidAuth('Invalid username')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 40.11158908374187}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    try:\n        self.users.pop(username)\n    except KeyError:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 23.783382756920226}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for user in self.users:\n        if username == user.username:\n            self.users.pop(self.users.index(user))\n            return\n    raise InvalidUser(\"user_not_found\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 31.272251243669626}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    try:\n        self.users.pop(username)\n    except KeyError:\n        raise InvalidUser(\"user_not_found\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 23.783382756920226}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n\n    try:\n        del self._data[\"auth_providers\"][credentials.data[\"username\"]]\n    except KeyError:\n        pass\n\n    await self.async_save()\n", "CodeBleu_score": 51.80122120530408}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n    try:\n        self._data[\"credentials\"].pop(credentials.username)\n    except KeyError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 50.94533369975767}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self.async_initialize()\n\n    try:\n        self._data[credentials.id].pop(CONF_ACCESS_TOKEN)\n        await self._store.async_save(self._data)\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 46.1035415739462}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    now = time.monotonic()\n    timeout_per_thread = timeout / len(threads)\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n\n        ident = getattr(thread, \"ident\", None)\n        if ident is None:\n            joined.add(thread)\n            continue\n\n        remaining = timeout_per_thread - (time.monotonic() - now)\n        thread.join(remaining)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n\n        if log:\n            _log_thread_running_at_shutdown(thread.name, ident)\n\n        with contextlib.suppress(SystemExit):\n            async_raise(ident, SystemExit)\n\n    return joined\n\n", "CodeBleu_score": 59.19666083088991}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    now = time.monotonic()\n    timeout_per_thread = timeout / len(threads)\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n\n        if thread.ident is None:\n            # Thread is daemonic, can't wait for it to join.\n            joined.add(thread)\n            continue\n\n        # Ask the thread to stop.\n        delta = now + timeout_per_thread - time.monotonic()\n        if delta <= 0:\n            # Immediately stop the thread.\n            joined.add(thread)\n            continue\n\n        thread.join(timeout=delta)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n\n    # Try to raise a SystemExit in the threads that have a running attribute.\n    for thread in threads:\n        if not hasattr(thread, \"running\"):\n            continue\n\n        if not thread.running:\n            continue\n\n        with contextlib.suppress(SystemExit):\n            async_raise(thread.ident, SystemExit)\n\n    return joined\n\n", "CodeBleu_score": 63.607274173517624}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    time_remaining = timeout\n    end_time = time.monotonic() + time_remaining\n    for thread in threads:\n        time_remaining = end_time - time.monotonic()\n        if time_remaining <= 0:\n            break\n        thread.join(time_remaining)\n        if not thread.is_alive():\n            joined.add(thread)\n        elif thread.ident is None:\n            # Threads created with daemon=True or _set_daemon() lose their\n            # ident at shutdown. We must preserve these threads' identities\n            # to avoid confusion in the logs.\n            joined.add(thread)\n        elif log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads.difference(joined):\n        if thread.is_alive():\n            with contextlib.suppress(SystemExit):\n                async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 57.012186384228514}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    shutdown_timeout = self.config.shutdown_timeout\n    remaining_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon\n    ]\n    timeout = shutdown_timeout / len(remaining_threads)\n    for thread in remaining_threads:\n        if thread.is_alive():\n            thread.join(timeout=timeout)\n            if thread.is_alive():\n                _LOGGER.warning(\n                    \"Thread %s did not join within %s seconds. This is likely a deadlock\",\n                    thread.name,\n                    timeout,\n                )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 41.59720411849644}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon\n    ]\n    timeout = self._shutdown_timeout / len(threads)\n    for thread in threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\"Failed to join thread %s\", thread.name)", "CodeBleu_score": 35.15318527797884}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n\n    def _join_thread(thread: threading.Thread, timeout: float) -> None:\n        \"\"\"The function \"_join_thread\" attempts to join a thread within a specified timeout. If the thread is successfully joined, it logs a message indicating that the thread has been joined. If the thread is not successfully joined within the timeout, it logs a warning message indicating that the thread has not been joined.\"\"\"\n        if thread.is_alive():\n            thread.join(timeout)\n            if thread.is_alive():\n                _LOGGER.warning(\n                    \"Thread %s did not join within %s seconds\", thread.name, timeout\n                )\n            else:\n                _LOGGER.debug(\"Thread %s joined\", thread.name)\n\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon\n    ]\n    timeout = SHUTDOWN_TIMEOUT / len(threads) if threads else SHUTDOWN_TIMEOUT\n    for thread in threads:\n        _join_thread(thread, timeout)", "CodeBleu_score": 43.20128421845924}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        async_dispatcher_send_internal(\n            self._hass,\n            f\"{self._entry.entry_id}_remaining_setups\",\n            remaining_with_setup_started,\n        )\n        self._previous_state = remaining_with_setup_started", "CodeBleu_score": 56.17761742419386}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        async_dispatcher_send_internal(\n            self._hass,\n            f\"{SIGNAL_SETUP_FINISHED}_{self._domain}\",\n            remaining_with_setup_started,\n        )\n        self._previous_state = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 56.81818674934513}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        async_dispatcher_send_internal(self._hass, f\"{SIGNAL_SETUP_STARTED}_remaining\", remaining_with_setup_started)\n        self._previous_state = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 49.09573345762518}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if not bluetooth_path.is_file():\n        config.add_error(\"bluetooth\", \"File bluetooth.py is not up to date\")\n        return\n\n    with open(bluetooth_path) as fp:\n        current = fp.read().strip()\n\n    if current != content:\n        config.add_error(\"bluetooth\", \"File bluetooth.py is not up to date\")\n\n", "CodeBleu_score": 69.47587312317829}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if not bluetooth_path.is_file():\n        config.add_error(\"bluetooth\", \"File bluetooth.py is not up to date\")\n        return\n\n    with bluetooth_path.open(\"r\") as fp:\n        current = fp.read().strip()\n\n    if current != content:\n        config.add_error(\"bluetooth\", \"File bluetooth.py is not up to date\")\n\n", "CodeBleu_score": 69.3493975198106}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if not bluetooth_path.is_file():\n        return\n\n    with open(str(bluetooth_path)) as fp:\n        current = fp.read()\n\n    if current != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n\n", "CodeBleu_score": 90.77992103778838}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken  string `json:\"access_token\"`\n\t\tTokenType    string `json:\"token_type\"`\n\t\tExpiresIn    int    `json:\"expires_in\"`\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t\tScope        string `json:\"scope\"`\n\t\tUID          string `json:\"uid\"`\n\t\tAccountID    string `json:\"account_id\"`\n\t}\n\tvar e struct {\n\t\tError            string `json:\"error\"`\n\t\tErrorDescription string `json:\"error_description\"`\n\t}\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.DropboxTokenEndpoint)\n\tif err != nil {\n\t\tlogger.Error(\"refresh token error\", zap.Error(err))\n\t\treturn err\n\t}\n\tif res.StatusCode() != 200 {\n\t\tlogger.Error(\"refresh token error\", zap.String(\"status\", res.Status()), zap.String(\"response\", res.String()))\n\t\treturn fmt.Errorf(\"refresh token error, status: %s\", res.Status())\n\t}\n\tif e.Error != \"\" {\n\t\tlogger.Error(\"refresh token error\", zap.String(\"error\", e.Error), zap.String(\"error_description\", e.ErrorDescription))\n\t\treturn fmt.Errorf(\"refresh token error, status: %s, %s\", e.Error, e.ErrorDescription)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 61.35595175729899}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken  string `json:\"access_token\"`\n\t\tTokenType    string `json:\"token_type\"`\n\t\tExpiresIn    int    `json:\"expires_in\"`\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t\tScope        string `json:\"scope\"`\n\t\tUID          string `json:\"uid\"`\n\t}\n\tvar e struct {\n\t\tError            string `json:\"error\"`\n\t\tErrorDescription string `json:\"error_description\"`\n\t}\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).\n\t\tSetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").\n\t\tPost(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif res.StatusCode() == 400 {\n\t\tlogger.Info(\"Dropbox refresh token failed\", zap.String(\"error\", e.Error), zap.String(\"error_description\", e.ErrorDescription))\n\t\treturn fmt.Errorf(\"Dropbox refresh token failed, %s\", e.ErrorDescription)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 62.268017922581144}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken  string `json:\"access_token\"`\n\t\tTokenType    string `json:\"token_type\"`\n\t\tExpiresIn    int    `json:\"expires_in\"`\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t\tScope        string `json:\"scope\"`\n\t\tUID          string `json:\"uid\"`\n\t\tAccountID    string `json:\"account_id\"`\n\t}\n\tvar e struct {\n\t\tError            string `json:\"error\"`\n\t\tErrorDescription string `json:\"error_description\"`\n\t}\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Endpoint.TokenURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif res.StatusCode() != 200 {\n\t\tlogger.Info(\"refresh token error\", zap.String(\"error\", e.Error), zap.String(\"error_description\", e.ErrorDescription))\n\t\treturn fmt.Errorf(res.String())\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 62.747002301835096}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode() == 401 {\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\tif !res.IsSuccess() {\n\t\treturn nil, fmt.Errorf(\"request failed, status code: %d, response body: %s\", res.StatusCode(), res.String())\n\t}\n\n\tif resp != nil {\n\t\treturn nil, nil\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 73.6224674228316}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode() == 401 {\n\t\td.refreshToken()\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\tif !res.IsSuccess() {\n\t\treturn nil, fmt.Errorf(\"request failed, status code: %d, response: %s\", res.StatusCode(), res.String())\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 68.29452436584349}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\tif err = d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif !res.IsSuccess() {\n\t\treturn nil, fmt.Errorf(\"request failed, status code: %d\", res.StatusCode())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 79.26018730019351}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size based on the file size\n\tchunkSize := int64(math.Ceil(float64(stream.GetSize()) / float64(d.ChunkSize)))\n\n\t// Initialize the starting position for the next chunk\n\tfinish := int64(0)\n\n\t// Loop through the file, uploading each chunk until it is fully uploaded\n\tfor finish < stream.GetSize() {\n\t\t// Check if the context has been canceled\n\t\tif utils.IsCanceled(ctx) {\n\t\t\t// If the context has been canceled, return an error\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Create a new HTTP request to upload the chunk\n\t\treq := d.request(\"PUT\", url, stream.GetName())\n\n\t\t// Set the headers for the chunk request\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\n\t\t// Send the chunk request and check for errors\n\t\tif err := req.Send(); err != nil {\n\t\t\t// If an error occurs, return the error\n\t\t\treturn err\n\t\t}\n\n\t\t// Update the starting position for the next chunk\n\t\tfinish += chunkSize\n\t}\n\n\t// Complete the upload by sending a final PUT request\n\treq := d.request(\"PUT\", url, stream.GetName())\n\treq.SetHeaders(map[string]string{\n\t\t\"Content-Length\": \"0\",\n\t}).SetBody(nil).SetContext(ctx)\n\treturn req.Send()\n}", "CodeBleu_score": 57.56262104863155}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := stream.GetSize() / 1000\n\tif chunkSize < 1024 {\n\t\tchunkSize = 1024\n\t}\n\tfinish := int64(0)\n\tfor {\n\t\tif stream.GetSize() <= finish {\n\t\t\tbreak\n\t\t}\n\t\tif stream.GetSize() < finish+chunkSize {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\treq := d.request(url, \"PUT\", nil)\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tif _, err := req.Do(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.75320975887717}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmountPoint := ctx.Bind(&storage.MountStorage{}).MountPoint\n\tif mountPoint == \"\" {\n\t\treturn common_err.ClientError(ctx, \"mount point is empty\")\n\t}\n\n\terr := service.MyService.Storage().UnmountStorage(mountPoint)\n\tif err != nil {\n\t\treturn common_err.ServiceError(ctx, err)\n\t}\n\n\terr = service.MyService.Storage().DeleteConfigByName(mountPoint)\n\tif err != nil {\n\t\treturn common_err.ServiceError(ctx, err)\n\t}\n\n\treturn common_err.Success(ctx, \"success\")\n}", "CodeBleu_score": 38.84178076161724}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context\n\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ClientError(err))\n\t}\n\n\t// Check if the mount point is empty\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ClientError(errors.New(\"mount_point is empty\")))\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ServiceError(err))\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ServiceError(err))\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, common_err.Success(\"Unmount storage successfully\"))\n}", "CodeBleu_score": 40.830201288789176}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ClientError{Msg: \"Mount point is required\"})\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.Success{Msg: \"Storage unmounted successfully\"})\n}", "CodeBleu_score": 45.04151705666728}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"filePath\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.FILE_PATH_MISSING))\n\t}\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.FILE_NOT_EXIST))\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.997905810376054}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg{\n\t\t\tMessage: \"file path is required\",\n\t\t})\n\t}\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg{\n\t\t\tMessage: \"file not found\",\n\t\t})\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 40.45586861994994}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.FILE_PATH_IS_EMPTY))\n\t}\n\n\tfile := file.Exists(path)\n\tif !file {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.FILE_NOT_EXISTS))\n\t}\n\n\treturn ctx.File(path)\n}", "CodeBleu_score": 45.19883539508799}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err.Error()))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(\"success\"))\n}", "CodeBleu_score": 65.0461794753755}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.SUCCESS)\n}", "CodeBleu_score": 64.31737759031284}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(err))\n}", "CodeBleu_score": 65.38881734559972}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\tconnections = append(connections, ws)\n\tgo SendMeg()\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(string(msg))\n\t}\n\treturn nil\n}", "CodeBleu_score": 46.65611783440643}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer ws.Close()\n\tconnections = append(connections, ws)\n\tif !service.Running {\n\t\tservice.Running = true\n\t\tgo service.SendMeg()\n\t}\n\n\tfor {\n\t\t// Read\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 53.52302555560486}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\twsConns = append(wsConns, ws)\n\t// Ensure that the message sending service is running\n\tgo SendMeg()\n\t// Continuously read messages from the WebSocket connection\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.656590719170744}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArchitecture := GetDriveInfo()\n\tcpuInfo, err := GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SystemHardwareInfoError))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.Success).AddData(\"drive_model\", driveModel).AddData(\"drive_architecture\", driveArchitecture).AddData(\"cpu_info\", cpuInfo))\n}", "CodeBleu_score": 23.302759868666058}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArchitecture := GetDriveInfo()\n\tcpuInfo, err := GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.GET_CPU_INFO_FAILED))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS).AddData(\"drive_model\", driveModel).AddData(\"drive_architecture\", driveArchitecture).AddData(\"cpu_info\", cpuInfo))\n}", "CodeBleu_score": 23.103169304671496}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArchitecture := GetDriveInfo()\n\tcpuInfo, err := GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg{\n\t\t\tMessage: \"nil\",\n\t\t})\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg{\n\t\tMessage: \"success\",\n\t\tData: map[string]interface{}{\n\t\t\t\"driveModel\":      driveModel,\n\t\t\t\"driveArchitecture\": driveArchitecture,\n\t\t\t\"cpuInfo\":         cpuInfo,\n\t\t},\n\t})\n}", "CodeBleu_score": 24.719282043936403}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 76.09609143114078}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 75.81318203044482}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 75.0506881420019}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageStr := make(map[string]string)\n\tfor k, v := range message {\n\t\tjsonStr, err := json.Marshal(v)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"json marshal error\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\tmessageStr[k] = string(jsonStr)\n\t}\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), name, messageStr)\n\tif err != nil {\n\t\tlogger.Error(\"publish event error\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"publish event failed\", zap.Any(\"response\", response))\n\t\treturn\n\t}\n}", "CodeBleu_score": 55.82560116490411}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t}\n\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), name, string(msg))\n\tif err != nil {\n\t\tlogger.Error(err)\n\t}\n\n\tif response.StatusCode != response.StatusOK {\n\t\tlogger.Error(fmt.Sprintf(\"failure in sending notification: %s\", response.Details))\n\t}\n}", "CodeBleu_score": 36.682577337188164}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tdata := make(map[string]string)\n\tfor key, value := range message {\n\t\tjsonValue, err := json.Marshal(value)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to marshal message value\", zap.Any(\"key\", key), zap.Any(\"value\", value), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdata[key] = string(jsonValue)\n\t}\n\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), name, data)\n\tif err != nil {\n\t\tlogger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 57.1250373600213}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tmb, err := external.GetMessageBusAddress(c.runtimePath)\n\tif err != nil {\n\t\tmb = \"error: unable to get message bus address\"\n\t}\n\n\tclient := message_bus.NewClientWithResponses(mb)\n\n\treturn client\n}", "CodeBleu_score": 32.47638051661659}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"\", message_bus.WithHTTPClient(c.client))\n\tresp, err := c.runtime.GetMessageBusAddress(context.Background())\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t\treturn client\n\t}\n\tclient.Server = resp.JSON200.Address\n\treturn client\n}", "CodeBleu_score": 42.87747850547298}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"\")\n\taddress, err := c.runtime.GetMessageBusAddress(c.runtime.GetRuntimePath())\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t} else {\n\t\tclient.Server = address\n\t}\n\treturn client\n}", "CodeBleu_score": 36.837029727755436}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t    forwarded := request.Header.Get(\"x-forwarded-for\")\n    if forwarded != \"\" {\n        // x-forwarded-for header is present, extract the first IP\n        parts := strings.Split(forwarded, \",\")\n        if len(parts) > 0 {\n            ip := strings.TrimSpace(parts[0])\n            if ip == \"::1\" {\n                ip = \"127.0.0.1\"\n            }\n            if ip == \"::ffff:127.0.0.1\" {\n                ip = \"127.0.0.1\"\n            }\n            return ip\n        }\n    }\n\n    // x-forwarded-for header is not present, use the request's remote address\n    ip := request.RemoteAddr\n    if ip == \"::1\" {\n        ip = \"127.0.0.1\"\n    }\n    if ip == \"::ffff:127.0.0.1\" {\n        ip = \"127.0.0.1\"\n    }\n    return ip\n}", "CodeBleu_score": 45.61919374253155}, {"code": "func GetIP(request *http.Request) string{\n\t\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\tif forwarded != \"\" {\n\t\tip := strings.Split(forwarded, \",\")[0]\n\t\treturn ip\n\t}\n\n\tip := request.RemoteAddr\n\tif strings.Contains(ip, \"::1\") || strings.Contains(ip, \"::ffff:127.0.0.1\") {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 40.68013738864924}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip != \"\" {\n\t\tip = strings.Split(ip, \",\")[0]\n\t} else {\n\t\tip, _, _ = net.SplitHostPort(request.RemoteAddr)\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 68.15907278525873}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := filepath.Join(c.config.RootDir, \"modules\")\n\tentryFilePath := filepath.Join(c.config.RootDir, \"entry.json\")\n\n\tif err := file.IsNotExistCreateFile(entryFilePath); err != nil {\n\t\tlogger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\tentryFile, err := os.OpenFile(entryFilePath, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to open entry file\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\tentry := make([]byte, 0)\n\tentry = append(entry, []byte(\"[\")...)\n\n\tmodules, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tfor _, module := range modules {\n\t\tif !module.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tmoduleDir := filepath.Join(modulesDir, module.Name())\n\t\tentryFilePath := filepath.Join(moduleDir, \"entry.json\")\n\n\t\tentryBytes, err := os.ReadFile(entryFilePath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(entry) > 1 {\n\t\t\tentry = append(entry, []byte(\",\")...)\n\t\t}\n\n\t\tentry = append(entry, entryBytes...)\n\t}\n\n\tentry = append(entry, []byte(\"]\")...)\n\n\tif _, err := entryFile.Write(entry); err != nil {\n\t\tlogger.Error(\"Failed to write to entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 50.82451835848997}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := filepath.Join(c.config.System.ModulesPath)\n\tentryFilePath := filepath.Join(c.config.System.ModulesPath, \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tif _, err := os.Create(entryFilePath); err != nil {\n\t\t\tc.logger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tvar entries []byte\n\tfor _, module := range c.config.System.Modules {\n\t\tmodulePath := filepath.Join(modulesPath, module)\n\t\tentryFile := filepath.Join(modulePath, \"entry.json\")\n\n\t\tentryData, err := os.ReadFile(entryFile)\n\t\tif err != nil {\n\t\t\tc.logger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, entryData...)\n\t}\n\n\t// Write the consolidated entries to the entry file path\n\tif err := os.WriteFile(entryFilePath, entries, 0644); err != nil {\n\t\tc.logger.Error(\"Failed to write entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 45.96583334929549}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnames, err := c.System().GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\tfor _, n := range names {\n\t\t\tif i.Name == n {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 70.61827192696724}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnames, err := MyService.System().GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 67.66870387551474}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t    ifaces, err := net.Interfaces()\n    if err != nil {\n        return \"\", err\n    }\n    names, err := c.System().GetNet()\n    if err != nil {\n        return \"\", err\n    }\n    for _, iface := range ifaces {\n        for _, name := range names {\n            if iface.Name == name {\n                return iface.HardwareAddr.String(), nil\n            }\n        }\n    }\n    return \"\", errors.New(\"No network interface found\")\n}", "CodeBleu_score": 63.870893267094985}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  pRequest->ref = 1;\n  atomic_add_fetch_64(&pTscObj->requestCount, 1);\n\n  if (pTscObj->pAppInfo) {\n    pTscObj->pAppInfo->requestSummary.totalRequests++;\n    pTscObj->pAppInfo->requestSummary.currentRequests++;\n  }\n\n  tscDebug(\"%s:%d, ref=%\" PRId64 \", requestCount=%\" PRId64 \", appId=%\" PRId64 \", appRequests=%\" PRId64, __FUNCTION__,\n           __LINE__, pRequest->ref, pTscObj->requestCount, pTscObj->appId, pTscObj->pAppInfo->requestSummary.currentRequests);\n\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 47.22797869300129}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t code;\n\n  atomic_add_fetch_64(&pRequest->ref, 1);\n  atomic_add_fetch_64(&pTscObj->requestCount, 1);\n\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->requestSummary.totalRequests++;\n    pTscObj->pAppInfo->requestSummary.currentRequests++;\n  }\n\n  tscDebug(\"%s:%d, ref:%ld, requestCount:%ld\", __FUNCTION__, __LINE__, pRequest->ref, pTscObj->requestCount);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 37.37934631140059}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t code = 0;\n\n  pRequest->ref = 1;\n  atomic_add_fetch_64(&pTscObj->numOfRequests, 1);\n\n  if (pTscObj->pAppInfo) {\n    pTscObj->pAppInfo->requestSummary.totalRequests++;\n    pTscObj->pAppInfo->requestSummary.currentRequests++;\n  }\n\n  tscDebug(\"%s:%d, ref:%d, numOfRequests:%ld\", __FUNCTION__, __LINE__, pRequest->ref, pTscObj->numOfRequests);\n\n  return code;\n}", "CodeBleu_score": 37.2612677224003}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (pRequest->db != NULL) {\n        if (strcmp(pRequest->db, exceptDb) != 0) {\n            return true;\n        }\n    }\n\n    if (pRequest->dbList != NULL) {\n        int32_t dbNum = taosArrayGetSize(pRequest->dbList);\n        for (int32_t i = 0; i < dbNum; ++i) {\n            char* db = (char*)taosArrayGet(pRequest->dbList, i);\n            if (db == NULL) {\n                continue;\n            }\n            char* dbName = strchr(db, '.');\n            if (dbName != NULL) {\n                dbName++;\n            } else {\n                dbName = db;\n            }\n            if (strcmp(dbName, exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 59.52099538634417}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest == NULL) return false;\n  if (pRequest->pDb == NULL) return false;\n\n  if (strcmp(pRequest->pDb->name, exceptDb) != 0) {\n    int32_t numDb = taosArrayGetSize(pRequest->dbArray);\n    for (int32_t i = 0; i < numDb; ++i) {\n      char* dbName = taosArrayGet(pRequest->dbArray, i);\n      char* p = strchr(dbName, '.');\n      if (p != NULL) {\n        *p = '\\0';\n      }\n      if (strcmp(dbName, exceptDb) == 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 62.0062140389515}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->pDb == NULL) return false;\n  if (strcmp(pRequest->pDb->name, exceptDb) == 0) return false;\n\n  for (int32_t i = 0; i < pRequest->numOfDb; ++i) {\n    char *dbName = pRequest->db[i];\n    char *pos = strchr(dbName, '.');\n    if (pos != NULL) dbName = pos + 1;\n    if (strcmp(dbName, exceptDb) == 0) return false;\n  }\n  return true;\n}", "CodeBleu_score": 58.12900767999728}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code != NEED_REDIRECT_ERROR) {\n        return false;\n    }\n    switch (msgType) {\n        case TMSG_CREATE:\n        case TMSG_MKDIR:\n        case TMSG_SYMLINK:\n        case TMSG_RENAME:\n        case TMSG_SETATTR:\n        case TMSG_SETXATTR:\n        case TMSG_REMOVEXATTR:\n        case TMSG_DELETE:\n        case TMSG_READDIR:\n        case TMSG_READDIRPLUS:\n        case TMSG_FSSTAT:\n        case TMSG_FSINFO:\n        case TMSG_PATHCONF:\n        case TMSG_COMMIT:\n            return true;\n        default:\n            return false;\n    }\n}", "CodeBleu_score": 39.86012498440136}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == NEED_REDIRECT_ERROR) {\n        if (msgType == Msg_RpcReq || msgType == Msg_RpcResp || msgType == Msg_RpcRetry) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 40.653697488216835}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == NEED_REDIRECT_ERROR) {\n        if (msgType != TMSG_T_RPC_RESPONSE && msgType != TMSG_T_RPC_REQUEST && msgType != TMSG_T_RPC_ERROR) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 38.66490745595744}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashIterator *pIter = taosHashIterate(pRequests, 0);\n  while (pIter) {\n    SRequest *pReq = (SRequest *)taosHashIterateNext(pIter);\n    if (pReq) {\n      int64_t rid = pReq->rid;\n      taos_stop_query(rid);\n      releaseRequest(rid);\n    }\n  }\n  taosHashIterateDestroy(pIter);\n}", "CodeBleu_score": 39.8732791255561}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashIterator iter;\n  SHashObj *pReq;\n  int32_t     code;\n  int64_t     rid;\n\n  pReq = taosHashIterateInit(pRequests, &iter);\n  while (pReq != NULL) {\n    rid = taosHashIterateNext(pRequests, &iter);\n    pReq = taosHashGet(pRequests, rid);\n    if (pReq == NULL) continue;\n\n    code = taos_stop_query(pReq);\n    if (code != 0) {\n      taosWarn(\"failed to stop query, code:%d\", code);\n    }\n\n    releaseRequest(rid);\n  }\n}", "CodeBleu_score": 49.84838891357912}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashIter *pIter = taosHashIterate(pRequests, NULL);\n  while (pIter) {\n    SRequest *pReq = (SRequest *)taosHashIterValue(pIter);\n    if (pReq) {\n      taos_stop_query(pReq->pQuery);\n      releaseRequest(pReq->rid);\n    }\n    pIter = taosHashIterate(pRequests, pIter);\n  }\n}", "CodeBleu_score": 61.2784439103389}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if (gClientCfg.crashReporting == false) {\n        return;\n    }\n\n    int32_t expected = 0;\n    while (!atomic_val_compare_exchange_32(&gClientCfg.clientStop, &expected, 1)) {\n        if (expected == 1) {\n            tError(\"crash report thread is already stopped\");\n            return;\n        }\n        taosMsleep(10);\n    }\n\n    while (gClientCfg.clientStop) {\n        taosMsleep(10);\n    }\n}", "CodeBleu_score": 55.722404009392825}, {"code": "void tscStopCrashReport(){\n\t  if (tscIsCrashReportEnabled() == false) {\n    return;\n  }\n  int32_t old = 0;\n  if (atomic_val_compare_exchange_32(&tscCrashReportClientStop, &old, 1) == false) {\n    tscError(\"tscStopCrashReport, crash report thread is already stopped.\");\n    return;\n  }\n  while (tscCrashReportClientStop == 0) {\n    taosMsleep(100);\n  }\n}", "CodeBleu_score": 51.975883338854864}, {"code": "void tscStopCrashReport(){\n\t  if (tscIsCrashReportEnabled() == false) {\n    return;\n  }\n\n  int32_t old = 1;\n  if (atomic_val_compare_exchange_32(&clientStop, &old, 0) == false) {\n    tscError(\"tscStopCrashReport, crash report thread is already stopped\");\n    return;\n  }\n\n  while (clientStop) {\n    taosMsleep(10);\n  }\n}", "CodeBleu_score": 53.76252856859255}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t     code = 0;\n  SViewMeta **ppViewMeta = NULL;\n  int32_t     numOfViewMeta = 0;\n  int32_t     numOfColumns = 0;\n  int32_t     i = 0;\n\n  SViewMetaRsp *pViewMetaRsp = (SViewMetaRsp *)value;\n\n  // Deserialize the response\n  code = taosDeserializeSViewHbRsp(pViewMetaRsp, valueLen, &ppViewMeta, &numOfViewMeta);\n  if (code != 0) {\n    taosMemoryFreeClear(pViewMetaRsp);\n    return code;\n  }\n\n  // Iterate through the view metadata\n  for (i = 0; i < numOfViewMeta; ++i) {\n    // Get the number of columns in the view\n    numOfColumns = ppViewMeta[i]->numOfColumns;\n\n    // If the number of columns is 0, remove the view metadata\n    if (numOfColumns == 0) {\n      catalogRemoveViewMeta(pCatalog, ppViewMeta[i]->viewName);\n    } else {\n      // Otherwise, update the view metadata\n      catalogUpdateViewMeta(pCatalog, ppViewMeta[i]);\n    }\n  }\n\n  // Destroy the response array\n  taosArrayDestroyEx(ppViewMeta, numOfViewMeta, (void *)taosFreeSViewMetaRsp);\n\n  // Clean up and return success\n  taosMemoryFreeClear(pViewMetaRsp);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 43.42119500409664}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  SViewMetaRsp *pRsp = (SViewMetaRsp *)value;\n  int32_t        code = 0;\n\n  if (pRsp == NULL) {\n    return TSDB_CODE_SUCCESS;\n  }\n\n  int32_t num = taosArrayGetSize(pRsp->pViews);\n\n  for (int32_t i = 0; i < num; ++i) {\n    SViewMeta *pView = (SViewMeta *)taosArrayGetP(pRsp->pViews, i);\n\n    if (pView->numOfColumns <= 0) {\n      catalogRemoveViewMeta(pCatalog, pView->db, pView->view);\n    } else {\n      code = catalogUpdateViewMeta(pCatalog, pView);\n      if (code != TSDB_CODE_SUCCESS) {\n        return code;\n      }\n    }\n  }\n\n  taosArrayDestroy(pRsp->pViews);\n  taosMemoryFreeClear(rsp, sizeof(SViewMetaRsp));\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 46.06624879575776}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  SViewMetaRsp *pRsp = (SViewMetaRsp *)value;\n  int32_t        code;\n\n  pRsp->pResp->pData[pRsp->pResp->num - 1] = '\\0';\n  if (pRsp->pResp->num <= 0) {\n    code = TSDB_CODE_CLI_OUT_OF_MEMORY;\n    goto cleanup;\n  }\n\n  if (pRsp->pResp->code != 0) {\n    code = pRsp->pResp->code;\n    goto cleanup;\n  }\n\n  int32_t num = taosArrayGetSize(pRsp->pResp->pArray);\n  for (int32_t i = 0; i < num; ++i) {\n    SViewMeta *pMeta = (SViewMeta *)taosArrayGetP(pRsp->pResp->pArray, i);\n    if (pMeta->numOfColumns > 1) {\n      code = catalogUpdateViewMeta(pCatalog, pMeta);\n    } else {\n      code = catalogRemoveViewMeta(pCatalog, pMeta->viewName);\n    }\n\n    if (code != 0) {\n      goto cleanup;\n    }\n  }\n\n  code = 0;\n\ncleanup:\n  taosArrayDestroyEx(pRsp->pResp->pArray, pRsp->pResp->pData);\n  return code;\n}", "CodeBleu_score": 43.1555015214358}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    S3_CHECK_OR_DIE(properties, S3StatusInvalidArgument, \"Invalid argument\");\n    S3_CHECK_OR_DIE(callbackData, S3StatusInvalidArgument, \"Invalid argument\");\n\n    S3CSEncryptCopyObjectCallbackData *callbackDataPtr = (S3CSEncryptCopyObjectCallbackData *)callbackData;\n\n    if (properties->getContentLength() > 0) {\n        callbackDataPtr->contentLength = properties->getContentLength();\n    } else {\n        callbackDataPtr->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 53.892670170380576}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    S3_CHECK_OR_RAISE(properties, S3StatusInvalidArgument, \"The input argument properties is invalid\");\n    S3_CHECK_OR_RAISE(callbackData, S3StatusInvalidArgument, \"The input argument callbackData is invalid\");\n\n    CallbackData *callbackDataPtr = (CallbackData *)callbackData;\n    if (properties->contentLength > 0) {\n        callbackDataPtr->contentLength = properties->contentLength;\n    } else {\n        callbackDataPtr->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 65.13907730778712}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    S3ListBucketContent *content = (S3ListBucketContent *)callbackData;\n\n    if (properties->getContentLength() > 0) {\n        content->contentLength = properties->getContentLength();\n    } else {\n        content->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 59.38398537311844}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t  if (taosMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2,\n#ifndef WINDOWS\n           \"rsync --daemon --port=%d --config=%srsync.conf\",\n#else\n           \"rsync --daemon --port=%d --config=%srsync.conf --no-detach\",\n#endif\n           tsCheckpointBackupPort, tsCheckpointBackupDir);\n  uDebug(\"[rsync] start rsync server, cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret != 0) {\n    uError(\"[rsync] start rsync server error, ret:%d\", ret);\n  } else {\n    uDebug(\"[rsync] start rsync server success\");\n  }\n}", "CodeBleu_score": 56.70988897585758}, {"code": "void startRsync(){\n\t  if (taosMkDir(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] create backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --port=%d --config=%srsync.conf\", tsCheckpointBackupPort, tsCheckpointBackupDir);\n  uDebug(\"[rsync] start rsync server:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret == 0) {\n    uInfo(\"[rsync] rsync server started successfully\");\n  } else {\n    uError(\"[rsync] rsync server start error, ret:%d\", ret);\n  }\n}", "CodeBleu_score": 51.36934117484182}, {"code": "void startRsync(){\n\t  if (taosMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --port %d --config=%srsync.conf\", tsCheckpointBackupPort, tsCheckpointBackupDir);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n\n  int32_t ret = system(cmd);\n  if (ret == 0) {\n    uInfo(\"[rsync] start rsync server success, port:%d\", tsCheckpointBackupPort);\n  } else {\n    uError(\"[rsync] start rsync server error, ret:%d\", ret);\n  }\n}", "CodeBleu_score": 60.34110738285816}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n}", "CodeBleu_score": 83.11228795411404}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n}", "CodeBleu_score": 72.63633881317374}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.getExecutor().shutdownNow();\n}", "CodeBleu_score": 69.20909028779478}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        forEach(parent, childFilter, childId -> {\n            if (actorSystemContext.getActor(childId) == null) {\n                warn(\"Actor [{}] is not registered, but it is referenced by [{}]\", childId, parent);\n            } else {\n                tell(childId, msg, highPriority);\n            }\n        });\n    }", "CodeBleu_score": 42.194677554270434}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        List<TbActorId> children = actorChildren.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> tell(child, msg, highPriority));\n        }\n    }", "CodeBleu_score": 48.61704011347601}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        List<TbActorId> children = childrenMap.get(parent);\n        if (children != null) {\n            forEach(children, child -> {\n                if (childFilter.test(child)) {\n                    TbActorId target = child;\n                    if (highPriority) {\n                        target = new TbActorId(child.getEntityType(), child.getId(), true);\n                    }\n                    try {\n                        tell(target, msg);\n                    } catch (TbActorStoppedException e) {\n                        warn(\"Failed to send message to stopped actor: [{}]\", target);\n                    }\n                }\n            });\n        }\n    }", "CodeBleu_score": 51.690006340611575}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        log.trace(\"[{}] Message received: {}\", selfId, msg);\n        if (!destructionInProgress) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else {\n            if (msg.getMsgType().equals(RULE_NODE_UPDATED_MSG)) {\n                if (initFailure) {\n                    log.debug(\"[{}] Reinitializing actor due to RULE_NODE_UPDATED_MSG\", selfId);\n                    tryInit(1);\n                }\n            } else {\n                msg.onTbActorStopped();\n            }\n        }\n    }", "CodeBleu_score": 60.603749567373534}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (destructionInProgress.get()) {\n            if (highPriority && msg.getMsgType().equals(RULE_NODE_UPDATED_MSG)) {\n                if (initFailed.get()) {\n                    tryInit(1);\n                }\n            } else {\n                msg.onTbActorStopped();\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 55.91572040914172}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (!destructionInProgress.get()) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else if (msg.getMsgType() == RULE_NODE_UPDATED_MSG && selfId.getType() == EntityType.RULE_CHAIN) {\n            if (initializationFailed.get()) {\n                tryInit(1);\n            } else {\n                msg.getCallback().onSuccess(null);\n            }\n        } else {\n            msg.getCallback().onSuccess(new TbActorError(\"Actor is being stopped\"));\n        }\n    }", "CodeBleu_score": 52.37516086532159}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t        try {\n            long startTime = System.currentTimeMillis();\n            int processedMsgs = 0;\n            while (true) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                }\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                } catch (TbActorInitializationException e) {\n                    stopReason = TbActorStopReason.INIT_FAILURE;\n                    destroy(e);\n                    return;\n                } catch (Throwable t) {\n                    log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n                    actor.onProcessFailure(t, msg);\n                    if (actor.getActorStopReason() != null) {\n                        destroy(t);\n                        return;\n                    }\n                }\n                processedMsgs++;\n                if (processedMsgs >= dispatcher.getActorThroughput()) {\n                    break;\n                }\n            }\n            long endTime = System.currentTimeMillis();\n            long duration = endTime - startTime;\n            if (duration > 0) {\n                actor.onProcessedMsg(processedMsgs, duration);\n            }\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                ready.set(FREE);\n                dispatcher.scheduleQueueProcessing(selfId);\n            } else {\n                dispatcher.getExecutor().execute(this::processMailbox);\n            }\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n        } finally {\n            busy.set(FREE);\n        }\n    }", "CodeBleu_score": 50.808243984319354}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\t        try {\n            long start = System.currentTimeMillis();\n            int throughput = 0;\n            while (throughput < actorThroughput) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                }\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                    throughput++;\n                } catch (TbActorInitializationException e) {\n                    stopReason = TbActorStopReason.INITIALIZATION_FAILED;\n                    destroy(e);\n                    break;\n                } catch (Exception e) {\n                    log.warn(\"[{}] Failed to process message: {}\", selfId, msg, e);\n                    actor.onProcessFailure(e);\n                    if (actor.stopIfFailed()) {\n                        stopReason = TbActorStopReason.STOPPED;\n                        destroy(e);\n                        break;\n                    }\n                }\n            }\n            long duration = System.currentTimeMillis() - start;\n            if (duration > 0) {\n                actorThroughput = (int) (throughput * 1000 / duration);\n            }\n        } finally {\n            busy.set(FREE);\n            if (ready.get() == READY) {\n                dispatcher.getExecutor().execute(this::tryProcessQueue);\n            }\n        }\n    }", "CodeBleu_score": 47.345235515286696}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t        if (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.36402548545796}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.85357591640158}, {"code": "public void destroy(Throwable cause){\n\t        if (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.36402548545796}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profileConfiguration == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    boolean result = checkRateLimit(api, rateLimitConfiguration, tenantId, level);\n    if (!result) {\n        processRateLimitNotification(api, tenantId, level);\n    }\n    return result;\n}", "CodeBleu_score": 38.03530300165098}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profileConfiguration == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    boolean result = checkRateLimit(api, tenantId, rateLimitConfiguration, level);\n    if (!result) {\n        processRateLimitNotification(api, tenantId, rateLimitConfiguration, level);\n    }\n    return result;\n}", "CodeBleu_score": 37.52278259332654}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isSysTenantId()) {\n        return true;\n    }\n    TenantProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId);\n    if (profileConfiguration == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        }\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n    LimitLevelEntityName limitLevelEntityName = new LimitLevelEntityName(api, level);\n    RateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    boolean success = rateLimitConfiguration.checkRateLimit(limitLevelEntityName);\n    if (!success) {\n        processRateLimitNotification(tenantId, limitLevelEntityName, rateLimitConfiguration);\n    }\n    return success;\n}", "CodeBleu_score": 54.28563671375143}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.trace(\"DTLS session {} removed due to inactivity\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 58.17000036872959}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : sessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            sessions.remove(entry.getKey());\n            LOG.trace(\"DTLS session {} evicted due to inactivity\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 56.977274273254665}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.trace(\"DTLS session {} has been removed due to inactivity timeout\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 57.61459432633813}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                result.add(parseValue(key, value));\n            }\n        }\n        return result;\n    }", "CodeBleu_score": 43.538723442859094}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> value = entry.getValue();\n            for (JsonNode jsonNode : value) {\n                result.add(new TsKvEntry(System.currentTimeMillis(), key, parseValue(key, jsonNode)));\n            }\n        }\n        return result;\n    }", "CodeBleu_score": 43.85015312596873}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<TsKvEntry> result = new ArrayList<>();\n        timeseries.forEach((key, values) -> values.forEach(value -> result.add(parseValue(key, value))));\n        return result;\n    }", "CodeBleu_score": 37.6489585809788}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t        Map<String, Object> request = new HashMap<>();\n        request.put(\"refreshToken\", this.refreshToken);\n        JsonNode response = postForEntity(authEndpoint + \"/refresh\", request, JsonNode.class).getBody();\n        setTokenInfo(currentTimeMillis(), response);\n    }", "CodeBleu_score": 45.34684812127424}, {"code": "public void refreshToken(){\n\t        Map<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", this.refreshToken);\n        long ts = currentTimeMillis();\n        JsonNode tokenInfo = postForEntity(this.authEndpoint, request, JsonNode.class).getBody();\n        setTokenInfo(ts, tokenInfo);\n    }", "CodeBleu_score": 50.55551593871055}, {"code": "public void refreshToken(){\n\t        long ts = currentTimeMillis();\n        Map<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", this.refreshToken);\n        ResponseEntity<JsonNode> response = postForEntity(AUTH_ENDPOINT, request, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 46.83341539678172}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t        long ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = postForEntity(\"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 66.21404587637815}, {"code": " private void doLogin(){\n\t        long ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = postForEntity(\n                \"/api/auth/login\",\n                loginRequest,\n                JsonNode.class\n        );\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 63.73965606084456}, {"code": " private void doLogin(){\n\t        long ts = currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = postForEntity(\"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 63.777303732414836}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n                String.format(\"/api/device/%s\", deviceId.getId()),\n                Device.class\n        );\n\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n\n        throw e;\n    }\n}", "CodeBleu_score": 64.99531130039786}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 68.6489194614633}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(baseUrl + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 79.65205707718}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", new DeviceWithCredentialsRequest(device, credentials), Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (Exception e) {\n        throw e;\n    }\n}", "CodeBleu_score": 48.4870311379616}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\n                deviceWithCredentialsUrl,\n                new HttpEntity<>(new DeviceWithCredentials(device, credentials)),\n                Device.class\n        );\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 63.21317193548089}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        DeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n        RequestEntity<DeviceWithCredentials> request = RequestEntity.post(\"/api/device-with-credentials\").body(deviceWithCredentials);\n        return Optional.of(restTemplate.exchange(request, Device.class).getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    }\n}", "CodeBleu_score": 47.194359755684935}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}, {"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}, {"code": "device(addr){\n\t  const bound = {};\n\n  /* keys from prototype */\n  Object.keys(LedControl.prototype).forEach(key => {\n    bound[key] = this[key].bind(this, addr);\n  });\n\n  /* functions from interface */\n  Object.getOwnPropertyNames(this).forEach(key => {\n    if (this[key] && typeof this[key] === \"function\") {\n      bound[key] = this[key].bind(this, addr);\n    }\n  });\n  return bound;\n}", "CodeBleu_score": 99.81793301349097}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach((method) => {\n    target[method] = (duration = 1000, callback) => {\n      if (typeof callback !== 'function') {\n        callback = () => {};\n      }\n      const promises = this.map((element) => {\n        return element[method](duration);\n      });\n      Promise.all(promises).then(callback);\n    };\n  });\n}", "CodeBleu_score": 31.1418601679038}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = (duration, callback) => {\n      duration = duration || 1000;\n      callback = callback || (() => {});\n      ensureFunction(callback);\n      const signals = [];\n      this.forEach(i => {\n        signals.push(i[method](duration));\n      });\n      Promise.all(signals).then(callback);\n    };\n  });\n}", "CodeBleu_score": 30.054550097706763}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  for (let i = 0; i < methods.length; i++) {\n    const method = methods[i];\n    target[method] = function (duration, callback) {\n      duration = duration || 1000;\n      callback = callback || function () {};\n      ensure(callback, 'function');\n      const signals = [];\n      for (let i = 0; i < this.length; i++) {\n        signals.push(this[i][method](duration));\n      }\n      Promise.all(signals).then(callback);\n    };\n  }\n}", "CodeBleu_score": 40.669545759275145}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  const state = priv.get(this);\n  let input = \"\";\n\n  // Start the read loop\n  this.io.serialRead(state.portId, data => {\n    input += new Buffer(data).toString(\"ascii\");\n    const sentences = input.split(\"\\r\n\");\n\n    if (sentences.length > 1) {\n      for (let i = 0; i < sentences.length - 1; i++) {\n        this.parseNmeaSentence(sentences[i]);\n      }\n      input = sentences[sentences.length - 1];\n    }\n  });\n}", "CodeBleu_score": 92.43838272585332}, {"code": "listen(){\n\t    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 90.92172031088639}, {"code": "listen(){\n\t    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 90.92172031088639}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t num_channels = sequence->channels->num_channels;\n\tuint32_t num_active_channels = POPCOUNT(sequence->channels->channel_mask);\n\tuint32_t needed_buffer_size = num_active_channels * config->resolution;\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= sequence->options->extra_samplings + 1U;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Buffer size insufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.87194795431565}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t num_active_channels = 0;\n\tuint32_t buffer_size = 0;\n\n\tfor (uint8_t i = 0; i < sequence->channels_count; i++) {\n\t\tif (sequence->channels[i].channel_id >= config->num_channels) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sequence->channels[i].sampling_delay != 0) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tif (sequence->channels[i].input_positive != sequence->channels[i].input_negative) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sequence->channels[i].input_positive >= config->num_channels) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sequence->channels[i].input_positive != i) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sequence->channels[i].differential) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tif (sequence->channels[i].acquisition_time != AD559X_ACQUISITION_TIME_4000) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tif (sequence->channels[i].gain != AD559X_GAIN_1) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tif (sequence->channels[i].reference != AD559X_REFERENCE_INTERNAL) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tnum_active_channels++;\n\t}\n\n\tbuffer_size = num_active_channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.764100437961275}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tuint8_t num_channels;\n\tuint32_t num_samples;\n\tuint32_t num_bytes;\n\n\tnum_channels = sequence->options->extra_samplings + 1;\n\tnum_samples = sequence->options->num_samples;\n\n\tif (num_samples == 0) {\n\t\tLOG_ERR(\"Number of samples cannot be zero\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (sequence->options->resolution) {\n\tcase 8:\n\t\tnum_bytes = num_channels * num_samples;\n\t\tbreak;\n\tcase 10:\n\t\tnum_bytes = num_channels * num_samples * 2;\n\t\tbreak;\n\tcase 12:\n\t\tnum_bytes = num_channels * num_samples * 3;\n\t\tbreak;\n\tcase 14:\n\t\tnum_bytes = num_channels * num_samples * 4;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported ADC resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < num_bytes) {\n\t\tLOG_ERR(\"Insufficient buffer size for ADC sequence\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.3738377572218}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tint err;\n\n\tif (sequence->resolution != ADC_RESOLUTION_12) {\n\t\tLOG_ERR(\"Unsupported ADC resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & (1 << ADC_CHANNEL_IDLE)) {\n\t\tLOG_ERR(\"ADC_CHANNEL_IDLE is not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tadc_context_start_read(dev, sequence);\n\n\tadc_context_wait_for_completion(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 45.67719186591776}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tuint8_t channels;\n\tsize_t needed;\n\n\tchannels = POPCOUNT(sequence->channels);\n\tneeded = channels * sizeof(uint16_t);\n\n\tif (sequence->resolution != ADC_RESOLUTION_16) {\n\t\tLOG_ERR(\"AD559x requires 16-bit resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (channels > CONFIG_AD559X_MAX_CHANNELS) {\n\t\tLOG_ERR(\"AD559x supports at most %d channels\", CONFIG_AD559X_MAX_CHANNELS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (adc_ad559x_validate_buffer_size(dev, sequence)) {\n\t\treturn -ENOMEM;\n\t}\n\n\tadc_context_start_read(dev, sequence);\n\tadc_context_wait_for_completion(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 49.39831092220356}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.478133658581989}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tadc_context_stop_sampling(ctx);\n\n\tctx->adc_data = adc_get_adc_data(ctx->adc_dev);\n\n\tctx->adc_data->channels = ctx->channels;\n\n\tctx->adc_data->repeat_buf = ctx->data;\n\n\tctx->adc_data->repeat_buf_size = ctx->data_size;\n\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 51.21294614074156}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n    struct adc_cfg *cfg = ctx->cfg;\n\n    /* Set channels to be sampled */\n    for (int i = 0; i < cfg->num_channels; i++) {\n        data->channels[i] = cfg->channels[i];\n    }\n\n    /* Initialize repeat buffer with data buffer */\n    data->repeat_buf.buf = cfg->buf;\n    data->repeat_buf.size = cfg->buf_size;\n\n    /* Release semaphore to signal start of sampling */\n    k_sem_give(&data->sem);\n}", "CodeBleu_score": 35.632653749017244}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n\n    data->channels = ctx->channels;\n    data->repeat_buf = ctx->buffer;\n\n    k_sem_give(&data->sem);\n}", "CodeBleu_score": 48.44471360772326}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    if (repeat_sampling) {\n        struct adc_data *data = CONTAINER_OF(ctx, struct adc_data, adc_context);\n        ctx->buffer = data->repeat_buffer;\n    }\n}", "CodeBleu_score": 58.838765224177706}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data *data = (struct adc_data *)ctx->data;\n    if (repeat_sampling) {\n        ctx->buffer = &data->repeat_buffer;\n    } else {\n        ctx->buffer = &data->buffer;\n    }\n}", "CodeBleu_score": 38.994837501181415}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data_container *container = ctx->container;\n    if (repeat_sampling) {\n        container->buffer = container->repeat_buffer;\n    }\n    else {\n        container->buffer = container->data_buffer;\n    }\n}", "CodeBleu_score": 47.35949584717216}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct adc_ad559x_config *config = data->dev->config;\n\tconst struct adc_channel_cfg *channel_cfg = config->channels;\n\tstruct adc_context *ctx;\n\tuint16_t result;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tctx = data->ctx;\n\n\t\tif (ctx == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (size_t i = 0; i < config->num_channels; i++) {\n\t\t\tif (!channel_cfg[i].acquisition_time) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, i, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", i, ret);\n\t\t\t\tadc_context_on_sampling_done(ctx, i, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadc_context_on_sampling_done(ctx, i, &result);\n\t\t}\n\n\t\tadc_context_complete(ctx, 0);\n\t}\n}", "CodeBleu_score": 48.86005487323708}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct adc_ad559x_config *config = data->dev->config;\n\tuint16_t val;\n\tuint8_t channel;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->num_channels; channel++) {\n\t\t\tif (!data->active_channels[channel]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC channel %d: %d\", channel, ret);\n\t\t\t\tadc_context_on_sampling_done(data->dev, NULL, 0);\n\t\t\t\tadc_context_complete(data->dev, NULL, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdata->buffer[channel] = val;\n\t\t}\n\n\t\tadc_context_on_sampling_done(data->dev, data->buffer, config->num_channels);\n\t}\n}", "CodeBleu_score": 51.94889502808265}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct adc_ad559x_config *config = data->dev->config;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < data->num_channels; channel++) {\n\t\t\tif (!data->active_channels[channel]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tadc_context_on_sampling_done(data->dev, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->buffer[channel] = result;\n\t\t}\n\n\t\tif (ret >= 0) {\n\t\t\tadc_context_on_sampling_done(data->dev, data->buffer);\n\t\t}\n\t}\n}", "CodeBleu_score": 55.586400894038455}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val;\n\tint rc;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\t\tk_sleep(K_USEC(100));\n\t} while (reg_val & ADS1112_CONFIG_DRDY);\n\n\treturn 0;\n}", "CodeBleu_score": 46.47685245908893}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\twhile (true) {\n\t\tint rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (reg_val & ADS1112_CONFIG_DRDY) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n}", "CodeBleu_score": 46.205282775986234}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val;\n\tint rc;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\t} while (!(reg_val & ADS1112_CONFIG_DRDY));\n\n\treturn 0;\n}", "CodeBleu_score": 39.5324263784496}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    int buffer_size = sequence->options->extra_samplings + 1;\n    if (sequence->options->n_samplings == 0) {\n        return 0;\n    }\n    buffer_size += sequence->options->n_samplings - 1;\n    if (sequence->buffer_size < buffer_size) {\n        LOG_ERR(\"ADC buffer size too small\");\n        return -EINVAL;\n    }\n    return 0;\n}", "CodeBleu_score": 43.76168164926008}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    size_t buffer_size = sequence->buffer_size;\n    size_t num_samplings = sequence->options->extra_samplings + sequence->options->oversampling + 1;\n    size_t required_buffer_size = sequence->channels->count * num_samplings;\n\n    if (buffer_size < required_buffer_size) {\n        LOG_ERR(\"buffer size %zu is smaller than required buffer size %zu\", buffer_size, required_buffer_size);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 38.45471265740925}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    size_t buffer_size = ADC_BUFFER_SIZE(sequence);\n    size_t required_size = sequence->options->extra_samplings + 1;\n\n    if (buffer_size < required_size) {\n        LOG_ERR(\"Buffer size %d is smaller than required size %d\", buffer_size, required_size);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 40.66062476569258}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->sequence = *sequence;\n\n\terr = adc_context_start_read(dev, sequence, wait);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.72468438485862}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence_buffer = sequence->buffer;\n\n\tret = adc_context_start_read(dev, sequence, wait);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(dev);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 58.86661250868259}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->sequence_buf = sequence->buffer;\n\n\terr = adc_context_start_read(dev, sequence, wait);\n\tif (err) {\n\t\tLOG_ERR(\"Failed to start read (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (wait) {\n\t\terr = adc_context_wait_for_completion(dev);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Failed to wait for completion (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.33566099753624}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\n    const struct device *codec;\n    int result;\n\n    codec = device_get_binding(argv[1]);\n    if (!codec) {\n        shell_error(sh, \"codec device not found\");\n        return -ENODEV;\n    }\n\n    result = audio_codec_apply_properties(codec);\n    if (result) {\n        shell_error(sh, \"apply properties failed: %d\", result);\n        return result;\n    }\n\n    return 0;\n}", "CodeBleu_score": 64.34301529061392}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    int res;\n    struct device *dev;\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"device not found\");\n        return -ENODEV;\n    }\n\n    res = audio_codec_apply_properties(dev);\n    if (res) {\n        shell_error(sh, \"failed to apply properties\");\n        return res;\n    }\n\n    return 0;\n}", "CodeBleu_score": 67.22648911717005}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    int ret;\n    struct device *dev;\n    struct audio_codec_data codec_data;\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Cannot get device %s\", argv[1]);\n        return -EINVAL;\n    }\n\n    codec_data.sample_rate = atoi(argv[2]);\n    codec_data.bit_width = atoi(argv[3]);\n    codec_data.channel_num = atoi(argv[4]);\n\n    ret = audio_codec_apply_properties(dev, &codec_data);\n    if (ret) {\n        shell_error(sh, \"Failed to apply properties to device %s\", argv[1]);\n        return ret;\n    }\n\n    shell_print(sh, \"Properties applied successfully to device %s\", argv[1]);\n    return 0;\n}", "CodeBleu_score": 50.164725520757415}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_i2s_data *data = dev->data;\n    int ret;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state != STATE_CONFIGURED) {\n                LOG_ERR(\"DMIC device not configured\");\n                return -EINVAL;\n            }\n\n            ret = mpxxdtyy_i2s_send_command(dev, I2S_CMD_START);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to send I2S start command\");\n                return ret;\n            }\n\n            data->state = STATE_ACTIVE;\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state != STATE_ACTIVE) {\n                LOG_ERR(\"DMIC device not active\");\n                return -EINVAL;\n            }\n\n            ret = mpxxdtyy_i2s_send_command(dev, I2S_CMD_STOP);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to send I2S stop command\");\n                return ret;\n            }\n\n            data->state = STATE_CONFIGURED;\n            break;\n\n        default:\n            LOG_ERR(\"Invalid DMIC trigger command\");\n            return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 54.56055865475141}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_i2s_data *data = dev->data;\n    int ret;\n\n    /* Check if the device is configured */\n    if (data->state != DMIC_STATE_CONFIGURED) {\n        LOG_ERR(\"Device not configured\");\n        return -ENODEV;\n    }\n\n    /* Set the I2S command based on the trigger command */\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            ret = i2s_trigger(data->i2s, I2S_TRIGGER_START);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to trigger start\");\n                return ret;\n            }\n            data->state = DMIC_STATE_ACTIVE;\n            break;\n        case DMIC_TRIGGER_STOP:\n            ret = i2s_trigger(data->i2s, I2S_TRIGGER_STOP);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to trigger stop\");\n                return ret;\n            }\n            data->state = DMIC_STATE_CONFIGURED;\n            break;\n        default:\n            LOG_ERR(\"Invalid trigger command\");\n            return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 52.69357191047237}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_i2s_trigger_config *config = dev->config;\n    struct mpxxdtyy_i2s_trigger_data *data = dev->data;\n    int ret;\n\n    if (cmd == DMIC_TRIGGER_START) {\n        if (data->state != STATE_CONFIGURED) {\n            LOG_ERR(\"I2S trigger start command received in invalid state %d\", data->state);\n            return -EINVAL;\n        }\n\n        ret = i2s_trigger(config->i2s, config->i2s_config, I2S_DIR_RX, I2S_TRIGGER_START);\n        if (ret < 0) {\n            LOG_ERR(\"Failed to start I2S trigger: %d\", ret);\n            return ret;\n        }\n\n        data->state = STATE_ACTIVE;\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n        if (data->state != STATE_ACTIVE) {\n            LOG_ERR(\"I2S trigger stop command received in invalid state %d\", data->state);\n            return -EINVAL;\n        }\n\n        ret = i2s_trigger(config->i2s, config->i2s_config, I2S_DIR_RX, I2S_TRIGGER_STOP);\n        if (ret < 0) {\n            LOG_ERR(\"Failed to stop I2S trigger: %d\", ret);\n            return ret;\n        }\n\n        data->state = STATE_CONFIGURED;\n    } else {\n        LOG_ERR(\"Invalid I2S trigger command: %d\", cmd);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 48.599839131661085}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = config->display_mode;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 45.415710892893536}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = config->display_mode;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_ON;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CMD_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_BLINK_ON;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CMD_CURSOR_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 64.64742515125359}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 70.60339717687629}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    int ret;\n\n    if (!config->busy_port) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get_dt(&config->busy_port);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return ret;\n}", "CodeBleu_score": 71.3047567891502}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    if (!config->busy_pin) {\n        return -ENOTSUP;\n    }\n    return gpio_pin_get_dt(&config->busy_pin);\n}", "CodeBleu_score": 44.72786733068607}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (!config->busy_gpio.port) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_dt(&config->busy_gpio);\n}", "CodeBleu_score": 47.27498086380455}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write_dt(&config->i2c, buf, sizeof(buf));\n}", "CodeBleu_score": 62.34762735307938}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[AUXDISPLAY_SERLCD_SPECIAL_COMMAND_BUF_SIZE];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write_dt(&config->i2c, buf, sizeof(buf));\n}", "CodeBleu_score": 64.2395418324423}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = (uint8_t)command;\n\n\tint result = i2c_write_dt(&config->i2c, buf, sizeof(buf));\n\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn result;\n}", "CodeBleu_score": 70.35034784509719}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_data *data = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > data->size) {\n\t\tdata->status.is_invalid = true;\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data->buffer + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 64.12315787097907}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > data->size) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(data, data->mem + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 68.9554386232667}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\tsize_t available_size = data->size - offset;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > available_size) {\n\t\treturn -EFAULT;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, data->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.7927427660659}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif ((offset + size) > data->size) {\n\t\tdata->status.is_invalid = true;\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&data->data[offset], data, size);\n\treturn 0;\n}", "CodeBleu_score": 55.75905390568909}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -ENXIO;\n\t}\n\n\tmemcpy(&data->mem[offset], data, size);\n\treturn 0;\n}", "CodeBleu_score": 57.26788500602702}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&data->memory[offset], data, size);\n\treturn 0;\n}", "CodeBleu_score": 54.89835610021066}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tARG_UNUSED(sh);\n\tARG_UNUSED(argc);\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device \\\"%s\\\" not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.66501014514942}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing BBRAM device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 89.1921737218719}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst char *dev_name;\n\tint ret = -EINVAL;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name argument\");\n\t\treturn ret;\n\t}\n\n\tdev_name = argv[1];\n\n\t*bbram_dev = device_get_binding(dev_name);\n\tif (!(*bbram_dev)) {\n\t\tshell_error(sh, \"BBRAM device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 71.40629894741359}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t    size_t bytes_read;\n    size_t remaining_bytes;\n\n    bytes_read = uart_fifo_read(dev, h4_hdr, sizeof(h4_hdr));\n    if (bytes_read != sizeof(h4_hdr)) {\n        LOG_ERR(\"Failed to read header from UART device\");\n        return;\n    }\n\n    remaining_bytes = h4_hdr_get_len(h4_hdr) - bytes_read;\n    if (remaining_bytes > 0) {\n        bytes_read += uart_fifo_read(dev, &h4_hdr[bytes_read], remaining_bytes);\n        if (bytes_read != h4_hdr_get_len(h4_hdr)) {\n            LOG_ERR(\"Failed to read remaining header bytes from UART device\");\n            return;\n        }\n    }\n}", "CodeBleu_score": 36.18496060446056}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    uint8_t bytes_read = h4_uart_fifo_read(dev, h4_hdr_buf, sizeof(h4_hdr_buf));\n\n    if (bytes_read < sizeof(h4_hdr_buf)) {\n        LOG_ERR(\"Failed to read header data from UART device\");\n        return;\n    }\n\n    h4_remaining_bytes -= bytes_read;\n}", "CodeBleu_score": 22.60041044568026}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    int ret;\n    uint8_t *hdr_buf;\n    size_t hdr_len;\n    size_t hdr_bytes_read;\n    size_t remaining_bytes;\n\n    hdr_buf = h4_get_hdr_buf(dev);\n    hdr_len = h4_get_hdr_len(dev);\n    hdr_bytes_read = h4_get_hdr_bytes_read(dev);\n    remaining_bytes = hdr_len - hdr_bytes_read;\n\n    ret = uart_fifo_read(dev, hdr_buf + hdr_bytes_read, remaining_bytes);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to read header data from UART device\");\n        return;\n    }\n\n    h4_set_hdr_bytes_read(dev, hdr_bytes_read + ret);\n}", "CodeBleu_score": 37.92246326751713}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t ret;\n\n\tret = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"uart_fifo_read error %d\", ret);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 58.80029712663304}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t ret;\n\n\tret = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\tif (ret == 0) {\n\t\tLOG_ERR(\"uart_fifo_read failed\");\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 51.219857196408526}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  uint8_t buf[33];\n  int ret;\n\n  ret = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n  if (ret < 0) {\n    LOG_ERR(\"UART FIFO read error: %d\", ret);\n    return 0;\n  }\n  return ret;\n}", "CodeBleu_score": 62.89855257897592}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    int hop = -1;\n    struct zbus_observer *observer;\n\n    /* Lock the channel data */\n    chan_lock(chan);\n\n    /* Iterate through the observers */\n    list_for_each_entry(observer, &chan->observers, list) {\n        /* Check if the observer is enabled and has a higher priority */\n        if (observer->enabled && (hop == -1 || observer->priority < hop)) {\n            hop = observer->priority;\n        }\n    }\n\n    /* Set the channel's highest observer priority */\n    chan->hop = hop;\n\n    /* Unlock the channel data */\n    chan_unlock(chan);\n}", "CodeBleu_score": 14.340074749485415}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tunsigned int hop = 0;\n\tunsigned int priority = 0;\n\tunsigned int i;\n\n\tchan_lock(chan);\n\n\tfor (i = 0; i < chan->observers_size; i++) {\n\t\tif (chan->observers[i].enabled) {\n\t\t\tpriority = chan->observers[i].priority;\n\t\t\tif (priority < hop) {\n\t\t\t\thop = priority;\n\t\t\t}\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tchan_unlock(chan);\n}", "CodeBleu_score": 25.242160324148788}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    unsigned int hop = 0;\n    struct zbus_channel_data *chan_data = chan->data;\n    struct zbus_observer *obs;\n\n    /* Lock the channel data */\n    spinlock_acquire(&chan_data->lock);\n\n    /* Iterate through the observers */\n    list_for_each_entry(obs, &chan_data->observers, list) {\n        /* Check if the observer is enabled and has a higher priority than the current highest */\n        if (obs->enabled && obs->priority < hop) {\n            hop = obs->priority;\n        }\n    }\n\n    /* Set the channel's highest observer priority */\n    chan_data->hop = hop;\n\n    /* Unlock the channel data */\n    spinlock_release(&chan_data->lock);\n}", "CodeBleu_score": 17.269796412664903}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_observations_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_observations_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.880910791310768}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_observations_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_observations_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.538572295624213}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = zbus_channel_observation_end_idx;\n\n\t\tfor (int16_t i = zbus_channel_observation_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.51676482725625}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_SPINLOCK(zbus_observers_lock);\n\tK_SPINLOCK(zbus_channels_lock);\n\n\t__ASSERT(!k_is_in_isr(), \"zbus_obs_attach_to_thread() cannot be called from ISR\");\n\t__ASSERT(obs != NULL, \"zbus_obs_attach_to_thread() cannot be called with NULL observer\");\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_observers_lock);\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&zbus_observers_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 53.97329433561644}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_SPINLOCK_DEFINE(zbus_observer_lock, ZBUS_OBSERVER_LOCK_INITIAL_VALUE);\n\n\tk_spinlock_key_t key;\n\n\t__ASSERT_NO_MSG(!k_is_in_isr());\n\t__ASSERT_NO_MSG(obs != NULL);\n\n\tkey = k_spin_lock(&zbus_observer_lock);\n\tobs->priority = K_LOWEST_APPLICATION_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_observer_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 49.616447831119416}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_SPINLOCK_DEFINE(lock, 0);\n\n\tk_is_in_isr();\n\tK_ASSERT(obs != NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&lock);\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 23.180023152782645}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\tk_timepoint_t end_time;\n\tint prio;\n\n\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\tend_time = sys_timepoint_calc(timeout);\n\n\terr = chan_lock(chan, sys_timepoint_timeout(end_time), &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 49.992994973694174}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\tint prio;\n\n\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 58.51076128846315}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint prio;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 50.562569815136584}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n    uint32_t tmpreg = 0;\n    uint32_t tmp = 0;\n\n    assert_param(IS_ETH_INT(Int));\n\n    tmpreg = ETH->ETH_IER;\n\n    if (enable) {\n        if (IS_ETH_INT_ABNORMAL(Int)) {\n            ETH->ETH_IER |= Int;\n        } else {\n            ETH->ETH_IER |= Int;\n            tmp = tmpreg & ETH_IER_NORMAL_INT_EN;\n            if (tmp == 0) {\n                ETH->ETH_IER |= ETH_IER_NORMAL_INT_EN;\n            }\n        }\n    } else {\n        ETH->ETH_IER &= ~Int;\n        if (IS_ETH_INT_ABNORMAL(Int)) {\n            tmp = tmpreg & ETH_IER_ABNORMAL_INT_EN;\n            tmp &= ~Int;\n            if (tmp == 0) {\n                ETH->ETH_IER &= ~ETH_IER_ABNORMAL_INT_EN;\n            }\n        } else {\n            tmp = tmpreg & ETH_IER_NORMAL_INT_EN;\n            tmp &= ~Int;\n            if (tmp == 0) {\n                ETH->ETH_IER &= ~ETH_IER_NORMAL_INT_EN;\n            }\n        }\n    }\n}", "CodeBleu_score": 49.87068069662136}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n    uint32_t tmpreg = 0;\n\n    /* Check the parameters */\n    assert_param(IS_ETH_INT(Int));\n\n    if (enable) {\n        if (IS_ETH_INT_ABNORMAL(Int)) {\n            tmpreg = ETH->ETH_DMASR;\n            tmpreg |= Int;\n            ETH->ETH_DMASR = tmpreg;\n        } else {\n            tmpreg = ETH->ETH_MACSR;\n            tmpreg |= Int;\n            ETH->ETH_MACSR = tmpreg;\n        }\n    } else {\n        if (IS_ETH_INT_ABNORMAL(Int)) {\n            tmpreg = ETH->ETH_DMASR;\n            tmpreg &= ~Int;\n            ETH->ETH_DMASR = tmpreg;\n        } else {\n            tmpreg = ETH->ETH_MACSR;\n            tmpreg &= ~Int;\n            ETH->ETH_MACSR = tmpreg;\n        }\n    }\n}", "CodeBleu_score": 52.66653633529159}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  uint32_t tmpreg = 0;\n  uint32_t tmpint = 0;\n  uint32_t tmpval = 0;\n  uint32_t tmpabn = 0;\n  uint32_t tmpnor = 0;\n\n  /* Check the parameters */\n  assert_param(IS_ETH_INT(Int));\n\n  /* Get the ETH_CIMR register value */\n  tmpreg = ETH_ReadCIMR();\n\n  /* Get the interrupt number */\n  tmpint = Int >> 16;\n\n  /* Get the interrupt value */\n  tmpval = Int & 0x0000FFFF;\n\n  /* Get the interrupt abnormal bit */\n  tmpabn = tmpint & 0x00000001;\n\n  /* Get the interrupt normal bit */\n  tmpnor = (tmpint >> 1) & 0x00000001;\n\n  /* Clear the interrupt */\n  tmpreg &= ~tmpval;\n\n  /* Update the interrupt enable bits */\n  if (enable) {\n    /* Enable the interrupt */\n    tmpreg |= tmpval;\n\n    /* Check if the interrupt is abnormal */\n    if (tmpabn) {\n      /* Set the abnormal interrupt enable bit */\n      ETH->CIMR |= ETH_CIMR_AIM;\n    } else {\n      /* Set the normal interrupt enable bit */\n      ETH->CIMR |= ETH_CIMR_NIM;\n    }\n  } else {\n    /* Check if the interrupt is abnormal */\n    if (tmpabn) {\n      /* Clear the abnormal interrupt enable bit */\n      ETH->CIMR &= ~ETH_CIMR_AIM;\n    } else {\n      /* Clear the normal interrupt enable bit */\n      ETH->CIMR &= ~ETH_CIMR_NIM;\n    }\n  }\n\n  /* Write the updated value to the ETH_CIMR register */\n  ETH_WriteCIMR(tmpreg);\n}", "CodeBleu_score": 39.16811875566163}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t  ETH_TX_DESC *txDesc = ETH_TxDesc;\n  ETH_TX_DESC *txDescEnd = ETH_TxDesc + ETH_TX_BUF_NUM;\n\n  while (txDesc != txDescEnd) {\n    if (!(txDesc->status & ETH_TX_STATUS_OWN)) {\n      return txDesc;\n    }\n    txDesc++;\n  }\n\n  return 0;\n}", "CodeBleu_score": 29.485539018654812}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *tx_desc = ETH_GetTxDesc();\n    ETH_TX_DESC *start_tx_desc = tx_desc;\n\n    do {\n        if (!ETH_IsTxDescOwnedByDma(tx_desc)) {\n            return tx_desc;\n        }\n\n        tx_desc = ETH_GetNextTxDesc(tx_desc);\n    } while (tx_desc != start_tx_desc);\n\n    return 0;\n}", "CodeBleu_score": 43.796410402496804}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *desc = ETH_GetTxDesc();\n    if (desc->status & ETH_TX_STATUS_OWN) {\n        return 0;\n    }\n    ETH_TX_DESC *next = desc;\n    do {\n        desc = next;\n        next = desc->nextTxDescAddr;\n    } while (desc->status & ETH_TX_STATUS_OWN);\n    return desc;\n}", "CodeBleu_score": 46.69897647577601}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    Cy_CSDIDAC_OutputEnable(device->hw_dac, cyp_dac_channel, *value);\n\n    if (Cy_CSDIDAC_GetStatus(device->hw_dac, cyp_dac_channel) != CY_CSDIDAC_STATUS_OK) {\n        LOG_E(\"DAC channel %d initialization failed\", channel);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 61.51339849935873}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable failed\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 57.25848154782809}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Failed to enable DAC output\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 57.169400137097156}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    int i;\n    rt_uint32_t end_addr = addr + size;\n\n    if (end_addr > FLASH_END_ADDRESS) {\n        LOG_E(\"Invalid argument: end_addr > FLASH_END_ADDRESS\");\n        return -EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t*)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 49.03327627758822}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    int i;\n    if (addr + size > FLASH_END_ADDRESS) {\n        LOG_E(\"flash read outrange\");\n        return -RT_EINVAL;\n    }\n    for (i = 0; i < size; i++, buf++, addr++) {\n        *buf = *(rt_uint8_t *) addr;\n    }\n    return size;\n}", "CodeBleu_score": 60.8529687206159}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    int i;\n    rt_uint32_t end_addr;\n\n    if (addr + size > FLASH_END_ADDR) {\n        LOG_E(\"Flash read address out of range\");\n        return -EINVAL;\n    }\n\n    end_addr = addr + size;\n\n    for (i = 0; addr < end_addr; i++, addr++) {\n        buf[i] = *(rt_uint8_t *)addr;\n    }\n\n    return size;\n}", "CodeBleu_score": 52.088235488683864}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->priv;\n\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 20.340784888222892}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 31.751041619710936}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 31.751041619710936}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    rt_err_t result;\n\n    result = rt_mutex_take(&dfs_lock_mutex, RT_WAITING_FOREVER);\n    RT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 20.393384698859357}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.942244434243107}, {"code": "void dfs_lock(void){\n\t    rt_err_t result;\n\n    result = rt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n    RT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 15.420372501786417}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n\n    /* find an empty slot starting from the specified index */\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* try to expand the fd table */\n    if (fd_slot_expand(fdt, fdt->maxfd) == -1) {\n        return -1;\n    }\n\n    /* find an empty slot starting from the expanded index */\n    for (index = fdt->maxfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* no empty slot found */\n    return -1;\n}", "CodeBleu_score": 44.36795984439527}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n    int index;\n\n    /* Search for an empty slot starting from the specified index */\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* If no empty slot is found, attempt to expand the fd table */\n    if (fd_slot_expand(fdt, fd) >= 0) {\n        return fd;\n    }\n\n    /* If expansion fails, search for an empty slot again */\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* If no empty slot is found after expansion, return -1 */\n    return -1;\n}", "CodeBleu_score": 46.125843632152964}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n\n    /* Search for an empty slot starting from the specified index */\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* If no empty slot is found, attempt to expand the fd table */\n    if (fd_slot_expand(fdt, index) < 0) {\n        return -1;\n    }\n\n    return index;\n}", "CodeBleu_score": 43.42854957389349}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(rt_errors) / sizeof(rt_errors[0]); i++) {\n        if (rt_errors[i].err == error) {\n            return rt_errors[i].str;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 65.90674400572239}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n\n    for (size_t i = 0; i < sizeof(errors) / sizeof(errors[0]); i++) {\n        if (errors[i].code == error) {\n            return errors[i].str;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 63.54928834637824}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(rt_errors) / sizeof(rt_errors[0]); i++) {\n        if (rt_errors[i].code == error) {\n            return rt_errors[i].message;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 65.2051863561066}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_uint32_t level;\n    struct rt_thread *thread;\n    rt_uint32_t i;\n    rt_err_t result;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    thread = rt_thread_self();\n\n    for (i = 0; i < RT_THREAD_HOOK_MAX; i++) {\n        if (thread->idle_hook[i] == RT_NULL) {\n            thread->idle_hook[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    if (i == RT_THREAD_HOOK_MAX) {\n        result = -RT_EFULL;\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 56.601437158746506}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_int32_t index;\n    rt_err_t result;\n\n    /* Lock the spinlock to ensure thread safety */\n    rt_spin_lock_irqsave(&rt_thread_idle_hook_lock, &level);\n\n    /* Iterate through the idle hook list to find an empty slot */\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_MAX; index++) {\n        if (rt_thread_idle_hook[index] == RT_NULL) {\n            /* Assign the hook to the empty slot */\n            rt_thread_idle_hook[index] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* If no empty slot was found, return an error */\n    if (index == RT_THREAD_IDLE_HOOK_MAX) {\n        result = -RT_EFULL;\n    }\n\n    /* Release the spinlock */\n    rt_spin_unlock_irqrestore(&rt_thread_idle_hook_lock, level);\n\n    /* Return the result */\n    return result;\n}", "CodeBleu_score": 61.09567273502737}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_uint8_t i;\n\n    rt_spin_lock_irqsave(&rt_thread_idle_hook_lock, level);\n\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n        if (rt_thread_idle_hook[i] == RT_NULL) {\n            rt_thread_idle_hook[i] = hook;\n            rt_spin_unlock_irqrestore(&rt_thread_idle_hook_lock, level);\n            return RT_EOK;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&rt_thread_idle_hook_lock, level);\n    return -RT_EFULL;\n}", "CodeBleu_score": 59.35201255254277}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n\n    rt_spin_lock_irqsave(&rt_thread_idle_hook_lock, &level);\n\n    for (int i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n        if (rt_thread_idle_hook[i] == hook) {\n            rt_thread_idle_hook[i] = NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    if (result != RT_EOK) {\n        result = -RT_ERROR;\n    }\n\n    rt_spin_unlock_irqrestore(&rt_thread_idle_hook_lock, level);\n\n    return result;\n}", "CodeBleu_score": 61.45578926976463}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_list_t *node;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    rt_spin_lock_irqsave(&idle_lock, &level);\n    node = rt_list_find(&idle_list, (void *)hook);\n    if (node != RT_NULL) {\n        rt_list_remove(&idle_list, node);\n    } else {\n        result = -RT_ERROR;\n    }\n    rt_spin_unlock_irqrestore(&idle_lock, level);\n\n    return result;\n}", "CodeBleu_score": 30.092076360116003}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_list_t *node;\n    rt_uint8_t result = RT_ERROR;\n\n    /* Lock the spinlock to ensure thread safety */\n    rt_spin_lock_irqsave(&idle_hook_lock, flags);\n\n    /* Iterate through the idle hook list */\n    for (node = idle_hook_list.next; node != &idle_hook_list; node = node->next) {\n        /* Check if the current node contains the specified hook */\n        if (node->owner == hook) {\n            /* Set the corresponding entry to null */\n            node->owner = RT_NULL;\n            /* Set the result to success */\n            result = RT_EOK;\n            /* Break out of the loop */\n            break;\n        }\n    }\n\n    /* Unlock the spinlock */\n    rt_spin_unlock_irqrestore(&idle_hook_lock, flags);\n\n    /* Return the result */\n    return result;\n}", "CodeBleu_score": 51.38440814874876}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_base_t level;\n    rt_thread_t thread;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* dequeue suspended thread and resume it */\n    while ((thread = rt_list_entry(rt_list_get_first(susp_list),\n                                  struct rt_thread,\n                                  tlist)) != RT_NULL) {\n        rt_thread_resume(thread);\n        rt_list_remove(&(thread->tlist));\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 30.890055755791245}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_base_t level;\n    rt_thread_t thread;\n\n    level = rt_hw_interrupt_disable();\n\n    while (!rt_list_isempty(susp_list)) {\n        thread = rt_list_entry(rt_list_get_first(susp_list), struct rt_thread, tlist);\n        rt_thread_resume(thread, thread_error);\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 40.560326007343484}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_err_t result = RT_EOK;\n    rt_thread_t thread = NULL;\n\n    /* Ensure the scheduler is unlocked */\n    rt_enter_critical();\n\n    /* Dequeue and resume each suspended thread from the list */\n    while (rt_list_length(susp_list) > 0) {\n        thread = rt_susp_list_dequeue(susp_list);\n        if (thread != RT_NULL) {\n            rt_thread_resume(thread);\n        } else {\n            result = RT_ERROR;\n            break;\n        }\n    }\n\n    /* Release the scheduler lock */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 32.03896153817968}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t device;\n    rt_device_t old_console = rt_console_get_device();\n\n    if (rt_strcmp(name, RT_CONSOLE_DEVICE_NAME) == 0) {\n        return old_console;\n    }\n\n    device = rt_device_find(name);\n    if (device == RT_NULL) {\n        return old_console;\n    }\n\n    if (device == old_console) {\n        return old_console;\n    }\n\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    rt_console_set_device(device);\n\n    return old_console;\n}", "CodeBleu_score": 56.77438061606944}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = rt_console;\n\n    if (rt_strcmp(name, RT_CONSOLE_DEVICE_NAME) == 0) {\n        rt_console = RT_NULL;\n    } else {\n        rt_device_t new_console = rt_device_find(name);\n        if (new_console != RT_NULL) {\n            if (new_console != old_console) {\n                if (old_console != RT_NULL) {\n                    rt_device_close(old_console);\n                }\n                rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n                rt_console = new_console;\n            }\n        }\n    }\n\n    return old_console;\n}", "CodeBleu_score": 59.777033901341255}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device = rt_console;\n    rt_device_t new_device = rt_device_find(name);\n    if (new_device != old_device) {\n        if (old_device != RT_NULL) {\n            rt_device_close(old_device);\n        }\n        if (new_device != RT_NULL) {\n            rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        }\n        rt_console = new_device;\n    }\n    return old_device;\n}", "CodeBleu_score": 64.90905736723805}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *info;\n\n    // Retrieve information about the object class type\n    info = rt_object_get_information(type);\n\n    // Lock the corresponding spinlock to ensure thread safety\n    rt_spin_lock_irqsave(&info->lock, flags);\n\n    // Iterate through the object list, counting the number of objects\n    rt_list_for_each(pos, &info->list) {\n        count++;\n    }\n\n    // Release the spinlock\n    rt_spin_unlock_irqrestore(&info->lock, flags);\n\n    return count;\n}", "CodeBleu_score": 39.14696178972338}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *info;\n    unsigned long flags;\n\n    info = rt_object_get_information(type);\n    if (!info) {\n        return -1;\n    }\n\n    rt_spin_lock_irqsave(&info->lock, flags);\n    rt_list_for_each(pos, &info->list) {\n        count++;\n    }\n    rt_spin_unlock_irqrestore(&info->lock, flags);\n\n    return count;\n}", "CodeBleu_score": 42.90853798713156}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *info;\n    unsigned long flags;\n\n    /* Get information about the object class type */\n    info = rt_object_get_information(type);\n    if (!info) {\n        return -1;\n    }\n\n    /* Lock the spinlock to ensure thread safety */\n    rt_spin_lock_irqsave(&info->lock, flags);\n\n    /* Iterate through the object list, counting the number of objects */\n    rt_list_for_each(node, &info->list) {\n        count++;\n    }\n\n    /* Release the spinlock */\n    rt_spin_unlock_irqrestore(&info->lock, flags);\n\n    return count;\n}", "CodeBleu_score": 43.191905693710886}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    RT_ASSERT(object != RT_NULL);\n\n    // Call the hook function for detachment\n    RT_OBJECT_HOOK_CALL(detach, object);\n\n    // Get the object's information structure\n    struct rt_object_information *information = object->information;\n\n    // Lock the object's spinlock to ensure thread safety\n    rt_spin_lock_irqsave(&information->lock, flag);\n\n    // Remove the object from its list\n    rt_list_remove(&information->object_list, &object->list);\n\n    // Unlock the object's spinlock\n    rt_spin_unlock_irqrestore(&information->lock, flag);\n\n    // Set the object's type to zero\n    object->type = 0;\n}", "CodeBleu_score": 43.065473301011025}, {"code": "void rt_object_detach(rt_object_t object){\n\t    RT_ASSERT(object != RT_NULL);\n\n    rt_object_information_t info = (rt_object_information_t)object;\n\n    /* call object detach hook */\n    RT_OBJECT_HOOK_CALL(detach, object);\n\n    /* lock object */\n    rt_spinlock_t *lock = &info->lock;\n    rt_spin_lock_irqsave(lock, &lock_flag);\n\n    /* remove from list */\n    rt_list_remove(&info->list);\n\n    /* unlock */\n    rt_spin_unlock_irqrestore(lock, &lock_flag);\n\n    /* set object type to zero */\n    info->type = 0;\n}", "CodeBleu_score": 38.43054567709184}, {"code": "void rt_object_detach(rt_object_t object){\n\t    RT_ASSERT(object != RT_NULL);\n    /* call object detach hook */\n    RT_OBJECT_HOOK_CALL(detach, object);\n    /* get object information */\n    struct rt_object_information *information = object->information;\n    /* lock object */\n    rt_spin_lock_irqsave(&information->object.lock, cpufreq);\n    /* remove object */\n    rt_list_remove(&information->object.list);\n    /* unlock object */\n    rt_spin_unlock_irqrestore(&information->object.lock);\n    /* set object type */\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 40.53326819934272}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n    rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n\n    /* Check if the object is valid and of the custom object class type */\n    if (custom_obj == RT_NULL || custom_obj->type != RT_Object_Class_Custom) {\n        return -RT_ERROR;\n    }\n\n    /* Check if the object has a destroy method */\n    if (custom_obj->destroy != RT_NULL) {\n        result = custom_obj->destroy(custom_obj);\n    }\n\n    /* Delete the object */\n    rt_object_delete(custom_obj);\n\n    return result;\n}", "CodeBleu_score": 49.6669257958648}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n    /* get information */\n    struct rt_object_information *information = rt_object_get_information((enum rt_object_class_type)obj->type);\n    RT_ASSERT(information != RT_NULL);\n\n    /* call destroy method if available */\n    if (information->destroy != RT_NULL) {\n        result = information->destroy(obj);\n    }\n\n    /* delete object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 48.10199942324005}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n    /* get object information */\n    struct rt_object_information *information = rt_object_get_information((enum rt_object_class_type)obj->type);\n    RT_ASSERT(information != RT_NULL);\n\n    /* check if the object has a destroy method */\n    if (information->destroy != RT_NULL) {\n        /* call the destroy method */\n        result = information->destroy(obj);\n    }\n\n    /* delete the object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 48.10199942324005}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    rt_sched_lock_level_t slvl;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add thread to defunct list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* exit critical section */\n    rt_exit_critical_safe();\n\n    /* trigger context switch */\n    rt_schedule();\n}", "CodeBleu_score": 66.85963098868906}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread = rt_thread_self();\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close the thread */\n    rt_thread_close(thread);\n\n    /* add the thread to the defunct list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* exit critical section safely */\n    rt_exit_critical_safe();\n\n    /* trigger a context switch */\n    rt_schedule();\n}", "CodeBleu_score": 59.35594029011513}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add thread to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* exit critical section */\n    rt_exit_critical_safe();\n\n    /* trigger context switch */\n    rt_schedule();\n}", "CodeBleu_score": 64.76145226418797}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (struct rt_thread *)parameter;\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n    rt_sched_lock();\n    rt_sched_thread_is_suspended(thread);\n    thread->error = -RT_ETIMEOUT;\n    rt_list_remove(&(thread->list));\n    rt_sched_insert_thread(thread, &RT_THREAD_LIST_NODE(thread));\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 58.02141688696929}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread;\n\n    thread = (rt_thread_t)parameter;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n    rt_sched_lock();\n    thread->error = -RT_ETIMEOUT;\n    rt_list_remove(&(thread->tlist));\n    rt_sched_insert_thread(thread);\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 44.43416307401202}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread;\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (rt_thread_t)parameter;\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n    RT_ASSERT(thread->timeout_func != RT_NULL);\n    RT_ASSERT(thread->timeout_value != 0);\n    rt_sched_lock();\n    rt_list_remove(&(thread->list));\n    thread->stat = RT_THREAD_READY;\n    thread->error = -RT_ERROR;\n    thread->timeout_value = 0;\n    thread->timeout_func = RT_NULL;\n    rt_sched_insert_thread(thread);\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 49.642099194329816}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_uint8_t level;\n\n    level = rt_hw_interrupt_disable();\n    if (thread->wait_object) {\n        if (thread->wait_object->type == RT_Object_Class_Mutex) {\n            rt_mutex_t mutex = (rt_mutex_t)thread->wait_object;\n            rt_list_remove(&(mutex->wait_list), &(thread->tlist));\n            thread->wait_object = RT_NULL;\n            rt_mutex_release(mutex);\n        }\n    }\n    rt_mutex_drop_thread(thread);\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 31.516220763486935}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_mutex_t mutex;\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n    rt_spinlock_take(&thread->lock);\n\n    mutex = thread->pending;\n    if (mutex != RT_NULL) {\n        rt_mutex_release(mutex);\n    }\n\n    thread->pending = RT_NULL;\n\n    rt_spinlock_release(&thread->lock);\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 29.050177536858378}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_spinlock_t *spin = &thread->lock;\n    rt_mutex_t mutex;\n\n    rt_spin_lock_irqsave(spin, &thread->lock_level);\n\n    if (thread->pending_mutex) {\n        mutex = thread->pending_mutex;\n        rt_list_remove(&thread->list);\n        thread->pending_mutex = RT_NULL;\n\n        rt_mutex_release(mutex);\n    }\n\n    rt_spin_unlock_irqrestore(spin, thread->lock_level);\n}", "CodeBleu_score": 34.08041187067866}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n\n    /* Check if the thread is not null, is in the initialization state, and is of the correct type */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n    RT_ASSERT(thread->current_priority == -1);\n\n    /* Log the thread's name and priority */\n    LOG_D(\"thread startup: %s, priority: %d\", thread->parent.name, thread->init_priority);\n\n    /* Calculate the thread's priority attributes */\n    thread->current_priority = thread->init_priority;\n    thread->number_mask = (1 << thread->current_priority);\n    thread->priority_bitmap = (1 << thread->current_priority);\n\n    /* Reset the thread's state to suspended */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* Resume the thread and trigger a scheduler if available */\n    result = rt_thread_resume(thread);\n\n    /* Return RT_EOK upon successful startup */\n    return result;\n}", "CodeBleu_score": 47.9631269050675}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_ready(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.31186223905877}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* set thread priority */\n    thread->stat = RT_THREAD_SUSPEND;\n    thread->priority = RT_THREAD_PRIORITY_MAX - 1;\n    thread->init_priority = thread->priority;\n    thread->number_mask = 1 << thread->priority;\n    thread->error = RT_EOK;\n\n    /* resume thread */\n    result = rt_thread_resume(thread);\n\n    return result;\n}", "CodeBleu_score": 61.010478908451034}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list;\n    rt_timer_t *timer;\n    rt_base_t level;\n\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    for (level = TIMER_SKIP_LIST_MAX_LEVEL - 1; level >= 0; level--) {\n        list = &timer_list[level];\n        if (!rt_list_isempty(list)) {\n            timer = rt_list_entry(list->next, struct rt_timer, list[level]);\n            *timeout_tick = timer->timeout;\n            return RT_EOK;\n        }\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 43.75551603121342}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list;\n    rt_timer_t *timer;\n\n    list = &timer_list[0];\n    if (rt_list_isempty(list)) {\n        return -RT_ERROR;\n    }\n\n    timer = rt_list_entry(list->next, struct rt_timer, list);\n    *timeout_tick = timer->timeout;\n\n    return RT_EOK;\n}", "CodeBleu_score": 39.718192635120445}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *head = &timer_list[0];\n    rt_list_t *lnode;\n    struct rt_timer *timer;\n    if (rt_list_isempty(head)) {\n        return -RT_ETIMEOUT;\n    }\n    lnode = rt_list_first(head);\n    timer = rt_list_entry(lnode, struct rt_timer, list);\n    *timeout_tick = timer->timeout_tick;\n    return RT_EOK;\n}", "CodeBleu_score": 55.68154193959817}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate memory for timer */\n    timer = (rt_timer_t)rt_object_allocate(sizeof(struct rt_timer),\n                                           typeof(*timer));\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* set timer name */\n    rt_object_init((rt_object_t)timer, name, RT_Object_Class_Timer);\n\n    return timer;\n}", "CodeBleu_score": 68.41784776758006}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    /* allocate memory for timer object */\n    timer = (rt_timer_t)rt_object_allocate(sizeof(struct rt_timer),\n                                           RT_Object_Class_Timer);\n    if (timer != RT_NULL)\n    {\n        /* initialize timer */\n        _timer_init(timer, timeout, parameter, time, flag);\n\n        /* set the timer name */\n        rt_object_set_name((rt_object_t)timer, name);\n    }\n\n    return timer;\n}", "CodeBleu_score": 61.23196258317115}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate memory for the timer object */\n    timer = (rt_timer_t)rt_object_allocate(&(rt_timer_class),\n                                          sizeof(struct rt_timer));\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* set the timer name */\n    rt_object_set_name((rt_object_t)timer, name);\n\n    return timer;\n}", "CodeBleu_score": 66.19479433089933}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 76.62963690977166}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\thandler := a.router\n\thandler.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 70.46630417359714}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 74.78282146881165}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := Asset(strings.TrimPrefix(req.URL.Path, \"/assets/\"))\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch {\n\tcase strings.HasSuffix(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.HasSuffix(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 56.14707316741254}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.Asset(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.HasSuffix(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase strings.HasSuffix(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\tres.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 56.676681047903074}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.Asset(req.URL.Path[1:])\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.HasSuffix(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase strings.HasSuffix(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 56.33318605515727}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(JSONRobot{\n\t\t\tName: robotName,\n\t\t\tConnections: []json.RawMessage{\n\t\t\t\t[]byte(`{\"error\":\"json-robot with name \"` + robotName + `\" not found\"}`),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\tconnections := []json.RawMessage{}\n\trobot.Connections().Each(func(connection gpio.DigitalReader) {\n\t\tconnections = append(connections, []byte(connection.Name()))\n\t})\n\tjson.NewEncoder(res).Encode(JSONRobot{\n\t\tName:        robotName,\n\t\tConnections: connections,\n\t})\n}", "CodeBleu_score": 49.74510066893752}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\trobot := a.master.FindRobot(robotName)\n\tif robot != nil {\n\t\tconnections := robot.Connections()\n\t\ta.writeJSON(res, connections)\n\t\treturn\n\t}\n\ta.writeJSON(res, JSON{\n\t\t\"error\": fmt.Sprintf(\"Robot %s not found\", robotName),\n\t})\n}", "CodeBleu_score": 28.432051436038325}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(JSON{\n\t\t\t\"error\": fmt.Sprintf(\"Robot with name %q not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tvar connections []JSON\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, JSON{\n\t\t\t\"name\":    connection.Name(),\n\t\t\t\"adaptor\": connection.GetAdaptor().Name(),\n\t\t})\n\t})\n\n\tjson.NewEncoder(res).Encode(JSON{\n\t\t\"robot\":      robotName,\n\t\t\"connections\": connections,\n\t})\n}", "CodeBleu_score": 46.59825213310723}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || user != username || pass != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the authentication is successful,\n\t\t// you can proceed with the next handler or middleware.\n\t}\n}", "CodeBleu_score": 54.2265934787457}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\treqUsername, reqPassword, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(username, reqUsername) || !secureCompare(password, reqPassword) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 55.74580565306477}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\treqUsername, reqPassword, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(username, reqUsername) || !secureCompare(password, reqPassword) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Please enter your username and password for this site\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Your handler logic here\n\t}\n}", "CodeBleu_score": 53.044232392480374}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation\n\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\t// Define the scaling function\n\tscale := func(input float64) (value int) {\n\t\t// Apply the scaling transformation\n\t\tvalue = int(slope*input + intercept)\n\n\t\t// Ensure the output is clamped within the target range\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn\n\t}\n\n\treturn scale\n}", "CodeBleu_score": 58.53699791399543}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.63205197792933}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.63205197792933}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"AnalogSensor has no valid connection\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.rawValue = raw\n\ta.scaledValue = float64(raw) * a.sensorCfg.scale\n\n\treturn raw, a.scaledValue, nil\n}", "CodeBleu_score": 50.06055677544437}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor has been removed\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastValue = float64(raw) * a.sensorCfg.scale\n\n\treturn raw, a.lastValue, nil\n}", "CodeBleu_score": 54.550318593583214}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor has been removed\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastValue = float64(raw) * a.sensorCfg.scale\n\n\treturn raw, a.lastValue, nil\n}", "CodeBleu_score": 54.550318593583214}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\toutput := m * float64(input) + n\n\t\tif output < toMin {\n\t\t\toutput = toMin\n\t\t} else if output > toMax {\n\t\t\toutput = toMax\n\t\t}\n\t\treturn output\n\t}\n}", "CodeBleu_score": 66.77561240861553}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\treturn func(input int) float64 {\n\t\tscaled := m * float64(input) + n\n\t\tif scaled < toMin {\n\t\t\treturn toMin\n\t\t} else if scaled > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn scaled\n\t}\n}", "CodeBleu_score": 72.35749307972539}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 51.0428035413939}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, 1*time.Second, opts...)\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(Vibration)\n\n\tgobot.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tgobot.Publish(d.Event(Vibration), nil)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t}\n}", "CodeBleu_score": 53.02094341500565}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, 1*time.Second, opts...)\n\td.SetName(GroveName)\n\td.AddEvent(Vibration)\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t}\n}", "CodeBleu_score": 55.20209328787895}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 10*time.Millisecond, 0, 1000, opts...),\n\t\tEventer:           gobot.NewEventer(),\n\t}\n\n\td.AddEvent(Vibration)\n\n\tgobot.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\td.DefaultName = GrovePiezoVibrationSensor\n\n\treturn d\n}", "CodeBleu_score": 53.78698410039131}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := int(1000000 / hz)\n\ttempo := float64(60) / d.bpm\n\n\td.On()\n\ttime.Sleep(time.Duration(period/2) * time.Microsecond)\n\td.Off()\n\ttime.Sleep(time.Duration(period/2) * time.Microsecond)\n\n\tfor i := 0; i < int(duration/tempo); i++ {\n\t\td.On()\n\t\ttime.Sleep(time.Duration(period/2) * time.Microsecond)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(period/2) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 33.71556465136049}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\ttonePeriod := int(1000000 / hz)\n\ttempo := int(60 / d.bpm * 1000000)\n\n\td.On()\n\n\tfor i := 0; i < int(duration*1000000); i += tempo {\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Microsecond)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Microsecond)\n\t\td.On()\n\t}\n\n\td.Off()\n\n\treturn nil\n}", "CodeBleu_score": 40.42242742339397}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\ttonePeriod := int(1000000.0 / hz)\n\ttempo := int(600000.0 / d.bpm)\n\n\td.On()\n\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\td.Off()\n\n\tcount := 0\n\tfor count < int(duration/1000.0/float64(tempo)/60.0) {\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\t\td.On()\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\t\td.Off()\n\t\tcount++\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 34.125718079809175}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.675466392120484}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.77240270918952}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.675466392120484}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Must initialize analog pins before use\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, id, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = sys.NewAnalogPin(path, id)\n\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 53.734099601531895}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Analog pins not initialized\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, pin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = sys.NewAnalogPin(path, pin)\n\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 54.43269073203918}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"must call AnalogPinsAdaptor.Connect() first\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, dir, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := sys.NewAnalogPin(path, dir)\n\tif err := p.Export(); err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 50.043763893119106}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = pin.Write(int(val))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 75.76544266376033}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := system.WithPinDirectionOutput(id, a.digitalPins, a.i2cPins)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 78.81993179483185}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 80.31323129026404}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins available\")\n\t}\n\n\topts = append(a.digitalPinOptions, opts...)\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := a.initialize(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t} else {\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 64.45389503344215}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins available\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\tif err := a.initialize(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins[id] = pin\n\t}\n\n\tpin.ApplyOptions(opts...)\n\n\treturn pin, nil\n}", "CodeBleu_score": 57.76576766614557}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"%s: no pins to digitalPin\", a.Name())\n\t}\n\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tsysPin, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.sys.NewDigitalPin(sysPin.chip, sysPin.line)\n\t\tif err := a.initialize(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins[id] = pin\n\t}\n\n\tpin.ApplyOptions(opts...)\n\n\treturn pin, nil\n}", "CodeBleu_score": 57.54105955064627}]}
