{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  // Get the list of required files from the server\n  auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n  // Check if each file exists locally\n  for (const auto &file : files) {\n    // Check if the file exists\n    if (FileTransfer::FileExists(file)) {\n      // Log that the file is found in the cache\n      log_info(\"File found in cache: \" + file);\n    } else {\n      // Request the file\n      if (download) {\n        log_info(\"Requesting file: \" + file);\n        RequestFile(file);\n      } else {\n        log_info(\"File not found in cache: \" + file);\n      }\n    }\n  }\n\n  // Return the list of required files\n  return files;\n}", "CodeBleu_score": 64.00688705128775}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n        for (const auto &file : required_files) {\n            // Check if the file exists locally\n            if (!FileTransfer::FileExists(file)) {\n                // If the file does not exist, request it and log the download action\n                _pimpl->Call(\"request_file\", file);\n                log_info(\"Downloading file {}\", file);\n            } else {\n                // If the file exists, log that it is found in the cache\n                log_info(\"File {} found in cache\", file);\n            }\n        }\n    }\n\n    // Return the list of required files\n    return required_files;\n}", "CodeBleu_score": 64.44341547509681}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  // Retrieve the list of required files from the server\n  auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n  if (download) {\n    for (const auto &file : files) {\n      // Check if the file exists locally\n      if (FileTransfer::FileExists(file)) {\n        log_info(\"File found in cache: \" + file);\n      } else {\n        // Request the file from the server\n        RequestFile(file);\n        log_info(\"Downloaded file: \" + file);\n      }\n    }\n  }\n\n  return files;\n}", "CodeBleu_score": 65.22946211547291}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  rpc::Actor actor;\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.MakeSafeUnitVector().z != 0.0f) {\n      _pimpl->GetEpisode().GetInstance().LogWarning(\n          \"Attachment type SpringArm or SpringArmGhost requires a valid transform. \"\n          \"The translation component of the transform must be zero in the z axis.\");\n    }\n  }\n  actor = _pimpl->CallAndWait<rpc::Actor>(\n      \"spawn_actor_with_parent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n  return actor;\n}", "CodeBleu_score": 53.45407878552373}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f && transform.location.z != 0.0f) {\n      // Issue a warning\n      _pimpl->GetEpisode().GetLogger()->warn(\n          \"Actor {} with attachment type {} has ill-formed transformation: {}\",\n          description.id,\n          static_cast<int>(attachment_type),\n          transform.location.z);\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process\n  return _pimpl->CallAndWait<rpc::Actor>(\n      _pimpl->GetEpisode().GetActorRegistry().GetActorSpawnFunction(description, transform, parent, attachment_type, socket_name));\n}", "CodeBleu_score": 48.316325645454086}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f && transform.location.z != 0.0f) {\n      auto warn_msg =\n          \"The translation of the transform is only in the 'z' axis. \"\n          \"This may cause ill-formed transformation. \"\n          \"Please check the transform.\";\n      _pimpl->GetEpisode().GetWorld().GetLogger().warn(warn_msg);\n    }\n  }\n  return _pimpl->CallAndWait<rpc::Actor>(\n      \"spawn_actor_with_parent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 54.755676669061046}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = _pimpl->rpc_client.call(\"Client::SubscribeToGBuffer\", ActorId, GBufferId).as<rpc::Token>();\n  auto token_data = token.GetData();\n  std::vector<unsigned char> token_data_vector(token_data.size());\n  std::memcpy(token_data_vector.data(), token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(token_data_vector, [this, callback](Buffer buffer) {\n    callback(std::move(buffer));\n  });\n}", "CodeBleu_score": 54.51640996710411}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t   auto token = _pimpl->rpc_client.GetGBuffer(ActorId, GBufferId);\n   auto token_data = token.GetData();\n   std::vector<unsigned char> token_data_vec(token_data.size());\n   std::memcpy(token_data_vec.data(), token_data.data(), token_data.size());\n   _pimpl->streaming_client.Subscribe(token_data_vec, [callback](const std::vector<unsigned char>& data) {\n      Buffer buffer;\n      buffer.data = data;\n      callback(buffer);\n   });\n}", "CodeBleu_score": 53.05690232090097}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = _pimpl->CallAndWait<std::vector<unsigned char>>(\n      \"simulator.get_token_for_gbuffer\", ActorId, GBufferId);\n  std::vector<unsigned char> token_data(token.size());\n  std::memcpy(token_data.data(), token.data(), token.size());\n  _pimpl->streaming_client.Subscribe(token_data,\n                                     [this, callback](Buffer buffer) {\n                                       callback(std::move(buffer));\n                                     });\n}", "CodeBleu_score": 58.65891799514923}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    // Check if the navigation object is null\n    if (!_walker_navigation) {\n        // Create a new WalkerNavigation instance\n        auto navigation = std::make_shared<WalkerNavigation>();\n        // Attempt to set the navigation object\n        if (!_walker_navigation.compare_exchange(nullptr, navigation)) {\n            // Another thread set the navigation object, so return it\n            navigation = _walker_navigation;\n        }\n    }\n    // Return the existing or newly created WalkerNavigation object\n    return _walker_navigation;\n}", "CodeBleu_score": 43.80026013254956}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  // Check if the navigation object is null\n  if (auto navigation = _walker_navigation.load(); navigation == nullptr) {\n    // Create a new WalkerNavigation instance\n    auto new_navigation = std::make_shared<WalkerNavigation>();\n    // Attempt to set the new navigation object\n    if (!_walker_navigation.compare_exchange_strong(navigation, new_navigation)) {\n      // If the compare_exchange_strong operation fails, another thread has set the navigation object, so return the existing object\n      return _walker_navigation.load();\n    }\n    // If the compare_exchange_strong operation succeeds, the new navigation object has been set, so return it\n    return new_navigation;\n  }\n  // If the navigation object is not null, return it\n  return _walker_navigation.load();\n}", "CodeBleu_score": 50.18756629501031}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (!_walker_navigation) {\n    auto nav = std::make_shared<WalkerNavigation>();\n    while (!_walker_navigation.compare_exchange_weak(\n        nullptr, nav, std::memory_order_release, std::memory_order_relaxed)) {\n      // expected was nullptr, so loop until it's set\n    }\n  }\n  return _walker_navigation;\n}", "CodeBleu_score": 41.35842990635719}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    std::this_thread::yield();\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(\n            std::chrono::system_clock::now() - start) > timeout.to_chrono()) {\n      return false;\n    }\n  }\n  episode.GetState()->GetTrafficManager().Tick();\n  return true;\n}", "CodeBleu_score": 49.28037509423431}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    std::this_thread::yield();\n    if (std::chrono::system_clock::now() - start > timeout.to_chrono()) {\n      return false;\n    }\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 42.49086206610648}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    std::this_thread::yield();\n    if (timeout.to_chrono() < std::chrono::system_clock::now() - start) {\n      return false;\n    }\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 42.18576183363905}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    _episode = std::make_unique<Episode>(\n        _client.LoadEpisode(map_name, reset_settings, map_layers).GetId(),\n        shared_from_this());\n\n    uint32_t timeout_ms = _client.GetTimeout().milliseconds();\n    uint32_t sleep_time_ms = std::min(timeout_ms, 10u);\n    uint32_t elapsed_time_ms = 0;\n    uint32_t previous_episode_id = _episode->GetId();\n\n    while (elapsed_time_ms < timeout_ms) {\n      std::this_thread::sleep_for(std::chrono::milliseconds(sleep_time_ms));\n      elapsed_time_ms += sleep_time_ms;\n      uint32_t current_episode_id = _client.GetEpisodeSettings().GetId();\n      if (current_episode_id != previous_episode_id) {\n        break;\n      }\n    }\n\n    if (elapsed_time_ms >= timeout_ms) {\n      throw_exception(std::runtime_error(\n          \"Timeout while waiting for episode to load.\"));\n    }\n\n    return GetCurrentEpisode();\n  }", "CodeBleu_score": 49.72666270345041}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // Load episode with the specified map name, reset settings, and map layers\n  _episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to be ready\n  GetReadyCurrentEpisode();\n\n  // Return the episode object\n  return EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 17.78149024779343}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // Create a new episode with the specified map name, reset settings, and map layers\n  _episode = std::make_unique<Episode>(map_name, reset_settings, map_layers);\n\n  // Connect to the new episode\n  bool connected = false;\n  for (int i = 0; i < _client.GetTimeout().milliseconds() / 100; ++i) {\n    // Get the current episode ID\n    uint32_t episode_id = GetCurrentEpisode().GetId();\n\n    // Send a tick cue to the new episode\n    _client.SendTickCue(episode_id);\n\n    // Wait for the episode to be ready\n    _episode->WaitForState(Episode::State::Ready);\n\n    // Check if the episode ID has changed\n    if (episode_id != GetCurrentEpisode().GetId()) {\n      connected = true;\n      break;\n    }\n\n    // Sleep for 100 milliseconds before retrying\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n\n  // If the episode was not successfully loaded, throw a runtime exception\n  if (!connected) {\n    throw std::runtime_error(\"Failed to connect to the new episode\");\n  }\n\n  // Return the episode object\n  return EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 50.57424492870395}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  WalkerPtr walker = GetWalker(controller.GetId());\n  if (!walker) {\n    throw std::runtime_error(\"Walker with id \" + std::to_string(controller.GetId()) + \" not found\");\n  }\n  DEBUG_ASSERT(episode != nullptr);\n  if (!nav) {\n    nav = episode->CreateNavigationIfMissing();\n  }\n  nav->RegisterWalker(walker);\n  controller.GetParent().RegisterController(controller);\n}", "CodeBleu_score": 57.678815873048485}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    // Get the walker associated with the controller\n    Walker *walker = _episode->GetWalker(controller.GetId());\n    // Throw an exception if the walker is not found\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Walker with ID \" + std::to_string(controller.GetId()) + \" not found.\");\n    }\n    // Assert that the episode is not null\n    DEBUG_ASSERT(_episode != nullptr);\n    // Create navigation if it is missing\n    if (!_episode->CreateNavigationIfMissing()) {\n        throw std::runtime_error(\"Failed to create navigation.\");\n    }\n    // Register the walker with the controller's ID\n    nav->RegisterWalker(walker, controller.GetId());\n}", "CodeBleu_score": 62.13805766023286}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    WalkerPtr walker = _episode->GetWalker(controller.GetId());\n    if (!walker) {\n        throw std::runtime_error(\n            \"No walker with id \" + std::to_string(controller.GetId()) + \" was found in the episode\");\n    }\n    ASSERT(_episode);\n    if (!_episode->CreateNavigationIfMissing()) {\n        throw std::runtime_error(\"Failed to create navigation\");\n    }\n    nav->RegisterWalker(walker, controller.GetId());\n}", "CodeBleu_score": 51.11243349500221}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto actor = std::make_shared<Actor>(blueprint, transform, parent, attachment_type, socket_name);\n  GetCurrentEpisode().RegisterActor(actor);\n  actor->SetGarbageCollectionPolicy(gc);\n  log_debug(\"Spawned actor: \" + actor->GetDisplayId());\n  return actor;\n}", "CodeBleu_score": 29.701505719313054}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n    auto actor = blueprint.MakeActor(\n        transform,\n        parent,\n        attachment_type,\n        socket_name);\n\n    if (gc == GarbageCollectionPolicy::Never) {\n      actor->SetAutomaticEmptyTriggerDistance(false);\n    }\n\n    _episode->RegisterActor(actor);\n    actor->SetEpisode(GetCurrentEpisode());\n\n    if (parent != nullptr) {\n      actor->SetParent(*parent);\n    }\n\n    log_debug(\n        \"ActorFactory created actor:\",\n        actor->GetDisplayId(),\n        \"with parent\",\n        parent != nullptr ? parent->GetDisplayId() : \"nullptr\");\n\n    return actor;\n  }", "CodeBleu_score": 44.361780193791844}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    auto actor = blueprint.MakeActorDescription(transform);\n    if (parent != nullptr) {\n      actor.parent = parent->GetId();\n      actor.attachment_type = attachment_type;\n      actor.socket_name = socket_name;\n    }\n    actor.gc = gc;\n    GetCurrentEpisode().RegisterActor(actor);\n    _client.SpawnActor(actor);\n    log_debug(\"Spawned actor: \" + actor.id);\n    return GetActorById(actor.id);\n  }", "CodeBleu_score": 42.77051434584948}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(_episode.get() != nullptr);\n\n  auto stream_token = sensor.GetActorDescription().GetStreamToken();\n  _client.SubscribeToStream(\n      stream_token,\n      [weak_episode = std::weak_ptr<EpisodeProxy>{_episode},\n       weak_callback = std::weak_ptr<std::function<void(SharedPtr<sensor::SensorData>)>>{\n           std::make_shared<std::function<void(SharedPtr<sensor::SensorData>)>>(callback)},\n       weak_sensor = std::weak_ptr<Sensor>{sensor.shared_from_this()}](Buffer buffer) {\n        auto episode = weak_episode.lock();\n        auto callback = weak_callback.lock();\n        auto sensor = weak_sensor.lock();\n        if (episode == nullptr || callback == nullptr || sensor == nullptr) {\n          return;\n        }\n        auto data = sensor::Deserializer::Deserialize(*sensor, std::move(buffer));\n        if (data != nullptr) {\n          data->SetEpisode(*episode);\n          (*callback)(data);\n        }\n      });\n}", "CodeBleu_score": 48.947944468121015}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (episode.expired()) {\n    throw std::runtime_error(\"This simulator has no episode\");\n  }\n  auto ep = episode.lock();\n\n  auto cb = [=](Buffer &&data) {\n    auto sensor_data = sensor::Deserializer::Deserialize(std::move(data));\n    if (sensor_data != nullptr) {\n      sensor_data->SetEpisodeId(ep->GetId());\n      callback(sensor_data);\n    }\n  };\n\n  client->SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      std::move(cb));\n}", "CodeBleu_score": 54.763365595223924}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(_Episode != nullptr);\n  _Client.SubscribeToStream<sensor::SensorData>(\n      sensor.GetActorDescription().GetStreamToken(),\n      [this, callback](SharedPtr<sensor::SensorData> sensor_data) {\n        sensor_data->SetEpisode(*_Episode);\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 41.607257708484035}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = uid;\n    description.id = id;\n    description.attributes.reserve(attributes.size());\n    for (const auto& attribute : attributes) {\n        description.attributes.push_back(attribute);\n    }\n    return description;\n}", "CodeBleu_score": 78.7429452821066}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = uid;\n    description.id = id;\n    description.attributes.reserve(attributes.size());\n    for (auto &attribute : attributes) {\n        description.attributes.push_back(attribute.MakeAttributeDescription());\n    }\n    return description;\n}", "CodeBleu_score": 71.55053250844804}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = uid;\n    description.id = id;\n    description.attributes.reserve(attributes.size());\n    for (auto& attribute : attributes) {\n        description.attributes.push_back(attribute);\n    }\n    return description;\n}", "CodeBleu_score": 78.22295476926615}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = std::make_shared<BlueprintLibrary>();\n  for (const auto &pair : blueprints_) {\n    const auto &blueprint = pair.second;\n    if (blueprint.ContainsAttribute(name)) {\n      const auto &attribute = blueprint.GetAttribute(name);\n      if (attribute.GetValue() == value ||\n          attribute.GetRecommendedValues().contains(value)) {\n        result->blueprints_.emplace(pair);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 46.21225146168871}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = std::make_shared<BlueprintLibrary>();\n  for (const auto &pair : _blueprints) {\n    if (!pair.second.ContainsAttribute(name)) {\n      continue;\n    }\n    const auto &attribute = pair.second.GetAttribute(name);\n    if (attribute.GetValue() == value ||\n        attribute.GetRecommendedValues().count(value) > 0) {\n      result->_blueprints.emplace(pair);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 46.71663129587519}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = std::make_shared<BlueprintLibrary>();\n  for (const auto& pair : blueprints_) {\n    if (!pair.second.ContainsAttribute(name)) {\n      continue;\n    }\n    auto attribute = pair.second.GetAttribute(name);\n    if (attribute.GetValue() == value ||\n        attribute.GetRecommendedValues().contains(value)) {\n      result->blueprints_.emplace(pair);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 43.59175163809503}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string full_path = base_folder + \"/\" + path;\n  if (!carla::FileSystem::ValidateFilePath(full_path, true)) {\n    return false;\n  }\n\n  std::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n  if (!out.good()) {\n    return false;\n  }\n\n  out.write(reinterpret_cast<char*>(content.data()), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 49.39154509308905}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    // Construct the full file path using the base folder and version information\n    std::string full_path = FileSystem::GetBaseFolder() + \"/\" + path + \".\" + std::to_string(FileSystem::GetVersion());\n\n    // Validate the file path\n    if (!FileSystem::ValidateFilePath(full_path)) {\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents\n    std::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    // Write the content to the file\n    file.write(reinterpret_cast<const char*>(content.data()), content.size());\n\n    // Close the file\n    file.close();\n\n    return true;\n}", "CodeBleu_score": 46.25878505357923}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string fullPath = FileSystem::GetFilePath(path);\n  if (!FileSystem::ValidateFilePath(fullPath, false)) {\n    return false;\n  }\n  std::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n  if (!out.good()) {\n    return false;\n  }\n  out.write(reinterpret_cast<char*>(content.data()), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 48.65664219646418}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const auto &extent = parent->GetBoundingBox().extent;\n    const auto location = transform.location + parent->GetBoundingBox().location;\n    const auto yaw = transform.rotation.yaw;\n    const auto corners = {\n        Rotate(yaw, geom::Location{extent.x, extent.y, 0.0f}),\n        Rotate(yaw, geom::Location{-extent.x, extent.y, 0.0f}),\n        Rotate(yaw, geom::Location{extent.x, -extent.y, 0.0f}),\n        Rotate(yaw, geom::Location{-extent.x, -extent.y, 0.0f})};\n    return std::make_shared<Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 57.57151489830273}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const geom::Location location = transform.location + parent_bounds->location;\n    const float yaw = transform.rotation.yaw;\n    const float extent_x = parent_bounds->extent.x;\n    const float extent_y = parent_bounds->extent.y;\n    const float extent_z = parent_bounds->extent.z;\n    const geom::Location corners[] = {\n        Rotate(yaw, geom::Location(extent_x, extent_y, extent_z)),\n        Rotate(yaw, geom::Location(-extent_x, extent_y, extent_z)),\n        Rotate(yaw, geom::Location(-extent_x, -extent_y, extent_z)),\n        Rotate(yaw, geom::Location(extent_x, -extent_y, extent_z)),\n        Rotate(yaw, geom::Location(extent_x, extent_y, -extent_z)),\n        Rotate(yaw, geom::Location(-extent_x, extent_y, -extent_z)),\n        Rotate(yaw, geom::Location(-extent_x, -extent_y, -extent_z)),\n        Rotate(yaw, geom::Location(extent_x, -extent_y, -extent_z))};\n    return std::make_shared<Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 45.27505378421443}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const auto &extents = parent->GetBoundingBox().extent;\n    const auto &location = parent->GetBoundingBox().location + transform.location;\n    const float yaw = transform.rotation.yaw;\n    const auto corners = {\n      Rotate(yaw, geom::Location{extents.x, extents.y, 0.0f}),\n      Rotate(yaw, geom::Location{extents.x, -extents.y, 0.0f}),\n      Rotate(yaw, geom::Location{-extents.x, -extents.y, 0.0f}),\n      Rotate(yaw, geom::Location{-extents.x, extents.y, 0.0f})};\n    return std::make_shared<Bounds>(frame, corners);\n  }", "CodeBleu_score": 50.56334000068796}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Query the current state of lights from the server.\n  std::vector<LightState> light_states = _episode.Lock()->QueryLightsStateToServer();\n\n  // Update the local light states.\n  for (auto &light_state : light_states) {\n    // Check if the light already exists in the _lights map.\n    auto it = _lights.find(light_state.id);\n    if (it == _lights.end()) {\n      // If the light does not exist, create a new light object.\n      Light light(light_state.id, light_state.transform, light_state.color,\n                  static_cast<LightState::LightGroup>(light_state.group));\n      _lights.emplace(light_state.id, std::move(light));\n    } else {\n      // If the light already exists, update its state.\n      it->second.SetTransform(light_state.transform);\n      it->second.SetColor(light_state.color);\n      it->second.SetGroup(static_cast<LightState::LightGroup>(light_state.group));\n    }\n  }\n}", "CodeBleu_score": 48.63132219292747}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_lights_mutex);\n  const auto light_states = _episode.Lock()->QueryLightsStateToServer();\n  for (auto &light_state : light_states) {\n    auto search = _lights.find(light_state.id);\n    if (search != _lights.end()) {\n      search->second->SetState(light_state);\n    } else {\n      _lights.insert({light_state.id, std::make_shared<Light>(light_state)});\n    }\n  }\n}", "CodeBleu_score": 40.1663395560731}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto light_state = _episode.Lock()->QueryLightsStateToServer();\n  for (auto &light_info : light_state) {\n    auto id = light_info.first;\n    auto transform = light_info.second.transform;\n    auto intensity = light_info.second.intensity;\n    auto color = light_info.second.color;\n    auto type = light_info.second.type;\n    auto light_group = static_cast<LightState::LightGroup>(light_info.second.group);\n    auto found_it = _lights.find(id);\n    if (found_it != _lights.end()) {\n      found_it->second->SetColor(color);\n      found_it->second->SetIntensity(intensity);\n      found_it->second->SetTransform(transform);\n      found_it->second->SetLightGroup(light_group);\n    } else {\n      _lights.insert({id, std::make_shared<Light>(id, transform, intensity, color, type, light_group)});\n    }\n  }\n}", "CodeBleu_score": 45.69113136511651}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_lights_mutex);\n\n  if (_lights_changes.empty()) {\n    return;\n  }\n\n  if (!discard_client) {\n    _episode.Lock()->UpdateServerLightsState(_lights_changes);\n  }\n\n  _lights_changes.clear();\n  _lights_dirty = false;\n}", "CodeBleu_score": 23.01794078842493}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (_lights_changes.empty())\n    return;\n\n  std::vector<rpc::LightState> message;\n  for (const auto& it_light : _lights) {\n    if (it_light.second.IsDirty()) {\n      rpc::LightState state;\n      state.set_name(it_light.first);\n      state.set_color(it_light.second.GetColor());\n      state.set_intensity(it_light.second.GetIntensity());\n      state.set_is_on(it_light.second.IsOn());\n      message.push_back(state);\n    }\n  }\n  _lights_changes.clear();\n  if (!message.empty()) {\n    _episode.Lock()->SendLightState(message, discard_client);\n  }\n  _dirty = false;\n}", "CodeBleu_score": 51.384749595756396}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  // Lock the mutex to ensure thread safety\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Check if there are any changes\n  if (_lights_changes.empty()) {\n    return;\n  }\n\n  // Create a message containing the updated light states\n  std::vector<rpc::LightState> message;\n  for (auto it_light = _lights.begin(); it_light != _lights.end(); ++it_light) {\n    if (_lights_changes.find(it_light->first) != _lights_changes.end()) {\n      message.push_back(it_light->second.GetState());\n    }\n  }\n\n  // Send the message to the server\n  if (!discard_client) {\n    _episode.Lock()->SendLightState(message);\n  }\n\n  // Clear the changes and reset the dirty flag\n  _lights_changes.clear();\n  _dirty = false;\n}", "CodeBleu_score": 43.191694989687214}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"Sending message from a sensor that is not the custom sensor.\");\n    return;\n  }\n  GetEpisode().Lock()->Send<carla::client::detail::EpisodeProxy>(std::move(message), GetContext());\n}", "CodeBleu_score": 55.58267034345914}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"This sensor is not sending custom messages\");\n    return;\n  }\n\n  auto context = GetContext();\n  log_debug(\"Sending message: \" + message);\n  GetEpisode().Lock()->Send<carla::client::SensorData>(*this, std::move(message), context);\n}", "CodeBleu_score": 57.987279571748694}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"This sensor is not sending custom messages\");\n    return;\n  }\n\n  GetEpisode().Lock()->Send(std::move(message), GetContext());\n}", "CodeBleu_score": 53.86250454598828}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        // Register the vehicle with the traffic manager\n        tm.RegisterVehicles(shared_from_this());\n    } else {\n        // Unregister the vehicle from the traffic manager\n        tm.UnregisterVehicles(shared_from_this());\n    }\n}", "CodeBleu_score": 52.01800071089884}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        // Register the vehicle with the traffic manager\n        tm.RegisterVehicles(shared_from_this(), tm_port);\n    } else {\n        // Unregister the vehicle from the traffic manager\n        tm.UnregisterVehicles(shared_from_this(), tm_port);\n    }\n}", "CodeBleu_score": 57.655925178523134}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        // Register the vehicle with the traffic manager\n        tm.RegisterVehicles(shared_from_this());\n    } else {\n        // Unregister the vehicle from the traffic manager\n        tm.UnregisterVehicles(shared_from_this());\n    }\n}", "CodeBleu_score": 52.01800071089884}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t    // Get the walker actor\n    auto walker = GetPawn();\n\n    // Register the AI controller with the episode\n    GetEpisode().Lock()->RegisterAIController(this);\n\n    // Add the walker actor to the navigation system with its current location\n    GetEpisode().Lock()->GetNavigation()->AddWalker(walker, walker->GetLocation());\n\n    // Disable the physics simulation and collisions for the walker actor\n    walker->GetRootComponent()->SetSimulatePhysics(false);\n    walker->GetRootComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 41.91737621571336}, {"code": "void WalkerAIController::Start(){\n\t    GetEpisode().Lock()->RegisterAIController(this);\n    walker = boost::static_pointer_cast<cc::Agent>(GetParent().lock());\n    GetEpisode().Lock()->GetNavigation()->AddWalker(walker, walker->GetLocation());\n    walker->GetActor()->SetSimulatePhysics(false);\n    walker->GetActor()->SetActorEnableCollision(false);\n}", "CodeBleu_score": 42.430230329844996}, {"code": "void WalkerAIController::Start(){\n\t    // Get the walker actor\n    AActor* walker = GetPawn();\n    // Get the episode\n    AEpisode* episode = GetEpisode();\n    // Register the AI controller with the episode\n    episode->RegisterAIController(this);\n    // Add the walker actor to the navigation system with its current location\n    episode->GetNavigation()->AddWalker(walker, walker->GetActorLocation());\n    // Disable the physics simulation and collisions for the walker actor\n    episode->SetActorSimulatePhysics(walker, false);\n    episode->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 40.645992841032516}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto* navigation = GetEpisode().Lock()->GetNavigation();\n  if (navigation == nullptr) {\n    // This may happen if the episode does not have a navigation system.\n    return;\n  }\n  auto* walker = boost::polymorphic_downcast<const Walker*>(GetParent());\n  if (navigation->GetWalkerSpeed(walker->GetId()) == boost::none) {\n    // This may happen if the navigation system does not have the specified walker.\n    return;\n  }\n  if (!navigation->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n    // This may happen if the walker is not found in the navigation system.\n    return;\n  }\n  LOG(WARNING) << \"Walker \" << walker->GetId() << \" speed has been set to \"\n               << max_speed;\n}", "CodeBleu_score": 49.63616947837493}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (auto episode = GetEpisode().Lock()) {\n    if (auto nav = episode->GetNavigation()) {\n      if (auto walker = nav->GetWalker(GetParent())) {\n        if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n          log_warning(\n            \"Unable to set max speed for walker: \",\n            GetParent()->GetId(),\n            \" with max speed: \",\n            max_speed\n          );\n        }\n      } else {\n        log_warning(\n          \"Unable to find walker with id: \",\n          GetParent()->GetId(),\n          \" in episode: \",\n          episode->GetId()\n        );\n      }\n    } else {\n      log_warning(\n        \"Unable to find navigation for episode: \",\n        episode->GetId()\n      );\n    }\n  } else {\n    log_warning(\n      \"Unable to find episode for walker: \",\n      GetParent()->GetId()\n    );\n  }\n}", "CodeBleu_score": 47.48275492677044}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (auto episode = GetEpisode().Lock()) {\n    auto parent_walker = GetParent();\n    auto nav = episode->GetNavigation();\n    if (nav != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(parent_walker, max_speed)) {\n        log_warning(\n            \"Trying to set max_speed to {}, but this walker {} is not in the \"\n            \"navigation system\",\n            max_speed,\n            parent_walker->GetId());\n      }\n    } else {\n      log_warning(\n          \"Trying to set max_speed to {}, but the episode {} does not have a \"\n          \"navigation system\",\n          max_speed,\n          episode->GetId());\n    }\n  } else {\n    log_warning(\n        \"Trying to set max_speed to {}, but the episode is not valid anymore\",\n        max_speed);\n  }\n}", "CodeBleu_score": 55.34632617985932}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(_parent->GetMap().GetPrevious(_waypoint, distance).size());\n    for (auto &waypoint: _parent->GetMap().GetPrevious(_waypoint, distance)) {\n        result.emplace_back(std::make_shared<Waypoint>(waypoint));\n    }\n    return result;\n}", "CodeBleu_score": 62.64431218582946}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(_parent->GetMap().GetPrevious(_waypoint, distance).size());\n  for (const auto &waypoint : _parent->GetMap().GetPrevious(_waypoint, distance)) {\n    result.emplace_back(std::make_shared<Waypoint>(_parent, waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 62.76294897518425}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(_parent->GetMap().GetPrevious(_waypoint).size());\n  for (auto &waypoint : _parent->GetMap().GetPrevious(_waypoint)) {\n    result.emplace_back(\n      std::make_shared<Waypoint>(waypoint, _parent));\n  }\n  return result;\n}", "CodeBleu_score": 60.63129064045595}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  std::unordered_set<SharedPtr<Waypoint>> added_signals;\n  std::vector<SharedPtr<Waypoint>> signals =\n      _parent->GetMap().GetSignalsInDistance(distance, *this);\n\n  for (auto &signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      SharedPtr<Waymark> landmark = std::make_shared<Landmark>(signal);\n      SharedPtr<Waypoint> wp = std::make_shared<Waypoint>(landmark);\n      result.emplace_back(wp);\n      added_signals.insert(signal);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 49.15788822006807}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<SharedPtr<Waypoint>> added_signals;\n  for (auto &signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    if (added_signals.count(signal) > 0) {\n      continue;\n    }\n    result.emplace_back(\n        SharedPtr<Landmark>(new Landmark(signal->GetLocation(), signal->GetType())));\n    added_signals.insert(signal);\n  }\n  return result;\n}", "CodeBleu_score": 42.6179486341986}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Waypoint>> signals =\n      _parent->GetMap().GetSignalsInDistance(distance, *this);\n\n  std::unordered_set<SharedPtr<Waypoint>> added_signals;\n  std::vector<SharedPtr<Landmark>> result;\n  for (auto &signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      SharedPtr<Waypoint> new_waypoint =\n          std::make_shared<Waypoint>(signal->GetTransform(), _parent);\n      SharedPtr<Landmark> new_landmark =\n          std::make_shared<Landmark>(new_waypoint, signal->GetType());\n      result.emplace_back(new_landmark);\n      added_signals.insert(signal);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 51.66022762398986}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    rpc::EpisodeSettings new_settings = settings;\n    if (settings.fixed_delta_seconds.has_value()) {\n      // Verify that the fixed delta time is correctly applied.\n      const float delta_time = settings.fixed_delta_seconds.get();\n      constexpr int attempts = 3;\n      for (int attempt = 0; attempt < attempts; ++attempt) {\n        const auto curr_snapshot = GetSnapshot();\n        const auto ticks = Tick(local_timeout);\n        if (ticks == 0) {\n          // If the world did not tick, the fixed delta time is not correctly applied.\n          log_warning(\n              \"Fixed delta time not correctly applied. \"\n              \"Please check the value of fixed_delta_seconds in the episode settings.\");\n          break;\n        }\n        const auto next_snapshot = GetSnapshot();\n        const float dt = (next_snapshot.GetTimestamp() - curr_snapshot.GetTimestamp()).get();\n        if (abs(dt - delta_time) > std::numeric_limits<float>::epsilon()) {\n          // If the delta time between consecutive snapshots does not match the expected value, the fixed delta time is not correctly applied.\n          log_warning(\n              \"Fixed delta time not correctly applied. \"\n              \"Please check the value of fixed_delta_seconds in the episode settings.\");\n          break;\n        }\n      }\n    }\n    return _episode.Lock()->SetEpisodeSettings(new_settings);\n  }", "CodeBleu_score": 62.128575695373826}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    rpc::EpisodeSettings new_settings = settings;\n    if (settings.fixed_delta_seconds.has_value()) {\n      const float dt = settings.fixed_delta_seconds.get();\n      const uint64_t attempts = 10;\n      const uint64_t ticks_per_attempt = 10;\n      const float epsilon = std::numeric_limits<float>::epsilon();\n      for (uint64_t attempt = 0; attempt < attempts; ++attempt) {\n        bool success = true;\n        for (uint64_t tick = 0; tick < ticks_per_attempt; ++tick) {\n          const auto curr_snapshot = _episode.Lock()->GetWorldSnapshot();\n          const float dt_computed = curr_snapshot.GetTimestamp().elapsed_seconds - _last_snapshot.GetTimestamp().elapsed_seconds;\n          if (std::abs(dt - dt_computed) > epsilon) {\n            success = false;\n            break;\n          }\n          _last_snapshot = curr_snapshot;\n          _episode.Lock()->Tick(local_timeout);\n        }\n        if (success) {\n          break;\n        }\n      }\n      if (!success) {\n        log_warning(\n            \"The fixed delta time could not be correctly applied. \"\n            \"The world will continue using the default fixed delta time.\");\n        new_settings.fixed_delta_seconds = boost::optional<float>();\n      }\n    }\n    return _episode.Lock()->SetEpisodeSettings(new_settings);\n  }", "CodeBleu_score": 58.59784538983024}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    rpc::EpisodeSettings new_settings = settings;\n    if (settings.fixed_delta_seconds.has_value()) {\n      // Verify fixed delta time.\n      const uint32_t attempts = 10;\n      const float epsilon = std::numeric_limits<float>::epsilon();\n      const float target_delta_time = settings.fixed_delta_seconds.get();\n      for (uint32_t i = 0; i < attempts; ++i) {\n        _episode.Lock()->SetEpisodeSettings(new_settings);\n        const auto curr_snapshot = _episode.Lock()->GetWorldSnapshot();\n        const float curr_delta_time = curr_snapshot.GetTimestamp().elapsed_seconds;\n        if (std::abs(curr_delta_time - target_delta_time) < epsilon) {\n          break;\n        }\n        log_warning(\n            \"fixed delta time not applied correctly, \"\n            \"retrying with fixed delta time:\",\n            target_delta_time,\n            \"current delta time:\",\n            curr_delta_time);\n        new_settings.fixed_delta_seconds = target_delta_time;\n      }\n    } else {\n      _episode.Lock()->SetEpisodeSettings(new_settings);\n    }\n    return _episode.Lock()->GetEpisodeSettings().map_name;\n  }", "CodeBleu_score": 59.01617417462667}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\n}", "CodeBleu_score": 3.377623342886302}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    const float segmentLengthSquared = DistanceSquared2D(segmentStart, segmentEnd);\n    if (segmentLengthSquared == 0.0f) {\n        return std::make_pair(0.0f, Distance2D(segmentStart, point));\n    }\n    const float segmentLength = std::sqrt(segmentLengthSquared);\n    const float t = Clamp(Dot2D(point - segmentStart, segmentEnd - segmentStart) / segmentLengthSquared, 0.0f, 1.0f);\n    const float distanceAlongSegment = t * segmentLength;\n    const Point2D projection = segmentStart + t * (segmentEnd - segmentStart);\n    const float distanceToPoint = Distance2D(projection, point);\n    return std::make_pair(distanceAlongSegment, distanceToPoint);\n}", "CodeBleu_score": 54.23824776550996}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\n}", "CodeBleu_score": 3.377623342886302}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n    auto initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 0; i < vertices.size() - 2; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i + 1);\n      AddIndex(initial_index + i + 2);\n    }\n  }", "CodeBleu_score": 55.08581797394817}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n    auto initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; i++) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 55.227215319808565}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n    auto initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 55.34315134094512}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  boost::asio::post(\n      _strand,\n      [=]() {\n        if (self->_socket.is_open()) {\n          self->_deadline.expires_from_now(boost::posix_time::seconds(10));\n          boost::asio::async_write(\n              self->_socket,\n              message->GetBufferSequence(),\n              boost::asio::bind_executor(\n                  self->_strand,\n                  [=](boost::system::error_code ec, std::size_t /*length*/) {\n                    self->handle_sent(message, ec);\n                  }));\n        } else {\n          log_error(\"trying to write on a closed socket\");\n        }\n      });\n}", "CodeBleu_score": 37.379412576134996}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t    DEBUG_ASSERT(message != nullptr);\n    boost::asio::post(\n        _strand,\n        [weak = weak_from_this(), message]() {\n            if (auto self = weak.lock()) {\n                if (self->_socket.is_open()) {\n                    self->_deadline.expires_from_now(boost::posix_time::seconds(10));\n                    boost::asio::async_write(\n                        self->_socket,\n                        message->GetBufferSequence(),\n                        boost::asio::bind_executor(\n                            self->_strand,\n                            [weak, message](auto ec, auto) {\n                                if (auto self = weak.lock()) {\n                                    if (ec) {\n                                        log_error(\"error writing to primary: \", ec.message());\n                                        self->CloseNow();\n                                    } else if (message->empty()) {\n                                        log_debug(\"primary sent: \", message->size(), \" bytes\");\n                                    } else {\n                                        self->Write(message);\n                                    }\n                                }\n                            }));\n                }\n            }\n        });\n}", "CodeBleu_score": 41.85640285852897}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  boost::asio::post(\n      _strand,\n      [weak = weak_from_this(), message]() {\n        if (auto self = weak.lock()) {\n          if (self->_socket.is_open()) {\n            self->_deadline.expires_from_now(boost::posix_time::seconds(10));\n            boost::asio::async_write(\n                self->_socket,\n                message->GetBufferSequence(),\n                boost::asio::bind_executor(\n                    self->_strand,\n                    [weak, message](boost::system::error_code ec, std::size_t) {\n                      if (auto self = weak.lock()) {\n                        if (ec) {\n                          log_error(\"error while writing to primary:\", ec.message());\n                          self->CloseNow();\n                        } else {\n                          log_debug(\"sent message to primary:\", message->GetHeader().size, \"bytes\");\n                        }\n                      }\n                    }));\n          } else {\n            log_error(\"trying to write to a closed primary\");\n          }\n        }\n      });\n}", "CodeBleu_score": 44.39185359157093}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n    if (!ec && _socket.is_open()) {\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        _socket.close(ec);\n    }\n    _on_closed();\n    log_debug(\"Session closed\");\n}", "CodeBleu_score": 50.29028632456166}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n    if (ec && _socket.is_open()) {\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        _socket.close();\n    }\n    _on_closed();\n    log_debug(\"session closed\");\n}", "CodeBleu_score": 49.94289655999846}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n    if (!ec && _socket.is_open()) {\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n        _socket.close();\n    }\n    _on_closed();\n    log_debug(\"Session closed\");\n}", "CodeBleu_score": 50.00815087351822}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    auto buffer = std::make_shared<Buffer>(msg.c_str(), msg.size());\n    log_info(\"Sending alive message: %s\", msg.c_str());\n    _router->WriteToNext(buffer, YOU_ALIVE);\n\n    auto fut = _router->ReadFromPrev();\n    log_info(\"Received alive response: %s\", fut.get()->data);\n}", "CodeBleu_score": 53.83402257595351}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    Buffer buffer(msg.c_str(), msg.size());\n    log_info(\"Sending Is Alive\");\n    _router->WriteToNext(buffer, YOU_ALIVE);\n    auto fut = _router->ReadFromNext();\n    log_info(\"Received Is Alive\");\n}", "CodeBleu_score": 47.42094723076843}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  // Create a buffer from the message\n  std::string msg = \"Are you alive?\";\n  Buffer buffer(msg.c_str(), msg.size());\n\n  // Log the sending action\n  log_info(\"Sending: %s\", msg.c_str());\n\n  // Write the buffer to the next router with the command YOU_ALIVE\n  _router->WriteToNext(buffer, YOU_ALIVE);\n\n  // Wait for the response from the system\n  std::future<Buffer> fut = _router->ReadFromNext();\n  Buffer response = fut.get();\n\n  // Log the response from the system\n  log_info(\"Received: %s\", response.data);\n}", "CodeBleu_score": 51.7386594934713}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  bool found = false;\n  for (auto& server : _servers) {\n    auto fut = server.second->WriteToOne(\n        std::make_unique<EnableROS>(sensor_id),\n        [&found](const std::unique_ptr<EnableROSResponse>& response) {\n          if (response->sensor_id == sensor_id) {\n            found = true;\n          }\n        });\n    fut.get();\n  }\n  if (!found) {\n    LOG_ERROR(\"Sensor {} not found on any server\", sensor_id);\n  }\n}", "CodeBleu_score": 46.20202146489519}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    for (auto &server : _servers) {\n        if (server.second.find(sensor_id) != server.second.end()) {\n            std::vector<uint8_t> buffer;\n            buffer.resize(sizeof(sensor_id));\n            memcpy(buffer.data(), &sensor_id, sizeof(sensor_id));\n            auto fut = _router->WriteToOne(server.first, buffer, Commands::ENABLE_ROS);\n            auto response = fut.get();\n            if (response.status != ResponseStatus::SUCCESS) {\n                log_error(\"Failed to enable ROS for sensor \" + std::to_string(sensor_id) + \" on server \" + std::to_string(server.first));\n            }\n            return;\n        }\n    }\n    log_error(\"Sensor \" + std::to_string(sensor_id) + \" not found on any server\");\n}", "CodeBleu_score": 54.28965546053954}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    // Check if the sensor is found on any server\n    auto it = _servers.find(sensor_id);\n    if (it == _servers.end()) {\n        // If not found, log an error message\n        log_error(\"Could not find sensor id \" + std::to_string(sensor_id) + \" on any server.\");\n        return;\n    }\n\n    // Create a buffer with the sensor ID\n    std::vector<uint8_t> buffer(sizeof(sensor_id));\n    memcpy(buffer.data(), &sensor_id, sizeof(sensor_id));\n\n    // Send an ENABLE_ROS command to the server using the router\n    std::future<std::vector<uint8_t>> fut = _router->WriteToOne(it->second, Commands::ENABLE_ROS, buffer);\n\n    // Wait for and process the server's response\n    std::vector<uint8_t> response = fut.get();\n    if (response.empty()) {\n        log_error(\"No response received from server.\");\n        return;\n    }\n    if (response[0] != Commands::ENABLE_ROS) {\n        log_error(\"Unexpected response received from server.\");\n        return;\n    }\n    if (response[1] != 0) {\n        log_error(\"Server responded with error code \" + std::to_string(response[1]));\n        return;\n    }\n}", "CodeBleu_score": 52.941762040809934}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  log_info(\"getting token for sensor: \", sensor_id);\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"sensor already activated\");\n    return it->second;\n  }\n\n  auto server = _router->GetNextServer();\n  auto new_token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = new_token;\n  _sensor_to_server[sensor_id] = server;\n  log_info(\"got token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  return new_token;\n}", "CodeBleu_score": 68.15185738669466}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  log_info(\"asking for a token\");\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"token already exists: \", it->second.get_stream_id(), \", \", it->second.get_port());\n    return it->second;\n  }\n\n  auto server = _router->GetNextServer();\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = server.Write(MultiGPUCommand::GET_TOKEN, std::move(buf));\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  _tokens.emplace(sensor_id, new_token);\n  _server_map.emplace(sensor_id, server);\n  return new_token;\n}", "CodeBleu_score": 59.87467853558979}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  log_info(\"asking for a token\");\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"sensor already activated, returning existing token: \", it->second.get_stream_id(), \", \", it->second.get_port());\n    return it->second;\n  }\n  log_info(\"sensor not activated, enabling sensor on secondary server\");\n  _router->GetNextServer().EnableSensor(sensor_id);\n  token_type new_token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = new_token;\n  _sensor_to_server[sensor_id] = _router->GetNextServer();\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  return new_token;\n}", "CodeBleu_score": 69.73066105766534}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.76847140907317}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.74225201289511}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.76847140907317}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!_is_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    std::unique_lock<std::mutex> lock(_mutex);\n\n    auto walker_it = _mapped_walkers_id.find(id);\n    if (walker_it != _mapped_walkers_id.end()) {\n      _crowd->removeAgent(walker_it->second);\n      _walker_manager.RemoveWalker(id);\n      _mapped_walkers_id.erase(walker_it);\n      _mapped_by_index.erase(walker_it->second);\n      return true;\n    }\n\n    auto vehicle_it = _mapped_vehicles_id.find(id);\n    if (vehicle_it != _mapped_vehicles_id.end()) {\n      _crowd->removeAgent(vehicle_it->second);\n      _vehicle_manager.RemoveVehicle(id);\n      _mapped_vehicles_id.erase(vehicle_it);\n      _mapped_by_index.erase(vehicle_it->second);\n      return true;\n    }\n\n    return false;\n  }", "CodeBleu_score": 70.84991862040224}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!_is_ready) {\n    return false;\n  }\n  DEBUG_ASSERT(_crowd != nullptr);\n  std::lock_guard<std::mutex> lock(_crowd_mutex);\n\n  // Remove from walkers.\n  auto walker_it = _mapped_walkers_id.find(id);\n  if (walker_it != _mapped_walkers_id.end()) {\n    _crowd->removeAgent(walker_it->second);\n    _walker_manager.RemoveWalker(id);\n    DEBUG_ASSERT(_mapped_walkers_id.erase(id) == 1);\n    return true;\n  }\n\n  // Remove from vehicles.\n  auto vehicle_it = _mapped_vehicles_id.find(id);\n  if (vehicle_it != _mapped_vehicles_id.end()) {\n    _crowd->removeAgent(vehicle_it->second);\n    _vehicle_manager.RemoveVehicle(id);\n    DEBUG_ASSERT(_mapped_vehicles_id.erase(id) == 1);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 68.60793367047886}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    std::unique_lock<std::mutex> lock(_mutex);\n\n    auto walker_it = _mapped_walkers_id.find(id);\n    if (walker_it != _mapped_walkers_id.end()) {\n      _crowd->removeAgent(walker_it->second);\n      _walker_manager.RemoveWalker(id);\n      _mapped_walkers_id.erase(walker_it);\n      _mapped_by_index.erase(id);\n      return true;\n    }\n\n    auto vehicle_it = _mapped_vehicles_id.find(id);\n    if (vehicle_it != _mapped_vehicles_id.end()) {\n      _crowd->removeAgent(vehicle_it->second);\n      _vehicle_manager.RemoveVehicle(id);\n      _mapped_vehicles_id.erase(vehicle_it);\n      _mapped_by_index.erase(id);\n      return true;\n    }\n\n    return false;\n  }", "CodeBleu_score": 71.8896049108577}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // collect the ids of currently mapped vehicles\n    std::set<ActorId> mapped_vehicles;\n    for (auto it = _mapped_vehicles_id.begin(); it != _mapped_vehicles_id.end(); ++it) {\n      mapped_vehicles.insert(it->first);\n    }\n\n    // add or update vehicles\n    for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n      // add or update\n      AddOrUpdateVehicle(*it);\n      // mark as updated\n      mapped_vehicles.erase(it->id);\n    }\n\n    // remove vehicles that are not updated\n    for (auto it = mapped_vehicles.begin(); it != mapped_vehicles.end(); ++it) {\n      RemoveAgent(*it);\n    }\n\n    return true;\n  }", "CodeBleu_score": 51.14567193130648}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // collect the IDs of currently mapped vehicles\n    std::set<ActorId> current_vehicles;\n    for (auto &pair : _mapped_vehicles_id) {\n      current_vehicles.insert(pair.first);\n    }\n\n    // add or update vehicles from the provided list\n    for (auto &vehicle : vehicles) {\n      if (AddVehicle(vehicle)) {\n        current_vehicles.erase(vehicle.id);\n      }\n    }\n\n    // remove vehicles not marked as updated\n    for (auto &id : current_vehicles) {\n      RemoveAgent(id);\n    }\n\n    return true;\n  }", "CodeBleu_score": 51.226791769334554}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // get the ids of currently mapped vehicles\n    std::set<ActorId> mapped_ids;\n    for (auto it = _mapped_vehicles_id.begin(); it != _mapped_vehicles_id.end(); ++it) {\n      mapped_ids.insert(it->first);\n    }\n\n    // add or update vehicles\n    for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n      AddOrUpdateVehicle(*it);\n    }\n\n    // remove vehicles not updated\n    for (auto it = mapped_ids.begin(); it != mapped_ids.end(); ++it) {\n      auto it2 = std::find_if(vehicles.begin(), vehicles.end(), [&it](VehicleCollisionInfo &vehicle) {\n        return vehicle.id == *it;\n      });\n      if (it2 == vehicles.end()) {\n        RemoveAgent(*it);\n      }\n    }\n\n    return true;\n  }", "CodeBleu_score": 50.71339128853941}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  if (_mapped_vehicles_id.find(id) != _mapped_vehicles_id.end()) {\n    return _crowd->hasVehicleNear(_mapped_vehicles_id.at(id), distance, direction);\n  } else if (_mapped_walkers_id.find(id) != _mapped_walkers_id.end()) {\n    return _crowd->hasVehicleNear(_mapped_walkers_id.at(id), distance, direction);\n  }\n  return false;\n}", "CodeBleu_score": 42.16520795825931}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  // Search for the actor in the mapped walkers and vehicles\n  auto walker_it = _mapped_walkers_id.find(id);\n  auto vehicle_it = _mapped_vehicles_id.find(id);\n\n  if (walker_it == _mapped_walkers_id.end() && vehicle_it == _mapped_vehicles_id.end()) {\n    return false;\n  }\n\n  // Enter a critical section to ensure thread safety\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Compute the squared distance\n  const float squared_distance = distance * distance;\n\n  // Use the crowd system to determine if a vehicle is nearby\n  return _crowd->hasVehicleNear(walker_it != _mapped_walkers_id.end() ? walker_it->second : vehicle_it->second,\n                                squared_distance,\n                                direction);\n}", "CodeBleu_score": 57.64009082063987}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  auto it_walkers = _mapped_walkers_id.find(id);\n  if (it_walkers != _mapped_walkers_id.end()) {\n    return _crowd->hasVehicleNear(it_walkers->second, distance, direction);\n  }\n\n  auto it_vehicles = _mapped_vehicles_id.find(id);\n  if (it_vehicles != _mapped_vehicles_id.end()) {\n    return _crowd->hasVehicleNear(it_vehicles->second, distance, direction);\n  }\n\n  return false;\n}", "CodeBleu_score": 58.05506679223771}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  const auto &route = info.GetRoute();\n  const auto &point = route.at(info.GetCurrentRouteIndex());\n\n  WalkerEventVisitor visitor(id, info, delta);\n  return boost::variant2::visit(visitor, point);\n}", "CodeBleu_score": 48.390504771475314}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  const auto &current_route_point = info.route_points[info.current_route_index];\n  WalkerEventVisitor visitor(id, info, current_route_point, delta);\n  return boost::variant2::visit(visitor, current_route_point.event);\n}", "CodeBleu_score": 48.91094949872756}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    const auto &current_route_point = info.route_points[info.current_route_point];\n    WalkerEventVisitor visitor(info.context, delta);\n    return boost::variant2::visit(visitor, current_route_point.event);\n}", "CodeBleu_score": 54.25169248180788}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n    // Iterate through each road node\n    for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n\n      // Get road ID\n      const int id = road_node.attribute(\"id\").as_int();\n\n      // Iterate through each lane section node\n      for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\n        // Get left, center, and right lane nodes\n        pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n        pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n        pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n        // Parse left lane\n        if (left_lane_node) {\n          ParseLanes(left_lane_node, id, map_builder);\n        }\n\n        // Parse center lane\n        if (center_lane_node) {\n          ParseLanes(center_lane_node, id, map_builder);\n        }\n\n        // Parse right lane\n        if (right_lane_node) {\n          ParseLanes(right_lane_node, id, map_builder);\n        }\n      }\n    }\n  }", "CodeBleu_score": 58.49840162193395}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n    // Extract the road ID\n    const int road_id = road_node.attribute(\"id\").as_int();\n\n    // Process each lane section within the lanes node\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\n      // Retrieve the left, center, and right lane nodes\n      const pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n      const pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n      const pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n      // Parse the left, center, and right lanes\n      ParseLanes(left_lane_node, center_lane_node, right_lane_node, map_builder, road_id);\n    }\n  }\n}", "CodeBleu_score": 43.452231381746465}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n    // Iterate through each road node\n    for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n      // Get the road ID\n      const int road_id = road_node.attribute(\"id\").as_int();\n\n      // Process each lane section within the lanes node\n      for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n        // Get the left, center, and right lane nodes\n        pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n        pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n        pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n        // Parse the left, center, and right lane nodes\n        ParseLanes(left_lane_node, center_lane_node, right_lane_node, road_id, map_builder);\n      }\n    }\n  }", "CodeBleu_score": 45.35047473112771}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cout << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 69.35360323362852}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 71.10309940676105}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 71.10309940676105}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_ = info.total_count;\n        if (matched_ > 0) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_ = info.total_count;\n        if (matched_ == 0) {\n            // destroy subscriber\n            //subscriber_owner->DestroySubscriber();\n        }\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for SubscriptionMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 81.13059213018417}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        if (matched_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        if (matched_ == 0) {\n            // Destroy the subscriber\n            delete _owner;\n        }\n    } else {\n        // Log an error message\n        std::cerr << \"Invalid change in subscription count\" << std::endl;\n    }\n}", "CodeBleu_score": 56.12419334814898}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        m_matched++;\n        if (m_matched == 1) {\n            m_first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        m_matched--;\n        if (m_matched == 0) {\n            m_owner->DestroySubscriber();\n        }\n    } else {\n        eprosima::fastrtps::log::Log::getError() << \"Error in CarlaSubscriberListenerImpl::on_subscription_matched: invalid change in matched count\" << std::endl;\n    }\n}", "CodeBleu_score": 57.689264076532446}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.02370031557412}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.01569280410635}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.02370031557412}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 94.30811008515623}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // exit immediately if target has already been set\n    if (tracker.g.sysid_target.get() != 0) {\n        return;\n    }\n\n    // decode the message and exit if it is not a message that should be tracked\n    mavlink_msg_heartbeat_decode(&msg, &tracker.g.heartbeat);\n    if (tracker.g.heartbeat.type != MAV_TYPE_GCS && tracker.g.heartbeat.type != MAV_TYPE_ONBOARD_CONTROLLER) {\n        return;\n    }\n\n    // set the target system ID if it is not set\n    if (tracker.g.sysid_target.get() == 0) {\n        tracker.g.sysid_target.set(tracker.g.heartbeat.sysid);\n    }\n\n    // request position and air pressure data streams from the target\n    tracker.gcs().request_datastream_position(tracker.g.sysid_target.get());\n    tracker.gcs().request_datastream_airpressure(tracker.g.sysid_target.get());\n\n    // flag that the target has been set\n    tracker.g.target_set.set(true);\n}", "CodeBleu_score": 43.29071515698755}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (tracker.target_set()) {\n        return;\n    }\n\n    mavlink_tracking_target_t packet;\n    mavlink_msg_tracking_target_decode(&msg, &packet);\n\n    if (packet.tracking_type != TRACKING_TYPE_MISSION) {\n        return;\n    }\n\n    if (packet.sysid_target == 0) {\n        tracker.g.sysid_target.set(tracker.g.sysid_my_gcs);\n        tracker.gcs().request_datastream_position();\n        tracker.gcs().request_datastream_airpressure();\n    } else {\n        tracker.g.sysid_target.set(packet.sysid_target);\n    }\n\n    tracker.target_set_flag(true);\n}", "CodeBleu_score": 54.09833006791946}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // exit immediately if the target has already been set\n    if (tracker.g.sysid_target.get() != 0) {\n        return;\n    }\n\n    // decode the message\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n\n    // exit immediately if the message type is not one that should be tracked\n    if (packet.type != MAV_TYPE_ANTENNA_TRACKER && packet.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    // set the sysid to the target and request position and air pressure data streams\n    tracker.g.sysid_target.set(msg.sysid);\n    tracker.gcs().request_datastream_position(tracker.g.sysid_target.get());\n    tracker.gcs().request_datastream_airpressure(tracker.g.sysid_target.get());\n\n    // flag that the target has been set\n    tracker.g.sysid_target.set(msg.sysid);\n}", "CodeBleu_score": 57.34374593514633}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n    if (result == MAV_RESULT_ACCEPTED) {\n        AP_Notify::flags.pre_arm_check_baro = true;\n    }\n\n    return result;\n}", "CodeBleu_score": 67.2424441207702}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        barometer.set_calibration_needed();\n    }\n    return result;\n}", "CodeBleu_score": 64.54935762665033}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 69.48170330049057}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (is_zero(packet.param1))  {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 89.27238189767404}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0f) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (packet.param1 == 0.0f) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 81.14154580216298}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0f) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (is_zero(packet.param1))  {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 89.56819036437824}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs; i++) {\n        if (HAVE_PAYLOAD_SPACE((mavlink_channel_t)i, DATA_STREAM)) {\n            mavlink_msg_request_data_stream_send(\n                (mavlink_channel_t)i,\n                sysid,\n                compid,\n                MAV_DATA_STREAM_POSITION,\n                position_update_rate_hz,\n                1);\n        }\n    }\n}", "CodeBleu_score": 77.21185239970877}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i = 0; i < num_gcs; i++) {\n        if (gcs[i] != nullptr && gcs[i]->initialised) {\n            if (HAVE_PAYLOAD_SPACE((mavlink_channel_t)i, DATA_STREAM)) {\n                mavlink_msg_request_data_stream_send(\n                    (mavlink_channel_t)i,\n                    sysid,\n                    compid,\n                    MAV_DATA_STREAM_POSITION,\n                    MAV_DATA_STREAM_POSITION_MSG_RATE,\n                    1);\n            }\n        }\n    }\n}", "CodeBleu_score": 74.16620276301916}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t", "CodeBleu_score": 5.5394447414533605}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS& ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (is_zero(cos_pitch)) {\n        return false;\n    }\n    ef_pitch = pitch + ahrs.sin_roll() * ahrs.sin_pitch() / cos_pitch;\n    ef_yaw = yaw + ahrs.cos_roll() * ahrs.sin_pitch() / cos_pitch;\n    return true;\n}", "CodeBleu_score": 63.04189445360464}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (is_zero(cos_pitch)) {\n        return false;\n    }\n    ef_pitch = radians(pitch) / cos_pitch;\n    ef_yaw = radians(yaw) / cos_pitch;\n    return true;\n}", "CodeBleu_score": 54.8206237462354}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    const float cos_pitch = ahrs.cos_pitch();\n    if (is_zero(cos_pitch)) {\n        return false;\n    }\n    ef_pitch = pitch / cos_pitch;\n    ef_yaw = yaw / cos_pitch;\n    return true;\n}", "CodeBleu_score": 54.54985675037412}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // get yaw and pitch targets\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float pitch = nav_status.pitch;\n    float yaw = nav_status.yaw;\n\n    // check if the target distance is valid or if no minimum distance is set\n    if (nav_status.target_valid || !tracker.g.min_distance_cm > 0) {\n        // if the target distance is valid, update the pitch and yaw servos\n        tracker.update_pitch_servo(pitch);\n        tracker.update_yaw_servo(yaw);\n    } else {\n        // if the target distance is not valid, stop the pitch and yaw servos\n        tracker.update_pitch_servo(0);\n        tracker.update_yaw_servo(0);\n    }\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate the angle error\n    calc_angle_error(pitch, yaw, direction_reversed);\n}", "CodeBleu_score": 48.79337431079319}, {"code": "void Mode::update_auto(void){\n\t    // get yaw and pitch target\n    int32_t yaw_cd = tracker.nav_status.bearing + tracker.g.yaw_trim;\n    int32_t pitch_cd = tracker.nav_status.pitch;\n\n    // check for direction reversal\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error\n    calc_angle_error(pitch_cd, yaw_cd, direction_reversed);\n\n    // get target distance in centimeters\n    float target_dist_cm = tracker.nav_status.target_distance;\n\n    // update pitch and yaw servos\n    if ((target_dist_cm <= tracker.g.min_distance_cm) || (tracker.g.min_distance_cm <= 0)) {\n        tracker.update_pitch_servo();\n        tracker.update_yaw_servo();\n    }\n}", "CodeBleu_score": 32.03218688768121}, {"code": "void Mode::update_auto(void){\n\t    // get target yaw and pitch rates from navigation controller\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float pitch = nav_status.pitch;\n    float yaw = nav_status.bearing + tracker.g.yaw_trim;\n\n    // check if the target is valid\n    bool target_valid = (nav_status.target_valid && nav_status.distance >= 0);\n\n    // check if the target is within the minimum distance\n    bool target_within_min_distance = (nav_status.distance <= tracker.g.min_distance_cm);\n\n    // check if the target is outside the maximum distance\n    bool target_outside_max_distance = (nav_status.distance > tracker.g.max_distance_cm);\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate the angle error\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // update pitch and yaw servos\n    if (target_valid || !tracker.g.min_distance_cm) {\n        tracker.update_pitch_servo(pitch);\n        tracker.update_yaw_servo(yaw);\n    }\n}", "CodeBleu_score": 54.538261600629355}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t    // Update the GPS data\n    gps.update();\n\n    // Check if the last message time has changed\n    if (last_message_time_ms != gps.last_message_time_ms()) {\n        last_message_time_ms = gps.last_message_time_ms();\n        // Check if the GPS status is at least 3D fix\n        if (gps.status() >= 3) {\n            // Decrement the countdown if it is greater than 0\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n            // Check if the countdown has reached 1\n            if (ground_start_countdown == 1) {\n                // Set the home location if the current location is valid\n                if (gps.location.isValid()) {\n                    set_home(gps.location.lat(), gps.location.lng());\n                } else {\n                    // Reset the countdown if the current location is invalid\n                    ground_start_countdown = 10;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 50.319618929273716}, {"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n    if (gps.last_message_time_ms() != last_gps_message_time_ms) {\n        last_gps_message_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= 3) {\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n            if (ground_start_countdown == 1) {\n                if (gps.location.isValid()) {\n                    set_home();\n                } else {\n                    ground_start_countdown = 3;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 49.125320246175264}, {"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n\n    if (gps.last_message_time_ms() != last_gps_message_time_ms) {\n        last_gps_message_time_ms = gps.last_message_time_ms();\n\n        // Update the ground start countdown\n        if (gps.status() >= GPS_OK_FIX_3D) {\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n\n            if (ground_start_countdown == 1) {\n                if (gps.location().is_valid()) {\n                    set_home();\n                } else {\n                    ground_start_countdown = 5;\n                }\n            }\n        } else {\n            ground_start_countdown = 5;\n        }\n    }\n}", "CodeBleu_score": 52.62302691704336}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // Set servo to the pitch angle\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, pitch);\n}", "CodeBleu_score": 7.22531243717177}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > 0) {\n        // Set the servo to 180 degrees\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, 18000);\n    } else {\n        // Set the servo to 0 degrees\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, 0);\n    }\n}", "CodeBleu_score": 20.98925090970535}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch < 0) {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, 1000);\n    } else {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, 1500);\n    }\n}", "CodeBleu_score": 20.944763492153243}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if ((checks_to_perform & ARMING_CHECK_BARO) == 0) {\n        return true;\n    }\n\n    // check baro reference\n    if (copter.g2.baro.get_ref_alt_source() == AP_Baro::AltSource::BARO_REF) {\n        // if using BARO_REF, then alt above home must be within 10m of alt above EKF origin\n        if (fabsf(copter.inertial_nav.get_position_z_up_cm() - copter.baro_alt) > BARO_MAX_ALT_ABOVE_HOME_CM) {\n            if (display_failure) {\n                gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Altitude disparity\");\n            }\n            check_failed(ARMING_CHECK_BARO);\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 51.59032431778612}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t", "CodeBleu_score": 2.150221949863861}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call parent class checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro reference is ok\n    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {\n        if (copter.ap.pre_arm_rc_check) {\n            // check baro vs inertial nav, start with baro use enabled\n            copter.g2.barometer.set_enabled(true);\n            if (!AP_Arming::barometer_checks(display_failure)) {\n                return false;\n            }\n\n            // check baro vs inertial nav, now disable baro use\n            copter.g2.barometer.set_enabled(false);\n            if (!AP_Arming::barometer_checks(display_failure)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 42.38702014237554}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AC_WPNav::TerrainSourceType::TERRAIN_FROM_RANGEFINDER) {\n        return false;\n    } else if (copter.wp_nav->get_terrain_source() == AC_WPNav::TerrainSourceType::TERRAIN_FROM_TERRAINDATABASE && copter.mode_rtl.get_alt_type() == ModeRTL::AltType::TERRAIN) {\n        return true;\n    } else {\n        return AP_Arming::terrain_database_required();\n    }\n}", "CodeBleu_score": 80.81602091110356}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_RANGEFINDER) {\n        return false;\n    }\n    if (copter.wp_nav->get_terrain_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_TERRAINDATABASE && copter.mode_rtl.get_alt_type() == ModeRTL::AltType::TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 88.16785608196383}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if the terrain source is from a rangefinder, then no terrain database is required\n    if (copter.wp_nav->get_terrain_source() == AP_Terrain::TerrainSourceType::TERRAIN_SOURCE_NONE) {\n        return false;\n    }\n    // if the terrain source is from the terrain database and the RTL altitude type is terrain, then a terrain database is required\n    if (copter.wp_nav->get_terrain_source() == AP_Terrain::TerrainSourceType::TERRAIN_SOURCE_TERRAINDATABASE && copter.mode_rtl.get_alt_type() == ModeRTL::AltType::ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    // otherwise, defer to the base class implementation of terrain_database_required\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 87.34464064669237}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // set attitude controller loop time\n    attitude_control->set_dt(scheduler().get_last_loop_time_s());\n\n    // run low level rate controllers that only require IMU data\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 26.868927675005448}, {"code": "void Copter::run_rate_controller(){\n\t    // set the loop time for attitude, position, and motor controllers\n    attitude_control->set_dt(scheduler.get_last_loop_time_s());\n    pos_control->set_dt(scheduler.get_last_loop_time_s());\n    motors->set_dt(scheduler.get_last_loop_time_s());\n\n    // run low-level rate controllers that require only IMU data\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 46.30037086006175}, {"code": "void Copter::run_rate_controller(){\n\t    // set the loop time for attitude, position, and motor controllers\n    attitude_control->set_dt(scheduler.get_last_loop_time_s());\n    pos_control->set_dt(scheduler.get_last_loop_time_s());\n    motors->set_dt(scheduler.get_last_loop_time_s());\n\n    // run low level rate controllers that only require IMU input\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 46.30037086006175}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    Location target_loc;\n\n    if (!get_wp(target_loc)) {\n        return false;\n    }\n\n    if (old_loc.same_loc_as(target_loc) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n        set_target_location(target_loc);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 64.58668078754914}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    Location target_loc = flightmode->get_wp();\n    if (target_loc == new_loc &&\n        old_loc.get_alt_frame() == new_loc.get_alt_frame() &&\n        old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 65.01450194781681}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    Location target_loc;\n\n    if (!flightmode->get_wp(target_loc)) {\n        return false;\n    }\n\n    if (!old_loc.same_loc_as(target_loc) || old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    set_target_location(target_loc);\n\n    return true;\n}", "CodeBleu_score": 74.99040086687508}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // change mode\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        // return to flight mode switch if already in the correct mode\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 69.34280080899627}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // engage mode (if not possible we remain in current flight mode)\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else {\n        // return to flight mode switch if we are currently in this mode\n        if (copter.flightmode->mode_number() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 73.49815815991316}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // change mode\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        // return to flight mode switch's default mode.\n        // We use this in the event the user levels a switch higher than 1000.\n        // That way the switch can be used to select modes higher than 1000\n        // (from the transmitter's point of view) without having to give\n        // the throttle raise and lower inputs.\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 69.34280080899627}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // get_control_in returns a value between -4500 and 4500\n    // convert to radians\n    float roll_trim = ToRad(channel_roll->get_control_in() / 4500.0f);\n    float pitch_trim = ToRad(channel_pitch->get_control_in() / 4500.0f);\n\n    // add trim values to AHRS\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(DATA_SAVEWP_MSG);\n\n    // send message to GCS\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 68.5652144379361}, {"code": "void Copter::save_trim(){\n\t    // get roll and pitch control inputs\n    float roll_in = channel_roll->get_control_in();\n    float pitch_in = channel_pitch->get_control_in();\n\n    // convert control inputs to radians\n    float roll_rad = ToRad(roll_in);\n    float pitch_rad = ToRad(pitch_in);\n\n    // add trim values to AHRS\n    ahrs.add_trim(roll_rad, pitch_rad);\n\n    // log event and send confirmation message\n    Log_Write_Event(DATA_SAVEWP_MSG);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 60.47379437882703}, {"code": "void Copter::save_trim(){\n\t    // get roll and pitch control inputs in centidegrees\n    float roll_in = channel_roll->get_control_in();\n    float pitch_in = channel_pitch->get_control_in();\n\n    // convert control inputs to radians\n    float roll_rad = ToRad(roll_in * 0.01f);\n    float pitch_rad = ToRad(pitch_in * 0.01f);\n\n    // add trim values to AHRS\n    ahrs.add_trim(roll_rad, pitch_rad);\n\n    // log event and send confirmation message\n    Log_Write_Event(DATA_SAVEWP_MSG);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 60.03004681736026}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // Get the copter's velocity\n    Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // Calculate the speed squared\n    float speed_sq = vel.xy().length_squared();\n\n    // Check if the copter's position is valid and the speed exceeds a minimum threshold\n    if (copter.position_ok && speed_sq > MIN_SPEED_SQUARED) {\n        // Update the look-ahead yaw angle using the arctangent of the velocity components\n        look_ahead_yaw = atan2f(-vel.y, -vel.x);\n    }\n\n    // Return the computed look-ahead yaw angle\n    return look_ahead_yaw;\n}", "CodeBleu_score": 54.28312377349576}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // Get the copter's velocity\n    const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // Calculate the speed squared\n    const float speed_sq = vel.xy().length_squared();\n\n    // Check if the copter's position is valid and the speed exceeds a minimum threshold\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQUARED)) {\n        // Update the look-ahead yaw angle using the arctangent of the velocity components\n        look_ahead_yaw = atan2f(-vel.y, -vel.x);\n    }\n\n    // Return the computed look-ahead yaw angle\n    return look_ahead_yaw;\n}", "CodeBleu_score": 70.83948702003995}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.xy().length_squared();\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQUARED)) {\n        look_ahead_yaw = atan2f(-vel.y, -vel.x);\n    }\n    return look_ahead_yaw;\n}", "CodeBleu_score": 66.47231617354171}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // check if arming checks are disabled\n    if (method == AP_Arming::Method::NONE) {\n        return true;\n    }\n\n    // check if the watchdog was armed\n    if (hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // check if rudder arming is disabled\n    if (get_rudder_arming_type() == RUDDER_ARMING_DISABLED) {\n        check_failed(ARMING_CHECK_PARAMETERS, display_failure, \"Rudder arming disabled\");\n        return false;\n    }\n\n    // check if the throttle is not zero\n    if (plane.get_throttle_input() > 0) {\n        check_failed(ARMING_CHECK_PARAMETERS, display_failure, \"Throttle not zero\");\n        return false;\n    }\n\n    // call the parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 63.01475799989389}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arming_disabled()) {\n            return false;\n        }\n        if (!is_zero(get_rudder_arming_type())) {\n            if (!is_zero(plane.get_throttle_input())) {\n                check_failed(display_failure, \"Must be at 0 throttle\");\n                return false;\n            }\n        }\n    }\n\n    if (hal.util->was_watchdog_armed()) {\n        // if we've already armed then skip the checks, except if arming\n        // is disabled:\n        if (method != AP_Arming::Method::NONE) {\n            return true;\n        }\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 68.40845703297418}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // check if rudder arming is disabled or if the throttle is not zero\n    if (method == AP_Arming::Method::RUDDER) {\n        if (is_zero(get_rudder_arming_type())) {\n            check_failed(ARMING_CHECK_PARAMETERS, display_failure, \"Rudder arming disabled\");\n            return false;\n        }\n        if (!is_zero(plane.get_throttle_input())) {\n            check_failed(ARMING_CHECK_PARAMETERS, display_failure, \"Non-zero throttle\");\n            return false;\n        }\n    }\n\n    // bypass checks if arming checks are disabled or if the watchdog was armed\n    if (method == AP_Arming::Method::NONE || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // call the parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 67.16619583482438}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (hal.util->was_watchdog_armed()) {\n        // don't allow arming if we were armed with the watchdog\n        return false;\n    }\n\n    // return true if already armed\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    if (do_arming_checks && !all_checks_passing(method)) {\n        return false;\n    }\n\n    // if checks are disabled (can_skip_checks) then arming is\n    // always allowed, except for low battery ports which\n    // require the pilot to confirm arming. We allow arming\n    // via the ground station but disallow arming via the\n    // switch. This is to ensure a pilot doesn't accidentally arm\n    // the plane via the switch.\n    if (!do_arming_checks &&\n        method != AP_Arming::Method::RUDDER &&\n        plane.battery.has_failsafed()) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Failsafe Battery\");\n        return false;\n    }\n\n    // all arming checks passed so lets arm\n    plane.set_armed(true);\n\n    // update home location\n    plane.update_home();\n\n    // update current location\n    plane.update_current_loc();\n\n    // update the armed flag\n    change_arm_state();\n\n    // set a flag to note we are delaying the arming checks\n    plane.set_delayed_arming_check(true);\n\n    // send arm notification to ground station\n    send_arm_disarm_statustext();\n\n    // set and save the home location in EEPROM\n    plane.ahrs.set_home(plane.home);\n\n    // return success\n    return true;\n}", "CodeBleu_score": 57.10788410714772}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // remember home to prevent accidental arming\n    plane.update_home();\n    AP_Arming::arm\n\n    // remember current location to prevent accidental arming\n    plane.update_current_loc();\n\n    // send arm status text\n    send_arm_disarm_statustext();\n\n    // set AHRS home location\n    plane.ahrs.set_home(plane.home);\n\n    // update current location\n    plane.update_current_loc();\n\n    // change arm state\n    change_arm_state();\n\n    // set delay arming flag\n    plane.set_delay_arming(true);\n\n    // return success\n    return true;\n}", "CodeBleu_score": 70.28085863503114}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (sub.motors.armed()) {\n        return true;\n    }\n\n    // if disarm button is not configured, do not allow arming\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm not configured\");\n        }\n        return false;\n    }\n\n    // call parent class checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.9958753477824}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (sub.motors.armed()) {\n        return true;\n    }\n\n    // check if disarm function is assigned\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm not configured\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.9958753477824}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // exit immediately if already armed\n    if (sub.motors.armed()) {\n        return true;\n    }\n\n    // if disarm button is not configured, display failure and exit\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm not configured\");\n        }\n        return false;\n    }\n\n    // call parent class checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.05145477444253}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw() - y * ahrs.sin_yaw();\n    float ne_y = x * ahrs.sin_yaw() + y * ahrs.cos_yaw();\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 84.29194785321683}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // convert to radians\n    float angle_deg = packet.param1;\n    float angle_rad = radians(angle_deg);\n    // a negative condition_value means no change to current angle\n    float change_rad = radians(packet.param4);\n\n    // get current yaw target\n    float curr_angle_rad = sub.ahrs.get_yaw();\n\n    if (is_zero(packet.param4)) {\n        // param4 is zero so use the current attitude target\n        curr_angle_rad = sub.attitude_control->get_att_target_euler_cd().z;\n    }\n\n    // check we are within 10 degrees of the target yaw\n    if (!is_zero(change_rad) && !is_equal(curr_angle_rad, angle_rad) && fabsf(wrap_PI(angle_rad - curr_angle_rad)) > radians(10.0f)) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check param1 is within acceptable range\n    if (fabsf(angle_rad) > radians(360.0f)) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // send yaw to waypoint controller\n    sub.mode_auto.set_auto_yaw_look_at_heading(angle_rad, false, 0, sub.g.wp_navalt_min_dist, sub.g.wp_navalt_max_dist, sub.g.wp_navalt_speed);\n\n    // log mode change\n    if (sub.g.log_mode_changes) {\n        AP::logger().Write_Mode(sub.control_mode, sub.mode_reason);\n    }\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 32.23721275083255}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // sanity check params\n    if (!is_equal(packet.param1, 0.0f) || !is_zero(packet.param2) || !is_zero(packet.param3) || !is_zero(packet.param4)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set yaw direction\n    sub.mode_auto.set_yaw_look_at_heading(packet.param4);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.34871073543901}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // param1 : target angle [0-360]\n    // param2 : speed during change [deg per second]\n    // param3 : direction (-1:ccw, +1:cw)\n    // param4 : relative offset (1) or absolute angle (0)\n\n    // exit immediately if vehicle is not in Guided mode\n    if (sub.control_mode != GUIDED) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // set guided mode yaw to a location or angle\n    sub.guided_set_angle(ROTATION_PITCH, packet.param1 * 100, packet.param2 * 100, (MAV_MOUNT_MODE) packet.param4, (MAV_GUIDED_MODE) packet.param3);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 36.350361886701386}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode != AUTO && sub.control_mode != GUIDED) {\n        return 0;\n    }\n    return wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination() / 2);\n}", "CodeBleu_score": 57.68040587887525}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode != AUTO && sub.control_mode != GUIDED) {\n        return 0;\n    }\n    return wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination()) / 2;\n}", "CodeBleu_score": 62.06239150494079}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == AUTO || sub.control_mode == GUIDED) {\n        return wrap_360_cd(sub.nav_controller->target_bearing_cd()) / 200;\n    }\n    return 0;\n}", "CodeBleu_score": 70.49942290548832}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us : AP_HAL::micros64(),\n            id      : (uint16_t)id,\n            value   : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 94.80406425803058}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data {\n            LOG_PACKET_HEADER;\n            LOG_PACKET_FIELD(id, id);\n            LOG_PACKET_FIELD(value, value);\n        };\n        struct log_Data pkt = {\n            LOG_PACKET_HEADER_INIT(MASK_LOG_ANY),\n            .id = id,\n            .value = value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 62.04496012266583}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (!should_log(id)) {\n        return;\n    }\n\n    uint64_t time = AP_HAL::micros64();\n\n    struct PACKED log_Data_Int {\n        LOG_PACKET_HEADER;\n        uint64_t time_us;\n        uint8_t id;\n        int32_t data_value;\n    };\n\n    struct log_Data_Int pkt = {\n        LOG_PACKET_HEADER_INIT(LOG_DATA_INT_MSG),\n        time: time,\n        id: (uint8_t)id,\n        data_value: value\n    };\n\n    logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n}", "CodeBleu_score": 65.07178760276014}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if disarmed, set home to current location\n    if (!motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        // if armed set home to current ekf location (this can fail if ekf origin not set)\n        if (!set_home_to_current_location(false)) {\n            // ignore failure\n        }\n    }\n}", "CodeBleu_score": 67.73302574595616}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set()) {\n        return;\n    }\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 56.058490264194816}, {"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if disarmed, set home to current location\n    if (!motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        // if armed set home to current ekf location (this can be called at any time as the EKF\n        // will update the home location when the home location is set or the EKF origin moves)\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 52.22267611140282}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // initialise waypoint and spline controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // set the destination\n    Vector3f stopping_point;\n    sub.wp_nav.get_wp_stopping_point(stopping_point);\n    sub.wp_nav.set_wp_destination(stopping_point, false);\n\n    // initialise yaw\n    // set auto yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 79.7227331851444}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set to position control mode\n    sub.guided_mode = SubMode::WP;\n\n    // initialise waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // initialise wpnav to stopping point\n    Vector3f stopping_point;\n    sub.wp_nav.get_wp_stopping_point(stopping_point);\n\n    // no need to check return status because terrain data is not used\n    sub.wp_nav.set_wp_destination(stopping_point, false);\n\n    // initialise yaw\n    // set auto yaw mode\n    sub.set_auto_yaw_mode(sub.get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 79.36005012096092}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set to position control mode\n    sub.guided_mode = SubMode::WP;\n\n    // initialise waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // initialise guided start time and position as reference for limit checking\n    guided_limit_init_time_and_pos();\n\n    // set yaw state\n    sub.set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 38.11203082609201}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    position_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise the vertical position controller\n    position_control->init_z_controller();\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 38.16435939266423}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    position_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n    position_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n\n    // initialise the vertical position controller\n    if (!position_control->is_active_z()) {\n        position_control->init_z_controller();\n    }\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 60.52989582331946}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    position_control->set_max_speed_accel_z(-sub.get_pilot_speed_dn(), sub.wp_nav.get_default_speed_up(), sub.wp_nav.get_default_speed_up(), sub.wp_nav.get_accel_z());\n\n    // initialize vertical speed and acceleration\n    position_control->set_max_speed_accel_xy(sub.wp_nav.get_default_speed_xy(), sub.wp_nav.get_default_speed_xy(), sub.wp_nav.get_accel_xy());\n\n    // initialise the vertical position controller\n    if (!position_control->is_active_z()) {\n        position_control->init_z_controller();\n    }\n\n    // initialise the lateral position controller\n    if (!position_control->is_active_xy()) {\n        position_control->init_xy_controller();\n    }\n\n    // set guided_vel_z_p to pos controller's alt max vel\n    // To-Do: make the guided vel controller smoother to prevent jerkiness\n    guided_vel_z_p = position_control->get_max_speed_accel_z_p();\n\n    // set yaw to auto (i.e. vehicle will slowly turn to heading instead of holing heading)\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 48.20290461554338}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // Check if a timeout has been exceeded\n    if (guided_limit.timeout_ms > 0 &&\n        millis() - guided_limit.start_millis > guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // Check if the current altitude is below a minimum or above a maximum threshold\n    if (!guided_limit.alt_min_cm.is_zero() &&\n        inertial_nav.get_altitude() < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (!guided_limit.alt_max_cm.is_zero() &&\n        inertial_nav.get_altitude() > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // Check if the horizontal distance moved exceeds a specified limit\n    if (!guided_limit.horiz_max_cm.is_zero() &&\n        get_horizontal_distance_cm(inertial_nav.get_position_neu_cm(),\n                                   guided_limit.start_pos.xy()) >\n            guided_limit.horiz_max_cm) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 56.49353966264176}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // Check if the current position is within the limits\n    if (!guided_limit.within_limits()) {\n        // If not, set the guided mode's state to GUIDED_MODE_REACHED_LIMIT\n        guided_limit.reached_limit = true;\n        return true;\n    }\n\n    // Check if the current position is within the minimum and maximum altitudes\n    if (!guided_limit.within_min_max_alt()) {\n        // If not, set the guided mode's state to GUIDED_MODE_REACHED_LIMIT\n        guided_limit.reached_limit = true;\n        return true;\n    }\n\n    // Check if the horizontal distance moved exceeds the specified limit\n    if (guided_limit.past_limit_xy()) {\n        // If so, set the guided mode's state to GUIDED_MODE_REACHED_LIMIT\n        guided_limit.reached_limit = true;\n        return true;\n    }\n\n    // If none of the above conditions are met, return false\n    return false;\n}", "CodeBleu_score": 29.03115029020927}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // Check if timeout has been exceeded\n    if (guided_limit.timeout_ms > 0 &&\n        millis() - guided_limit.start_time >= guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // Check if current altitude is below min or above max\n    if (!is_zero(guided_limit.alt_min) &&\n        inertial_nav.get_altitude() < guided_limit.alt_min) {\n        return true;\n    }\n    if (!is_zero(guided_limit.alt_max) &&\n        inertial_nav.get_altitude() > guided_limit.alt_max) {\n        return true;\n    }\n\n    // Get current horizontal distance from start position\n    const Vector3f& curr_pos = inertial_nav.get_position_neu_cm();\n    uint32_t dist_cm = get_horizontal_distance_cm(curr_pos.xy(),\n                                                   guided_limit.start_pos.xy());\n\n    // Check if distance from start is greater than maximum distance\n    if (!is_zero(guided_limit.horiz_max) &&\n        dist_cm >= guided_limit.horiz_max) {\n        return true;\n    }\n\n    // If we got here, all checks passed\n    return false;\n}", "CodeBleu_score": 67.70460006633677}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}, {"code": "bool Sub::verify_motor_test(){\n\t    // Check if the motor test is enabled\n    if (!motor_test.enabled) {\n        return true;\n    }\n\n    // Check if the motor test requests are received within the timeout period\n    if (AP_HAL::millis() - motor_test.last_recv_ms > 500) {\n        // Send a timeout message\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n\n        // Disable the motor test\n        motor_test.enabled = false;\n\n        // Disarm the system\n        AP::arming().disarm();\n\n        // Record the failure time\n        motor_test.failed_ms = AP_HAL::millis();\n\n        // Return false to indicate failure\n        return false;\n    }\n\n    // Return true to indicate success\n    return true;\n}", "CodeBleu_score": 64.23188783074495}, {"code": "bool Sub::verify_motor_test(){\n\t    // get the time in milliseconds\n    uint32_t tnow = AP_HAL::millis();\n\n    // check if the motor test is still active\n    if (!motor_test.running) {\n        return true;\n    }\n\n    // check if the motor test has timed out\n    if (tnow - motor_test.last_run_ms > 500) {\n        // send a timeout message\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n\n        // set the pass flag to false\n        motor_test.pass = false;\n\n        // disable the motor test\n        motor_test.running = false;\n\n        // disarm the system\n        AP::arming().disarm();\n\n        // record the failure time\n        motor_test.failed_ms = tnow;\n\n        // return false\n        return false;\n    }\n\n    // check if the motor test has completed\n    if (motor_test.throttle_pwm == motor_test.throttle_max && motor_test.motor_running) {\n        // send a success message\n        gcs().send_text(MAV_SEVERITY_INFO, \"Motor test completed successfully\");\n\n        // set the pass flag to true\n        motor_test.pass = true;\n\n        // disable the motor test\n        motor_test.running = false;\n\n        // return true\n        return true;\n    }\n\n    // return true\n    return true;\n}", "CodeBleu_score": 56.375170402713316}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    int16_t roll_cd = wp_nav.get_roll();\n    int16_t pitch_cd = wp_nav.get_pitch();\n\n    // constrain target forward/lateral values\n    // roll_cd is reversed (set above)\n    roll_cd = constrain_int16(roll_cd, -aparm.angle_max, aparm.angle_max);\n    pitch_cd = constrain_int16(pitch_cd, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out = (float)roll_cd/(float)aparm.angle_max;\n    forward_out = (float)pitch_cd/(float)aparm.angle_max;\n}", "CodeBleu_score": 69.47806032847849}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav.get_roll();\n    forward_out = wp_nav.get_pitch();\n\n    // constrain target angles\n    lateral_out = constrain_int16(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_int16(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out  /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 47.76675200954935}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets from wp_nav in centidegrees\n    int16_t roll_cd = wp_nav.get_roll();\n    int16_t pitch_cd = wp_nav.get_pitch();\n\n    // constrain targets within a specified maximum angle range\n    roll_cd = constrain_int16(roll_cd, -aparm.angle_max, aparm.angle_max);\n    pitch_cd = constrain_int16(pitch_cd, -aparm.angle_max, aparm.angle_max);\n\n    // normalize targets\n    lateral_out = 0.0f;\n    forward_out = 0.0f;\n    if (roll_cd > 0) {\n        lateral_out = (float)roll_cd / aparm.angle_max;\n    } else if (roll_cd < 0) {\n        lateral_out = (float)roll_cd / -aparm.angle_max;\n    }\n    if (pitch_cd > 0) {\n        forward_out = (float)pitch_cd / aparm.angle_max;\n    } else if (pitch_cd < 0) {\n        forward_out = (float)pitch_cd / -aparm.angle_max;\n    }\n}", "CodeBleu_score": 59.552435167763385}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t    // update barometer data\n    barometer.update();\n\n    // update barometer calibration\n    if (barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n\n    // update sensor health status\n    if (depth_sensor) {\n        barometer.healthy = depth_sensor->healthy;\n    }\n}", "CodeBleu_score": 71.84640214821896}, {"code": "void Sub::read_barometer(){\n\t    // return immediately during low battery\n    if (!motors.armed() && (failsafe.radio || failsafe.battery)) {\n        return;\n    }\n\n    // update barometric altitude estimate\n    barometer.update();\n\n    // if we are using the range finder for altitude\n    if (rangefinder_state.enabled && (rangefinder_state.alt_ok || !sonar_enabled)) {\n        sonar_update();\n    }\n\n    // only recalculate altitude when we don't have an absolute position reference\n    if (ahrs.get_home().alt == 0 && barometer.get_status() != Barometer::BARO_OUT_OF_RANGE) {\n        if (sonar_enabled && sonar.status() == RangeFinder::RangeFinder_Good) {\n            // use range finder altitude when it is valid\n            barometer.set_barometric_altitude(sonar.distance_cm() * 0.01f);\n        } else if (rangefinder_state.enabled && rangefinder_state.alt_ok) {\n            // use rangefinder altitude when it's valid\n            barometer.set_barometric_altitude(rangefinder_state.alt_cm * 0.01f);\n        } else {\n            // otherwise estimate it via baro\n            est_altitude();\n        }\n    }\n\n    // only use baro altitude when rangefinder health is poor\n    if (rangefinder_state.enabled && rangefinder_state.alt_healthy) {\n        barometer.set_barometric_altitude(sonar.distance_cm() * 0.01f);\n    }\n\n    // new data from Barometer or sonar is available\n    barometer.update_calibration();\n\n    if (barometer.get_status() != Barometer::BARO_OUT_OF_RANGE) {\n        if (should_log(MASK_LOG_BARO)) {\n            DataFlash.Log_Write_Baro(barometer);\n        }\n    }\n}", "CodeBleu_score": 33.77829337452113}, {"code": "void Sub::read_barometer(){\n\t    // update barometer health\n    barometer.update_health();\n    barometer.update();\n    if (barometer.healthy()) {\n        barometer.update_calibration();\n    }\n\n    if (barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n\n    if (depth_sensor.enabled()) {\n        depth_sensor.update_health(barometer.get_altitude());\n    }\n}", "CodeBleu_score": 65.8449186241934}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf is not in a good mode\n    if (ahrs.healthy() && !ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // return true if disarmed\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // return true if using inertial nav and the origin is set\n    if (ahrs.have_inertial_nav() && ahrs.get_origin().xyz.is_zero()) {\n        return true;\n    }\n\n    // return false if ekf position is too far from origin\n    if (ahrs.get_position().xyz.is_zero()) {\n        return false;\n    }\n\n    // return false if ekf horizontal velocity is too high\n    if (ahrs.groundspeed() > EKF_HORIZONTAL_VELOCITY_MAX) {\n        return false;\n    }\n\n    // if ekf is not in constant position mode, accept a predicted horizontal position\n    if (ahrs.get_vert_pos_state() != VertPosState::POS_FIXED_APPROACH) {\n        return true;\n    }\n\n    // return true if ekf is in constant position mode and origin has been set\n    return (ahrs.get_origin().xyz.is_zero());\n}", "CodeBleu_score": 53.6228854070819}, {"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf is not used\n    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // return true if not arming or in loiter\n    if (!motors.armed() || (control_mode == LAND || control_mode == RTL || control_mode == AUTO || control_mode == ACRO || control_mode == FLOWHOLD)) {\n        return true;\n    }\n\n    // ensure the inertial nav has enough data\n    if (!ahrs.get_filter_status().flags.horiz_pos_abs || !ahrs.get_filter_status().flags.pred_horiz_pos_abs) {\n        return false;\n    }\n\n    // check for ekf position being unhealthy\n    if (!ahrs.healthy()) {\n        return false;\n    }\n\n    // check position estimate.  do not allow ekf position estimate to drift too far\n    // requires a more recent position estimate than velocity estimate\n    if (ekf_position_estimate()) {\n        // position estimate must be within 1m of current position\n        const float position_error_sq = sq(current_loc.lng - inertial_nav.get_position().lng) + sq(current_loc.lat - inertial_nav.get_position().lat);\n        return (position_error_sq < sq(1.0f));\n    }\n\n    // if we got this far we should return true\n    return true;\n}", "CodeBleu_score": 51.478579140821566}, {"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf not yet available\n    Location temp_loc;\n    return ahrs.get_location(temp_loc);\n}", "CodeBleu_score": 16.399069816658564}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!rover.control_mode->requires_position() && !rover.control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure ahrs is ready\n    if (!ahrs.pre_arm_check()) {\n        check_failed(display_failure, \"AHRS not healthy\");\n        return false;\n    }\n\n    // check ekf position estimate\n    if (!rover.ekf_position_ok()) {\n        check_failed(display_failure, \"EKF estimate not ok\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 56.341318887636405}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // check EKF pre-arm checks\n    if (!rover.control_mode->requires_position() && !rover.control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // Check the EKF position estimate is ok\n    if (!rover.ekf_position_ok()) {\n        check_failed(display_failure, \"EKF failsafe\");\n        return false;\n    }\n\n    // if we have a position estimate then check it is within acceptable limits\n    if (rover.current_loc.lat != 0 && rover.current_loc.lng != 0) {\n        // check pos_horiz_accuracy\n        if (rover.gps.horizontal_accuracy() > rover.g.pos_horiz_accuracy) {\n            check_failed(display_failure, \"PosHorizAccuracy %.1fm\", (double)rover.gps.horizontal_accuracy());\n            return false;\n        }\n        // check pos_vert_accuracy\n        if (fabsf(rover.current_loc.alt - rover.ekf_altitude) > rover.g.pos_vert_accuracy) {\n            check_failed(display_failure, \"PosVertAccuracy %.1fm\", (double)fabsf(rover.current_loc.alt - rover.ekf_altitude));\n            return false;\n        }\n    }\n\n    // if we have a valid position, check if it is within range of home\n    if (rover.current_loc.lat != 0 && rover.current_loc.lng != 0) {\n        if (!rover.ahrs.pre_arm_check()) {\n            check_failed(display_failure, \"AHRS not healthy\");\n            return false;\n        }\n    }\n\n    // if we've gotten this far the GPS must be ok\n    return true;\n}", "CodeBleu_score": 62.80906735972147}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // check if ekf has started without GPS\n    if (!rover.control_mode->requires_position() && !rover.control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure ahrs is ready\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: AHRS not healthy\");\n        }\n        return false;\n    }\n\n    // ensure ekf position is ok\n    if (rover.ekf_position_ok()) {\n        return true;\n    }\n\n    if (display_failure) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: EKF position check failed\");\n    }\n    return false;\n}", "CodeBleu_score": 56.43947136642795}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!rover.control_mode->do_user_takeoff_start(method == AP_Arming::Method::RUDDER)) {\n        return false;\n    }\n\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // remember home is set after arming for auto\n    rover.g2.smart_rtl.set_home(true);\n\n    // initialise simple heading\n    rover.mode_simple.init_heading();\n\n    // record home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    // update soft armed flag\n    update_soft_armed();\n\n    // log arming to dataflash\n    AP::logger().Write_Event(LogEvent::ARMING_RUDDER);\n\n    // send text of action to ground stations\n    send_arm_disarm_notice(ARMING_MESSAGE, method);\n\n    return true;\n}", "CodeBleu_score": 72.63655651592907}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t    // If charging is allowed, but should not continue, disable charging and record the time\n    if (charging_allowed && !checkShouldCharge()) {\n        digitalWrite(PIN_CHARGE_ENABLE, LOW);\n        charging_disabled_time = millis();\n        return;\n    }\n\n    // If charging is not allowed, retry enabling charging after a specified delay\n    if (!charging_allowed && (millis() - charging_disabled_time) > CHARGING_DISABLED_DELAY) {\n        if (checkShouldCharge()) {\n            digitalWrite(PIN_CHARGE_ENABLE, HIGH);\n            charging_disabled_time = 0;\n        }\n    }\n}", "CodeBleu_score": 42.01607803129623}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (!charging_enabled) {\n                charging_enabled = true;\n                digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n            }\n        } else {\n            if (charging_enabled) {\n                charging_enabled = false;\n                digitalWrite(CHARGE_ENABLE_PIN, LOW);\n                last_charging_disabled_time = millis();\n            }\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            digitalWrite(CHARGE_ENABLE_PIN, LOW);\n            last_charging_disabled_time = millis();\n        } else {\n            if (millis() - last_charging_disabled_time > CHARGING_RETRY_DELAY) {\n                if (checkShouldCharge()) {\n                    charging_enabled = true;\n                    digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 63.527829349835706}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (charging_enabled) {\n                charging_enabled = false;\n                charging_disabled_time = millis();\n            }\n        } else {\n            charging_enabled = true;\n        }\n    } else {\n        if (millis() - charging_disabled_time > CHARGING_DISABLED_RETRY_TIME) {\n            if (checkShouldCharge()) {\n                charging_allowed = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 55.00384992556151}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t    if (ros::ok() && size >= 4) {\n        uint16_t crc = CRC16.ccitt((uint8_t *)message, size - 2);\n        memcpy((uint8_t *)message + size - 2, &crc, 2);\n        packetSerial.send((uint8_t *)message, size);\n    }\n}", "CodeBleu_score": 45.69381340737706}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (ros::ok() && size >= 4) {\n        uint16_t crc = CRC16.ccitt((uint8_t *) message, size - 2);\n        memcpy((uint8_t *) message + size - 2, &crc, 2);\n        packetSerial.send((uint8_t *) message, size);\n    }\n}", "CodeBleu_score": 50.64206374977914}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros::ok()) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    packetSerial.send((uint8_t *)message, size);\n    packetSerial.send((uint8_t *)&crc, sizeof(crc));\n  }\n}", "CodeBleu_score": 34.906009180290035}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.flush();\n  if (initializeSoundModule() && getNumberOfTracks()) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 34.08348600863005}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t  if (active_sounds.size() == 0) {\n    return active_sounds.size();\n  }\n  if (myMP3.isPlaying()) {\n    return active_sounds.size();\n  }\n  else {\n    myMP3.play(active_sounds.back());\n    active_sounds.pop_back();\n    return active_sounds.size();\n  }\n}", "CodeBleu_score": 48.508064965240926}, {"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0) {\n        return 0;\n    }\n    if (myMP3.isPlaying()) {\n        return active_sounds.size();\n    }\n    myMP3.play(active_sounds.back().c_str());\n    active_sounds.pop_back();\n    return active_sounds.size();\n}", "CodeBleu_score": 48.890418079421785}, {"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0) {\n        return 0;\n    }\n\n    if (myMP3.isPlaying()) {\n        return active_sounds.size();\n    }\n\n    MP3Sound mp3 = active_sounds.back();\n    active_sounds.pop_back();\n    mp3.play();\n    return active_sounds.size();\n}", "CodeBleu_score": 47.391466765268696}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      WbAbstractCamera *ac = (WbAbstractCamera *)d;\n      if (ac->m_memory_mapped_file) {\n        if (wb_memory_mapped_file_unmap(ac->m_memory_mapped_file) == -1)\n          fprintf(stderr, \"Error while unmapping memory-mapped file.\n\");\n        wb_memory_mapped_file_destroy(ac->m_memory_mapped_file);\n      }\n      ac->m_memory_mapped_file = wb_memory_mapped_file_create(r->readString());\n      if (wb_memory_mapped_file_map(ac->m_memory_mapped_file) == -1) {\n        fprintf(stderr, \"Error while mapping memory-mapped file.\n\");\n        wb_memory_mapped_file_destroy(ac->m_memory_mapped_file);\n        ac->m_memory_mapped_file = NULL;\n      }\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 44.664787688327024}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (camera->m_memory_mapped_file != NULL) {\n        if (camera->m_memory_mapped_file->m_filename)\n          free(camera->m_memory_mapped_file->m_filename);\n        free(camera->m_memory_mapped_file);\n        camera->m_memory_mapped_file = NULL;\n      }\n\n      camera->m_memory_mapped_file = (WbMemoryMappedFile *)malloc(sizeof(WbMemoryMappedFile));\n      camera->m_memory_mapped_file->m_filename = (char *)wb_request_get_string(r);\n      camera->m_memory_mapped_file->m_size = wb_request_get_int(r);\n      camera->m_memory_mapped_file->m_data = wb_request_get_data(r);\n      camera->m_memory_mapped_file->m_data_size = wb_request_get_data_size(r);\n      break;\n\n    default:\n      return false;\n  }\n  return true;\n}", "CodeBleu_score": 46.14277248219099}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_abstract_camera_cleanup_memory_mapped_file(d);\n      wb_abstract_camera_setup_memory_mapped_file(d, r);\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 35.7933031486465}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  wb_mutex_lock(d->mutex);\n  if (d->image)\n    height = d->image->height;\n  else\n    height = -1;\n  wb_mutex_unlock(d->mutex);\n  return height;\n}", "CodeBleu_score": 43.239168946674965}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  wb_robot_mutex_lock();\n  if (d->tag == WB_DEVICE_CAMERA)\n    height = d->data.camera->height;\n  else\n    height = -1;\n  wb_robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 50.371871590954306}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  wb_robot_mutex_lock();\n  if (d->image_height)\n    height = d->image_height;\n  else\n    height = -1;\n  wb_robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 52.37874942902141}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n\n  robot_mutex_lock();\n  accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    fprintf(stderr, \"Error: %s: invalid tag.\n\", __FUNCTION__);\n  }\n  robot_mutex_unlock();\n\n  return sampling_period;\n}", "CodeBleu_score": 56.998431717799704}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n    robot_mutex_unlock();\n    return sampling_period;\n  }\n  robot_mutex_unlock();\n  fprintf(stderr, \"Error: %s: invalid device tag.\n\", __FUNCTION__);\n  return 0;\n}", "CodeBleu_score": 63.2518554585101}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  robot_mutex_lock();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s: invalid tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 60.50791483277016}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 39.817711736096165}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.37179132599584}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString(dms);\n    free(dms);\n    return dmsString;\n}", "CodeBleu_score": 40.9693929303718}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT (g,\"bad geom\");\n    dUASSERT (g->_class == dBoxClass,\"must be a box\");\n    dReal p[3];\n    p[0] = x;\n    p[1] = y;\n    p[2] = z;\n    dGeomBoxGetTangentPlane1 (g,p,plane);\n}", "CodeBleu_score": 13.486042956521704}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dUASSERT (g,\"bad geom argument\");\n  dUASSERT (plane,\"bad plane argument\");\n  dGeomBoxGetLengths (g,plane+0,plane+1,plane+2);\n  plane[3] = -dCalcVectorDot3_41 (plane,&x);\n}", "CodeBleu_score": 9.84640499956286}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t   sBoxImmersionData data;\n\n   dIASSERT (box);\n   dIASSERT (box->body);\n   dIASSERT (fluidPlane);\n   dIASSERT (immersion);\n\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.immersion = immersion;\n   data.flags = flags;\n   data.performImmersionChecking = data.performImmersionChecking;\n\n   return dImmerseBoxData (&data);\n}", "CodeBleu_score": 45.65872657516052}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t   dIASSERT (box);\n   dIASSERT (box->body);\n   dIASSERT (box->body->flags & dxBodyFlagEnabled);\n   dIASSERT (flags == (flags & (dIMMERSE_SURFACE | dIMMERSE_BOX_SURFACE)));\n\n   sBoxImmersionData data;\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.immersion = immersion;\n   data.flags = flags;\n\n   return dGeomBoxImmersion (box->geom, box->body->posr.pos, box->body->posr.R,\n         fluidPlane, flags, immersion, &data.performImmersionChecking);\n}", "CodeBleu_score": 44.67083586983704}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t   sBoxImmersionData data;\n\n   dUASSERT (box, \"bad box argument\");\n   dUASSERT (box->body, \"box has no body\");\n   dUASSERT ((flags & ~(dIMMERSE_SURFACE_INCLUDED | dIMMERSE_BOX_INCLUDED)) == 0,\n         \"bad flags argument\");\n\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.immersion = immersion;\n   data.flags = flags;\n\n   data.performImmersionChecking = dImmerseBox_performImmersionChecking;\n\n   return dImmerseBox_performImmersionChecking (&data);\n}", "CodeBleu_score": 48.22292162662023}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (o1->type == dBoxClass);\n  dIASSERT (o2->type == dCapsuleClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dReal fluidPlane[4];\n  dGeomCapsuleGetImmersionPlane (o2, fluidPlane);\n\n  return dImmerseBox ((dxBox*)o1, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 33.902593737779654}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dxBox *box;\n  dxCapsule *capsule;\n  dReal fluidPlane[4];\n\n  dUASSERT (o1->type == dBoxClass, \"First object is not a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"Second object is not a capsule\");\n  dUASSERT ((flags & NUMI_MASK) >= 1, \"Number of immersion iterations must be at least 1\");\n\n  box = (dxBox *) o1;\n  capsule = (dxCapsule *) o2;\n\n  // Compute the immersion plane for the capsule\n  dGeomCapsuleGetImmersionPlane (o2, fluidPlane);\n\n  // Check for collisions between the box and the capsule\n  if (dCollideCapsuleBox (o2, o1, flags, immersion)) {\n    // If a collision is detected, set the immersion parameters and call dImmerseBox to process the immersion of the box in the fluid\n    immersion->geom[0] = o1;\n    immersion->geom[1] = o2;\n    immersion->numi = flags & NUMI_MASK;\n    immersion->flags = flags;\n    immersion->surface = dContactSurface ();\n    immersion->depth = immersion->depth1 = immersion->depth2 = 0;\n    immersion->mode = dImmersionMode ();\n\n    return dImmerseBox (box, fluidPlane, flags, immersion);\n  }\n\n  return 0;\n}", "CodeBleu_score": 57.50835184702767}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (dGeomGetClass (o1) == dBoxClass);\n  dIASSERT (dGeomGetClass (o2) == dCapsuleClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  // Get the immersion plane of the capsule\n  dReal immersionPlane[4];\n  dGeomCapsuleGetImmersionPlane(o2, immersionPlane);\n\n  // Check for collisions between the box and the capsule\n  if (dCollideCapsuleBox(o2, o1, immersionPlane, flags)) {\n    // Set the immersion parameters\n    immersion->geom = o1;\n    immersion->immersionDepth = dGeomBoxPointDepth(o1, immersionPlane);\n    immersion->immersionPlane[0] = immersionPlane[0];\n    immersion->immersionPlane[1] = immersionPlane[1];\n    immersion->immersionPlane[2] = immersionPlane[2];\n    immersion->immersionPlane[3] = immersionPlane[3];\n\n    // Process the immersion of the box in the fluid\n    return dImmerseBox(dGeomBoxGetBox(o1), immersionPlane, flags, immersion);\n  }\n\n  return 0;\n}", "CodeBleu_score": 45.84656850346411}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\n    // Calculate the integrand values at the endpoints of the integration interval\n    dReal integrand0 = volumeIntegrand(zIOverR, tanTheta0, sinTheta1, -1);\n    dReal integrand1 = volumeIntegrand(zIOverR, tanTheta0, sinTheta1, 1);\n\n    // Calculate the volume using Simpson's rule for numerical integration\n    dReal volume = (integrand0 + 4 * volumeIntegrand(zIOverR, tanTheta0, sinTheta1, 0) + integrand1) * (2 * M_PI / 3);\n\n    // Return the normalized volume\n    return volume / (4 * M_PI * R * R * R / 3);\n}", "CodeBleu_score": 35.442399487083875}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    // Calculate the x-coordinate of the buoyancy center using Simpson's rule\n    dReal xBuoyancyCenter = Simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(sHemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1), 0.0, sinTheta1, 10000);\n    // Scale the x-coordinate by the radius and adjust by the volume\n    return (xBuoyancyCenter * radius) / volume;\n}", "CodeBleu_score": 46.972840367868784}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n    // Calculate the integrand using the given inputs and the current angle\n    auto integrand = [=](dReal theta) {\n        return zIOverR * tanTheta0 + sin(theta) * sinTheta1;\n    };\n\n    // Calculate the integral using Simpson's rule\n    return simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(integrand, 0, M_PI_2, 1000000);\n}", "CodeBleu_score": 43.683980413398004}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n    // Declare variables for the x-coordinate of the buoyancy center, the integrand, and the integrand's value at the current angle\n    dReal xBuoyancyCenter = 0;\n    dReal integrand = 0;\n    dReal integrandValue = 0;\n\n    // Loop over the angles of the hemisphere's surface\n    for (int i = 0; i < SIMPSON_INTEGRATION_STEPS; i++) {\n\n        // Calculate the current angle\n        dReal theta = (dReal)i * SIMPSON_INTEGRATION_STEP;\n\n        // Calculate the integrand's value at the current angle\n        integrandValue = integrand(zIOverR, tanTheta0, sinTheta1, theta);\n\n        // Add the integrand's value to the integrand for odd steps, subtract it for even steps\n        integrand += (2 * (i % 2) - 1) * integrandValue;\n\n        // Add the integrand's value multiplied by the cosine of the current angle to the x-coordinate of the buoyancy center\n        xBuoyancyCenter += integrandValue * cos(theta);\n    }\n\n    // Multiply the x-coordinate of the buoyancy center by the radius and adjust it by the volume\n    return xBuoyancyCenter * R * volume;\n}", "CodeBleu_score": 41.97412955461909}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 4.191970305576363}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (o1->type == dGeomIDTriMesh);\n  dIASSERT (o2->type == dGeomIDCapsule);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o2->g, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 34.52620272596704}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 4.191970305576363}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t    auto duration_ms = getInput<int>(\"duration_ms\");\n    if (!duration_ms) {\n        return NodeStatus::SUCCESS;\n    }\n    if (*duration_ms <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n    setStatus(NodeStatus::RUNNING);\n    timer_.add(std::chrono::milliseconds(*duration_ms),\n               [this]() {\n                   timer_waiting_ = false;\n                   emitWakeUpSignal();\n               },\n               true);\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 49.80843374168895}, {"code": "NodeStatus SleepNode::onStart(){\n\t    getInput(\"duration\", sleep_duration_);\n    if (sleep_duration_ <= std::chrono::milliseconds::zero()) {\n        return NodeStatus::SUCCESS;\n    }\n    setStatus(NodeStatus::RUNNING);\n    timer_.start();\n    timer_.add(sleep_duration_, [this]() {\n        if (timer_.cancel()) {\n            timer_waiting_ = false;\n        }\n        emitWakeUpSignal();\n    });\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 43.993164743991485}, {"code": "NodeStatus SleepNode::onStart(){\n\t  auto duration_ms = getInput<int>(\"duration\");\n  if (!duration_ms) {\n    return NodeStatus::SUCCESS;\n  }\n  if (*duration_ms <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_.add(std::chrono::milliseconds(*duration_ms),\n             [this]() {\n               timer_waiting_ = false;\n               emitWakeUpSignal();\n             },\n             true);\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 47.230840728383654}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    Entry entry;\n    if (!config().blackboard->getEntry(entry_name_, entry)) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::lock_guard<std::mutex> lock(entry.mutex);\n\n    if (entry.sequence_number != last_sequence_number_) {\n        last_sequence_number_ = entry.sequence_number;\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 42.55353999677373}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  std::string entry_name;\n  if (!getInput(\"entry_name\", entry_name)) {\n    throw std::logic_error(\"EntryUpdatedAction: missing entry_name\");\n  }\n\n  auto entry = config().blackboard->getEntry(entry_name);\n  if (!entry) {\n    throw std::logic_error(\"EntryUpdatedAction: entry not found\");\n  }\n\n  auto current_sequence_ID = entry->sequenceNumber();\n  std::lock_guard<std::mutex> lock(entry_mutex_);\n  if (current_sequence_ID != last_sequence_ID_) {\n    last_sequence_ID_ = current_sequence_ID;\n    return NodeStatus::SUCCESS;\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 47.48123677878243}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    auto entry = config().blackboard->getEntry(entry_name_);\n    if (entry) {\n        std::unique_lock<std::mutex> lock(entry->mutex);\n        if (entry->sequenceID != last_sequence_ID_) {\n            last_sequence_ID_ = entry->sequenceID;\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 37.80392569325198}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t  auto success_threshold = success_threshold_;\n  if (success_threshold < 0) {\n    success_threshold = children_nodes_.size() + success_threshold;\n  }\n  return static_cast<size_t>(std::max(0, success_threshold));\n}", "CodeBleu_score": 49.494913463856975}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    size_t success_threshold = success_threshold_;\n    if (success_threshold < 0) {\n        success_threshold = children_nodes_.size() + success_threshold;\n    }\n    return std::max(size_t(0), success_threshold);\n}", "CodeBleu_score": 50.15096805957793}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  size_t success_threshold = static_cast<size_t>(success_threshold_);\n  if (success_threshold < 0) {\n    success_threshold = static_cast<size_t>(children_nodes_.size() + success_threshold);\n  }\n  return success_threshold;\n}", "CodeBleu_score": 49.69118274359211}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (!_p->stop_heartbeat) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    if (_p->heartbeat_active != _p->heartbeat_last_active) {\n      _p->heartbeat_last_active = _p->heartbeat_active;\n      enableAllHooks(_p->heartbeat_active);\n    }\n  }\n}", "CodeBleu_score": 34.262318354926705}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    auto now = std::chrono::system_clock::now();\n    auto time_since_last_heartbeat = now - _p->last_heartbeat;\n    if (time_since_last_heartbeat > std::chrono::seconds(1)) {\n        _p->heartbeat_ok = false;\n        enableAllHooks(false);\n    } else {\n        _p->heartbeat_ok = true;\n        enableAllHooks(true);\n    }\n}", "CodeBleu_score": 52.944996254844035}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while(true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    if (_p->heartbeat_active && std::chrono::system_clock::now() - _p->last_heartbeat > std::chrono::milliseconds(500)) {\n      _p->heartbeat_active = false;\n      enableAllHooks(false);\n    }\n    else if (!_p->heartbeat_active && std::chrono::system_clock::now() - _p->last_heartbeat < std::chrono::milliseconds(500)) {\n      _p->heartbeat_active = true;\n      enableAllHooks(true);\n    }\n  }\n}", "CodeBleu_score": 44.95855867722527}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<std::string> bb_names;\n    BT::splitString(bb_list, bb_names, ';');\n\n    nlohmann::json j_dump;\n    for (const auto& bb_name : bb_names) {\n        auto it = _p->subtrees.find(bb_name);\n        if (it != _p->subtrees.end()) {\n            auto subtree_locked = it->second.lock();\n            if (subtree_locked) {\n                nlohmann::json j_bb = ExportBlackboardToJSON(subtree_locked->blackboard);\n                j_dump[bb_name] = j_bb;\n            }\n        }\n    }\n\n    std::vector<uint8_t> msgpack_dump = nlohmann::json::to_msgpack(j_dump);\n    return msgpack_dump;\n}", "CodeBleu_score": 56.92506630837663}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    // Split the input string of blackboard names into a vector of strings\n    std::vector<std::string> bb_names = BT::splitString(bb_list, ';');\n    // Create a JSON object to store the blackboards\n    nlohmann::json j;\n    // Iterate through the blackboard names\n    for (const auto& bb_name : bb_names) {\n        // Find the corresponding subtree and lock it\n        auto it = _p->subtrees.find(bb_name);\n        if (it != _p->subtrees.end() && it->second.lock()) {\n            // Export the blackboard to JSON and add it to the JSON object\n            j[bb_name] = ExportBlackboardToJSON(it->second.lock()->blackboard());\n        }\n    }\n    // Convert the JSON object to MessagePack format and return it as a vector of uint8_t\n    return nlohmann::json::to_msgpack(j);\n}", "CodeBleu_score": 58.69632068763727}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> out;\n    std::vector<std::string> blackboards;\n    BT::splitString(bb_list, blackboards, ';');\n    nlohmann::json j_dump;\n    for (const auto& bb : blackboards) {\n        auto it = _p->subtrees.find(bb);\n        if (it != _p->subtrees.end()) {\n            auto subtree = it->second.lock();\n            if (subtree) {\n                nlohmann::json j_bb = ExportBlackboardToJSON(subtree->blackboard);\n                j_dump[bb] = j_bb;\n            }\n        }\n    }\n    nlohmann::json::to_msgpack(j_dump, out);\n    return out;\n}", "CodeBleu_score": 54.30724185625243}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if (!hook)\n    return false;\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if (hook->status == NodeStatus::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 42.639281198475906}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if (hook->status != NodeStatus::BREAKPOINT) {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 45.32251472016549}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if (hook->status == NodeStatus::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 45.4058203189265}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    thread_ = std::async(std::launch::async, [this]() {\n      try {\n        NodeStatus status = tick();\n        if (!halt_requested_ && status != prev_status) {\n          setStatus(status);\n        }\n      } catch (std::exception &ex) {\n        std::cerr << \"ThreadedAction: \" << name() << \" loop: \" << ex.what() << std::endl;\n        setStatus(NodeStatus::IDLE);\n      }\n    });\n  }\n\n  try {\n    thread_.wait();\n  } catch (std::exception &ex) {\n    std::cerr << \"ThreadedAction: \" << name() << \" loop: \" << ex.what() << std::endl;\n    setStatus(NodeStatus::IDLE);\n  }\n\n  if (std::current_exception()) {\n    std::rethrow_exception(std::current_exception());\n  }\n\n  return status();\n}", "CodeBleu_score": 52.604289332784624}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    NodeStatus prev_status = status();\n\n    if (prev_status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n        future_ = std::async(std::launch::async, [this]() {\n            try {\n                tick();\n            }\n            catch (std::exception& exc) {\n                halt_requested_.store(true);\n                setStatus(NodeStatus::FAILURE);\n                std::cerr << name() << \": executeTick() exception: \" << exc.what() << std::endl;\n            }\n        });\n    }\n\n    // this part is optional, but it allows to catch the exception if it is thrown\n    // in the tick function\n    if (future_.valid() && status() == NodeStatus::RUNNING) {\n        auto status = future_.wait_for(std::chrono::milliseconds(1));\n        if (status == std::future_status::ready) {\n            future_.get();\n        }\n    }\n\n    if (halt_requested_.load()) {\n        setStatus(NodeStatus::IDLE);\n    }\n\n    std::exception_ptr exception_ptr = nullptr;\n    if (_exception_ptr) {\n        exception_ptr = _exception_ptr;\n        _exception_ptr = nullptr;\n    }\n    if (exception_ptr) {\n        std::rethrow_exception(exception_ptr);\n    }\n\n    return status();\n}", "CodeBleu_score": 51.265001506833244}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    thread_ = std::async(std::launch::async, [this]() {\n      try {\n        tick_functor_(*this);\n        if (!halt_requested_) {\n          setStatus(NodeStatus::SUCCESS);\n        }\n      } catch (std::exception &ex) {\n        BT_ROS_ERROR(\"ThreadedAction [%s]: %s\", name().c_str(), ex.what());\n        setStatus(NodeStatus::IDLE);\n      }\n    });\n  }\n  std::exception_ptr exception_ptr;\n  if ((exception_ptr = thread_.get_exception_ptr())) {\n    std::rethrow_exception(exception_ptr);\n  }\n  return status();\n}", "CodeBleu_score": 45.74756067574668}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  auto print = [&](const TreeNode* node, int depth) {\n    for (int i = 0; i < depth; i++) {\n      stream << \"  \";\n    }\n    stream << node->name() << std::endl;\n    auto control = dynamic_cast<const BT::ControlNode*>(node);\n    if (control) {\n      for (const auto& child : control->children()) {\n        print(child, depth + 1);\n      }\n    } else {\n      auto decorator = dynamic_cast<const BT::DecoratorNode*>(node);\n      if (decorator) {\n        print(decorator->child(), depth + 1);\n      }\n    }\n  };\n\n  stream << std::endl;\n  print(root_node, 0);\n  stream << std::endl;\n}", "CodeBleu_score": 54.83493372696891}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    static const std::string g_whitespace = \"                              \";\n    int depth = 0;\n    std::function<void(const TreeNode*)> recursive;\n    recursive = [&](const TreeNode* node) {\n        auto indent = [&]() {\n            for (int i = 0; i < depth; i++)\n                stream << g_whitespace;\n        };\n        if (!node) {\n            stream << \"NULLPTR\" << std::endl;\n            return;\n        }\n        indent();\n        stream << node->name() << std::endl;\n        depth++;\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                recursive(child);\n            }\n        }\n        else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            recursive(decorator->child());\n        }\n        depth--;\n    };\n\n    stream << \"----------------\" << std::endl;\n    recursive(root_node);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 62.85224821695034}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  auto print_node = [](const TreeNode* node, int indent, auto recurse) {\n    for (int i = 0; i < indent; i++) {\n      stream << \"  \";\n    }\n    stream << node->name() << std::endl;\n    if (auto control_node = dynamic_cast<const BT::ControlNode*>(node)) {\n      for (const auto& child : control_node->children()) {\n        recurse(child, indent + 1, recurse);\n      }\n    } else if (auto decorator_node = dynamic_cast<const BT::DecoratorNode*>(node)) {\n      recurse(decorator_node->child(), indent + 1, recurse);\n    }\n  };\n\n  stream << \"----------------\" << std::endl;\n  print_node(root_node, 0, print_node);\n  stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 60.63250636155504}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 93.0591372626442}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 93.0591372626442}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (!node) {\n        throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n    }\n\n    visitor(node);\n\n    if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n        for (const auto& child : control->children()) {\n            applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n        }\n    } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n        applyRecursiveVisitor(decorator->child(), visitor);\n    }\n}", "CodeBleu_score": 92.18483361921538}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (auto it = _p->builders.find(manifest.registration_ID);\n      it != _p->builders.end()) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                \"] already registered\");\n  }\n  _p->builders.insert({manifest.registration_ID, builder});\n  _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 80.08211256641043}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (_p->builders.count(manifest.registration_ID) != 0) {\n        throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                    \"] already registered\");\n    }\n    _p->builders.insert({manifest.registration_ID, builder});\n    _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 65.12565753422035}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (_p->builders.find(manifest.registration_ID) != _p->builders.end()) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                \"] already registered\");\n  }\n\n  _p->builders.insert({manifest.registration_ID, builder});\n  _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 69.85372770067481}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = NodeType::ACTION;\n  manifest.ports = std::move(ports);\n  manifest.registration_ID = ID;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 78.32717543226237}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = NodeType::ACTION;\n  manifest.ports = std::move(ports);\n  manifest.registration_ID = ID;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 68.30458138938171}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = NodeType::ACTION;\n  manifest.ports = std::move(ports);\n  manifest.registration_ID = ID;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 65.64319408782691}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for (const auto& subtree : tree.subtrees) {\n    auto bb_copy = Blackboard::create();\n    subtree->blackboard->cloneInto(*bb_copy);\n    backup.push_back(bb_copy);\n  }\n  return backup;\n}", "CodeBleu_score": 60.46121070135245}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        Blackboard::Ptr backup = Blackboard::create();\n        subtree->blackboard->cloneInto(*backup);\n        backups.push_back(std::move(backup));\n    }\n    return backups;\n}", "CodeBleu_score": 57.80454758978058}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backup;\n    backup.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        auto bb_copy = Blackboard::create();\n        subtree->blackboard->cloneInto(*bb_copy);\n        backup.push_back(bb_copy);\n    }\n    return backup;\n}", "CodeBleu_score": 59.001427756045466}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (executor) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 90.66348552543847}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if(executor) {\n        return executor.value()(env);\n    }\n    else {\n        return nonstd::make_unexpected(executor.error());\n    }\n}", "CodeBleu_score": 98.0209682639688}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (!executor) {\n    return nonstd::make_unexpected(executor.error());\n  }\n  return executor.value()(env);\n}", "CodeBleu_score": 75.23174261213809}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(m_mutex);\n    if (m_handle) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    m_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!m_handle) {\n        throw RuntimeError(dlerror());\n    }\n    m_path = path;\n}", "CodeBleu_score": 52.143418512073204}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::unique_lock<std::mutex> lock(mutex_);\n  if (handle_) {\n    throw RuntimeError(\"A library is already loaded.\");\n  }\n  handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle_) {\n    throw RuntimeError(dlerror());\n  }\n  path_ = path;\n}", "CodeBleu_score": 49.40892219889702}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    if (handle_ != nullptr) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        std::string error_message = dlerror();\n        throw RuntimeError(\"Failed to load library: \" + error_message);\n    }\n\n    path_ = path;\n}", "CodeBleu_score": 58.994794737137276}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n\n  const StringView stripped = strip(str);\n  if (stripped.front() != '{' || stripped.back() != '}') {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n  }\n  return true;\n}", "CodeBleu_score": 25.308000703947958}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n\n  StringView stripped = strip(str);\n\n  if (stripped.front() != '{' || stripped.back() != '}') {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n  }\n\n  return true;\n}", "CodeBleu_score": 24.478044656196257}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n\n    const auto stripped_str = strip(str);\n    if (stripped_str.front() != '{' || stripped_str.back() != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = stripped_str.substr(1, stripped_str.size() - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 27.29280661891429}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    //Bresenham Ray-Tracing\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for( LineIterator line( x0, y0, x1, y1 ); line.isValid(); line.advance() )\n    {\n      point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n      if(point_cost < 0)\n        return point_cost;\n\n      if(line_cost < point_cost)\n        line_cost = point_cost;\n    }\n\n    return line_cost;\n\n  }", "CodeBleu_score": 98.2844620526792}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    //Bresenham Ray-Tracing\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for(LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n      point_cost = pointCost(line.getX(), line.getY()); //Score based on the clearance\n\n      if(point_cost < 0)\n        return point_cost;\n\n      if(line_cost < point_cost)\n        line_cost = point_cost;\n    }\n\n    return line_cost;\n\n  }", "CodeBleu_score": 87.21518696352865}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    //Bresenham Ray-Tracing\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for( LineIterator line( x0, y0, x1, y1 ); line.isValid(); line.advance() )\n    {\n      point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n      if(point_cost < 0)\n        return point_cost;\n\n      if(line_cost < point_cost)\n        line_cost = point_cost;\n    }\n\n    return line_cost;\n\n  }", "CodeBleu_score": 98.2844620526792}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty())\n        return;\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.poses.resize(path.size());\n\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n    pub.publish(gui_path);\n}", "CodeBleu_score": 83.33637986637554}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 83.77730789736049}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty()) {\n        return;\n    }\n\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n\n    gui_path.poses.resize(path.size());\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    pub.publish(gui_path);\n}", "CodeBleu_score": 81.89011914743215}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n    fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && \n    fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.92104072520007}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.50765311307872}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n    fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n    fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.94400169988755}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = LocalPlannerLimits(config);\n}", "CodeBleu_score": 94.37547694487087}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 84.69149037454177}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 84.69149037454177}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= lethal_cost_ || cell_cost == unknown_cost_) {\n    if (!current_cell->target_mark) {\n      check_cell->target_dist = obstacleCosts();\n      return false;\n    }\n  }\n\n  double new_target_dist = current_cell->target_dist + 1;\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n  }\n  return true;\n}", "CodeBleu_score": 70.80622360996682}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = (unsigned int) costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= lethal_cost_ || check_cell->target_dist != UNKNOWN) {\n    return false;\n  }\n\n  // update the distance from the cell we're checking to the new\n  // closest distance\n  double new_target_dist = distanceLookup(current_cell, check_cell);\n  double new_target_mark = distanceLookup(check_cell, current_cell);\n\n  if (check_cell->target_dist > new_target_dist) {\n    check_cell->target_dist = new_target_dist;\n    check_cell->target_mark = new_target_mark;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 57.4103146928119}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = (unsigned int) costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= lethal_cost_ || cell_cost == unknown_cost_)\n    return false;\n\n  if (check_cell->target_dist + 1 < check_cell->target_dist)\n    return false;\n\n  if (check_cell->target_dist == 0xffffffff)\n    return false;\n\n  if (check_cell->target_dist > current_cell->target_dist + 1)\n    check_cell->target_dist = current_cell->target_dist + 1;\n  return true;\n}", "CodeBleu_score": 50.341192065833404}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint()?\");\n    return -9;\n  }\n\n  //footprint cost\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double x = traj.getPoint(i).x, y = traj.getPoint(i).y, th = traj.getPoint(i).th;\n\n    double footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n    if (footprint_cost < 0) {\n      return -5.0;\n    }\n\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 77.55029474188821}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint?\");\n    return -9;\n  }\n\n  //footprint costs for going forward\n  double forward_point_costs = 0.0;\n  for (unsigned int i = 0; i < traj.getPointsSize() - 1; ++i) {\n    double this_point_forward_cost = footprintCost(traj.getPoint(i).x, traj.getPoint(i).y, traj.getPoint(i).th, scale, footprint_spec_, costmap_, world_model_);\n    forward_point_costs += this_point_forward_cost;\n  }\n  if (forward_point_costs < 0) {\n    return -5.0;\n  }\n\n  if (sum_scores_) {\n    return forward_point_costs;\n  }\n  return forward_point_costs;\n}", "CodeBleu_score": 60.59763648600548}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    // check if the plugin initialized\n    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized\");\n        return -1.0;\n    }\n\n    // get the footprint points\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    // get the footprint of the robot\n    costmap->getScaledFootprint(x, y, th, scale, scaled_footprint);\n\n    // set the cost of the robot footprint\n    double footprint_cost = world_model->footprintCost(\n        x, y, th, scaled_footprint,\n        inscribed_radius_, circumscribed_radius_);\n\n    // if the footprint is in collision\n    // or\n    // the footprint is off the map\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n\n    unsigned int cell_x, cell_y;\n\n    // we want the cell of the hit point\n    if (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n        return -7.0;\n    }\n\n    unsigned char cost = std::max(std::max(costmap->getCost(cell_x, cell_y),\n        costmap->getCost(cell_x, cell_y + 1)),\n        std::max(costmap->getCost(cell_x, cell_y - 1),\n        costmap->getCost(cell_x + 1, cell_y - 1)));\n\n    // if the footprint is in collision\n    // or\n    // the footprint is off the map\n    if (cost == LETHAL_OBSTACLE) {\n        return -5.0;\n    }\n\n    // if the footprint is near an obstacle considerer it a collision\n    if (cost == INSCRIBED_INFLATED_OBSTACLE) {\n        return -5.0;\n    }\n\n    // the point is not in collision\n    return std::max(cost, footprint_cost);\n}", "CodeBleu_score": 55.78319385228346}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if ( odom_topic != odom_topic_ ) {\n    odom_topic_ = odom_topic;\n\n    if ( odom_topic_ == \"\" ) {\n      odom_sub_.shutdown();\n      return;\n    }\n\n    ros::NodeHandle gn;\n    odom_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n        &OdometryHelperRos::odomCallback, this);\n  }\n}", "CodeBleu_score": 62.0780272660461}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if ( odom_topic != odom_topic_ ) {\n    odom_topic_ = odom_topic;\n\n    if ( odom_topic_ == \"\" ) {\n      odom_sub_.shutdown();\n      return;\n    }\n\n    ros::NodeHandle gn;\n    odom_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n        boost::bind (&OdometryHelperRos::odomCallback, this, _1));\n  }\n}", "CodeBleu_score": 61.65217864894442}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if( odom_topic != odom_topic_ ) {\n    odom_topic_ = odom_topic;\n\n    if( odom_topic_ == \"\" ) {\n      odom_sub_.shutdown();\n      return;\n    }\n\n    ros::NodeHandle gn;\n    odom_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n        boost::bind( &OdometryHelperRos::odomCallback, this, _1 ));\n  }\n}", "CodeBleu_score": 64.99967043573808}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n\n  if (sq_dist < oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n  }\n\n  double angle = atan2(pos(1) - prev(1), pos(0) - prev(0));\n  if (fabs(angle - prev_angle_) > oscillation_reset_angle_) {\n    resetOscillationFlags();\n  }\n\n  prev_angle_ = angle;\n}", "CodeBleu_score": 46.873253996247286}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n\n  if (sq_dist < oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n    return;\n  }\n\n  double sq_dist_thresh = oscillation_reset_angle_sq_ * sq_dist;\n\n  Eigen::Vector3f delta_move = pos - prev;\n  double sq_angle = delta_move.squaredNorm();\n\n  if (sq_angle < sq_dist_thresh) {\n    resetOscillationFlags();\n    return;\n  }\n}", "CodeBleu_score": 43.81932535314411}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n  if (sq_dist < oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n    return;\n  }\n\n  double diff = acos( (pos.dot(prev)) / (pos.norm() * prev.norm()) );\n  if (diff < oscillation_reset_angle_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 44.455289554935526}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n  gridCoords(pt, gx, gy);\n\n  //check for out-of-bounds\n  if(gx > width_ || gy > height_)\n    return;\n\n  //check for too-close-to-neighbor\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //get the index of the cell the point belongs to\n  unsigned int index = gridIndex(gx, gy);\n\n  //insert the point into the cell\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 80.40100280642292}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    //get the grid coordinates of the point\n    unsigned int gx, gy;\n    gridCoords(pt, gx, gy);\n\n    //check for legality of the point\n    if(gx > width_ || gy > height_)\n      return;\n\n    //check for proximity to existing points\n    if(nearestNeighborDistance(pt) <= sq_min_separation_)\n      return;\n\n    //get the index of the cell the point belongs to\n    unsigned int index = gridIndex(gx, gy);\n\n    //insert the point\n    cells_[index].push_back(pt);\n  }", "CodeBleu_score": 74.69918475737617}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    //get the grid coordinates of the point\n    unsigned int gx, gy;\n    gridCoords(pt, gx, gy);\n\n    //check if the point is outside the grid bounds\n    if(gx >= width_ || gy >= height_)\n        return;\n\n    //check if the point is too close to its nearest neighbor\n    if(nearestNeighborDistance(pt) < sq_min_separation_)\n        return;\n\n    //get the grid index\n    unsigned int index = gridIndex(gx, gy);\n\n    //insert the point into the corresponding cell\n    cells_[index].push_back(pt);\n}", "CodeBleu_score": 78.4684546320246}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel;\n    new_vel.setZero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel(i) < vel(i) - acclimits(i) * dt) {\n            new_vel(i) = vel(i) - acclimits(i) * dt;\n        } else if (sample_target_vel(i) > vel(i) + acclimits(i) * dt) {\n            new_vel(i) = vel(i) + acclimits(i) * dt;\n        } else {\n            new_vel(i) = sample_target_vel(i);\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 55.174587707502745}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n  Eigen::Vector3f new_vel;\n  new_vel.setZero();\n  for (int i = 0; i < 3; i++) {\n    if (vel[i] < sample_target_vel[i]) {\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 92.00728190678082}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel;\n    new_vel.setZero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n        } else {\n            new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 87.31843678487434}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  int goal_x = cell_x;\n  int goal_y = cell_y;\n\n  if (global_plan_.size() == 0) {\n    return DBL_MAX;\n  }\n\n  for (int i = global_plan_.size() - 1; i >= 0; --i) {\n    goal_x = global_plan_[i].pose.position.x;\n    goal_y = global_plan_[i].pose.position.y;\n\n    double goal_x_d, goal_y_d;\n    costmap_.mapToWorld(goal_x, goal_y, goal_x_d, goal_y_d);\n\n    double x_diff = goal_x_d - x;\n    double y_diff = goal_y_d - y;\n    double diff_yaw = atan2(y_diff, x_diff) - heading;\n\n    if (fabs(diff_yaw) < M_PI) {\n      return fabs(diff_yaw);\n    }\n  }\n\n  return DBL_MAX;\n}", "CodeBleu_score": 59.3963343395211}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  //Get the cell coordinates of the goal point\n  int goal_x, goal_y;\n  costmap_.worldToMap(x, y, goal_x, goal_y);\n\n  //Calculate the distance between the current position and the goal point\n  double distance = hypot(goal_x - cell_x, goal_y - cell_y);\n\n  //Iterate through the global plan in reverse to find the farthest point with a clear line of sight\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    //Get the world coordinates of the current plan point\n    double plan_x = global_plan_[i].pose.position.x;\n    double plan_y = global_plan_[i].pose.position.y;\n\n    //Convert the world coordinates to cell coordinates\n    int plan_cell_x, plan_cell_y;\n    costmap_.worldToMap(plan_x, plan_y, plan_cell_x, plan_cell_y);\n\n    //Calculate the distance between the current position and the plan point\n    double plan_distance = hypot(plan_cell_x - cell_x, plan_cell_y - cell_y);\n\n    //Check if the plan point is within the line of sight\n    if (plan_distance <= distance) {\n      //Convert the goal cell coordinates to world coordinates\n      double goal_world_x, goal_world_y;\n      costmap_.mapToWorld(goal_x, goal_y, goal_world_x, goal_world_y);\n\n      //Calculate the direction to the goal point\n      double goal_heading = atan2(goal_world_y - y, goal_world_x - x);\n\n      //Return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n      return fabs(angles::shortest_angular_distance(heading, goal_heading));\n    }\n  }\n\n  //If no valid point is found, return DBL_MAX\n  return DBL_MAX;\n}", "CodeBleu_score": 59.1272168213282}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // 1. find the point on the global plan with the shortest distance to the robot\n  // 2. convert the point to world coordinates\n  // 3. return the shortest angular distance between the robot and the goal point\n\n  // 1. find the point on the global plan with the shortest distance to the robot\n  int min_index = -1;\n  double min_dist = DBL_MAX;\n  for (int i = global_plan_.size() - 1; i >= 0; --i) {\n    double dist = hypot(x - global_plan_[i].pose.position.x, y - global_plan_[i].pose.position.y);\n    if (dist < min_dist) {\n      min_dist = dist;\n      min_index = i;\n    }\n  }\n\n  // 2. convert the point to world coordinates\n  double goal_x = global_plan_[min_index].pose.position.x;\n  double goal_y = global_plan_[min_index].pose.position.y;\n  unsigned int mx, my;\n  costmap_.worldToMap(goal_x, goal_y, mx, my);\n  int goal_cell_x = mx;\n  int goal_cell_y = my;\n\n  // 3. return the shortest angular distance between the robot and the goal point\n  double goal_heading = atan2(goal_y - y, goal_x - x);\n  return fabs(angles::shortest_angular_distance(heading, goal_heading));\n}", "CodeBleu_score": 58.497922358654854}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n          vtheta_samp, cost);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 85.50632450639611}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n          vtheta_samp, cost);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 85.50632450639611}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if( cost < 0 ) {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n          vtheta_samp, cost);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 85.02236509352502}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The global and local costmap must be set before runBehavior is called\");\n    return;\n  }\n\n  if (affected_maps_.size() == 0) {\n    ROS_ERROR(\"affected_maps_ size is 0, so nothing will be cleared\");\n    return;\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing all areas in the update bounds except those in the clear area\");\n  } else {\n    ROS_WARN(\"Clearing all areas in the update bounds including those in the clear area\");\n  }\n\n  if (affected_maps_.count(\"global_costmap\") > 0) {\n    clear(global_costmap_);\n    global_costmap_->updateMap();\n    ROS_DEBUG(\"Ran ClearCostmapRecovery, %.3f milliseconds\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n  }\n\n  if (affected_maps_.count(\"local_costmap\") > 0) {\n    clear(local_costmap_);\n    local_costmap_->updateMap();\n    ROS_DEBUG(\"Ran ClearCostmapRecovery, %.3f milliseconds\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n  }\n}", "CodeBleu_score": 54.03088617327177}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The global and local costmap must be set before runBehavior is called\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing the area outside the current footprint\");\n  } else {\n    ROS_WARN(\"Clearing the area inside the current footprint\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if (affected_maps_.count(\"global\") > 0) {\n    ROS_DEBUG(\"Clearing global costmap\");\n    global_costmap_->updateMap();\n    clear(global_costmap_);\n    ROS_DEBUG(\"Global costmap cleared\");\n  }\n\n  if (affected_maps_.count(\"local\") > 0) {\n    ROS_DEBUG(\"Clearing local costmap\");\n    local_costmap_->updateMap();\n    clear(local_costmap_);\n    ROS_DEBUG(\"Local costmap cleared\");\n  }\n\n  ROS_DEBUG(\"Clearing took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 54.01158241591858}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s to unstuck robot\", affected_maps_.c_str(), invert_area_to_clear_ ? \"s\" : \"\");\n\n  // Clear both costmaps\n  if (affected_maps_ == \"global_costmap,local_costmap\") {\n    clear(global_costmap_);\n    clear(local_costmap_);\n  }\n  // Clear just the local costmap\n  else if (affected_maps_ == \"local_costmap\" ) {\n    clear(local_costmap_);\n  }\n  // Clear just the global costmap\n  else if (affected_maps_ == \"global_costmap\" ) {\n    clear(global_costmap_);\n  }\n  // Error on unrecognized costmap name\n  else {\n    ROS_ERROR(\"An internal error occurred in ClearCostmapRecovery. Unknown costmap name. Check affected_maps_ parameter in your costmap common params. Doing nothing.\");\n    return;\n  }\n\n  if (force_publish_) {\n    global_costmap_->updateMap();\n    local_costmap_->updateMap();\n  }\n\n  ROS_DEBUG(\"Clearing costmap recovery behaviors finished.\");\n}", "CodeBleu_score": 47.95487271555008}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    PolygonOutlineCells cell_gatherer(*this);\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n    }\n    if (!polygon.empty()) {\n        unsigned int last_index = polygon.size() - 1;\n        // we also need to close the polygon by going from the last point to the first\n        raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n    }\n    polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 92.10207300456341}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cell_gatherer(*this);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], cell_gatherer);\n  }\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(polygon[last_index], polygon[0], cell_gatherer);\n  }\n\n  polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 68.17607959219988}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cell_gatherer(*this);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n\n  polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 93.34364503767658}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  ROS_DEBUG(\"Checking for new subscribers\");\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 67.311593696568}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  ROS_DEBUG(\"Someone subscribed to costmap\");\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 67.17876295792209}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::recursive_mutex > lock(*costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = \"map\";\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.clear();\n  unsigned int size = grid_.info.width * grid_.info.height;\n  grid_.data.resize(size);\n\n  unsigned char *data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < size; i++) {\n    if (data[i] == 0)\n      grid_.data[i] = -1;\n    else if (data[i] == NO_INFORMATION)\n      grid_.data[i] = costmap_2d::NO_INFORMATION;\n    else if (data[i] >= LETHAL_OBSTACLE)\n      grid_.data[i] = 100;\n    else if (data[i] >= INSCRIBED_INFLATED_OBSTACLE)\n      grid_.data[i] = 99;\n    else if (data[i] == FREE_SPACE)\n      grid_.data[i] = 0;\n    else\n      grid_.data[i] = -1;\n  }\n}", "CodeBleu_score": 76.70665769094316}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::mutex > lock(*costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = new_header_frame_id_;\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.clear();\n  unsigned char* charMap = costmap_->getCharMap();\n  unsigned int size_x = costmap_->getSizeInCellsX(), size_y = costmap_->getSizeInCellsY();\n\n  //we'll have to store our costmap as unsigned ints until we use occupancy_grid_t, at which point we'll need to convert\n  grid_.data.resize(size_x * size_y);\n\n  unsigned char cost = 0;\n\n  for (unsigned int i = 0; i < size_x; ++i) {\n    for (unsigned int j = 0; j < size_y; ++j) {\n      //check the cost against the thresholds to prevent unnecessary updates\n      cost = charMap[j * size_x + i];\n      if (track_unknown_space_ && cost == costmap_2d::NO_INFORMATION)\n        grid_.data[j * size_x + i] = -1;\n      else\n        grid_.data[j * size_x + i] = cost;\n    }\n  }\n}", "CodeBleu_score": 75.9874113644599}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.frame_id = \"map\";\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.clear();\n  unsigned int size = grid_.info.width * grid_.info.height;\n  grid_.data.resize(size);\n\n  unsigned char* characters = costmap_->getCharMap();\n\n  for (unsigned int i = 0; i < size; i++) {\n    if (characters[i] == 0) {\n      grid_.data[i] = -1;\n    } else if (characters[i] == NO_INFORMATION) {\n      grid_.data[i] = costmap_2d::NO_INFORMATION;\n    } else if (characters[i] >= LETHAL_OBSTACLE) {\n      grid_.data[i] = 100;\n    } else if (characters[i] <= FREE_SPACE) {\n      grid_.data[i] = 0;\n    } else {\n      grid_.data[i] = characters[i];\n    }\n  }\n}", "CodeBleu_score": 80.38299106111015}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (new_config.footprint != \"\") {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n    } else {\n      ROS_ERROR(\"Planner will always fail because footprint parameter is not set and cannot be retrieved from the parameter server by footprint_from_param.\");\n    }\n  } else {\n    // get the footprint from the parameter server if one is available\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (getFootprintFromParam(new_config.footprint_from_param, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n    } else {\n      // otherwise, set the footprint to be a circle of radius robot_radius\n      std::vector<geometry_msgs::Point> points;\n      geometry_msgs::Point pt;\n      pt.x = new_config.robot_radius;\n      pt.y = 0.0;\n      points.push_back(pt);\n      setUnpaddedRobotFootprint(points);\n    }\n  }\n}", "CodeBleu_score": 74.19572025489096}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // If the footprint and robot radius in the new and old configurations are the same,\n  // return immediately.\n  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If the new configuration contains a valid footprint string, convert it to a\n  // footprint and set it.\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n      return;\n    }\n  }\n\n  // If the new configuration does not contain a valid footprint string, set the\n  // footprint based on the robot radius.\n  if (new_config.robot_radius != old_config.robot_radius) {\n    std::vector<geometry_msgs::Point> new_footprint;\n    makeFootprintFromRadius(new_config.robot_radius, new_footprint);\n    setUnpaddedRobotFootprint(new_footprint);\n  }\n}", "CodeBleu_score": 71.61384843283987}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // check if the footprint has changed\n  if (new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  // update the local copy of the footprint\n  footprint_ = new_config.footprint;\n\n  // make sure that we have a valid footprint\n  if (footprint_ == \"\") {\n    // the footprint parameter is left empty, so we will make the footprint\n    // from the specified radius\n    float footprint_radius = new_config.footprint_radius;\n\n    // pad the footprint in case it is not circular\n    float footprint_padding = new_config.footprint_padding;\n\n    // construct the footprint from the radius with padding\n    makeFootprintFromRadius(footprint_radius, footprint_padding);\n  } else {\n    // the footprint parameter is not empty, so we will use it to construct the footprint\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(footprint_, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n    } else {\n      // the footprint parameter is not valid, use the robot radius to make the footprint\n      float footprint_padding = new_config.footprint_padding;\n      float footprint_radius = new_config.footprint_radius;\n      makeFootprintFromRadius(footprint_radius, footprint_padding);\n    }\n  }\n}", "CodeBleu_score": 60.03729388610359}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"[Costmap2DROS] Could not get robot pose, cancelling reconfiguration\");\n    return;\n  }\n\n  // Check whether the robot has moved since the last update\n  if (fabs((old_pose_.pose.position.x - new_pose.pose.position.x) < resolution_ * 2.0) &&\n      fabs((old_pose_.pose.position.y - new_pose.pose.position.y) < resolution_ * 2.0) &&\n      fabs((tf2::getYaw(old_pose_.pose.orientation) - tf2::getYaw(new_pose.pose.orientation)) < M_PI / 4.0)) {\n    return;\n  }\n\n  // Update the stored pose\n  old_pose_ = new_pose;\n\n  // Update the size of the layered costmap (if enabled)\n  if (resize_map_) {\n    updateMap();\n  }\n}", "CodeBleu_score": 63.866944413392744}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Could not get the robot pose on timer in %s, canceling reconfiguration\", name_.c_str());\n    return;\n  }\n  // if the pose is updated\n  if (pose_ == new_pose) {\n    return;\n  }\n  // if we have a new pose, we need to clear the old map\n  resetMap();\n  // set the new pose\n  pose_ = new_pose;\n  // update the size of the map\n  size_lock_.lock();\n  size_x_ = getSizeInCellsX();\n  size_y_ = getSizeInCellsY();\n  size_lock_.unlock();\n  // update the map\n  updateMap(pose_.pose.position.x, pose_.pose.position.y);\n}", "CodeBleu_score": 65.51848614318871}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t", "CodeBleu_score": 1.488121648976743}, {"code": "void Costmap2DROS::start(){\n\t  std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n  // check if we're stopped or just not initialized\n  if (stopped_) {\n    // if we're stopped we need to re-subscribe to topics\n    for (vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin != plugins->end();\n         ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n  stop_updates_ = false;\n  // block until the costmap is initialized.. it should be.\n  ROS_DEBUG(\"Waiting for map update\");\n  ros::Rate r(100);\n  while (ros::ok() && !map_initialized_) {\n    r.sleep();\n  }\n  ROS_DEBUG(\"Map initialized\");\n  // now we need to wait for the map updates... they should be.\n  ROS_DEBUG(\"Waiting for updates\");\n  while (ros::ok() && !map_update_ && !stop_updates_) {\n    r.sleep();\n  }\n  ROS_DEBUG(\"Map updates started\");\n}", "CodeBleu_score": 80.65889349751679}, {"code": "void Costmap2DROS::start(){\n\t  std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n  // check if we're stopped or just not initialized\n  if (stopped_) {\n    // if we're stopped we need to re-subscribe to topics\n    for (vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin != plugins->end();\n         ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n  //block until the costmap is initialized.. it should be faster than that anyway\n  ROS_DEBUG(\"Waiting for map update\");\n  ros::Rate r(100);\n  ros::NodeHandle n;\n  while (n.ok() && !costmap_->getCostmap()->isCurrent()) {\n    r.sleep();\n  }\n  ROS_DEBUG(\"Map update loop: going\");\n  stop_updates_ = false;\n  //now we need to spin, until the user calls stopUpdate\n  map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, 100.0));\n}", "CodeBleu_score": 77.85638186652521}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    if (observation_list_.size() > 0) {\n      observation_list_.erase(observation_list_.begin() + 1, observation_list_.end());\n    }\n  } else {\n    ros::Time now = ros::Time::now();\n    for (ObservationList::iterator it = observation_list_.begin(); it != observation_list_.end(); ++it) {\n      if (now - it->header.stamp > observation_keep_time_) {\n        observation_list_.erase(it, observation_list_.end());\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 53.882346913495404}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    if (observation_list_.size() > 1) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n    }\n    return;\n  }\n\n  for (ObservationList::iterator obs_it = observation_list_.begin(); obs_it != observation_list_.end(); ++obs_it) {\n    if (ros::Time::now() - (*obs_it)->header.stamp > observation_keep_time_) {\n      observation_list_.erase(observation_list_.begin(), obs_it);\n      return;\n    }\n  }\n}", "CodeBleu_score": 54.991207746953144}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  // If the observation keep time is zero, keep only the latest observation\n  if (observation_keep_time_ == ros::Duration(0.0)) {\n    if (observation_list_.size() > 1) {\n      observation_list_.erase(observation_list_.begin(), --observation_list_.end());\n    }\n    return;\n  }\n\n  // Iterate through the observations and remove any that are older than the keep time\n  for (ObservationList::iterator it = observation_list_.begin(); it != observation_list_.end();) {\n    // Check if the observation is older than the keep time\n    if ((last_updated_time_ - it->header.stamp) > observation_keep_time_) {\n      // If it is, remove it from the list\n      it = observation_list_.erase(it);\n    } else {\n      // If it isn't, stop iterating\n      break;\n    }\n  }\n}", "CodeBleu_score": 48.38528052158904}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  if (start_index < 0 || end_index >= path.size() || start_index > end_index) {\n    ROS_ERROR(\"Invalid start and end indices for interpolation\");\n    return;\n  }\n\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = start_yaw + (i - start_index) * delta_yaw / (end_index - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 57.793952168069794}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  if (start_index < 0 || end_index >= path.size()) {\n    return;\n  }\n\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  double increment = delta_yaw / (end_index - start_index);\n\n  for (int i = start_index; i <= end_index; ++i) {\n    double new_yaw = start_yaw + (i - start_index) * increment;\n    set_angle(&path[i], new_yaw);\n  }\n}", "CodeBleu_score": 69.3731396226745}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double angle_increment = angles::shortest_angular_distance(start_yaw, end_yaw) / (end_index - start_index);\n\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = start_yaw + (i - start_index) * angle_increment;\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 61.31650426621431}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    std::vector<geometry_msgs::PoseStamped> path;\n    bool success = makePlan(req.start, req.goal, path);\n\n    // Update the response with the success status and the generated path\n    resp.plan_found = success;\n    resp.path = path;\n\n    return true;\n}", "CodeBleu_score": 78.2970353820451}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  std::vector<geometry_msgs::PoseStamped> path;\n\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  bool success = makePlan(req.start, req.goal, path);\n  resp.plan_found = success;\n  if (success) {\n    resp.path = path;\n  }\n\n  return true;\n}", "CodeBleu_score": 91.8845741286968}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  geometry_msgs::PoseStamped start;\n  geometry_msgs::PoseStamped goal;\n  start.header.frame_id = \"map\";\n  start.header.stamp = ros::Time::now();\n  start.pose = req.start;\n\n  goal.header.frame_id = \"map\";\n  goal.header.stamp = ros::Time::now();\n  goal.pose = req.goal;\n\n  std::vector<geometry_msgs::PoseStamped> plan;\n  bool success = makePlan(start, goal, plan);\n  resp.plan_found = success;\n  if (success) {\n    resp.path = plan;\n  }\n  return true;\n}", "CodeBleu_score": 60.56399102215764}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 69.4833654683534}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 69.4833654683534}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 69.4833654683534}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < origin_x_ || wy < origin_y_) {\n        return false;\n    }\n\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    if (mx < size_x_ && my < size_y_) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 40.43951180551774}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < origin_x_ || wy < origin_y_)\n    return false;\n\n  mx = (wx - origin_x_) / resolution_;\n  my = (wy - origin_y_) / resolution_;\n\n  if (mx < size_x_ && my < size_y_)\n    return true;\n\n  return false;\n}", "CodeBleu_score": 40.893829773699785}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n        return false;\n    }\n\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 51.726624803815824}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\n        \"This planner has not been initialized yet, \"\n        \"but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  if (!path.empty()) {\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the \n    // same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n      gui_path.poses[i] = path[i];\n    }\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 92.75031918217968}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    // create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = frame_id_;\n        gui_path.header.stamp = ros::Time::now();\n\n        // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n        for (unsigned int i = 0; i < path.size(); i++) {\n            gui_path.poses[i] = path[i];\n        }\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 94.08867277033083}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\n                \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 99.82945959233214}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 87.45198712220873}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG_NAMED(\"move_base\", \"Received a new goal\");\n    actionlib::SimpleActionClient<move_base_msgs::MoveBaseAction> action_client(\"move_base\", true);\n    move_base_msgs::MoveBaseGoal goal;\n    goal.target_pose = *goal;\n    goal.target_pose.header.stamp = ros::Time::now();\n    action_client.sendGoal(goal);\n    action_client.waitForResult();\n}", "CodeBleu_score": 56.410975353215306}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received a new goal\");\n  actionlib_msgs::GoalID goal_id;\n  goal_id.stamp = ros::Time::now();\n  goal_id.id = to_string(goal_id.stamp.toNSec());\n  actionlib_msgs::GoalStatus goal_status;\n  goal_status.goal_id = goal_id;\n  goal_status.status = actionlib_msgs::GoalStatus::ACTIVE;\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal_id = goal_id;\n  action_goal.goal = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 63.20804671597217}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Moved enough, removing speed limit\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 61.37029501692509}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  boost::mutex::scoped_lock lock(distance_check_mutex_);\n  if (getSqDistance() <= distance_limit_ * distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough, removing speed limit\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 76.15213529353322}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough. Removing speed limit.\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 59.81555792189578}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current pose of the robot\n    geometry_msgs::PoseStamped start;\n    cmap_->getRobotPose(start);\n\n    // Set the goal pose\n    geometry_msgs::PoseStamped goal_pose = *goal;\n\n    // Create an empty path vector\n    std::vector<geometry_msgs::PoseStamped> plan;\n\n    // Generate a path from the current pose to the goal pose\n    makePlan(start, goal_pose, plan);\n}", "CodeBleu_score": 54.37411995858863}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current robot pose\n    rm::PoseStamped start;\n    getRobotPose(start);\n\n    // Set the goal pose\n    rm::PoseStamped goal_pose;\n    goal_pose.header.frame_id = \"map\";\n    goal_pose.header.stamp = ros::Time::now();\n    goal_pose.pose.position.x = goal->pose.position.x;\n    goal_pose.pose.position.y = goal->pose.position.y;\n    goal_pose.pose.position.z = goal->pose.position.z;\n    goal_pose.pose.orientation.x = goal->pose.orientation.x;\n    goal_pose.pose.orientation.y = goal->pose.orientation.y;\n    goal_pose.pose.orientation.z = goal->pose.orientation.z;\n    goal_pose.pose.orientation.w = goal->pose.orientation.w;\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<rm::PoseStamped> plan;\n    makePlan(start, goal_pose, plan);\n}", "CodeBleu_score": 41.34241213068931}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current pose of the robot\n    geometry_msgs::PoseStamped start;\n    cmap_->getRobotPose(start);\n\n    // Set the goal pose\n    geometry_msgs::PoseStamped goal_pose;\n    goal_pose.header.frame_id = \"map\";\n    goal_pose.pose.position.x = goal->x;\n    goal_pose.pose.position.y = goal->y;\n    goal_pose.pose.orientation = tf::createQuaternionMsgFromYaw(goal->theta);\n\n    // Create a vector to store the path\n    std::vector<geometry_msgs::PoseStamped> path;\n\n    // Generate a path from the current pose to the goal pose\n    if (makePlan(start, goal_pose, path)) {\n        // Publish the path\n        nav_msgs::Path gui_path;\n        gui_path.header.frame_id = \"map\";\n        gui_path.header.stamp = ros::Time::now();\n        gui_path.poses = path;\n        plan_pub_.publish(gui_path);\n    }\n    else {\n        ROS_WARN(\"Failed to find a path to the goal\");\n    }\n}", "CodeBleu_score": 44.827894465429}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    dji_osdk_ros::GimbalParamSet gimbal_param_set;\n    gimbal_param_set.request.param_id = param_set.param_id;\n    gimbal_param_set.request.value = param_set.value;\n    this->param_set_client_.call(gimbal_param_set);\n}", "CodeBleu_score": 59.797516832569066}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    dji_osdk_ros::GimbalParamSet gimbal_param_set;\n    gimbal_param_set.request.param_id = param_set.param_id;\n    gimbal_param_set.request.param_value = param_set.param_value;\n    this->param_set_client_.call(gimbal_param_set);\n}", "CodeBleu_score": 58.9170940027328}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    dji_osdk_ros::GimbalParamSet gimbal_param_set;\n    gimbal_param_set.request.param_id = param_set.param_id;\n    gimbal_param_set.request.value = param_set.value;\n    this->param_set_client_.call(gimbal_param_set);\n}", "CodeBleu_score": 59.797516832569066}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t  // Wait for connection from ground station\n  waitConnectionFromGroundStation();\n\n  // Enter loop to accept incoming connections\n  while (true) {\n    // Accept incoming connection\n    accept();\n\n    // Receive data\n    recv();\n\n    // If data is received successfully\n    if (recv_len > 0) {\n      // Decode message\n      decodeMsg();\n\n      // Publish message\n      pubMsg();\n    }\n    // If received message length is zero or less\n    else {\n      // Log error\n      perror(\"recv failed\");\n\n      // Close socket\n      close();\n\n      // Exit program\n      exit(1);\n    }\n  }\n}", "CodeBleu_score": 8.773573940929797}, {"code": "void CommunicationBridge::serverFun(){\n\t    if (waitConnectionFromGroundStation() != 0) {\n        perror(\"ERROR on accept\");\n        exit(1);\n    }\n\n    while (1) {\n        if (waitConnectionFromGroundStation() != 0) {\n            perror(\"ERROR on accept\");\n            exit(1);\n        }\n\n        int n = recv(newsockfd, buffer, 255, 0);\n        if (n < 0) {\n            perror(\"ERROR reading from socket\");\n            exit(1);\n        }\n\n        if (n == 0) {\n            ROS_ERROR(\"Connection closed by ground station\");\n            close(newsockfd);\n            break;\n        }\n\n        buffer[n] = '\\0';\n        pubMsg(buffer);\n    }\n}", "CodeBleu_score": 37.410700030665275}, {"code": "void CommunicationBridge::serverFun(){\n\t    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(port);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *) &address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    if ((new_socket = accept(server_fd, (struct sockaddr *) &address, (socklen_t *) &addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n\n    while (true) {\n        valread = read(new_socket, buffer, 1024);\n        if (valread > 0) {\n            decodeMsg(buffer, valread);\n        } else if (valread <= 0) {\n            ROS_ERROR(\"Ground station disconnected.\");\n            close(new_socket);\n            break;\n        }\n    }\n}", "CodeBleu_score": 54.97837475170553}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    // If not in simulation mode, publish the command to a single UAV\n    if (!this->simulation_mode_) {\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    }\n    // If in simulation mode, find the corresponding UAV by ID from swarm_control_simulation_ and publish the command to the matching UAV\n    else {\n        std::map<int, std::shared_ptr<UAVBasic>>::iterator it = this->swarm_control_simulation_.find(uav_cmd.drone_id);\n        if (it != this->swarm_control_simulation_.end()) {\n            (*it).second->uavCmdPub(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 62.502161659503706}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (!this->simulation_mode_) {\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    } else {\n        std::map<int, UAV*>::iterator it;\n        it = this->swarm_control_simulation_.find(uav_cmd.id);\n        if (it != this->swarm_control_simulation_.end()) {\n            (*it).second->uavCmdPub(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 62.07879861789538}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->simulation_mode_) {\n        std::map<int, std::shared_ptr<UAVBasic>>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != this->swarm_control_simulation_.end()) {\n            (*it).second->uavCmdPub(uav_cmd);\n        }\n    } else {\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    }\n}", "CodeBleu_score": 60.8915542888005}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    switch (mode_selection.mode) {\n        case REBOOTNX:\n            system(\"reboot\");\n            break;\n        case EXITNX:\n            system(\"exit\");\n            break;\n        default:\n            if (mode_selection.use_mode) {\n                createMode(mode_selection.mode);\n            } else {\n                deleteMode(mode_selection.mode);\n            }\n            break;\n    }\n}", "CodeBleu_score": 39.393885073745395}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    switch (mode_selection.mode) {\n        case REBOOTNX:\n            // Execute system command to reboot the system\n            system(\"reboot\");\n            break;\n        case EXITNX:\n            // Execute system command to exit the system\n            system(\"exit\");\n            break;\n        default:\n            // Handle other modes\n            if (mode_selection.use_mode) {\n                createMode(mode_selection.mode);\n            } else {\n                deleteMode(mode_selection.mode);\n            }\n            break;\n    }\n}", "CodeBleu_score": 39.393885073745395}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode == REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.use_mode == EXITNX) {\n        system(\"exit\");\n    } else if (mode_selection.use_mode == CREATE) {\n        createMode(mode_selection.use_mode);\n    } else if (mode_selection.use_mode == DELETE) {\n        deleteMode(mode_selection.use_mode);\n    }\n}", "CodeBleu_score": 52.67995863854693}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (time_event.last_real > time_event.current_real) {\n        // ROS time has been reset\n        ROS_WARN(\"ROS time has been reset. Resetting heartbeat counter.\");\n        heartbeat_count_ = 0;\n        return;\n    }\n\n    if (heartbeat_count_ == heartbeat_threshold_) {\n        // Vehicle is disconnected\n        ROS_ERROR(\"Vehicle is disconnected. Triggering appropriate actions.\");\n        disconnect_flag_ = true;\n        if (vehicle_type_ == \"swarm\") {\n            triggerSwarmControl();\n        } else if (vehicle_type_ == \"UAV\") {\n            triggerUAV();\n        } else if (vehicle_type_ == \"UGV\") {\n            triggerUGV();\n        }\n    } else {\n        // Vehicle is connected\n        ROS_INFO(\"Vehicle is connected.\");\n    }\n}", "CodeBleu_score": 41.41700138293152}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n    if (heartbeat_count == heartbeat_count_prev) {\n        heartbeat_missed_count++;\n        if (heartbeat_missed_count >= heartbeat_missed_threshold) {\n            if (vehicle_type == \"swarm\") {\n                ROS_ERROR(\"Swarm heartbeat missed\");\n                triggerSwarmControl();\n            } else if (vehicle_type == \"UAV\") {\n                ROS_ERROR(\"UAV heartbeat missed\");\n                triggerUAV();\n            } else if (vehicle_type == \"UGV\") {\n                ROS_ERROR(\"UGV heartbeat missed\");\n                triggerUGV();\n            }\n            disconnect_flag = true;\n        }\n    } else {\n        heartbeat_missed_count = 0;\n    }\n    heartbeat_count_prev = heartbeat_count;\n}", "CodeBleu_score": 41.519256299765075}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  if (heartbeat_counter != heartbeat_state) {\n    heartbeat_counter = heartbeat_state;\n    heartbeat_missed = 0;\n  } else {\n    heartbeat_missed++;\n  }\n  if (heartbeat_missed > heartbeat_missed_threshold) {\n    heartbeat_missed = 0;\n    ROS_ERROR(\"Heartbeat Missed\");\n    if (vehicle_type == \"swarm\") {\n      triggerSwarmControl();\n    } else if (vehicle_type == \"UAV\") {\n      triggerUAV();\n    } else if (vehicle_type == \"UGV\") {\n      triggerUGV();\n    }\n    disconnect_flag = true;\n  }\n}", "CodeBleu_score": 39.551083505854024}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using octree compression\n    std::stringstream compressed_data;\n    pcl::io::OctreePointCloudCompression<pcl::PointXYZ>* PointCloudEncoder;\n    PointCloudEncoder = new pcl::io::OctreePointCloudCompression<pcl::PointXYZ> (4);\n    PointCloudEncoder->encodePointCloud(cloud, compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 new_msg;\n    new_msg.header = msg.header;\n    new_msg.height = 1;\n    new_msg.width = compressed_data.str().size();\n    new_msg.fields.resize(1);\n    new_msg.fields[0].name = \"compressed_data\";\n    new_msg.fields[0].offset = 0;\n    new_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n    new_msg.fields[0].count = new_msg.width;\n    new_msg.is_bigendian = false;\n    new_msg.point_step = new_msg.width;\n    new_msg.row_step = new_msg.width;\n    new_msg.is_dense = true;\n    new_msg.data.resize(new_msg.width);\n    std::memcpy(&new_msg.data[0], compressed_data.str().c_str(), new_msg.width);\n\n    // Release dynamically allocated memory\n    delete PointCloudEncoder;\n\n    // Return the new PointCloud2 message\n    return new_msg;\n}", "CodeBleu_score": 44.884939431453205}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t  // Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Compress the point cloud using an octree compression technique\n  std::stringstream compressed_data;\n  octree_compression.encodePointCloud(cloud, compressed_data);\n\n  // Create a new PointCloud2 message with the compressed data\n  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = 1;\n  compressed_msg.width = compressed_data.str().size();\n  compressed_msg.fields.resize(1);\n  compressed_msg.fields[0].name = \"compressed_data\";\n  compressed_msg.fields[0].offset = 0;\n  compressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n  compressed_msg.fields[0].count = compressed_data.str().size();\n  compressed_msg.is_bigendian = false;\n  compressed_msg.point_step = compressed_data.str().size();\n  compressed_msg.row_step = compressed_data.str().size();\n  compressed_msg.is_dense = true;\n  compressed_msg.data.resize(compressed_data.str().size());\n  std::memcpy(&compressed_msg.data[0], compressed_data.str().c_str(), compressed_data.str().size());\n\n  // Release dynamically allocated memory\n  cloud.reset();\n\n  return compressed_msg;\n}", "CodeBleu_score": 43.65950685317503}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    std::stringstream compressed_data;\n    std::vector<uint8_t> compressed_str;\n    octree_compression.encodePointCloud(cloud, compressed_str);\n    compressed_data.str(std::string(compressed_str.begin(), compressed_str.end()));\n\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_str.size();\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = compressed_msg.width;\n    compressed_msg.row_step = compressed_msg.width;\n    compressed_msg.is_dense = true;\n    compressed_msg.data.resize(compressed_msg.width * compressed_msg.height);\n    std::memcpy(&compressed_msg.data[0], &compressed_str[0], compressed_msg.width * compressed_msg.height);\n\n    return compressed_msg;\n}", "CodeBleu_score": 44.84554133052743}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  // Iterate through the list of UAV states\n  for (auto& uav : this->multi_uav_state_.uav_state_all) {\n    // If the UAV ID matches the provided uav_state, update the UAV state\n    if (uav.uav_id == uav_state.uav_id) {\n      uav = uav_state;\n      break;\n    }\n  }\n}", "CodeBleu_score": 43.96069915842101}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 96.75999708297736}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 96.75999708297736}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    swarm_control::MultiUGVState multi_ugv_state;\n    int ugv_count = 0;\n    for (auto &ugv_state : m_multi_ugv_state.ugv_state_all) {\n        swarm_control::UGVState ugv_state_msg;\n        ugv_state_msg.ugv_id = ugv_state.ugv_id;\n        ugv_state_msg.battery = ugv_state.battery;\n        ugv_state_msg.position.x = ugv_state.position.x;\n        ugv_state_msg.position.y = ugv_state.position.y;\n        ugv_state_msg.position.z = ugv_state.position.z;\n        ugv_state_msg.velocity.x = ugv_state.velocity.x;\n        ugv_state_msg.velocity.y = ugv_state.velocity.y;\n        ugv_state_msg.velocity.z = ugv_state.velocity.z;\n        ugv_state_msg.attitude.x = ugv_state.attitude.x;\n        ugv_state_msg.attitude.y = ugv_state.attitude.y;\n        ugv_state_msg.attitude.z = ugv_state.attitude.z;\n        ugv_state_msg.attitude.w = ugv_state.attitude.w;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state_msg);\n        ugv_count++;\n    }\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 44.22787674284894}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  MultiUGVState multi_ugv_state;\n  int ugv_count = 0;\n  for (auto ugv_state : m_multi_ugv_state.ugv_state_all) {\n    UGVState ugv_state_msg;\n    ugv_state_msg.ID = ugv_state.ID;\n    ugv_state_msg.battery = ugv_state.battery;\n    ugv_state_msg.position.x = ugv_state.position.x;\n    ugv_state_msg.position.y = ugv_state.position.y;\n    ugv_state_msg.position.z = ugv_state.position.z;\n    ugv_state_msg.velocity.x = ugv_state.velocity.x;\n    ugv_state_msg.velocity.y = ugv_state.velocity.y;\n    ugv_state_msg.velocity.z = ugv_state.velocity.z;\n    ugv_state_msg.attitude.x = ugv_state.attitude.x;\n    ugv_state_msg.attitude.y = ugv_state.attitude.y;\n    ugv_state_msg.attitude.z = ugv_state.attitude.z;\n    ugv_state_msg.attitude.w = ugv_state.attitude.w;\n    multi_ugv_state.ugv_state_all.push_back(ugv_state_msg);\n    ugv_count++;\n  }\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 41.705118251087555}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient.setZero();\n\n  // Iterate through control points of the B-spline\n  for (int i = 0; i < q.cols(); i++) {\n    // Get the predicted positions of moving objects at the current control point\n    Eigen::MatrixXd obj_prid = moving_objs_->evaluateConstVel(q.col(i), ros::Time::now().toSec());\n\n    // Iterate through moving objects\n    for (int j = 0; j < obj_prid.cols(); j++) {\n      // Calculate the distance between control point and moving object\n      double dist = (cps_.points.col(i) - obj_prid.col(j)).norm();\n\n      // If the distance is less than the clearance, update the cost and gradient\n      if (dist < moving_clearance_) {\n        // Calculate the cost\n        cost += pow(dist - moving_clearance_, 2);\n\n        // Calculate the gradient\n        gradient.col(i) += 2.0 * (dist - moving_clearance_) * (cps_.points.col(i) - obj_prid.col(j)).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 39.27499499846697}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Clear the gradient matrix\n  gradient.setZero();\n\n  // Initialize the cost to zero\n  cost = 0.0;\n\n  // Iterate through control points of the B-spline\n  for (int i = 0; i < q.cols(); i++) {\n    // Get the predicted positions of moving objects at the current control point\n    Eigen::MatrixXd obj_prid = moving_objs_->evaluateConstVel(q.col(i), ros::Time::now().toSec());\n\n    // Iterate through predicted positions of moving objects\n    for (int j = 0; j < obj_prid.cols(); j++) {\n      // Compute the distance between control point and the predicted position of the moving object\n      double dist = (cps_.points.col(i) - obj_prid.col(j)).norm();\n\n      // If the distance is less than the clearance, update the cost and gradient\n      if (dist < kMovingObjClearance) {\n        // Compute the distance error\n        double dist_err = kMovingObjClearance - dist;\n\n        // Update the cost\n        cost += pow(dist_err, 2);\n\n        // Update the gradient\n        gradient.col(i) += 2.0 * dist_err * (cps_.points.col(i) - obj_prid.col(j)).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 44.859360542235024}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  /*\n   * q: Control points of the B-spline.\n   * cost: Cost of the trajectory.\n   * gradient: Gradient of the cost with respect to the control points.\n   */\n  cost = 0.0;\n  gradient.setZero();\n  Eigen::MatrixXd obj_prid = moving_objs_->evaluateConstVel(ros::Time::now().toSec());\n  // Iterate through control points\n  for (int i = 0; i < q.cols(); ++i) {\n    // Iterate through moving objects\n    for (int j = 0; j < moving_objs_->getObjNums(); ++j) {\n      // Calculate distance between control point and object\n      double dist = (q.col(i) - obj_prid.col(j)).norm();\n      // If distance is less than clearance, update cost and gradient\n      if (dist < moving_objs_->getClearance()) {\n        cost += pow(dist - moving_objs_->getClearance(), 2);\n        gradient.col(i) += 2.0 * (dist - moving_objs_->getClearance()) * (q.col(i) - obj_prid.col(j)).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 36.54004904311634}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Initialize cost to zero\n  cost = 0.0;\n  // Set the gradient to zero\n  gradient.setZero();\n\n  // Iterate through the control points of the trajectory\n  for (int i = 2; i < q.cols() - 2; i++) {\n    // Compute the positional error relative to reference points\n    Eigen::Vector3d p = q.col(i) - ref_pts_[i];\n    // Compute the velocity vector\n    Eigen::Vector3d v = q.col(i + 1) - q.col(i - 1);\n    // Compute the dot product and cross product of the error and velocity vectors\n    double a2 = p.dot(p);\n    double b2 = p.cross(v).norm();\n    // Update the cost function\n    cost += a2 + b2;\n    // Compute the derivatives of the cost function\n    Eigen::Vector3d gradient_p = 2.0 * p + b2 * v.normalized();\n    Eigen::Vector3d gradient_v = -2.0 * p.cross(v.normalized()) + b2 * (q.col(i + 1) - q.col(i - 1)).normalized();\n    // Update the gradient for the current control point\n    gradient.col(i) += gradient_p;\n    gradient.col(i - 1) += gradient_v;\n    gradient.col(i + 1) += gradient_v;\n  }\n}", "CodeBleu_score": 38.16411775253769}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Initialize the cost to zero\n  cost = 0.0;\n  // Set the gradient to zero\n  gradient.setZero();\n\n  // Iterate through the control points of the trajectory\n  for (int i = 2; i < N - 2; i++) {\n    // Compute the positional error relative to reference points\n    Eigen::Vector3d error = q.col(i) - ref_pts_[i];\n    // Compute the velocity vector\n    Eigen::Vector3d v = (q.col(i + 1) - q.col(i - 1)) / (t_[i + 1] - t_[i - 1]);\n\n    // Compute the dot product of the error and velocity vectors\n    double a2 = error.dot(v);\n    // Compute the cross product of the error and velocity vectors\n    Eigen::Vector3d b2 = error.cross(v);\n\n    // Update the cost function\n    cost += a2 * a2 + b2.squaredNorm();\n\n    // Update the gradient for the current control point\n    gradient.col(i) += 4.0 * a2 * error + 4.0 * b2.dot(v) * (q.col(i + 1) - q.col(i - 1)) / (t_[i + 1] - t_[i - 1]);\n  }\n}", "CodeBleu_score": 34.24981953530418}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Initialize cost to zero\n  cost = 0.0;\n\n  // Initialize gradient matrix to zero\n  gradient.setZero(q.rows(), q.cols());\n\n  // Iterate through control points\n  for (int i = 2; i < q.cols() - 2; ++i) {\n    // Compute positional error relative to reference points\n    Eigen::Vector3d e = q.col(i) - ref_pts_[i];\n\n    // Compute velocity vector\n    Eigen::Vector3d v = (q.col(i + 1) - q.col(i - 1)) / (dt_ * 2.0);\n\n    // Compute dot product and cross product of error and velocity vectors\n    double a2 = e.dot(e);\n    Eigen::Vector3d b2 = e.cross(v);\n\n    // Update cost function\n    cost += a2 + b2.squaredNorm();\n\n    // Compute gradient for current control point\n    Eigen::Vector3d gradient_i = (2.0 * e + 2.0 * b2.cross(v)) / (dt_ * dt_);\n    gradient.col(i) = gradient_i;\n  }\n}", "CodeBleu_score": 32.99745781639169}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  double jerk = 0.0;\n  double time_step = jerk_traj.getTimeSum() / (ctrl_pts_.cols() - 1);\n  Eigen::VectorXd knot_increment = jerk_traj.getKnot().segment(1, jerk_traj.getKnot().rows() - 1) -\n                                  jerk_traj.getKnot().segment(0, jerk_traj.getKnot().rows() - 1);\n  for (int i = 0; i < jerk_traj.getControlPoint().rows(); ++i) {\n    for (int j = 0; j < jerk_traj.getControlPoint().cols(); ++j) {\n      jerk += (jerk_traj.getControlPoint()(i, j) * jerk_traj.getControlPoint()(i, j) *\n               knot_increment(j) * knot_increment(j));\n    }\n  }\n  jerk = sqrt(jerk / time_step);\n\n  return jerk;\n}", "CodeBleu_score": 56.68509877121506}, {"code": "double UniformBspline::getJerk(){\n\t  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n  double jerk = 0.0;\n  double time_step = jerk_traj.getTimeSum() / (jerk_traj.getControlPoint().rows() - 1);\n  Eigen::VectorXd knot = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  for (int i = 0; i < ctrl_pts.cols(); ++i) {\n    for (int j = 0; j < ctrl_pts.rows(); ++j) {\n      jerk += (knot(j) - knot(0)) * (knot(j) - knot(0)) * ctrl_pts(j, i) * ctrl_pts(j, i);\n    }\n  }\n\n  jerk = sqrt(jerk / time_step / (jerk_traj.getControlPoint().rows() - 1));\n  return jerk;\n}", "CodeBleu_score": 72.0716695107926}, {"code": "double UniformBspline::getJerk(){\n\t  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  double jerk = 0.0;\n  double time_step = jerk_traj.getTimeSum() / (ctrl_pts_.cols() - 3);\n\n  Eigen::VectorXd knot = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  for (int i = 0; i < ctrl_pts.cols(); ++i) {\n    for (int j = 0; j < ctrl_pts.rows(); ++j) {\n      jerk += (ctrl_pts.coeff(j, i) * ctrl_pts.coeff(j, i)) * (knot(i + 1) - knot(i)) * (knot(i + 1) - knot(i));\n    }\n  }\n\n  jerk = sqrt(jerk / time_step);\n\n  return jerk;\n}", "CodeBleu_score": 74.24419996000444}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.35005343899863}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n    return pos;\n}", "CodeBleu_score": 63.352792714373265}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t  Eigen::Vector4d pos;\n  pos[0] = (u - cx_) * depth / fx_;\n  pos[1] = (v - cy_) * depth / fy_;\n  pos[2] = depth;\n  pos[3] = 1;\n  return pos;\n}", "CodeBleu_score": 63.07111904746579}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        int drone_id = std::stoi(odom.child_frame_id.substr(5, 1));\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        ROS_ERROR(\"Failed to extract drone ID from child_frame_id: %s\", e.what());\n    }\n}", "CodeBleu_score": 55.668891475004855}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    int drone_id = std::stoi(odom.child_frame_id.substr(1));\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (std::exception& e) {\n    ROS_ERROR(\"Failed to extract drone ID from child_frame_id: %s\", e.what());\n  }\n}", "CodeBleu_score": 57.31956602972025}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        int droneID = std::stoi(odom.child_frame_id.substr(1, 1));\n        rcvDroneOdomCallbackBase(odom, droneID);\n    } catch (const std::exception& e) {\n        std::cout << \"Error extracting drone ID from child_frame_id: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 56.42141048295398}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Calculate the true pose of the drone in the camera frame\n  Eigen::Vector3d true_pose = getTruePose(drone_id, true_pixel);\n\n  // Check if the drone is present in the image\n  if (isPresent(drone_id, true_pose)) {\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = computePoseError(true_pose);\n\n    // Update the debug result with the detected drone\n    updateDebugResult(drone_id, true_pixel, pose_error);\n\n    // Publish the pose error\n    drone_pose_err_pub_[drone_id].publish(pose_error);\n  } else {\n    // Update the debug result to indicate failure\n    updateDebugResult(drone_id, true_pixel, Eigen::Vector3d::Zero());\n  }\n}", "CodeBleu_score": 31.91333632680202}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Calculate the true pose of the drone in the camera frame\n  Eigen::Vector3d true_pose = camera_model_->cameraToWorld(true_pixel);\n\n  // Check for the presence of the drone in the camera frame\n  if (is_detected(drone_id, true_pose)) {\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = true_pose - drone_pose_[drone_id];\n\n    // Update the debug result\n    debug_result_.pose_error = pose_error;\n    debug_result_.drone_detected = true;\n\n    // Publish the pose error\n    drone_pose_err_pub_[drone_id].publish(pose_error);\n  } else {\n    // Update the debug result to indicate failure\n    debug_result_.drone_detected = false;\n  }\n}", "CodeBleu_score": 34.041457642296116}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Calculate the true pose of the drone in the camera frame\n  Eigen::Vector3d true_pose = camera_model_.pixelToCamera(true_pixel, 1.0);\n\n  // Check for the drone's presence\n  if (isPresent(drone_id, true_pose)) {\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = computePoseError(drone_id, true_pose);\n\n    // Update the debug result\n    updateDebugResult(drone_id, true_pose, pose_error);\n\n    // Publish the pose error\n    publishPoseError(drone_id, pose_error);\n  } else {\n    // Update the debug result to indicate failure\n    updateDebugResult(drone_id, true_pose, Eigen::Vector3d::Zero());\n  }\n}", "CodeBleu_score": 29.478112128863255}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 98.77621185986197}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n\n    reverse(path.begin(), path.end());\n    return path;\n}", "CodeBleu_score": 85.55990978531281}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t  vector<GridNodePtr> path;\n  // std::cout << \"Retrieving path\" << std::endl;\n  path.push_back(current);\n  while (current->cameFrom != NULL) {\n    current = current->cameFrom;\n    path.push_back(current);\n  }\n  return path;\n}", "CodeBleu_score": 96.25191622895396}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n        return false;\n\n    if (checkOccupancy(start_idx)) {\n        //ROS_WARN(\"Start point is insde obstacle, adjusting start point.\");\n        do {\n            start_pt = start_pt - 0.05 * (end_pt - start_pt).normalized();\n            if (!Coord2Index(start_pt, start_idx))\n                return false;\n        } while (checkOccupancy(start_idx));\n        //ROS_WARN(\"Adjusted start point to: (%.2f, %.2f, %.2f)\", start_pt(0), start_pt(1), start_pt(2));\n    }\n\n    if (checkOccupancy(end_idx)) {\n        //ROS_WARN(\"End point is insde obstacle, adjusting end point.\");\n        do {\n            end_pt = end_pt + 0.05 * (end_pt - start_pt).normalized();\n            if (!Coord2Index(end_pt, end_idx))\n                return false;\n        } while (checkOccupancy(end_idx));\n        //ROS_WARN(\"Adjusted end point to: (%.2f, %.2f, %.2f)\", end_pt(0), end_pt(1), end_pt(2));\n    }\n\n    return true;\n}", "CodeBleu_score": 70.54266737806242}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n    return false;\n\n  if (checkOccupancy(start_idx)) {\n    //ROS_WARN(\"Start point is insde obstacle !\");\n    do {\n      start_pt = (start_pt - end_pt).normalized() * step_size + start_pt;\n      //ROS_WARN(\"new start point: (%f, %f, %f)\", start_pt(0), start_pt(1), start_pt(2));\n    } while (checkOccupancy(start_idx));\n    Coord2Index(start_pt, start_idx);\n  }\n\n  if (checkOccupancy(end_idx)) {\n    //ROS_WARN(\"End point is insde obstacle !\");\n    do {\n      end_pt = (end_pt - start_pt).normalized() * step_size + end_pt;\n      //ROS_WARN(\"new end point: (%f, %f, %f)\", end_pt(0), end_pt(1), end_pt(2));\n    } while (checkOccupancy(end_idx));\n    Coord2Index(end_pt, end_idx);\n  }\n\n  return true;\n}", "CodeBleu_score": 67.28073751385357}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n        return false;\n\n    if (checkOccupancy(start_idx)) {\n        //ROS_WARN(\"Start point is insde obstacle !\");\n        do {\n            start_pt = start_pt - 0.2 * (end_pt - start_pt).normalized();\n            if (!Coord2Index(start_pt, start_idx))\n                return false;\n        } while (checkOccupancy(start_idx));\n    }\n\n    if (checkOccupancy(end_idx)) {\n        //ROS_WARN(\"End point is insde obstacle !\");\n        do {\n            end_pt = end_pt + 0.2 * (end_pt - start_pt).normalized();\n            if (!Coord2Index(end_pt, end_idx))\n                return false;\n        } while (checkOccupancy(end_idx));\n    }\n\n    return true;\n}", "CodeBleu_score": 70.54972165321736}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.467120033493703}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.467120033493703}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  boundIndex(min_id);\n  boundIndex(max_id);\n\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) + y * grid_size_(2) + z] = 0;\n      }\n}", "CodeBleu_score": 70.98044599828887}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d pt_near_boundary = pt;\n    double min_pos_scaling_factor = 1.0;\n\n    for (int i = 0; i < 3; i++) {\n        if (diff[i] > 0) {\n            double max_scaling_factor = (max_boundary_[i] - camera_pt[i]) / diff[i];\n            double min_scaling_factor = (min_boundary_[i] - camera_pt[i]) / diff[i];\n\n            if (max_scaling_factor < min_pos_scaling_factor) {\n                min_pos_scaling_factor = max_scaling_factor;\n            }\n            if (min_scaling_factor < min_pos_scaling_factor) {\n                min_pos_scaling_factor = min_scaling_factor;\n            }\n        }\n    }\n\n    for (int i = 0; i < 3; i++) {\n        pt_near_boundary[i] = camera_pt[i] + min_pos_scaling_factor * diff[i];\n    }\n\n    return pt_near_boundary;\n}", "CodeBleu_score": 47.48034557332302}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_t = (m_map_max_boundary - camera_pt).cwiseQuotient(diff);\n    Eigen::Vector3d min_t = (m_map_min_boundary - camera_pt).cwiseQuotient(diff);\n    Eigen::Vector3d pt_near_boundary = pt;\n\n    for (int i = 0; i < 3; ++i) {\n        if (max_t[i] > 0 && max_t[i] < min_t[i]) {\n            pt_near_boundary = camera_pt + max_t[i] * diff;\n            break;\n        } else if (min_t[i] > 0 && min_t[i] < max_t[i]) {\n            pt_near_boundary = camera_pt + min_t[i] * diff;\n            break;\n        }\n    }\n\n    return pt_near_boundary;\n}", "CodeBleu_score": 50.081105188072115}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_t = (m_map_max_boundary - camera_pt).cwiseQuotient(diff);\n    Eigen::Vector3d min_t = (m_map_min_boundary - camera_pt).cwiseQuotient(diff);\n\n    double min_positive_t = std::numeric_limits<double>::max();\n    for (int i = 0; i < 3; ++i) {\n        if (max_t[i] > 0 && max_t[i] < min_positive_t) {\n            min_positive_t = max_t[i];\n        }\n        if (min_t[i] > 0 && min_t[i] < min_positive_t) {\n            min_positive_t = min_t[i];\n        }\n    }\n    return camera_pt + min_positive_t * diff;\n}", "CodeBleu_score": 51.14387386520327}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if an update is needed\n  if (md_.has_new_depth_ || md_.has_new_odom_) {\n    // Project depth image into points\n    md_.proj_points_.clear();\n    md_.proj_points_cnt_ = 0;\n    projectDepthImage();\n\n    // Process points with raycasting\n    raycastProcess();\n\n    // Clear and inflate local map\n    clearAndInflateLocalMap();\n\n    // Handle timeout errors\n    if ((ros::Time::now() - md_.last_odom_time_).toSec() > md_.odom_timeout_) {\n      md_.has_odom_ = false;\n      md_.odom_init_ = false;\n      ROS_ERROR(\"Odometry data timeout!\");\n    }\n    if ((ros::Time::now() - md_.last_depth_time_).toSec() > md_.depth_timeout_) {\n      md_.has_depth_ = false;\n      ROS_ERROR(\"Depth data timeout!\");\n    }\n\n    // Set flags\n    md_.has_new_depth_ = false;\n    md_.has_new_odom_ = false;\n  }\n}", "CodeBleu_score": 61.43721768436742}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if an update is needed\n  if (!md_.has_odom_ || !md_.has_depth_ || !md_.has_cloud_) return;\n\n  // Project depth image into points\n  projectDepthImage();\n\n  // Process points with raycasting\n  raycastProcess();\n\n  // Clear and inflate the local map\n  clearAndInflateLocalMap();\n\n  // Handle timeout errors for odometry or depth data\n  if ((ros::Time::now() - md_.last_odom_time_).toSec() > md_.odom_timeout_) {\n    ROS_ERROR(\"Odometry data timeout!\");\n    md_.has_odom_ = false;\n  }\n\n  if ((ros::Time::now() - md_.last_depth_time_).toSec() > md_.depth_timeout_) {\n    ROS_ERROR(\"Depth data timeout!\");\n    md_.has_depth_ = false;\n  }\n\n  // Set flags for timeout errors\n  md_.map_valid_ = false;\n  md_.odom_valid_ = false;\n  md_.md_.state_ = WAIT_FOR_MAP;\n}", "CodeBleu_score": 59.982702000018804}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float sum_f = 0.f;\n    unsigned n_imgs = image_fns.size();\n    for (unsigned i = 0; i < n_imgs; ++i) {\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        Mat3b img = imread(image_fns[i]);\n        float f = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        sum_f += f;\n    }\n    return sum_f / float(n_imgs);\n}", "CodeBleu_score": 57.49947343522499}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_measure = 0.f;\n    unsigned sz = image_fns.size();\n    for (unsigned i = 0; i < sz; ++i) {\n        Mat3b img = imread(image_fns[i], 1);\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n        f_measure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n    }\n    f_measure /= float(sz);\n    return f_measure;\n}", "CodeBleu_score": 58.390540153592575}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_measure_accum = 0.f;\n    unsigned sz = image_fns.size();\n    for (unsigned i = 0; i < sz; ++i) {\n        const string& image_fn = image_fns[i];\n        const string& gt_fn = gt_fns[i];\n        const string& dt_fn = dt_fns[i];\n\n        Mat3b img = imread(image_fn);\n        if (img.empty()) {\n            cout << \"Error loading image: \" << image_fn << endl;\n            continue;\n        }\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n        float f_measure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        f_measure_accum += f_measure;\n    }\n    return f_measure_accum / float(sz);\n}", "CodeBleu_score": 48.98245321725938}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n    float angle_diff = angle_diff_signed(angle1, angle2);\n    float normal_angle = angle1 + angle_diff / 2.0;\n    while (normal_angle <= -M_PI) normal_angle += M_2__PI;\n    while (normal_angle >   M_PI) normal_angle -= M_2__PI;\n    return normal_angle;\n}", "CodeBleu_score": 56.091661447639865}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a, b;\n    if (foci) {\n        a = atan2(y - foci[1], x - foci[0]);\n        b = atan2(y - foci[3], x - foci[2]);\n    } else {\n        a = atan2(y, x);\n        b = atan2(y, x);\n    }\n    return angle_diff_signed(a, b);\n}", "CodeBleu_score": 42.73933825881646}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle_from_focus1 = atan2(y - foci[1], x - foci[0]);\n    float angle_from_focus2 = atan2(y - foci[3], x - foci[2]);\n    float angle_diff = angle_diff_signed(angle_from_focus1, angle_from_focus2);\n    float normal_angle = angle_from_focus1 + angle_diff / 2;\n    if (normal_angle < -M_PI) {\n        normal_angle += M_2__PI;\n    } else if (normal_angle > M_PI) {\n        normal_angle -= M_2__PI;\n    }\n    return normal_angle;\n}", "CodeBleu_score": 52.93209537716342}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    int min_x = vp1[start].x;\n    int min_y = vp1[start].y;\n    int max_x = vp1[start].x;\n    int max_y = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        min_x = min(min_x, vp1[i].x);\n        min_y = min(min_y, vp1[i].y);\n        max_x = max(max_x, vp1[i].x);\n        max_y = max(max_y, vp1[i].y);\n    }\n    int integral_above = 0;\n    int integral_below = 0;\n    for (int i = start; i <= end; i++) {\n        int x1 = vp1[i].x;\n        int y1 = vp1[i].y;\n        int x2 = vp1[i + 1].x;\n        int y2 = vp1[i + 1].y;\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        int integral = dx * (min_y + max_y) + dy * (min_x + max_x) + (x1 * y2 - x2 * y1);\n        if (integral > 0) {\n            integral_above += integral;\n        } else {\n            integral_below += integral;\n        }\n    }\n    return (integral_above < integral_below);\n}", "CodeBleu_score": 42.56005646864429}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        if (vp1[i].x < min_x)\n            min_x = vp1[i].x;\n        if (vp1[i].x > max_x)\n            max_x = vp1[i].x;\n        if (vp1[i].y < min_y)\n            min_y = vp1[i].y;\n        if (vp1[i].y > max_y)\n            max_y = vp1[i].y;\n    }\n    double integral_above = 0;\n    double integral_below = 0;\n    for (int i = start; i <= end; i++) {\n        double x1 = vp1[i].x;\n        double y1 = vp1[i].y;\n        double x2 = vp1[(i + 1) % vp1.size()].x;\n        double y2 = vp1[(i + 1) % vp1.size()].y;\n        integral_above += (x2 - x1) * (y2 + y1) / 2;\n        integral_below += (x2 - x1) * (y2 - y1) / 2;\n    }\n    return integral_above < integral_below;\n}", "CodeBleu_score": 43.3926452617785}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->num_of_detection; i++) {\n        ellipse_det[i] = msg->detection_info[i];\n        if (ellipse_det[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    ellipse_det[0].sight_angle = -ellipse_det[0].sight_angle;\n    ellipse_det[1].sight_angle = -ellipse_det[1].sight_angle;\n}", "CodeBleu_score": 70.70238905236674}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    bool is_safe = true;\n    if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n        is_safe = true;\n    } else {\n        is_safe = false;\n    }\n    return is_safe;\n}", "CodeBleu_score": 55.749810300450605}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    Eigen::Vector3i cur_idx;\n    cur_idx = coord2gridIndex(cur_pos);\n    return Occupy_map_ptr->check_safety(cur_idx, safe_distance);\n}", "CodeBleu_score": 53.32165918090625}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\n    return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 45.78128616816927}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 74.70027882849524}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t  NodePtr current_node = end_node;\n  path_nodes_.push_back(current_node);\n\n  while (current_node->parent != nullptr) {\n    current_node = current_node->parent;\n    path_nodes_.push_back(current_node);\n  }\n\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 73.06814700495583}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t  NodePtr current_node = end_node;\n  path_nodes_.push_back(current_node);\n\n  while (current_node->parent != nullptr) {\n    current_node = current_node->parent;\n    path_nodes_.push_back(current_node);\n  }\n\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 73.06814700495583}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t", "CodeBleu_score": 3.1699249080664136}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  state_nei[id].pos(0) = odom->pose.pose.position.x;\n  state_nei[id].pos(1) = odom->pose.pose.position.y;\n  state_nei[id].pos(2) = odom->pose.pose.position.z;\n  state_nei[id].vel(0) = odom->twist.twist.linear.x;\n  state_nei[id].vel(1) = odom->twist.twist.linear.y;\n  state_nei[id].vel(2) = odom->twist.twist.linear.z;\n  state_nei[id].acc(0) = odom->twist.twist.angular.x;\n  state_nei[id].acc(1) = odom->twist.twist.angular.y;\n  state_nei[id].acc(2) = odom->twist.twist.angular.z;\n  state_nei[id].quat.w() = odom->pose.pose.orientation.w;\n  state_nei[id].quat.x() = odom->pose.pose.orientation.x;\n  state_nei[id].quat.y() = odom->pose.pose.orientation.y;\n  state_nei[id].quat.z() = odom->pose.pose.orientation.z;\n  state_nei[id].quat.normalize();\n  state_nei[id].rot = state_nei[id].quat.toRotationMatrix();\n\n  if(sim_mode) {\n    if((start_pos-state_nei[id].pos).norm()>5) {\n      get_nei_state[id] = false;\n    } else {\n      get_nei_state[id] = true;\n    }\n  }\n}", "CodeBleu_score": 50.27270938388633}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    // ROS_INFO(\"nei_odom_cb\");\n    state_nei[id].pos(0) = odom->pose.pose.position.x;\n    state_nei[id].pos(1) = odom->pose.pose.position.y;\n    state_nei[id].pos(2) = odom->pose.pose.position.z;\n    state_nei[id].vel(0) = odom->twist.twist.linear.x;\n    state_nei[id].vel(1) = odom->twist.twist.linear.y;\n    state_nei[id].vel(2) = odom->twist.twist.linear.z;\n    state_nei[id].acc(0) = odom->twist.twist.angular.x;\n    state_nei[id].acc(1) = odom->twist.twist.angular.y;\n    state_nei[id].acc(2) = odom->twist.twist.angular.z;\n    state_nei[id].quat.w() = odom->pose.pose.orientation.w;\n    state_nei[id].quat.x() = odom->pose.pose.orientation.x;\n    state_nei[id].quat.y() = odom->pose.pose.orientation.y;\n    state_nei[id].quat.z() = odom->pose.pose.orientation.z;\n    state_nei[id].quat.normalize();\n\n    if (sim_mode) {\n        if ((start_pos-state_nei[id].pos).norm() > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    } else {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 56.633194334550396}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n  if (!odom_ready) {\n    return;\n  }\n\n  if (!sensor_ready) {\n    sensor_ready = true;\n  }\n\n  update_counter++;\n\n  if (update_counter == 5) {\n    update_counter = 0;\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n  }\n}", "CodeBleu_score": 55.43748070745585}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter == 5) {\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n        update_counter = 0;\n    }\n}", "CodeBleu_score": 67.04130380910856}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        ROS_WARN(\"Odometry not ready, cannot update map\");\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter % 5 == 0) {\n        update_counter = 0;\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n    }\n}", "CodeBleu_score": 59.86642502461002}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n    // check if the global map has been updated\n    if (get_gpcl == false) {\n        get_gpcl = true;\n        // convert the sensor message to a point cloud\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*global_point, *cloud);\n        // store the point cloud\n        global_cloud = cloud;\n        // inflate the point cloud\n        inflate_point_cloud(global_cloud);\n    }\n}", "CodeBleu_score": 59.5792318653787}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (!get_gpcl) {\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*global_point, *cloud);\n        global_map_pcl = cloud;\n        inflate_point_cloud(global_map_pcl, global_map_pcl, 0.5);\n    }\n}", "CodeBleu_score": 58.54112542155047}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl) {\n    get_gpcl = false;\n    pcl::fromROSMsg(*global_point, *global_cloud);\n    global_map_inflate();\n  }\n}", "CodeBleu_score": 38.86181641360421}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    sensor_msgs::PointCloud2 cloud2;\n    projector_.projectLaser(*local_point, cloud2);\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(cloud2, cloud);\n    if (!simulation_) {\n        local_map_merge_odom(cloud, odom);\n    }\n}", "CodeBleu_score": 47.765123322238146}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    if (local_point == NULL) {\n        ROS_WARN(\"laser data is NULL\");\n        return;\n    }\n\n    sensor_msgs::PointCloud2 local_map_point;\n    projector_.projectLaser(*local_point, local_map_point);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr local_map_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(local_map_point, *local_map_pcl);\n\n    if (!simulation_mode_) {\n        pcl::PointCloud<pcl::PointXYZ>::Ptr map_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::PointCloud<pcl::PointXYZ>::Ptr map_pcl_temp(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(map_data_, *map_pcl);\n        local_map_merge_odom(map_pcl_temp, map_pcl, local_map_pcl, odom);\n        pcl::toROSMsg(*map_pcl_temp, map_data_);\n    } else {\n        pcl::toROSMsg(*local_map_pcl, map_data_);\n    }\n}", "CodeBleu_score": 49.28317750437525}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr local_map_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr global_map_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr global_map_pcl_merge(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // project laser scan into a PointCloud2 format\n    sensor_msgs::PointCloud2 local_map_pointcloud2;\n    projector_.projectLaser(*local_point, local_map_pointcloud2);\n\n    // convert PointCloud2 to pcl::PointCloud\n    pcl::fromROSMsg(local_map_pointcloud2, *local_map_pcl);\n\n    // merge local map with odometry data\n    if (!simulation_mode_) {\n        local_map_merge_odom(local_map_pcl, odom);\n    }\n\n    // convert PointCloud2 to pcl::PointCloud\n    pcl::fromROSMsg(global_map_pointcloud2_, *global_map_pcl);\n\n    // merge global map with local map\n    *global_map_pcl_merge = *global_map_pcl + *local_map_pcl;\n\n    // convert pcl::PointCloud to PointCloud2\n    pcl::toROSMsg(*global_map_pcl_merge, global_map_pointcloud2_);\n\n    // publish global map\n    global_map_publisher_.publish(global_map_pointcloud2_);\n}", "CodeBleu_score": 48.001768039017485}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Convert the global point cloud map to a ROS message\n    pcl::toROSMsg(global_map, global_map_msg);\n    global_map_msg.header.frame_id = \"world\";\n    // Publish the global point cloud message\n    global_pcl_pub.publish(global_map_msg);\n\n    // Convert the inflated point cloud to a ROS message\n    pcl::toROSMsg(inflate_map, inflate_map_msg);\n    inflate_map_msg.header.frame_id = \"world\";\n    // Publish the inflated point cloud message\n    inflate_pcl_pub.publish(inflate_map_msg);\n}", "CodeBleu_score": 45.88543673266186}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    global_pcl_pub.publish(pcl::toROSMsg(global_pcl_map));\n    inflate_pcl_pub.publish(pcl::toROSMsg(inflate_pcl_map));\n}", "CodeBleu_score": 16.64640449906904}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Convert the global point cloud map to a ROS message\n    pcl::toROSMsg(*global_map_ptr, global_map_msg);\n    global_map_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_map_msg);\n\n    // Convert and publish the inflated point cloud\n    pcl::toROSMsg(*inflate_map_ptr, inflate_map_msg);\n    inflate_map_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_map_msg);\n}", "CodeBleu_score": 51.084401414779414}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  // If odometry is ready, set sensor_ready flag to true\n  if (odom_ready) {\n    sensor_ready = true;\n  }\n\n  // Update the A* algorithm's map using the new point cloud data and current UAV odometry\n  Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, current_odom);\n}", "CodeBleu_score": 55.314034007711896}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (odom_ready) {\n        sensor_ready = true;\n        Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n        Astar_ptr->set_start_point(odom_pos);\n        Astar_ptr->set_goal_point(goal_pos);\n        Astar_ptr->Astar_search();\n        Astar_ptr->get_result(result);\n        if (result.empty()) {\n            ROS_WARN(\"No path found!\");\n            return;\n        }\n        else {\n            ROS_INFO(\"Path found!\");\n            pub_path(result);\n        }\n    }\n    else {\n        ROS_WARN(\"No odom!\");\n    }\n}", "CodeBleu_score": 50.81685116131583}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  float target_foot_positions[12];\n  float target_joint_positions[12];\n  bool foot_contacts[4];\n\n  // Calculate target foot positions based on desired pose\n  body_controller_.getTargetFootPositions(rosTimeToChampTime(event.current_real), target_foot_positions);\n\n  // Compute velocity commands for legs\n  for (size_t i = 0; i < 4; ++i) {\n    leg_controller_.velocityCommand(rosTimeToChampTime(event.current_real), i, target_foot_positions + i * 3,\n                                    base_.legs[i]->state.foot_position, base_.legs[i]->state.joint_positions,\n                                    base_.legs[i]->state.joint_velocities, base_.legs[i]->gait_phase(),\n                                    base_.legs[i]->swing_phase(), base_.legs[i]->stance_phase(),\n                                    base_.legs[i]->phase_reset_time(), base_.legs[i]->phase_reset_duration(),\n                                    base_.legs[i]->phase_reset_percent(), base_.legs[i]->phase_reset_offset());\n  }\n\n  // Perform inverse kinematics to determine target joint positions\n  for (size_t i = 0; i < 4; ++i) {\n    kinematics_.inverse(target_foot_positions + i * 3, target_joint_positions + i * 3);\n  }\n\n  // Publish foot contact information\n  for (size_t i = 0; i < 4; ++i) {\n    foot_contacts[i] = base_.legs[i]->gait_phase() > 0.5;\n  }\n  publishFootContacts_(foot_contacts);\n\n  // Publish joint positions\n  publishJoints_(target_joint_positions);\n}", "CodeBleu_score": 50.58969801258153}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Calculate the desired foot positions based on the desired pose\n    float target_foot_positions[12];\n    body_controller_.calculateFootPositionsFromPoseCommand(target_foot_positions);\n\n    // Calculate the desired joint angles for each leg\n    float target_joint_angles[12];\n    kinematics_.inverse(target_foot_positions, target_joint_angles);\n\n    // Calculate the desired joint velocities for each leg\n    float target_joint_velocities[12];\n    for (size_t i = 0; i < 12; i++) {\n        target_joint_velocities[i] = leg_controller_.velocityCommand(target_joint_angles[i], i);\n    }\n\n    // Publish foot contact information\n    bool foot_contacts[4];\n    for (size_t i = 0; i < 4; i++) {\n        foot_contacts[i] = base_.legs[i]->gait_phase();\n    }\n    publishFootContacts_(foot_contacts);\n\n    // Publish joint positions\n    publishJoints_(target_joint_angles);\n}", "CodeBleu_score": 59.099144017297625}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n    //Get the current time\n    ros::Time time = ros::Time::now();\n\n    //Get the current time in microseconds\n    uint64_t time_now = time.toNSec() / 1000ul;\n\n    //Check if the loop frequency is too high\n    if ((time_now - last_control_loop_time_) < (control_loop_frequency_ * 1000000ul)) {\n        return;\n    }\n\n    //Update the last control loop time\n    last_control_loop_time_ = time_now;\n\n    //Update the robot state\n    updateJointStates_();\n\n    //Update the body state\n    updateBodyState_();\n\n    //Update the leg states\n    updateLegStates_();\n\n    //Update the ground reaction force\n    updateGroundReactionForce_();\n\n    //Compute the desired body pose\n    computeDesiredBodyPose_();\n\n    //Compute the desired leg positions\n    computeDesiredLegPositions_();\n\n    //Compute the desired joint positions\n    computeDesiredJointPositions_();\n\n    //Compute the desired joint velocities\n    computeDesiredJointVelocities_();\n\n    //Publish the foot contacts\n    publishFootContacts_();\n\n    //Publish the joint positions\n    publishJoints_();\n}", "CodeBleu_score": 38.026259707143794}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    std_msgs::Float64MultiArray contacts_msg;\n    contacts_msg.data.resize(4);\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.data[i] = foot_contacts[i];\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 47.70305062359243}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getTopic().empty()) {\n    return;\n  }\n\n  free_gait_msgs::ContactsStamped contacts_msg;\n  contacts_msg.header.stamp = ros::Time::now();\n  contacts_msg.contacts.resize(4);\n  for (int i = 0; i < 4; i++) {\n    contacts_msg.contacts.at(i).contact_state = foot_contacts[i];\n    contacts_msg.contacts.at(i).robot_side = base_.legs[i]->robot_side;\n    contacts_msg.contacts.at(i).gazebo_side = base_.legs[i]->gazebo_side;\n    contacts_msg.contacts.at(i).gait_phase = base_.legs[i]->gait_phase;\n  }\n  foot_contacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 53.204540554011835}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    // Create a ContactsStamped message\n    free_gait_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.contacts.resize(4);\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i] = foot_contacts[i];\n    }\n\n    // Publish the message\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 60.31889262749186}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    // Create a minimal joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.position = joints.position[:12]\n\n    # Publish the joints message\n    self.joints_pub.publish(joints_msg)\n\n    # Create a joint trajectory message with the same positions and a specified duration\n    joint_traj_msg = JointTrajectory()\n    joint_traj_msg.header.stamp = rospy.Time.now()\n    joint_traj_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = rospy.Duration(2.0)\n    joint_traj_msg.points.append(point)\n\n    # Publish the joint trajectory message\n    self.joint_traj_pub.publish(joint_traj_msg)\n}", "CodeBleu_score": 47.32879947156894}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.header.stamp = self.get_clock().now().to_msg()\n    joints_msg.header.frame_id = \"base_link\"\n    joints_msg.name = [\n        \"shoulder_pan_joint\",\n        \"shoulder_lift_joint\",\n        \"elbow_joint\",\n        \"wrist_1_joint\",\n        \"wrist_2_joint\",\n        \"wrist_3_joint\",\n        \"linear_arm_actuator_joint\",\n        \"robotiq_85_left_knuckle_joint\",\n        \"robotiq_85_right_knuckle_joint\",\n        \"robotiq_85_left_finger_joint\",\n        \"robotiq_85_right_finger_joint\",\n        \"robotiq_85_left_inner_knuckle_joint\",\n        \"robotiq_85_right_inner_knuckle_joint\",\n    ]\n    joints_msg.position = joints.position[:12]\n\n    # Publish the joints message\n    self.joints_publisher.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    trajectory_msg = JointTrajectory()\n    trajectory_msg.header.stamp = self.get_clock().now().to_msg()\n    trajectory_msg.header.frame_id = \"base_link\"\n    trajectory_msg.joint_names = joints_msg.name\n    point = JointTrajectoryPoint()\n    point.positions = joints_msg.position\n    point.time_from_start = Duration(sec=2.0)\n    trajectory_msg.points.append(point)\n\n    # Publish the joint trajectory message\n    self.joint_trajectory_publisher.publish(trajectory_msg)\n}", "CodeBleu_score": 42.001440060418275}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joints_msg.position = joints.position[:12]\n\n    # Publish the joints message\n    self.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    joint_trajectory_msg = JointTrajectory()\n    joint_trajectory_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = Duration(sec=2)\n    joint_trajectory_msg.points.append(point)\n\n    # Publish the joint trajectory message\n    self.publish(joint_trajectory_msg)\n}", "CodeBleu_score": 43.7606436262356}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // Initialize foot contact states to false\n    contact_left_foot_ = false;\n    contact_right_foot_ = false;\n\n    // Iterate through each contact message\n    for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n        // Split the collision string to identify the contact link\n        std::vector<std::string> collision_strings;\n        boost::split(collision_strings, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n\n        // Check if the contact link matches one of the foot links\n        if (collision_strings[0] == \"foot_left_link\") {\n            contact_left_foot_ = true;\n        } else if (collision_strings[0] == \"foot_right_link\") {\n            contact_right_foot_ = true;\n        }\n    }\n}", "CodeBleu_score": 39.975020733844666}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contact_states[i] = false;\n  }\n\n  // Process each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string to identify the contact link\n    std::vector<std::string> contact_link_parts;\n    boost::split(contact_link_parts, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n    std::string contact_link = contact_link_parts[0];\n\n    // Check if the contact link matches one of the foot links\n    if (contact_link == \"left_front_foot_link\" || contact_link == \"right_front_foot_link\" ||\n        contact_link == \"left_hind_foot_link\" || contact_link == \"right_hind_foot_link\") {\n      // Set the corresponding foot contact state to true\n      if (contact_link == \"left_front_foot_link\") {\n        foot_contact_states[0] = true;\n      } else if (contact_link == \"right_front_foot_link\") {\n        foot_contact_states[1] = true;\n      } else if (contact_link == \"left_hind_foot_link\") {\n        foot_contact_states[2] = true;\n      } else if (contact_link == \"right_hind_foot_link\") {\n        foot_contact_states[3] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 50.60398616510238}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // Initialize foot contact states to false\n    for (int i = 0; i < 4; i++) {\n        foot_contact_states[i] = false;\n    }\n\n    // Process each contact in the message\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        // Split the collision string to identify the contact link\n        std::vector<std::string> contact_parts;\n        boost::split(contact_parts, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n        std::string contact_link = contact_parts[0];\n\n        // Check if the contact link matches one of the foot links\n        if (contact_link == \"foot_fl\" || contact_link == \"foot_fr\" || contact_link == \"foot_rl\" || contact_link == \"foot_rr\") {\n            // Set the corresponding foot contact state to true\n            if (contact_link == \"foot_fl\") {\n                foot_contact_states[0] = true;\n            } else if (contact_link == \"foot_fr\") {\n                foot_contact_states[1] = true;\n            } else if (contact_link == \"foot_rl\") {\n                foot_contact_states[2] = true;\n            } else if (contact_link == \"foot_rr\") {\n                foot_contact_states[3] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 50.861415184619595}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == rotor_count_);\n\n  rotor_velocities->resize(rotor_count_);\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_count_));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 87.3521291533696}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == rotor_count_);\n\n  rotor_velocities->resize(rotor_count_);\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_count_));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 87.3521291533696}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == rotor_count_);\n\n  rotor_velocities->resize(rotor_count_);\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  // Return 0 velocities on all rotors, until the first command is received.\n  if ( !command_trajectory_initialized_){\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 90.79097178159496}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(initialized_);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d acc_des;\n  acc_des = position_gain_.cwiseProduct(position_error) + velocity_gain_.cwiseProduct(velocity_error) +\n            odometry_.orientation.toRotationMatrix() * Eigen::Vector3d(0, 0, -gravity_) +\n            acceleration_gain_.cwiseProduct(command_trajectory_.acceleration_W);\n\n  *acceleration = acc_des;\n}", "CodeBleu_score": 74.7487269282551}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(initialized_);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d commanded_acceleration_world;\n  commanded_acceleration_world = command_trajectory_.acceleration_W;\n\n  *acceleration = position_gain_.cwiseProduct(position_error) +\n                   velocity_gain_.cwiseProduct(velocity_error) +\n                   commanded_acceleration_world / mass_;\n\n  *acceleration += gravity_;\n}", "CodeBleu_score": 73.88597669306144}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration != nullptr);\n\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  // Transform the velocity to the world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W = R_W_I * odometry_.velocity;\n  // Calculate the position error.\n  position_error = R_W_I.transpose() *\n                    (command_trajectory_.position_W - odometry_.position_W);\n  // Calculate the velocity error.\n  velocity_error = R_W_I.transpose() * (command_trajectory_.velocity_W - velocity_W);\n\n  Eigen::Vector3d acc_grav = R_W_I.col(2) * (-EARTH_GRAVITY);\n\n  *acceleration = position_error.cwiseProduct(position_gain_) +\n                   velocity_error.cwiseProduct(velocity_gain_) +\n                   acc_grav + command_trajectory_.acceleration_W;\n}", "CodeBleu_score": 63.90344157230198}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_);\n\n  rotor_velocities->resize(rotor_count_);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd angular_acceleration_thrust(4);\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = control_attitude_thrust_reference_(3);\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_count_) * min_rotor_velocity_);\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 81.65504325228221}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_);\n\n  rotor_velocities->resize(rotor_configuration_.rotors.size());\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd angular_acceleration_thrust(4);\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = control_attitude_thrust_reference_(3);\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_matrix_.transpose() * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 85.45114863993746}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_);\n\n  rotor_velocities->resize(rotor_configuration_.rotors.size());\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd angular_acceleration_thrust(4);\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = control_attitude_thrust_reference_(3);\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 89.8034225339529}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_obj = copy.deepcopy(self)\n    sliced_obj.time = self.time[start_index:end_index]\n    sliced_obj.value = self.value[start_index:end_index]\n    sliced_obj.units = self.units[start_index:end_index]\n    sliced_obj.description = self.description[start_index:end_index]\n    return sliced_obj\n\n", "CodeBleu_score": 29.553634693298854}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices for the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # Make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # Slice each attribute of the copied object\n    for attr in vars(copied_obj):\n        if isinstance(getattr(copied_obj, attr), list):\n            setattr(copied_obj, attr, getattr(copied_obj, attr)[start_index:end_index])\n\n    return copied_obj", "CodeBleu_score": 42.31447937836216}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.value = copied_obj.value[start_index:end_index]\n    copied_obj.quality = copied_obj.quality[start_index:end_index]\n    copied_obj.source = copied_obj.source[start_index:end_index]\n    copied_obj.notes = copied_obj.notes[start_index:end_index]\n    return copied_obj\n\n", "CodeBleu_score": 31.598305908167802}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert the rotation to Euler angles\n    _, _, yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object with the position and yaw values\n    point = Point(position.x, position.y, position.z, yaw)\n\n    # Check if the current waypoint is different from the last one\n    if not self.waypoints or point != self.waypoints[-1]:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.time.append(msg_time)\n        self.bag_time.append(bag_time)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 23.742790353912714}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    yaw = euler_from_quaternion(rotation.x, rotation.y, rotation.z, rotation.w)[2]\n    point = Point(position.x, position.y, position.z)\n    if self.last_point is None or self.last_yaw is None or (\n        position.x != self.last_point.x or position.y != self.last_point.y or yaw != self.last_yaw\n    ):\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_point = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 33.494490956853376}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    _, _, yaw = euler_from_quaternion([quaternion.x, quaternion.y, quaternion.z, quaternion.w])\n    point = Point(position.x, position.y, position.z)\n\n    if not self.waypoint_list or point != self.waypoint_list[-1].point or yaw != self.waypoint_list[-1].yaw:\n        self.waypoint_list.append(Waypoint(point, yaw))\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 33.32008239178525}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        msg_time = msg.header.stamp.to_sec()\n        self.append_times(msg_time, bag_time)\n        self.acc_x = numpy.append(self.acc_x, msg.linear_acceleration.x)\n        self.acc_y = numpy.append(self.acc_y, msg.linear_acceleration.y)\n        self.acc_z = numpy.append(self.acc_z, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 39.35421317224006}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        self.append_times(to_sec(msg.header.stamp), bag_time)\n    elif topic == '/imu/data_raw':\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        self.append_times(to_sec(msg.header.stamp), bag_time)\n\n", "CodeBleu_score": 31.447190700351875}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.ax = numpy.append(self.ax, msg.linear_acceleration.x)\n        self.ay = numpy.append(self.ay, msg.linear_acceleration.y)\n        self.az = numpy.append(self.az, msg.linear_acceleration.z)\n        self.time = numpy.append(self.time, msg.header.stamp.to_sec())\n        self.bag_time = numpy.append(self.bag_time, bag_time)\n    elif topic == '/imu/data_raw':\n        self.ax = numpy.append(self.ax, msg.linear_acceleration.x)\n        self.ay = numpy.append(self.ay, msg.linear_acceleration.y)\n        self.az = numpy.append(self.az, msg.linear_acceleration.z)\n        self.time = numpy.append(self.time, msg.header.stamp.to_sec())\n        self.bag_time = numpy.append(self.bag_time, bag_time)\n\n", "CodeBleu_score": 31.00844274520853}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    # Create a figure with a title\n    fig = pyplot.figure(figsize=(12, 8))\n    fig.suptitle('Accelerations')\n\n    # Create a subplot for accelerations\n    a_x = fig.add_subplot(3, 1, 1)\n    a_y = fig.add_subplot(3, 1, 2)\n    a_z = fig.add_subplot(3, 1, 3)\n\n    # Plot the x, y, and z components over time with different colors and labels\n    a_x.plot(self.time, self.a_x, 'r', label='x')\n    a_y.plot(self.time, self.a_y, 'g', label='y')\n    a_z.plot(self.time, self.a_z, 'b', label='z')\n\n    # Add labels for the x and y axes\n    a_z.set_xlabel('Time (s)')\n    a_x.set_ylabel('Acceleration (m/s^2)')\n    a_y.set_ylabel('Acceleration (m/s^2)')\n    a_z.set_ylabel('Acceleration (m/s^2)')\n\n    # Include a legend\n    a_x.legend()\n    a_y.legend()\n    a_z.legend()\n\n    # If saving plots is enabled, save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        fig.savefig(f'{self.plot_prefix}accelerations{plot_suffix}.png')\n\n", "CodeBleu_score": 38.592084597461486}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    fig = pyplot.figure(figsize=(12, 8))\n    fig.suptitle(f\"Accelerations for {self.name}\")\n\n    a_x = fig.add_subplot(311)\n    a_x.set_ylabel(\"x acceleration (m/s^2)\")\n    a_x.plot(self.time, self.a_x, color=\"red\", label=\"x acceleration\")\n    a_x.legend()\n\n    a_y = fig.add_subplot(312)\n    a_y.set_ylabel(\"y acceleration (m/s^2)\")\n    a_y.plot(self.time, self.a_y, color=\"green\", label=\"y acceleration\")\n    a_y.legend()\n\n    a_z = fig.add_subplot(313)\n    a_z.set_ylabel(\"z acceleration (m/s^2)\")\n    a_z.plot(self.time, self.a_z, color=\"blue\", label=\"z acceleration\")\n    a_z.legend()\n\n    if self.save_plots:\n        filename = f\"{self.name}_accelerations\"\n        if plot_suffix is not None:\n            filename += f\"_{plot_suffix}\"\n        filename += \".png\"\n        pyplot.savefig(filename)\n\n\n\n", "CodeBleu_score": 38.144550245195276}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    ax_a_x = fig.add_subplot(111)\n    for i, acceleration in enumerate(self.accelerations):\n        ax_a_x.plot(\n            self.times,\n            [\n                acceleration_component.x\n                for acceleration_component in acceleration.accelerations\n            ],\n            label=\"x\" + str(i),\n            color=\"r\",\n        )\n        ax_a_x.plot(\n            self.times,\n            [\n                acceleration_component.y\n                for acceleration_component in acceleration.accelerations\n            ],\n            label=\"y\" + str(i),\n            color=\"g\",\n        )\n        ax_a_x.plot(\n            self.times,\n            [\n                acceleration_component.z\n                for acceleration_component in acceleration.accelerations\n            ],\n            label=\"z\" + str(i),\n            color=\"b\",\n        )\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    if self.save_plots:\n        filename = \"accelerations\"\n        if plot_suffix:\n            filename += \"_\" + plot_suffix\n        pyplot.savefig(filename + \".png\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 39.61657889521085}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"At least two pose indeces are required to perform comparisons.\")\n        return\n\n    for i, index in enumerate(pose_indeces):\n        for j, subsequent_index in enumerate(pose_indeces[i+1:]):\n            compare_two_xyz(self.poses[index], self.poses[subsequent_index])\n\n", "CodeBleu_score": 54.47058202020436}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"At least two pose indices are required to perform comparisons.\")\n        return\n\n    for i, pose_index_one in enumerate(pose_indeces):\n        for j in range(i + 1, len(pose_indeces)):\n            pose_index_two = pose_indeces[j]\n            compare_two_xyz(pose_index_one, pose_index_two)\n\n", "CodeBleu_score": 43.69037723573443}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indices are required to perform comparisons.\")\n        return\n\n    for i, pose_index in enumerate(pose_indeces):\n        for j, other_pose_index in enumerate(pose_indeces[i+1:]):\n            compare_two_xyz(pose_index, other_pose_index)\n\n", "CodeBleu_score": 44.981391986592136}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time is not None and end_time is not None:\n            if time >= start_time and time <= end_time:\n                collision_times.append(time)\n        elif start_time is not None:\n            if time >= start_time:\n                collision_times.append(time)\n        elif end_time is not None:\n            if time <= end_time:\n                collision_times.append(time)\n        else:\n            collision_times.append(time)\n    return collision_times\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 40.406570633891704}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench.keys():\n        if start_time <= collision_time <= end_time:\n            collision_times.append(collision_time)\n    return collision_times\n\n", "CodeBleu_score": 38.75549238535944}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        time = collision.header.stamp.to_sec()\n        if start_time is not None and time < start_time:\n            continue\n        if end_time is not None and time > end_time:\n            continue\n        collision_times.append(time)\n    return collision_times\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 43.38105733011082}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  const float multiplier =\n      this->focal_length * this->baseline /\n      (this->min_depth * this->max_depth * this->min_depth * this->max_depth);\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  const float rms_noise = this->rms_noise * multiplier;\n  const float noise = rms_noise * rms_noise;\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (this->InRange(data_vector_map[i])) {\n      data_vector_map[i] += this->dist(this->generator) * noise;\n    } else {\n      data_vector_map[i] = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 57.41049042314099}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  float multiplier = this->k1 * this->k2 * this->k3 * 1000.0f;\n\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  float rms_noise = this->k1 * this->k2 * this->k3 * 1000.0f;\n\n  float noise_value = this->k1 * this->k2 * this->k3 * 1000.0f;\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (this->InRange(data[i])) {\n      data[i] += noise_value;\n    } else {\n      data[i] = bad_point;\n    }\n  }\n}", "CodeBleu_score": 42.70424110505581}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  const float multiplier =\n      this->k1 * this->k2 * this->k3 * this->horizontal_fov * this->vertical_fov;\n\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  const float rms_noise = this->rms_noise * multiplier;\n  const float noise = rms_noise * this->dist(this->gen);\n\n  for (int i = 0; i < data_vector_map.size(); i++) {\n    if (this->InRange(data_vector_map(i))) {\n      data_vector_map(i) += noise;\n    } else {\n      data_vector_map(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 50.34626693447864}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  gazebo::common::Time current_time = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 60.03292164776721}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time sim_time = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = sim_time.sec;\n  ros_time.nsec = sim_time.nsec;\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 62.56491486939082}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time now = world_->SimTime();\n  ros::Time ros_time(now.sec, now.nsec);\n\n  // Write trajectory message to bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectpoint_msg);\n}", "CodeBleu_score": 58.91423905661974}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time now_ros = ros::Time::now();\n\n  // Prepare a message for actuator velocities\n  mav_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n  // Iterate through the motor joints\n  for (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin();\n       m != motor_joints_.end(); ++m) {\n    // Calculate the slowed-down rotational velocities\n    double vel = m->second->GetVelocity(0) * rotor_velocity_slowdown_;\n\n    // Assign the velocities to the message\n    rot_velocities_msg.angular_velocities[m - motor_joints_.begin()] = vel;\n  }\n\n  // Set the message timestamp\n  rot_velocities_msg.header.stamp = now_ros;\n\n  // Write the data to a bag file\n  writeBag(motor_topic_, rot_velocities_msg, motor_bag_name_, motor_bag_namespace_);\n}", "CodeBleu_score": 60.85646562650157}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t    ros::Time ros_time = ros::Time::now();\n    rot_velocities_msg.header.stamp.sec = now.sec;\n    rot_velocities_msg.header.stamp.nsec = now.nsec;\n    for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n        rot_velocities_msg.angular_velocities[m - motor_joints_.begin()] = m->second->GetVelocity(0) * 1000.0;\n    }\n    rot_velocities_msg.header.frame_id = \"0\";\n    writeBag(ros_time, \"actuator_velocities\", rot_velocities_msg);\n}", "CodeBleu_score": 55.60871271012242}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert the simulation time to ROS time\n  ros::Time ros_now = ros::Time::now();\n\n  // Prepare a message for actuator velocities\n  gazebo_msgs::msgs::ActuatorVelocities rot_velocities_msg;\n\n  // Iterate through the motor joints\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Calculate the slowed-down rotational velocities\n    double rot_vel = m->second->GetVelocity(0) * rot_vel_slowdown_factor_;\n\n    // Assign the slowed-down rotational velocities to the message\n    rot_velocities_msg.add_angular_velocities(rot_vel);\n  }\n\n  // Set the message timestamp\n  rot_velocities_msg.set_time_usec(now.Double() * 1e6);\n\n  // Write the data to a bag file using the specified namespace and motor topic\n  writeBag(namespace_, motor_topic_, ros_now, rot_velocities_msg);\n}", "CodeBleu_score": 52.417463443739585}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert the normalized input values to control surface angles.\n  aileron_left_->SetAngle(NormalizedInputToAngle(\n      aileron_left_->GetControlSurface(),\n      roll_pitch_yawrate_thrust_msg->roll()));\n  aileron_right_->SetAngle(NormalizedInputToAngle(\n      aileron_right_->GetControlSurface(),\n      roll_pitch_yawrate_thrust_msg->roll()));\n  elevator_->SetAngle(NormalizedInputToAngle(\n      elevator_->GetControlSurface(),\n      roll_pitch_yawrate_thrust_msg->pitch()));\n  rudder_->SetAngle(NormalizedInputToAngle(\n      rudder_->GetControlSurface(),\n      roll_pitch_yawrate_thrust_msg->yaw_rate()));\n\n  // Set the throttle value from the thrust message.\n  throttle_->SetThrottle(roll_pitch_yawrate_thrust_msg->thrust());\n}", "CodeBleu_score": 61.5419640901808}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called.\n\";\n  }\n\n  double aileron_angle = NormalizedInputToAngle(\n      aileron_, roll_pitch_yawrate_thrust_msg->roll());\n  double elevator_angle = NormalizedInputToAngle(\n      elevator_, roll_pitch_yawrate_thrust_msg->pitch());\n  double rudder_angle = NormalizedInputToAngle(\n      rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n\n  if (debug_) {\n    gzdbg << \"aileron angle: \" << aileron_angle << \"\n\";\n    gzdbg << \"elevator angle: \" << elevator_angle << \"\n\";\n    gzdbg << \"rudder angle: \" << rudder_angle << \"\n\";\n    gzdbg << \"throttle: \" << throttle_ << \"\n\";\n  }\n}", "CodeBleu_score": 48.34259477667096}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << __FUNCTION__ << \" called.\" << std::endl;\n  }\n\n  double ailerons = NormalizedInputToAngle(\n      control_surfaces_.ailerons, roll_pitch_yawrate_thrust_msg->roll());\n  double elevator = NormalizedInputToAngle(\n      control_surfaces_.elevator, roll_pitch_yawrate_thrust_msg->pitch());\n  double rudder = NormalizedInputToAngle(\n      control_surfaces_.rudder, roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust().x();\n}", "CodeBleu_score": 61.31481621553135}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n\n  struct timeval timeout;\n  timeout.tv_sec = 0;\n  timeout.tv_usec = _timeoutMs * 1000;\n\n  int ret = select(_fd + 1, &readfds, nullptr, nullptr, &timeout);\n\n  if (ret < 0) {\n    // Select error...\n    return;\n  }\n\n  if (ret == 0) {\n    // Timeout...\n    return;\n  }\n\n  if (FD_ISSET(_fd, &readfds)) {\n    // There is data to read on the port...\n    uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n    ssize_t recvlen = recvfrom(_fd, buf, MAVLINK_MAX_PACKET_LEN, 0, nullptr,\n                               nullptr);\n\n    if (recvlen > 0) {\n      mavlink_message_t msg;\n      mavlink_status_t status;\n\n      for (ssize_t i = 0; i < recvlen; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_1, buf[i], &msg, &status)) {\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 55.04485451569438}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  fd_set readfds;\n  timeval timeout;\n  timeout.tv_sec = 0;\n  timeout.tv_usec = _timeoutMs * 1000;\n\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n\n  int ret = select(_fd + 1, &readfds, nullptr, nullptr, &timeout);\n\n  if (ret < 0) {\n    gzerr << \"Error on select(): \" << strerror(errno) << \"\n\";\n  } else if (ret == 0) {\n    // timeout\n  } else {\n    if (FD_ISSET(_fd, &readfds)) {\n      uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n      ssize_t recv_len = recvfrom(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0,\n                                  nullptr, nullptr);\n\n      if (recv_len > 0) {\n        mavlink_message_t msg;\n        mavlink_status_t status;\n\n        for (int i = 0; i < recv_len; i++) {\n          if (mavlink_parse_char(MAVLINK_COMM_1, buffer[i], &msg, &status)) {\n            handle_message(&msg);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 52.45421101422081}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  boost::mutex::scoped_lock lock(mutex);\n  if (is_open()) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable())\n      io_thread_.join();\n  }\n}", "CodeBleu_score": 75.15123475493989}, {"code": "void GazeboMavlinkInterface::close() {\n\t  boost::mutex::scoped_lock lock(mutex);\n  if (is_open()) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 68.73164459149605}, {"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::recursive_mutex> lock(mutex_);\n    if (is_open()) {\n        io_service_.stop();\n        serial_dev_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n    }\n}", "CodeBleu_score": 66.82019726986461}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d point1;\n    ignition::math::Vector3d point2;\n    double value1;\n    double value2;\n    double target_position;\n    double value;\n\n    if (target_position < point1.X()) {\n        value = value1;\n    } else if (target_position > point2.X()) {\n        value = value2;\n    } else {\n        value = value1 + (value2 - value1) * (target_position - point1.X()) / (point2.X() - point1.X());\n    }\n\n    return value;\n}", "CodeBleu_score": 39.63121989782812}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  this->timePos = _time;\n\n  if (this->timePos < 0.0) {\n    this->timePos = 0.0;\n  } else if (this->timePos > this->length) {\n    this->timePos = this->length;\n  }\n}", "CodeBleu_score": 44.39686173772377}, {"code": "void Animation::SetTime(double _time){\n\t  if (time != _time) {\n    time = _time;\n    if (time < 0) {\n      time = 0;\n    }\n    if (time > length) {\n      time = length;\n    }\n  }\n}", "CodeBleu_score": 31.688806281624842}, {"code": "void Animation::SetTime(double _time){\n\t  this->timePos = _time;\n  this->timePos = std::max(0.0, this->timePos);\n  this->timePos = std::min(this->timePos, this->Length());\n}", "CodeBleu_score": 30.638433584245817}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_motion = self.construct_target(x=self.local_position[0], y=self.local_position[1], z=self.local_position[2], yaw=self.yaw)\n    self.publish_target(target_motion)\n    print(\"Vehicle Type:\", self.vehicle_type, \"Vehicle ID:\", self.vehicle_id, \"Flight Mode:\", self.flight_mode)\n\n", "CodeBleu_score": 55.793295110798134}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = MAV_FRAME_LOCAL_NED\n    self.motion_type = 0\n    target_motion = self.construct_target(self.local_position[0], self.local_position[1], self.local_position[2], 0, 0, 0, 0, 0, 0, self.local_position[3])\n    self.send_mavlink(target_motion)\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 34.67791581945448}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_motion = self.construct_target(self.position[0], self.position[1], self.position[2], 0, 0, 0, 0, 0, 0, self.yaw, 0)\n    self.set_target_motion(target_motion)\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n", "CodeBleu_score": 53.17505670385319}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        print(self.vehicle_type+'_'+self.vehicle_id+': Mode switch success')\n        return True\n    else:\n        if self.flightModeService(custom_mode=self.flight_mode):\n            print(self.vehicle_type+'_'+self.vehicle_id+': Mode switch success')\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+': Mode switch failed')\n            return False\n\n\n\n", "CodeBleu_score": 53.25459331834516}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode switched to \"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode switch failed\")\n            return False", "CodeBleu_score": 64.85965691173085}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(\"Failed to switch to \"+self.flight_mode+\" mode\")\n            return False\n\n", "CodeBleu_score": 46.643001487258914}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n\n    if self.hover_flag == 0:\n        self.hover_state_transition(x, y, z, w)\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n\n", "CodeBleu_score": 59.074018028902195}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n    if self.flight_mode == \"HOVER\" and self.hover_flag == 0:\n        self.hover_flag = 1\n        self.hover()\n\n", "CodeBleu_score": 55.72686917679939}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != 'HOVER' and (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n    elif self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n\n", "CodeBleu_score": 77.55038065073387}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n\n    if self.flight_mode != 'HOVER' and (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n    elif self.flight_mode == 'HOVER' and abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        self.hover()\n\n", "CodeBleu_score": 65.6735809774449}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n\n", "CodeBleu_score": 24.26411761619382}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        return q.yaw_pitch_roll[0]\n\n", "CodeBleu_score": 42.03119669833365}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        return q.yaw_pitch_roll[0]\n\n", "CodeBleu_score": 42.03119669833365}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = MAV_FRAME_BODY_NED\n    self.motion_type = 0\n\n    target_motion = self.construct_target(self.local_position.pose.position.x, self.local_position.pose.position.y, self.local_position.pose.position.z, 0, 0, 0, 0, 0, 0, self.yaw, 0)\n    self.set_position_target_local_ned(target_motion)\n    print(\"Vehicle: \", self.vehicle_type, \"ID: \", self.vehicle_id, \"Flight Mode: \", self.flight_mode)\n\n", "CodeBleu_score": 36.25526212528079}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = MAV_FRAME_BODY_OFFSET_NED\n    self.motion_type = 2\n    self.target_motion = self.construct_target(0, 0, 0, 0, 0, 0, 0, 0, 0, self.yaw)\n    print(\"Hovering\")\n\n", "CodeBleu_score": 19.4029999480882}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = MAV_FRAME_BODY_NED\n    self.motion_type = 2\n    target_motion = self.construct_target(0, 0, 0, 0, 0, 0, 0, 0, 0, self.yaw)\n    print(\"Vehicle Type:\", self.vehicle_type, \"Vehicle ID:\", self.vehicle_id, \"Flight Mode:\", self.flight_mode)\n    return target_motion\n\n", "CodeBleu_score": 24.907602566729604}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n    else:\n        try:\n            flight_mode_service = self.vehicle_type + '_' + self.vehicle_id + \"/flight_mode_service\"\n            rospy.wait_for_service(flight_mode_service)\n            flight_mode_service = rospy.ServiceProxy(flight_mode_service, FlightModeService)\n            response = flight_mode_service(self.flight_mode)\n            if response.success:\n                self.flight_mode = self.flight_mode\n                print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n                return True\n            else:\n                print(\"Failed to switch to \" + self.flight_mode + \" flight mode\")\n                return False\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False", "CodeBleu_score": 41.64313696759638}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        self.flightModeService(self.flight_mode)\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 70.33796778327245}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except Exception as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Flight mode switch failed: \" + str(e))\n            return False\n\n", "CodeBleu_score": 68.16669578652558}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\n        self.local_pose = msg\n\n        if self.ground_control_station == \"px4\":\n            self.takeoff_target_pose = msg\n            self.hover_target_pose = msg\n\n        self.global_pose = copy.deepcopy(msg)\n        self.global_pose.pose.position.x += self.position_bias[0]\n        self.global_pose.pose.position.y += self.position_bias[1]\n        self.global_pose.pose.position.z += self.position_bias[2]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 30.154110168787874}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == 'world':\n        if msg.index == i:\n            self.local_pose = msg\n            self.global_pose = msg\n            self.global_pose.pose.position.x += self.bias[0]\n            self.global_pose.pose.position.y += self.bias[1]\n            self.global_pose.pose.position.z += self.bias[2]\n\n            if self.takeoff_command:\n                self.takeoff_target_pose = msg\n                self.takeoff_target_pose.pose.position.z = self.takeoff_height\n\n            if self.hover_command:\n                self.hover_target_pose = msg\n\n            if self.land_command:\n                self.land_target_pose = msg\n                self.land_target_pose.pose.position.z = 0.0\n\n            if self.go_to_command:\n                self.go_to_target_pose = msg\n                self.go_to_target_pose.pose.position.x = self.go_to_target_pose.pose.position.x + self.bias[0]\n                self.go_to_target_pose.pose.position.y = self.go_to_target_pose.pose.position.y + self.bias[1]\n                self.go_to_target_pose.pose.position.z = self.go_to_target_pose.pose.position.z + self.bias[2]\n\n            if self.follow_me_command:\n                self.follow_me_target_pose = msg\n                self.follow_me_target_pose.pose.position.x = self.follow_me_target_pose.pose.position.x + self.bias[0]\n                self.follow_me_target_pose.pose.position.y = self.follow_me_target_pose.pose.position.y + self.bias[1]\n                self.follow_me_target_pose.pose.position.z = self.follow_me_target_pose.pose.position.z + self.bias[2]\n\n            if self", "CodeBleu_score": 17.093709179987492}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n    if self.command == \"takeoff\":\n        self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n        self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n        self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z + self.takeoff_height\n        self.takeoff_target_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.takeoff_target_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.takeoff_target_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.takeoff_target_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n    elif self.command == \"hover\":\n        self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x\n        self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y\n        self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z\n        self.hover_target_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.hover_target_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.hover_target_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.hover_target_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n    self.global_pose = copy.deepcopy(self.local_pose)\n    self.global_pose.pose.position.x += self.bias_x\n    self.global_pose.pose.position.y += self.bias_y\n    self", "CodeBleu_score": 24.220975654240103}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 57.03249491742921}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 57.03249491742921}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 57.03249491742921}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    dist_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            dist = np.linalg.norm(orig_formation[i] - orig_formation[j])\n            dist_matrix[i][j] = int(50 - dist)\n    return dist_matrix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 26.3252579303146}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = np.zeros((len(orig_formation), len(orig_formation)), dtype=int)\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            distance = np.linalg.norm(orig_formation[i] - change_formation[j])\n            distance_matrix[i][j] = int(50 - distance)\n    return distance_matrix\n", "CodeBleu_score": 28.645078986490642}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n    for i, uav1 in enumerate(orig_formation):\n        for j, uav2 in enumerate(orig_formation):\n            dist_matrix[i][j] = int(50 - np.linalg.norm(uav1 - uav2))\n    return dist_matrix\n\n", "CodeBleu_score": 22.37375531704597}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.num_uav):\n        self.slack_right = [float('inf')] * self.num_target\n        while True:\n            self.visit_left = [False] * self.num_uav\n            self.visit_right = [False] * self.num_target\n            if self.find_path(i):\n                break\n            else:\n                d = float('inf')\n                for j in range(self.num_target):\n                    if not self.visit_right[j] and d > self.slack_right[j]:\n                        d = self.slack_right[j]\n                for j in range(self.num_uav):\n                    if self.visit_left[j]:\n                        self.label_left[j] -= d\n                for j in range(self.num_target):\n                    if self.visit_right[j]:\n                        self.label_right[j] += d\n                    else:\n                        self.slack_right[j] -= d\n\n    return [self.match_right[j] for j in range(self.num_target)]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 38.60708916037206}, {"code": "def KM(self)\n\t\n    for i in range(self.size):\n        self.slack_right = [float(\"inf\")] * self.size\n        while True:\n            self.visit_left = [False] * self.size\n            self.visit_right = [False] * self.size\n            if self.find_path(i):\n                break\n            d = float(\"inf\")\n            for j in range(self.size):\n                if not self.visit_right[j]:\n                    d = min(d, self.slack_right[j])\n            for j in range(self.size):\n                if self.visit_left[j]:\n                    self.label_left[j] -= d\n            for j in range(self.size):\n                if self.visit_right[j]:\n                    self.label_right[j] += d\n                else:\n                    self.slack_right[j] -= d\n    return self.match_right\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 45.1434058730564}, {"code": "def KM(self)\n\t\n    for i in range(self.n_left):\n        self.label_left[i] = max(self.adj_matrix[i])\n    self.label_right = [0] * self.n_right\n    for i in range(self.n_left):\n        while True:\n            self.visit_left = [False] * self.n_left\n            self.visit_right = [False] * self.n_right\n            self.slack_right = [float(\"inf\")] * self.n_right\n            if self.find_path(i):\n                break\n            d = float(\"inf\")\n            for j in range(self.n_right):\n                if not self.visit_right[j]:\n                    d = min(d, self.slack_right[j])\n            for j in range(self.n_left):\n                if self.visit_left[j]:\n                    self.label_left[j] -= d\n            for j in range(self.n_right):\n                if self.visit_right[j]:\n                    self.label_right[j] += d\n                else:\n                    self.slack_right[j] -= d\n    match_right = [-1] * self.n_right\n    for i in range(self.n_right):\n        if self.match_right[i] != -1:\n            match_right[i] = self.match_right[i]\n    return match_right\n\n", "CodeBleu_score": 40.19555898849249}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n\n    # Create a mask for yellow color using the defined bounds\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 30.440587715580143}, {"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 27.00416257573453}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.uint8([10, 100, 100])\n    upper_yellow = np.uint8([50, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 30.790466088041608}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t    // Search for the given ID in the standalone_tag_descriptions_ map\n    auto it = standalone_tag_descriptions_.find(id);\n    if (it != standalone_tag_descriptions_.end()) {\n        // If found, set the descriptionContainer to the tag's description and return true\n        descriptionContainer = it->second;\n        return true;\n    } else {\n        // If not found, log a warning message if printWarning is true and return false\n        if (printWarning) {\n            ROS_WARN_THROTTLE(10.0, \"Standalone tag description with ID %d not found\", id);\n        }\n        return false;\n    }\n}", "CodeBleu_score": 40.95303697045086}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  bool printWarning = true;\n  TagDescriptionContainer& descriptionContainer;\n  int id;\n  if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN_THROTTLE(10.0, \"Standalone tag description with ID = %d does not exist\", id);\n    }\n    return false;\n  }\n\n  descriptionContainer = standalone_tag_descriptions_[id];\n  return true;\n}", "CodeBleu_score": 48.70674982560368}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  // Search for the tag description by ID in the standalone_tag_descriptions_ map\n  auto it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end()) {\n    // If the description is not found and printWarning is true, log a warning message\n    if (print_warning) {\n      ROS_WARN_THROTTLE(10.0, \"Tag description with ID %d not found.\", id);\n    }\n    return false;\n  }\n  // If the description is found, set the descriptionContainer to the tag's description and return true\n  descriptionContainer = it->second;\n  return true;\n}", "CodeBleu_score": 38.38760054429684}]}
