{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Retrieve the list of required files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if the file exists locally\n    for (auto &file : files) {\n      if (download) {\n        if (!FileTransfer::FileExists(file)) {\n          RequestFile(file);\n          log_info(\"Downloaded file %s\", file.c_str());\n        } else {\n          log_info(\"Found file %s in cache\", file.c_str());\n        }\n      }\n    }\n\n    return files;\n  }", "CodeBleu_score": 65.2239164395714}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if the files are already downloaded\n    if (download) {\n        for (const auto &file : required_files) {\n            if (FileTransfer::FileExists(file)) {\n                log_info(\"Found file in cache: \" + file);\n            } else {\n                log_info(\"Downloading file: \" + file);\n                RequestFile(file);\n            }\n        }\n    }\n\n    return required_files;\n}", "CodeBleu_score": 67.5698664268813}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n      for (auto &file : required_files) {\n        // If the file does not exist, request it and log the download action\n        if (!FileTransfer::FileExists(file)) {\n          RequestFile(file);\n          log_info(\"Downloaded file: \" + file);\n        }\n        // Otherwise, log that the file is found in the cache\n        else {\n          log_info(\"Found file in cache: \" + file);\n        }\n      }\n    }\n\n    // Return the list of required files\n    return required_files;\n  }", "CodeBleu_score": 69.40169063394963}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tif (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.MakeSafeUnitVector().IsNearlyZero(1e-4f)) {\n      UE_LOG(LogCarla, Warning, TEXT(\"Attempted to spawn actor with invalid \"\n          \"transformation (only translation in z-axis).\"));\n    }\n  }\n  return _pimpl->CallAndWait<rpc::Actor>(\n      \"spawn_actor_with_parent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 46.23187332475137}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t// Check if the actor is valid\n    if (!description.IsValid()) {\n        throw_exception(std::invalid_argument, \"Actor description is not valid\");\n    }\n\n    // Check if the parent is valid\n    if (parent == 0) {\n        throw_exception(std::invalid_argument, \"Parent actor is not valid\");\n    }\n\n    // Check if the attachment type is valid\n    if (attachment_type != rpc::AttachmentType::Rigid &&\n        attachment_type != rpc::AttachmentType::SpringArm &&\n        attachment_type != rpc::AttachmentType::SpringArmGhost) {\n        throw_exception(std::invalid_argument, \"Attachment type is not valid\");\n    }\n\n    // Check if the attachment type is SpringArm or SpringArmGhost\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        // Check if the transformation is valid\n        if (!transform.IsValid()) {\n            throw_exception(std::invalid_argument, \"Actor transform is not valid\");\n        }\n\n        // Check if the transformation is valid\n        if (!transform.location.IsValid()) {\n            throw_exception(std::invalid_argument, \"Actor transform location is not valid\");\n        }\n\n        // Check if the transformation is valid\n        if (!transform.rotation.IsValid()) {\n            throw_exception(std::invalid_argument, \"Actor transform rotation is not valid\");\n        }\n\n        // Check if the transformation is valid\n        if (!transform.scale.IsValid()) {\n            throw_exception(std::invalid_argument, \"Actor transform scale is not valid\");\n        }\n\n        // Check if the transformation is valid\n        if (transform.location.MakeSafeUnitVector().SquaredLength() <\n            std::numeric_limits<float>::epsilon()) {\n            throw_exception(std::invalid_argument, \"Actor transform location is not valid\");\n        }\n\n        // Check if the transformation is valid\n        if (geom::Math::Dot(transform.location, transform.rotation.GetForwardVector()) >", "CodeBleu_score": 47.66108859920008}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t// Check if the transformation is valid for SpringArm and SpringArmGhost attachment types\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.location.MakeSafeUnitVector().Length() < 0.001f) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Actor %s has an invalid transformation\"),\n            *rpc::ToFString(description.id));\n      }\n    }\n\n    auto result = _pimpl->CallAndWait<rpc::Actor>(\n        \"spawn_actor_with_parent\",\n        description,\n        transform,\n        parent,\n        attachment_type,\n        socket_name);\n\n    if (result.HasError()) {\n      throw_exception(std::move(result).GetError());\n    }\n\n    return result.Get();\n  }", "CodeBleu_score": 50.14173874821085}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the G-buffer token\n    auto token = _pimpl->streaming_client.GetGBufferToken(ActorId, GBufferId);\n    // Copy the token data\n    std::vector<unsigned char> token_data(token.size);\n    std::memcpy(token_data.data(), token.data.get(), token_data.size());\n    // Subscribe to the streaming client\n    _pimpl->streaming_client.Subscribe(std::move(token_data), std::move(callback));\n}", "CodeBleu_score": 61.09294335623596}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer.\n    rpc::Token token = _pimpl->streaming_client.GetGBufferToken(ActorId, GBufferId);\n    // Get the token data.\n    const std::vector<uint8_t>& token_data = token.GetTokenData();\n    // Copy the token data to a new vector.\n    std::vector<uint8_t> token_data_copy(token_data.size());\n    std::memcpy(token_data_copy.data(), token_data.data(), token_data.size());\n    // Subscribe to the streaming client using the provided callback function.\n    _pimpl->streaming_client.Subscribe(std::move(token_data_copy), callback);\n}", "CodeBleu_score": 50.96280382913578}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer.\n    auto token_data = _pimpl->streaming_client.GetToken(ActorId, GBufferId);\n\n    // Copy the token data to a vector.\n    std::vector<unsigned char> token_vector(token_data.size);\n    std::memcpy(token_vector.data(), token_data.data, token_data.size);\n\n    // Subscribe to the streaming client using the provided callback function.\n    _pimpl->streaming_client.Subscribe(\n        ActorId,\n        GBufferId,\n        std::move(token_vector),\n        std::move(callback));\n}", "CodeBleu_score": 57.99760565612401}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n    while (navigation == nullptr) {\n        std::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>(this);\n        if (_walker_navigation.compare_exchange_strong(navigation, new_navigation)) {\n            navigation = new_navigation;\n        }\n    }\n    return navigation;\n}", "CodeBleu_score": 53.5951515889739}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tif (!_walker_navigation.load()) {\n        std::shared_ptr<WalkerNavigation> nav = std::make_shared<WalkerNavigation>();\n        if (_walker_navigation.compare_exchange_strong(nav, nav)) {\n            return nav;\n        }\n    }\n    return _walker_navigation.load();\n}", "CodeBleu_score": 43.05327323098606}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>();\n        if (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n            navigation = _walker_navigation.load();\n        }\n    }\n    return navigation;\n}", "CodeBleu_score": 53.17756545463499}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono;\n  auto start_time = system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    if (timeout.to_chrono() <= system_clock::now() - start_time) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 36.16849312594531}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono;\n  using namespace std::chrono_literals;\n\n  auto start_time = system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    if (system_clock::now() > (start_time + timeout)) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 37.25372141501373}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono;\n    const auto start_time = system_clock::now();\n    while (episode.GetState()->GetFrame() < frame) {\n        if (timeout.to_chrono() <= duration_cast<milliseconds>(system_clock::now() - start_time)) {\n            return false;\n        }\n        std::this_thread::yield();\n    }\n    episode.GetTrafficManager()->Tick();\n    return true;\n}", "CodeBleu_score": 39.14433429290302}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tif (GetCurrentEpisode().GetId() != 0u) {\n        throw std::runtime_error(\"Simulator::LoadEpisode: Attempting to load a new episode while another episode is already running.\");\n    }\n\n    std::string episode_name = map_name;\n    if (episode_name.empty()) {\n        episode_name = GetCurrentEpisode().GetMapName();\n    }\n\n    // Send the episode start request.\n    rpc::EpisodeSettings episode_settings;\n    episode_settings.set_map_name(episode_name);\n    episode_settings.set_reset_settings(reset_settings);\n    episode_settings.set_map_layers(map_layers);\n    _client.LoadEpisode(episode_settings);\n\n    // Wait for the episode to start.\n    std::chrono::microseconds timeout = _client.GetTimeout().milliseconds();\n    std::chrono::microseconds start_time = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch());\n    uint32_t episode_id = 0u;\n    while (true) {\n        if (_client.GetEpisodeSettings().map_name() == episode_name) {\n            episode_id = _client.GetEpisodeSettings().episode_id();\n            break;\n        }\n        if (std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() - start_time.count() > timeout.count()) {\n            throw std::runtime_error(\"Simulator::LoadEpisode: Failed to connect to the new episode.\");\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    // Wait for the episode to be ready.\n    _client.SendTickCue();\n    _episode.WaitForState(timeout, [this](rpc::EpisodeState episode_state) {\n        return episode_state.state() == rpc::EpisodeState::READ", "CodeBleu_score": 46.57900292584124}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tif (IsPending()) {\n        throw std::runtime_error(\"Cannot load episode while another operation is in progress\");\n    }\n\n    // Set the episode state to \"Loading\"\n    _episode->SetState(EpisodeState::Loading);\n\n    // Get the current episode ID\n    uint64_t current_episode_id = _episode->GetId();\n\n    // Load the new episode\n    _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n    // Wait for the episode to be ready\n    WaitForState(current_episode_id, EpisodeState::Ready);\n\n    // Return the episode\n    return EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 32.800068087884625}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tGetReadyCurrentEpisode();\n\n    // Load the new episode\n    _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n    // Wait until the new episode is ready\n    while (true) {\n        // Get the episode ID of the new episode\n        uint64_t episode_id = _client.GetEpisodeId();\n\n        // Check if the new episode is ready\n        if (_client.GetEpisodeSettings().GetId() == episode_id) {\n            return EpisodeProxy{shared_from_this()};\n        }\n\n        // Wait until the episode ID changes\n        _client.SendTickCue();\n        std::this_thread::sleep_for(_client.GetTimeout().milliseconds());\n    }\n}", "CodeBleu_score": 35.616112408951885}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tWalker *walker = GetWalker(controller.GetId());\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker not found for controller\");\n  }\n\n  DEBUG_ASSERT(_episode != nullptr, \"Episode is null\");\n  if (_episode->GetNavigation() == nullptr) {\n    _episode->CreateNavigationIfMissing();\n  }\n\n  _episode->GetNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 53.81689182796487}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(_episode != nullptr, \"Episode is null.\");\n\n  auto walker = _episode->FindWalker(controller.GetDisplayId());\n  DEBUG_ASSERT(walker != nullptr,\n               \"Walker is null. \" + controller.GetDisplayId());\n\n  _episode->CreateNavigationIfMissing();\n  _episode->GetNavigation()->RegisterWalker(controller.GetId(),\n                                           controller.GetParent(), walker);\n}", "CodeBleu_score": 52.97448943238619}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(_episode != nullptr, \"Episode is null\");\n\n  auto *nav = _episode->GetNavigation();\n  DEBUG_ASSERT(nav != nullptr, \"Navigation is null\");\n\n  auto *walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker is null\");\n  }\n\n  nav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 56.822057650016646}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tGetReadyCurrentEpisode();\n    ActorDescription actor_description;\n    actor_description.SetActorId(ActorId::GenerateRandomActorId());\n    actor_description.SetName(blueprint.GetName());\n    actor_description.SetParentId(parent == nullptr ? ActorId() : parent->GetId());\n    actor_description.SetTransform(transform);\n    actor_description.SetAttachmentType(attachment_type);\n    actor_description.SetSocketId(socket_name);\n    actor_description.SetTags(blueprint.GetTags());\n    actor_description.SetSemanticTags(blueprint.GetSemanticTags());\n    actor_description.SetPersistentLines(blueprint.GetPersistentLines());\n    actor_description.SetIsRecommended(blueprint.IsRecommended());\n    actor_description.SetIsEthereal(blueprint.IsEthereal());\n    actor_description.SetIsAutonomous(blueprint.IsAutonomous());\n    actor_description.SetIsActorEnabled(blueprint.IsActorEnabled());\n    actor_description.SetIsVisible(blueprint.IsVisible());\n    actor_description.SetIsCastingShadow(blueprint.IsCastingShadow());\n    actor_description.SetScriptVariables(blueprint.GetScriptVariables());\n    actor_description.SetLightSettings(blueprint.GetLightSettings());\n    actor_description.SetActorType(blueprint.GetActorType());\n    actor_description.SetAttachmentData(blueprint.GetAttachmentData());\n    actor_description.SetActorDescription(blueprint.GetActorDescription());\n    actor_description.SetTrafficLightStateData(blueprint.GetTrafficLightStateData());\n    actor_description.SetTrafficLightGroupData(blueprint.GetTrafficLightGroupData());\n    actor_description.SetTrafficSignData(blueprint.GetTrafficSignData());\n    actor_description.SetSpeedLimitData(blueprint.GetSpeedLimitData());\n    actor_description.SetRssSensorData(blueprint.GetRssSensorData());\n    actor_description.SetRssDynamicsData(blueprint.GetRss", "CodeBleu_score": 29.068590488781204}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tGetReadyCurrentEpisode();\n\n    ActorDescription description;\n    description.Uuid = blueprint.MakeActorDescription();\n    description.ParentId = parent ? parent->GetId() : \"\";\n    description.AttachmentType = attachment_type;\n    description.AttachmentSocketName = socket_name;\n    description.Transform = transform;\n\n    auto result = _client.SpawnActor(description, gc);\n    if (!result.HasError()) {\n      auto actor = Actor::MakeActor(result.GetActorId(), shared_from_this());\n      _episode->RegisterActor(actor);\n      log_debug(\"Spawned actor: \" + actor->GetDisplayId());\n      return actor;\n    }\n\n    log_error(\"Failed to spawn actor: \" + result.GetError().Message);\n    return nullptr;\n  }", "CodeBleu_score": 48.67291363244505}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tGetReadyCurrentEpisode();\n\n    auto actor = _episode->SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n    if (actor == nullptr) {\n      log_debug(\"Failed to spawn actor\");\n      return nullptr;\n    }\n\n    if (gc == GarbageCollectionPolicy::Inherit) {\n      gc = parent == nullptr ? GarbageCollectionPolicy::Enabled : parent->GetGarbageCollectionPolicy();\n    }\n\n    actor->SetGarbageCollectionPolicy(gc);\n\n    log_debug(\"Spawned actor\", actor->GetDisplayId(), actor->GetActorId());\n\n    return actor;\n  }", "CodeBleu_score": 48.128775822237394}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tif (!_episode_initialized) {\n        UE_LOG(LogCarla, Error, TEXT(\"Episode not initialized!\"));\n        return;\n    }\n\n    auto ep = _current_episode;\n    auto token = sensor.GetActorDescription().GetStreamToken();\n    if (token == 0u) {\n        UE_LOG(LogCarla, Error, TEXT(\"Sensor has an invalid token!\"));\n        return;\n    }\n\n    _client.SubscribeToStream(\n        token,\n        [this, ep, callback](auto buffer) {\n            SharedPtr<sensor::SensorData> data;\n            try {\n                data = sensor.GetActorDescription().GetSensorRegistry()->Deserialize(std::move(buffer));\n            } catch (const std::exception &e) {\n                UE_LOG(LogCarla, Error, TEXT(\"Failed to deserialize sensor data: %s\"), *carla::rpc::ToFString(e.what()));\n                return;\n            }\n            data->SetEpisode(ep);\n            callback(std::move(data));\n        });\n}", "CodeBleu_score": 50.945226677103946}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tif (!Episode->IsValid()) {\n        throw std::runtime_error(\"cannot subscribe to sensor, episode is not valid\");\n    }\n\n    auto &client = Episode->GetClient();\n    auto stream_token = sensor.GetActorDescription().GetStreamToken();\n    if (!stream_token.has_value()) {\n        throw std::runtime_error(\"cannot subscribe to sensor, sensor is not streaming\");\n    }\n\n    client.SubscribeToStream(\n        stream_token.value(),\n        [this, callback, stream_token](auto buffer) {\n            auto &client = Episode->GetClient();\n            auto &sensor = Episode->GetActorRegistry().Find(stream_token.value());\n            if (sensor == nullptr) {\n                UE_LOG(LogCarla, Warning, TEXT(\"cannot find sensor with token %d\"), stream_token.value());\n                return;\n            }\n\n            auto data = sensor::Deserializer::Deserialize(std::move(buffer));\n            data->SetActorRegistry(Episode->GetActorRegistry());\n            data->SetEpisode(Episode);\n            data->SetFrameNumber(client.GetEpisodeFrameNumber());\n            callback(data);\n        });\n}", "CodeBleu_score": 54.82341220174356}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tDEBUG_ASSERT(sensor.IsValid());\n    _client.SubscribeToStream(\n        sensor.GetActorDescription().GetStreamToken(),\n        [this, callback](SharedPtr<sensor::SensorData> data) {\n            // Associate the sensor data with the current episode.\n            data->SetEpisode(shared_from_this());\n            // Deserialize the sensor data.\n            sensor::Deserializer::Deserialize(data);\n            // Invoke the callback.\n            callback(data);\n        });\n}", "CodeBleu_score": 40.591419772416295}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// load the walkers\n    auto walkers = _walkers.Load(episode);\n\n    // check if empty\n    if (walkers->empty()) return;\n\n    // get the current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // check if walkers exist\n    CheckIfWalkerExist(*walkers, *state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode);\n\n    // update the crowd\n    _nav.UpdateCrowd();\n\n    // create the batch\n    std::vector<carla::rpc::Command> commands;\n    commands.reserve(walkers->size());\n\n    // for each walker\n    for (auto &&walker : *walkers) {\n      // get the transform\n      const auto transform = _nav.GetWalkerTransform(walker.walker);\n      // get the speed\n      const auto speed = _nav.GetWalkerSpeed(walker.walker);\n      // create the command\n      commands.emplace_back(carla::rpc::Command::ApplyWalkerState{walker.walker, transform, speed});\n    }\n\n    // apply the commands\n    _simulator.lock()->ApplyBatchSync(commands, true);\n\n    // check if any walker has been killed\n    for (auto &&walker : *walkers) {\n      if (!_nav.IsWalkerAlive(walker.walker)) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 56.5629415266519}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// load the current walkers\n    auto walkers = _walkers.Load();\n\n    // check if empty\n    if (walkers->empty())\n      return;\n\n    // get the current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // check if walker exists\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles\n    UpdateVehiclesInCrowd(episode);\n\n    // update the crowd\n    _nav.UpdateCrowd();\n\n    // get the current commands\n    auto commands = _nav.GetCommands();\n\n    // reserve the commands\n    commands.reserve(walkers->size());\n\n    // get the current time\n    auto current_time = episode->GetCurrentTime();\n\n    // get the batch\n    auto batch = _simulator.lock()->CreateBatch();\n\n    // for each walker\n    for (auto &&walker : *walkers) {\n      // get the transform\n      auto transform = _simulator.lock()->GetActorTransform(walker.walker);\n      // get the speed\n      auto speed = _nav.GetWalkerSpeed(walker.walker);\n      // create the command\n      commands.emplace_back(carla::rpc::Command::ApplyWalkerState{\n        walker.walker,\n        transform,\n        speed,\n        current_time\n      });\n    }\n\n    // apply the batch\n    _simulator.lock()->ApplyBatchSync(batch, commands, true);\n\n    // check if any walker is dead\n    for (auto &&walker : *walkers) {\n      // check if dead\n      if (_simulator.lock()->IsActorDead(walker.walker)) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n\n  }", "CodeBleu_score": 57.50653044837946}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// load the walkers\n    std::vector<WalkerHandle> walkers = LoadWalkers(episode);\n\n    // check if empty\n    if (walkers.empty()) return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // check if any walker exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode);\n\n    // update the crowd\n    _nav.UpdateCrowd();\n\n    // get the commands\n    std::vector<WalkerControl> commands;\n    commands.reserve(walkers.size());\n    for (auto &&walker : walkers) {\n      // get the transform\n      auto transform = _simulator.lock()->GetActorTransform(walker.walker);\n      // get the speed\n      auto speed = _simulator.lock()->GetActorVelocity(walker.walker);\n      // create the control\n      commands.emplace_back(WalkerControl{walker.walker, transform, speed});\n    }\n\n    // apply the commands\n    _simulator.lock()->ApplyBatchSync(commands, true);\n\n    // check if any walker is dead\n    for (auto &&walker : walkers) {\n      // check if dead\n      if (_simulator.lock()->IsActorDead(walker.walker)) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 50.21785624037489}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n    description.set_uid(uid);\n    description.set_id(id);\n    description.attributes.reserve(attributes.size());\n    for (auto attribute : attributes) {\n        description.attributes.push_back(attribute.as_rpc_attribute());\n    }\n    return description;\n}", "CodeBleu_score": 64.4134972558972}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.attributes.reserve(attributes.size());\n  for (auto &attribute : attributes) {\n    description.attributes.push_back(attribute.as_rpc_attribute());\n  }\n  return description;\n}", "CodeBleu_score": 66.60530500170563}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.set_uid(GetActorId());\n  description.set_id(GetActorClass());\n  description.attributes.reserve(attributes.size());\n  for (auto& attribute : attributes) {\n    description.attributes.push_back(attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 64.55619016647918}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tauto result = MakeShared<BlueprintLibrary>();\n    for (auto &pair : blueprints_) {\n        auto &blueprint = pair.second;\n        auto &attributes = blueprint.GetAttributes();\n        if (attributes.find(name) == attributes.end()) {\n            continue;\n        }\n        auto &attribute = attributes.at(name);\n        if (attribute.GetValue() == value || attribute.GetRecommendedValues().Contains(value)) {\n            result->emplace(pair.first, pair.second);\n        }\n    }\n    return result;\n}", "CodeBleu_score": 49.664670373112216}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tauto result = MakeShared<BlueprintLibrary>();\n    for (auto& pair : blueprints) {\n        if (pair.second.ContainsAttribute(name)) {\n            const auto& attribute = pair.second.GetAttribute(name);\n            if (attribute.GetValue() == value || attribute.GetRecommendedValues().Contains(value)) {\n                result->emplace(pair.first, pair.second);\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 43.81485986917906}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tauto result = MakeShared<BlueprintLibrary>();\n    for (const auto& pair : blueprints) {\n        if (pair.second.ContainsAttribute(name)) {\n            auto attribute = pair.second.GetAttribute(name);\n            if (attribute.GetValue() == value ||\n                attribute.GetRecommendedValues().Contains(value)) {\n                result->emplace(pair.first, pair.second);\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 44.15688603417484}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = GetFullPath(path);\n  if (!ValidateFilePath(fullPath)) {\n    return false;\n  }\n  std::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n  if (!out.good()) {\n    return false;\n  }\n  out.write((char*)content.data(), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 46.775142647979294}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Create the full file path using the base folder and version information.\n  std::string full_file_path = FileSystem::GetFullFilePath(path);\n\n  // Validate the file path.\n  if (!FileSystem::ValidateFilePath(full_file_path)) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents.\n  std::ofstream out(full_file_path, std::ios::binary | std::ios::trunc);\n\n  // Write the content.\n  out.write(reinterpret_cast<char*>(content.data()), content.size());\n\n  // Close the file.\n  out.close();\n\n  return true;\n}", "CodeBleu_score": 45.05101851416222}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string full_path = FileSystem::GetFullPath(path);\n  if (!FileSystem::ValidateFilePath(full_path)) {\n    return false;\n  }\n  std::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n  if (!out.good()) {\n    return false;\n  }\n  out.write(reinterpret_cast<const char *>(content.data()), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 48.22140130629634}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto &location = transform.location;\n    const auto &extent = GetExtent();\n    const auto &yaw = transform.rotation.yaw;\n\n    const auto left_front = Rotate(yaw, {location.x - extent.x, location.y - extent.y, location.z});\n    const auto right_front = Rotate(yaw, {location.x + extent.x, location.y - extent.y, location.z});\n    const auto left_back = Rotate(yaw, {location.x - extent.x, location.y + extent.y, location.z});\n    const auto right_back = Rotate(yaw, {location.x + extent.x, location.y + extent.y, location.z});\n\n    return std::make_shared<Bounds>(frame, left_front, right_front, left_back, right_back);\n  }", "CodeBleu_score": 52.6243312923818}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto location = transform.GetLocation() +\n                          parent_bounds_.GetLocation();\n    const float yaw = transform.GetRotation().yaw;\n    const auto extents = parent_bounds_.GetExtent();\n    const auto p1 = Rotate(yaw, geom::Location(-extents.x, -extents.y, 0));\n    const auto p2 = Rotate(yaw, geom::Location(extents.x, -extents.y, 0));\n    const auto p3 = Rotate(yaw, geom::Location(extents.x, extents.y, 0));\n    const auto p4 = Rotate(yaw, geom::Location(-extents.x, extents.y, 0));\n    return std::make_shared<const Bounds>(\n        frame,\n        location,\n        geom::Location(p1.x, p1.y, 0),\n        geom::Location(p2.x, p2.y, 0),\n        geom::Location(p3.x, p3.y, 0),\n        geom::Location(p4.x, p4.y, 0));\n  }", "CodeBleu_score": 40.93195993655371}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto &location = transform.location;\n    const auto &extent = _parent->GetExtent();\n    const auto &yaw = transform.rotation.yaw;\n    const auto &corners = geom::Math::GetCorners(_parent->GetExtent());\n    std::array<geom::Location, 4> rotated_corners;\n    for (size_t i = 0; i < 4; ++i) {\n      rotated_corners[i] = Rotate(yaw, corners[i] + location);\n    }\n    return std::make_shared<const Bounds>(frame, rotated_corners);\n  }", "CodeBleu_score": 37.67392295647862}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_episode.Lock()->GetMutex());\n    const auto lights_state = _episode.Lock()->GetLightManager().GetLightsState();\n    for (auto const &light_state : lights_state) {\n        auto found_light = _lights.find(light_state.id);\n        if (found_light == _lights.end()) {\n            _lights.insert(std::make_pair(light_state.id, std::make_shared<Light>(light_state, _episode)));\n        } else {\n            found_light->second->SetLightState(light_state);\n        }\n    }\n}", "CodeBleu_score": 41.650185248628375}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_episode_mutex);\n\n    // Get the current state of lights from the server\n    std::vector<rpc::LightState> light_states;\n    _client->QueryLightsState(light_states);\n\n    // Update the local light states\n    for (auto &light_state : light_states) {\n        // Get the light group\n        LightGroup group = static_cast<LightGroup>(light_state.group);\n\n        // Get the light from the map\n        auto it = _lights.find(light_state.id);\n        if (it == _lights.end()) {\n            // If the light does not exist in the map, create it\n            Light light(light_state.id, group);\n            _lights.insert({light_state.id, light});\n            it = _lights.find(light_state.id);\n        }\n\n        // Update the light state\n        it->second.SetLightState(light_state);\n    }\n}", "CodeBleu_score": 45.079228982704855}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tboost::mutex::scoped_lock lock(_mutex);\n  LightState::LightGroup lights;\n  _episode.Lock()->GetLightManager()->GetAllLightStates(lights);\n  for (auto &light : lights) {\n    auto it = _lights.find(light.first);\n    if (it == _lights.end()) {\n      _lights[light.first] = std::make_shared<Light>(light.second);\n    } else {\n      it->second->SetLightState(light.second);\n    }\n  }\n}", "CodeBleu_score": 33.96141103326028}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t_episode.Lock()->GetState()->SetAspectRatio(GetAspectRatio());\n    _episode.Lock()->GetState()->SetViewportDims(GetViewportDims());\n    _episode.Lock()->GetState()->SetVehicleTransform(GetVehicleTransform());\n    _episode.Lock()->GetState()->SetVehicleType(_vehicle_type);\n    _episode.Lock()->GetState()->SetMapName(_map_name);\n    _episode.Lock()->GetState()->SetMapUrl(_map_url);\n    _episode.Lock()->GetState()->SetWeatherParameters(_weather);\n\n    // Check if there are any changes\n    if (_lights_changes.size() == 0) {\n        return;\n    }\n\n    // Create message\n    std::vector<rpc::Command> message;\n    for (auto it_light = _lights.begin(); it_light != _lights.end(); ++it_light) {\n        if (it_light->second.GetStateChanged()) {\n            rpc::Command command;\n            command.set_type(rpc::Command::LIGHT_STATE_CHANGE);\n            command.set_light_id(it_light->first);\n            command.set_light_state(it_light->second.GetLightState());\n            command.set_light_color(it_light->second.GetColor());\n            command.set_light_intensity(it_light->second.GetIntensity());\n            command.set_light_location(it_light->second.GetLocation());\n            command.set_light_rotation(it_light->second.GetRotation());\n            command.set_light_direction(it_light->second.GetDirection());\n            command.set_light_range(it_light->second.GetRange());\n            command.set_light_attenuation_linear(it_light->second.GetAttenuationLinear());\n            command.set_light_attenuation_quadratic(it_light->second.GetAttenuationQuadratic());\n            command.set_light_attenuation_angular(it_light", "CodeBleu_score": 30.971875194839924}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n  if (_lights_changes.empty()) {\n    return;\n  }\n  std::vector<rpc::LightState> message;\n  message.reserve(_lights_changes.size());\n  for (const auto& light_change : _lights_changes) {\n    message.push_back(light_change.second.GetLightStateMessage());\n  }\n  _episode.Lock()->UpdateServerLightsState(message, discard_client);\n  _lights_changes.clear();\n  _lights_dirty = false;\n}", "CodeBleu_score": 40.480664790274}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(mutex);\n    if (lights_changes.empty()) {\n        return;\n    }\n    rpc::LightStateList message;\n    message.mutable_lights()->Reserve(lights_changes.size());\n    for (auto &it : lights_changes) {\n        message.mutable_lights()->Add()->CopyFrom(it.second.GetLightState());\n    }\n    if (discard_client) {\n        message.set_discard_client_light_states(true);\n    }\n    EpisodeProxy episode = episode_.Lock();\n    episode.Lock()->GetClient()->SendMessage(message);\n    lights_changes.clear();\n}", "CodeBleu_score": 37.03636676020704}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"ServerSideSensor::Send\");\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not sensor.other.v2x_custom\");\n        return;\n    }\n    GetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 57.19138059269567}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"ServerSideSensor::Send()\");\n  if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"Sensor ID does not match expected value\");\n    return;\n  }\n  GetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 55.60140054554314}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"ServerSideSensor::Send\");\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not sensor.other.v2x_custom\");\n        return;\n    }\n    GetEpisode().Lock()->Send({\n        GetDisplayId(),\n        GetActorDescription().GetSensorId(),\n        message\n    });\n}", "CodeBleu_score": 59.27966781563798}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n        SetTrafficManager(tm_port);\n    } else {\n        UnsetTrafficManager();\n    }\n}", "CodeBleu_score": 32.98438855193729}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n        // Register with the traffic manager\n        SetTrafficManagerPort(tm_port);\n        SetTrafficManager(true);\n    } else {\n        // Unregister from the traffic manager\n        SetTrafficManager(false);\n        SetTrafficManagerPort(0);\n    }\n}", "CodeBleu_score": 38.20175152307698}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tSetAutopilot(enabled, tm_port, 0);\n}", "CodeBleu_score": 25.97319709031458}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());\n  check(GetEpisode().IsValid());", "CodeBleu_score": 32.93486020773007}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\t\n\t// Get the episode\n\tUCarlaEpisode* episode = GetEpisode();\n\tif (episode == nullptr) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"Episode not found\"));\n\t\treturn;\n\t}\n\t\n\t// Get the walker\n\tauto walker = GetWalker();\n\tif (walker == nullptr) {\n\t\tUE_LOG(LogCarla, Error, TEXT(\"Walker not found\"));\n\t\treturn;\n\t}\n\t\n\t// Register the controller with the episode\n\tepisode->RegisterAIController(this);\n\t\n\t// Add the walker to the navigation system\n\tepisode->Lock()->GetNavigation()->AddWalker(walker->GetId(), walker->GetLocation());\n\t\n\t// Disable collisions and physics for the walker\n\tepisode->Lock()->SetActorCollisions(walker, false);\n\tepisode->Lock()->SetActorSimulatePhysics(walker, false);\n}", "CodeBleu_score": 47.40407160608435}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n    // Get the walker actor\n    AWalkerCharacter* walker = Cast<AWalkerCharacter>(GetPawn());\n    if (walker == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::Start: Walker is not a WalkerCharacter\"));\n        return;\n    }\n    // Get the episode\n    UCarlaEpisode* episode = GetEpisode();\n    if (episode == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::Start: Episode is null\"));\n        return;\n    }\n    // Get the navigation system\n    ANavigationSystem* nav = episode->GetNavigation();\n    if (nav == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::Start: Navigation system is null\"));\n        return;\n    }\n    // Add the walker to the navigation system\n    nav->AddWalker(walker->GetWalkerAgent(), walker->GetLocation());\n    // Disable physics simulation and collisions for the walker\n    episode->Lock()->SetActorCollisions(walker, false);\n    episode->Lock()->SetActorSimulatePhysics(walker, false);\n}", "CodeBleu_score": 43.86842406807422}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tUAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", \"Started\", LogDebugLevel::Informational);\n\n    // Get the current episode\n    UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", \"GetEpisode\", LogDebugLevel::Informational);\n    APawn* pawn = GetPawn();\n    if (pawn == nullptr) {\n        UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", \"Pawn is null\", LogDebugLevel::Failure);\n        return;\n    }\n    AWalkerAI* walker = Cast<AWalkerAI>(pawn);\n    if (walker == nullptr) {\n        UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", \"Walker is null\", LogDebugLevel::Failure);\n        return;\n    }\n\n    // Get the navigation instance\n    UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", \"GetEpisode().Lock()\", LogDebugLevel::Informational);\n    FActorRegistry* actor_registry = GetEpisode().Lock()->GetActorRegistry();\n    if (actor_registry == nullptr) {\n        UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", \"actor_registry is null\", LogDebugLevel::Failure);\n        return;\n    }\n    FActorView* walker_view = actor_registry->GetActorView(walker->GetId());\n    if (walker_view == nullptr) {\n        UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", \"walker_view is null\", LogDebugLevel::Failure);\n        return;\n    }\n    AWalkerNavigation* nav = walker_view->GetNavigation();\n    if (nav == nullptr) {\n        UAirBlueprintLib::LogMessageString(\"WalkerAIController::SetMaxSpeed\", \"nav is null\", LogDebugLevel::Failure);\n        return;\n    }\n\n    // Set the maximum speed\n    UAirBlue", "CodeBleu_score": 42.09237152293166}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t// Get the current episode\n  auto episode = GetEpisode();\n  // Check if it is valid\n  if (!episode.IsValid()) {\n    log_warning(\"Cannot set walker max speed. The episode is not valid.\");\n    return;\n  }\n  // Get the navigation instance from the episode\n  auto nav = episode.Lock()->GetNavigation();\n  // Check if it is valid\n  if (!nav) {\n    log_warning(\"Cannot set walker max speed. The navigation instance is not valid.\");\n    return;\n  }\n  // Get the parent walker\n  auto walker = GetParent();\n  // Check if it is valid\n  if (!walker) {\n    log_warning(\"Cannot set walker max speed. The parent walker is not valid.\");\n    return;\n  }\n  // Attempt to set the maximum speed of the walker\n  if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n    log_warning(\"Failed to set walker max speed.\");\n  }\n}", "CodeBleu_score": 58.4514656016547}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tif (episode_ == nullptr) {\n    log_warning(\"Can't set max speed when no episode is set.\");\n    return;\n  }\n  auto nav = episode_->GetNavigation();\n  if (nav == nullptr) {\n    log_warning(\"Can't set max speed when no navigation is set.\");\n    return;\n  }\n  auto walker = GetWalker();\n  if (walker == nullptr) {\n    log_warning(\"Can't set max speed when no walker is set.\");\n    return;\n  }\n  if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n    log_warning(\"Failed to set max speed for walker: \" + walker->GetDisplayId());\n  }\n}", "CodeBleu_score": 57.90404758824703}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n  result.reserve(static_cast<size_t>(distance / _parent->GetMap().GetResolution()));\n  for (auto& waypoint : _parent->GetMap().GetPrevious(this, distance)) {\n    result.emplace_back(std::make_shared<Waypoint>(waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 56.320932384248565}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n  if (distance <= 0.0) {\n    return result;\n  }\n\n  auto waypoints = _parent->GetMap().GetPrevious(distance, _location);\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(std::move(std::make_shared<Waypoint>(_parent, waypoint)));\n  }\n\n  return result;\n}", "CodeBleu_score": 72.04108927328389}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &wp : _parent->GetMap().GetPrevious(this, distance)) {\n        result.emplace_back(std::make_shared<Waypoint>(*wp));\n    }\n    return result;\n}", "CodeBleu_score": 56.062636992651505}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n  std::set<SharedPtr<Signal>> added_signals;\n  for (SharedPtr<Signal> signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    if (added_signals.count(signal) == 0) {\n      added_signals.insert(signal);\n      result.emplace_back(\n          SharedPtr<Landmark>(new Landmark(signal, _parent)));\n    }\n  }\n  return result;\n}", "CodeBleu_score": 36.29445120548395}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n\n  // Get the signals within the distance\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n  // Create a set to avoid duplicates\n  std::set<SharedPtr<Signal>> added_signals;\n\n  // For each signal\n  for (SharedPtr<Signal> signal : signals) {\n    // If it has not been added yet\n    if (added_signals.count(signal) == 0) {\n      // Add it to the set\n      added_signals.insert(signal);\n\n      // Create a new waypoint\n      SharedPtr<Waypoint> waypoint = _parent->GetMap().GetWaypoint(signal->GetLocation());\n\n      // Create a new landmark\n      SharedPtr<Landmark> landmark = _parent->GetMap().CreateLandmark(waypoint);\n\n      // Add the landmark to the result\n      result.emplace_back(landmark);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 49.69531506006564}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n\n  // Get all signals within the distance\n  std::vector<SharedPtr<Waypoint>> signals = GetSignalsInDistance(distance);\n\n  // Create a set to avoid duplicates\n  std::set<SharedPtr<Waypoint>> added_signals;\n\n  // For each signal, check if it is already in the set\n  // If not, add it to the set and create a new Landmark\n  for (auto& signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      // Create a new Landmark\n      SharedPtr<Landmark> landmark =\n          SharedPtr<Landmark>(new Landmark(signal->GetId(), signal->GetTransform()));\n\n      // Add the signal to the set\n      added_signals.insert(signal);\n\n      // Add the Landmark to the result\n      result.emplace_back(landmark);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 41.91536374979964}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    uint64_t settings_id = _episode.Lock()->SetEpisodeSettings(settings, local_timeout);\n    if (settings.fixed_delta_seconds.has_value()) {\n        const float epsilon = std::numeric_limits<float>::epsilon();\n        float fixed_delta = settings.fixed_delta_seconds.get();\n        float delta = 0.0f;\n        for (uint32_t i = 0; i < 1000u; ++i) {\n            uint64_t curr_snapshot = Tick(local_timeout);\n            delta = GetSnapshot().GetTimestamp().delta_seconds;\n            if (abs(delta - fixed_delta) < epsilon) {\n                break;\n            }\n        }\n        if (abs(delta - fixed_delta) > epsilon) {\n            log_warning(\n                \"Fixed delta seconds setting not correctly applied. \"\n                \"Expected: \" +\n                std::to_string(fixed_delta) + \" seconds, \"\n                \"Actual: \" +\n                std::to_string(delta) + \" seconds.\");\n        }\n    }\n    return settings_id;\n  }", "CodeBleu_score": 59.905737989119544}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    const auto &new_settings = _episode.Lock()->SetEpisodeSettings(settings, local_timeout);\n    if (new_settings.fixed_delta_seconds.has_value()) {\n        const auto curr_snapshot = GetSnapshot();\n        const auto curr_time = curr_snapshot.GetTimestamp().elapsed_seconds;\n        const auto delta = new_settings.fixed_delta_seconds.get();\n        const auto num_ticks = static_cast<uint64_t>(std::ceil(std::abs(curr_time / delta)));\n        const auto new_time = curr_time + (num_ticks * delta);\n        const auto max_diff = std::numeric_limits<float>::epsilon() * 10.0f;\n        for (uint64_t i = 0; i < num_ticks; ++i) {\n            const auto start_time = curr_time + (i * delta);\n            const auto end_time = start_time + delta;\n            Tick(local_timeout);\n            const auto new_snapshot = GetSnapshot();\n            const auto new_time = new_snapshot.GetTimestamp().elapsed_seconds;\n            if (std::abs(new_time - end_time) > max_diff) {\n                log_warning(\n                    \"Fixed delta seconds setting not correctly applied after\",\n                    num_ticks,\n                    \"ticks. Delta time is\",\n                    new_time - start_time,\n                    \"instead of\",\n                    delta);\n                break;\n            }\n        }\n    }\n    return new_settings.id;\n  }", "CodeBleu_score": 56.207088939595785}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    uint64_t settings_id = _episode.Lock()->SetEpisodeSettings(settings, local_timeout);\n    if (settings.fixed_delta_seconds.has_value()) {\n        const float fixed_delta_seconds = settings.fixed_delta_seconds.value();\n        if (std::abs(fixed_delta_seconds - _episode.Lock()->GetWorldSettings().fixed_delta_seconds) > std::numeric_limits<float>::epsilon()) {\n            log_warning(\"The requested fixed delta seconds value of\", fixed_delta_seconds, \"is not correct. The actual fixed delta seconds is\", _episode.Lock()->GetWorldSettings().fixed_delta_seconds);\n        }\n    }\n    return settings_id;\n  }", "CodeBleu_score": 43.93443841271699}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t/*\n     * Computes the squared length of the segment and its length.\n     */\n    auto segmentLengthSquared = (segmentEnd - segmentStart).LengthSquared();\n    auto segmentLength = std::sqrt(segmentLengthSquared);\n    /*\n     * If the segment length is zero, it returns zero and the distance from the point to one endpoint.\n     */\n    if (segmentLengthSquared < 1.192092896e-07F) {\n        return std::make_pair(0.0f, (point - segmentStart).Length());\n    }\n    /*\n     * Otherwise, it projects the point onto the segment, clamps the projection, and returns the distance along the segment and the distance from the projection to the point.\n     */\n    auto projection = segmentStart + Dot2D(point - segmentStart, segmentEnd - segmentStart) / segmentLengthSquared * (segmentEnd - segmentStart);\n    return std::make_pair(Distance2D(segmentStart, projection), Distance2D(projection, point));\n}", "CodeBleu_score": 35.311849233487294}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t/*\n\t * This function, Math::DistanceSegmentToPoint, calculates the shortest distance from a point to a line segment in 2D space.", "CodeBleu_score": 7.319039389195646}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t/*\n\t * The squared length of the segment.\n\t */\n\tfloat squaredLength;\n\t/*\n\t * The length of the segment.\n\t */\n\tfloat length;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance2;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance3;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance4;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance5;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance6;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance7;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance8;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance9;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance10;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance11;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance12;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance13;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance14;\n\t/*\n\t * The distance from the point to the projection of the point onto the segment.\n\t */\n\tfloat distance15;\n\t/*\n\t * The distance from the point to the projection", "CodeBleu_score": 11.326784286290739}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n\n    size_t initial_index = GetVerticesNum();\n    AddVertices(vertices);\n\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 56.29920365017412}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n    index_type index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 2; i < vertices.size(); ++i) {\n      AddIndex(index);\n      AddIndex(index + i);\n      AddIndex(index + i - 1);\n    }\n  }", "CodeBleu_score": 53.953382070651635}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n    size_t initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 2; i < vertices.size(); ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i - 1);\n      AddIndex(initial_index + i);\n    }\n  }", "CodeBleu_score": 56.15253225015701}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(_strand.running_in_this_thread());\n\n  if (message->empty()) {\n    LOG_ERROR(\"Primary::Write: message is empty\");\n    return;\n  }\n\n  _strand.post([this, self = shared_from_this(), message]() {\n    if (!self->_socket.is_open()) {\n      LOG_ERROR(\"Primary::Write: socket is not open\");\n      return;\n    }\n\n    self->_deadline.expires_from_now(boost::posix_time::milliseconds(_timeout));\n\n    auto buffer = message->GetBufferSequence();\n\n    boost::asio::async_write(\n        self->_socket,\n        buffer,\n        self->_strand.wrap(boost::asio::bind_executor(\n            self->_strand,\n            [this, self = shared_from_this(), message](const boost::system::error_code &ec, std::size_t bytes) {\n              if (ec) {\n                log_error(\"Primary::Write:\", ec.message());\n                self->CloseNow();\n              } else {\n                DEBUG_ASSERT(bytes == message->size());\n              }\n            })));\n  });\n}", "CodeBleu_score": 54.79910197226939}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  if (!message->empty()) {\n    auto self = shared_from_this();\n    _strand.post([self, message]() {\n      if (self->_socket.is_open()) {\n        self->_deadline.expires_from_now(boost::posix_time::seconds(1));\n        boost::asio::async_write(\n            self->_socket,\n            message->GetBufferSequence(),\n            boost::asio::bind_executor(\n                self->_strand,\n                [self, message](boost::system::error_code ec, size_t) {\n                  self->handle_sent(ec, message);\n                }));\n      } else {\n        log_error(\n            \"Primary\",\n            \"ignoring message to closed connection: \",\n            message->GetType());\n      }\n    });\n  }\n}", "CodeBleu_score": 42.02480965022753}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->GetSize() > 0u);\n  DEBUG_ASSERT(message->GetSize() <= carla::streaming::detail::tcp::MAX_MESSAGE_SIZE);\n  DEBUG_ASSERT(message->GetBufferSequence().size() == 1u);\n  DEBUG_ASSERT(message->GetBufferSequence().begin()->size() == message->GetSize());\n  DEBUG_ASSERT(message->GetBufferSequence().begin()->data() != nullptr);\n  DEBUG_ASSERT(message->GetBufferSequence().begin()->data() == message->GetData());\n\n  auto self = shared_from_this();\n  self->_strand.post([self, message]() {\n    if (!self->_socket.is_open()) {\n      log_error(self->_logger, \"Write: socket is not open\");\n      return;\n    }\n\n    self->_deadline.expires_from_now(self->_timeout);\n    boost::asio::async_write(\n        self->_socket,\n        message->GetBufferSequence(),\n        boost::asio::bind_executor(\n            self->_strand,\n            [self, message](const boost::system::error_code &ec, std::size_t) {\n              self->_deadline.cancel();\n              if (ec) {\n                log_error(self->_logger, \"Write: \", ec.message());\n                self->CloseNow();\n              }\n            }));\n  });\n}", "CodeBleu_score": 45.42891792919034}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t// Cancel the deadline timer.\n\t_deadline.cancel();\n\n\t// If no error code is provided and the socket is open, shut down and close the socket.\n\tif (!ec && _socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t_socket.close(ec);\n\t}\n\n\t// Trigger the on_closed callback and log that the session has been closed.\n\tif (_on_closed) {\n\t\t_on_closed();\n\t}\n\tlog_debug(\"Session closed.\");\n}", "CodeBleu_score": 54.73497425460685}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\n\n  if (!ec) {\n    if (_socket.is_open()) {\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n      _socket.close(ec);\n    }\n  }\n\n  if (ec) {\n    log_debug(\"Error closing connection\", ec);\n  }\n\n  if (_on_closed) {\n    _on_closed();\n  }\n\n  log_debug(\"Session closed\");\n}", "CodeBleu_score": 69.20506151281755}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\n\n  if (!ec) {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n      _socket.close(ec);\n    }\n  }\n\n  _on_closed(ec);\n  log_debug(\"session closed\");\n}", "CodeBleu_score": 65.27951774094024}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\tstd::string msg = \"Are you alive?\";\n  std::vector<unsigned char> buffer = std::vector<unsigned char>(msg.begin(), msg.end());\n  log_info(\"Sending message: %s\", msg.c_str());\n  _router->WriteToNext(buffer, YOU_ALIVE);\n  std::vector<unsigned char> response;\n  _router->ReadFromNext(&response);\n  log_info(\"Received message: %s\", response.data());\n}", "CodeBleu_score": 50.410551519918734}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t// Create a buffer from the message\n  std::unique_ptr<Buffer> buffer = std::make_unique<Buffer>(\n      std::vector<std::uint8_t>(msg.begin(), msg.end()));\n  // Log the sending action\n  log_info(logger, \"Sending message: {}\", msg);\n  // Write the buffer to the next router with the command YOU_ALIVE\n  _router->WriteToNext(buffer, YOU_ALIVE);\n  // Wait for and log the response from the system\n  auto fut = _router->ReadFromNext();\n  auto response = fut.get();\n  log_info(logger, \"Received response: {}\",\n           std::string(response.buffer.data.begin(), response.buffer.data.end()));\n}", "CodeBleu_score": 52.93427714508072}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tstd::string msg = \"Are you alive?\";\n    std::vector<uint8_t> buffer = std::vector<uint8_t>(msg.begin(), msg.end());\n    log_info(msg);\n    _router->WriteToNext(buffer, YOU_ALIVE);\n    std::future<std::vector<uint8_t>> fut = _router->ReadFromNext();\n    std::vector<uint8_t> response = fut.get();\n    msg = std::string(response.begin(), response.end());\n    log_info(msg);\n}", "CodeBleu_score": 50.26526213190377}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Check if the sensor is active on any secondary server.\n  bool found = false;\n  for (auto &server : _servers) {\n    if (server.second->IsSensorActive(sensor_id)) {\n      found = true;\n      break;\n    }\n  }\n\n  // If the sensor is not active on any server, log an error message.\n  if (!found) {\n    log_error(\"Sensor %d not found on any secondary server\", sensor_id);\n    return;\n  }\n\n  // Create a buffer with the sensor ID.\n  Buffer buffer;\n  buffer.data.resize(sizeof(stream_id));\n  *reinterpret_cast<stream_id *>(buffer.data.data()) = sensor_id;\n\n  // Send an ENABLE_ROS command to the server using the router.\n  auto fut = _router->WriteToOne(buffer, _servers.find(sensor_id)->second->GetId());\n  fut.get();\n\n  // Wait for and process the server's response.\n  Buffer response;\n  response.data.resize(sizeof(bool));\n  fut = _router->ReadFromOne(response, _servers.find(sensor_id)->second->GetId());\n  fut.get();\n\n  // If the sensor is not found on any server, log an error message.\n  if (*reinterpret_cast<bool *>(response.data.data())) {\n    log_error(\"Sensor %d not found on any secondary server\", sensor_id);\n    return;\n  }\n}", "CodeBleu_score": 52.013043919919454}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tauto fut = _router->WriteToOne(\n      std::make_shared<Command>(Command::ENABLE_ROS, sensor_id));\n  auto response = fut.get();\n  if (response.buffer.data == nullptr) {\n    log_error(\"Sensor not found on any server\");\n  }\n}", "CodeBleu_score": 31.073315414821906}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tauto it = _servers.find(sensor_id);\n    if (it != _servers.end()) {\n        std::string buffer = \"ENABLE_ROS \" + std::to_string(sensor_id);\n        auto fut = _router->WriteToOne(it->second, buffer.data(), buffer.size());\n        fut.get();\n        std::string response;\n        if (_router->ReadFromOne(it->second, response)) {\n            if (response.compare(\"OK\") == 0) {\n                _logger->info(\"Sensor \" + std::to_string(sensor_id) + \" has been enabled for ROS.\");\n            } else {\n                _logger->error(\"Sensor \" + std::to_string(sensor_id) + \" could not be enabled for ROS.\");\n            }\n        } else {\n            _logger->error(\"Sensor \" + std::to_string(sensor_id) + \" could not be enabled for ROS.\");\n        }\n    } else {\n        _logger->error(\"Sensor \" + std::to_string(sensor_id) + \" could not be enabled for ROS.\");\n    }\n}", "CodeBleu_score": 53.27376082482527}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"already activated\");\n    return it->second;\n  }\n\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(buf));\n\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  _tokens.insert(std::make_pair(sensor_id, new_token));\n  return new_token;\n}", "CodeBleu_score": 53.70569436487076}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_debug(\"GetToken: \", sensor_id);\n\n  // check if the sensor is already activated\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"GetToken: \", sensor_id, \" already activated\");\n    return it->second;\n  }\n\n  // enable the sensor on a secondary server\n  log_debug(\"GetToken: \", sensor_id, \" not activated, enabling on a secondary server\");\n  auto new_token = SendGetToken(sensor_id);\n\n  // update the maps\n  _tokens.insert(std::make_pair(sensor_id, new_token));\n  _sensor_ids.insert(std::make_pair(new_token.get_port(), sensor_id));\n\n  log_debug(\"GetToken: \", sensor_id, \" enabled on port \", new_token.get_port());\n  return new_token;\n}", "CodeBleu_score": 56.19382559115559}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_debug(\"PrimaryCommands::GetToken: \", sensor_id);\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"PrimaryCommands::GetToken: found existing token\");\n    return it->second;\n  } else {\n    log_debug(\"PrimaryCommands::GetToken: sensor is not activated\");\n    auto new_token = SendGetToken(sensor_id);\n    _tokens.insert({sensor_id, new_token});\n    log_info(\"PrimaryCommands::GetToken: sensor activated\");\n    return new_token;\n  }\n}", "CodeBleu_score": 53.52686637204687}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!IsReady()) {\n    return false;\n  }\n  DEBUG_ASSERT(_crowd != nullptr);\n  auto itr = _mapped_walkers_id.find(id);\n  if (itr != _mapped_walkers_id.end()) {\n    CrowdAgentId agent_id = itr->second;\n    {\n      std::lock_guard<std::mutex> lock(_mutex);\n      _crowd->removeAgent(agent_id);\n      _walker_manager.RemoveWalker(id);\n    }\n    _mapped_walkers_id.erase(itr);\n    _mapped_by_index.erase(agent_id);\n    return true;\n  }\n  itr = _mapped_vehicles_id.find(id);\n  if (itr != _mapped_vehicles_id.end()) {\n    CrowdAgentId agent_id = itr->second;\n    {\n      std::lock_guard<std::mutex> lock(_mutex);\n      _crowd->removeAgent(agent_id);\n      _vehicle_manager.RemoveVehicle(id);\n    }\n    _mapped_vehicles_id.erase(itr);\n    _mapped_by_index.erase(agent_id);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 71.02215552010982}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!_ready) {\n    return false;\n  }\n  DEBUG_ASSERT(_crowd);\n\n  Crowd::AgentId agent_id = 0;\n  {\n    std::lock_guard<std::mutex> lock(_mutex);\n    auto itr = _mapped_walkers_id.find(id);\n    if (itr != _mapped_walkers_id.end()) {\n      agent_id = itr->second;\n    } else {\n      auto itr = _mapped_vehicles_id.find(id);\n      if (itr != _mapped_vehicles_id.end()) {\n        agent_id = itr->second;\n      }\n    }\n  }\n  if (agent_id == 0) {\n    return false;\n  }\n\n  {\n    std::lock_guard<std::mutex> lock(_mutex);\n    DEBUG_ASSERT(_crowd);\n    _crowd->removeAgent(agent_id);\n\n    auto itr = _mapped_walkers_id.find(id);\n    if (itr != _mapped_walkers_id.end()) {\n      _walker_manager.RemoveWalker(id);\n      _mapped_walkers_id.erase(itr);\n    } else {\n      auto itr = _mapped_vehicles_id.find(id);\n      if (itr != _mapped_vehicles_id.end()) {\n        _vehicle_manager.RemoveVehicle(id);\n        _mapped_vehicles_id.erase(itr);\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 58.440560758189875}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!IsReady()) {\n        return false;\n    }\n\n    DEBUG_ASSERT(_crowd);\n\n    Crowd::AgentId agent_id;\n    Crowd::Agent* agent = nullptr;\n\n    {\n        std::lock_guard<std::recursive_mutex> lock(_mutex);\n\n        auto it = _mapped_walkers_id.find(id);\n        if (it != _mapped_walkers_id.end()) {\n            agent_id = it->second;\n            agent = _crowd->getAgent(agent_id);\n            _walker_manager.RemoveWalker(id);\n            _mapped_walkers_id.erase(it);\n        }\n\n        it = _mapped_vehicles_id.find(id);\n        if (it != _mapped_vehicles_id.end()) {\n            agent_id = it->second;\n            agent = _crowd->getAgent(agent_id);\n            _vehicle_manager.RemoveVehicle(id);\n            _mapped_vehicles_id.erase(it);\n        }\n    }\n\n    if (agent) {\n        _crowd->removeAgent(agent_id);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 67.49960423540979}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tif (id == 0) {\n    return false;\n  }\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    const auto &walker = it->second;\n    const auto &location = walker->GetLocation();\n    const auto &rotation = walker->GetTransform().rotation;\n    const auto &forward = rotation.GetForwardVector();\n    const auto &squared_distance = (location - direction).SquaredLength();\n    const auto &squared_distance_forward = (location - direction + forward * distance).SquaredLength();\n    if (squared_distance < squared_distance_forward) {\n      return false;\n    }\n    const auto &vehicle = _crowd->hasVehicleNear(location, distance);\n    if (vehicle != nullptr) {\n      return true;\n    }\n    return false;\n  }\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    const auto &vehicle = it->second;\n    const auto &location = vehicle->GetLocation();\n    const auto &rotation = vehicle->GetTransform().rotation;\n    const auto &forward = rotation.GetForwardVector();\n    const auto &squared_distance = (location - direction).SquaredLength();\n    const auto &squared_distance_forward = (location - direction + forward * distance).SquaredLength();\n    if (squared_distance < squared_distance_forward) {\n      return false;\n    }\n    const auto &vehicle = _crowd->hasVehicleNear(location, distance);\n    if (vehicle != nullptr) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n}", "CodeBleu_score": 52.88572328138185}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tauto it = _mapped_vehicles_id.find(id);\n  if (it == _mapped_vehicles_id.end()) {\n    return false;\n  }\n\n  const auto &vehicle = it->second;\n  const auto &vehicle_location = vehicle.GetLocation();\n  const auto &vehicle_rotation = vehicle.GetTransform().rotation;\n  const auto &vehicle_forward = vehicle_rotation.GetForwardVector();\n  const auto &vehicle_right = vehicle_rotation.GetRightVector();\n\n  const auto &direction_normalized = direction.MakeUnitVector();\n  const auto &vehicle_forward_normalized = vehicle_forward.MakeUnitVector();\n  const auto &vehicle_right_normalized = vehicle_right.MakeUnitVector();\n\n  const auto &cos_alpha = FVector::DotProduct(vehicle_forward_normalized, direction_normalized);\n  const auto &cos_beta = FVector::DotProduct(vehicle_right_normalized, direction_normalized);\n\n  const auto &distance_squared =\n      (direction_normalized * distance * cos_alpha)\n      .SquaredNorm() +\n      (vehicle_right_normalized * distance * cos_beta)\n      .SquaredNorm();\n\n  const auto &location_to_check = vehicle_location + direction_normalized * distance;\n  const auto &vehicle_extent = vehicle.GetBoundingBox().extent;\n  const auto &vehicle_extent_squared = vehicle_extent.X * vehicle_extent.X + vehicle_extent.Y * vehicle_extent.Y;\n\n  bool result = false;\n  {\n    // We need to lock the crowd, because we are using the crowd system to check for vehicles.\n    // We need to lock the crowd, because we are using the crowd system to check for vehicles.\n    std::lock_guard<std::mutex> lock(_crowd_mutex);\n\n    if (_crowd->hasVehicleNear(\n        location_to_check.x,", "CodeBleu_score": 51.21023419404317}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tauto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    std::lock_guard<std::mutex> lock(_mutex);\n    const float sq_distance = carla::geom::Math::DistanceSquared(it->second, direction);\n    if (sq_distance < distance * distance) {\n      return _crowd->hasVehicleNear(it->second);\n    }\n  }\n  return false;\n}", "CodeBleu_score": 53.612858855265834}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tauto &route_point = info.route_point;\n  auto &event = route_point.event;\n  WalkerEventVisitor visitor(info, delta);\n  return boost::variant2::visit(visitor, event);\n}", "CodeBleu_score": 52.499222456298625}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t// Get the current route point for the walker\n    RoutePoint &routePoint = info.routePoints[info.currentRoutePoint];\n\n    // Create a WalkerEventVisitor with the current context\n    WalkerEventVisitor visitor(info.context, info.currentRoutePoint, delta);\n\n    // Process the event at the current route point using boost::variant2::visit\n    return boost::variant2::visit(visitor, routePoint.event);\n}", "CodeBleu_score": 55.94545045361738}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tauto &route = info.route;\n    auto &route_point = route[info.route_point];\n    auto &event = route_point.event;\n\n    WalkerEventVisitor visitor(info, delta);\n    EventResult result = boost::variant2::visit(visitor, event);\n\n    return result;\n}", "CodeBleu_score": 52.03188534909988}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t(void)writer;\n  if (info.current_count_change == 1) {\n    std::cout << \"New publication matched\" << std::endl;\n    ++matched_count_;\n    if (matched_count_ == 1) {\n      std::cout << \"First publication matched\" << std::endl;\n      first_connected_ = true;\n    }\n  } else if (info.current_count_change == -1) {\n    std::cout << \"Publication match lost\" << std::endl;\n    --matched_count_;\n  } else {\n    std::cout << \"Publication match error\" << std::endl;\n  }\n}", "CodeBleu_score": 48.34126121045223}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t(void)writer;\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (info.current_count_change == 1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched() | \"\n            << \"New match made to \" << info.current_count << std::endl;\n        matched_count_ = info.current_count;\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched() | \"\n            << \"Match lost to \" << info.current_count << std::endl;\n        matched_count_ = info.current_count;\n    } else {\n        std::cout << \"CarlaListenerImpl::on_publication_matched() | \"\n            << \"Invalid count change (\" << info.current_count_change << \") to \" << info.current_count << std::endl;\n    }\n}", "CodeBleu_score": 48.56003561622545}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tstd::lock_guard<std::mutex> lock(mutex_);\n  if (info.current_count_change == 1) {\n    std::cout << \"CarlaListenerImpl::on_publication_matched() \"\n              << info.current_count << std::endl;\n    if (info.current_count == 1) {\n      first_connected_ = true;\n    }\n  } else if (info.current_count_change == -1) {\n    std::cout << \"CarlaListenerImpl::on_publication_matched() \"\n              << info.current_count << std::endl;\n  } else {\n    std::cout << \"CarlaListenerImpl::on_publication_matched() \"\n              << \"ERROR: \" << info.current_count_change\n              << std::endl;\n  }\n}", "CodeBleu_score": 59.96049425292138}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\" << std::endl;\n        _first_connected = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n        if (info.total_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cout << \"Subscriber matched error.\" << std::endl;\n    }\n}", "CodeBleu_score": 63.03954153376853}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\" << std::endl;\n        _matched = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n        _matched = false;\n        if (info.total_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cerr << \"Subscription matched error.\" << std::endl;\n    }\n}", "CodeBleu_score": 61.358623725898866}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif(info.current_count_change == 1) {\n        std::cout << \"Subscriber matched\" << std::endl;\n    } else if(info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched\" << std::endl;\n    } else {\n        std::cout << \"Subscriber matched error\" << std::endl;\n    }\n\n    _matched_count += info.current_count_change;\n    if(_matched_count == 0) {\n        _owner->DestroySubscriber();\n    }\n}", "CodeBleu_score": 58.18587140824098}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (\n        !CarlaCollisionEventPubSubType::isKeyDefined()) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(p_type),\n        static_cast<uint32_t>(p_type->getKeyMaxCdrSerializedSize()));\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\n    // Serialize the key.\n    p_type->serializeKey(ser);\n\n    if (force_md5 || CarlaCollisionEventPubSubType::isKeyMd5()) {\n        // Compute MD5 hash.\n        m_md5.init();\n        m_md5.update(fastbuffer.getBuffer(), static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        // Directly copy the key.\n        memcpy(handle->value, fastbuffer.getBuffer(),\n            static_cast<uint32_t>(ser.getSerializedDataLength()));\n    }\n\n    return true;\n}", "CodeBleu_score": 73.4673211888337}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < CarlaCollisionEvent::getKeyMaxCdrSerializedSize(); ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 85.10771755491498}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (0 == strcmp(type->getName(), \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (force_md5 || 0 == strcmp(type->getName(), \"CarlaCollisionEvent\")) {\n        if (0 == strcmp(type->getName(), \"CarlaCollisionEvent\")) {\n            static const char* key_names[] = {\n                \"frame\",\n                \"collision_event\"\n            };\n            if (0 == strcmp(type->getMD5(), \"755f71179199550347088446e24f6f23\")) {\n                static const uint8_t key_values[] = {\n                    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0", "CodeBleu_score": 22.541965644088037}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    try {\n        p_type->serialize(ser);\n        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n        return true;\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException&) {\n        return false;\n    }\n}", "CodeBleu_score": 87.99897789354372}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n  eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n  eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n  payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n  // Serialize encapsulation\n  ser.serialize_encapsulation();\n\n  try {\n    // Serialize the object.\n    p_type->serialize(ser);\n  }\n  catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n    return false;\n  }\n\n  // Get the serialized length\n  payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n  return true;\n}", "CodeBleu_score": 97.16308933214583}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 98.77571843442053}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t// If the target has been set, do nothing\n    if (target_set)\n        return;\n\n    // Decode the message\n    mavlink_heartbeat_t hb;\n    mavlink_msg_heartbeat_decode(&msg, &hb);\n\n    // If the message type is not one that should be tracked, do nothing\n    if (hb.type != MAV_TYPE_QUADROTOR &&\n        hb.type != MAV_TYPE_HELICOPTER &&\n        hb.type != MAV_TYPE_FIXED_WING &&\n        hb.type != MAV_TYPE_VTOL_DUOROTOR &&\n        hb.type != MAV_TYPE_VTOL_QUADROTOR &&\n        hb.type != MAV_TYPE_VTOL_TILTROTOR &&\n        hb.type != MAV_TYPE_VTOL_RESERVED2 &&\n        hb.type != MAV_TYPE_VTOL_RESERVED3 &&\n        hb.type != MAV_TYPE_VTOL_RESERVED4 &&\n        hb.type != MAV_TYPE_VTOL_RESERVED5)\n        return;\n\n    // If the target system ID has not been set, set it and request position and air pressure data streams\n    if (target_sysid == 0) {\n        target_sysid = hb.sysid;\n        gcs().request_datastream_position(target_sysid);\n        gcs().request_datastream_airpressure(target_sysid);\n    }\n\n    // Flag that the target has been set\n    target_set = true;\n}", "CodeBleu_score": 39.01756402884226}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) {\n\t\treturn;\n\t}\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tmavlink_heartbeat_t hb;\n\tmavlink_msg_heartbeat_decode(&msg, &hb);\n\tif (hb.system_status == MAV_STATE_ACTIVE) {\n\t\tif (hb.type == MAV_TYPE_FIXED_WING || hb.type == MAV_TYPE_QUADROTOR || hb.type == MAV_TYPE_HELICOPTER) {\n\t\t\tif (hb.autopilot == MAV_AUTOPILOT_ARDUPILOTMEGA) {\n\t\t\t\tsysid_target = hb.sysid;\n\t\t\t\tgcs().request_datastream_position(sysid_target, true);\n\t\t\t\tgcs().request_datastream_airpressure(sysid_target, true);\n\t\t\t\ttarget_set = true;\n\t\t\t\tgcs().send_text_P(MAV_SEVERITY_INFO, PSTR(\"Target set\"));\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.41347305870689}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (tracker.g.sysid_target.get() != 0) {\n        return;\n    }\n\n    mavlink_heartbeat_t hb;\n    mavlink_msg_heartbeat_decode(&msg, &hb);\n\n    if (hb.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    if (hb.autopilot == MAV_AUTOPILOT_INVALID) {\n        return;\n    }\n\n    if (hb.base_mode & MAV_MODE_FLAG_SAFETY_ARMED) {\n        return;\n    }\n\n    tracker.g.sysid_target.set(hb.sysid);\n    tracker.gcs().request_datastream_position(hb.sysid);\n    tracker.gcs().request_datastream_airpressure(hb.sysid);\n}", "CodeBleu_score": 50.976262519295105}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_to_calibrate_baro = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.49766486271447}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    mavlink_command_long_t cmd;\n    mavlink_msg_command_long_decode(&msg, &cmd);\n    result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _baro_cal_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 59.35390026656623}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _calibration_baro_pending = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.5120898085136}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    if (packet.param1 == 0.0) {\n        tracker.disarm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 1.0) {\n        tracker.arm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}", "CodeBleu_score": 61.39977953372412}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n\tif (is_equal(packet.param1, 0.0)) {\n\t\ttracker.disarm_servos();\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t} else if (is_equal(packet.param1, 1.0)) {\n\t\ttracker.arm_servos();\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 61.165024854262505}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tif (packet.param1 == 1.0f) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0f) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 75.8268528879277}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tif (num_gcs == 0) {\n        return;\n    }\n    // Iterate over all available GCS channels\n    for (unsigned i = 0; i < num_gcs; i++) {\n        // Check if there is space available for the message on the current channel\n        if (HAVE_PAYLOAD_SPACE(gcs_channels[i])) {\n            // Send request to start data stream\n            mavlink_msg_request_data_stream_send(gcs_channels[i], sysid, compid, MAVLINK_DATA_STREAM_POSITION, 1000, 1);\n        }\n    }\n}", "CodeBleu_score": 39.08499754470568}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tif (sysid == 0 && compid == 0) {\n        return;\n    }\n    // iterate over all GCS channels\n    for (uint8_t chan = 0; chan < ORB_MULTI_MAX_INSTANCES; chan++) {\n        // check if the channel is available\n        if (_gcs_channels[chan] == nullptr) {\n            continue;\n        }\n        // check if the channel is already streaming position data\n        if (_gcs_channels[chan]->get_stream_position()) {\n            continue;\n        }\n        // check if there is enough space in the channel\n        if (!_gcs_channels[chan]->has_free_space()) {\n            continue;\n        }\n        // check if there is enough space in the channel\n        if (!_gcs_channels[chan]->has_free_space()) {\n            continue;\n        }\n        // set the stream status\n        _gcs_channels[chan]->set_stream_position(true);\n        // send the request to start streaming position data\n        mavlink_msg_request_data_stream_send(\n            _mavlink->get_channel(),\n            _mavlink->get_system_id(),\n            _mavlink->get_component_id(),\n            _mavlink->get_system_id(),\n            _mavlink->get_component_id(),\n            chan,\n            MAVLINK_MSG_ID_GLOBAL_POSITION_INT,\n            _gcs_channels[chan]->get_stream_rate(),\n            1);\n        // exit the loop\n        break;\n    }\n}", "CodeBleu_score": 44.39898182067819}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// Iterate over the available GCS channels and check for available payload space.\n    for (int i = 0; i < num_gcs; i++) {\n        if (gcs_channels[i].available() >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n            // If space is available, send a request to start the data stream on the corresponding channel with the specified update rate.\n            mavlink_msg_request_data_stream_send(gcs_channels[i].get_channel(),\n                                                 sysid,\n                                                 compid,\n                                                 MAVLINK_DATA_STREAM_POSITION,\n                                                 1000000 / GCS_POS_RATE);\n            break;\n        }\n    }\n}", "CodeBleu_score": 51.93777537660497}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tif (is_zero(ahrs.cos_pitch)) {\n\t\treturn false;\n\t}\n\tef_pitch = atan2(ahrs.sin_roll * ahrs.sin_pitch + ahrs.cos_roll * ahrs.cos_pitch * ahrs.sin_yaw, ahrs.cos_pitch * ahrs.cos_yaw);\n\tef_yaw = atan2(ahrs.sin_roll * ahrs.cos_pitch * ahrs.sin_yaw - ahrs.cos_roll * ahrs.sin_pitch, ahrs.cos_pitch * ahrs.cos_yaw);\n\treturn true;\n}", "CodeBleu_score": 37.94700974355053}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS* ahrs = AP::ahrs;\n    if (is_zero(ahrs->cos_pitch)) {\n        return false;\n    }\n    ef_pitch = atan2f(ahrs->sin_roll * ahrs->sin_pitch + ahrs->cos_roll * ahrs->sin_yaw * ahrs->cos_pitch,\n                      ahrs->cos_roll * ahrs->cos_pitch - ahrs->sin_roll * ahrs->sin_yaw * ahrs->sin_pitch);\n    ef_yaw = atan2f(ahrs->sin_roll * ahrs->cos_pitch - ahrs->cos_roll * ahrs->sin_yaw * ahrs->sin_pitch,\n                    ahrs->cos_roll * ahrs->cos_pitch + ahrs->sin_roll * ahrs->sin_yaw * ahrs->sin_pitch);\n    return true;\n}", "CodeBleu_score": 34.194030992978725}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS* ahrs = AP_AHRS::get_ahrs();\n    if (ahrs->is_zero_pitch()) {\n        return false;\n    }\n    ef_pitch = atan2f(ahrs->cos_pitch() * sinf(pitch), ahrs->cos_roll() * sinf(yaw) + ahrs->sin_roll() * ahrs->sin_pitch() * cosf(pitch));\n    ef_yaw = atan2f(ahrs->sin_roll() * sinf(yaw) - ahrs->cos_roll() * ahrs->sin_pitch() * cosf(pitch), ahrs->cos_pitch() * cosf(pitch));\n    return true;\n}", "CodeBleu_score": 60.6214050395641}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\tstruct Tracker::NavStatus &nav_status = tracker.nav_status;\n    Parameters &g = tracker.g;\n\n    // calculate the yaw and pitch in centidegrees\n    float yaw_cd = nav_status.bearing * 100;\n    float pitch_cd = nav_status.distance * 100;\n\n    // calculate the angle error to target in both directions (i.e. moving up/right or lower/left)\n    float yaw_angle_error_upper;\n    float yaw_angle_error_lower;\n    if (yaw_cd >= 0) {\n        yaw_angle_error_upper = yaw_cd;\n        yaw_angle_error_lower = yaw_cd - 36000;\n    } else {\n        yaw_angle_error_upper = 36000 + yaw_cd;\n        yaw_angle_error_lower = yaw_cd;\n    }\n\n    // checks that the vehicle is outside the tracker's range\n    if ((yaw_angle_error_lower < g.yaw_range) && (yaw_angle_error_upper > g.yaw_range)) {\n        // if the tracker is trying to move clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving counter-clockwise then set direction_reversed to true\n        if (yaw_cd>0 && ((g.yaw_range - yaw_angle_error_lower) < (yaw_angle_error_upper - g.yaw_range))) {\n            nav_status.direction_reversed = true;\n        }\n        // if the tracker is trying to move counter-clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving then set direction_reversed to true\n        if (yaw_cd<0 && ((g.yaw_range - yaw_angle_error_lower) > (yaw_angle_error_upper - g.yaw_range))) {\n            nav_status.direction_reversed = true;\n        }\n    }", "CodeBleu_score": 46.54331152529333}, {"code": "void Mode::update_auto(void){\n\t// update tracker parameters\n    Parameters &g = tracker.g;\n    g.pidPitch2Srv.set_kp(g.pid_pitch_p);\n    g.pidPitch2Srv.set_ki(g.pid_pitch_i);\n    g.pidPitch2Srv.set_kd(g.pid_pitch_d);\n    g.pidPitch2Srv.set_imax(g.pid_pitch_imax);\n    g.pidPitch2Srv.set_imax(g.pid_pitch_imax);\n    g.pidPitch2Srv.set_cmd_max(g.pid_pitch_cmdmax);\n    g.pidPitch2Srv.set_cmd_min(g.pid_pitch_cmdmin);\n    g.pidYaw2Srv.set_kp(g.pid_yaw_p);\n    g.pidYaw2Srv.set_ki(g.pid_yaw_i);\n    g.pidYaw2Srv.set_kd(g.pid_yaw_d);\n    g.pidYaw2Srv.set_imax(g.pid_yaw_imax);\n    g.pidYaw2Srv.set_cmd_max(g.pid_yaw_cmdmax);\n    g.pidYaw2Srv.set_cmd_min(g.pid_yaw_cmdmin);\n\n    // get navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n\n    // calculate target yaw and pitch in centi-degrees\n    float yaw_target = wrap_180_cd((nav_status.bearing + g.yaw_trim) * 100);\n    float pitch_target = (nav_status.distance / g.pitch_range) * 100 + g.pitch_trim;\n\n    // calculate distance to target in centi-meters\n    float distance_to_target = (nav_status.distance * 100) + g.range_offset;", "CodeBleu_score": 37.41392604000973}, {"code": "void Mode::update_auto(void){\n\tParameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    // calculate the yaw and pitch in centi-degrees\n    float yaw = wrap_180_cd((nav_status.bearing+g.yaw_trim)*100);\n    float pitch = (nav_status.distance*100.0f)/(g.pitch_range*100.0f);\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate the angle error\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // convert the errors from earth frame to body frame\n    float bf_pitch_err;\n    float bf_yaw_err;\n    convert_ef_to_bf(nav_status.angle_error_pitch, nav_status.angle_error_yaw, bf_pitch_err, bf_yaw_err);\n\n    // if the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly\n    if (nav_status.distance_valid || g.min_distance == 0) {\n        // update the yaw servo\n        tracker.update_yaw_servo(bf_yaw_err);\n\n        // update the pitch servo\n        tracker.update_pitch_servo(bf_pitch_err);\n    }\n}", "CodeBleu_score": 68.54251055624357}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t// Update the GPS data.\n  gps.update();\n  // Check if the last message time has changed.\n  if (gps.last_message_time_ms() != last_message_time_ms) {\n    // If the status is at least 3D fix, then set the home location.\n    if (gps.status() >= 3) {\n      // Set the home location.\n      set_home();\n      // Reset the countdown.\n      countdown = 0;\n    }\n    // Set the last message time.\n    last_message_time_ms = gps.last_message_time_ms();\n  }\n  // If the countdown is not zero, decrement it.\n  if (countdown != 0) {\n    // Decrement the countdown.\n    countdown--;\n    // If the countdown is one, check if the current location is valid.\n    if (countdown == 1) {\n      // If the current location is valid, then set the home location.\n      if (is_valid_location()) {\n        // Set the home location.\n        set_home();\n      }\n      // Reset the countdown.\n      countdown = 0;\n    }\n  }\n}", "CodeBleu_score": 43.49843011779233}, {"code": "void Tracker::update_GPS(void){\n\t// Update the GPS data\n  gps.update();\n  // Check if the last message time has changed\n  if (gps.last_message_time_ms() != last_message_time) {\n    // Reset the countdown\n    countdown = 5;\n    // Save the last message time\n    last_message_time = gps.last_message_time_ms();\n  }\n  // Check if the GPS status is at least 3D fix\n  if (gps.status >= 3) {\n    // If the location is valid\n    if (gps.location.isValid()) {\n      // Set the home location\n      set_home();\n      // Reset the countdown\n      countdown = 5;\n    } else {\n      // Reset the countdown\n      countdown = 5;\n    }\n  }\n  // If the countdown has reached one\n  if (countdown == 1) {\n    // If the location is valid\n    if (gps.location.isValid()) {\n      // Set the home location\n      set_home();\n    }\n  }\n  // Decrement the countdown\n  countdown--;\n}", "CodeBleu_score": 46.656926887598004}, {"code": "void Tracker::update_GPS(void){\n\t// Update GPS data\n  gps.update();\n\n  // Check if the last message time has changed\n  if (gps.last_message_time_ms != last_message_time_ms) {\n    // Reset the countdown\n    countdown = 10;\n  }\n\n  // Check if the GPS status is at least 3D fix\n  if (gps.status >= 3) {\n    // Check if the countdown is at one\n    if (countdown == 1) {\n      // Set the home location if the current location is valid\n      if (gps.location.isValid()) {\n        set_home();\n      }\n    }\n    // Decrement the countdown\n    countdown--;\n  }\n\n  // Save the last message time\n  last_message_time_ms = gps.last_message_time_ms;\n}", "CodeBleu_score": 34.961518588843575}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch\n\t// set servo to pitch", "CodeBleu_score": 4.619414655645427}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    // TODO: add a check to make sure the pitch is in the range\n    //", "CodeBleu_score": 4.6194146543064525}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tfloat servo_pitch = 0.0f;\n\tif (pitch > 0.0f) {\n\t\tservo_pitch = 1.0f;\n\t} else if (pitch < 0.0f) {\n\t\tservo_pitch = -1.0f;\n\t}\n\tSRV_Channels::set_output_scaled(SRV_Channels::CH_PITCH, servo_pitch);\n}", "CodeBleu_score": 14.324544184167193}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call parent function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check barometer reference\n    if (AP_Arming::arming_check_baro && !_baro_ref.healthy()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Baro reference not healthy\n\"));\n        }\n        return false;\n    }\n\n    // check barometer altitude\n    if (AP_Arming::arming_check_baro && fabsf(_baro_ref.get_altitude_cm() - _inertial_nav.get_position_z_up_cm()) > AP_Arming::arming_check_baro_alt_diff_cm) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Baro altitude differs from inertial nav altitude by more than %d cm\n\"), AP_Arming::arming_check_baro_alt_diff_cm);\n        }\n        return false;\n    }\n\n    // barometer checks passed\n    return true;\n}", "CodeBleu_score": 50.85987876941228}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (!(hal.util->get_soft_armed() || hal.util->get_hard_armed())) {\n        return true;\n    }\n    if (!_checks.baro_check) {\n        return true;\n    }\n    float inertial_alt = 0;\n    float baro_alt = 0;\n    float baro_alt_error = 0;\n    if (_checks.baro_check == ARMING_CHECK_BARO_ALT) {\n        inertial_alt = copter.inertial_nav.get_position_z_up_cm();\n        baro_alt = barometer.get_altitude();\n        baro_alt_error = fabsf(inertial_alt - baro_alt);\n    }\n    if (baro_alt_error > _checks.baro_alt_err) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Baro alt error: %f\n\"), (double)baro_alt_error);\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 55.36143732055104}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n#if defined(ARMING_CHECK_BARO)\n    if (should_check_baro()) {\n        float inertial_alt = 0;\n        float baro_alt = 0;\n        if (!get_baro_alt(baro_alt)) {\n            return false;\n        }\n        if (!get_inertial_nav_alt(inertial_alt)) {\n            return false;\n        }\n        if (fabsf(inertial_alt - baro_alt) > AP_ARMING_BARO_ALT_DIFF) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"baro alt diff %d\n\"), (int)fabsf(inertial_alt - baro_alt));\n            }\n            return false;\n        }\n    }\n#endif\n    return true;\n}", "CodeBleu_score": 48.24902814925055}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\treturn copter.mode_rtl.get_alt_type() == RTL_ALT_TYPE_TERRAIN && copter.wp_nav->get_terrain_source() == WP_Terrain_Source::DATABASE;\n}", "CodeBleu_score": 26.571689826268262}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (copter.wp_nav->get_terrain_source() == AP_Terrain::RANGEFINDER) {\n        return false;\n    }\n    if (copter.mode_rtl.get_alt_type() == AP_RTL::ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 61.87126768873412}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (copter.wp_nav->get_terrain_source() == AP_Terrain::RANGE_FINDER) {\n        return false;\n    }\n    if (copter.mode_rtl.get_alt_type() == RTL_ALT_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.043872098934806}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// get loop time\n    uint32_t now = AP::scheduler().get_last_loop_time_s();\n    uint32_t dt = now - last_loop_time;\n    last_loop_time = now;\n\n    // set dt for rate controllers\n    attitude_control->set_dt(dt);\n    pos_control->set_dt(dt);\n    motors->set_dt(dt);\n\n    // run rate controllers\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 62.24373988987537}, {"code": "void Copter::run_rate_controller(){\n\t// set dt in attitude controller\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    // set dt in position controller\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    // set dt in motor controller\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n    // run rate controllers that require only IMU data\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 49.51466761076095}, {"code": "void Copter::run_rate_controller(){\n\t// set dt for controllers\n    const uint32_t now = AP::scheduler().get_last_loop_time_s();\n    const uint32_t dt = now - last_run_time;\n    last_run_time = now;\n\n    // set dt for controllers\n    attitude_control->rate_controller_run(dt);\n    pos_control->set_dt(dt);\n    motors->set_dt(dt);\n    attitude_control->set_dt(dt);\n}", "CodeBleu_score": 60.97744842743832}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    if (!old_loc.get_alt_frame().same_alt_frame(new_loc.get_alt_frame())) {\n        return false;\n    }\n\n    if (!old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 62.22885232507384}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (flightmode->get_wp() == NULL) {\n        return false;\n    }\n\n    if (!old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 67.909848219838}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // get the next waypoint location\n    Location new_wp_loc = wp_nav.get_next_wp_location();\n\n    // exit if the old location matches the next waypoint location\n    if (old_loc.same_loc_as(new_wp_loc)) {\n        return false;\n    }\n\n    // exit if the altitude frames of the old and new locations are different\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 70.4185311330034}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (aux_function_type == AUX_FUNCTION_MODE_SWITCH) {\n        if (aux_switch_pos == ch_flag) {\n            copter.set_mode(mode);\n        } else if (copter.flightmode->mode_number == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 65.23662477483842}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (aux_function_enabled(ch_flag)) {\n        if (aux_function_active(ch_flag)) {\n            copter.set_mode(mode);\n        } else {\n            if (copter.flightmode->mode_number == mode) {\n                rc().reset_mode_switch();\n            }\n        }\n    }\n}", "CodeBleu_score": 64.11952162794185}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (aux_function_enabled(ch_flag)) {\n        if (aux_switch_on(ch_flag)) {\n            copter.set_mode(mode);\n        } else if (copter.flightmode->mode_number == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 64.02273125949091}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t// get roll and pitch trim\n    float roll_trim = ToRad(channel_roll->get_control_in());\n    float pitch_trim = ToRad(channel_pitch->get_control_in());\n\n    // add to AHRS\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(LOGGER_WRITE_EVENT, EVENT_TRIM_SAVED);\n\n    // send confirmation message\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Trim saved: roll %0.2f pitch %0.2f\", roll_trim, pitch_trim);\n}", "CodeBleu_score": 60.09338269854477}, {"code": "void Copter::save_trim(){\n\t// calculate trim from control inputs\n    float roll_trim = ToRad(channel_roll->get_control_in());\n    float pitch_trim = ToRad(channel_pitch->get_control_in());\n    // add trim to AHRS\n    ahrs.add_trim(roll_trim, pitch_trim);\n    // log event\n    Log_Write_Event(LOGGER_WRITE_EVENT, EVENT_TRIM_SAVED);\n    // send confirmation message\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Trim saved: roll %0.2f, pitch %0.2f\", (double)roll_trim, (double)pitch_trim);\n}", "CodeBleu_score": 60.46304122002164}, {"code": "void Copter::save_trim(){\n\tfloat roll_trim = ToRad(channel_roll->get_control_in());\n    float pitch_trim = ToRad(channel_pitch->get_control_in());\n    ahrs.add_trim(roll_trim, pitch_trim);\n    log_write_event(LOGGER_WRITE_EVENT);\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Trim saved: %f %f\", (double)roll_trim, (double)pitch_trim);\n}", "CodeBleu_score": 61.601655563201405}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// Get the copter's velocity\n\tVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\t// Calculate the speed squared\n\tfloat speed_sqrd = vel.xy().length_squared();\n\t// If the copter's position is valid and the speed exceeds a minimum threshold\n\tif (copter.inertial_nav.is_position_ok() && speed_sqrd > 0.00001f) {\n\t\t// Update the look-ahead yaw angle using the arctangent of the velocity components\n\t\tlook_ahead_yaw_angle = atan2f(vel.x, vel.y);\n\t}\n\t// Return the computed look-ahead yaw angle\n\treturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 50.06856587723786}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// get velocity and check that it's valid\n  Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n  if (!vel.is_valid()) {\n    return 0;\n  }\n  // get speed squared and check that it's greater than the minimum threshold\n  float speed_sq = vel.xy().length_squared();\n  if (speed_sq < MIN_SPEED_SQ) {\n    return 0;\n  }\n  // update look-ahead yaw angle using arctangent of velocity components\n  return atan2f(vel.y, vel.x) * 180.0f / M_PI;\n}", "CodeBleu_score": 44.508592613426956}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat yaw = 0.0f;\n    if (copter.position_ok && copter.inertial_nav.get_velocity_neu_cms().xy().length_squared() > 0.000001f) {\n        yaw = atan2f(copter.inertial_nav.get_velocity_neu_cms().x, copter.inertial_nav.get_velocity_neu_cms().y);\n        yaw = wrap_PI(yaw);\n        yaw = degrees(yaw);\n    }\n    return yaw;\n}", "CodeBleu_score": 36.004245640463104}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\n        // rudder arming disabled or throttle not zero\n        if (get_rudder_arming_type() == AP_Arming_Plane::RUDDER_DISABLED || plane.get_throttle_input() != 0) {\n            return false;\n        }\n    } else if (method == AP_Arming::WATCHDOG) {\n        // watchdog armed\n        if (hal.util->was_watchdog_armed()) {\n            return false;\n        }\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 44.570067700724145}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// rudder arming is not enabled or throttle not zero\n    if (method == AP_Arming::RUDDER && (get_rudder_arming_type() == AP_Arming::DISABLED || plane.get_throttle_input() != 0)) {\n        return false;\n    }\n    // watchdog was armed\n    if (hal.util->was_watchdog_armed()) {\n        return true;\n    }\n    // arming checks disabled\n    if (AP_Arming::get_checks_enabled() == false) {\n        return true;\n    }\n    // run parent class's arm_checks\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 47.340925428253165}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// rudder method\n    if (method == AP_Arming::RUDDER) {\n        // rudder arming disabled\n        if (gcs().get_rudder_arming_type() == GCS_MAVLINK::RUD_DISABLED) {\n            return false;\n        }\n        // rudder arming enabled and throttle is not zero\n        if (gcs().get_rudder_arming_type() == GCS_MAVLINK::RUD_ENABLED && plane.get_throttle_input() > 0) {\n            return false;\n        }\n    }\n    // bypass arming checks if arming checks are disabled or watchdog was armed\n    if (!hal.util->get_soft_armed() || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 57.97765049038398}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tbool success = false;\n\n    // don't arm if already armed\n    if (armed()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_arming_disabled()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_battery()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_gps()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_radio()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_pilot_input()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_battery()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_gps()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_radio()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_pilot_input()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if (plane.failsafe.failsafe_battery()) {\n        return false;\n    }\n\n    // don't arm if we are in a failsafe state\n    if", "CodeBleu_score": 26.39620610730204}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tif (method == AP_Arming::Method::GPS_FAILSAFE) {\n        // we are arming in GPS failsafe mode\n        gps_failsafe = true;\n    }\n\n    // check for arming method\n    if (method == AP_Arming::Method::RC) {\n        // we are arming via RC\n        if (do_arming_checks && !rc_override_arming_checks()) {\n            return false;\n        }\n    } else if (method == AP_Arming::Method::MANUAL) {\n        // we are arming manually\n        if (do_arming_checks && !manual_arming_checks()) {\n            return false;\n        }\n    } else if (method == AP_Arming::Method::GPS_FAILSAFE) {\n        // we are arming in GPS failsafe mode\n        if (do_arming_checks && !gps_failsafe_arming_checks()) {\n            return false;\n        }\n    } else {\n        // we are arming via a pre-arm check\n        if (do_arming_checks && !pre_arm_check_arming_checks()) {\n            return false;\n        }\n    }\n\n    // update home location\n    plane.update_home();\n\n    // arm the plane\n    AP_Arming::arm();\n\n    // update current location\n    plane.update_current_loc();\n\n    // send status text\n    send_arm_disarm_statustext();\n\n    // set home location in AHRS\n    plane.ahrs.set_home();\n\n    // set flag to delay arming\n    delay_arming = true;\n\n    // return true to indicate arming was successful\n    return true;\n}", "CodeBleu_score": 48.83003662867754}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tbool success = false;\n\n    if (do_arming_checks) {\n        // check for any reason to not arm\n        if (!arming_checks()) {\n            return false;\n        }\n    }\n\n    // check for a reason to not arm\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we are already armed, just return true\n    if (is_armed()) {\n        return true;\n    }\n\n    // arm the plane\n    if (method == AP_Arming::Method::Manual) {\n        // manual arming\n        success = arm_manual();\n    } else if (method == AP_Arming::Method::GPS_Always) {\n        // GPS-based arming\n        success = arm_gps();\n    } else if (method == AP_Arming::Method::GPS_Home) {\n        // GPS-based arming with home location\n        success = arm_gps_home();\n    } else if (method == AP_Arming::Method::RC_WithStartupThrottle) {\n        // RC-based arming with startup throttle\n        success = arm_rc_with_startup_throttle();\n    } else if (method == AP_Arming::Method::RC_WithThrottle) {\n        // RC-based arming with throttle\n        success = arm_rc_with_throttle();\n    } else if (method == AP_Arming::Method::RC_WithPassthrough) {\n        // RC-based arming with passthrough\n        success = arm_rc_with_passthrough();\n    } else if (method == AP_Arming::Method::RC_WithStartupThrottle_WithPassthrough) {\n        // RC-based arming with startup throttle and passthrough\n        success = arm_rc_with_startup_throttle_with_passthrough();\n    } else if (method == AP_Arming::Method::RC_WithThrottle_WithPassthrough) {\n        // RC-based arming with throttle and passthrough", "CodeBleu_score": 35.20742786796649}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (arming.is_armed()) {\n        return true;\n    }\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"No disarm button configured\n\"));\n        }\n        return false;\n    }\n    return AP_Arming::pre_arm_checks();\n}", "CodeBleu_score": 61.28144343367743}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (sub.armed()) {\n        return true;\n    }\n\n    // make sure the craft has a disarm button assigned before it is armed\n    // check all the standard btn functions\n    for (uint8_t i = 0; i < 16; i++) {\n        switch (sub.get_button(i)->function(false)) {\n            case JSButton::k_disarm :\n                return AP_Arming::pre_arm_checks(display_failure);\n        }\n    }\n\n    // check all the shift functions if there's shift assigned\n    bool has_shift_function = false;\n    for (uint8_t i = 0; i < 16; i++) {\n        switch (sub.get_button(i)->function(true)) {\n            case JSButton::k_disarm :\n                return AP_Arming::pre_arm_checks(display_failure);\n            case JSButton::k_shift :\n                has_shift_function = true;\n                break;\n        }\n    }\n\n    // if we get here, there is no disarm button assigned\n    if (display_failure) {\n        sub.log_printf(MAV_SEVERITY_CRITICAL, \"Arming failed. No disarm button assigned.\");\n    }\n    return false;\n}", "CodeBleu_score": 52.25110381001483}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (armed()) {\n        return true;\n    }\n\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"WARNING: No disarm button configured\n\"));\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.50784034371443}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n    float ne_y = x * sin_yaw + y * cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 57.973379496821366}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n\n\tne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n\tne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 59.47953651234155}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 67.78210296278249}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_ACCEPTED;\n    // Check if yaw angle is within acceptable range\n    if (fabsf(packet.param1) > 360.0f) {\n        result = MAV_RESULT_DENIED;\n    }\n    // Check if param4 is within acceptable range\n    if (fabsf(packet.param4) > 1.0f) {\n        result = MAV_RESULT_DENIED;\n    }\n    // Set yaw heading\n    if (result == MAV_RESULT_ACCEPTED) {\n        set_yaw_heading(packet.param1, packet.param4);\n    }\n    return result;\n}", "CodeBleu_score": 38.95553776188051}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_DENIED;\n    float yaw_angle = packet.param1;\n    float yaw_rate = packet.param2;\n    float yaw_angle_rate = packet.param3;\n    float yaw_angle_absolute = packet.param4;\n    float yaw_angle_rate_absolute = packet.param5;\n    float yaw_angle_rate_relative = packet.param6;\n    float yaw_angle_rate_relative_angle = packet.param7;\n    if (is_zero(yaw_angle_rate_relative_angle)) {\n        if (is_zero(yaw_angle_rate_relative)) {\n            if (is_zero(yaw_angle_rate_absolute)) {\n                if (is_zero(yaw_angle_absolute)) {\n                    if (is_zero(yaw_angle)) {\n                        result = MAV_RESULT_ACCEPTED;\n                    } else {\n                        result = MAV_RESULT_ACCEPTED;\n                    }\n                } else {\n                    result = MAV_RESULT_ACCEPTED;\n                }\n            } else {\n                result = MAV_RESULT_ACCEPTED;\n            }\n        } else {\n            result = MAV_RESULT_ACCEPTED;\n        }\n    } else {\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}", "CodeBleu_score": 39.220895413126975}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tfloat yaw = packet.param1;\n    float lat = packet.param2;\n    float lon = packet.param3;\n    float alt = packet.param4;\n    float yaw_rate = packet.param5;\n    float loiter_radius = packet.param6;\n    float loiter_direction = packet.param7;\n\n    if (is_zero(yaw) && is_zero(lat) && is_zero(lon) && is_zero(alt) && is_zero(yaw_rate) && is_zero(loiter_radius) && is_zero(loiter_direction)) {\n        // if all params are zero, then we clear the yaw condition\n        _vehicle->set_yaw_look_at_heading(0.0f);\n        return MAV_RESULT_ACCEPTED;\n    } else if (is_equal(yaw, 0.0f) && is_equal(lat, 0.0f) && is_equal(lon, 0.0f) && is_equal(alt, 0.0f) && is_equal(yaw_rate, 0.0f) && is_equal(loiter_radius, 0.0f) && is_equal(loiter_direction, 0.0f)) {\n        // if all params are zero, then we clear the yaw condition\n        _vehicle->set_yaw_look_at_heading(0.0f);\n        return MAV_RESULT_ACCEPTED;\n    } else if (is_equal(yaw, 0.0f) && is_equal(lat, 0.0f) && is_equal(lon, 0.0f) && is_equal(alt, 0.0f) && is_equal(yaw_rate, 0.0f) && is_equal(loiter_radius, 0.0f) && is_equal(loiter_direction, 1.0f)) {\n        // if all params are zero, then we clear the yaw condition\n        _vehicle->set_yaw_look_at_heading(0.0f);\n        return MAV_RES", "CodeBleu_score": 40.3709870328033}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tuint8_t tgt_heading = 0;\n  if (control_mode == GCS_MAVLINK::MAV_MODE_AUTO_ARMED || control_mode == GCS_MAVLINK::MAV_MODE_GUIDED_ARMED) {\n    tgt_heading = wrap_180_cd(wp_bearing_to_destination()) / 2;\n  }\n  return tgt_heading;\n}", "CodeBleu_score": 44.23078618280774}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tuint8_t tgt_heading = 0;\n    if (control_mode == vehicle_status_s::MAIN_STATE_AUTO_MISSION || control_mode == vehicle_status_s::MAIN_STATE_AUTO_LOITER || control_mode == vehicle_status_s::MAIN_STATE_AUTO_RTL || control_mode == vehicle_status_s::MAIN_STATE_AUTO_RTGS || control_mode == vehicle_status_s::MAIN_STATE_AUTO_LAND || control_mode == vehicle_status_s::MAIN_STATE_AUTO_FOLLOW_TARGET || control_mode == vehicle_status_s::MAIN_STATE_AUTO_PRECLAND) {\n        tgt_heading = wrap_360_cd(get_wp_bearing_to_destination()) / 2;\n    }\n    return tgt_heading;\n}", "CodeBleu_score": 38.029416805094634}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tuint8_t ret = 0;\n    if (control_mode == FLYING_AUTO || control_mode == FLYING_GUIDED) {\n        // Convert from -18000->18000 to 0->360\n        float wp_bearing_to_destination = wrap_360_cd(get_wp_bearing_to_destination());\n        // Divide by 2\n        ret = wp_bearing_to_destination / 2;\n    }\n    return ret;\n}", "CodeBleu_score": 46.20841007928396}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log) {\n        LogPacket packet;\n        packet.time = AP_HAL::micros64();\n        packet.data_id = id;\n        packet.value = value;\n        logger.WriteCriticalBlock(&packet, sizeof(packet));\n    }\n}", "CodeBleu_score": 43.910311831794715}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log) {\n        LogPacket packet;\n        packet.header = LOG_PACKET_HEADER_INIT;\n        packet.header.data_id = id;\n        packet.header.time = AP_HAL::micros64();\n        packet.data.int32 = value;\n        logger.WriteCriticalBlock(&packet, sizeof(packet));\n    }\n}", "CodeBleu_score": 47.08494936249957}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log) {\n    LogPacket packet;\n    packet.header.id = id;\n    packet.header.time = AP_HAL::micros64();\n    packet.data.int32 = value;\n    logger.WriteCriticalBlock(&packet, sizeof(LogPacket));\n  }\n}", "CodeBleu_score": 45.176137848325986}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\tif (!ahrs.home_is_set()) {\n        if (motors.armed()) {\n            set_home_to_current_location_inflight();\n        } else {\n            set_home_to_current_location(false);\n        }\n    }\n}", "CodeBleu_score": 46.665017223610676}, {"code": "void Sub::update_home_from_EKF(){\n\tif (!ahrs.home_is_set()) {\n        if (motors.armed()) {\n            set_home_to_current_location_inflight();\n        } else {\n            set_home_to_current_location(false);\n        }\n    }\n}", "CodeBleu_score": 46.665017223610676}, {"code": "void Sub::update_home_from_EKF(){\n\t// if home is already set, exit immediately\n    if (ahrs.home_is_set()) {\n        return;\n    }\n    // if motors are armed, set home to current location in-flight\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n        return;\n    }\n    // if motors are not armed, attempt to set home to current EKF location\n    set_home_to_current_location(false);\n}", "CodeBleu_score": 49.37544512831312}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\tif (!motors.armed()) {\n        motors.set_throttle_out(0);\n        motors.set_desired_spool_state(SPOOL_STATE_UNLIMITED_THROTTLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    motors.set_desired_spool_state(SPOOL_STATE_UNLIMITED_THROTTLE);\n\n    // get pilot's desired rates\n    attitude_control->input_rate_bf_roll_pitch_yaw(channel_roll->get_control_in(), channel_pitch->get_control_in(), channel_yaw->get_control_in());\n\n    // run attitude controller\n    attitude_control->set_throttle_out(channel_throttle->norm_input());\n    attitude_control->relax_attitude_controllers();\n\n    // set motor outputs\n    motors.set_lateral(channel_lateral->norm_input());\n    motors.set_forward(channel_forward->norm_input());\n}", "CodeBleu_score": 44.33379331454921}, {"code": "void ModeAcro::run(){\n\tif (!motors.armed()) {\n        motors.set_throttle_out(0.0f);\n        motors.set_desired_spool_state(Motors::SPOOL_UNLIMITED_THROTTLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    motors.set_desired_spool_state(Motors::SPOOL_UNLIMITED_THROTTLE);\n    attitude_control->input_rate_bf_roll_pitch_yaw(get_pilot_desired_angle_rates());\n    attitude_control->set_throttle_out(channel_throttle->norm_input());\n    motors.set_forward(channel_forward->norm_input());\n    motors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 41.15131852673349}, {"code": "void ModeAcro::run(){\n\tif (!motors.armed()) {\n        motors.set_throttle_out(0.0f);\n        motors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    motors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n\n    // get pilot's desired rates\n    attitude_control->input_rate_bf_roll_pitch_yaw(\n        channel_roll->get_control_in(),\n        channel_pitch->get_control_in(),\n        channel_yaw->get_control_in());\n\n    // run attitude controller\n    attitude_control->run();\n\n    // get pilot's desired throttle\n    float pilot_throttle = channel_throttle->norm_input();\n\n    // set throttle\n    motors.set_throttle_out(pilot_throttle);\n\n    // set forward and lateral motor inputs\n    motors.set_forward(channel_forward->norm_input());\n    motors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 50.56476530576766}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// set position control mode\n    set_mode(AUTO);\n\n    // initialise waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // get stopping point\n    get_stopping_point();\n\n    // set destination\n    sub.wp_nav.set_wp_destination();\n\n    // set yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 37.72325557868484}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set the mode to position control\n    set_mode(GUIDED);\n\n    // initialise the waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // get the stopping point\n    const Vector3f &stopping_point = sub.wp_nav.get_wp_stopping_point();\n\n    // set the waypoint destination to the stopping point\n    sub.wp_nav.set_wp_destination(stopping_point);\n\n    // set the yaw mode to the default\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 56.544682512380795}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set position controller to use waypoint controller\n    sub.pos_control.set_wp_controller();\n\n    // get stopping point\n    const Vector3f &stopping_point = sub.wp_nav.get_wp_stopping_point();\n\n    // set waypoint destination\n    sub.wp_nav.set_wp_destination(stopping_point);\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 53.5186854785558}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set maximum speeds and accelerations\n    position_control->set_max_speed_accel_xy(sub.pilot_velocity_z_max, sub.pilot_velocity_z_max, sub.pilot_acceleration_z_max, sub.pilot_acceleration_z_max);\n    position_control->set_max_speed_accel_z(sub.pilot_velocity_xy_max, sub.pilot_velocity_xy_max, sub.pilot_acceleration_xy_max, sub.pilot_acceleration_xy_max);\n\n    // initialise velocity controllers\n    position_control->init_xy_controller();\n    position_control->init_z_controller();\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 49.62214198372716}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set max speeds and accelerations\n    position_control->set_max_speed_accel_z(sub.pilot_velz_max, sub.pilot_accel_z);\n    position_control->set_correction_speed_accel_z(sub.pilot_velz_max, sub.pilot_accel_z);\n\n    // initialise velocity controllers\n    position_control->init_xy_controller();\n    position_control->init_z_controller();\n\n    // set yaw mode to hold\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 50.89984260622287}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set max speed and acceleration\n    position_control->set_max_speed_accel_z(sub.pilot_velocity_z_max, sub.pilot_acceleration_z);\n\n    // initialise position controller\n    position_control->init_z_controller();\n    position_control->init_xy_controller();\n\n    // set yaw control mode\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 44.10592288606246}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t// check if we have been running for too long\n  if ((hrt_absolute_time() - _guided_start_time) > GUIDED_LIMIT_MAX_T) {\n    return true;\n  }\n\n  // check if we have reached the maximum altitude\n  if (_param_gnd_max_alt.get() > 0) {\n    if (inertial_nav.get_position_neu_cm().z < -_param_gnd_max_alt.get()) {\n      return true;\n    }\n  }\n\n  // check if we have reached the minimum altitude\n  if (_param_gnd_min_alt.get() > 0) {\n    if (inertial_nav.get_position_neu_cm().z > -_param_gnd_min_alt.get()) {\n      return true;\n    }\n  }\n\n  // check if we have exceeded the maximum horizontal distance\n  if (_param_gnd_max_dist.get() > 0) {\n    if (get_horizontal_distance_cm() > _param_gnd_max_dist.get()) {\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 40.016264386509306}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// check for timeout\n    if (hrt_elapsed_time(&_guided_start_time) > GUIDED_TIMEOUT) {\n        return true;\n    }\n    // check for minimum altitude\n    if (_param_mpc_alt_mode.get() == 1) {\n        if (get_terrain_altitude() < _param_mpc_alt_min.get()) {\n            return true;\n        }\n    } else {\n        if (_sub_att.get().z < _param_mpc_alt_min.get()) {\n            return true;\n        }\n    }\n    // check for maximum altitude\n    if (_param_mpc_alt_max.get() > 0 && _sub_att.get().z > _param_mpc_alt_max.get()) {\n        return true;\n    }\n    // check for maximum horizontal distance\n    if (_param_mpc_xy_cruise.get() > 0) {\n        float dist_xy = get_horizontal_distance_cm();\n        if (dist_xy > _param_mpc_xy_cruise.get() * 100) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 42.224397264285}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// Check if we've been running for too long\n    if (hrt_elapsed_time(&_guided_start_time) > GUIDED_LIMIT_MAX_TIME) {\n        return true;\n    }\n\n    // Check if we've moved more than GUIDED_LIMIT_MAX_DIST meters from our start position\n    float horizontal_distance = get_horizontal_distance_cm();\n\n    if (horizontal_distance > GUIDED_LIMIT_MAX_DIST * 100.0f) {\n        return true;\n    }\n\n    // Check if we've dropped below GUIDED_LIMIT_MIN_ALT meters\n    if (inertial_nav.get_position_neu_cm().z < GUIDED_LIMIT_MIN_ALT * 100.0f) {\n        return true;\n    }\n\n    // Check if we've risen above GUIDED_LIMIT_MAX_ALT meters\n    if (inertial_nav.get_position_neu_cm().z > GUIDED_LIMIT_MAX_ALT * 100.0f) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 32.67928888011274}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\tif (motor_test_requested == false) {\n        // motor test has not been requested\n        return false;\n    }\n    // motor test has been requested\n    if (AP_HAL::millis() - motor_test_time > 1000) {\n        // motor test has timed out\n        gcs().send_text_fmt(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n        motor_test_pass = false;\n        AP::arming().disarm();\n        motor_test_fail_time = AP_HAL::millis();\n        return false;\n    }\n    // motor test is still running\n    return true;\n}", "CodeBleu_score": 49.76527829771378}, {"code": "bool Sub::verify_motor_test(){\n\tif (AP_HAL::millis() - motor_test_start_time > 2000) {\n    gcs().send_text_fmt(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n    motor_test_pass = false;\n    AP::arming().motor_test_pass = false;\n    AP::arming().motor_test_start_time = 0;\n    AP::arming().motor_test_finish_time = AP_HAL::millis();\n    AP::arming().disarm();\n    return false;\n  }\n  if (motor_test_pass) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 51.88891988251887}, {"code": "bool Sub::verify_motor_test(){\n\t// check if motor test requests are received at least every 2 Hz.\n  if (AP_HAL::millis() - _last_motor_test_request_time > 500) {\n    // send a timeout message\n    gcs().send_text_fmt(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n    // set the pass flag to false\n    _motor_test_pass = false;\n    // disables the motor test\n    _motor_test_enabled = false;\n    // disarms the system\n    AP::arming().disarm();\n    // records the failure time\n    _motor_test_fail_time = AP_HAL::millis();\n    // returns false\n    return false;\n  }\n  // returns true\n  return true;\n}", "CodeBleu_score": 46.671977126535836}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_target = wp_nav.get_roll();\n\tfloat pitch_target = wp_nav.get_pitch();\n\n\t// constrain the roll and pitch targets to the specified maximum angle range\n\troll_target = constrain_int16(roll_target, -max_roll_target, max_roll_target);\n\tpitch_target = constrain_int16(pitch_target, -max_pitch_target, max_pitch_target);\n\n\t// normalize the roll and pitch targets to the range [-1, 1]\n\troll_target = (float)roll_target / max_roll_target;\n\tpitch_target = (float)pitch_target / max_pitch_target;\n\n\t// assign the normalized roll and pitch targets to the output variables\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 45.22514000855661}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Get the roll and pitch targets from wp_nav in centidegrees.\n  float roll_target = wp_nav.get_roll();\n  float pitch_target = wp_nav.get_pitch();\n\n  // Constrain the roll and pitch targets within the specified maximum angle range.\n  roll_target = constrain_int16(roll_target, -max_roll, max_roll);\n  pitch_target = constrain_int16(pitch_target, -max_pitch, max_pitch);\n\n  // Normalize the roll and pitch targets.\n  float roll_norm = (float)roll_target / max_roll;\n  float pitch_norm = (float)pitch_target / max_pitch;\n\n  // Assign the normalized roll and pitch targets to lateral_out and forward_out.\n  lateral_out = roll_norm;\n  forward_out = pitch_norm;\n}", "CodeBleu_score": 47.16474526324741}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_target = wp_nav.get_roll();\n  float pitch_target = wp_nav.get_pitch();\n  constrain_int16(roll_target, -2000, 2000);\n  constrain_int16(pitch_target, -2000, 2000);\n  float roll_norm = constrain_float(roll_target, -1.0, 1.0);\n  float pitch_norm = constrain_float(pitch_target, -1.0, 1.0);\n  lateral_out = roll_norm;\n  forward_out = pitch_norm;\n}", "CodeBleu_score": 40.0663388235176}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\tif (barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n    if (depth_sensor != nullptr) {\n        if (barometer.healthy()) {\n            depth_sensor->set_health(SensorHealth::healthy);\n        } else {\n            depth_sensor->set_health(SensorHealth::unhealthy);\n        }\n    }\n    barometer.update();\n}", "CodeBleu_score": 65.54511660594497}, {"code": "void Sub::read_barometer(){\n\tbarometer.update();\n  if (barometer.healthy()) {\n    if (barometer.get_altitude() > 0) {\n      barometer.update_calibration();\n    }\n  }\n  else {\n    if (depth_sensor.healthy()) {\n      depth_sensor.set_health(false);\n    }\n  }\n}", "CodeBleu_score": 69.10133257882036}, {"code": "void Sub::read_barometer(){\n\tbarometer.get_altitude();\n  if (barometer.altitude > 0) {\n    barometer.update_calibration();\n  }\n  if (depth_sensor.healthy) {\n    barometer.update();\n  }\n}", "CodeBleu_score": 65.24360589883831}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t// If inertial navigation is not available, return false\n  if (!ahrs.have_inertial_nav()) {\n    return false;\n  }\n\n  // If the motors are disarmed, accept a predicted horizontal position\n  if (!motors.armed()) {\n    return true;\n  }\n\n  // If the motors are armed, require a good absolute position and ensure the EKF is not in constant position mode\n  return ahrs.inertial_nav_position_ok() && !inertial_nav.get_filter_status().constant_position_mode;\n}", "CodeBleu_score": 43.950753231348905}, {"code": "bool Sub::ekf_position_ok(){\n\treturn true;\n}", "CodeBleu_score": 2.277480785173957}, {"code": "bool Sub::ekf_position_ok(){\n\treturn false;\n}", "CodeBleu_score": 5.492677746086194}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if the current control mode does not require position or velocity, return true\n    if (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\n        return true;\n    }\n    // call the parent class's GPS checks and return false if they fail\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    // check if the AHRS system is ready and if the EKF failsafe is active, returning false if either check fails\n    if (!ahrs.pre_arm_check() || rover.ekf_position_ok == 0) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"EKF position estimate not valid\");\n        }\n        return false;\n    }\n    // ensure the position estimate is valid, returning false if not\n    if (!rover.ekf_position_ok) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"EKF position estimate not valid\");\n        }\n        return false;\n    }\n    // if all checks pass, return true\n    return true;\n}", "CodeBleu_score": 55.238192044277376}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// call parent class's gps_checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the AHRS system is ready\n    if (!ahrs.healthy()) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"AHRS not ready\");\n        }\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (ahrs.is_failsafe()) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"EKF failsafe active\");\n        }\n        return false;\n    }\n\n    // check if the position estimate is valid\n    if (!rover.ekf_position_ok()) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Position estimate not valid\");\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 53.544367487321544}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if the current control mode does not require position or velocity, return true\n    if (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\n        return true;\n    }\n    // call parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    // check if the AHRS system is ready\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            rover.gcs->set_nav_state(NAV_STATE_STANDBY);\n            rover.gcs->send_text_fmt(MAV_SEVERITY_CRITICAL, \"Arming failed: AHRS system not ready\");\n        }\n        return false;\n    }\n    // check if the EKF failsafe is active\n    if (rover.ekf.failsafe.ekf_failsafe) {\n        if (display_failure) {\n            rover.gcs->set_nav_state(NAV_STATE_STANDBY);\n            rover.gcs->send_text_fmt(MAV_SEVERITY_CRITICAL, \"Arming failed: EKF failsafe active\");\n        }\n        return false;\n    }\n    // check if the position estimate is valid\n    if (!rover.ekf_position_ok()) {\n        if (display_failure) {\n            rover.gcs->set_nav_state(NAV_STATE_STANDBY);\n            rover.gcs->send_text_fmt(MAV_SEVERITY_CRITICAL, \"Arming failed: Position estimate not valid\");\n        }\n        return false;\n    }\n    // if all checks pass, return true\n    return true;\n}", "CodeBleu_score": 56.241012382907144}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks) {\n        // do arming checks\n        if (!check_arming_preconditions()) {\n            return false;\n        }\n    }\n\n    // set the arming method\n    arming_method = method;\n\n    // if we are armed, just return\n    if (is_armed()) {\n        return true;\n    }\n\n    // arm the vehicle\n    if (!rover.g2.smart_rtl.set_home()) {\n        return false;\n    }\n    rover.mode_simple.init_heading();\n    if (!AP_Arming::arm()) {\n        return false;\n    }\n    rover.g2.windvane.record_home_heading();\n    send_arm_disarm_statustext();\n    return true;\n}", "CodeBleu_score": 58.57135075106572}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// if we're already armed, we can't arm again\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we're not in simple mode, we can't arm\n    if (rover.mode_simple.get_mode() != RoverMode::MODE_SIMPLE) {\n        return false;\n    }\n\n    // if we're not in a valid GPS fix, we can't arm\n    if (!rover.gps.is_valid()) {\n        return false;\n    }\n\n    // if we're not in a valid home position, we can't arm\n    if (!rover.g2.smart_rtl.is_home_position_valid()) {\n        return false;\n    }\n\n    // if we're not in a valid wind direction, we can't arm\n    if (!rover.g2.windvane.is_valid()) {\n        return false;\n    }\n\n    // if we're not in a valid airspeed, we can't arm\n    if (!rover.airspeed.is_valid()) {\n        return false;\n    }\n\n    // if we're not in a valid altitude, we can't arm\n    if (!rover.gps.is_valid()) {\n        return false;\n    }\n\n    // if we're not in a valid compass, we can't arm\n    if (!rover.compass.is_healthy()) {\n        return false;\n    }\n\n    // if we're not in a valid barometer, we can't arm\n    if (!rover.baro.healthy()) {\n        return false;\n    }\n\n    // if we're not in a valid sonar, we can't arm\n    if (!rover.sonar.is_healthy()) {\n        return false;\n    }\n\n    // if we're not in a valid rangefinder, we can't arm\n    if (!rover.rangefinder.healthy()) {\n        return false;\n    }\n\n    // if we're not in a valid temperature, we can't", "CodeBleu_score": 26.19065301019535}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// if we're already armed, return immediately\n    if (is_armed()) {\n        return true;\n    }\n\n    // if we're not supposed to be armed, return immediately\n    if (!do_arming_checks) {\n        return true;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we can arm, return immediately\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we're not in a state where we", "CodeBleu_score": 26.88236351025602}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\tif (status_message.charging_allowed && !status_message.charging_enabled) {\n        if (checkShouldCharge()) {\n            digitalWrite(PIN_CHARGE_ENABLE, HIGH);\n            status_message.charging_enabled = true;\n            status_message.charging_start_time = millis();\n        }\n    }\n    else if (!status_message.charging_allowed && status_message.charging_enabled) {\n        digitalWrite(PIN_CHARGE_ENABLE, LOW);\n        status_message.charging_enabled = false;\n        status_message.charging_stop_time = millis();\n        delay(1000);\n        if (status_message.charging_allowed) {\n            updateChargingEnabled();\n        }\n    }\n}", "CodeBleu_score": 42.003928933732595}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (!charging_enabled) {\n                charging_enabled = true;\n                charging_disabled_start_time = millis();\n            }\n        } else {\n            if (charging_enabled) {\n                charging_enabled = false;\n                charging_disabled_start_time = millis();\n            }\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            charging_disabled_start_time = millis();\n        } else {\n            if (millis() - charging_disabled_start_time > 10000) {\n                charging_allowed = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 53.01849456119485}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed && !charging_enabled) {\n        charging_enabled = true;\n        charging_start_time = millis();\n    } else if (!charging_allowed && charging_enabled) {\n        charging_enabled = false;\n        charging_disable_time = millis();\n    } else if (!charging_allowed && !charging_enabled) {\n        if (millis() - charging_disable_time > 1000) {\n            charging_enabled = true;\n            charging_start_time = millis();\n        }\n    }\n}", "CodeBleu_score": 43.49895335889865}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\tif (ros::ok() && size >= 4) {\n    uint8_t *message_bytes = (uint8_t *)message;\n    uint16_t crc = CRC16.ccitt(message_bytes, size);\n    message_bytes[size] = crc & 0xff;\n    message_bytes[size + 1] = (crc >> 8) & 0xff;\n    packetSerial.send(message, size + 2);\n  }\n}", "CodeBleu_score": 57.12304449527639}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ros::ok() && size >= 4) {\n    uint16_t crc = CRC16.ccitt(message, size - 2);\n    uint8_t *msg = (uint8_t *)message;\n    msg[size - 2] = crc & 0xff;\n    msg[size - 1] = crc >> 8;\n    packetSerial.send(message, size);\n  }\n}", "CodeBleu_score": 56.72319195255993}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ros::ok() && size >= 4) {\n    // Calculate the CRC\n    uint16_t crc = CRC16.ccitt(message, size);\n    // Append the CRC to the message\n    uint8_t *messageWithCRC = (uint8_t *)malloc(size + 2);\n    memcpy(messageWithCRC, message, size);\n    messageWithCRC[size] = crc & 0xff;\n    messageWithCRC[size + 1] = (crc >> 8) & 0xff;\n    // Send the message\n    packetSerial.send(messageWithCRC, size + 2);\n    free(messageWithCRC);\n  }\n}", "CodeBleu_score": 55.646345550460794}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t// initialize the serial port\n  soundSerial.begin(9600);\n  soundSerial.flush();\n\n  // initialize the sound module\n  soundSerial.write('I');\n  soundSerial.write('N');\n  soundSerial.write('I');\n  soundSerial.write('T');\n  soundSerial.write('\n');\n\n  // wait for the module to respond\n  while (!soundSerial.available()) {\n    delay(10);\n  }\n\n  // read the response from the module\n  char response[5];\n  soundSerial.readBytes(response, 5);\n\n  // if the response is not \"INIT OK\", return false\n  if (strcmp(response, \"INIT OK\") != 0) {\n    return false;\n  }\n\n  // retrieve the number of sound files on the SD card\n  soundSerial.write('N');\n  soundSerial.write('U');\n  soundSerial.write('M');\n  soundSerial.write('B');\n  soundSerial.write('E');\n  soundSerial.write('R');\n  soundSerial.write('S');\n  soundSerial.write('\n');\n\n  // wait for the module to respond\n  while (!soundSerial.available()) {\n    delay(10);\n  }\n\n  // read the response from the module\n  soundSerial.readBytes(response, 5);\n\n  // if the response is not \"NUMBER\", return false\n  if (strcmp(response, \"NUMBER\") != 0) {\n    return false;\n  }\n\n  // read the number of sound files from the serial port\n  numSdTracks = soundSerial.parseInt();\n\n  // if there are no sound files on the SD card, return false\n  if (numSdTracks == 0) {\n    return false;\n  }\n\n  // return true if there are one or more sound files on the SD card\n  return true;\n}", "CodeBleu_score": 45.144618529728994}, {"code": "bool MP3Sound::begin(){\n\t// Initialize the serial port to the sound module\n  soundSerial.begin(9600);\n  // Clear any existing data in the buffer\n  soundSerial.flush();\n  // Initialize the sound module\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x01);\n  soundSerial.write(0x56);\n  // Read the response from the sound module\n  if (soundSerial.read() == 0x7E) {\n    if (soundSerial.read() == 0xFF) {\n      if (soundSerial.read() == 0x06) {\n        if (soundSerial.read() == 0x01) {\n          if (soundSerial.read() == 0x56) {\n            // Get the number of sound files on the SD card\n            numSdTracks = getNumSdTracks();\n            // Return true if there are one or more sound files available\n            return (numSdTracks > 0);\n          }\n        }\n      }\n    }\n  }\n  // Return false if there are no sound files available\n  return false;\n}", "CodeBleu_score": 48.050053214938856}, {"code": "bool MP3Sound::begin(){\n\t// Clear the serial buffer\n  soundSerial.flush();\n  // Initialize the serial port\n  soundSerial.begin(9600);\n  // Send the initialization command\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x01);\n  soundSerial.write(0x56);\n  soundSerial.write(0xAE);\n  // Wait for the response\n  while (!soundSerial.available());\n  // Read the response\n  unsigned char response = soundSerial.read();\n  // Check the response\n  if (response == 0x7E) {\n    // Read the remaining bytes\n    soundSerial.read();\n    soundSerial.read();\n    soundSerial.read();\n    soundSerial.read();\n    // Read the number of tracks\n    numSdTracks = soundSerial.read();\n    // Check the number of tracks\n    if (numSdTracks > 0) {\n      // Initialize the sound module\n      soundSerial.write(0x7E);\n      soundSerial.write(0xFF);\n      soundSerial.write(0x06);\n      soundSerial.write(0x0D);\n      soundSerial.write(0x01);\n      soundSerial.write(0x56);\n      soundSerial.write(0xAE);\n      // Wait for the response\n      while (!soundSerial.available());\n      // Read the response\n      response = soundSerial.read();\n      // Check the response\n      if (response == 0x7E) {\n        // Read the remaining bytes\n        soundSerial.read();\n        soundSerial.read();\n        soundSerial.read();\n        soundSerial.read();\n        // Read the number of tracks\n        numSdTracks = soundSerial.read();\n        // Return true\n        return true;\n      }\n    }\n  }\n  // Return false\n  return false;\n}", "CodeBleu_score": 43.115497427074786}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0 || myMP3.isPlaying())\n    return active_sounds.size();\n  else {\n    myMP3.play(active_sounds.back());\n    active_sounds.pop_back();\n    return active_sounds.size();\n  }\n}", "CodeBleu_score": 45.79937796493555}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0 || myMP3.isPlaying) {\n        return active_sounds.size();\n    } else {\n        myMP3.play(active_sounds.back());\n        active_sounds.pop_back();\n        return active_sounds.size();\n    }\n}", "CodeBleu_score": 46.398164601660625}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.30795718535374}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tswitch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_abstract_camera_cleanup(d);\n      wb_abstract_camera_setup(d, r);\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 34.35993350770481}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *abstract_camera = (WbAbstractCamera *)d;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      // check if the memory-mapped file is already open\n      if (abstract_camera->mmapped_file) {\n        munmap(abstract_camera->mmapped_file, abstract_camera->mmapped_size);\n        close(abstract_camera->mmapped_fd);\n        abstract_camera->mmapped_file = NULL;\n        abstract_camera->mmapped_size = 0;\n        abstract_camera->mmapped_fd = 0;\n      }\n\n      // open the memory-mapped file\n      const char *filename = wb_request_read_string(r);\n      abstract_camera->mmapped_fd = open(filename, O_RDWR | O_CREAT, 0666);\n      if (abstract_camera->mmapped_fd < 0) {\n        fprintf(stderr, \"Error: could not open memory-mapped file '%s'.", "CodeBleu_score": 44.05204616884973}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *ac = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    // cleanup previous memory-mapped file\n    if (ac->mmap_file_name) {\n      munmap(ac->mmap_data, ac->mmap_data_size);\n      close(ac->mmap_fd);\n      ac->mmap_data = NULL;\n      ac->mmap_data_size = 0;\n      ac->mmap_fd = -1;\n      free(ac->mmap_file_name);\n      ac->mmap_file_name = NULL;\n    }\n    // setup new memory-mapped file\n    const char *requested_file_name = wb_request_read_string(r);\n    if (requested_file_name) {\n      ac->mmap_file_name = strdup(requested_file_name);\n      ac->mmap_fd = open(requested_file_name, O_RDWR);\n      if (ac->mmap_fd < 0) {\n        fprintf(stderr, \"Error: %s(): could not open file \\\"%s\\\"", "CodeBleu_score": 42.08134923068686}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height;\n  robot_mutex_lock_step();\n  AbstractCamera *camera = abstract_camera_get_struct(d);\n  if (camera->height)\n    height = camera->height;\n  else\n    height = -1;\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 50.811746234841216}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height;\n  robot_mutex_lock_step();\n  height = d->pdata ? d->pdata->height : -1;\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 48.68175524485604}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height;\n  robot_mutex_lock_step();\n  AbstractCamera *camera = d->pdata;\n  if (camera->height == -1)\n    height = -1;\n  else\n    height = camera->height;\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 54.4331434056333}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    sampling_period = 0;\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 53.59830461359788}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 59.840755812614276}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 58.203810251954536}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dmsString = static_cast<string>(const_cast<char *>(dms));\n  free(dms);\n  return dmsString;\n}", "CodeBleu_score": 56.62077366200029}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = const_cast<char *>(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 52.09972349156915}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = const_cast<char *>(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 52.09972349156915}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g);\n  dUASSERT (g->type == dBoxClass,\"argument not a box\");\n  dUASSERT (plane,\"argument plane is NULL\");\n  dxBox *b = (dxBox *) g;\n  dVector3 pos;\n  dReal side[3];\n  dReal nside[3];\n  dReal q[4];\n  dReal side2[3];\n  dReal nside2[3];\n  dReal q2[4];\n  dReal min,sideproj,sideproj2,nsideproj,nsideproj2;\n  int i;\n\n  // compute box center and side lengths\n  dReal c[3];\n  dGeomBoxGetLengths (g, side);\n  dGeomBoxGetLengths (g, nside);\n  dGeomBoxGetCenter (g, c);\n  for (i=0; i < 3; i++) {\n    side[i] *= 0.5;\n    nside[i] *= 0.5;\n  }\n\n  // get the relative position\n  pos[0] = x - c[0];\n  pos[1] = y - c[1];\n  pos[2] = z - c[2];\n\n  // find the minimum component of the position\n  min = pos[0];\n  if (pos[1] < min) min = pos[1];\n  if (pos[2] < min) min = pos[2];\n\n  // if the point is inside the box, then return the plane for the closest\n  // face. the normal is set to point out of the box.\n  if (min > 0) {\n    if (pos[0] < 0) {\n      plane[0] = -1;\n      plane[1] = 0;\n      plane[2] = 0;\n      plane[3] = -c[0] - side[0];\n    }\n    else if (pos[1] < 0) {\n      plane[0] = 0;\n      plane[1] = -1;\n      plane[2] = 0;\n      plane[3] = -c[1]", "CodeBleu_score": 41.66310661407461}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g && g->type == dBoxClass);\n  dUASSERT (plane, \"argument plane is NULL\");\n  dxBox *b = (dxBox*) g;\n  const dReal *R = dGeomGetRotation(g);\n  const dReal *pos = dGeomGetPosition(g);\n  dVector3 q = {x - pos[0], y - pos[1], z - pos[2]};\n  dVector3 n = {0, 0, 0};\n  dReal d = 0;\n  dReal min = dInfinity;\n  int i;\n  for (i = 0; i != 3; ++i) {\n    dVector3 p;\n    dVector3Cross (R[i*4], q, p);\n    dReal l = dCalcVectorDot3_41 (p, p);\n    if (l < min) {\n      min = l;\n      n[0] = p[0];\n      n[1] = p[1];\n      n[2] = p[2];\n      d = -dCalcVectorDot3_41 (R[i*4], q);\n    }\n  }\n  plane[0] = n[0];\n  plane[1] = n[1];\n  plane[2] = n[2];\n  plane[3] = d;\n}", "CodeBleu_score": 50.16896985385455}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT (g && g->type == dBoxClass,\"argument not a geom\");", "CodeBleu_score": 5.536688953696365}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdAASSERT (box);\n  dAASSERT (box->body);\n  dAASSERT ((flags & ~(dIMMERSE_BOX_NO_IMPACTS|dIMMERSE_BOX_NO_ROTATIONAL_IMPACTS)) == 0);\n\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.flags = flags;\n  data.performImmersionChecking = 1;\n\n  dImmerseBoxGeneric (&data);\n  return data.immersion->code;\n}", "CodeBleu_score": 46.438963362862296}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdIASSERT (box != 0);\n  dIASSERT (box->body != 0);\n  dIASSERT ((flags & ~(dIMMERSE_BOX_NO_IMPACTS|dIMMERSE_BOX_NO_FLOAT)) == 0);\n  dIASSERT (immersion != 0);\n\n  // initialize the sBoxImmersionData structure\n  sBoxImmersionData s;\n  s.box = box;\n  s.fluidPlane = fluidPlane;\n  s.flags = flags;\n  s.immersion = immersion;\n\n  // perform the immersion checking\n  return dImmerseBoxData (&s);\n}", "CodeBleu_score": 47.21008635403312}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT (o1->type == dBoxClass);\n  dIASSERT (o2->type == dCapsuleClass);\n  dUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n\n  sBoxImmersionData data(box, capsule, flags, immersion);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 29.919171975607163}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT (o1 && o2);\n  dIASSERT (o1->type == dBoxClass);\n  dIASSERT (o2->type == dCapsuleClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dxBox *box = (dxBox *)o1;\n  dxCapsule *capsule = (dxCapsule *)o2;\n\n  dVector3 fluidPlane;\n  dReal depth;\n  int code = dCollideCapsuleBox(capsule, box, &depth, fluidPlane);\n  if (code == 0) {\n    return 0;\n  }\n\n  if (flags & IMMERSION_LINEAR) {\n    immersion->immersionType = IMMERSION_LINEAR;\n    immersion->depth = depth;\n    dVector3Copy(fluidPlane, immersion->plane);\n    return 1;\n  }\n\n  if (flags & IMMERSION_SPHERICAL) {\n    immersion->immersionType = IMMERSION_SPHERICAL;\n    dReal radius = capsule->radius;\n    dReal half_height = capsule->lz * REAL(0.5);\n    dReal sphere_depth = radius - half_height;\n    dReal sphere_depth_squared = sphere_depth * sphere_depth;\n\n    if (depth > sphere_depth_squared) {\n      return 0;\n    }\n\n    dReal sqrt_depth = dSqrt(depth);\n    dReal cos_theta = (sphere_depth - sqrt_depth) / sphere_depth;\n    dReal sin_theta = dSqrt(1.0 - cos_theta * cos_theta);\n\n    immersion->depth = sqrt_depth;\n    immersion->plane[0] = fluidPlane[0] * cos_theta + fluidPlane[1] * sin_theta;\n    immersion->plane[1] = fluidPlane[0] * -sin_theta + fluidPlane[1] * cos_theta;\n    immersion->plane[2] = fluidPlane", "CodeBleu_score": 46.32796759741246}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT (immersion != nullptr);\n  dUASSERT (o1->type == dBoxClass, \"First argument must be a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"Second argument must be a capsule\");\n  dUASSERT (o1->body && o2->body, \"This box and capsule have no body and hence cannot be tested for immersion into a fluid\");\n\n  dReal *fluidPlane = immersion->plane;\n\n  dReal *capsuleParams = (dReal *)dGeomGetClassData(o2);\n  dReal radius = capsuleParams[0];\n  dReal length = capsuleParams[1];\n  dReal *capsulePos = o2->posr.pos;\n  dReal *capsuleAxis = o2->posr.R + 2;\n\n  // Compute the capsule's immersion plane\n  dReal d = dCalcVectorDot3(capsulePos, capsuleAxis);\n  dReal t = (d - radius) / length;\n  if (t < -1.0 || t > 1.0) {\n    return 0;\n  }\n\n  // Compute the immersion plane\n  dReal plane[4];\n  plane[0] = -capsuleAxis[0];\n  plane[1] = -capsuleAxis[1];\n  plane[2] = -capsuleAxis[2];\n  plane[3] = dCalcVectorDot3(capsulePos, plane);\n\n  // Compute the capsule's immersion point\n  dReal point[3];\n  point[0] = capsulePos[0] + t * capsuleAxis[0];\n  point[1] = capsulePos[1] + t * capsuleAxis[1];\n  point[2] = capsulePos[2] + t * capsuleAxis[2];\n\n  // Compute the capsule's immersion normal\n  dReal normal[3];\n  normal[0] = -capsuleAxis[0];\n  normal[1] = -capsuleAxis[1];\n  normal", "CodeBleu_score": 41.58326060868387}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t// We want to integrate from tanTheta0 to tanTheta1, but we need to be careful to avoid singularities\n\t// at the poles.  If theta0 is close to 0 or pi, we need to split the integral into two parts.\n\t// The first part is from tanTheta0 to 1, and the second part is from -1 to tanTheta1.\n\tdReal tanTheta1 = zIOverR;\n\tdReal tanTheta0a = tanTheta0;\n\tdReal tanTheta1a = tanTheta1;\n\tdReal tanTheta0b = tanTheta0;\n\tdReal tanTheta1b = tanTheta1;\n\tdReal volume = 0;\n\n\tif (tanTheta0 < -0.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", "CodeBleu_score": 19.279537359168863}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tsHemisphereIntegrationData hemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1);\n\tdReal volume = 0.0;\n\tvolume += Simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand> (hemisphereIntegrationData, 0.0, 1.0, 2000);\n\tvolume += Simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand> (hemisphereIntegrationData, 1.0, 2.0, 2000);\n\treturn volume;\n}", "CodeBleu_score": 36.23654417651589}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t// Check for singularities\n\tif (zIOverR < 0.0) {\n\t\t// The hemisphere is completely immersed in the capsule.\n\t\treturn 1.0;\n\t}\n\telse if (zIOverR > 1.0) {\n\t\t// The hemisphere is completely above the capsule.\n\t\treturn 0.0;\n\t}\n\n\t// Calculate the normalized volume of the hemisphere\n\tdReal volume = 0.0;\n\tdReal tanTheta1 = tanTheta0 * zIOverR;\n\tdReal sinTheta0 = sinTheta1 / zIOverR;\n\tdReal cosTheta0 = dSqrt(1.0 - sinTheta0 * sinTheta0);\n\tdReal cosTheta1 = dSqrt(1.0 - sinTheta1 * sinTheta1);\n\tdReal sinTheta = sinTheta0 * cosTheta1 + cosTheta0 * sinTheta1 * tanTheta0;\n\tdReal cosTheta = cosTheta0 * cosTheta1 - sinTheta0 * sinTheta1 * tanTheta0;\n\tdReal cosPhi = cosTheta / sinTheta;\n\tdReal sinPhi = dSqrt(1.0 - cosPhi * cosPhi);\n\tdReal tanPhi = sinPhi / cosPhi;\n\tdReal tanTheta = tanPhi / tanTheta0;\n\tdReal cotTheta = cosPhi / tanPhi;\n\tdReal cotTheta0 = cosTheta0 / sinTheta0;\n\tdReal cotTheta1 = cosTheta1 / sinTheta1;\n\tdReal cotTheta2 = cosTheta / sinTheta;\n\tdReal cotTheta3 = tanTheta * cotTheta0;\n\tdReal cotTheta4 = tanTheta * cotTheta1;\n\tdReal cotTheta5 = tanTheta * cotTheta2;\n\tdReal cotTheta6 = tanTheta * cotTheta3;\n\tdReal cotTheta7 = tanTheta * cotTheta4;\n\tdReal cotTheta8 = tanTheta * cotTheta5;\n\tdReal cotTheta9 = tanTheta * cotTheta6;\n\tdReal cotTheta10 = tanTheta * cotTheta7;\n\tdReal cotTheta11 = tanTheta *", "CodeBleu_score": 38.26399986602051}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tsHemisphereIntegrationData data;\n    data.radius = radius;\n    data.zIOverR = zIOverR;\n    data.tanTheta0 = tanTheta0;\n    data.sinTheta1 = sinTheta1;\n    data.volume = volume;\n    data.xCenterOfMass = 0;\n    data.xIntegral = 0;\n    data.xIntegralError = 0;\n    data.xCenterOfMassIntegrand(0, 0, 0);\n    return data.xCenterOfMass;\n}", "CodeBleu_score": 37.043164420162014}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t// This function uses Simpson's rule for numerical integration over the hemisphere's surface.\n    // The function takes the immersion depth ratio, tangent of the initial angle, sine of the final angle, and volume as inputs.\n    // It returns the x-coordinate of the buoyancy center scaled by the radius and adjusted by the volume.\n\n    // The integration limits are the tangent of the initial angle and the sine of the final angle.\n    const dReal a = tanTheta0;\n    const dReal b = sinTheta1;\n\n    // The integration step size is the average of the absolute values of the limits.\n    const dReal h = 0.5 * (dAbs(a) + dAbs(b));\n\n    // The number of steps is the ceiling of the average of the absolute values of the limits divided by the step size.\n    const int n = (int) (0.5 * (dAbs(a) + dAbs(b)) / h + 0.5);\n\n    // The Simpson's rule integration step is 1/3 the average of the absolute values of the limits.\n    const dReal h3 = h / 3.0;\n\n    // The Simpson's rule integration step is 4/3 the average of the absolute values of the limits.\n    const dReal h43 = 4.0 / 3.0 * h;\n\n    // The Simpson's rule integration step is 2/3 the average of the absolute values of the limits.\n    const dReal h23 = 2.0 / 3.0 * h;\n\n    // The Simpson's rule integration step is 1/4 the average of the absolute values of the limits.\n    const dReal h14 = h / 4.0;\n\n    // The Simpson's rule integration step is 3/4 the average of the absolute values of the limits.\n    const dReal h34 = 3.0 / 4.0 * h;\n\n    // The Simpson's rule integration step is 1/6 the average of the absolute values of the limits.\n    const dReal h16 = h / 6.0;\n\n    //", "CodeBleu_score": 39.43925149705581}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tsHemisphereIntegrationData hemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1);\n    return (volume * (hemisphereIntegrationData.xCenterOfMassIntegrand(0) + 2 * hemisphereIntegrationData.xCenterOfMassIntegrand(1) + hemisphereIntegrationData.xCenterOfMassIntegrand(2)));\n}", "CodeBleu_score": 29.714559048411736}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 33.405351690706}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 33.405351690706}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data((dxCapsule*)o1, (dxTriMesh*)o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 40.971826598364515}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the sleep duration in milliseconds from the input\n  auto sleep_duration = getInput<std::chrono::milliseconds>(\"sleep_duration\");\n\n  // If the duration is missing or non-positive, return SUCCESS\n  if (!sleep_duration) {\n    RCLCPP_INFO(getLogger(), \"No sleep duration given, returning SUCCESS\");\n    return NodeStatus::SUCCESS;\n  }\n\n  // If the duration is positive, set the node status to RUNNING, start a timer, and set a callback to emit a wake-up signal when the timer expires\n  setStatus(NodeStatus::RUNNING);\n  timer_ = createWallTimer(\n    *sleep_duration, std::bind(&SleepNode::emitWakeUpSignal, this),\n    true);\n\n  // If the timer is aborted, ensure the timer_waiting_ flag is reset\n  if (!timer_) {\n    timer_waiting_ = false;\n    return NodeStatus::FAILURE;\n  }\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 43.31799613930071}, {"code": "NodeStatus SleepNode::onStart(){\n\tauto sleep_duration = getInput<std::chrono::milliseconds>(\"sleep_duration\");\n    if (!sleep_duration || *sleep_duration <= std::chrono::milliseconds(0)) {\n        return NodeStatus::SUCCESS;\n    }\n\n    setStatus(NodeStatus::RUNNING);\n    timer_ = std::make_unique<rclcpp::TimerBase::SharedPtr>(\n        std::make_shared<rclcpp::TimerBase>(\n            getNode()->get_node_base_interface()->get_context()));\n    timer_->add(\n        *sleep_duration,\n        std::bind(&SleepNode::emitWakeUpSignal, this),\n        getNode()->get_node_timers_interface());\n    timer_waiting_ = true;\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 50.79038319171632}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the sleep duration in milliseconds\n  auto duration = getInput<std::chrono::milliseconds>(\"duration\");\n  // If the duration is missing or non-positive, return SUCCESS\n  if (!duration || duration.value() <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n  // Start a timer\n  timer_.add(duration.value(),\n             [this]() {\n               // Set the node status to SUCCESS\n               setStatus(NodeStatus::SUCCESS);\n               // Emit a wake-up signal\n               emitWakeUpSignal();\n             },\n             [this]() {\n               // Ensure the timer_waiting_ flag is reset\n               timer_waiting_ = false;\n             });\n  // Set the timer_waiting_ flag\n  timer_waiting_ = true;\n  // Return RUNNING\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 56.63801582310346}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// Retrieve the entry from the blackboard\n    std::shared_ptr<Blackboard::Entry> entry = config().blackboard->getEntry(config().entryKey);\n    if (entry) {\n        // Lock the entry mutex\n        std::lock_guard<std::mutex> lock(entry->mutex);\n        // Compare the sequence ID with the previously stored sequence ID\n        if (entry->sequenceID != m_sequenceID) {\n            // Update the stored sequence ID\n            m_sequenceID = entry->sequenceID;\n            // Return NodeStatus::SUCCESS\n            return NodeStatus::SUCCESS;\n        }\n    }\n    // Return NodeStatus::FAILURE\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 39.59237711153102}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// Get the entry from the blackboard\n\tBlackboard::Entry* entry = config().blackboard->getEntry(config().key);\n\n\t// If the entry is not found, return FAILURE\n\tif (!entry)\n\t\treturn NodeStatus::FAILURE;\n\n\t// Lock the entry mutex\n\tstd::unique_lock<std::mutex> lock(entry->mutex);\n\n\t// Compare the sequence ID\n\tif (entry->sequenceID != config().sequenceID) {\n\t\t// If the IDs differ, update the stored sequence ID and return SUCCESS\n\t\tconfig().sequenceID = entry->sequenceID;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Return FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 40.45886897866744}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tif(config().blackboard == nullptr) {\n        throw std::logic_error(\"[EntryUpdatedAction] Blackboard is nullptr\");\n    }\n\n    if(config().key == nullptr) {\n        throw std::logic_error(\"[EntryUpdatedAction] Key is nullptr\");\n    }\n\n    auto entry = config().blackboard->getEntry(config().key);\n    if(entry == nullptr) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::lock_guard<std::mutex> lock(entry->mutex);\n\n    if(entry->sequence_id == config().sequence_id) {\n        return NodeStatus::FAILURE;\n    }\n\n    config().sequence_id = entry->sequence_id;\n\n    return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 43.65843033697011}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n        return (children_nodes_.size() + success_threshold_);\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 53.14825530183474}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n        return std::max(size_t(0), children_nodes_.size() + success_threshold_);\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 55.652097873655826}, {"code": "size_t ParallelNode::successThreshold() const{\n\tsize_t result = success_threshold_;\n    if (result < 0) {\n        result = std::max(children_nodes_.size() + result, 0);\n    }\n    return result;\n}", "CodeBleu_score": 48.50715245950968}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile(true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    if(_p->heartbeat_status) {\n      // heartbeat is active\n      if(std::chrono::system_clock::now() - _p->heartbeat_time > std::chrono::milliseconds(500)) {\n        // heartbeat is no longer active\n        _p->heartbeat_status = false;\n        enableAllHooks(false);\n      }\n    } else {\n      // heartbeat is inactive\n      if(std::chrono::system_clock::now() - _p->heartbeat_time < std::chrono::milliseconds(500)) {\n        // heartbeat is now active\n        _p->heartbeat_status = true;\n        enableAllHooks(true);\n      }\n    }\n  }\n}", "CodeBleu_score": 44.92561771707274}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n        auto now = std::chrono::system_clock::now();\n        for (auto& [node_uid, hook] : _p->pre_hooks) {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            if (hook->enabled) {\n                auto last_heartbeat = hook->last_heartbeat;\n                if (now - last_heartbeat > std::chrono::milliseconds(1000)) {\n                    hook->enabled = false;\n                    lk.unlock();\n                    hook->wakeup.notify_all();\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 44.334068220072936}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile(true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n    for(auto& [node_uid, hook] : _p->pre_hooks) {\n      std::unique_lock<std::mutex> lk(hook->mutex);\n      if(hook->mode == Monitor::Hook::Mode::BREAKPOINT) {\n        if(hook->heartbeat_active && hook->heartbeat_last_time + std::chrono::milliseconds(1000) < std::chrono::system_clock::now()) {\n          hook->heartbeat_active = false;\n          hook->enabled = false;\n          lk.unlock();\n          hook->wakeup.notify_all();\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 40.01597569931475}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tnlohmann::json json_dump;\n    std::vector<uint8_t> msgpack_dump;\n\n    std::vector<std::string> bb_names = BT::splitString(bb_list, ',');\n\n    for (const auto& bb_name : bb_names) {\n        auto it = _p->subtrees.find(bb_name);\n        if (it != _p->subtrees.end()) {\n            std::lock_guard<std::mutex> lock(it->second.lock);\n            if (it->second.subtree) {\n                json_dump[bb_name] = BT::ExportBlackboardToJSON(it->second.subtree->rootNode()->blackboard());\n            }\n        }\n    }\n    msgpack_dump = nlohmann::json::to_msgpack(json_dump);\n    return msgpack_dump;\n}", "CodeBleu_score": 56.51185339845502}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> msgpack_data;\n\tnlohmann::json bb_dump;\n\tstd::vector<std::string> bb_names;\n\tstd::string bb_name;\n\tstd::string::size_type pos = 0;\n\tstd::string::size_type prev = 0;\n\n\t// Split the blackboard names\n\twhile (pos != std::string::npos) {\n\t\tpos = bb_list.find(',', prev);\n\t\tbb_name = bb_list.substr(prev, pos - prev);\n\t\tbb_names.push_back(bb_name);\n\t\tprev = pos + 1;\n\t}\n\n\t// Iterate through the blackboard names\n\tfor (auto bb_name : bb_names) {\n\t\t// Find the subtree\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it == _p->subtrees.end()) {\n\t\t\tROS_ERROR_STREAM(\"Blackboard \" << bb_name << \" not found\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Lock the subtree\n\t\tstd::lock_guard<std::mutex> lock(it->second.lock);\n\t\tif (it->second.subtree == nullptr) {\n\t\t\tROS_ERROR_STREAM(\"Blackboard \" << bb_name << \" is not valid\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Export the blackboard to JSON\n\t\tnlohmann::json bb_json = it->second.subtree->ExportBlackboardToJSON();\n\t\tbb_dump[bb_name] = bb_json;\n\t}\n\n\t// Convert the JSON object to MessagePack\n\tmsgpack_data = nlohmann::json::to_msgpack(bb_dump);\n\n\treturn msgpack_data;\n}", "CodeBleu_score": 48.74094950568125}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> msgpack_dump;\n    nlohmann::json json_dump;\n    std::vector<std::string> bb_names;\n    std::vector<std::string> subtree_names;\n    std::vector<std::string>::iterator it;\n    std::vector<std::string>::iterator it_subtree;\n    std::vector<std::string>::iterator it_bb;\n    std::vector<std::string>::iterator it_subtree_end;\n    std::vector<std::string>::iterator it_bb_end;\n    std::string::size_type pos;\n    std::string::size_type pos_subtree;\n    std::string::size_type pos_bb;\n    std::string subtree_name;\n    std::string bb_name;\n    std::string bb_name_full;\n    std::string bb_name_subtree;\n    std::string bb_name_subtree_full;\n    std::string bb_name_subtree_full_temp;\n    std::string bb_name_subtree_full_temp_2;\n    std::string bb_name_subtree_full_temp_3;\n    std::string bb_name_subtree_full_temp_4;\n    std::string bb_name_subtree_full_temp_5;\n    std::string bb_name_subtree_full_temp_6;\n    std::string bb_name_subtree_full_temp_7;\n    std::string bb_name_subtree_full_temp_8;\n    std::string bb_name_subtree_full_temp_9;\n    std::string bb_name_subtree_full_temp_10;\n    std::string bb_name_subtree_full_temp_11;\n    std::string bb_name_subtree_full_temp_12;\n    std::string bb_name_subtree_full_temp_13;\n    std::string bb_name_subtree_full_temp_14;\n    std::string bb_name", "CodeBleu_score": 12.027384518111484}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook) {\n    ROS_ERROR_STREAM(\"Could not find hook for node with UID \" << node_uid);\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->status != Monitor::Hook::BREAKPOINT) {\n    ROS_ERROR_STREAM(\"Hook for node with UID \" << node_uid << \" is not in breakpoint mode\");\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 52.209953133391785}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->wakeup.mutex);\n  if(hook->mode != Mode::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->mode = Mode::NORMAL;\n  hook->remove = remove;\n  hook->status = result;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 47.83470348077671}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if (hook->status != BreakpointStatus::BREAKPOINT) {\n    return false;\n  }\n  hook->status = BreakpointStatus::UNLOCKED;\n  hook->remove = remove;\n  hook->result = result;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 46.79223043689044}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t// Check if the node is IDLE\n  if (status() == NodeStatus::IDLE) {\n    // Set the status to RUNNING\n    setStatus(NodeStatus::RUNNING);\n    // Reset the halt request\n    halt_requested_.store(false);\n    // Start a new thread\n    tick_thread_ = std::async(std::launch::async, [this]() {\n      // Run the tick function\n      try {\n        tick_functor_(*this);\n      } catch (const std::exception& ex) {\n        // If an exception occurs, set the status to FAILURE and log the error\n        setStatus(NodeStatus::FAILURE);\n        BT::print(\"[ERROR] [BT::ThreadedAction::executeTick] \" + std::string(ex.what()));\n      } catch (...) {\n        // If an exception occurs, set the status to FAILURE and log the error\n        setStatus(NodeStatus::FAILURE);\n        BT::print(\"[ERROR] [BT::ThreadedAction::executeTick] Unknown exception\");\n      }\n      // If the tick function completes without a halt request, set the status to SUCCESS\n      if (!halt_requested_.load()) {\n        setStatus(NodeStatus::SUCCESS);\n      }\n      // Check if there are any exceptions stored\n      if (exception_ptr_ != nullptr) {\n        // If there are, rethrow them\n        std::rethrow_exception(exception_ptr_);\n      }\n    });\n  }\n  return status();\n}", "CodeBleu_score": 46.804638041722576}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n    halt_requested_.store(false);\n\n    std::future<NodeStatus> future_result = std::async(std::launch::async, [this]() {\n      try {\n        return tick_functor_(*this);\n      }\n      catch(const std::exception& ex) {\n        setStatus(NodeStatus::IDLE);\n        BT::setErrorMessage(ex.what());\n        return NodeStatus::IDLE;\n      }\n    });\n\n    future_result_ = std::move(future_result);\n  }\n\n  if(future_result_.valid() && future_result_.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n    try {\n      NodeStatus status = future_result_.get();\n\n      if(status != prev_status) {\n        setStatus(status);\n      }\n    }\n    catch(const std::exception& ex) {\n      setStatus(NodeStatus::IDLE);\n      BT::setErrorMessage(ex.what());\n    }\n  }\n\n  return status();\n}", "CodeBleu_score": 50.90777305322568}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  if(halt_requested_.load())\n  {\n    halt_requested_.store(false);\n    setStatus(NodeStatus::IDLE);\n    return NodeStatus::IDLE;\n  }\n\n  std::future<NodeStatus> future_result = std::async(std::launch::async, &ThreadedAction::tick_functor_, this);\n\n  try\n  {\n    NodeStatus status = future_result.get();\n    if(status != prev_status)\n    {\n      setStatus(status);\n    }\n  }\n  catch(const std::exception& ex)\n  {\n    setStatus(NodeStatus::IDLE);\n    std::stringstream ss;\n    ss << \"Exception caught in ThreadedAction: \" << ex.what();\n    throw std::runtime_error(ss.str());\n  }\n  catch(...)\n  {\n    setStatus(NodeStatus::IDLE);\n    throw std::runtime_error(\"Unknown exception caught in ThreadedAction\");\n  }\n\n  return status();\n}", "CodeBleu_score": 49.19561944180336}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// Define a recursive lambda function to print the tree\n  std::function<void(const TreeNode*, int)> print_tree_recursively = [&print_tree_recursively](const TreeNode* node, int depth) {\n    // Print the separator line\n    stream << std::string(depth, ' ') << \"------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "CodeBleu_score": 10.093388491545474}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tconst std::string indent_char = \" \";\n    const std::string separator = \"------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "CodeBleu_score": 5.031923775185551}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tconst std::string indent = \"    \";\n    const std::string separator = \"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "CodeBleu_score": 5.043788055725461}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n  visitor(node);\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for(const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 98.62111516673492}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for(const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 98.62111516673492}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for(const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 98.62111516673492}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.find(manifest.registrationID) != _p->builders.end()) {\n        throw BehaviorTreeException(\"Builder already registered for manifest \" + manifest.registrationID);\n    }\n    _p->builders.insert(std::make_pair(manifest.registrationID, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 57.367563310114456}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (manifest.registrationID.empty()) {\n        throw BehaviorTreeException(\"Registration ID cannot be empty\");\n    }\n\n    auto it = _p->builders.find(manifest.registrationID);\n    if (it != _p->builders.end()) {\n        throw BehaviorTreeException(\"Registration ID already exists\");\n    }\n\n    _p->builders.insert(std::make_pair(manifest.registrationID, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 57.30247174105655}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.registration_ID) != builders.end()) {\n        throw BehaviorTreeException(\"Builder with ID '\" + manifest.registration_ID + \"' is already registered.\");\n    }\n\n    manifests.insert(std::make_pair(manifest.registration_ID, manifest));\n    builders.insert(std::make_pair(manifest.registration_ID, builder));\n}", "CodeBleu_score": 51.66137266074766}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tauto builder = [=](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = TreeNodeManifest::NodeType::ACTION;\n  manifest.node_type = \"SimpleAction\";\n  manifest.registration_ID = ID;\n  manifest.ports = std::move(ports);\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 61.66575497151786}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tregisterBuilder(\n      TreeNodeManifest(ID, SimpleActionNode::type(), std::move(ports)),\n      [tick_functor](const std::string& ID, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(ID, tick_functor, config);\n      });\n}", "CodeBleu_score": 49.612399689204025}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tregisterBuilder(\n      TreeNodeManifest(ID, SimpleActionNode::type(), std::move(ports)),\n      [tick_functor](const std::string& ID, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(ID, tick_functor, config);\n      });\n}", "CodeBleu_score": 49.612399689204025}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n\n    for(auto& sub : tree.subtrees) {\n        bb.push_back(Blackboard::create());\n        sub->blackboard->cloneInto(bb.back());\n    }\n\n    return bb;\n}", "CodeBleu_score": 77.2000081213999}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        bb.push_back(Blackboard::create());\n        sub->blackboard->cloneInto(bb.back());\n    }\n    return bb;\n}", "CodeBleu_score": 79.06045304680563}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (auto& sub : tree.subtrees) {\n        bb.push_back(Blackboard::create());\n        sub->blackboard->cloneInto(bb.back());\n    }\n    return bb;\n}", "CodeBleu_score": 77.01419809235573}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor.has_value())\n  {\n    try\n    {\n      return executor.value()(env);\n    }\n    catch(std::runtime_error& err)\n    {\n      return nonstd::make_unexpected(err.what());\n    }\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 80.88446817024831}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor.has_value())\n  {\n    return executor.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 88.44682696911835}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor.has_value())\n  {\n    return executor.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 88.44682696911835}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n    if (library) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    library = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!library) {\n        throw RuntimeError(dlerror());\n    }\n    this->path = path;\n}", "CodeBleu_score": 51.3181242554396}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n  if (loaded) {\n    throw RuntimeError(\"Shared library already loaded\");\n  }\n  handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (handle == nullptr) {\n    throw RuntimeError(dlerror());\n  }\n  this->path = path;\n  loaded = true;\n}", "CodeBleu_score": 51.714333063614625}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Shared library already loaded\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    this->path = path;\n    loaded = true;\n}", "CodeBleu_score": 53.13513283590022}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size < 3) {\n        return false;\n    }\n\n    StringView stripped_str = str.strip();\n\n    if (stripped_str.size < 3) {\n        return false;\n    }\n\n    if (stripped_str.data[0] != '{') {\n        return false;\n    }\n\n    if (stripped_str.data[stripped_str.size - 1] != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = StringView(stripped_str.data + 1, stripped_str.size - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 28.560872946476202}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.trim();\n\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 25.830763866039756}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.data[0] != '{' || stripped.data[stripped.size - 1] != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = StringView(stripped.data + 1, stripped.size - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 24.944316558454766}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble lineCost = 0;\n  //initialize the line iterator\n  LineIterator line(x0, y0, x1, y1);\n\n  while(line.isValid()) {\n    //calculate the cost of the current point\n    double pointCost = this->pointCost(line.getX(), line.getY());\n    //if the cost is negative, we can't continue\n    if(pointCost < 0)\n      return pointCost;\n    //otherwise, update the line cost if the point cost is higher\n    if(pointCost > lineCost)\n      lineCost = pointCost;\n    //advance the line iterator\n    line.advance();\n  }\n\n  //return the total line cost\n  return lineCost;\n}", "CodeBleu_score": 62.31025364986187}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//initialize the line cost to the cost of the start point\n    double lineCost = pointCost(x0, y0);\n\n    //create a line iterator\n    LineIterator line(x0, y0, x1, y1);\n\n    //iterate through all of the points on the line\n    while(line.isValid()){\n      //calculate the cost of the current point\n      double cost = pointCost(line.getX(), line.getY());\n\n      //if the cost is negative, return it immediately\n      if(cost < 0)\n        return cost;\n\n      //otherwise, update the line cost if the cost is higher\n      if(cost > lineCost)\n        lineCost = cost;\n\n      //advance the line iterator\n      line.advance();\n    }\n\n    //return the total line cost\n    return lineCost;\n  }", "CodeBleu_score": 51.5711759799344}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble lineCost = 0;\n\n    //initialize the line iterator\n    LineIterator line(x0, y0, x1, y1);\n\n    //iterate through each point on the line\n    while(line.isValid()) {\n      //get the cost of the point\n      double pointCost = this->pointCost(line.getX(), line.getY());\n\n      //if the point cost is negative, return the point cost\n      if(pointCost < 0)\n        return pointCost;\n\n      //otherwise, update the line cost if the point cost is higher\n      if(pointCost > lineCost)\n        lineCost = pointCost;\n\n      //advance the line iterator\n      line.advance();\n    }\n\n    return lineCost;\n  }", "CodeBleu_score": 63.81510634189485}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) return;\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n  for (unsigned int i=0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 87.4367760741649}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty())\n    return;\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  for (unsigned int i=0; i < path.size(); i++)  {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 91.69680483105623}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty())\n        return;\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.poses.resize(path.size());\n    for (unsigned int i = 0; i < path.size(); ++i)\n        gui_path.poses[i] = path[i].pose;\n    pub.publish(gui_path);\n}", "CodeBleu_score": 77.74266047265694}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\treturn (std::abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n            std::abs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity &&\n            std::abs(base_odom.twist.twist.linear.z) <= trans_stopped_velocity &&\n            std::abs(base_odom.twist.twist.angular.x) <= rot_stopped_velocity &&\n            std::abs(base_odom.twist.twist.angular.y) <= rot_stopped_velocity &&\n            std::abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity);\n}", "CodeBleu_score": 56.05771791035114}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tif (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n        abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n        abs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 70.15254638725685}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tif(fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n        fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n        fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 83.91264003375211}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_) {\n    if (restore_defaults) {\n      config_ = LocalPlannerLimits();\n      setup_ = false;\n    }\n    else {\n      config_ = config;\n    }\n  }\n  else {\n    config_ = config;\n    setup_ = true;\n  }\n  boost::unique_lock<boost::mutex> lock(mutex_);\n  limits_ = config_;\n}", "CodeBleu_score": 57.89872498102555}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t// Check if the setup is done\n  if (!setup) {\n    // Setup the default limits\n    default_limits.max_vel_x = config.max_vel_x;\n    default_limits.max_vel_y = config.max_vel_y;\n    default_limits.max_vel_theta = config.max_vel_theta;\n    default_limits.max_vel_x_backwards = config.max_vel_x_backwards;\n    default_limits.min_in_place_vel_x = config.min_in_place_vel_x;\n    default_limits.min_in_place_vel_y = config.min_in_place_vel_y;\n    default_limits.min_in_place_vel_theta = config.min_in_place_vel_theta;\n    default_limits.max_vel_x_robot_centric = config.max_vel_x_robot_centric;\n    default_limits.max_vel_y_robot_centric = config.max_vel_y_robot_centric;\n    default_limits.max_vel_theta_robot_centric = config.max_vel_theta_robot_centric;\n    default_limits.max_vel_x_backwards_robot_centric = config.max_vel_x_backwards_robot_centric;\n    default_limits.min_in_place_vel_x_robot_centric = config.min_in_place_vel_x_robot_centric;\n    default_limits.min_in_place_vel_y_robot_centric = config.min_in_place_vel_y_robot_centric;\n    default_limits.min_in_place_vel_theta_robot_centric = config.min_in_place_vel_theta_robot_centric;\n    default_limits.max_vel_x_local_goal = config.max_vel_x_local_goal;\n    default_limits.max_vel_y_local_goal = config.max_vel_y_local_goal;\n    default_limits.max_", "CodeBleu_score": 22.523482036931686}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_flag_) {\n        if (restore_defaults) {\n            config.max_vel_x = default_config_.max_vel_x;\n            config.max_vel_x_backwards = default_config_.max_vel_x_backwards;\n            config.max_vel_y = default_config_.max_vel_y;\n            config.max_vel_theta = default_config_.max_vel_theta;\n            config.min_in_place_vel_theta = default_config_.min_in_place_vel_theta;\n            config.max_vel_x_in_place = default_config_.max_vel_x_in_place;\n            config.max_vel_y_in_place = default_config_.max_vel_y_in_place;\n            config.max_vel_theta_in_place = default_config_.max_vel_theta_in_place;\n            config.max_trans_acc = default_config_.max_trans_acc;\n            config.max_rot_acc = default_config_.max_rot_acc;\n            config.max_trans_jerk = default_config_.max_trans_jerk;\n            config.max_rot_jerk = default_config_.max_rot_jerk;\n            config.max_vel_x_backwards = default_config_.max_vel_x_backwards;\n            config.max_vel_y_backwards = default_config_.max_vel_y_backwards;\n            config.max_vel_theta_backwards = default_config_.max_vel_theta_backwards;\n            config.min_in_place_vel_theta_backwards = default_config_.min_in_place_vel_theta_backwards;\n            config.max_vel_x_in_place_backwards = default_config_.max_vel_x_in_place_backwards;\n            config.max_vel_y_in_place_backwards = default_config_.max_vel_y_in_place_backwards;\n            config.max_vel_theta_in_place_backwards = default_config_.max_vel_theta_in_place_", "CodeBleu_score": 27.25670309682458}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tunsigned int mx, my;\n  unsigned int cx, cy;\n  double x_res, y_res;\n  double x, y;\n  double new_distance;\n\n  // get the map coordinates of the current cell\n  mx = current_cell->getX();\n  my = current_cell->getY();\n\n  // get the map coordinates of the cell we're checking\n  cx = check_cell->getX();\n  cy = check_cell->getY();\n\n  // get the resolution of the costmap\n  x_res = costmap.getResolution();\n  y_res = costmap.getResolution();\n\n  // calculate the distance from the current cell to the cell we're checking\n  x = (cx - mx) * x_res;\n  y = (cy - my) * y_res;\n\n  // calculate the new distance\n  new_distance = current_cell->getTargetDistance() + sqrt(x * x + y * y);\n\n  // if the new distance is shorter, update the cell's target distance\n  if (new_distance < check_cell->getTargetDistance()) {\n    check_cell->setTargetDistance(new_distance);\n    return true;\n  }\n\n  // otherwise, the new distance is longer, so don't update the cell\n  return false;\n}", "CodeBleu_score": 44.40207630678402}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tunsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n    if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n        check_cell->target_distance = obstacle_cost_;\n        return false;\n    }\n    double new_distance = std::sqrt(std::pow(current_cell->x - check_cell->x, 2) +\n                                    std::pow(current_cell->y - check_cell->y, 2));\n    if (new_distance < check_cell->target_distance) {\n        check_cell->target_distance = new_distance;\n    }\n    return true;\n}", "CodeBleu_score": 66.3727450897652}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// get the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->x_, check_cell->y_);\n  // if the cost is an obstacle or the costmap has no information\n  if (cost == costmap_2d::LETHAL_OBSTACLE ||\n      cost == costmap_2d::NO_INFORMATION) {\n    // set the target distance to the maximum obstacle cost\n    check_cell->target_distance_ = obstacle_costs_->max_obstacle_cost;\n    return false;\n  }\n  // otherwise calculate a new target distance\n  double new_distance = calculateDistance(current_cell, check_cell);\n  // if the new distance is shorter\n  if (new_distance < check_cell->target_distance_) {\n    // update the target distance\n    check_cell->target_distance_ = new_distance;\n  }\n  return true;\n}", "CodeBleu_score": 64.04318135488548}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"Obstacle cost function called before footprint was set\");\n    return -9.0;\n  }\n\n  //we'll use the scaling factor to make the robot slow down if it's\n  //going to hit something, or to keep it further from obstacles\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //we'll use the scaling factor to make the robot slow down if it's\n  //going to hit something, or to keep it further from obstacles\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double x, y, th;\n    traj.getPoint(i, x, y, th);\n\n    cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint cost is negative, we'll return immediately\n    if (cost < 0.0) {\n      return cost;\n    }\n\n    //otherwise, we'll either sum the scores or take the maximum\n    if (sum_scores_) {\n      cost += cost;\n    }\n    else {\n      cost = std::max(cost, cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 66.74791944837042}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n\n  //if we don't have a footprint specification, we can't score the trajectory\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"ObstacleCostFunction: No footprint specified for trajectory scoring\");\n    return -9.0;\n  }\n\n  //initialize the scaling factor based on the speed of the robot\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //if we're going to be summing the scores, we'll initialize the cost to 0\n  if (sum_scores_) {\n    cost = 0.0;\n  }\n  else {\n    //otherwise, we'll initialize the cost to a very high value\n    cost = -100000000.0;\n  }\n\n  //for each point in the trajectory, we'll calculate the footprint cost\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    geometry_msgs::Point pt = traj.getPoint(i);\n    double x = pt.x;\n    double y = pt.y;\n    double th = traj.getYaw(i);\n    double footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint cost is negative, we'll return immediately\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    //otherwise, we'll either sum the scores or take the maximum\n    if (sum_scores_) {\n      cost += footprint_cost;\n    }\n    else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  //return the total cost\n  return cost;\n}", "CodeBleu_score": 67.57861372161372}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: No footprint specification given\");\n    return -9.0;\n  }\n\n  //initialize the cost and scaling factor based on the trajectory and speed parameters\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  cost = footprintCost(traj.getPoint(0).x, traj.getPoint(0).y, traj.getPoint(0).theta, scale, footprint_spec_, costmap_, world_model_);\n  if (cost < 0) {\n    return cost;\n  }\n\n  //for each point in the trajectory, calculate the footprint cost\n  for (unsigned int i = 1; i < traj.getPointsSize(); ++i) {\n    cost = footprintCost(traj.getPoint(i).x, traj.getPoint(i).y, traj.getPoint(i).theta, scale, footprint_spec_, costmap_, world_model_);\n    if (cost < 0) {\n      return cost;\n    }\n\n    //either sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_) {\n      cost += footprintCost(traj.getPoint(i).x, traj.getPoint(i).y, traj.getPoint(i).theta, scale, footprint_spec_, costmap_, world_model_);\n    } else {\n      cost = std::max(cost, footprintCost(traj.getPoint(i).x, traj.getPoint(i).y, traj.getPoint(i).theta, scale, footprint_spec_, costmap_, world_model_));\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 58.09358256861172}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// Scale the footprint points\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point point;\n    point.x = scale * footprint_spec[i].x;\n    point.y = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(point);\n  }\n\n  // Get the cost at the given position\n  double cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n\n  // If the cost is negative, return -6.0\n  if (cost < 0) {\n    return -6.0;\n  }\n\n  // If the position is off the map, return -7.0\n  if (!costmap->worldToMap(x, y, x, y)) {\n    return -7.0;\n  }\n\n  // Otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n  return std::max(cost, (double)costmap->getCost(x, y));\n}", "CodeBleu_score": 67.43036518711116}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// scale the footprint points by the given scale factor\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point point = footprint_spec[i];\n    point.x *= scale;\n    point.y *= scale;\n    scaled_footprint.push_back(point);\n  }\n  // compute the footprint cost using a world model\n  double footprint_cost = world_model->footprintCost(scaled_footprint, costmap, x, y, th);\n  // if the cost is negative, return -6.0\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  // if the position is off the map, return -7.0\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n  // otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n  unsigned int cost = costmap->getCost(mx, my);\n  return std::max(cost, footprint_cost);\n}", "CodeBleu_score": 69.31761110842172}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      ROS_INFO_STREAM_NAMED(\"dwa_local_planner\", \"Setting odometry topic to \" << odom_topic_);\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      ROS_INFO_STREAM_NAMED(\"dwa_local_planner\", \"Shutting down odometry subscription\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.81924904178901}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 50.760719993128674}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n    else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 51.28764340022194}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f diff = pos - prev;\n  float dist = diff.norm();\n  if (dist > kDistThreshold) {\n    resetOscillationFlags();\n  }\n  else {\n    float angle = diff.angle(prev);\n    if (angle > kAngleThreshold) {\n      resetOscillationFlags();\n    }\n  }\n}", "CodeBleu_score": 38.182862442425495}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f diff = pos - prev;\n  float dist = diff.norm();\n  float angle = fabs(diff.z() / dist);\n  if (dist > 0.05 || angle > 0.25) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 31.803785144180484}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f dist = pos - prev;\n  float distance = dist.norm();\n  float angle = fabs(atan2(dist.y(), dist.x()));\n\n  if (distance > reset_distance_threshold_ || angle > reset_angle_threshold_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 33.29441836168277}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy));\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy + 1));\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx, gy + 1));\n    }\n\n    //upper right\n    if(gx < width_ - 1 && gy < height_ - 1){", "CodeBleu_score": 43.70135926228376}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //get the bounds of the grid cell in world coords\n  geometry_msgs::Point lower_left, upper_right;\n  getCellBounds(gx, gy, lower_left, upper_right);\n\n  //if the point is too close to its nearest neighbor, don't insert it\n  double sq_dist = sq_distance(pt, lower_left);\n  if(sq_dist < sq_min_separation_)\n    return;\n\n  //get the index of the cell to insert the point into\n  unsigned int cell_index = gridIndex(gx, gy);\n\n  //insert the point into the cell\n  cells_[cell_index].push_back(pt);\n}", "CodeBleu_score": 67.12026948026522}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n    gridCoords(pt, gx, gy);\n\n    //check if the point is outside the grid bounds\n    if(gx >= width_ || gy >= height_)\n      return;\n\n    //check if the point is too close to its nearest neighbor\n    if(nearestNeighborDistance(pt) < sq_min_separation_)\n      return;\n\n    //calculate the grid index\n    unsigned int pt_index = gx + gy * width_;\n\n    //insert the point into the grid\n    cells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 77.00718757086554}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i] + acclimits[i] * dt)\n            new_vel[i] = vel[i] + acclimits[i] * dt;\n        else if (sample_target_vel[i] < vel[i] - acclimits[i] * dt)\n            new_vel[i] = vel[i] - acclimits[i] * dt;\n        else\n            new_vel[i] = sample_target_vel[i];\n    }\n\n    return new_vel;\n}", "CodeBleu_score": 71.97930240449125}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel(i) > vel(i) + acclimits(i) * dt) {\n      new_vel(i) = vel(i) + acclimits(i) * dt;\n    }\n    else if (sample_target_vel(i) < vel(i) - acclimits(i) * dt) {\n      new_vel(i) = vel(i) - acclimits(i) * dt;\n    }\n    else {\n      new_vel(i) = sample_target_vel(i);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 61.57917137812245}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    new_vel[i] = vel[i] + acclimits[i] * dt;\n    if (new_vel[i] < sample_target_vel[i]) {\n      new_vel[i] = std::min(new_vel[i], sample_target_vel[i]);\n    } else {\n      new_vel[i] = std::max(new_vel[i], sample_target_vel[i]);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 75.79754983284668}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (unsigned int i = global_plan_.size() - 1; i >= 0; --i) {\n    // Convert the goal cell coordinates to world coordinates\n    double goal_x = costmap_.mapToWorld(global_plan_[i].x_i, global_plan_[i].y_i).x;\n    double goal_y = costmap_.mapToWorld(global_plan_[i].x_i, global_plan_[i].y_i).y;\n\n    // Check if the goal cell is clear\n    if (costmap_.getCost(global_plan_[i].x_i, global_plan_[i].y_i) < 50) {\n      // Calculate the shortest angular distance between the current heading and the direction to the goal point\n      double heading_diff = angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n\n      // Check if the heading difference is valid\n      if (heading_diff >= 0.0) {\n        // Return the absolute value of the heading difference\n        return fabs(heading_diff);\n      }\n    }\n  }\n\n  // Return DBL_MAX\n  return DBL_MAX;\n}", "CodeBleu_score": 50.47324846590545}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = global_plan_.size() - 2; i >= 0; i--) {\n    double x_diff = global_plan_[i].pose.position.x - x;\n    double y_diff = global_plan_[i].pose.position.y - y;\n    double distance = sqrt(x_diff * x_diff + y_diff * y_diff);\n\n    //If the distance to the goal point is greater than the robot's radius, then it is not a valid point\n    if (distance > radius_) {\n      continue;\n    }\n\n    //If the goal point is not in the robot's costmap, then it is not a valid point\n    if (!costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, cell_x, cell_y)) {\n      continue;\n    }\n\n    //If the goal point is not in the robot's footprint, then it is not a valid point\n    if (footprintCost(cell_x, cell_y) < 0) {\n      continue;\n    }\n\n    //If the goal point is not in a line of sight, then it is not a valid point\n    if (lineCost(robot_x_, robot_y_, cell_x, cell_y) < 0) {\n      continue;\n    }\n\n    //If a valid point is found, convert the goal cell coordinates to world coordinates and return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n    double goal_x = global_plan_[i].pose.position.x;\n    double goal_y = global_plan_[i].pose.position.y;\n    costmap_.mapToWorld(cell_x, cell_y, goal_x, goal_y);\n    return angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n  }\n\n  //If no valid point is found, return DBL_", "CodeBleu_score": 56.642974393859625}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//Find the farthest point with a clear line of sight from the robot's current cell\n  double d = DBL_MAX;\n  unsigned int i = 0;\n  for (i = global_plan_.size() - 1; i >= 1; i--) {\n    if (worldToMap(global_plan_[i].x, global_plan_[i].y, cell_x, cell_y)) {\n      if (lineCost(cell_x, cell_x + cos(heading), cell_y, cell_y + sin(heading)) >= 0) {\n        d = angles::shortest_angular_distance(heading, atan2(global_plan_[i].y - y, global_plan_[i].x - x));\n        break;\n      }\n    }\n  }\n\n  //If a valid point is found, convert the goal cell coordinates to world coordinates and return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n  if (i > 0) {\n    return fabs(d);\n  }\n\n  //If no valid point is found, return DBL_MAX\n  return DBL_MAX;\n}", "CodeBleu_score": 50.37593081283218}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tTrajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    if (t.cost_ < 0) {\n      ROS_WARN(\"Trajectory rejected: sampled velocities (%f,%f,%f), cost %f\",\n               vx_samp, vy_samp, vtheta_samp, t.cost_);\n      return false;\n    } else {\n      return true;\n    }\n  }", "CodeBleu_score": 59.268292501608244}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tTrajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    if( t.cost_ >= 0 ) {\n      return true;\n    } else {\n      ROS_WARN(\"Trajectory rejected.  Cost: %f, sample velocities: (%f, %f, %f)\",\n               t.cost_, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n  }", "CodeBleu_score": 59.0006265503948}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta,\n                                  vx_samp, vy_samp, vtheta_samp);\n\n    if (cost < 0) {\n      ROS_WARN(\"Trajectory rejected: cost = %f, vx = %f, vy = %f, vtheta = %f\",\n               cost, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n\n    return true;\n  }", "CodeBleu_score": 73.02070763010475}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointers are not set\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside of the specified area\");\n  } else {\n    ROS_WARN(\"Clearing inside of the specified area\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if (affected_maps_.find(\"global_costmap\") != affected_maps_.end()) {\n    global_costmap_->updateMap();\n    ROS_DEBUG(\"Global costmap cleared in %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (affected_maps_.find(\"local_costmap\") != affected_maps_.end()) {\n    local_costmap_->updateMap();\n    ROS_DEBUG(\"Local costmap cleared in %f seconds\", (ros::WallTime::now() - t0).toSec());\n  }\n}", "CodeBleu_score": 46.91001095562293}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"The plugin must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointers are not set\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the area specified by the footprint\");\n  } else {\n    ROS_WARN(\"Clearing outside the area specified by the footprint\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_.find(\"global_costmap\") != std::string::npos) {\n    clear(global_costmap_);\n  }\n\n  if (affected_maps_.find(\"local_costmap\") != std::string::npos) {\n    clear(local_costmap_);\n  }\n\n  ROS_DEBUG(\"Clearing took %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 42.70849682817707}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"The plugin must be initialized before runBehavior is called.\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global costmap must exist to run this behavior.\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"The local costmap must exist to run this behavior.\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside of the specified area.\");\n  } else {\n    ROS_WARN(\"Clearing inside of the specified area.\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_.find(\"global_costmap\") != std::string::npos) {\n    clear(global_costmap_);\n  }\n  if (affected_maps_.find(\"local_costmap\") != std::string::npos) {\n    clear(local_costmap_);\n  }\n  ROS_DEBUG(\"Time to clear costmaps: %f\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 44.81206319691541}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tpolygon_cells.clear();\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tif (polygon.size() == 1) {\n\t\tpolygon_cells.push_back(polygon.front());\n\t\treturn;\n\t}\n\tMapLocation current_cell, next_cell;\n\tstd::vector<MapLocation> ray;\n\tfor (unsigned int i = 0; i < polygon.size(); ++i) {\n\t\tconst MapLocation& current_point = polygon[i];\n\t\tconst MapLocation& next_point = polygon[(i + 1) % polygon.size()];\n\t\traytraceLine(current_point, next_point, ray);\n\t\tfor (unsigned int j = 0; j < ray.size(); ++j) {\n\t\t\tcurrent_cell = ray[j];\n\t\t\tif (i == 0) {\n\t\t\t\tpolygon_cells.push_back(current_cell);\n\t\t\t} else {\n\t\t\t\tnext_cell = polygon_cells.back();\n\t\t\t\tif (!(current_cell == next_cell)) {\n\t\t\t\t\tpolygon_cells.push_back(current_cell);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.35944043242797}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tpolygon_cells.clear();\n  if (polygon.empty()) {\n    return;\n  }\n\n  // initialize the polygon outline object\n  PolygonOutlineCells outline(polygon);\n\n  // iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points\n  for (unsigned int i = 0; i < polygon.size(); i++) {\n    const MapLocation& start = polygon[i];\n    const MapLocation& end = polygon[(i + 1) % polygon.size()];\n    outline.raytraceLine(start, end);\n  }\n\n  // if the polygon is not empty, it also closes the polygon by connecting the last point to the first\n  if (!polygon.empty()) {\n    const MapLocation& start = polygon[polygon.size() - 1];\n    const MapLocation& end = polygon[0];\n    outline.raytraceLine(start, end);\n  }\n\n  // get the cells from the polygon outline object\n  polygon_cells = outline.getCells();\n}", "CodeBleu_score": 55.319824146145045}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tpolygon_cells.clear();\n  PolygonOutlineCells outline_cells(polygon);\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    if (i < polygon.size() - 1) {\n      raytraceLine(polygon[i], polygon[i + 1], outline_cells);\n    } else if (polygon.size() > 1) {\n      raytraceLine(polygon[i], polygon[0], outline_cells);\n    }\n  }\n  polygon_cells = outline_cells.getCells();\n}", "CodeBleu_score": 55.422956118533875}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (pub.getSubscriberName() == \"map_metadata\")\n    return;\n\n  if (!pub.getTopic().empty()) {\n    ROS_DEBUG(\"Got a new subscriber to the costmap topic: %s\", pub.getSubscriberName().c_str());\n    prepareGrid();\n    pub.publish(grid_);\n  }\n}", "CodeBleu_score": 59.84859038981928}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 64.70573755156508}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (pub.getSubscriberName() == pub_.getSubscriberName()) {\n    // we're not interested in our own subscriber\n    return;\n  }\n\n  prepareGrid();\n  pub_.publish(grid_);\n}", "CodeBleu_score": 56.58593665923445}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\tcostmap_->getMutex()->lock();\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = costmap_->getResolution();\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = translation_table_[costmap_->getCharMap()[i]];\n  }\n  costmap_->getMutex()->unlock();\n}", "CodeBleu_score": 55.474876436428474}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// Lock the costmap mutex\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*costmap_->getMutex());\n\n  // Get the resolution of the costmap\n  double resolution = costmap_->getResolution();\n\n  // Set the header\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n\n  // Set the resolution\n  grid_.info.resolution = resolution;\n\n  // Set the width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin\n  double origin_x, origin_y;\n  costmap_->mapToWorld(0, 0, origin_x, origin_y);\n\n  // Set the origin's position and orientation\n  grid_.info.origin.position.x = origin_x;\n  grid_.info.origin.position.y = origin_y;\n  grid_.info.origin.position.z = 0;\n  grid_.info.origin.orientation.x = 0;\n  grid_.info.origin.orientation.y = 0;\n  grid_.info.origin.orientation.z = 0;\n  grid_.info.origin.orientation.w = 1;\n\n  // Save the origin coordinates\n  origin_x_ = origin_x;\n  origin_y_ = origin_y;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = charMapToOccupancyGrid(costmap_->getCharMap()[i]);\n  }\n}", "CodeBleu_score": 68.52641620979021}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tif (!enabled_) {\n    return;\n  }\n\n  costmap_->lock();\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.info.resolution = costmap_->getResolution();\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx;\n  grid_.info.origin.position.y = wy;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = char2cost(costmap_->getCharMap()[i]);\n  }\n\n  costmap_->unlock();\n}", "CodeBleu_score": 59.811669192883585}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// check if the footprint is the same in the new and old configs\n  if (new_config.footprint.empty() && old_config.footprint.empty() &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // check if the new config contains a valid footprint string\n  if (!new_config.footprint.empty()) {\n    if (makeFootprintFromString(new_config.footprint, unpadded_footprint_)) {\n      setUnpaddedRobotFootprint(unpadded_footprint_);\n      return;\n    }\n\n    ROS_ERROR(\"Invalid footprint string provided.  Defaulting to a square footprint.\");\n  }\n\n  // if we get here, we need to make a footprint from the robot radius\n  makeFootprintFromRadius(new_config.robot_radius, unpadded_footprint_);\n  setUnpaddedRobotFootprint(unpadded_footprint_);\n}", "CodeBleu_score": 60.97720673433626}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// Check if the footprint or robot radius has changed\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If the footprint string is valid, set the footprint\n  if (new_config.footprint.size() > 0) {\n    std::vector<geometry_msgs::Point> footprint;\n    if (makeFootprintFromString(new_config.footprint, footprint)) {\n      setUnpaddedRobotFootprint(footprint);\n      return;\n    }\n  }\n\n  // If the footprint string is invalid or empty, set the footprint based on the robot radius\n  std::vector<geometry_msgs::Point> footprint;\n  makeFootprintFromRadius(new_config.robot_radius, footprint);\n  setUnpaddedRobotFootprint(footprint);\n}", "CodeBleu_score": 64.56855095042499}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    if (makeFootprintFromString(new_config.footprint, points)) {\n      setUnpaddedRobotFootprint(points);\n      return;\n    }\n  }\n\n  ROS_ERROR(\"Invalid footprint string.  Using default.\");\n  setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n}", "CodeBleu_score": 68.7704353235877}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get robot pose for reconfiguration. Reconfiguration cancelled.\");\n    return;\n  }\n  if (new_pose.header.stamp.toSec() == 0.0) {\n    ROS_WARN(\"Got a zero time stamp for robot pose. Reconfiguration cancelled.\");\n    return;\n  }\n  if (new_pose.header.frame_id != global_frame_) {\n    ROS_WARN(\"Got a pose in the wrong frame. Reconfiguration cancelled.\");\n    return;\n  }\n  if (new_pose.pose.position.x == 0.0 && new_pose.pose.position.y == 0.0) {\n    ROS_WARN(\"Got a zero position for robot pose. Reconfiguration cancelled.\");\n    return;\n  }\n  if (new_pose.pose.orientation.x == 0.0 && new_pose.pose.orientation.y == 0.0 &&\n      new_pose.pose.orientation.z == 0.0 && new_pose.pose.orientation.w == 0.0) {\n    ROS_WARN(\"Got a zero orientation for robot pose. Reconfiguration cancelled.\");\n    return;\n  }\n  if (new_pose.pose.position.x == robot_pose_.pose.position.x &&\n      new_pose.pose.position.y == robot_pose_.pose.position.y &&\n      new_pose.pose.orientation.x == robot_pose_.pose.orientation.x &&\n      new_pose.pose.orientation.y == robot_pose_.pose.orientation.y &&\n      new_pose.pose.orientation.z == robot_pose_.pose.orientation.z &&\n      new_pose.pose.orientation.w == robot_pose_.pose.orientation.w) {\n    ROS_WARN(\"Got the same pose as last time. Reconfiguration cancelled.\");\n    return;\n  }\n\n  // update the robot pose\n  robot_pose_ = new_pose;\n\n  // update the costmap", "CodeBleu_score": 51.99589395519395}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// get the robot's pose\n  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get the robot pose for reconfiguration. Cancelling reconfiguration.\");\n    return;\n  }\n  // check if the robot has moved\n  if (!new_pose.pose.position.x == robot_pose_.pose.position.x ||\n      !new_pose.pose.position.y == robot_pose_.pose.position.y ||\n      !new_pose.pose.position.z == robot_pose_.pose.position.z) {\n    // update the robot's pose\n    robot_pose_ = new_pose;\n    // update the robot's footprint\n    footprint_spec_.clear();\n    geometry_msgs::Point p;\n    p.x = robot_inscribed_radius_ * cos(robot_pose_.pose.orientation.w);\n    p.y = robot_inscribed_radius_ * sin(robot_pose_.pose.orientation.w);\n    footprint_spec_.push_back(p);\n    p.x = robot_inscribed_radius_ * cos(robot_pose_.pose.orientation.w + M_PI_2);\n    p.y = robot_inscribed_radius_ * sin(robot_pose_.pose.orientation.w + M_PI_2);\n    footprint_spec_.push_back(p);\n    p.x = robot_inscribed_radius_ * cos(robot_pose_.pose.orientation.w + M_PI);\n    p.y = robot_inscribed_radius_ * sin(robot_pose_.pose.orientation.w + M_PI);\n    footprint_spec_.push_back(p);\n    p.x = robot_inscribed_radius_ * cos(robot_pose_.pose.orientation.w + 3 * M_PI_2);\n    p.y = robot_inscribed_radius_ * sin(robot_pose_.pose.orientation.w + 3 * M_PI_2);\n    footprint_spec_.push_back(p);\n    // update the robot'", "CodeBleu_score": 51.85179113113626}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// get the global pose of the robot\n  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get robot pose for reconfiguration. Cancelling reconfigure.\");\n    return;\n  }\n\n  // check if the robot has moved\n  if (new_pose.pose.position.x != x_ || new_pose.pose.position.y != y_ ||\n      new_pose.pose.orientation.x != q_x_ || new_pose.pose.orientation.y != q_y_ ||\n      new_pose.pose.orientation.z != q_z_ || new_pose.pose.orientation.w != q_w_) {\n    // update the robot's position\n    x_ = new_pose.pose.position.x;\n    y_ = new_pose.pose.position.y;\n    q_x_ = new_pose.pose.orientation.x;\n    q_y_ = new_pose.pose.orientation.y;\n    q_z_ = new_pose.pose.orientation.z;\n    q_w_ = new_pose.pose.orientation.w;\n\n    // update the costmap\n    updateMap();\n  }\n}", "CodeBleu_score": 55.076776574577366}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\tif (!stop_updates_) {\n    return;\n  }\n  stop_updates_ = false;\n  // re-subscribe to topics by activating each plugin\n  for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n    (*plugin)->activate();\n  }\n  // wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !initialized_ || !map_update_thread_active_) {\n    ros::Duration(0.001).sleep();\n  }\n}", "CodeBleu_score": 50.778646677104646}, {"code": "void Costmap2DROS::start(){\n\tif (is_running_) {\n    return;\n  }\n\n  // get the list of plugins\n  std::vector<boost::shared_ptr<Layer> > plugins = layered_costmap_->getPlugins();\n\n  // check if the costmap was stopped\n  if (stop_updates_) {\n    // re-subscribe to topics by activating each plugin\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins.begin(); plugin != plugins.end(); ++plugin) {\n      (*plugin)->activate();\n    }\n\n    // set the stopped flag to false\n    stop_updates_ = false;\n  }\n\n  // set stop_updates_ to false\n  stop_updates_ = false;\n\n  // wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !layered_costmap_->isInitialized() || !map_update_thread_) {\n    r.sleep();\n  }\n\n  // set the running flag to true\n  is_running_ = true;\n}", "CodeBleu_score": 62.181755261470094}, {"code": "void Costmap2DROS::start(){\n\t// if the costmap is not stopped, do nothing\n  if (!stopped_) {\n    return;\n  }\n\n  // re-subscribe to topics by activating each plugin\n  for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n    (*plugin)->activate();\n  }\n\n  // set the stopped flag to false\n  stopped_ = false;\n\n  // set stop_updates_ to false\n  stop_updates_ = false;\n\n  // wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !initialized_ || !map_update_thread_active_) {\n    r.sleep();\n  }\n}", "CodeBleu_score": 53.67765994350739}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0)) {\n    if (!observation_list_.empty()) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.end()-1);\n    }\n  } else {\n    while (observation_list_.size() > 1) {\n      if ((ros::Time::now() - observation_list_.front().timestamp_) > observation_keep_time_) {\n        observation_list_.pop_front();\n      } else {\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 41.009898919401685}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_list_.empty()) {\n    return;\n  }\n  if (observation_keep_time_ == ros::Duration(0)) {\n    observation_list_.erase(observation_list_.begin(), observation_list_.end());\n    observation_list_.push_back(observation_);\n    return;\n  }\n  // Iterate through the list and remove observations that are older than the specified keep time, stopping once it finds a valid observation.\n  observation_list_.erase(observation_list_.begin(), observation_list_.end());\n  observation_list_.push_back(observation_);\n  for (ObservationList::iterator it = observation_list_.begin(); it != observation_list_.end(); ++it) {\n    if (ros::Time::now() - it->header.stamp < observation_keep_time_) {\n      return;\n    }\n    observation_list_.erase(it);\n  }\n}", "CodeBleu_score": 50.874547482404274}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0)) {\n    if (observation_list_.size() > 0) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.end()-1);\n    }\n  } else {\n    for (ObservationList::iterator it = observation_list_.begin(); it != observation_list_.end(); ++it) {\n      if (ros::Time::now() - it->time_stamp_ < observation_keep_time_) {\n        break;\n      }\n      it = observation_list_.erase(it);\n      if (it == observation_list_.end()) {\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 47.53882040576735}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tdouble start_angle = angles::shortest_angular_distance(0, tf2::getYaw(path[start_index].pose.orientation));\n  double end_angle = angles::shortest_angular_distance(0, tf2::getYaw(path[end_index].pose.orientation));\n  double delta_angle = angles::shortest_angular_distance(start_angle, end_angle);\n  double delta_angle_increment = delta_angle / (end_index - start_index);\n  for (int i = start_index; i <= end_index; i++) {\n    double angle = angles::shortest_angular_distance(start_angle, i * delta_angle_increment);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 60.203762761156995}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// 1. Compute the yaw angle at the start and end indices\n  double start_yaw = angles::shortest_angular_distance(0.0, tf2::getYaw(path[start_index].pose.orientation));\n  double end_yaw = angles::shortest_angular_distance(0.0, tf2::getYaw(path[end_index].pose.orientation));\n\n  // 2. Determine the shortest angular distance between the start and end yaw angles\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // 3. Compute the incremental change in angle for each pose and update the orientation of each pose in the specified range accordingly\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = angles::shortest_angular_distance(start_yaw, tf2::getYaw(path[i].pose.orientation));\n    double incremental_change = angles::shortest_angular_distance(yaw, yaw + delta_yaw);\n    set_angle(&path[i], yaw + incremental_change);\n  }\n}", "CodeBleu_score": 56.092124587088264}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tif (start_index >= end_index) {\n    return;\n  }\n\n  // get yaw angles at start and end\n  double start_angle = tf2::getYaw(path.at(start_index).pose.orientation);\n  double end_angle = tf2::getYaw(path.at(end_index).pose.orientation);\n\n  // determine the shortest angular distance between start and end\n  double delta_angle = angles::shortest_angular_distance(start_angle, end_angle);\n\n  // determine incremental change in angle for each pose\n  double angle_inc = delta_angle / (end_index - start_index);\n\n  // set the angle for each pose in the specified range\n  for (int i = start_index; i <= end_index; ++i) {\n    set_angle(&path.at(i), start_angle);\n    start_angle += angle_inc;\n  }\n}", "CodeBleu_score": 51.494806917833245}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t//ROS_INFO(\"PlannerWithCostmap::makePlanService\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::makePlanService: start\");\n  //ROS_INFO(\"PlannerWithCostmap::make", "CodeBleu_score": 6.095726268776039}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tROS_INFO(\"PlannerWithCostmap::makePlanService called\");\n\n  // Set the start and goal frames to \"map\"\n  req.start.header.frame_id = req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  bool success = makePlan(req.start, req.goal, resp.plan);\n\n  // If a path is found, set the success status to true\n  resp.success = success;\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 58.539815380112024}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tif (req.start.header.frame_id != \"map\" || req.goal.header.frame_id != \"map\") {\n    ROS_ERROR(\"PlannerWithCostmap::makePlanService() called with non-map frame_id\");\n    return false;\n  }\n  geometry_msgs::PoseStamped start, goal;\n  start.header.frame_id = \"map\";\n  start.pose = req.start.pose;\n  goal.header.frame_id = \"map\";\n  goal.pose = req.goal.pose;\n  bool success = makePlan(start, goal, resp.plan.poses);\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.header.stamp = ros::Time::now();\n  resp.success = success;\n  return true;\n}", "CodeBleu_score": 54.49236730943483}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 54.93965293437767}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 55.797091470717234}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 55.797091470717234}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    return false;\n  }\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 47.28143722639827}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    return false;\n  }\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n  return true;\n}", "CodeBleu_score": 42.896701384277755}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t// Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  if (mx < 0 || mx >= costmap_->getSizeInCellsX() ||\n      my < 0 || my >= costmap_->getSizeInCellsY()) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 46.405484094545514}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // Create a Path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  // Extract the poses\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // Set the frame ID and timestamp and publish\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 90.1416185200641}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    for (unsigned int i = 0; i < path.size(); ++i) {\n        gui_path.poses[i] = path[i];\n    }\n\n    gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n    gui_path.header.stamp = ros::Time::now();\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 89.4134960770634}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 90.1647751094476}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG(\"Wrapping goal in an action message\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 71.02637254682554}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal in an action message\");\n\nMoveBaseActionGoal action_goal;\naction_goal.header.stamp = ros::Time::now();\naction_goal.goal.target_pose = *goal;\naction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 70.47356498454113}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_STREAM_NAMED(name_, \"Wrapping received goal in an action goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 72.04730125548099}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tROS_INFO(\"MoveSlowAndClear::distanceCheck: checking distance...\");\n  double sq_distance = getSqDistance();\n  if (sq_distance > sq_distance_limit_) {\n    ROS_INFO(\"MoveSlowAndClear::distanceCheck: distance limit reached.\");\n    if (remove_limit_thread_) {\n      ROS_INFO(\"MoveSlowAndClear::distanceCheck: removing limit thread...\");\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = nullptr;\n    }\n    ROS_INFO(\"MoveSlowAndClear::distanceCheck: starting remove limit thread...\");\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 57.687249517903574}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tdouble sq_distance = getSqDistance();\n  if (sq_distance > sq_limit_distance_) {\n    ROS_INFO(\"MoveSlowAndClear: Distance check passed, robot has moved far enough\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 78.61715332800455}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tdouble sq_distance = getSqDistance();\n  if (sq_distance > sq_distance_limit_) {\n    ROS_INFO(\"The robot has moved far enough from the speed limit. The speed limit will be removed.\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      remove_limit_thread_.reset();\n    }\n    remove_limit_thread_.reset(new boost::thread(&MoveSlowAndClear::removeLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 62.54086242836655}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Retrieve the current robot pose\n  // Get the global pose of the robot\n  // Get the global pose of the robot\n  tf::Stamped<tf::Pose> global_pose;\n  try {\n    listener_.waitForTransform(global_frame_, base_frame_, ros::Time(0), ros::Duration(10.0));\n    listener_.transformPose(global_frame_, *goal, global_pose);\n  }\n  catch (tf::TransformException& ex) {\n    ROS_ERROR(\"TF exception: %s\", ex.what());\n    return;\n  }\n\n  // Generate a plan\n  // Generate a plan from the current robot pose to the goal pose\n  // Generate a plan from the current robot pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(global_pose, goal->pose, path);\n\n  // Publish the plan\n  // Publish the plan to the move_base action server\n  // Publish the plan to the move_base action server\n  if (success) {\n    move_base_msgs::MoveBaseResult result;\n    result.path = path;\n    ac_.setSucceeded(result);\n  }\n  else {\n    move_base_msgs::MoveBaseResult result;\n    result.text = \"Could not find a plan\";\n    ac_.setAborted(result);\n  }\n}", "CodeBleu_score": 46.633475038111726}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tROS_INFO(\"NavfnWithCostmap::poseCallback\");\n  // Get the current robot pose\n  tf::Stamped<tf::Pose> robot_pose;\n  try {\n    tf_->transformPose(goal->header.frame_id, ros::Time(0), *goal, goal->header.frame_id, robot_pose);\n  } catch (tf::TransformException ex) {\n    ROS_ERROR(\"NavfnWithCostmap::poseCallback: %s\", ex.what());\n    return;\n  }\n\n  // Get the goal pose\n  tf::Stamped<tf::Pose> goal_pose;\n  try {\n    tf_->transformPose(goal->header.frame_id, ros::Time(0), *goal, goal->header.frame_id, goal_pose);\n  } catch (tf::TransformException ex) {\n    ROS_ERROR(\"NavfnWithCostmap::poseCallback: %s\", ex.what());\n    return;\n  }\n\n  // Get the current global plan\n  std::vector<geometry_msgs::PoseStamped> global_plan;\n\n  // Generate a new plan\n  bool success = makePlan(robot_pose, goal_pose, global_plan);\n\n  // Publish the new plan\n  if (success) {\n    global_plan_pub_.publish(global_plan);\n  }\n}", "CodeBleu_score": 43.54926656409508}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Get the robot pose\n  cmap_->getRobotPose(robot_pose_);\n\n  // Create a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> path;\n  if (makePlan(robot_pose_, *goal, path)) {\n    // If a path was found, publish it\n    path_pub_.publish(path);\n  }\n}", "CodeBleu_score": 53.93438445896054}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a service request\n    mavros_msgs::ParamSetRequest param_set_request;\n\n    // Assign parameter ID and value to the service request\n    param_set_request.param_id = param_set.param_id;\n    param_set_request.param_value = param_set.param_value;\n\n    // Call the service\n    param_set_client_.call(param_set_request);\n}", "CodeBleu_score": 52.6289277442711}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a parameter set service request\n    ros::ServiceClient param_set_client_ = nh_.serviceClient<mavros_msgs::ParamSet>(\"mavros/param/set\");\n    mavros_msgs::ParamSet param_set_srv;\n\n    // Assign parameter ID and value to the service request\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.integer_value = param_set.value;\n\n    // Send the request\n    if (param_set_client_.call(param_set_srv)) {\n        if (param_set_srv.response.success) {\n            ROS_INFO(\"Gimbal parameter set successfully\");\n        } else {\n            ROS_ERROR(\"Gimbal parameter set failed\");\n        }\n    } else {\n        ROS_ERROR(\"Gimbal parameter set failed\");\n    }\n}", "CodeBleu_score": 43.69162750997111}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Set the parameter ID\n    this->param_set_srv_.request.param_id = param_set.param_id;\n\n    // Set the parameter value\n    this->param_set_srv_.request.param_value = param_set.param_value;\n\n    // Call the param_set_client_\n    this->param_set_client_.call(this->param_set_srv_);\n}", "CodeBleu_score": 37.74227729795805}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t// Create a TCP socket\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    // Bind the socket to a specific port\n    struct sockaddr_in serv_addr;\n    bzero((char *) &serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(SERVER_PORT);\n    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"ERROR on binding\");\n        exit(1);\n    }\n\n    // Listen for incoming connections\n    listen(sockfd, 5);\n\n    // Wait for a connection from the ground station\n    socklen_t clilen;\n    struct sockaddr_in cli_addr;\n    clilen = sizeof(cli_addr);\n    int newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n    if (newsockfd < 0) {\n        perror(\"ERROR on accept\");\n        exit(1);\n    }\n\n    // Enter a loop to accept incoming connections, receive data, and process it\n    while (true) {\n\n        // Wait for a connection from the ground station\n        socklen_t clilen;\n        struct sockaddr_in cli_addr;\n        clilen = sizeof(cli_addr);\n        newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n        if (newsockfd < 0) {\n            perror(\"ERROR on accept\");\n            exit(1);\n        }\n\n        // Receive data\n        char buffer[256];\n        int n = recv(newsockfd, buffer, 256, 0);\n        if (n < 0) {\n            perror(\"ERROR reading from socket\");\n            exit(", "CodeBleu_score": 48.729887299738245}, {"code": "void CommunicationBridge::serverFun(){\n\t// wait for a connection\n    waitConnectionFromGroundStation();\n\n    // accept the connection\n    accept();\n\n    // loop until the connection is closed\n    while (true) {\n        // receive data\n        string recvData = recvConnection();\n\n        // if the data is empty, log an error and close the connection\n        if (recvData.length() <= 0) {\n            perror(\"recvConnection\");\n            close();\n            break;\n        }\n\n        // decode the received data\n        string decodedData = decodeMsg(recvData);\n\n        // publish the decoded data\n        publisher.publish(decodedData);\n    }\n}", "CodeBleu_score": 22.630966930642632}, {"code": "void CommunicationBridge::serverFun(){\n\t// Wait for a connection from the ground station\n  waitConnectionFromGroundStation();\n\n  // Enter a loop to accept incoming connections\n  while (true) {\n    // Accept an incoming connection\n    accept();\n\n    // Receive data\n    std::string recv_msg = recvMsg();\n\n    // Process the received message\n    processRecvMsg(recv_msg);\n  }\n}", "CodeBleu_score": 9.960052731694704}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (this->simulation_mode_) {\n        std::map<int, UAV*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != this->swarm_control_simulation_.end()) {\n            //this->uav_basic_->uavCmdPub(it->second->uavCmdPub, uav_cmd);\n            this->uav_basic_->uavCmdPub(it->second->uavCmdPub, uav_cmd);\n        }\n    } else {\n        //this->uav_basic_->uavCmdPub(this->uav_basic_->uavCmdPub, uav_cmd);\n        this->uav_basic_->uavCmdPub(this->uav_basic_->uavCmdPub, uav_cmd);\n    }\n}", "CodeBleu_score": 51.053760701561224}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (!this->simulation_mode_) {\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    } else {\n        std::map<int, std::shared_ptr<UAVBasic>>::iterator it;\n        it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != this->swarm_control_simulation_.end()) {\n            it->second->uavCmdPub(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 55.23553724990775}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t// If not in simulation mode, publish to a single UAV\n    if (!this->simulation_mode_) {\n        // Publish the command to the UAV\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    }\n    // If in simulation mode, publish to a UAV in the swarm\n    else {\n        // Find the UAV in the swarm\n        std::map<int, UAVBasic*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n        // If the UAV is in the swarm\n        if (it != this->swarm_control_simulation_.end()) {\n            // Publish the command to the UAV\n            it->second->uavCmdPub(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 54.86493952552276}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == 0) {\n        deleteMode(mode_selection.mode_to_delete);\n    }\n    else if (mode_selection.use_mode == 1) {\n        createMode(mode_selection.mode_to_create);\n    }\n    else if (mode_selection.use_mode == 2) {\n        system(\"reboot\");\n    }\n    else if (mode_selection.use_mode == 3) {\n        system(\"poweroff\");\n    }\n}", "CodeBleu_score": 52.48013750245123}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == REBOOTNX) {\n    system(\"reboot\");\n  } else if (mode_selection.use_mode == EXITNX) {\n    system(\"exit\");\n  } else if (mode_selection.use_mode == CREATE) {\n    createMode(mode_selection);\n  } else if (mode_selection.use_mode == DELETE) {\n    deleteMode(mode_selection);\n  }\n}", "CodeBleu_score": 61.94677012508988}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.use_mode == EXITNX) {\n        system(\"exit\");\n    } else if (mode_selection.use_mode == CREATEMODE) {\n        createMode(mode_selection.mode_name);\n    } else if (mode_selection.use_mode == DELETEMODE) {\n        deleteMode(mode_selection.mode_name);\n    } else {\n        std::cout << \"Invalid mode selection.\" << std::endl;\n    }\n}", "CodeBleu_score": 54.60019393286502}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// Check if the heartbeat has been received within the specified time\n    if (heartbeat_count == 0) {\n        // Increment the heartbeat count\n        heartbeat_count++;\n\n        // Print a warning message\n        ROS_WARN_STREAM(\"[CommunicationBridge]: No heartbeat received from the vehicle. Check connectivity.\");\n\n        // Check if the vehicle is a swarm\n        if (vehicle_type == \"swarm\") {\n            // Trigger the swarm control\n            triggerSwarmControl();\n        }\n        // Check if the vehicle is a UAV\n        else if (vehicle_type == \"uav\") {\n            // Trigger the UAV control\n            triggerUAV();\n        }\n        // Check if the vehicle is a UGV\n        else if (vehicle_type == \"ugv\") {\n            // Trigger the UGV control\n            triggerUGV();\n        }\n        // Check if the vehicle is a UGV\n        else if (vehicle_type == \"uav_ugv\") {\n            // Trigger the UGV control\n            triggerUGV();\n        }\n    }\n    // Check if the heartbeat has been received within the specified time\n    else if (heartbeat_count > 0) {\n        // Reset the heartbeat count\n        heartbeat_count = 0;\n    }\n}", "CodeBleu_score": 40.12251492900408}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\tif (heartbeat_count == heartbeat_count_old) {\n        heartbeat_count_old = heartbeat_count;\n        heartbeat_count_missed++;\n        if (heartbeat_count_missed > heartbeat_count_missed_threshold) {\n            ROS_ERROR(\"[CommunicationBridge]: Heartbeat missed %d times. Triggering emergency stop.\", heartbeat_count_missed);\n            if (vehicle_type == \"swarm\") {\n                triggerSwarmControl(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "CodeBleu_score": 29.376264357198355}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// Check if the heartbeat has been missed\n  if (heartbeat_count == heartbeat_count_prev) {\n    heartbeat_count++;\n    if (heartbeat_count > heartbeat_count_max) {\n      // If the heartbeat has been missed for a long time, trigger the appropriate action\n      ROS_ERROR(\"Heartbeat lost!\");\n      if (heartbeat_count > heartbeat_count_max) {\n        // If the heartbeat has been missed for a long time, trigger the appropriate action\n        ROS_ERROR(\"Heartbeat lost!\");\n        if (vehicle_type == \"swarm\") {\n          // If the vehicle is a swarm, trigger the swarm control node to stop the swarm\n          triggerSwarmControl();\n        }\n        else if (vehicle_type == \"UAV\") {\n          // If the vehicle is a UAV, trigger the UAV node to stop the UAV\n          triggerUAV();\n        }\n        else if (vehicle_type == \"UGV\") {\n          // If the vehicle is a UGV, trigger the UGV node to stop the UGV\n          triggerUGV();\n        }\n        else {\n          // If the vehicle type is not recognized, print an error message\n          ROS_ERROR(\"Vehicle type not recognized!\");\n        }\n        // Set the disconnect flag to true\n        disconnect_flag = true;\n      }\n    }\n  }\n  else {\n    // If the heartbeat has not been missed, reset the heartbeat count\n    heartbeat_count = 0;\n  }\n  // Save the heartbeat count for the next check\n  heartbeat_count_prev = heartbeat_count;\n}", "CodeBleu_score": 45.613591498447136}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// Get the drone ID\n    int id = msg->id;\n\n    // For each trajectory\n    for (int i = 0; i < msg->traj.size(); i++) {\n        // Initialize a Bspline struct\n        Bspline bspline;\n\n        // Set its attributes\n        bspline.id = id;\n        bspline.start_time = msg->traj[i].start_time.toSec();\n        bspline.duration = msg->traj[i].duration.toSec();\n        bspline.dim = msg->traj[i].dim;\n        bspline.order = msg->traj[i].order;\n        bspline.n_seg = msg->traj[i].n_seg;\n        bspline.n_pts = msg->traj[i].n_pts;\n\n        // Populate its knots\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots.push_back(msg->traj[i].knots[j]);\n        }\n\n        // Populate its position points\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n        }\n\n        // Populate its yaw points\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n        }\n\n        // Add the Bspline struct to the vector of Bsplines\n        bsplines.push_back(bspline);\n    }\n\n    // Encode the MultiBsplines data\n    this->communication->encodeMsg(bsplines);\n\n    // Send the encoded data via TCP using the communication module\n    this->communication->sendMsgByTcp();\n\n    // Clear the vector of Bsplines\n    bsplines.clear();", "CodeBleu_score": 73.05152821005967}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t//std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n\n    // Extract drone ID and trajectory data from message\n    std::vector<int> drone_ids;\n    std::vector<std::vector<double>> traj_data;\n    for (int i = 0; i < msg->traj.size(); i++) {\n        drone_ids.push_back(msg->traj[i].drone_id);\n        std::vector<double> temp_traj_data;\n        temp_traj_data.push_back(msg->traj[i].start_time.toSec());\n        temp_traj_data.push_back(msg->traj[i].duration);\n        temp_traj_data.push_back(msg->traj[i].knots.size());\n        temp_traj_data.push_back(msg->traj[i].yaw_pts.size());\n        temp_traj_data.push_back(msg->traj[i].pos_pts.size());\n        traj_data.push_back(temp_traj_data);\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            traj_data[i].push_back(msg->traj[i].knots[j]);\n        }\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            traj_data[i].push_back(msg->traj[i].yaw_pts[j]);\n        }\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            traj_data[i].push_back(msg->traj[i].pos_pts[j]);\n        }\n    }\n\n    // Initialize Bspline structs, set their attributes, and populate their knots, position points, and yaw points\n    std::vector<Bspline> bsplines;\n    for (int i = 0; i < msg->tra", "CodeBleu_score": 59.53155476378365}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// Extract drone ID\n    int id = msg->id;\n\n    // Initialize Bspline struct\n    Bspline bspline;\n\n    // Set Bspline attributes\n    bspline.id = id;\n    bspline.dim = msg->traj[0].pos_pts.size();\n    bspline.order = msg->traj[0].order;\n    bspline.n_seg = msg->traj[0].seg_num;\n    bspline.duration = msg->traj[0].duration;\n    bspline.start_time = msg->traj[0].start_time.toSec();\n    bspline.end_time = bspline.start_time + bspline.duration;\n\n    // Populate Bspline knots\n    for (int i = 0; i < msg->traj[0].knots.size(); i++) {\n        bspline.knots.push_back(msg->traj[0].knots[i]);\n    }\n\n    // Populate Bspline position points\n    for (int i = 0; i < msg->traj[0].pos_pts.size(); i++) {\n        bspline.pos_pts.push_back(msg->traj[0].pos_pts[i]);\n    }\n\n    // Populate Bspline yaw points\n    for (int i = 0; i < msg->traj[0].yaw_pts.size(); i++) {\n        bspline.yaw_pts.push_back(msg->traj[0].yaw_pts[i]);\n    }\n\n    // Encode Bspline data\n    std::string data = this->communication->encodeMsg(bspline);\n\n    // Send Bspline data via TCP\n    this->communication->sendMsgByTcp(data);\n}", "CodeBleu_score": 44.06626494106693}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Compress the point cloud\n  pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree_compression (0.005f);\n  octree_compression.setInputCloud(cloud);\n  std::vector<uint8_t> compressed_data;\n  octree_compression.encodePointCloud(compressed_data);\n\n  // Create a new PointCloud2 message with the compressed data\n  sensor_msgs::PointCloud2 compressed_str;\n  compressed_str.header = msg.header;\n  compressed_str.height = 1;\n  compressed_str.width = compressed_data.size();\n  compressed_str.fields = msg.fields;\n  compressed_str.is_bigendian = msg.is_bigendian;\n  compressed_str.point_step = compressed_data.size();\n  compressed_str.row_step = compressed_data.size();\n  compressed_str.is_dense = msg.is_dense;\n  compressed_str.data.resize(compressed_data.size());\n  std::memcpy(&compressed_str.data[0], &compressed_data[0], compressed_data.size());\n\n  // Release dynamically allocated memory\n  cloud.reset();\n\n  // Return the compressed message\n  return compressed_str;\n}", "CodeBleu_score": 43.50171257317378}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGB>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Create a new octree compression object\n  pcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB, 8> octree_compression (resolution_);\n\n  // Compress the point cloud\n  octree_compression.setInputCloud(cloud);\n  octree_compression.addPointsFromInputCloud();\n\n  // Get the compressed data\n  std::vector<uint8_t> compressed_data;\n  compressed_data = octree_compression.getCompressedVoxelCenters();\n\n  // Create a new PointCloud2 message with the compressed data\n  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = 1;\n  compressed_msg.width = compressed_data.size();\n  compressed_msg.fields = msg.fields;\n  compressed_msg.is_bigendian = msg.is_bigendian;\n  compressed_msg.point_step = compressed_data.size() * sizeof(uint8_t);\n  compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n  compressed_msg.is_dense = msg.is_dense;\n  compressed_msg.data.resize(compressed_msg.row_step);\n  std::memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_msg.row_step);\n\n  // Release dynamically allocated memory\n  cloud.reset();\n  cloud = nullptr;\n\n  return compressed_msg;\n}", "CodeBleu_score": 43.789174974290695}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Compress the point cloud\n  pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree_compression (0.001);\n  octree_compression.setInputCloud (cloud);\n  octree_compression.addPointsFromInputCloud ();\n  std::vector<uint8_t> compressed_data;\n  octree_compression.encodePointCloud (compressed_data);\n\n  // Create a new PointCloud2 message with the compressed data\n  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = 1;\n  compressed_msg.width = compressed_data.size();\n  compressed_msg.fields = msg.fields;\n  compressed_msg.is_bigendian = msg.is_bigendian;\n  compressed_msg.point_step = compressed_msg.width * sizeof (uint8_t);\n  compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n  compressed_msg.is_dense = msg.is_dense;\n  compressed_msg.data.resize (compressed_msg.row_step);\n  std::memcpy (&compressed_msg.data[0], compressed_data.str (), compressed_msg.row_step);\n\n  // Release dynamically allocated memory\n  cloud.reset();\n  compressed_data.clear();\n\n  // Return the compressed message\n  return compressed_msg;\n}", "CodeBleu_score": 44.584143847453284}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t// Iterate through the list of UAV states and replace the matching UAV state with the new uav_state data based on the UAV ID.\n    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].UAV_ID == uav_state.UAV_ID) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 80.06566784770396}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].UAV_id == uav_state.UAV_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 79.97201832560782}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t// Iterate through all the UAV states\n    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        // Check if the UAV ID matches\n        if (this->multi_uav_state_.uav_state_all[i].UAV_ID == uav_state.UAV_ID) {\n            // Replace the UAV state with the new UAV state\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n\n}", "CodeBleu_score": 80.06566784770396}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize the MultiUGVState message\n    m_multi_ugv_state.header.stamp = ros::Time::now();\n    m_multi_ugv_state.header.frame_id = \"map\";\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (std::vector<struct UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        it->id = m_multi_ugv_state.ugv_count;\n        it->battery = m_multi_ugv_state.battery;\n        it->position = m_multi_ugv_state.position;\n        it->velocity = m_multi_ugv_state.velocity;\n        it->attitude = m_multi_ugv_state.attitude;\n\n        // Increment the UGV count and add each UGVState to the MultiUGVState message\n        m_multi_ugv_state.ugv_count++;\n        m_multi_ugv_state.ugv_state_all.push_back(*it);\n\n    }\n\n    // Publish the assembled MultiUGVState message\n    this->all_ugv_state_pub_.publish(m_multi_ugv_state);\n\n}", "CodeBleu_score": 30.61687731015005}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize a MultiUGVState message\n    m_multi_ugv_state.header.stamp = ros::Time::now();\n    m_multi_ugv_state.header.frame_id = \"swarm_control\";\n    m_multi_ugv_state.ugv_count = 0;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (std::vector<struct UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        m_multi_ugv_state.ugv_state[m_multi_ugv_state.ugv_count].id = it->id;\n        m_multi_ugv_state.ugv_state[m_multi_ugv_state.ugv_count].battery = it->battery;\n        m_multi_ugv_state.ugv_state[m_multi_ugv_state.ugv_count].position.x = it->position.x;\n        m_multi_ugv_state.ugv_state[m_multi_ugv_state.ugv_count].position.y = it->position.y;\n        m_multi_ugv_state.ugv_state[m_multi_ugv_state.ugv_count].position.z = it->position.z;\n        m_multi_ugv_state.ugv_state[m_multi_ugv_state.ugv_count].velocity.x = it->velocity.x;\n        m_multi_ugv_state.ugv_state[m_multi_ugv_state.ugv_count].velocity.y = it->velocity.y;\n        m_multi_ugv_state.ugv_state[m_multi_ugv_state.ugv_count].velocity.z = it->velocity.z;\n        m_multi_ugv_state.ugv_state[m", "CodeBleu_score": 28.892559277605358}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize MultiUGVState message\n    mrs_msgs::MultiUGVState m_multi_ugv_state_msg;\n    m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n    m_multi_ugv_state_msg.header.frame_id = \"map\";\n\n    // Iterate through all UGVs\n    for (std::vector<struct UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n        // Initialize UGVState message\n        mrs_msgs::UGVState ugv_state_msg;\n\n        // Populate UGVState message\n        ugv_state_msg.id = it->id;\n        ugv_state_msg.battery = it->battery;\n        ugv_state_msg.position.x = it->position.x;\n        ugv_state_msg.position.y = it->position.y;\n        ugv_state_msg.position.z = it->position.z;\n        ugv_state_msg.velocity.x = it->velocity.x;\n        ugv_state_msg.velocity.y = it->velocity.y;\n        ugv_state_msg.velocity.z = it->velocity.z;\n        ugv_state_msg.attitude.w = it->attitude.w;\n        ugv_state_msg.attitude.x = it->attitude.x;\n        ugv_state_msg.attitude.y = it->attitude.y;\n        ugv_state_msg.attitude.z = it->attitude.z;\n\n        // Increment UGV count\n        m_multi_ugv_state_msg.ugv_count++;\n\n        // Add UGVState message to MultiUGVState message\n        m_multi_ugv_state_msg.ugv_state.push_back(ugv_state_msg);\n    }\n\n    // Publish Multi", "CodeBleu_score": 47.86172290769704}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tif (moving_objs_ == NULL) {\n    return;\n  }\n\n  const int num_points = cps_.rows;\n  const int num_objs = moving_objs_->getObjNums();\n  const double time_interval = (ros::Time::now() - start_time_).toSec();\n  const double time_interval_inv = 1.0 / time_interval;\n  const double time_interval_inv_2 = time_interval_inv * time_interval_inv;\n  const double time_interval_inv_3 = time_interval_inv_2 * time_interval_inv;\n  const double time_interval_inv_4 = time_interval_inv_2 * time_interval_inv_2;\n  const double time_interval_inv_5 = time_interval_inv_2 * time_interval_inv_3;\n  const double time_interval_inv_6 = time_interval_inv_3 * time_interval_inv_3;\n\n  // Compute the predicted positions of moving objects\n  Eigen::MatrixXd obj_pos(3, num_objs);\n  Eigen::MatrixXd obj_vel(3, num_objs);\n  Eigen::MatrixXd obj_acc(3, num_objs);\n  Eigen::MatrixXd obj_jrk(3, num_objs);\n  Eigen::MatrixXd obj_snp(3, num_objs);\n  Eigen::MatrixXd obj_crk(3, num_objs);\n  for (int i = 0; i < num_objs; i++) {\n    moving_objs_->evaluateConstAcc(time_interval, obj_pos.col(i), obj_vel.col(i), obj_acc.col(i), i);\n    moving_objs_->evaluateConstJrk(time_interval, obj_jrk.col(i), i);\n    moving_objs_->evaluateConstSnp(time_interval, obj_snp.col(i), i);\n    moving_objs_->evaluateConstCrk(time_interval, obj_crk.col(i), i", "CodeBleu_score": 35.17269106468738}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// initialize cost and gradient\n  cost = 0.0;\n  gradient.setZero();\n\n  // get the number of control points\n  int n_cp = q.cols();\n\n  // iterate through control points\n  for (int i = 0; i < n_cp; i++) {\n    // get the predicted position of moving objects at time t = i\n    Eigen::MatrixXd obj_prid;\n    moving_objs_->evaluateConstVel(q.col(i), obj_prid);\n\n    // get the numbers of moving objects\n    std::vector<int> obj_nums = moving_objs_->getObjNums();\n\n    // iterate through moving objects\n    for (int j = 0; j < obj_nums.size(); j++) {\n      // get the clearance of the object\n      double obj_clearance = moving_objs_->getObjClearance(obj_nums[j]);\n\n      // get the distance between the control point and the predicted position of the object\n      double dist = (cps_.points.col(i) - obj_prid.col(j)).norm();\n\n      // if the distance is less than the clearance, update the cost and gradient\n      if (dist < obj_clearance) {\n        cost += pow(obj_clearance - dist, 2);\n        gradient.col(i) += 2 * (obj_clearance - dist) * (cps_.points.col(i) - obj_prid.col(j)).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 45.98327320755076}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// Initialization\n  cost = 0.0;\n  gradient.setZero();\n\n  // Iterate through control points\n  for (int i = 0; i < q.cols(); i++) {\n    // Compute the predicted positions of moving objects\n    Eigen::MatrixXd obj_prid;\n    moving_objs_->evaluateConstVel(q.col(i), obj_prid);\n\n    // Evaluate the distance between control points and these objects\n    Eigen::VectorXd dist(moving_objs_->getObjNums());\n    for (int j = 0; j < moving_objs_->getObjNums(); j++) {\n      dist(j) = (cps_.points.col(i) - obj_prid.col(j)).norm();\n    }\n\n    // Update the cost and gradient based on the distance error\n    if (dist.minCoeff() < cfg_->moving_obj_clearance) {\n      cost += pow(dist.minCoeff() - cfg_->moving_obj_clearance, 2);\n      gradient.col(i) += 2.0 * (dist.minCoeff() - cfg_->moving_obj_clearance) * (cps_.points.col(i) - obj_prid.col(dist.minCoeffIndex())).normalized();\n    }\n  }\n}", "CodeBleu_score": 41.02663350005697}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\n  gradient.setZero();\n  for (int i = 0; i < q.cols(); i++) {\n    Eigen::Vector3d x(q(0, i), q(1, i), q(2, i));\n    Eigen::Vector3d v(q(3, i), q(4, i), q(5, i));\n    Eigen::Vector3d x_ref(ref_pts_[i](0), ref_pts_[i](1), ref_pts_[i](2));\n    Eigen::Vector3d v_ref(ref_pts_[i](3), ref_pts_[i](4), ref_pts_[i](5));\n    Eigen::Vector3d x_diff = x - x_ref;\n    Eigen::Vector3d v_diff = v - v_ref;\n    Eigen::Vector3d x_cross_v = x.cross(v);\n    double x_dot_v = x.dot(v);\n    double x_cross_v_norm = x_cross_v.norm();\n    double x_dot_v_norm = x_dot_v / (a2 + b2 * x_cross_v_norm);\n    cost += a2 * x_diff.squaredNorm() + b2 * x_dot_v_norm * x_dot_v_norm;\n    gradient(0, i) = 2.0 * a2 * x_diff(0) + b2 * x_dot_v_norm * (v(0) - x(0));\n    gradient(1, i) = 2.0 * a2 * x_diff(1) + b2 * x_dot_v_norm * (v(1) - x(1));\n    gradient(2, i) = 2.0 * a2 * x_diff(2) + b2 * x_dot_v_norm * (v(2) - x(2));\n    gradient(3, i) = b2 * x_dot_v_norm * (v(0) + x(0)) + b2 * x_cross_v_norm * (v_ref(1) - v", "CodeBleu_score": 40.87444505967856}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\n    gradient.setZero();\n    double a2 = 1.0, b2 = 1.0;\n    for (int i = 2; i < q.cols(); i++) {\n        Eigen::Vector3d x = q.col(i) - ref_pts_[i - 2];\n        Eigen::Vector3d v = (ref_pts_[i - 1] - ref_pts_[i - 2]).normalized();\n        double xdotv = x.dot(v);\n        double xcrossv = x.cross(v).norm();\n        cost += a2 * pow(xdotv, 2) + b2 * pow(xcrossv, 2);\n        gradient.col(i) = 2 * a2 * xdotv * v + 2 * b2 * xcrossv * x.cross(v).normalized();\n    }\n}", "CodeBleu_score": 39.872992172871314}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n    gradient.setZero();\n    for (int i = 1; i < q.cols() - 1; i++) {\n        Eigen::Vector3d v = (q.col(i) - q.col(i - 1)).normalized();\n        Eigen::Vector3d x = (ref_pts_[i] - ref_pts_[i - 1]).normalized();\n        double c = x.dot(v);\n        double s = x.cross(v).norm();\n        cost += a2_ * (1.0 - c * c) + b2_ * s * s;\n        gradient.col(i) += 2.0 * a2_ * (x.cross(v) * (x.dot(v) - 1.0) + x.cross(v).norm() * x.cross(v).norm() * x.cross(v));\n        gradient.col(i - 1) += 2.0 * a2_ * (-x.cross(v) * (x.dot(v) - 1.0) + x.cross(v).norm() * x.cross(v).norm() * x.cross(v));\n        gradient.col(i) += 2.0 * b2_ * x.cross(v) * x.cross(v).norm();\n        gradient.col(i - 1) += 2.0 * b2_ * x.cross(v) * x.cross(v).norm();\n    }\n}", "CodeBleu_score": 42.28919200523949}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative().getDerivative();\n  Eigen::VectorXd knot = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n  double jerk = 0;\n\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += ctrl_pts(j, i) * (knot(i + 1) - knot(i));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 66.4154040869523}, {"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative().getDerivative();\n  Eigen::VectorXd knot_times = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  double jerk = 0.0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += ctrl_pts(j, i) * (knot_times(i + 1) - knot_times(i));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 68.91753432590092}, {"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk_traj = getDerivative().getDerivative();\n    Eigen::VectorXd knot_times = jerk_traj.getKnot();\n    Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n    double jerk = 0;\n    for (int i = 0; i < ctrl_pts.cols(); i++) {\n        for (int j = 0; j < ctrl_pts.rows(); j++) {\n            jerk += pow(ctrl_pts(j, i), 2) * (knot_times(i + 1) - knot_times(i));\n        }\n    }\n\n    return jerk;\n}", "CodeBleu_score": 67.37126156121231}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos_in_camera;\n    pos_in_camera(0) = (u - cx_) * depth / fx_;\n    pos_in_camera(1) = (v - cy_) * depth / fy_;\n    pos_in_camera(2) = depth;\n    pos_in_camera(3) = 1;\n\n    return pos_in_camera;\n}", "CodeBleu_score": 84.77994445559092}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos_in_camera;\n  pos_in_camera << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n  return pos_in_camera;\n}", "CodeBleu_score": 53.042904280922144}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos_cam;\n  pos_cam << (u - cx_) * depth / fx_,\n             (v - cy_) * depth / fy_,\n             depth,\n             1.0;\n  return pos_cam;\n}", "CodeBleu_score": 52.76628300461624}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        int drone_id = std::stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (std::exception& e) {\n        ROS_ERROR_STREAM(\"Could not extract drone ID from odometry message: \" << e.what());\n    }\n}", "CodeBleu_score": 56.329852050041694}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n    std::string droneID = std::stoi(odom.child_frame_id.substr(1, 1));\n    rcvDroneOdomCallbackBase(odom, droneID);\n  } catch (const std::exception& e) {\n    ROS_ERROR_STREAM(\"Could not extract drone ID from odometry message. Exception: \" << e.what());\n  }\n}", "CodeBleu_score": 50.60540733848119}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n    rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(1)));\n  } catch (const std::exception& e) {\n    ROS_ERROR_STREAM(\"Failed to parse drone ID from child_frame_id: \" << e.what());\n  }\n}", "CodeBleu_score": 43.78628065197921}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Get the true pose of the drone in the camera frame\n  Eigen::Vector3f drone_pose_camera;\n  Eigen::Matrix3f drone_pose_camera_cov;\n  bool found = drone_pose_estimator_->estimatePose(drone_id, drone_pose_camera, drone_pose_camera_cov);\n\n  // Check for drone presence\n  if (found) {\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3f drone_pose_error = drone_pose_camera - true_pixel;\n\n    // Update the debug result\n    debug_result_.drone_pose_error[drone_id] = drone_pose_error;\n    debug_result_.drone_pose_error_valid[drone_id] = true;\n\n    // Publish the pose error\n    drone_pose_err_pub_[drone_id].publish(pose_error_to_msg(drone_id, drone_pose_error, drone_pose_camera_cov));\n  }\n  else {\n    // Update the debug result\n    debug_result_.drone_pose_error[drone_id] = Eigen::Vector3f::Zero();\n    debug_result_.drone_pose_error_valid[drone_id] = false;\n  }\n}", "CodeBleu_score": 45.110570071874236}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// 1. Compute the true pose of the drone in the camera frame.\n    Eigen::Vector3f drone_pose_cam_frame;\n    compute_true_pose_cam_frame(drone_id, drone_pose_cam_frame);\n\n    // 2. Check for the drone's presence.\n    bool found = check_presence(drone_pose_cam_frame);\n\n    // 3. Compute the pose error between the camera and world coordinates.\n    Eigen::Vector3f drone_pose_err;\n    compute_pose_error(drone_pose_cam_frame, drone_pose_err);\n\n    // 4. Update the debug result.\n    update_debug_result(drone_id, true_pixel, drone_pose_err, found);\n\n    // 5. Publish the pose error.\n    if (found) {\n        pose_error_msg_.drone_id = drone_id;\n        pose_error_msg_.pose_err = drone_pose_err;\n        pose_error_msg_.found = true;\n        pose_error_pub_.publish(pose_error_msg_);\n    }\n}", "CodeBleu_score": 37.23798220067843}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// check if the drone is in the frame\n  if (drone_id == 0) {\n    // check if the drone is in the frame\n    if (is_in_frame(true_pixel, drone_id)) {\n      // compute the true pose of the drone in the camera frame\n      Eigen::Vector3d true_pose_camera;\n      compute_true_pose_camera(true_pixel, drone_id, true_pose_camera);\n      // check if the drone is in the frame\n      if (is_in_frame(true_pose_camera, drone_id)) {\n        // compute the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error;\n        compute_pose_error(true_pose_camera, drone_id, pose_error);\n        // update the debug result to indicate success\n        debug_result_.detection_result = true;\n        // publish the pose error\n        countPixel++;\n        drone_pose_err_pub_[drone_id].publish(pose_error);\n      } else {\n        // update the debug result to indicate failure\n        debug_result_.detection_result = false;\n      }\n    } else {\n      // update the debug result to indicate failure\n      debug_result_.detection_result = false;\n    }\n  } else {\n    // check if the drone is in the frame\n    if (is_in_frame(true_pixel, drone_id)) {\n      // compute the true pose of the drone in the camera frame\n      Eigen::Vector3d true_pose_camera;\n      compute_true_pose_camera(true_pixel, drone_id, true_pose_camera);\n      // check if the drone is in the frame\n      if (is_in_frame(true_pose_camera, drone_id)) {\n        // compute the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error;\n        compute_pose_error(true_pose_camera, drone_id, pose_error);\n        // update the debug result to indicate success\n        debug_result_.detection_", "CodeBleu_score": 41.339526987366014}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 88.14720026434847}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != NULL) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 92.86881305072592}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getCameFrom() != nullptr) {\n        current = current->getCameFrom();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 77.3329999488077}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// convert start and end points to grid indices\n    if (!ConvertToIndex(start_pt, start_idx)) {\n        return false;\n    }\n    if (!ConvertToIndex(end_pt, end_idx)) {\n        return false;\n    }\n\n    // adjust start point if it is inside an obstacle\n    if (IsInObstacle(start_idx)) {\n        // if start point is in an obstacle, adjust it by moving it away from the end point\n        Vector3d start_pt_adjusted = start_pt;\n        Vector3d dir = (end_pt - start_pt).normalized();\n        while (IsInObstacle(start_pt_adjusted)) {\n            start_pt_adjusted = start_pt + 1.0 * dir;\n        }\n        if (!ConvertToIndex(start_pt_adjusted, start_idx)) {\n            return false;\n        }\n    }\n\n    // adjust end point if it is inside an obstacle\n    if (IsInObstacle(end_idx)) {\n        // if end point is in an obstacle, adjust it by moving it away from the start point\n        Vector3d end_pt_adjusted = end_pt;\n        Vector3d dir = (start_pt - end_pt).normalized();\n        while (IsInObstacle(end_pt_adjusted)) {\n            end_pt_adjusted = end_pt + 1.0 * dir;\n        }\n        if (!ConvertToIndex(end_pt_adjusted, end_idx)) {\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 55.23223029786174}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert the start and end points to grid indices.\n    start_idx = Coord2Index(start_pt);\n    end_idx = Coord2Index(end_pt);\n\n    // If either start or end point is not inside the grid, return false.\n    if (start_idx.x() < 0 || start_idx.y() < 0 || start_idx.z() < 0 || end_idx.x() < 0 || end_idx.y() < 0 || end_idx.z() < 0)\n        return false;\n\n    // If either start or end point is inside an obstacle, adjust the point.\n    if (m_occupancy_map[start_idx.x()][start_idx.y()][start_idx.z()] || m_occupancy_map[end_idx.x()][end_idx.y()][end_idx.z()]) {\n\n        // Adjust the start point.\n        Vector3d adjusted_start_pt = start_pt;\n        while (m_occupancy_map[start_idx.x()][start_idx.y()][start_idx.z()]) {\n            adjusted_start_pt += (end_pt - start_pt) * 0.01;\n            start_idx = Coord2Index(adjusted_start_pt);\n        }\n\n        // Adjust the end point.\n        Vector3d adjusted_end_pt = end_pt;\n        while (m_occupancy_map[end_idx.x()][end_idx.y()][end_idx.z()]) {\n            adjusted_end_pt -= (end_pt - start_pt) * 0.01;\n            end_idx = Coord2Index(adjusted_end_pt);\n        }\n\n        // If the adjusted start or end point is not inside the grid, return false.\n        if (start_idx.x() < 0 || start_idx.y() < 0 || start_idx.z() < 0 || end_idx.x() < 0 || end_idx.y() < 0 || end_idx.z() < 0)", "CodeBleu_score": 42.17996897202357}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tif (start_pt == end_pt) {\n\t\treturn false;\n\t}\n\n\tVector3d dir = (end_pt - start_pt).normalized();\n\tVector3d start_pt_adjusted = start_pt;\n\tVector3d end_pt_adjusted = end_pt;\n\n\t// Convert start point to grid index.\n\tstart_idx = Coord2Index(start_pt_adjusted);\n\tif (start_idx == Vector3i(-1, -1, -1)) {\n\t\treturn false;\n\t}\n\n\t// Convert end point to grid index.\n\tend_idx = Coord2Index(end_pt_adjusted);\n\tif (end_idx == Vector3i(-1, -1, -1)) {\n\t\treturn false;\n\t}\n\n\t// Adjust start point if it is inside an obstacle.\n\tif (GetOccupancy(start_idx) > 0) {\n\t\tint i = 0;\n\t\twhile (GetOccupancy(start_idx) > 0) {\n\t\t\tstart_pt_adjusted += dir;\n\t\t\tstart_idx = Coord2Index(start_pt_adjusted);\n\t\t\tif (start_idx == Vector3i(-1, -1, -1)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (i > 1000) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// Adjust end point if it is inside an obstacle.\n\tif (GetOccupancy(end_idx) > 0) {\n\t\tint i = 0;\n\t\twhile (GetOccupancy(end_idx) > 0) {\n\t\t\tend_pt_adjusted -= dir;\n\t\t\tend_idx = Coord2Index(end_pt_adjusted);\n\t\t\tif (end_idx == Vector3i(-1, -1, -1)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (i > 1", "CodeBleu_score": 41.09624863258294}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tEigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.242859760710868}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// TODO: Implement this function\n  int min_id[3], max_id[3];\n  getGridIndexFromPosition(min_pos, min_id);\n  getGridIndexFromPosition(max_pos, max_id);\n\n  for (int i = min_id[0]; i <= max_id[0]; i++) {\n    for (int j = min_id[1]; j <= max_id[1]; j++) {\n      for (int k = min_id[2]; k <= max_id[2]; k++) {\n        int id = getIndex(i, j, k);\n        occupancy_buffer_inflate_[id] = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 38.70369340154252}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tEigen::Vector3i min_id, max_id;\n    getGridIndexFromPosition(min_pos, min_id);\n    getGridIndexFromPosition(max_pos, max_id);\n\n    resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 28.092445190629945}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d max_translation(0, 0, 0);\n  Eigen::Vector3d min_translation(0, 0, 0);\n  Eigen::Vector3d adjusted_pt(0, 0, 0);\n\n  // Compute the maximum translation along each axis\n  for (int i = 0; i < 3; i++) {\n    if (diff(i) > 0) {\n      max_translation(i) = (this->map_size_ - this->map_origin_(i)) / diff(i);\n    } else {\n      max_translation(i) = (this->map_origin_ - this->map_size_) / diff(i);\n    }\n  }\n\n  // Compute the minimum translation along each axis\n  for (int i = 0; i < 3; i++) {\n    if (diff(i) > 0) {\n      min_translation(i) = (this->map_origin_ - this->map_size_) / diff(i);\n    } else {\n      min_translation(i) = (this->map_size_ - this->map_origin_(i)) / diff(i);\n    }\n  }\n\n  // Find the minimum positive translation factor along each axis\n  for (int i = 0; i < 3; i++) {\n    if (max_translation(i) < 0) {\n      adjusted_pt(i) = camera_pt(i) + min_translation(i) * diff(i);\n    } else if (min_translation(i) > 0) {\n      adjusted_pt(i) = camera_pt(i) + max_translation(i) * diff(i);\n    } else {\n      adjusted_pt(i) = pt(i);\n    }\n  }\n\n  return adjusted_pt;\n}", "CodeBleu_score": 38.171673461455526}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_translation = Eigen::Vector3d(0.5 * map_size_x_, 0.5 * map_size_y_, 0.5 * map_size_z_);\n    Eigen::Vector3d min_translation = Eigen::Vector3d(-0.5 * map_size_x_, -0.5 * map_size_y_, -0.5 * map_size_z_);\n    Eigen::Vector3d translation_coefficients = Eigen::Vector3d(0.0, 0.0, 0.0);\n    Eigen::Vector3d adjusted_point = Eigen::Vector3d(0.0, 0.0, 0.0);\n\n    for (int i = 0; i < 3; i++) {\n        if (diff(i) > 0.0) {\n            translation_coefficients(i) = (map_size_[i] - camera_pt(i)) / diff(i);\n        } else if (diff(i) < 0.0) {\n            translation_coefficients(i) = (-camera_pt(i)) / diff(i);\n        } else {\n            translation_coefficients(i) = 0.0;\n        }\n\n        translation_coefficients(i) = std::min(std::max(translation_coefficients(i), min_translation(i)), max_translation(i));\n    }\n\n    adjusted_point = camera_pt + translation_coefficients.cwiseProduct(diff);\n\n    return adjusted_point;\n}", "CodeBleu_score": 43.81321475544809}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff = pt - camera_pt;\n\n  Eigen::Vector3d min_trans = Eigen::Vector3d::Zero();\n  Eigen::Vector3d max_trans = Eigen::Vector3d::Zero();\n\n  for (int i = 0; i < 3; i++) {\n    if (diff(i) > 0) {\n      max_trans(i) = (max_pt(i) - pt(i)) / diff(i);\n      min_trans(i) = (min_pt(i) - pt(i)) / diff(i);\n    } else {\n      max_trans(i) = (min_pt(i) - pt(i)) / diff(i);\n      min_trans(i) = (max_pt(i) - pt(i)) / diff(i);\n    }\n  }\n\n  double min_trans_mag = min_trans.norm();\n  double max_trans_mag = max_trans.norm();\n\n  double min_trans_mag_scaled = min_trans_mag;\n  double max_trans_mag_scaled = max_trans_mag;\n\n  if (min_trans_mag < 0) {\n    min_trans_mag_scaled = 0;\n  }\n  if (max_trans_mag > 1) {\n    max_trans_mag_scaled = 1;\n  }\n\n  Eigen::Vector3d adjusted_pt = pt + diff * (min_trans_mag_scaled + max_trans_mag_scaled) / 2;\n\n  return adjusted_pt;\n}", "CodeBleu_score": 43.096554093328116}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if an update is needed.\n  if (!needUpdate()) {\n    return;\n  }\n\n  // Project depth image into points.\n  std::vector<Eigen::Vector3d> points;\n  if (!projectDepthImage(points)) {\n    ROS_ERROR(\"Could not project depth image.\");\n    return;\n  }\n\n  // Process points.\n  if (!raycastProcess(points)) {\n    ROS_ERROR(\"Could not process points.\");\n    return;\n  }\n\n  // Clear and inflate local map.\n  if (!clearAndInflateLocalMap()) {\n    ROS_ERROR(\"Could not clear and inflate local map.\");\n    return;\n  }\n}", "CodeBleu_score": 33.82979114479914}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n  // Check if an update is needed.\n  if (md_.last_occ_update_time_ - md_.last_update_time_ < md_.update_interval_) {\n    return;\n  }\n  // Check if odometry is available.\n  if (!md_.odom_available_) {\n    ROS_ERROR(\"No odometry available.\");\n    return;\n  }\n  // Check if depth data is available.\n  if (!md_.depth_available_) {\n    ROS_ERROR(\"No depth data available.\");\n    return;\n  }\n  // Project depth image into points.\n  std::vector<cv::Point3f> points;\n  projectDepthImage(points);\n  // Process points with raycasting.\n  if (points.size() > 0) {\n    ros::Time start = ros::Time::now();\n    raycastProcess(points);\n    ROS_DEBUG(\"Raycasting took %f seconds.\", (ros::Time::now() - start).toSec());\n  }\n  // Clear and inflate local map.\n  clearAndInflateLocalMap();\n}", "CodeBleu_score": 49.12657720946868}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if update is needed.\n  if (md_.last_occ_update_time_ - md_.last_update_time_ < md_.update_period_) {\n    return;\n  }\n\n  // Check if depth image is available.\n  if (md_.depth_image_msg_.data.empty()) {\n    ROS_ERROR(\"Depth image not available.\");\n    md_.depth_image_timeout_ = true;\n    return;\n  }\n\n  // Check if odometry is available.\n  if (md_.odom_msg_.data.empty()) {\n    ROS_ERROR(\"Odometry not available.\");\n    md_.odom_timeout_ = true;\n    return;\n  }\n\n  // Check if odometry is valid.\n  if (md_.odom_msg_.data.empty()) {\n    ROS_ERROR(\"Odometry not available.\");\n    md_.odom_timeout_ = true;\n    return;\n  }\n\n  // Project depth image into points.\n  projectDepthImage();\n\n  // Process points.\n  raycastProcess();\n\n  // Clear and inflate local map.\n  clearAndInflateLocalMap();\n\n  // Reset timeout flags.\n  md_.depth_image_timeout_ = false;\n  md_.odom_timeout_ = false;\n}", "CodeBleu_score": 56.571342155752205}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tMat3b img;\n    vector<Ellipse> gt_ellipses, dt_ellipses;\n    float fmeasure_accum = 0.f;\n    unsigned num_images = image_fns.size();\n\n    for (unsigned i = 0; i < num_images; ++i)\n    {\n        imread(image_fns[i], img);\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        fmeasure_accum += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n    }\n\n    return fmeasure_accum / num_images;\n}", "CodeBleu_score": 58.92142053033893}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tint n_images = image_fns.size();\n\n    float f_measure = 0.f;\n\n    for (int i = 0; i < n_images; ++i)\n    {\n        Mat3b img = imread(image_fns[i]);\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        f_measure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n    }\n\n    f_measure /= float(n_images);\n\n    return f_measure;\n}", "CodeBleu_score": 62.46864786162203}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat fmeasure = 0.f;\n\n    unsigned sz_imgs = image_fns.size();\n    unsigned sz_imgs_min = unsigned(min(1000, int(sz_imgs)));\n\n    vector<Mat3b> imgs(sz_imgs_min);\n    vector<vector<Ellipse> > vec_ell_gt(sz_imgs_min);\n    vector<vector<Ellipse> > vec_ell_dt(sz_imgs_min);\n\n    for (unsigned i = 0; i<sz_imgs_min; ++i)\n    {\n        imgs[i] = imread(image_fns[i]);\n        _load_ellipse_GT(gt_fns[i], vec_ell_gt[i], gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], vec_ell_dt[i], gt_angle_radians);\n    }\n\n    for (unsigned i = 0; i<sz_imgs_min; ++i)\n    {\n        fmeasure += _ellipse_evaluate_one(vec_ell_gt[i], vec_ell_dt[i], imgs[i]);\n    }\n\n    return fmeasure / float(sz_imgs_min);\n}", "CodeBleu_score": 48.22842109901215}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b;\n    if (foci) {\n        a = angle_diff_signed(atan2(y, x), atan2(y - foci[0], x - foci[1]));\n        b = angle_diff_signed(atan2(y, x), atan2(y - foci[1], x - foci[0]));\n        if (a < b) return a;\n        else return b;\n    }\n    else return atan2(y, x);\n}", "CodeBleu_score": 41.99758803474526}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat angle = atan2(y, x);\n    if (foci != NULL) {\n        float angle_to_focus1 = angle_diff_signed(angle, atan2(foci[1].y - y, foci[1].x - x));\n        float angle_to_focus2 = angle_diff_signed(angle, atan2(foci[0].y - y, foci[0].x - x));\n        angle = angle_diff_signed(angle_to_focus1, angle_to_focus2);\n    }\n    return angle;\n}", "CodeBleu_score": 38.444642215025425}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat angle;\n    float angle_a, angle_b;\n    float angle_diff;\n    float angle_diff_abs;\n    float angle_diff_signed;\n\n    if (foci) {\n        angle_a = atan2(y - foci[0], x - foci[1]);\n        angle_b = atan2(y - foci[0], x - foci[3]);\n        angle_diff = angle_diff_signed(angle_a, angle_b);\n        angle_diff_abs = fabs(angle_diff);\n        if (angle_diff_abs > M_PI) {\n            angle_diff_signed = angle_diff / angle_diff_abs;\n            angle = angle_diff_signed * (M_2__PI - angle_diff_abs);\n        } else {\n            angle = angle_diff;\n        }\n    } else {\n        angle = atan2(y, x);\n    }\n\n    return angle;\n}", "CodeBleu_score": 48.26901891775287}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t// Compute the minimum and maximum x and y coordinates of the points in the section.\n\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\t// Compute the integral above and below the polygon section.\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\tintegral_below += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n\t}\n\n\t// If the integral above is less than the integral below, the section is convex.\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 39.24084125078999}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tdouble xmin = vp1[start].x;\n    double xmax = vp1[start].x;\n    double ymin = vp1[start].y;\n    double ymax = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        if (vp1[i].x < xmin) {\n            xmin = vp1[i].x;\n        }\n        if (vp1[i].x > xmax) {\n            xmax = vp1[i].x;\n        }\n        if (vp1[i].y < ymin) {\n            ymin = vp1[i].y;\n        }\n        if (vp1[i].y > ymax) {\n            ymax = vp1[i].y;\n        }\n    }\n    double x = (xmax - xmin) / 2;\n    double y = (ymax - ymin) / 2;\n    double integral_above = 0;\n    double integral_below = 0;\n    for (int i = start; i <= end; i++) {\n        integral_above += (vp1[i].x - x) * (vp1[i].y - y);\n        integral_below += (vp1[i].x - x) * (vp1[i].y + y);\n    }\n    return integral_above < integral_below;\n}", "CodeBleu_score": 43.61989164577736}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint i;\n\tdouble x_min = vp1[start].x;\n\tdouble x_max = vp1[start].x;\n\tdouble y_min = vp1[start].y;\n\tdouble y_max = vp1[start].y;\n\tfor (i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < x_min) {\n\t\t\tx_min = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > x_max) {\n\t\t\tx_max = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < y_min) {\n\t\t\ty_min = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > y_max) {\n\t\t\ty_max = vp1[i].y;\n\t\t}\n\t}\n\tdouble x_integral_above = (x_max * (y_max - y_min) - x_min * (y_max - y_min)) / 2;\n\tdouble x_integral_below = (x_max * (y_min - y_min) - x_min * (y_min - y_min)) / 2;\n\tdouble y_integral_above = (y_max * (x_max - x_min) - y_min * (x_max - x_min)) / 2;\n\tdouble y_integral_below = (y_max * (x_min - x_min) - y_min * (x_min - x_min)) / 2;\n\tif (x_integral_above < x_integral_below) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 30.006847499580058}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tif (msg->detected) {\n    for (int i = 0; i < msg->detection_info.size(); i++) {\n      if (msg->detection_info[i].name == \"T\") {\n        num_regain++;\n        num_lost = 0;\n        break;\n      }\n      num_lost++;\n    }\n    if (num_lost > VISION_THRES) {\n      is_detected = false;\n      num_regain = 0;\n    }\n    if (num_regain > VISION_THRES) {\n      is_detected = true;\n      num_lost = 0;\n    }\n  }\n  else {\n    num_regain = 0;\n    num_lost = 0;\n  }\n  ellipse_det = msg->detection_info;\n  for (int i = 0; i < ellipse_det.size(); i++) {\n    if (ellipse_det[i].name == \"T\") {\n      ellipse_det[i].sight_angle = sight_angle;\n    }\n    else {\n      ellipse_det[i].sight_angle = -sight_angle;\n    }\n  }\n}", "CodeBleu_score": 59.972737166135914}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->det_num; i++) {\n    if (msg->det_info[i].det_name == \"T\") {\n      ellipse_det.is_detected = true;\n      ellipse_det.num_regain++;\n      ellipse_det.num_lost = 0;\n      if (ellipse_det.sight_angle_1 > ellipse_det.sight_angle_2) {\n        ellipse_det.sight_angle_1 = ellipse_det.sight_angle_2;\n        ellipse_det.sight_angle_2 = ellipse_det.sight_angle_1;\n      }\n    } else {\n      ellipse_det.num_regain = 0;\n      ellipse_det.num_lost++;\n      if (ellipse_det.num_lost > VISION_THRES) {\n        ellipse_det.is_detected = false;\n      }\n    }\n  }\n  if (ellipse_det.num_regain > VISION_THRES) {\n    ellipse_det.is_detected = true;\n  }\n\n}", "CodeBleu_score": 40.59717165376806}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->det_info.size(); i++) {\n    if (msg->det_info[i].detected) {\n      if (msg->det_info[i].detected_object_name == \"T\") {\n        num_regain++;\n        num_lost = 0;\n      } else {\n        num_regain = 0;\n        num_lost++;\n      }\n    }\n  }\n  if (num_lost > VISION_THRES) {\n    is_detected = false;\n  } else if (num_regain > VISION_THRES) {\n    is_detected = true;\n  }\n  if (is_detected) {\n    ellipse_det.sight_angle_x = ellipse_det.sight_angle_y;\n  } else {\n    ellipse_det.sight_angle_y = ellipse_det.sight_angle_x;\n  }\n}", "CodeBleu_score": 63.44625867426328}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tEigen::Vector3d pos_check;\n  pos_check << cur_pos(0), cur_pos(1), cur_pos(2);\n  if (Occupy_map_ptr->check_safety(pos_check, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 49.47021809763785}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tEigen::Vector3d cur_pos_vec(cur_pos.x(), cur_pos.y(), cur_pos.z());\n  return Occupy_map_ptr->check_safety(cur_pos_vec, safe_distance);\n}", "CodeBleu_score": 49.911765663227584}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tEigen::Vector3d pos_temp = cur_pos;\n  pos_temp.z() = 0;\n  Eigen::Vector3d pos_temp_2 = pos_temp;\n  pos_temp_2.z() = 2 * safe_distance;\n  if (Occupy_map_ptr->getOccupancy(pos_temp) > 0.5) {\n    return false;\n  }\n  if (Occupy_map_ptr->getOccupancy(pos_temp_2) > 0.5) {\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 42.38177938014221}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t// TODO: Implement this function\n  NodePtr curr_node = end_node;\n  while (curr_node != nullptr) {\n    path_nodes_.push_back(curr_node);\n    curr_node = curr_node->parent;\n  }\n  std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 54.55130005226073}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t// Follow the parent pointers from the goal node to the start node\n\t// and store each node in path_nodes_\n\tNodePtr node = end_node;\n\tpath_nodes_.push_back(node);\n\twhile (node->parent) {\n\t\tnode = node->parent;\n\t\tpath_nodes_.push_back(node);\n\t}\n\n\t// Reverse the order of path_nodes_ to go from start to end\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.22967111542891}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tpath_nodes_.push_back(end_node);\n  NodePtr current_node = end_node;\n  while (current_node->parent_ != nullptr) {\n    path_nodes_.push_back(current_node->parent_);\n    current_node = current_node->parent_;\n  }\n  std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 59.20698395488005}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t// get the odometry data\n    double x = odom->pose.pose.position.x;\n    double y = odom->pose.pose.position.y;\n    double z = odom->pose.pose.position.z;\n\n    // update the state of the neighboring UGV\n    start_pos_state_nei[id].x = x;\n    start_pos_state_nei[id].y = y;\n    start_pos_state_nei[id].z = z;\n\n    // check if the distance from the start position exceeds 5 meters\n    if(sim_mode) {\n        if(sqrt(pow(x-start_pos.x,2)+pow(y-start_pos.y,2)+pow(z-start_pos.z,2))>5) {\n            get_nei_state[id] = false;\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n    else {\n        get_nei_state[id] = true;\n    }\n\n}", "CodeBleu_score": 55.01293658136114}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t// update the state of a neighboring UGV\n  state_nei[id] = (odom->pose.pose.position).norm();\n  // set get_nei_state flag to false if the distance from start position exceeds 5 meters\n  if (state_nei[id] > 5) {\n    get_nei_state[id] = false;\n  }\n  else {\n    get_nei_state[id] = true;\n  }\n}", "CodeBleu_score": 34.9294663794015}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t// Update the state of the neighboring UGV\n    state_nei[id].x = odom->pose.pose.position.x;\n    state_nei[id].y = odom->pose.pose.position.y;\n    state_nei[id].z = odom->pose.pose.position.z;\n\n    // Check if the neighboring UGV is too far from the start position\n    if(sim_mode) {\n        if(sqrt(pow(state_nei[id].x - start_pos.x, 2) + pow(state_nei[id].y - start_pos.y, 2)) > 5)\n            get_nei_state[id] = false;\n        else\n            get_nei_state[id] = true;\n    }\n\n    return;\n}", "CodeBleu_score": 41.71503673612691}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (!odometry_ready) {\n    return;\n  }\n  sensor_ready = true;\n  update_counter++;\n  if (update_counter % 5 == 0) {\n    // Update the map\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n    update_counter = 0;\n  }\n}", "CodeBleu_score": 58.357370841740675}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// If odometry is not ready, return immediately\n  if(!odom_ready) {\n    return;\n  }\n\n  // Set sensor_ready flag to true\n  sensor_ready = true;\n\n  // Increment update counter\n  update_counter++;\n\n  // If update counter is not equal to 5, return immediately\n  if(update_counter != 5) {\n    return;\n  }\n\n  // Reset update counter\n  update_counter = 0;\n\n  // Get the current time\n  ros::Time t_start = ros::Time::now();\n\n  // Convert the point cloud data to a point cloud object\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n\n  // Get the current robot pose\n  tf::Stamped<tf::Pose> robot_pose;\n  tf_listener->waitForTransform(map_frame, base_frame, ros::Time(0), ros::Duration(10.0) );\n  tf_listener->lookupTransform(map_frame, base_frame, ros::Time(0), robot_pose);\n\n  // Get the current robot position\n  double robot_x = robot_pose.getOrigin().x();\n  double robot_y = robot_pose.getOrigin().y();\n\n  // Get the current robot orientation\n  double robot_yaw = tf::getYaw(robot_pose.getRotation());\n\n  // Get the current robot velocity\n  double robot_vel_x = robot_vel.linear.x;\n  double robot_vel_y = robot_vel.linear.y;\n\n  // Get the current robot acceleration\n  double robot_acc_x = robot_acc.linear.x;\n  double robot_acc_y = robot_acc.linear.y;\n\n  // Get the current robot angular velocity\n  double robot_ang_vel = robot_vel.angular.z;\n\n  // Get the current robot angular acceleration\n  double robot_ang_acc = robot_acc.angular.z;\n\n  // Get the current robot acceleration\n  double robot_acc_mag = sqrt(robot_acc_x*robot", "CodeBleu_score": 47.49904064022517}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (!odom_ready) {\n    return;\n  }\n\n  sensor_ready = true;\n  update_count++;\n\n  if (update_count % 5 != 0) {\n    return;\n  }\n\n  // Update the Astar map\n  Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\n  // Reset update counter\n  update_count = 0;\n}", "CodeBleu_score": 59.111370704466204}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, global_map);\n    inflate_point_cloud(global_map);\n  }\n}", "CodeBleu_score": 46.5421064221427}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif(!get_gpcl){\n    get_gpcl = true;\n    global_pcl = pcl::PointCloud<pcl::PointXYZ>::Ptr(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*global_point, *global_pcl);\n    inflate_point_cloud(global_pcl, inflate_global_pcl, inflate_global_pcl_num);\n  }\n\n}", "CodeBleu_score": 54.81668150947665}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (get_gpcl == false) {\n    get_gpcl = true;\n    global_pcl = *global_point;\n    pcl::fromROSMsg(global_pcl, *global_pcl_ptr);\n    inflate_point_cloud(global_pcl_ptr, inflated_global_pcl_ptr, inflation_radius);\n  }\n}", "CodeBleu_score": 50.93759013728474}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// 1. Convert laser scan data to PointCloud2 format\n  sensor_msgs::PointCloud2 local_point_cloud;\n  projector_.projectLaser(*local_point, local_point_cloud);\n  // 2. Convert PointCloud2 to pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr local_pcl_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(local_point_cloud, *local_pcl_ptr);\n  // 3. Merge the local map with the provided odometry data\n  if (!simulation_mode_) {\n    local_map_merge_odom(local_pcl_ptr, odom);\n  }\n}", "CodeBleu_score": 50.79339929570988}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// 1. Convert laser scan to point cloud\n  sensor_msgs::PointCloud2 cloud;\n  local_map_projector_.projectLaser(*local_point, cloud);\n  pcl::PointCloud<pcl::PointXYZ> local_map;\n  pcl::fromROSMsg(cloud, local_map);\n\n  // 2. Transform the point cloud to the map frame\n  pcl::PointCloud<pcl::PointXYZ> local_map_transformed;\n  pcl_ros::transformPointCloud(odom.header.frame_id, odom.header.stamp, local_map, local_map_transformed, tf_);\n\n  // 3. Merge the local map with the map\n  if (!simulation_mode_) {\n    local_map_merge_odom(local_map_transformed, odom);\n  } else {\n    local_map_merge_no_odom(local_map_transformed);\n  }\n}", "CodeBleu_score": 51.34735422442649}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// if in simulation mode, we do not need to merge the map with the odometry data\n  if (simulation_mode_) {\n    local_map_merge_odom(local_point, odom);\n  } else {\n    // if not in simulation mode, we need to merge the map with the odometry data\n    local_map_merge_odom(local_point, odom);\n    // merge the local map with the odometry data\n    merge_odom(odom);\n  }\n}", "CodeBleu_score": 41.77734459602359}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic\n  sensor_msgs::PointCloud2 global_pcl_ros_msg;\n  pcl::toROSMsg(global_pcl_map, global_pcl_ros_msg);\n  global_pcl_ros_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_ros_msg);\n\n  // Convert and publish the inflated point cloud to the inflate_pcl_pub topic with the same frame ID\n  sensor_msgs::PointCloud2 inflate_pcl_ros_msg;\n  pcl::toROSMsg(inflate_pcl_map, inflate_pcl_ros_msg);\n  inflate_pcl_ros_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_ros_msg);\n}", "CodeBleu_score": 58.81169948705372}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Convert the global map to a ROS message and publish it\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_pcl_ptr, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Convert the inflated global map to a ROS message and publish it\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*inflate_pcl_ptr, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 65.04287261418962}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic.\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl_map, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert and publish the inflated point cloud to the inflate_pcl_pub topic with the same frame ID.\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl_map, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 59.53100550996322}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// ROS_INFO(\"Received point cloud\");\n  // ROS_INFO(\"Size of point cloud: %d\", msg->width*msg->height);\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.capacity());\n  // ROS_INFO(\"Size of point cloud: %d\", msg->data.size());\n  // R", "CodeBleu_score": 8.1003284050378}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// Get the current time\n  ros::Time current_time = ros::Time::now();\n  // Check if the odometry is ready\n  if (odometry_ready) {\n    // Set the sensor_ready flag to true\n    sensor_ready = true;\n    // Check if the current time is greater than the last time the map was updated\n    if (current_time > last_map_update_time) {\n      // Update the map using the new point cloud data and current UAV odometry\n      Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, current_odometry);\n      // Set the last_map_update_time to the current time\n      last_map_update_time = current_time;\n    }\n  }\n}", "CodeBleu_score": 55.14716168688991}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb 1\");\n    if (Astar_ptr->Occupy_map_ptr->map_updated) {\n        Astar_ptr->Occupy_map_ptr->map_updated = false;\n        return;\n    }\n    //ROS_INFO(\"Lpointcloud_cb 2\");\n    if (sensor_ready) {\n        //ROS_INFO(\"Lpointcloud_cb 3\");\n        sensor_ready = false;\n        //ROS_INFO(\"Lpointcloud_cb 4\");\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(*msg, cloud);\n        //ROS_INFO(\"Lpointcloud_cb 5\");\n        //ROS_INFO(\"Lpointcloud_cb 6\");\n        Astar_ptr->Occupy_map_ptr->map_update_lpcl(cloud);\n        //ROS_INFO(\"Lpointcloud_cb 7\");\n        sensor_ready = true;\n        //ROS_INFO(\"Lpointcloud_cb 8\");\n    }\n}", "CodeBleu_score": 52.98490578734558}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n  champ::PhaseGenerator::Time time = rosTimeToChampTime(ros::Time::now());\n\n  // Compute the desired foot positions\n  float desired_foot_positions[4][3];\n  body_controller_.poseCommand(desired_foot_positions, time);\n\n  // Compute the desired joint positions\n  float desired_joint_positions[12];\n  kinematics_.inverse(desired_joint_positions, desired_foot_positions);\n\n  // Publish the joint positions\n  publishJoints_(desired_joint_positions);\n\n  // Publish the foot contacts\n  bool foot_contacts[4];\n  for(size_t i = 0; i < 4; i++)\n  {\n    foot_contacts[i] = base_.legs[i]->isInContact();\n  }\n  publishFootContacts_(foot_contacts);\n}", "CodeBleu_score": 57.91181753550671}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t//Check if we are in simulation or not\n    if(!in_gazebo_)\n    {\n        //Get the current time\n        ros::Time now = ros::Time::now();\n\n        //Get the current state of the robot\n        champ::ChampState state = champ::ChampState::fromROS(state_subscriber_.getState());\n\n        //Get the current pose of the robot\n        champ::Pose current_pose = state.getPose();\n\n        //Get the current joint positions\n        champ::JointPositions current_joints = state.getJointPositions();\n\n        //Get the current foot contacts\n        champ::Contacts current_contacts = state.getContacts();\n\n        //Get the current imu data\n        champ::IMU current_imu = state.getIMU();\n\n        //Get the current battery voltage\n        double current_voltage = state.getVoltage();\n\n        //Get the current temperature\n        double current_temperature = state.getTemperature();\n\n        //Get the current pressure\n        double current_pressure = state.getPressure();\n\n        //Get the current pressure\n        double current_altitude = state.getAltitude();\n\n        //Get the current pressure\n        double current_gravity = state.getGravity();\n\n        //Get the current pressure\n        double current_acceleration = state.getAcceleration();\n\n        //Get the current pressure\n        double current_angular_velocity = state.getAngularVelocity();\n\n        //Get the current pressure\n        double current_orientation = state.getOrientation();\n\n        //Get the current pressure\n        double current_linear_acceleration = state.getLinearAcceleration();\n\n        //Get the current pressure\n        double current_magnetic_field = state.getMagneticField();\n\n        //Get the current pressure\n        double current_roll = state.getRoll();\n\n        //Get the current pressure\n        double current_pitch = state.getPitch();\n\n        //Get the current pressure\n        double current_yaw = state.getYaw();\n\n        //Get the current pressure\n        double current_", "CodeBleu_score": 30.567207021918364}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t//Get the current time\n  ros::Time time_now = ros::Time::now();\n  //Get the current time in Champ time\n  champ::PhaseGenerator::Time time_now_champ = rosTimeToChampTime(time_now);\n\n  //Get the desired pose\n  champ::Pose desired_pose = body_controller_.poseCommand(time_now_champ);\n\n  //Get the desired foot positions\n  champ::FootPositions desired_foot_positions = kinematics_.inverse(desired_pose);\n\n  //Compute the velocity commands\n  champ::FootVelocities desired_foot_velocities = body_controller_.velocityCommand(time_now_champ, desired_foot_positions);\n\n  //Compute the target joint positions\n  float target_joints[12];\n  kinematics_.forward(desired_foot_positions, desired_foot_velocities, target_joints);\n\n  //Publish the joint positions\n  publishJoints_(target_joints);\n\n  //Publish the foot contact information\n  bool foot_contacts[4];\n  for(size_t i = 0; i < 4; i++)\n  {\n      foot_contacts[i] = desired_foot_positions[i].contact();\n  }\n  publishFootContacts_(foot_contacts);\n}", "CodeBleu_score": 51.43683313909324}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    if (!gazebo_ros_->isInitialized()) {\n      // Create a contacts message.\n      quadruped_msgs::ContactsStamped contacts_msg;\n      contacts_msg.header.stamp = ros::Time::now();\n      contacts_msg.contacts.resize(4);\n\n      for (int i = 0; i < 4; ++i) {\n        contacts_msg.contacts[i].gait_phase =\n            base_.legs[i]->gait_phase;\n        contacts_msg.contacts[i].contact = foot_contacts[i];\n      }\n\n      // Publish the contacts message.\n      foot_contacts_publisher_.publish(contacts_msg);\n    }\n  }\n}", "CodeBleu_score": 56.10124878844963}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    if (!use_gazebo_) {\n      // Create a ContactsStamped message.\n      quadruped_msgs::ContactsStamped contacts_msg;\n      contacts_msg.header.stamp = ros::Time::now();\n      contacts_msg.contacts.resize(4);\n\n      // Populate the message with the current gait phase of each leg.\n      for (int i = 0; i < 4; ++i) {\n        contacts_msg.contacts[i].gait_phase =\n            base_.legs[i]->gait_phase;\n      }\n\n      // Publish the message.\n      foot_contacts_publisher_.publish(contacts_msg);\n    }\n  }\n}", "CodeBleu_score": 66.89894457197727}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    if (is_gazebo_) {\n      for (int i = 0; i < 4; i++) {\n        foot_contacts_[i] = foot_contacts[i];\n      }\n    } else {\n      ros::Time current_time = ros::Time::now();\n      contacts_msg_.header.stamp = current_time;\n      contacts_msg_.header.frame_id = \"world\";\n      contacts_msg_.contacts.resize(4);\n\n      for (int i = 0; i < 4; i++) {\n        contacts_msg_.contacts[i].id = i;\n        contacts_msg_.contacts[i].is_in_contact = foot_contacts[i];\n        contacts_msg_.contacts[i].gait_phase = base_.legs[i]->gait_phase;\n      }\n\n      foot_contacts_publisher_.publish(contacts_msg_);\n    }\n  }\n}", "CodeBleu_score": 50.18860758229561}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t# Create a minimal joints message with the first 12 joint positions\n  joints_msg = JointState()\n  joints_msg.header.stamp = rospy.Time.now()\n  joints_msg.name = self.joints_msg.name[0:12]\n  joints_msg.position = joints.position[0:12]\n  self.joints_pub.publish(joints_msg)\n\n  # Create a joint trajectory message\n  joint_trajectory_msg = JointTrajectory()\n  joint_trajectory_msg.header.stamp = rospy.Time.now()\n  joint_trajectory_msg.joint_names = joints_msg.name\n  joint_trajectory_point = JointTrajectoryPoint()\n  joint_trajectory_point.positions = joints_msg.position\n  joint_trajectory_point.time_from_start = rospy.Duration(self.duration)\n  joint_trajectory_msg.points.append(joint_trajectory_point)\n  self.joint_trajectory_pub.publish(joint_trajectory_msg)\n}", "CodeBleu_score": 47.366280585828115}, {"code": "def joints_cmd_callback(self, joints){\n\t# Create a Joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.header.stamp = joints.header.stamp\n    joints_msg.header.frame_id = joints.header.frame_id\n    joints_msg.name = joints.name[0:12]\n    joints_msg.position = joints.position[0:12]\n    joints_msg.velocity = joints.velocity[0:12]\n    joints_msg.effort = joints.effort[0:12]\n    # Publish the joints message to the joints topic\n    self.joints_pub.publish(joints_msg)\n    # Create a JointTrajectory message with the same positions and a specified duration\n    joint_traj_msg = JointTrajectory()\n    joint_traj_msg.header.stamp = joints.header.stamp\n    joint_traj_msg.header.frame_id = joints.header.frame_id\n    joint_traj_msg.joint_names = joints.name[0:12]\n    joint_traj_point = JointTrajectoryPoint()\n    joint_traj_point.positions = joints.position[0:12]\n    joint_traj_point.velocities = joints.velocity[0:12]\n    joint_traj_point.effort = joints.effort[0:12]\n    joint_traj_point.time_from_start = rospy.Duration(0.5)\n    joint_traj_msg.points.append(joint_traj_point)\n    # Publish the joint trajectory message to the joint trajectory topic\n    self.joint_traj_pub.publish(joint_traj_msg)\n}", "CodeBleu_score": 37.264418045121175}, {"code": "def joints_cmd_callback(self, joints){\n\tdef joints_msg = JointState()\n    joints_msg.header = joints.header\n    joints_msg.name = joints.name\n    joints_msg.position = joints.position[0:12]\n    self.joint_pub.publish(joints_msg)\n\n    def joint_trajectory = JointTrajectory()\n    joint_trajectory.header = joints.header\n    joint_trajectory.joint_names = joints.name[0:12]\n    def joint_trajectory_point = JointTrajectoryPoint()\n    joint_trajectory_point.positions = joints.position[0:12]\n    joint_trajectory_point.time_from_start = Duration(secs=1)\n    joint_trajectory.points.append(joint_trajectory_point)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 45.9555178523212}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contact_[i] = false;\n  }\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n\n    // Split the collision string to identify the contact link\n    std::vector<std::string> collision_array;\n    boost::split(collision_array, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n\n    // If a contact matches one of the foot links\n    if (collision_array[collision_array.size() - 1] == \"foot_link\") {\n\n      // Set the corresponding foot contact state to true\n      if (collision_array[collision_array.size() - 3] == \"left\") {\n        foot_contact_[0] = true;\n      } else if (collision_array[collision_array.size() - 3] == \"right\") {\n        foot_contact_[1] = true;\n      }\n\n    }\n\n  }\n\n}", "CodeBleu_score": 53.410239593245066}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false\n  for (int i = 0; i < 4; ++i) {\n    foot_contact_[i] = false;\n  }\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    // Split the collision string to identify the contact link\n    std::vector<std::string> collision_str;\n    boost::split(collision_str, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n    // If a contact matches one of the foot links\n    if (collision_str[collision_str.size() - 1] == \"l_foot\" ||\n        collision_str[collision_str.size() - 1] == \"r_foot\") {\n      // Set the corresponding foot contact state to true\n      if (collision_str[collision_str.size() - 1] == \"l_foot\") {\n        foot_contact_[0] = true;\n      } else if (collision_str[collision_str.size() - 1] == \"r_foot\") {\n        foot_contact_[1] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 52.59911003040415}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Reset the foot contact flags\n  for (int i = 0; i < 4; i++) {\n    foot_contact_[i] = false;\n  }\n\n  // Check each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Get the collision1 string\n    std::string collision1 = _msg->contact(i).collision1();\n\n    // Check if the collision string contains the name of a foot link\n    if (collision1.find(\"l_foot\") != std::string::npos) {\n      foot_contact_[0] = true;\n    }\n    if (collision1.find(\"r_foot\") != std::string::npos) {\n      foot_contact_[1] = true;\n    }\n    if (collision1.find(\"l_hand\") != std::string::npos) {\n      foot_contact_[2] = true;\n    }\n    if (collision1.find(\"r_hand\") != std::string::npos) {\n      foot_contact_[3] = true;\n    }\n  }\n}", "CodeBleu_score": 52.99134311430116}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!IsActive()) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z-axis.\n  Eigen::Vector3d thrust;\n  thrust = acceleration.dot(Eigen::Vector3d::UnitZ()) * Eigen::Vector3d::UnitZ();\n\n  // Combine angular acceleration and thrust.\n  Eigen::VectorXd acceleration_thrust(3 + vehicle_parameters_.rotor_configuration_.rotors.size());\n  acceleration_thrust.block<3, 1>(0, 0) = thrust;\n  acceleration_thrust.block<3, 1>(0, 1) = angular_acceleration;\n\n  // Compute rotor velocities.\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  *rotor_velocities = vehicle_parameters_.rotor_configuration_.rotor_count_matrix\n      * acceleration_thrust;\n\n  // Ensure that rotor velocities are positive.\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n}", "CodeBleu_score": 59.94094808610883}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!IsActive()) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z-axis.\n  Eigen::Vector3d thrust;\n  thrust = acceleration.dot(Eigen::Vector3d::UnitZ()) * Eigen::Vector3d::UnitZ();\n\n  // Combine angular acceleration and thrust.\n  Eigen::Vector3d angular_acceleration_thrust;\n  angular_acceleration_thrust = angular_acceleration + thrust;\n\n  // Convert angular acceleration and thrust to rotor velocities.\n  rotor_velocities->block<3, 1>(0, 0) = angular_acceleration_thrust;\n  rotor_velocities->block<3, 1>(3, 0) = odometry_.orientation.toRotationMatrix().col(2);\n\n  // Ensure that all rotor velocities are positive.\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n\n  // Compute rotor velocities.\n  rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 57.06555141386412}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t// Ensure that the input is valid.\n  assert(rotor_velocities);\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!is_active_) {\n    rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute desired acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  // Compute desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto the body z-axis and combine with angular acceleration.\n  Eigen::Vector3d thrust;\n  thrust = acceleration.dot(Eigen::Vector3d::UnitZ()) * Eigen::Vector3d::UnitZ();\n  Eigen::Vector3d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust.block<1, 1>(3, 0) = thrust;\n\n  // Compute rotor velocities.\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  rotor_velocities->cwiseSqrt() =\n      vehicle_parameters_.rotor_configuration_.rotor_direction *\n      vehicle_parameters_.rotor_configuration_.rotor_speed_to_thrust_table *\n      angular_acceleration_thrust.cwiseMax(Eigen::VectorXd::Zero(4));\n}", "CodeBleu_score": 60.81786759967671}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// TODO: Implement\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  Eigen::Vector3d desired_acceleration;\n\n  position_error = odometry_.position - command_trajectory_.position;\n  velocity_error = odometry_.linear_velocity - command_trajectory_.linear_velocity;\n\n  // position_error = odometry_.position - command_trajectory_.position;\n  // velocity_error = odometry_.linear_velocity - command_trajectory_.linear_velocity;\n\n  // position_error.cwiseProduct(position_error);\n  // velocity_error.cwiseProduct(velocity_error);\n\n  // desired_acceleration = position_error * position_gain_ + velocity_error * velocity_gain_;\n  // desired_acceleration.cwiseProduct(desired_acceleration);\n\n  // desired_acceleration = position_error * position_gain_ + velocity_error * velocity_gain_;\n  // desired_acceleration.cwiseProduct(desired_acceleration);\n\n  // desired_acceleration = position_error * position_gain_ + velocity_error * velocity_gain_;\n  // desired_acceleration.cwiseProduct(desired_acceleration);\n\n  // desired_acceleration = position_error * position_gain_ + velocity_error * velocity_gain_;\n  // desired_acceleration.cwiseProduct(desired_acceleration);\n\n  // desired_acceleration = position_error * position_gain_ + velocity_error * velocity_gain_;\n  // desired_acceleration.cwiseProduct(desired_acceleration);\n\n  // desired_acceleration = position_error * position_gain_ + velocity_error * velocity_gain_;\n  // desired_acceleration.cwiseProduct(desired_acceleration);\n\n  // desired_acceleration = position_error * position_gain_ + velocity_error * velocity_gain_;", "CodeBleu_score": 28.358805083962473}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// Compute position error\n  Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n\n  // Compute velocity error\n  Eigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity;\n\n  // Transform velocity to world frame\n  Eigen::Vector3d velocity_world = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n  // Compute desired acceleration\n  *acceleration = position_error.cwiseProduct(position_gain_) +\n                 velocity_error.cwiseProduct(velocity_gain_) +\n                 Eigen::Vector3d(0.0, 0.0, -1.0) * gravity_ -\n                 velocity_world.cwiseProduct(inertia_) -\n                 command_trajectory_.acceleration;\n}", "CodeBleu_score": 44.57813927254475}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// Calculate the position error\n  Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n\n  // Calculate the velocity error\n  Eigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity;\n\n  // Calculate the desired acceleration\n  Eigen::Vector3d desired_acceleration =\n      position_error.cwiseProduct(position_gains_) +\n      velocity_error.cwiseProduct(velocity_gains_);\n\n  // Adjust for gravity and vehicle mass\n  desired_acceleration[2] -= gravity_ / vehicle_mass_;\n\n  // Adjust for the commanded acceleration\n  desired_acceleration += command_trajectory_.acceleration;\n\n  // Transform the desired acceleration to the world frame\n  *acceleration = odometry_.orientation.toRotationMatrix() * desired_acceleration;\n}", "CodeBleu_score": 44.33024935008857}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // Ensure that the number of rotors is correct.\n  assert(rotor_velocities->rows() == kNumRotors);\n\n  // Resize the vector to the number of rotors.\n  rotor_velocities->resize(kNumRotors);\n\n  // Compute the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::VectorXd angular_acceleration_thrust(3);\n  angular_acceleration_thrust << angular_acceleration, thrust_reference_;\n\n  // Multiply the combined vector with the predefined matrix.\n  *rotor_velocities = rotor_velocities_matrix_ * angular_acceleration_thrust;\n\n  // Ensure that the rotor velocities are at least one.\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(kNumRotors));\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 65.97905428733677}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(rotor_velocities->size() == 4);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd thrust_reference = control_attitude_thrust_reference_;\n  thrust_reference.cwiseMax() = Eigen::VectorXd::Ones(4);\n\n  Eigen::VectorXd control_vector(7);\n  control_vector << thrust_reference, angular_acceleration;\n\n  // Compute rotor velocities\n  *rotor_velocities = rotor_velocity_to_thrust_matrix_ * control_vector;\n  rotor_velocities->cwiseSqrt();\n  rotor_velocities->rows() = rotor_velocities->cwiseMax(1.0);\n}", "CodeBleu_score": 54.77686738006335}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // Ensure that the input is valid.\n  assert(rotor_velocities->size() == kNumMotors);\n\n  // Resize the output vector.\n  rotor_velocities->resize(kNumMotors);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // Combine the thrust reference and the desired angular acceleration.\n  Eigen::VectorXd angular_acceleration_thrust(Eigen::VectorXd::Ones(kNumMotors));\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust.block<3, 1>(3, 0) = control_attitude_thrust_reference_;\n\n  // Multiply the desired angular acceleration with the predefined matrix.\n  *rotor_velocities = rotor_velocity_to_thrust_matrix_ * angular_acceleration_thrust;\n\n  // Take the square root of each component.\n  rotor_velocities->cwiseSqrt();\n\n  // Ensure that the rotor velocities are at least one.\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(kNumMotors));\n}", "CodeBleu_score": 65.56738832396955}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\ttry:\n        start_index = self.get_next_index(start_time)\n        end_index = self.get_next_index(end_time)\n    except Exception, e:\n        raise e\n    copied_obj = copy.deepcopy(self)\n    for attr in self.attributes:\n        setattr(copied_obj, attr, getattr(copied_obj, attr)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 65.14135968202646}, {"code": "def slice(self, start_time, end_time)\n\t# get the indices of the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n    # update each attribute to contain only the sliced data\n    for attr in copied_obj.__dict__.keys():\n        if attr != 'time':\n            copied_obj.__setattr__(attr, copied_obj.__getattribute__(attr)[start_index:end_index])\n    return copied_obj\n\n\n", "CodeBleu_score": 59.12963087746077}, {"code": "def slice(self, start_time, end_time)\n\tcopied_obj = copy.deepcopy(self)\n    start_index = copied_obj.get_next_index(start_time)\n    end_index = copied_obj.get_next_index(end_time)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.position = copied_obj.position[start_index:end_index]\n    copied_obj.velocity = copied_obj.velocity[start_index:end_index]\n    copied_obj.acceleration = copied_obj.acceleration[start_index:end_index]\n    copied_obj.jerk = copied_obj.jerk[start_index:end_index]\n    copied_obj.snap = copied_obj.snap[start_index:end_index]\n    copied_obj.crackle = copied_obj.crackle[start_index:end_index]\n    copied_obj.pop = copied_obj.pop[start_index:end_index]\n    return copied_obj\n\n", "CodeBleu_score": 18.056587151147962}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tpoint = Point()\n    point.x = waypoint_msg.pose.pose.position.x\n    point.y = waypoint_msg.pose.pose.position.y\n    point.z = waypoint_msg.pose.pose.position.z\n\n    quat = waypoint_msg.pose.pose.orientation\n    euler = euler_from_quaternion([quat.x, quat.y, quat.z, quat.w])\n    point.yaw = euler[2]\n\n    if self.last_waypoint is None or not self.last_waypoint.equal(point):\n        self.append_point(point)\n        self.append_yaw(point.yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_waypoint = point\n\n", "CodeBleu_score": 24.143752669437287}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Get the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert the rotation to Euler angles\n    euler_angles = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a point object\n    point = Point(position.x, position.y, position.z, euler_angles[2])\n    # Check if the waypoint is different from the last one\n    if self.last_point is None or not self.last_point.equal(point):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.last_point = point\n        self.points.append_point(point)\n        self.points.append_yaw(euler_angles[2])\n        self.points.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 23.688920561342872}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Extract the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    orientation = waypoint_msg.pose.pose.orientation\n\n    # Convert the orientation to Euler angles\n    euler = euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n\n    # Create a Point object to append\n    point = Point(position.x, position.y, position.z, euler[2])\n\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is None or not self.last_waypoint.is_equal(point):\n        self.last_waypoint = point\n\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.point_array.append_point(point)\n        self.yaw_array.append(point.yaw)\n        self.point_array.append_times(msg_time, bag_time)\n        self.yaw_array.append_times(msg_time, bag_time)", "CodeBleu_score": 25.436550791659023}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t# Convert the message timestamp to seconds\n    msg_time = to_sec(msg.header.stamp)\n\n    # Append the linear acceleration data to the corresponding x, y, and z attributes\n    if topic == \"/imu/imu_linear_acceleration\":\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n\n    # Append the message time and bag time to the time attributes\n    self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 33.97032861943164}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t# Extract the message time\n    msg_time = self.to_sec(msg.header.stamp)\n\n    # Append the message time and the bag time\n    self.append_times(msg_time, bag_time)\n\n    # Extract the linear acceleration\n    self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.linear_acceleration.x)\n    self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.linear_acceleration.y)\n    self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 21.637744635115546}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t# Convert the message time to seconds\n    msg_time = to_sec(msg.header.stamp)\n    # Append the message time and the bag time to the time attributes\n    self.append_times(msg_time, bag_time)\n    # Append the linear acceleration data to the corresponding x, y, and z attributes\n    self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.linear_acceleration.x)\n    self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.linear_acceleration.y)\n    self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 21.79988050627345}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Create a figure with a title\n    fig = pyplot.figure()\n    fig.suptitle(self.acceleration_data_name)\n\n    # Add a subplot for accelerations\n    ax1 = fig.add_subplot(111)\n\n    # Plot each acceleration dataset with a different color and label\n    for i, accel_data in enumerate(self.acceleration_data):\n        ax1.plot(\n            accel_data.time,\n            accel_data.x,\n            label=accel_data.name + \" x\",\n            color=self.colors[i],\n        )\n        ax1.plot(\n            accel_data.time,\n            accel_data.y,\n            label=accel_data.name + \" y\",\n            color=self.colors[i],\n        )\n        ax1.plot(\n            accel_data.time,\n            accel_data.z,\n            label=accel_data.name + \" z\",\n            color=self.colors[i],\n        )\n\n    # Add labels for the x and y axes\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.xlabel(\"Time (s)\")\n\n    # Add a legend\n    pyplot.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix\n    if self.save_plots:\n        filename = self.plot_filename_prefix + \"_accelerations\"\n        if plot_suffix:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n\n        # Save the plot as a PNG file\n        pyplot.savefig(filename)\n\n    # Show the plot\n    pyplot.show()\n\n\n\n\n", "CodeBleu_score": 36.72306465587915}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Create the plot\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration Data\")\n    ax = fig.add_subplot(111)\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.set_xlabel(\"Time (seconds)\")\n    for i, acc in enumerate(self.accelerations):\n        ax.plot(acc.x, label=\"Accel X \" + str(i), color=colors[i])\n        ax.plot(acc.y, label=\"Accel Y \" + str(i), color=colors[i])\n        ax.plot(acc.z, label=\"Accel Z \" + str(i), color=colors[i])\n    pyplot.legend()\n    # If saving plots is enabled, save the plot\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        pyplot.savefig(self.plot_dir + \"/\" + \"accelerations\" + plot_suffix + \".png\")\n\n\n\n\n\n", "CodeBleu_score": 42.08642186570554}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Create a figure and a subplot\n    fig = pyplot.figure()\n    ax = fig.add_subplot(111)\n    # Set the title and labels\n    fig.suptitle('Accelerations')\n    pyplot.ylabel('Acceleration (m/s^2)')\n    # Plot each acceleration dataset\n    for i, accel in enumerate(self.accelerations):\n        # Plot the x, y, and z components of the acceleration\n        ax.plot(accel.time, accel.x, label='Accel X', color=self.colors[i])\n        ax.plot(accel.time, accel.y, label='Accel Y', color=self.colors[i])\n        ax.plot(accel.time, accel.z, label='Accel Z', color=self.colors[i])\n    # Add a legend and labels for the x and y axes\n    pyplot.legend()\n    pyplot.xlabel('Time (s)')\n    # If saving plots is enabled, construct a filename and save the plot\n    if self.save_plots:\n        filename = self.plot_filename_prefix + '_accelerations'\n        if plot_suffix is not None:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        pyplot.savefig(filename)\n    # Show the plot\n    pyplot.show()", "CodeBleu_score": 40.77242449662803}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\tif len(pose_indeces) < 2:\n        print(\"compare_positions: At least two pose indices are required to perform comparisons.\")\n        return\n    for i in range(0, len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self.poses[pose_indeces[i]].xyz, self.poses[pose_indeces[j]].xyz)\n\n", "CodeBleu_score": 38.24768143618813}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t# Initialize an empty list for collision times.\n    collision_times = []\n\n    # Iterate through each collision's time in self.wrench.\n    for collision in self.wrench:\n        # If the time is within the start_time and end_time range, append the time to the collision_times list.\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n\n    # Return the list of collision times.\n    return collision_times", "CodeBleu_score": 38.827983576462124}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision in self.wrench:\n        if start_time <= collision[0] <= end_time:\n            collision_times.append(collision[0])\n    return collision_times", "CodeBleu_score": 34.751048419934676}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n\n\n\n", "CodeBleu_score": 35.368254569040616}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n\n  const float multiplier =\n      (this->max_depth - this->min_depth) / (this->max_value - this->min_value);\n\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  Eigen::VectorXf rms_noise =\n      (data_vector_map * 1000.0).array().square().sqrt();\n\n  for (int i = 0; i < width * height; i++) {\n    if (InRange(data_vector_map(i))) {\n      data_vector_map(i) +=\n          (rms_noise(i) * this->noise_stddev *\n           std::sqrt(2.0f * std::atan(this->noise_stddev * 1000.0f /\n                                      (data_vector_map(i) * multiplier))))\n              .array();\n    } else {\n      data_vector_map(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 53.42428117705316}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n  // Calculate the multiplier based on the camera parameters\n  const float multiplier = 1.0f / (this->max_depth - this->min_depth);\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  // Calculate the RMS noise\n  const Eigen::VectorXf rms_noise =\n      (data_vector_map * 1000.0).array().square().sum() /\n      (width * height) -\n      (data_vector_map * 1000.0).array().square().mean().square();\n  // Add noise to each pixel\n  for (uint32_t i = 0; i < width * height; i++) {\n    // Check if the pixel value is in range\n    if (this->InRange(data_vector_map[i])) {\n      // Add noise\n      data[i] +=\n          (data[i] - this->min_depth) * multiplier * rms_noise.array().sqrt();\n    } else {\n      // Set pixel to a bad point value\n      data[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 57.85290111929402}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier based on camera parameters\n  const float multiplier = 1000.0f / this->depth_scale;\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  // Calculate RMS noise\n  const float rms_noise = std::sqrt(this->rms_noise);\n\n  // Apply noise to data\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (InRange(data[i] * multiplier)) {\n      data[i] += rms_noise * noise_distribution(this->random_engine);\n    } else {\n      data[i] = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 48.66199051755192}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  common::Time simTime = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time rosTime = ros::Time(simTime.sec, simTime.nsec);\n\n  // Write the trajectory message to a bag file\n  writeBag(trajectory_msg, rosTime, \"trajectory\", \"waypoint\");\n}", "CodeBleu_score": 61.925011287309616}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get current simulation time\n  gazebo::common::Time current_time = world_->GetSimTime();\n\n  // Convert to ROS time\n  ros::Time current_ros_time;\n  current_ros_time.sec = current_time.sec;\n  current_ros_time.nsec = current_time.nsec;\n\n  // Write message to bag file\n  bag_writer_->write(namespace_ + \"/\" + waypoint_topic_,\n                     current_ros_time,\n                     *trajectory_msg);\n}", "CodeBleu_score": 54.60652438050897}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  common::Time sim_time = world_->GetSimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n  // Write the trajectory message to the bag file\n  writeBag(namespace_, waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 61.47964190118322}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert Gazebo time to ROS time\n  ros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities\n  actuator_msgs::RotVelocities rot_velocities_msg;\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n  // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n  for (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Calculate the slowed-down rotational velocities\n    double rot_velocity = m->second->GetVelocity(0) * slowdown_factor_;\n\n    // Assign the slowed-down rotational velocities to the message\n    rot_velocities_msg.angular_velocities[m->second->GetScopedName()] = rot_velocity;\n  }\n\n  // Set the message timestamp\n  rot_velocities_msg.header.stamp = ros_time;\n\n  // Write the data to a bag file using the specified namespace and motor topic\n  rot_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 62.612096051929}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert simulation time to ROS time\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities\n  actuator_msgs::RotVelocities rot_velocities_msg;\n\n  // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); m++) {\n    // Get the velocity of the motor joint\n    double velocity = m->second->GetVelocity(0);\n\n    // Calculate the slowed-down rotational velocity\n    double rot_velocity = velocity * slowdown_factor_;\n\n    // Assign the rotational velocity to the message\n    rot_velocities_msg.angular_velocities.resize(rot_velocities_msg.angular_velocities.size() + 1);\n    rot_velocities_msg.angular_velocities.back() = rot_velocity;\n  }\n\n  // Set the timestamp of the message\n  rot_velocities_msg.header.stamp = ros_now;\n\n  // Write the message to a bag file using the specified namespace and motor topic\n  motor_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 57.14471181282287}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time ros_time = ros::Time(now.sec, now.nsec);\n  actuator_velocities_msg.header.stamp = ros_time;\n  for (motor_joints_iter m = motor_joints_.begin(); m != motor_joints_.end(); m++) {\n    double rot_velocity = m->second->GetVelocity(0);\n    rot_velocity *= rot_vel_slowdown_factor_;\n    rot_velocities_msg.angular_velocities.resize(rot_velocities_msg.angular_velocities.size() + 1);\n    rot_velocities_msg.angular_velocities[rot_velocities_msg.angular_velocities.size() - 1].joint_name = m->first;\n    rot_velocities_msg.angular_velocities[rot_velocities_msg.angular_velocities.size() - 1].joint_velocity = rot_velocity;\n  }\n  actuator_velocities_msg.data = rot_velocities_msg;\n  actuator_velocities_pub_.publish(actuator_velocities_msg);\n  actuator_velocities_bag_.write(actuator_velocities_topic_, ros_time, actuator_velocities_msg);\n}", "CodeBleu_score": 48.88377470457639}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called\n\";\n  }\n\n  // Convert roll, pitch, and yaw rate to control surface angles\n  aileron_angle_ = NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll());\n  elevator_angle_ = NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch());\n  rudder_angle_ = NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set throttle value\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Publish control surface angles\n  aileron_angle_pub_->Publish(aileron_angle_);\n  elevator_angle_pub_->Publish(elevator_angle_);\n  rudder_angle_pub_->Publish(rudder_angle_);\n}", "CodeBleu_score": 47.17575775063098}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called.\n\";\n  }\n  // Convert normalized inputs to control surface angles\n  double roll_angle = NormalizedInputToAngle(roll_surface_,\n                                            roll_pitch_yawrate_thrust_msg->roll());\n  double pitch_angle = NormalizedInputToAngle(pitch_surface_,\n                                             roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Set control surface angles and throttle\n  roll_surface_.SetDeflection(roll_angle);\n  pitch_surface_.SetDeflection(pitch_angle);\n  yaw_surface_.SetDeflection(yaw_rate);\n  throttle_ = thrust;\n}", "CodeBleu_score": 43.94216674107264}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called\n\";\n  }\n\n  // Convert normalized inputs to control surface angles\n  aileron_angle_ = NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll());\n  elevator_angle_ = NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch());\n  rudder_angle_ = NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set throttle value\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 40.668686069139085}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tif (is_open()) {\n    struct timeval timeout;\n    timeout.tv_sec = _timeoutMs / 1000;\n    timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n    fd_set fds;\n    FD_ZERO(&fds);\n    FD_SET(_fd, &fds);\n\n    int ret = select(_fd + 1, &fds, nullptr, nullptr, &timeout);\n\n    if (ret > 0) {\n      if (FD_ISSET(_fd, &fds)) {\n        char buf[MAVLINK_MAX_PACKET_LEN];\n        ssize_t len = read(_fd, buf, sizeof(buf));\n        if (len > 0) {\n          mavlink_status_t status;\n          mavlink_message_t msg;\n          for (ssize_t i = 0; i < len; ++i) {\n            if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n              handle_message(&msg);\n              if (serial_enabled_) {\n                send_mavlink_message(&msg, 0);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 60.36105043694003}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tstruct timeval tv;\n  tv.tv_sec = (long)(_timeoutMs / 1000);\n  tv.tv_usec = (long)(_timeoutMs % 1000) * 1000;\n\n  // Poll for new messages\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n\n  int ready = select(_fd + 1, &fds, NULL, NULL, &tv);\n\n  if (ready < 0) {\n    gzerr << \"Error in select", "CodeBleu_score": 28.357200467647935}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tstruct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(_fd, &read_fds);\n\n  int ret = select(_fd + 1, &read_fds, NULL, NULL, &timeout);\n  if (ret < 0) {\n    gzerr << \"Error in select()\n\";\n    return;\n  }\n\n  if (ret > 0) {\n    if (FD_ISSET(_fd, &read_fds)) {\n      uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n      ssize_t len = recvfrom(\n          _fd, buffer, MAVLINK_MAX_PACKET_LEN, 0, NULL, NULL);\n\n      if (len <= 0) {\n        gzerr << \"Failed receiving mavlink message\n\";\n        return;\n      }\n\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      for (ssize_t i = 0; i < len; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 57.117986067416915}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t", "CodeBleu_score": 2.410600273879713}, {"code": "void GazeboMavlinkInterface::close() {\n\tboost::mutex::scoped_lock lock(mutex_);\n  if (is_open()) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable())\n      io_thread_.join();\n  }\n}", "CodeBleu_score": 76.37863941972375}, {"code": "void GazeboMavlinkInterface::close() {\n\t", "CodeBleu_score": 2.410600273879713}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tignition::math::Vector3d position,\n    ignition::math::Vector3d point1,\n    ignition::math::Vector3d point2,\n    ignition::math::Vector3d value1,\n    ignition::math::Vector3d value2\n}", "CodeBleu_score": 18.587145124323293}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x, double y, double z,\n    double x1, double y1, double z1,\n    double x2, double y2, double z2\n}", "CodeBleu_score": 10.336350974981487}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t/*\n     * This function, GazeboWindPlugin::LinearInterpolation::operator(), performs linear interpolation for a given position.\nIt calculates the interpolated value between two points using their corresponding values and returns the resulting vector.\n     * @param[in] x The position where the interpolation will be performed.\n     * @param[in] x1 The first position.\n     * @param[in] x2 The second position.\n     * @param[in] v1 The first value.\n     * @param[in] v2 The second value.\n     * @return The interpolated vector.\n     */\n    double x, x1, x2, v1, v2;\n\n    return (x - x1) * (v2 - v1) / (x2 - x1) + v1;\n}", "CodeBleu_score": 24.91628230361724}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t//line 179 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\tif (( this->GetTime() == _time )) \n\t{\n\t\t//line 180 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\t\treturn ;\n\t}\n\t\n\t//line 183 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\tif (this->Loop) \n\t{\n\t\t//line 184 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\t\t_time = ::hx::Mod(::Math_obj::abs(_time), this->Length);\n\t}\n\telse\n\t{\n\t\t//line 186 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\t\tif ((_time < 0)) \n\t\t{\n\t\t\t//line 187 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\t\t\t_time = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//line 188 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\t\t\tif ((_time > this->Length)) \n\t\t\t{\n\t\t\t\t//line 189 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\t\t\t\t_time = this->Length;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\t//line 192 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\tthis->Time = _time;\n\t//line 193 \"C:\\\\Users\\\\peter\\\\Development\\\\verb\\\\src\\\\data\\\\Animation.hx\"\n\tthis->Update();\n}", "CodeBleu_score": 45.64794901649162}, {"code": "void Animation::SetTime(double _time){\n\t// Line: 166\n\tthis->time = _time;\n\t\n\t// Line: 167\n\tif (this->looping) {\n\t\t\n\t\t// Line: 168\n\t\tthis->time = fmod(this->time, this->length);\n\t\t\n\t\t// Line: 169\n\t\tif (this->time < 0) {\n\t\t\t\n\t\t\t// Line: 170\n\t\t\tthis->time += this->length;\n\t\t\t\n\t\t\t// Line: 171\n\t\t\tif (this->time < 0) {\n\t\t\t\t\n\t\t\t\t// Line: 172\n\t\t\t\tthis->time = 0;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t} else {\n\t\t\n\t\t// Line: 175\n\t\tif (this->time < 0) {\n\t\t\t\n\t\t\t// Line: 176\n\t\t\tthis->time = 0;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// Line: 177\n\t\t\tif (this->time > this->length) {\n\t\t\t\t\n\t\t\t\t// Line: 178\n\t\t\t\tthis->time = this->length;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\t// Line: 181\n\tthis->UpdateTime();\n\t\n\t// Line: 182\n\treturn;\n\t\n}", "CodeBleu_score": 53.74168284374407}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_raw_pose = self.construct_target()\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 42.484351622978494}, {"code": "def hover(self)\n\tself.coordinate_frame = mavros_msgs.msg.PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = 0\n    self.target_raw_pose = self.construct_target()\n    self.print_vehicle_info()\n", "CodeBleu_score": 22.010470419638732}, {"code": "def hover(self)\n\tself.coordinate_frame = mavros_msgs.msg.PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.target_raw_pose_pub.publish(target_raw_pose)\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 27.72149918510821}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flightModeService(custom_mode=self.flight_mode)\n        if self.flight_mode == 'AUTO.LAND':\n            return True\n        else:\n            if self.flightModeService(custom_mode=self.flight_mode):\n                print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode switch successful\")\n                return True\n            else:\n                print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode switch failed\")\n                return False\n\n", "CodeBleu_score": 55.21308438794499}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        self.flight_mode_service = rospy.ServiceProxy(self.vehicle_id + '/flight_mode', SetFlightMode)\n        self.flight_mode_service(self.flight_mode)\n        if self.flight_mode_service.wait_for_service(timeout=10):\n            try:\n                self.flight_mode_service(self.flight_mode)\n                print(self.vehicle_type+'_'+self.vehicle_id+\": Successfully switched to \"+self.flight_mode)\n                return True\n            except rospy.ServiceException as e:\n                print(self.vehicle_type+'_'+self.vehicle_id+\": Failed to switch to \"+self.flight_mode)\n                return False\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Failed to switch to \"+self.flight_mode)\n            return False\n\n", "CodeBleu_score": 52.11440446989162}, {"code": "def flight_mode_switch(self)\n\tself.flight_mode = self.flight_mode_dict[self.flight_mode]\n    self.flight_mode_service = rospy.ServiceProxy(self.flight_mode_service_name, SetFlightMode)\n    self.flight_mode_service_request = SetFlightModeRequest()\n    self.flight_mode_service_request.custom_mode = self.flight_mode\n    self.flight_mode_service_response = self.flight_mode_service(self.flight_mode_service_request)\n    if self.flight_mode_service_response.mode_sent:\n        if self.flight_mode == 'HOVER':\n            self.hover()\n            self.hover_flag = 1\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode set.\")\n            return True\n    else:\n        print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode not set.\")\n        return False\n\n", "CodeBleu_score": 43.65066909931606}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.hover_flag == 0:\n        if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            print(\"hover_state_transition: \" + self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n            print(\"hover_state_transition: \" + self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    else:\n        if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            print(\"hover_state_transition: \" + self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            print(\"hover_state_transition: \" + self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 35.8933221584125}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t# Checks if the drone is in hover mode\n    if self.flight_mode != \"HOVER\":\n        if self.hover_flag == 1:\n            # If the drone is not in hover mode and hover_flag is 1, it sets hover_flag to 0, changes the flight mode to 'OFFBOARD', and initiates the hover action\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.hover()\n        elif self.hover_flag == 0:\n            # If the drone is not in hover mode and hover_flag is 0, it sets hover_flag to 1, changes the flight mode to 'HOVER', and initiates the hover action\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n    else:\n        # If the drone is in hover mode, it checks if any of the x, y, z values exceed 0.02 or w exceeds 0.005\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            # If any of the x, y, z values exceed 0.02 or w exceeds 0.005, it sets hover_flag to 0 and changes the flight mode to 'OFFBOARD'\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        else:\n            # If the drone is in hover mode and the conditions are not met, it sets hover_flag to 1 and initiates the hover action\n            self.hover_flag = 1\n            self.hover()\n\n", "CodeBleu_score": 49.57757603478933}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.flight_mode != \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.hover()\n        elif abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n    else:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.hover()\n        elif abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n\n", "CodeBleu_score": 59.94739340738931}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 26.83026792740599}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 16.806809161752323}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 16.806809161752323}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = self.coordinate_frame_enum.BODY_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.set_target_pose(target_raw_pose)\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_ID)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 25.085736508812044}, {"code": "def hover(self)\n\tself.coordinate_frame = self.coordinate_frame_enum.BODY_NED\n    self.motion_type = 1\n    self.target_position = self.construct_target()\n    self.vehicle.send_mavlink(self.target_position)\n    self.vehicle.flush()\n    print(\"Vehicle type:\", self.vehicle.type)\n    print(\"Vehicle ID:\", self.vehicle.vehicle_id)\n    print(\"Flight mode:\", self.vehicle.flight_mode)\n\n", "CodeBleu_score": 27.710733851593268}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_pose = self.construct_target()\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_ID)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 34.529107471062055}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        self.flightModeService(self.flight_mode)\n        if self.flight_mode == 'HOVER':\n            self.hover = True\n            self.hover()\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + ': Failed to switch to ' + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 48.934876328937705}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n    else:\n        self.flight_mode = self.flight_mode.upper()\n        self.flightModeService(self.flight_mode)\n        if self.flightModeService.success:\n            self.flight_mode = self.flightModeService.response.flight_mode\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(\"Failed to switch to \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 60.73082925646008}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n    else:\n        self.flightModeService(self.flight_mode)\n        if self.flightModeService.success:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": failed to switch to \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 70.42792362598145}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n\n", "CodeBleu_score": 55.40188162220928}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 55.40188162220928}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()", "CodeBleu_score": 55.26923076876874}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\tif i == self.id:\n        self.local_pose = msg\n        self.local_pose.position.x = self.local_pose.position.x + self.x_bias\n        self.local_pose.position.y = self.local_pose.position.y + self.y_bias\n        self.local_pose.position.z = self.local_pose.position.z + self.z_bias\n\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = self.local_pose\n            self.hover_target_pose = self.local_pose\n\n        if self.gcs_command == \"hover\":\n            self.hover_target_pose = self.local_pose\n\n        self.global_pose = self.local_pose\n\n", "CodeBleu_score": 25.95825322628625}, {"code": "def local_pose_callback(self, msg, i)\n\tif msg.id == i:\n        self.local_pose = msg\n\n    if self.gcs_command == \"takeoff\":\n        self.takeoff_target_pose = msg\n\n    if self.gcs_command == \"hover\":\n        self.hover_target_pose = msg\n\n    self.global_pose = self.local_pose\n    self.global_pose.x += self.position_bias[0]\n    self.global_pose.y += self.position_bias[1]\n    self.global_pose.z += self.position_bias[2]\n\n\n\n\n", "CodeBleu_score": 26.80957069757386}, {"code": "def local_pose_callback(self, msg, i)\n\t# Update the local pose\n    if msg.id == i:\n        self.local_pose = msg\n\n    # Update the takeoff target pose\n    if self.gcs_cmd == 1:\n        self.takeoff_target_pose = msg\n\n    # Update the hover target pose\n    if self.gcs_cmd == 2:\n        self.hover_target_pose = msg\n\n    # Update the global pose\n    self.global_pose.position.x = msg.position.x + self.pose_bias[0]\n    self.global_pose.position.y = msg.position.y + self.pose_bias[1]\n    self.global_pose.position.z = msg.position.z + self.pose_bias[2]\n    self.global_pose.orientation.x = msg.orientation.x\n    self.global_pose.orientation.y = msg.orientation.y\n    self.global_pose.orientation.z = msg.orientation.z\n    self.global_pose.orientation.w = msg.orientation.w", "CodeBleu_score": 25.942070678425605}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False", "CodeBleu_score": 61.889133687930844}, {"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.889133687930844}, {"code": "def takeoff_detection(self)\n\tif self.get_arm_state() == \"active\" and self.get_altitude() > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 59.08772353700482}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t# Build the distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n\n    return dist_matrix\n\n", "CodeBleu_score": 25.06887277982979}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# Calculate the pairwise distances between UAVs in the original and changed formations using the Euclidean norm\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i, j] = round(np.linalg.norm(orig_formation[i] - change_formation[j]))\n    # Adjust the distances by subtracting them from 50 and converting them to integers\n    distance_matrix = distance_matrix - 50\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n", "CodeBleu_score": 24.084534002510395}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# Calculate the pairwise distances between UAVs in the original and changed formations\n    distance_matrix = np.array(\n        [\n            [\n                int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n                for j in range(len(change_formation))\n            ]\n            for i in range(len(orig_formation))\n        ]\n    )\n\n    return distance_matrix\n\n", "CodeBleu_score": 21.68598947862154}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\tself.match_right = numpy.full(self.n, -1, dtype=numpy.int)\n    self.visit_left = numpy.zeros(self.n, dtype=numpy.bool)\n    self.visit_right = numpy.zeros(self.n, dtype=numpy.bool)\n    self.slack_right = numpy.full(self.n, numpy.inf, dtype=numpy.float)\n    while True:\n        self.visit_left.fill(False)\n        self.visit_right.fill(False)\n        self.slack_right.fill(numpy.inf)\n        for i in range(self.n):\n            if self.match_left[i] == -1:\n                if self.find_path(i):\n                    break\n        else:\n            break\n        for j in range(self.n):\n            if self.slack_right[j] == 0:\n                continue\n            self.label_right[j] -= self.slack_right[j]\n            for i in range(self.n):\n                self.adj_matrix[i, j] += self.slack_right[j]\n\n    return self.match_right", "CodeBleu_score": 31.506721743716152}, {"code": "def KM(self)\n\twhile True:\n        for i in range(self.n):\n            self.slack_left[i] = self.slack_right[i] = numpy.inf\n            self.visit_left[i] = self.visit_right[i] = False\n        for i in range(self.n):\n            if self.match_left[i] == -1 and self.find_path(i):\n                break\n        else:\n            return self.match_right\n        for j in range(self.n):\n            if self.slack_right[j] == numpy.inf:\n                continue\n            for i in range(self.n):\n                if self.slack_left[i] == numpy.inf:\n                    continue\n                self.adj_matrix[i, j] -= self.slack_left[i] + self.slack_right[j]\n            self.label_left += self.slack_left\n            self.label_right += self.slack_right\n\n", "CodeBleu_score": 30.911602837584596}, {"code": "def KM(self)\n\twhile True:\n        for i in range(self.n_left):\n            self.slack_right = numpy.array([0] * self.n_right)\n            self.visit_left = numpy.array([False] * self.n_left)\n            self.visit_right = numpy.array([False] * self.n_right)\n            if self.find_path(i):\n                break\n        else:\n            break\n        for j in range(self.n_right):\n            if not self.visit_right[j]:\n                self.label_right[j] += self.slack_right[j]\n                for i in range(self.n_left):\n                    self.label_left[i] -= self.slack_right[j]\n    return self.match_right\n\n", "CodeBleu_score": 29.107131386711256}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t# Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Create a mask for the color \"yellow\"\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t# Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Define lower and upper boundaries of yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # Create a mask of yellow color within the image\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t# Convert image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the HSV range for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\tstd::string tagId = tagDescription.getId();\n    std::map<std::string, TagDescription>::iterator it = standalone_tag_descriptions_.find(tagId);\n    if (it != standalone_tag_descriptions_.end()) {\n        descriptionContainer = it->second;\n        return true;\n    }\n    else {\n        if (printWarning) {\n            ROS_WARN_THROTTLE(1.0, \"Could not find tag description with ID '%s'\", tagId.c_str());\n        }\n        return false;\n    }\n}", "CodeBleu_score": 43.432550875204925}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tTagDescriptionContainer& descriptionContainer,\n    const TagDescriptionId& id,\n    const bool printWarning = true) {\n    // Check the standalone_tag_descriptions_ map for the given ID.\n    auto descriptionIterator = standalone_tag_descriptions_.find(id);\n\n    // If the description is not found and printWarning is true, log a warning message.\n    if (descriptionIterator == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            ROS_WARN_THROTTLE(1, \"TagDetector: Standalone tag description with ID %s not found.\", id.c_str());\n        }\n\n        return false;\n    }\n\n    // If found, set the descriptionContainer to the tag's description and return true.\n    descriptionContainer = descriptionIterator->second;\n\n    return true;\n}", "CodeBleu_score": 55.98160975735718}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t// Check if the description is in the map\n    auto it = standalone_tag_descriptions_.find(id);\n    if (it != standalone_tag_descriptions_.end()) {\n        // Found it\n        descriptionContainer = it->second;\n        return true;\n    }\n    // Not found\n    if (printWarning) {\n        ROS_WARN_THROTTLE(1.0, \"Could not find standalone tag description with ID %d\", id);\n    }\n    return false;\n}", "CodeBleu_score": 38.071494969297824}]}
